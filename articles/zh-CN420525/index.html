<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 🏀 👈🏽 网络最老练。 第十五部分。 服务质量 ㊗️ 🐽 🔴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SDSM-15。 关于QoS。 现在有了拉取请求的可能性。 

 因此，我们进入了QoS的主题。 

 您知道为什么现在才为什么，为什么它将成为整个SDSM课程的结尾文章？ 因为QoS非常复杂。 周期中最难的事情。 

 这不是一种神奇的存档器，它可以巧妙地动态压缩流量并将您的千兆位推入一百兆位的上...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>网络最老练。 第十五部分。 服务质量</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420525/">  SDSM-15。 关于QoS。 现在有了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拉取请求</a>的可能性。 <br><br> 因此，我们进入了QoS的主题。 <br><br> 您知道为什么现在才为什么，为什么它将成为整个SDSM课程的结尾文章？ 因为QoS非常复杂。 周期中最难的事情。 <br><br> 这不是一种神奇的存档器，它可以巧妙地动态压缩流量并将您的千兆位推入一百兆位的上行链路。  QoS是关于如何牺牲不必要的东西，将不可食用的东西推入允许的框架中。 <br><br>  QoS与萨满主义和不可访问性的光环交织在一起，以至于所有年轻的工程师（不仅是工程师）都试图谨慎地忽略它的存在，认为这足以引发金钱问题，并不断扩大联系。 没错，直到他们意识到采用这种方法之前，失败将不可避免地等待着他们。 企业要么开始问一些不舒服的问题，要么会出现很多与通道宽度几乎不相关的问题，而直接取决于其使用效率。 是的，VoIP积极地在幕后挥舞着笔，组播流量恶意地抚摸着您。 <br><br> 因此，让我们意识到QoS是强制性的，您将不得不以某种方式知道它，并且由于某种原因，现在不要在轻松的氛围中开始。 <br><br><img src="https://habrastorage.org/webt/sc/of/k6/scofk6lx2y49bzisp0pwsnrsywg.jpeg"><a name="habracut"></a><br><hr><br><h1> 目录内容 </h1><br>  1. <b>决定QoS的因素是什么？</b> <br><br><ul><li> 损失 </li><li> 延误 </li><li> 抖动 </li></ul><br>  2. <b>三种QoS模型</b> <br><br><ul><li> 最佳效果 </li><li> 综合服务 </li><li> 差异化服务 </li></ul><br>  3. <b>DiffServ机制</b> <br><br>  4. <b>分类和标签</b> <br><br><ul><li> 行为汇总 </li><li> 多领域 </li><li> 基于接口 </li></ul><br>  5. <b>队列</b> <br><br>  6. <b>避免拥塞</b> <br><br><ul><li> 尾巴和头部掉落 </li><li> 红色的 </li><li> 丝线 </li></ul><br>  7. <b>拥塞管理</b> <br><br><ul><li> 先进先出 </li><li> 优先排队 </li><li> 公平排队 </li><li> 轮循 </li></ul><br>  8. <b>速度限制</b> <br><br><ul><li> 塑形 </li><li> 警务 </li><li> 漏斗和令牌桶 </li></ul><br>  9. <b>QoS的硬件实现</b> <br><hr><br><blockquote> 在读者深入研究这个漏洞之前，我将在其中进行三个设置： <br><br><ul><li> 扩展频段并不能解决所有问题。 </li><li>  QoS不会扩展带宽。 </li><li> 有关管理有限资源的QoS。 </li></ul></blockquote><br><h1>  1.决定QoS的因素是什么？ </h1><br> 企业希望网络堆栈能够很好地执行其简单功能-将比特流从一台主机传输到另一台主机：无损且在可预测的时间内。 <br><br> 从这个简短的句子中，可以得出所有网络质量指标： <br><br><ul><li> 损失 </li><li> 延误 </li><li> 抖动 </li></ul><br> 这三个特征决定了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">质量，而与网络</a>的性质无关：数据包，信道，IP，MPLS，无线电， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">鸽子</a> 。 <br><br><h2> 损失 </h2><br> 此度量标准告诉您源发送的数据包中有多少到达目的地。 <br> 丢失的原因可能是接口/电缆出现问题，网络拥塞，阻止ACL规则的位错误。 <br><br> 如果丢失，该怎么办由应用程序决定。 它可以忽略它们，就像在电话交谈中那样，不再需要延迟的数据包，或者重新发送它-TCP这样做是为了确保源数据的准确传递。 <br><br><img src="https://habrastorage.org/webt/s9/vc/jj/s9vcjjwjb494cyrx19oby8ykvms.png" width="600"><br><br> 如果不可避免，如何在拥塞管理一章中管理损失。 <br><br> 如何利用拥塞预防一章中的损失。 <br><br><h2> 延误 </h2><br> 这是数据需要从源到目标的时间。 <br><br><img src="https://habrastorage.org/webt/m6/xo/qa/m6xoqapl9y6v422k8c4d--xtmvm.png" width="600"><br><br> 累积延迟由以下部分组成。 <br><br><ul><li>  <b>序列化延迟</b> -节点将数据包分解为比特并放入到下一个节点的链接所<b>花费</b>的时间。 它由接口的速度决定。 因此，例如，通过100 Mb / s的接口传输大小为1500字节的数据包将花费0.0001 s，而花费56 Kb / s-0.2 s。 </li><li>  <b>传播延迟</b>是臭名昭著的电磁波传播速度限制的结果。 物理学不允许您以30毫秒（实际上是70毫秒）的速度从纽约到达托木斯克。 </li><li>  <b>QoS引入的延迟</b>是队列中数据包的减弱（ <b>排队延迟</b> ）和整形的后果（ <b>整形延迟</b> ）。 今天，我们将在“速度控制”一章中对此进行大量讨论。 </li><li>  <b>处理数据包的</b> <b>延迟</b> （ <b>Processing Delay</b> ）-决定<b>处理数据包</b>的时间：查找，ACL，NAT，DPI-并将其从输入接口传递到输出。 但是在瞻博网络在其M40中将控制和数据平面分开的那天，可以忽略处理延迟。 </li></ul><br> 对于不需要匆忙的应用程序，延迟并不是那么严重：文件共享，浏览，VoD，Internet广播电台等。 相反，它们对于交互操作非常重要：在电话交谈过程中，200毫秒的耳朵已经令人不快。 <br><br> 与<b>RTT</b> （ <b>往返时间</b> ）不同义的与延迟相关的术语是往返。 在ping和跟踪时，您可以看到完全是RTT，而不是单向延迟，尽管这些值具有相关性。 <br><br><h2> 抖动 </h2><br> 连续数据包的传送之间的延迟差异称为抖动。 <br><br><img src="https://habrastorage.org/webt/hv/-j/9z/hv-j9zu-h0eyuzkf9eaupcputhe.png" width="600"><br><br> 像延迟一样，抖动对许多应用程序都无关紧要。 甚至看起来，有什么区别-包装已经交付，还有什么呢？ <br><br> 但是，对于交互式服务而言，这一点很重要。 <br><br> 以相同的电话为例。 实际上，它是模拟信号的数字化，分为多个单独的数据块。 输出是相当统一的数据包流。 在接收侧，有一个固定大小的小缓冲区，顺序到达的数据包可放入其中。 为了恢复模拟信号，需要一定数量的模拟信号。 在浮动延迟的情况下，下一个数据块可能无法按时到达，这相当于丢失，并且信号无法恢复。 <br><br> 延迟可变性的最大贡献就是QoS。 在“速度限制”一章中，这也很繁琐。 <br><br><hr><br> 这是网络质量的三个主要特征，但还有两个也起着重要作用。 <br><br><h2> 随机发货 </h2><br> 当数据包以错误的发送顺序到达接收方时，诸如电话， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NAS</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CES</a>等许多应用程序对数据包的随机传送极为敏感。 这可能导致连接断开，错误，文件系统损坏。 <br><br> 尽管随机传送不是正式的QoS功能，但它绝对是指网络质量。 <br><br> 即使TCP可以容忍此类问题，也会出现重复的ACK和重传。 <br><br><img src="https://habrastorage.org/webt/yu/51/63/yu5163hdbesjbypr34w4w5puhbo.png" width="600"><br><br><h2> 频宽 </h2><br> 不能将其区分为网络质量的度量标准，因为实际上它的缺点导致了上述三个方面。 但是，在我们的现实中，当应保证对某些应用程序使用它，或者相反，应按合同对其进行限制时，例如，MPLS TE在整个LSP中保留它，至少值得一提，至少作为一个弱指标。 <br> 速度控制机制将在“速度限制”一章中进行讨论。 <br><br><hr><br> 为什么规格会变坏？ <br><br> 因此，我们从一个非常原始的想法开始，即网络设备（无论是交换机，路由器，防火墙还是其他设备）只是一条称为通信通道的管道，与铜线或光缆相同。 <br><br><img src="https://habrastorage.org/webt/r2/yh/hr/r2yhhr2urldnn3t6mqhhk6erz-u.png" width="600"><br><br> 然后，所有数据包都以它们到达的相同顺序飞过，并且没有任何额外的延迟-无处可去。 <br><br> 但是实际上，每个路由器都会从信号中还原位和数据包，对它们进行一些处理（我们尚未考虑），然后将数据包转换回信号。 <br><br> 出现序列化延迟。 但是总的来说，这并不可怕，因为它是恒定的。 只要输出接口的宽度大于输入的宽度就不会令人恐惧。 <br><br> 例如，在设备的入口处是一个千兆端口，在输出处是一个620 Mb / s的无线电中继线连接到同一个千兆端口？ <br><br> 没有人会通过正式的千兆链路千兆流量禁止子弹。 <br> 无需执行任何操作-380 Mb / s会溅到地板上。 <br><br> 他们在这里-损失。 <br><br> 但与此同时，我非常希望摆脱最糟糕的部分-来自youtube的视频，并且执行董事与工厂董事之间的电话交谈不会被打断，甚至不会崩溃。 <br><br> 我希望声音有专线。 <br><br> 或者有五个输入接口，但有一个输出，并且同时有五个节点开始尝试向一个接收者注入流量。 <br><br> 添加少量VoIP理论（一篇没人写过的文章）-它对延迟及其变化非常敏感。 <br><br> 如果对于来自youtube的TCP视频流（在撰写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QUIC</a>文章时-仍在进行实验），由于缓冲而造成的延迟（即使是几秒钟）完全不值钱，那么在与堪察加进行首次此类对话后，导演将致电技术部门主管。 <br> 在较早的时期，当自行车的作者仍在晚上做作业时，问题特别严重。 调制解调器连接的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">速度为56k</a> 。 <br><br> 当1.5K数据包进入这种连接时，它将占用整个线路200毫秒。 此刻没有人可以通过。 有声音吗 不，我没有听到。 <br><br> 因此，MTU问题非常重要-程序包不应占用接口太长时间。 速度越慢，所需的MTU越低。 <br><br> 他们在这里-延迟。 <br><br> 现在，该频道是免费的，并且延迟很短，一秒钟后有人开始下载大文件，延迟增加了。 他在这里-紧张不安。 <br><br> 因此，有必要使语音数据包以最小的延迟通过管道，而youtube将等待。 <br><br> 可用620 Mb / s用于语音，视频以及购买VPN的B2B客户。 我希望一种流量不会压制另一种流量，因此我们需要一个频带保证。 <br><br><hr><br> 关于网络的性质，所有上述特征都是通用的。 但是，提供它们有三种不同的方法。 <br><br><h1>  2.三种QoS模型 </h1><br><ul><li> 尽力而为-不保证质量。 所有人都是平等的。 </li><li>  IntServ是每个流的质量保证。 从源到目标保留资源。 </li><li>  DiffServ-没有保留。 每个节点本身确定如何确保正确的质量。 </li></ul><br><h2> 尽力而为（BE） </h2><br>  <i>没有保证。</i> <br><br> 实施QoS的最简单方法，从IP网络开始并一直沿用至今，有时是因为这样就足够了，但更多时候是因为没人考虑QoS。 <br><br> 顺便说一句，当您将流量发送到Internet时，它将作为BestEffort进行处理。 因此，通过在Internet上滚动的VPN（与提供商所提供的VPN相对），重要的通信量（例如电话对话）可能不会很自信。 <br><br> 在BE的情况下，所有流量类别都是相同的；任何优先级均不优先。 因此，不能保证任何延迟/抖动或频带。 <br><br> 这种方法的名称有点误会，即“尽力而为”（Best Effort），新来者用“ best”一词误导了它。 <br><br> 但是，“我将尽我所能”一词意味着演讲者将尽一切可能但不保证任何事情。 <br><br> 实施BE不需要任何操作-这是默认行为。 它制造便宜，员工不需要深入的专业知识，在这种情况下，QoS无法定制。 <br><br> 但是，这种简单性和静态性不会导致“尽力而为”方法未在任何地方使用的事实。 它可用于具有高带宽且不存在拥塞和突发的网络中。 <br><br> 例如，在跨大陆线路或某些没有超额预订的数据中心的网络中。 <br> 换句话说，在没有拥塞且不需要以任何特殊方式关联任何流量（例如电话）的网络中，BE是非常合适的。 <br><br><h2> 互动 </h2><br>  <i>预先为从源到目的地的整个流程预留资源。</i> <br><br>  MIT，Xerox和ISI网络之父决定将可预测性元素添加到不断增长的随机互联网中，同时保持其可操作性和灵活性。 <br><br> 因此，在1994年，IntServ的想法应运而生，以响应实时流量的快速增长和组播的发展。 然后将其简化为IS。 <br><br> 该名称反映了在同一网络中希望同时为实时和非实时流量类型提供服务的愿望，并通过预留频段来提供使用资源的第一优先权。 能够重用每个人都能赚钱的频段，并保留了IP拍摄的能力。 <br><br> 备份任务已分配给RSVP协议，该协议为<b>每个</b>流在<b>每个</b>网络设备上保留一个频段。 <br><br> 粗略地讲，在设置单速率三色MarkerP会话或开始数据交换之前，最终主机会以所需的带宽发送RSVP路径。 如果两个人都返回了RSVP Resv，则他们可以开始交流。 同时，如果没有可用资源，则RSVP将返回错误，并且主机将无法通信或无法使用BE。 <br><br> 现在让最勇敢的读者想象一下，将为当今Internet上的<b>任何</b>流预先发送一个频道信号。 考虑到这要求<b>每个</b>传输节点的CPU和内存成本不为零，并将实际交互延迟一段时间，因此很清楚为什么IntServ变成了一个几乎死命的想法-零可伸缩性。 <br><br> 从某种意义上讲，IntServ的现代化身是带有TEVP标记版本的MPLS TE-RSVP TE。 尽管这里当然不是端到端的，也不是按流的。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 1633中</a>描述了IntServ。 <br> 从原则上讲，该文档很好地评估了您在预测中的天真性。 <br><br><h2> 区分服务 </h2><br>  <i>DiffServ很复杂。</i> <br><br>  90年代末期，当端到端IntServ IP方法失败时，IETF召集了差异化服务工作组，该工作组对新QoS模型提出了以下要求： <br><br><ul><li> 没有信号（Adjos，RSVP！）。 </li><li> 基于总流量分类，而不是关注流量，客户等。 </li><li> 它具有一组有限的确定性操作，用于处理类的数据流量。 </li></ul><br> 结果，标志性的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 2474</a> （ <i>IPv4和IPv6标头中的“区分服务字段”（DS字段）的定义</i> ）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 2475</a> （ <i>“区分服务的体系结构”</i> ）诞生了。 <br><br> 进一步，我们将仅讨论DiffServ。 <br><br><blockquote> 值得注意的是，名称DiffServ并不是IntServ的对立面。 它反映出我们区分了各种应用程序提供的服务，或者说它们的流量，换句话说，我们共享/区分了这些类型的流量。 <br>  IntServ的作用相同-区分在同一网络上传输的流量BE和实时流量的类型。 和：IntServ和DiffServ都-区分服务的方式。 </blockquote><br><hr><br><h1>  3. DiffServ机制 </h1><br> 什么是DiffServ？为什么它击败了IntServ？ <br><br> 如果非常简单，则将流量分为几类。 对每个节点入口处的软件包进行分类，并对其应用一组工具，该工具以不同的方式处理不同类别的软件包，从而为它们提供不同的服务级别。 <br><br> 但这<a href="">不会</a> 。 <br><br>  DiffServ的核心是经验丰富的IP IP <b>PHB</b>概念<b>-每跳行为</b> 。 业务路径上的每个节点都根据其报头独立地决定如何相对于传入数据包进行操作。 <br><br> 分组路由器的动作称为行为模型。 这样的模型的数量是确定性的并且是有限的。 在不同的设备上，针对相同流量的行为模型<i>可能会</i>有所不同，因此它们是逐跳的。 <br><br>  <i>我将在本文中将<b>Behavior</b>和<b>PHB</b>的概念用作同义词。</i> <br><blockquote> 有点混乱。  PHB一方面是每个节点的独立行为的一般概念，另一方面是特定节点上的特定模型。 有了这个，我们会解决的。 <br></blockquote><img src="https://habrastorage.org/webt/8w/jq/kq/8wjqkqc9e4jwrm1lokdaahlnod8.png" width="600"><br><br> 行为模型由一组工具及其参数确定：警务，丢弃，排队，调度，整形。 <br><br> 使用可用的行为模型，网络可以提供各种服务<b>类别（Service Class</b> ）。 <br><br> 也就是说，通过将不同的PHB应用于流量，不同类别的流量可以在网络上接收不同级别的服务。 <br><br> 因此，首先，您需要确定服务流量指的是- <b>分类</b> 。 <br><br> 每个节点独立地对输入的数据包进行分类。 <br><br><img src="https://habrastorage.org/webt/_o/lp/jm/_olpjmv8pc3bclzzg9qtvh1_vke.png" width="700"><br><br> 分类后，将进行测量（ <b>计数</b> ）-此类流量的多少位/字节已到达路由器。 <br><br> 根据结果​​，可以对包裹进行涂漆（ <b>着色</b> ）：绿色（在确定的限制范围内），黄色（在限制范围之外），红色（完全被海岸包围）。 <br><br><img src="https://habrastorage.org/webt/3h/6g/xi/3h6gxiq2g_7lejnvonvxtft9pys.png" width="700"><br><br> 如有必要，则进行<b>警务</b>处理（对这样的描图纸很抱歉，有一个更好的选择-写，我会改变）。 基于数据包颜色的抛光器为数据包分配一个操作-传输，丢弃或重新标记。 <br><br><img src="https://habrastorage.org/webt/ft/gk/2k/ftgk2klys-yvgdicuzs1i8zg3lo.png" width="700"><br><br> 之后，数据包应落入队列之一（ <b>Quueing</b> ）。 为每个服务类分配一个单独的队列，这使它们可以使用不同的PHB进行区分。 <br><br> 但是即使在数据包进入队列之前，如果队列已满，也可以将其丢弃（ <b>Dropper</b> ）。 <br><br> 如果为绿色，则它将通过；如果为黄色，则如果行已满，并且如果红色肯定是自杀炸弹袭击者，则很可能将其丢弃。 有条件地，丢弃的可能性取决于数据包的颜色和将要到达的队列的满度。 <br><br><img src="https://habrastorage.org/webt/er/q2/ks/erq2ksivfaq7yj2gch6ihcbezts.png" width="700"><br><br> 在队列出口处， <b>Shaper</b>起作用，其任务与polyser的任务非常相似-将流量限制为给定值。 <br><br> 您可以为单个队列甚至在队列内配置任意成形器。 <br> 关于“速度限制”一章中的成形器和聚合器之间的区别。 <br><br> 所有队列最终都应合并为一个输出接口。 <br><br> 记住在路上8条车道合并为3条车的情况。如果没有交通管制员，这将变成混乱。 如果我们具有与输入相同的输出，则依次分隔将没有意义。 <br><br> 因此，有一个特殊的调度程序（ <b>Scheduler</b> ），该调度<b>程序</b>周期性地从不同队列中取出数据包，并将其发送到接口（ <b>Scheduling</b> ）。 <br><br> 实际上，一组队列和一个调度程序的组合是最重要的QoS机制，它允许您将不同的规则应用于不同的流量类别，一个提供较宽的带宽，另一个提供较低的延迟，第三种是没有丢弃。 <br><br> 然后，数据包已经到达接口，在该接口处，数据包被转换为比特流-序列化（ <b>Serialization</b> ），然后转换为环境信号。 <br><br><img src="https://habrastorage.org/webt/dy/i2/pk/dyi2pkpat1havyiz3ps3dmret-y.png" width="700"><br><br> 在DiffServ中，每个节点的行为都独立于其他节点；没有信令协议可以指示网络上哪个QoS策略。 同时，我希望在网络内部以相同的方式处理流量。 如果只有一个节点的行为有所不同，则整个QoS策略将不堪重负。 <br><br> 为此，首先，在所有路由器上为其配置相同的类别和PHB，其次，使用数据包的<b>标记</b> -属于特定类别<b>的</b>数据包记录在报头（IP，MPLS，802.1q）中。 <br><br>  DiffServ的优点在于，下一个节点可以依靠此标签进行分类。 <br><br> 在这种信任区域中，将应用相同的流量分类规则和相同的行为，称为DiffServ域（ <b>DiffServ-Domain</b> ）。 <br><br><img src="https://habrastorage.org/webt/8o/7d/ex/8o7dexwfq0xawzyhsuix7-viewi.png" width="700"><br><br> 因此，在DiffServ域的入口处，我们可以基于5元组或接口对包进行分类，并根据域的规则对其进行标记（ <b>Remark / Rewrite</b> ），其他节点将信任该标记，而无需进行复杂的分类。 <br> 也就是说，DiffServ中没有显式的信令，但是节点可以告诉以下所有对象，该包需要提供哪个类，以等待其被信任。 <br><br> 在DiffServ域之间的交界处，您需要协商QoS策略（或不协商）。 <br><br> 整个图片如下所示： <br><br><img src="https://habrastorage.org/webt/_-/7v/nt/_-7vntuvn9r1ugem7yenmxoj9fw.png" width="1000"><br><blockquote> 为了清楚起见，我将给出一个现实生活中的类似物。 <br> 乘飞机飞行（不是胜利）。 <br> 服务分为三类（CoS）：经济，业务，第一。 <br> 购买机票时，会进行分类-乘客会根据价格获得某种服务等级。 <br> 在机场上有一个标记（备注）-发出表明等级的机票。 <br> 有两种行为（PHB）：尽力而为和高级。 <br> 有一些机制可以实现这种行为：普通的候诊室或VIP休息室，小巴或共用公共汽车，舒适的大座位或紧排的座位，每位乘务员的乘客人数，点酒的能力。 <br> 根据班级，将行为模型分配给-尽力而为型经济，给企业-高级基础，再分配给第一-高级SUPER-POWER-NINJA-TURBO-NEO-ULTRA-HYPER-MEGA-MULTI-ALPHA-META-EXTRA-UBER-PREFIX！ <br> 同时，两种溢价有所不同，一种溢价是半甜的，另一种溢价是无限的百加得。 <br><br> 然后，到达机场后，每个人都穿过一扇门。 那些试图携带武器或没有票的人是不允许的（丢弃）。 商业和经济进入不同的候诊室和不同的交通方式（排队）。 首先，他们让头等舱登机，然后是商务，然后是经济舱（计划），但随后他们都乘坐一架飞机（界面）飞往目的地。 <br><br> 在同一示例中，飞机上的飞行是传播延迟，着陆是序列化延迟，在大厅中等待飞机的队列是排队，而护照控制是处理中。 请注意，此处的处理延迟通常在总时间方面可以忽略不计。 <br><br> 下一个机场可以用完全不同的方式来应对旅客-它的PHB是不同的。 但是同时，如果乘客不更换航空公司，那么对他的态度很可能不会改变，因为一家公司是一个DiffServ域。 <br></blockquote> 您可能已经注意到，DiffServ非常（或无限）复杂。 但是，我们将分析上述所有内容。 同时，在本文中，我将不涉及物理实现的细微差别（即使在同一路由器的两个板上，它们也可能有所不同），也不会谈论HQoS和MPLS DS-TE。 <br><br> 进入了解QoS技术的工程师圈子的门槛比路由协议，MPLS或Radya，STP宽恕得多。 <br><br> 尽管如此，DiffServ已获得全球网络的认可和实施，因为正如他们所说的那样，它具有高度的可扩展性。 <br><br> 在本文的其余部分中，我将仅分析DiffServ。 <br><br> 下面我们将分析图中所示的所有工具和过程。 <br><br><img src="https://habrastorage.org/webt/qb/21/kg/qb21kgaqnsm6-pi2qwe0rdniqq4.png" width="600"><br><br><hr><br> 在扩展主题的过程中，我将在实践中展示一些东西。 <br> 我们将与这样的网络合作： <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br>  Trisolarans是具有两个连接点的linkmeup提供程序客户端。 <br><br> 黄色区域是Linkmeup网络的DiffServ域，其中有效的是单个QoS策略。 <br>  Linkmeup_R1是由提供商管理的CPE设备，因此位于受信任的区域中。 随之而来的是OSPF，并且通过干净的IP进行交互。 <br><br> 网络的核心是带有L3VPN的MPLS + LDP + MP-BGP，从Linkmeup_R2延伸到Linkmeup_R4。 <br> 我将在必要时提供所有其他评论。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">初始配置文件</a> 。 <br><br><hr><br><h1>  4.分类和标签 </h1><br> 在他的网络中，管理员定义了他可以提供流量的服务类别。 <br><br> 因此，每个节点在接收到数据包时要做的第一件事就是对其进行分类。 <br><br> 有三种方法： <br><br><ol><li>  <b>行为汇总</b> （ <b>BA</b> ） <br> 只需信任其标头中的现有包装标签即可。 例如，IP DSCP字段。 <br> 之所以这样称呼，是因为在DSCP字段中的同一标签下，汇总了各种流量类别，这些流量类别期望针对自己的行为相同。 例如，所有SIP会话都将汇总到一个类中。 <br><br> 可能的服务类别的数量以及行为方式均受到限制。 因此，不可能为每个类别（甚至对于流而言，甚至更多）都分配一个单独的类-必须进行汇总。 </li><li>  <b>基于接口</b> <br> 特定接口上的所有内容都应放在一个流量类别中。 例如，我们确定数据库服务器已连接到该端口，仅此而已。 并在另一个员工工作站中。 </li><li>  <b>多场</b> （ <b>MF</b> ） <br> 分析数据包头字段-IP地址，端口，MAC地址。 一般来说，任意字段。 <br><br> 例如，所有到达端口5000上的10.127.721.0/24子网的流量都需要标记为流量，这有条件地要求使用第5类服务。 </li></ol><br> 管理员确定网络可以提供的服务类别集，并为它们映射一些数字值。 <br><br> 在DS域的入口处，我们不信任任何人，因此以第二种或第三种方式进行分类：根据地址，协议或接口，确定服务等级和相应的数字值。 <br><br> 在第一个节点的出口处，此数字被编码在IP头的DSCP字段（或流量类别的另一个字段：MPLS流量类别，IPv6流量类别，以太网802.1p）中-发生注释。 <br><br> 通常在DS域中信任此标签，因此，传输节点使用第一种分类方法（BA）-最简单的方法。 无需复杂的标题分析，只需查看记录的数字即可。 <br><br> 如上所述，在两个域的交界处，您可以基于接口或MF进行分类，也可以信任带有保留的BA标记。 <br><br> 例如，信任除6和7以外的所有值，然后将6和7重新分配给5。 <br><br> 当提供者连接具有其自己的标签策略的法人实体时，这种情况是可能的。 提供者不介意保存它，但不希望流量属于接收网络协议数据包的类别。 <br><br><img src="https://habrastorage.org/webt/8o/7d/ex/8o7dexwfq0xawzyhsuix7-viewi.png" width="900"><br><br><h2> 行为汇总 </h2><br>  BA使用非常简单的分类-我看到一个数字-我了解该类。 <br> 那么数字是多少？ 并记录在哪个领域？ <br><br><ul><li>  IPv6流量类别 </li><li>  MPLS流量类别 </li><li> 以太网802.1p </li></ul><br> 分类主要基于换向标题。 <br><br>  <i>我称呼一个通勤报头，设备根据此报文确定将数据包发送到哪里，以便它更接近接收者。</i> <br> 也就是说，如果IP数据包到达路由器，则会分析IP头和DSCP字段。 如果MPLS到达，则将其解析-MPLS流量类。 <br><br> 如果以太网+ VLAN + MPLS + IP数据包到达常规的L2交换机，则将分析802.1p（尽管可以更改）。 <br><br><h3>  IPv4服务条款 </h3><br>  QoS字段与IP一样精确地伴随着我们。 八位TOS字段-服务类型-应该带有数据包的优先级。 <br><br> 甚至在DiffServ出现之前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 791</a> （ <i>INTERNET PROTOCOL</i> ）就描述了如下字段： <br><br>  IP优先级（IPP）+ DTR + 00。 <br><br><img src="https://habrastorage.org/webt/fw/fe/of/fwfeofy_xr9dbft1vbap2djoszm.png" width="700"><br><br> 也就是说，数据包的优先级依次提高，然后是延迟，吞吐量，可靠性的精确度位（0-不要求，1-要求）。 <br><br> 最后两位必须为零。 <br><br><div class="spoiler">  <b class="spoiler_title">优先级确定以下值...</b> <div class="spoiler_text">  111-网络控制 <br>  110-互联网控制 <br>  101-评论/ ECP <br>  100-闪存覆盖 <br>  011-闪光灯 <br>  010-立即发货 <br>  001-优先 <br>  000-例行 <br></div></div><br> 稍后在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 1349</a> （ <i>Internet协议套件中的服务类型</i> ）中，对TOS字段进行了稍微的重新定义： <br><br><img src="https://habrastorage.org/webt/95/dz/pm/95dzpm400ckireeowdta1q_7lvg.png" width="700"><br><br> 剩下的三位保留IP优先级，在添加Cost位后，剩下的四位变为TOS。 <br><br> 以下是读取这些TOS位中单位的方法： <br><br><ul><li>  D-“最小化延迟”， </li><li>  T-“最大化<b>t</b>通量”， </li><li>  R-“最大化可靠性”， </li><li>  C-“最小化成本”。 </li></ul><br> 朦胧的描述并没有促进这种方法的普及。 <br><br> 整个路径上没有系统的QoS方法，也没有关于如何使用优先级字段的明确建议，对延迟，吞吐量和可靠性位的描述非常模糊。 <br><br> 因此，在DiffServ的上下文中，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 2474</a> （ <i>IPv4和IPv6标头中的区分服务字段（DS字段）的</i>定义）中再次重新定义了TOS字段： <br><br><img src="https://habrastorage.org/webt/n_/ie/zm/n_iezmmdhv2tg7qlbxqad7c_4_m.png" width="700"><br><br> 代替了IPP和DTRC位，引入了六位字段DSCP- <b>区分服务代码点</b> ，未使用两个正确的位。 <br><br> 从那时起，应该是DSCP字段成为DiffServ的主要标记：在其中写入了某个值（代码），该值在DS域中表征了程序包所需的特定服务类别及其丢弃优先级。 这是同一个人。 <br><br> 管理员可以视需要使用DSCP的所有6位，最多共享64个服务类。 <br><br> 但是，为了与IP优先级兼容，他们保留了前三位的类选择器的作用。 <br><br> 也就是说，与IPP一样，Class Selector的3位允许您定义8个类别。 <br><br><img src="https://habrastorage.org/webt/fw/vl/p0/fwvlp0wanilpj7_lrp8bxj7blqe.png" width="700"><br><br> 但是，这仅是一种安排，即在其DS域的限制内，管理员可以根据自己的判断轻松地忽略并使用所有6位。 <br><br> 此外，我还注意到，根据IETF的建议，CS中记录的值越高，对该服务的流量要求越高。 <br><br> 但这不应被视为不可否认的真理。 <br><br> 如果前三位定义了流量类别，则后三位用于指示数据包丢弃优先级（ <b>丢弃优先级</b>或<b>数据包丢失优先级-PLP</b> ）。 <br><blockquote> 八堂课-是很多还是一点？ 乍看之下，这还远远不够-毕竟，网络上存在许多不同的流量，因此人们希望按类别区分每种协议。 但是，事实证明，对于所有可能的情况，八个就足够了。 <br> 对于每个类，您都需要定义一个将以不同于其他类的方式处理它的PHB。 <br> 随着除数的增加，股息（资源）不会增加。 <br> 我没有在谈论它们描述的流量类别的确切值，因为没有标准，您可以自行决定正式使用它们。 下面我将告诉您推荐哪些类及其对应的值。 <br></blockquote><div class="spoiler">  <b class="spoiler_title">ECN位...</b> <div class="spoiler_text"> 两位ECN字段仅出现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 3168</a> （ <i>显式拥塞通知</i> ）中。 定义该字段的目的是明确通知最终主机此过程中有人正在发生拥塞。 <br> 例如，当数据包在路由器队列中长时间延迟并填充（例如，由85％填充）时，它将更改ECN值，告知最终主机需要降低的速度-类似于以太网上的暂停帧。 <br><br> 在这种情况下，发送方必须降低传输速率并减少受灾节点的负载。 <br><br> 同时，从理论上讲，不需要所有传输节点对该字段的支持。 也就是说，使用ECN不会破坏不支持它的网络。 <br><br> 目标是好的，但是在生命周期中未特别发现ECN。 如今，超大型和超大型机对这两个比特产生了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新的兴趣</a> 。 <br><br>  ECN是下面描述的拥塞避免机制之一。 <br></div></div><br><hr><br><h4>  DSCP分类实践 </h4><br> 一点练习也没有什么坏处。 <br><br> 该方案是相同的。 <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br> 要开始使用，只需发送一个ICMP请求： <br><br><pre><code class="hljs pgsql">Linkmeup_R1#ping ip <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> source <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">escape</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>. Sending <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-byte ICMP Echos <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>, timeout <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> seconds: Packet sent <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a source address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> !!!!! Success rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> percent (<span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span>), round-trip min/avg/max = <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span> ms</code> </pre> <br>  <i>Linkmeup_R1。</i>  <i>E0 / 0。</i> <br><br><img src="https://habrastorage.org/webt/6g/zl/lp/6gzllpyfrbtsvqjd3sqn-rljc8g.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br> 现在设置了DSCP值。 <br><br><pre> <code class="hljs pgsql"> Linkmeup_R1#ping ip <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> source <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> tos <span class="hljs-number"><span class="hljs-number">184</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">escape</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>. Sending <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-byte ICMP Echos <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>, timeout <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> seconds: Packet sent <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a source address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> !!!!! Success rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> percent (<span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span>), round-trip min/avg/max = <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span> ms</code> </pre> <br> 值184是二进制10111000的十进制表示形式。其中，前6位是101110，即十进制46，这是EF类。 <br><br><div class="spoiler">  <b class="spoiler_title">方便popingushki的标准TOS值表...</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/z5/fx/ij/z5fxijhtpv24gndpefezlypbdju.png" width="500"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多细节</a></i> <br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IETF建议书</a>一章的文字下面<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>我将告诉您这些数字和名称的来源。 <br></div></div><br>  <i>Linkmeup_R2。</i>  <i>E0 / 0</i> <br><br><img src="https://habrastorage.org/webt/y_/fn/gn/y_fngnyvicccbvsesftdw5lawrc.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br> 一个奇怪的提示：ICMP Echo回复中pingushka的目的地设置了与Echo Request中相同的类值。 这是合乎逻辑的-如果发件人发送了具有特定重要性级别的数据包，那么显然他希望收到保证回送的数据包。 <br><br>  <i>Linkmeup_R2。</i>  <i>E0 / 0</i> <br><br><img src="https://habrastorage.org/webt/wk/uu/ea/wkuueaujq2oqgrgd6cu960kqezu.png" width="600"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DSCP分类配置文件。</a> <br><br><h3>  IPv6流量类别 </h3><br>  IPv6在QoS方面与IPv4并无太大不同。 八位字段称为流量类别，也分为两部分。 前6位（DSCP）的作用完全相同。 <br><br><img src="https://habrastorage.org/webt/cu/xd/nf/cuxdnfexzlj8ls4zjd3qxwh8oa8.png" width="700"><br><br> 是的，流标签已经出现。 他们说，它可以用于类别的其他区分。 但是这个想法尚未在生活中应用。 <br><br><h3>  MPLS流量类别 </h3><br>  DiffServ的概念集中在具有IP标头路由的IP网络上。 真是倒霉-3年后，他们发布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 3031</a> （ <i>多协议标签交换体系结构</i> ）。  MPLS开始接管网络提供商。 <br><br>  DiffServ无法扩展到他。 <br><br> 碰巧的是，对于任何实验情况，都将三位EXP字段放入MPLS。 尽管事实上很久以前在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 5462</a> （ <i>“ EXP”字段重命名为“ Traffic Class”字段</i> ）中正式成为Traffic Class字段，但由于惯性，它被称为IExPi。 <br><br> 它有一个问题-它的长度为3位，这将可能的值的数量限制为9。它不仅很小，而且比DSCP少3个二进制数。 <br><br><img src="https://habrastorage.org/webt/is/r0/tc/isr0tc7unhhkxs-bjevcbipjq6k.png" width="700"><br><br> 鉴于MPLS流量类通常是从DSCP IP数据包继承的，因此存档时会丢失。 或者...不，您不想知道... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">L-LSP</a> 。 结合使用“流量类别+标签”值。 <br><blockquote> 通常，情况很奇怪-MPLS被设计为用于快速决策的IP辅助-MPLS标签是通过Full Match在CAM中立即检测到的，而不是传统的Longest Prefix Match。 也就是说，他们了解IP，并参与了交换，但是没有提供正常的优先级字段。 <br></blockquote> 实际上，我们在上面已经看到，只有DSCP的前三位用于确定流量类别，其他三位是丢弃优先级（或PLP-丢包优先级）。 <br><br> 因此，就服务类别而言，我们仍然具有1：1的对应关系，仅丢失有关丢弃优先级的信息。 <br><br> 在MPLS的情况下，IP分类可以基于接口MF，IP DSCP或流量类别MPLS。 <br><br> 标记意味着将值写入MPLS标头的“业务类别”字段。 <br><br> 一个数据包可能包含多个MPLS标头。 出于DiffServ的目的，仅使用顶部。 <br><br> 通过MPLS域将数据包从一个纯IP段移动到另一个纯IP段时，存在三种不同的重标记场景：（这只是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>的摘录）。 <br><br><ol><li> 统一模式 </li><li> 管道模式 </li><li> 短管模式 </li></ol><br><div class="spoiler">  <b class="spoiler_title">操作模式...</b> <div class="spoiler_text"><br><h3> 统一模式 </h3><br> 这是一个扁平的端到端模型。 <br><br><img src="https://habrastorage.org/web/e50/932/53b/e5093253bcf94dc091f88500be2b6f9d.png" width="1000"><br><br> 在Ingress PE，我们信任IP DSCP并在MPLS EXP（隧道和VPN标头）中复制（ <i>严格地说是显示，但为简单起见，我们</i>称其为<i>“复制”</i> ）。 在Ingress PE的输出处，已经根据上层MPLS标头的EXP字段的值处理了数据包。 <br><br> 每个中转站P也根据最高EXP处理数据包。 但是同时，如果操作员需要，他可以更改它。 <br><br> 倒数第二个节点删除传输标签（PHP），并将EXP值复制到VPN标头。 站在那里并没关系-在统一模式下，会进行复制。 <br><br> 出口PE删除了VPN标签，也将EXP值复制到IP DSCP，即使在其中写入了其他内容也是如此。 <br><br> 也就是说，如果在中间某处隧道头中的EXP标签的值已更改，则此更改将被IP数据包继承。 <br><br><h3> 管道模式 </h3><br><img src="https://habrastorage.org/web/5a1/f9a/a46/5a1f9aa46bb94ed88d62185535f5b41e.png" width="1000"><br><br> 如果在Ingress PE上我们决定不信任DSCP值，则将运营商想要的EXP值插入到MPLS标头中。 <br><br> 但是可以复制DSCP中的内容。 例如，您可以重新定义值-将所有内容复制到EF，然后将CS6和CS7映射到EF。 <br><br> 每个转接P仅查看上层MPLS标头的EXP。 <br><br> 倒数第二个节点删除传输标签（PHP），并将EXP值<b>复制</b>到VPN标头。 <br><br> 出口PE首先根据MPLS标头中的EXP字段处理数据包，然后才将其删除， <b>而不将</b>值<b>复制</b>到DSCP。 <br><br> 也就是说，不管MPLS标头中的EXP字段发生了什么，IP DSCP都保持不变。 <br><br> 当运营商拥有自己的Diff-Serv域并且不希望客户端流量以某种方式影响它时，可以使用这种方案。 <br><br><h3> 短管模式 </h3><br><img src="https://habrastorage.org/web/f80/1c8/e2d/f801c8e2dac84ff1b376a5f68824d93e.png" width="1000"><br><br> 您可以将此模式视为管道模式的变体。 唯一的区别是，在MPLS网络的出口处，将根据数据包的IP DSCP字段而不是MPLS EXP来处理数据包。 <br><br> 这意味着输出端的数据包优先级是由客户端而不是运营商确定的。 <br> 入口PE不信任IP DSCP入站数据包 <br>  Transit Ps在顶部标题的EXP字段中查找。 <br> 倒数第二个P删除传输标签，并将值复制到VPN标签。 <br> 出口PE首先删除MPLS标签，然后处理队列中的数据包。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">思科的</a>解释。 <br></div></div><br><hr><br><h4> 分类实践MPLS Traffic Class </h4><br> 该方案是相同的： <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">配置文件是相同的。</a> <br><br> 在linkmeup网络图中，存在从IP到MPLS到Linkmeup_R2的过渡。 <br> 让我们看看在<b>ping ip 172.16.2.2源172.16.1.1 tos 184</b>时标记发生了什么。 <br><br>  <i>Linkmeup_R2。</i>  <i>E0 / 0。</i> <br><img src="https://habrastorage.org/webt/lj/at/14/ljat14wahqfc91ojgigmlrwayzo.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br> 因此，我们看到IP DSCP中的原始EF标签被转换为VPN标头和传输标头的EXP MPLS字段的值5（也是流量类，记住这一点）。 <br> 在这里，我们目睹了统一操作模式。 <br><br><hr><br><h3> 以太网802.1p </h3><br>  802.3（Ethernet）中缺少优先级字段的原因是，以太网最初专门作为LAN网段的解决方案而设计。 如果花很少的钱，您可能会获得过多的带宽，并且上行链路始终是瓶颈-无需担心优先级。 <br><br> 但是，很快就清楚地认识到，以太网+ IP的经济吸引力将这一捆绑带到了骨干网和WAN层。 而且，需要解决洪流和电话的一个局域网段中的同居问题。 <br><br> 幸运的是，802.1q（VLAN）为此及时到来，其中为优先级分配了一个3位（再次）字段。 <br><br> 在DiffServ计划中，此字段允许您定义相同的8个流量类别。 <br><br><img src="https://habrastorage.org/webt/oh/_i/1l/oh_i1l1omqt1rk8agowdenx6x7o.png" width="600"><br><br><hr><br> 接收数据包时，DS域的网络设备在大多数情况下会考虑其用于交换的报头： <br><br><ul><li> 以太网交换机-802.1p </li><li>  MPLS节点-MPLS流量类别 </li><li>  IP路由器-IP DSCP </li></ul><br> 尽管可以更改此行为：基于接口和多字段分类。 有时您甚至可以在CoS字段中明确地说出要查看的标头。 <br><br><hr><br><h2> 基于接口 </h2><br> 这是对额头上的包裹进行分类的最简单方法。 注入到指定接口中的所有内容均使用特定类进行标记。 <br><br> 在某些情况下，这种粒度就足够了，因此可以在生活中使用基于接口的方法。 <br><br><h4> 基于界面的分类实践 </h4><br> 该方案是相同的： <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br> 在大多数供应商的设备中设置QoS策略分为多个阶段。 <br><br><ol><li> 首先，定义分类器： <br> <code>class-map match-all TRISOLARANS_INTERFACE_CM <br> match input-interface Ethernet0/2</code> <br> 以太网0/2接口的所有内容。 <br></li><li> 接下来，创建一个策略，其中将分类器和必要的操作相关联。 <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-map TRISOLARANS_REMARK <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_INTERFACE_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp cs7</code> </pre> <br> 如果数据包符合TRISOLARANS_INTERFACE_CM分类器，则在DSCP字段中写入CS7。 <br><blockquote> 在这里，我先使用晦涩的CS7，然后再使用EF，AF。 您可以在下面阅读有关这些缩写和已接受协议的信息。 同时，只需知道这些是具有不同服务级别的不同类别即可。 <br></blockquote></li><li> 最后一步是将策略应用于接口： <br><br><pre> <code class="hljs pgsql"> interface Ethernet0/<span class="hljs-number"><span class="hljs-number">2</span></span> service-<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> TRISOLARANS_REMARK</code> </pre> <br><blockquote> 在这里，分类器有点多余，它将检查数据包是否到达e0 / 2接口，然后在其中应用策略。 任何人都可以写匹配： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_INTERFACE_CM match <span class="hljs-keyword"><span class="hljs-keyword">any</span></span></code> </pre> <br> 但是，该策略实际上可以应用在vlanif或输出接口上，因此是可行的。 <br></blockquote><br></li></ol><br> 使用Trisolaran1在172.16.2.2（Trisolaran2）上执行常规ping： <br><br><img src="https://habrastorage.org/webt/sm/gh/5j/smgh5j3nxjmen6yspkxl8tu9so8.png" width="400"><br><br> 在Linkmeup_R1和Linkmeup_R2之间的转储中，我们将看到以下内容： <br><br><img src="https://habrastorage.org/webt/rh/qe/6z/rhqe6z4z98dxmkcrygfpb7zboee.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于配置文件界面的分类。</a> <br><br><h2> 多领域 </h2><br>  DS域入口处最常见的分类类型。 我们不信任现有的标签，并且根据包头分配一个类。 <br><br> 在发件人未标记的情况下，通常这是完全“启用” QoS的方法。 <br><br> 一个相当灵活的工具，但同时又很麻烦-您需要为每个类创建困难的规则。 因此，在DS域中，BA更重要。 <br><br><h4>  MF分类实践 </h4><br> 该方案是相同的： <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br> 从上面的实际示例中可以看出，网络设备默认情况下信任传入数据包的标签。 <br><br> 这在DS域中很好，但在入口点是不可接受的。 <br><br> 现在让我们不要盲目相信吗？ 在<b>Linkmeup_R2上，</b> ICMP将标记为EF（仅作为示例），TCP标记为AF12，其他所有标记为CS0。 <br> 这将是MF（多字段）分类。 <br><br><ol><li> 步骤是相同的​​，但是现在我们将根据ACL进行匹配，以取消必要的流量类别，因此首先创建它们。 <br><br> 在Linkmeup_R2上： <br><br><pre> <code class="hljs pgsql"> ip <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list extended TRISOLARANS_ICMP_ACL permit icmp <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> ip <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list extended TRISOLARANS_TCP_ACL permit tcp <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> ip <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list extended TRISOLARANS_OTHER_ACL permit ip <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span></code> </pre> <br></li><li> 接下来，我们定义分类器： <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_TCP_CM match <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> TRISOLARANS_TCP_ACL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_OTHER_CM match <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> TRISOLARANS_OTHER_ACL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_ICMP_CM match <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> TRISOLARANS_ICMP_ACL</code> </pre> <br></li><li> 现在，我们定义了政治评论的规则： <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-map TRISOLARANS_ADMISSION_CONTROL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_ICMP_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp ef <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_TCP_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp af11 <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_OTHER_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp <span class="hljs-keyword"><span class="hljs-keyword">default</span></span></code> </pre> <br></li><li> 并且我们在接口上挂起了策略。 分别在输入时，因为必须在网络的入口处做出决定。 <br><br><pre> <code class="hljs pgsql"> interface Ethernet0/<span class="hljs-number"><span class="hljs-number">1</span></span> service-<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> TRISOLARANS_ADMISSION_CONTROL</code> </pre> <br></li></ol><br> 来自最终主机Trisolaran1的ICMP测试。 我们没有明确指定类别-默认值为0。 <br><br>  <b>我已经用Linkmeup_R1删除了该策略，因此流量带有标记CS0，而不是CS7。</b> <br><br><img src="https://habrastorage.org/webt/_f/si/90/_fsi9012_fo5a8z1x14fdtxqz0m.png" width="400"><br><br> 这是附近的两个转储，分别是Linkmeup_R1和Linkmeup_R2： <br><br>  <i>Linkmeup_R1。</i>  <i>E0 / 0。</i> <br><img src="https://habrastorage.org/webt/cp/t5/ge/cpt5gersxbcrhjsba4lz8t-5z-i.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br>  <i>Linkmeup_R2。</i>  <i>E0 / 0。</i> <br><img src="https://habrastorage.org/webt/9x/0w/j7/9x0wj7gkztleiock6vnax33m-7c.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br> 可以看出，在对ICMP数据包的Linkmeup_R2进行分类并重新标记后，不仅DSCP更改为EF，而且MPLS Traffic Class等于5。 <br><br> 使用telnet 172.16.2.2。进行类似的测试。  80-因此请检查TCP： <br><br><img src="https://habrastorage.org/webt/rd/f1/xo/rdf1xovczuma9nuziqbawyyuqji.png" width="400"><br><br>  <i>Linkmeup_R1。</i>  <i>E0 / 0。</i> <br><img src="https://habrastorage.org/webt/-i/nr/gj/-inrgjtler0zsvt2y3hq3cxvd8m.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br>  <i>Linkmeup_R2。</i>  <i>E0 / 0。</i> <br><img src="https://habrastorage.org/webt/mk/z_/qz/mkz_qz44dywl9kr5uw3ohauu9qa.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br> 阅读-什么和要求期望。  TCP作为AF11传输。 <br><br> 下一个测试将测试UDP，根据我们的分类器，它应该转到CS0。 我们将为此使用iperf（通过Apps将其引入Linux Tiny Core）。 在远程端<b>iperf3 -s-</b>启动服务器，在本地<b>iperf3 -c -u -t1-</b>客户端（ <b>-c</b> ），UDP协议（ <b>-u</b> ）上，测试1秒钟（ <b>-t1</b> ）。 <br><br><img src="https://habrastorage.org/webt/zw/gu/sb/zwgusb4bqnq7prgq_yw5ue44pqo.png" width="400"><br><br>  <i>Linkmeup_R1。</i>  <i>E0 / 0。</i> <br><img src="https://habrastorage.org/webt/rm/sx/pq/rmsxpqgca2wmuhhcu5mcnvcth7y.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br>  <i>Linkmeup_R2。</i>  <i>E0 / 0</i> <br><img src="https://habrastorage.org/webt/yt/9q/gv/yt9qgv2qcqun9rpr8me4nuyghym.png" width="600"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pcapng</a></i> <br><br> 从现在开始，将根据配置的规则对进入此界面的所有内容进行分类。 <br><br><hr><br><h2> 在设备内部标记 </h2><br> 再次：在DS域分类的入口处可以发生MF，基于接口或BA。 <br> 在DS域的节点之间，标头中的数据包带有有关所需服务等级的标志，并由BA分类。 <br><br> 无论采用哪种分类方法，在包装之后，都将在设备内为包装分配内部类，并根据该内部类对其进行处理。 标头被删除，裸包（否）到达出口。 <br> 在输出处，内部类将转换为新标头的CoS字段。 <br><br> 也就是说，标题1⇒分类⇒内部服务等级⇒标题2。 <br><br> 在某些情况下，您需要在另一个协议的标头字段中显示一个协议的标头字段，例如，“流量类别”中的DSCP。 <br><br> 这仅通过中间内部标记发生。 <br><br> 例如，DSCP标题⇒分类⇒内部服务等级⇒交通等级标题。 <br><br> 形式上，内部类可以随意调用，也可以简单地编号，并且它们仅分配有一定的队列。 <br><br> 在本文深入探讨时，无论它们叫​​什么都无所谓，重要的是将特定的行为模型与QoS字段的特定值相关联。 <br><br> 如果我们正在谈论特定的QoS实现，则设备可以提供的服务类别的数量不超过可用队列的数量。 通常有八种（在国际植检门户网站的影响下，有时甚至是未经书面同意）。 但是，取决于供应商，设备，板，它们可以更多或更少。 <br><br> 也就是说，如果有4个队列，那么服务类根本就没有意义要做四个以上的队列。 <br><br> 让我们在硬件一章中更详细地讨论这一点。 <br><br><div class="spoiler">  <b class="spoiler_title">如果您仍然真的想要一点特殊性...</b> <div class="spoiler_text"><blockquote> 乍看起来，下表似乎对QoS字段和内部类之间的关系似乎很方便，但是在调用类PHB名称时，它们有些误导。 尽管如此，PHB是将哪种行为模型分配给特定类别的流量，大致来说，其名称是任意的。 <br><br> 因此，请持怀疑态度参阅下表（因此，在扰流板之下）。 </blockquote><br>  <i>以华为为例</i> 。 在这里，Service-Class是包的非常内部的类。 <br><br> 也就是说，如果在输入中将BA分类，则DSCP值将转换为相应的Service-Class和Color值。 <br><br><img src="https://habrastorage.org/webt/h-/xh/sp/h-xhspe0wg3zymljrw4fdcd8v-u.png" width="500"><br><br> 值得注意的是，没有使用许多DSCP值，而带有此类标记的数据包实际上被视为BE。 <br><br> 这是一个向后匹配表，显示重新标记输出时将为通信设置哪些DSCP值。 <br><br><img src="https://habrastorage.org/webt/as/t4/49/ast449vrq3tmkbo_xhxoqmvayjm.png" width="500"><br><br> 请注意，只有AF具有颜色渐变。  BE，EF，CS6，CS7-全部为绿色。 <br><br> 该表用于将IPP，MPLS流量类别和802.1p以太网字段转换为内部服务类别。 <br><br><img src="https://habrastorage.org/webt/d7/nz/up/d7nzupuudz6mpvapmunecfol43a.png" width="500"><br><br> 再回来 <br><br><img src="https://habrastorage.org/webt/nc/qz/zr/ncqzzr58m-3acsu1gid9xkowfxy.png" width="500"><br><br> 注意，关于丢弃优先级的任何信息通常都会在此处丢失。 <br><br> 应该重复进行-这只是<i>随机</i>选择的供应商提供的默认匹配的一个具体示例。 对于其他人，这可能有所不同。 管理员可以在其网络上配置完全不同的服务和PHB类。 <br><br></div></div><br> 就PHB而言，用于分类的DSCP，流量类别，802.1p绝对没有区别。 <br><br> 在设备内部，它们变成了网络管理员定义的流量类别。 <br> 也就是说，所有这些标记都是一种告诉邻居应将其分配给此服务包的服务等级的方法。 就像BGP社区一样，它本身并不意味着任何东西，除非在网络上定义了解释它们的策略。 <br><br><hr><br><h2>  IETF建议（流量类别，服务等级和行为） </h2><br> 标准并没有完全标准化应该存在哪些特定服务类别，如何对它们进行分类和标记以及将哪些PHB应用于它们。 <br><br> 这受供应商和网络管理员的控制。 <br><br> 我们只有3位-我们可以根据需要使用。 <br><br> 这很好： <br><br><ul><li> 每块铁（供应商）独立选择用于PHB的机制-无信号，无兼容性问题。 </li><li> 每个网络的管理员可以灵活地在不同类别之间分配流量，选择类别本身和相应的PHB。 </li></ul><br> 这很不好： <br><br><ul><li> 在DS域的边界，出现转换问题。 </li><li> 在完全行动自由的条件下-有些在森林里，有些是恶魔。 </li></ul><br> 因此，IETF在2006年发布了有关如何实现服务差异化的培训手册： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 4594</a> （ <i>DiffServ服务类别的配置指南</i> ）。 <br><br> 以下是此RFC的简要摘要。 <br><br><h3> 行为模型（PHB） </h3><br>  <b>DF-默认转发</b> <br>  <i>标准出货。</i> <br> 如果未专门为流量模型分配行为模型，则将使用默认转发对其进行处理。 <br><br> 这是尽力而为-该设备将尽一切可能，但不能保证任何事情。 可能会出现掉落，混乱，不可预测的延迟和浮动抖动，但这并不准确。 <br><br> 该模型适用于要求不高的应用程序，例如邮件或文件下载。 <br> 顺便说一句，有PHB甚至更不确定<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-A努力</a> 。 <br><br>  <b>AF-保证转发</b> <br>  <i>保证发货。</i> <br> 这是一种改进的BE。 一些保证出现在这里，例如带。 下降和浮动延迟仍然可能，但程度要小得多。 <br><br> 该模型适用于多媒体：流媒体，视频会议，在线游戏。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 2597</a> （ <i>保证转发PHB组</i> ）。 <br><br>  <b>EF-快速转发</b> <br>  <i>紧急运送。</i> <br> 所有资源和优先事项都涌向这里。 该模型适用于不需要损耗，短延迟，稳定抖动但对带宽不贪婪的应用。 例如，电话或有线仿真服务（CES-电路仿真服务）。 <br><br>  EF的损失，混乱和浮动延迟极不可能。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 3246</a> （ <i>快速转发PHB</i> ）。 <br><br>  <b>CS-类选择器</b> <br> 这些行为旨在维护具有DS功能的网络中与IP优先级的向后兼容性。 <br><br>  IPP中存在以下类别：CS0，CS1，CS2，CS3，CS4，CS5，CS6，CS7。 <br> 并非所有人都总是有一个单独的PHB，通常有两个或三个，然后将其余的简单地转换为最近的DSCP类并获得相应的PHB。 <br> 因此，例如，标记为CS 011000的数据包可以分类为011010。 <br><br> 当然，在CS中，仅将推荐用于NCP（网络控制协议）且需要单独PHB的CS6，CS7保留在设备中。 <br><br> 像EF一样，PHB CS6.7设计用于具有很高的延迟和损耗要求，但在一定程度上可以容忍频带歧视的类。 <br> 用于CS6.7的PHB的任务是提供一种服务级别，即使在接口，芯片和队列极度过载的情况下，也可以消除丢弃和延迟。 <br><hr><br><br> 重要的是要了解PHB是一个抽象概念-实际上，它们是通过实际设备上可用的机制来实现的。 <br><br> 因此，在DS域中定义的相同PHB在Juniper和华为上可能有所不同。 <br><br> 此外，单个PHB并不是一组静态的操作；例如，PHB AF可能包含几个选项，这些选项的保证级别（带宽，可接受的延迟）不同。 <br><br><hr><br><h3> 服务等级 </h3><br>  IETF照顾了管理员，并确定了应用程序的主要类别及其服务类别。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在这里不会太冗长，仅插入本准则RFC中的几版。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用类别：</font></font><br><br><img src="https://habrastorage.org/webt/an/hr/np/anhrnppkfmebfm7vaoarb1xv7s0.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对网络特性的要求：</font></font><br><br><img src="https://habrastorage.org/webt/ih/5r/z2/ih5rz2jw4ifygst1mjgte9a_vc0.png" width="560"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，推荐类名称和相应的DSCP值：</font></font><br><br><img src="https://habrastorage.org/webt/jg/rp/4k/jgrp4kzhhhvz1-zygrsiexieeyy.png" width="560"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过以不同方式组合上述类（以适应8种可用的类型），您可以获得适用于不同网络的QoS解决方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许最常见的是：</font></font><br><br><img src="https://habrastorage.org/webt/su/ft/ed/suftedkuzswznewqbj3uslcncru.png" width="560"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DF（或BE）类标记的流量绝对不高-它在剩余的基础上受到关注。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHB AF服务于AF1，AF2，AF3，AF4类。他们都需要提供一条通道，以免造成延误和损失。丢失由丢弃优先级位控制，这就是为什么将它们称为AFxy的原因，其中x是服务级别，y是丢弃优先级。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EF需要某种最小频带保证，但更重要的是-保证延迟，抖动和无损失。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS6，CS7甚至需要更少的带宽，因为这是服务包的细流，其中仍然可能发生突发（例如BGP Update），但是其中的损失和延迟是不可接受的-如果Hello崩溃，BFD使用10 ms的定时器是什么100毫秒队列？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，在AF下提供了8个可用课程中的4个。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管事实上它们通常只是这样做，但我再说一遍，这些只是建议，没有什么可以阻止DS域中的三个类分配EF，而只有两个分配AF。</font></font><br><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 分类汇总 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在节点的入口处，根据接口，MF或其标签（BA）对包装进行分类。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标签是IPv4中DSCP字段的值，IPv6中通信类的值以及802.1q中MPLS或802.1p的值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有8种服务类别，可汇总各种流量。每个班级都有自己的PHB，可以满足班级的要求。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据IETF的建议，区分以下服务类别：CS1，CS0，AF11，AF12，AF13，AF21，CS2，AF22，AF23，CS3，AF31，AF32，AF33，CS4，AF41，AF42，AF43，CS5，EF，CS6， CS7在交通中的重要性越来越高。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中可以选择8的组合，这些组合实际上可以编码为CoS字段。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最常见的组合：CS0，AF1，AF2，AF3，AF4，EF，CS6，CS7，具有3种用于AF的颜色等级。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个类别都分配有一个PHB，其中PHB的严重性从高到低依次为3-默认转发，保证转发，快速转发。</font><font style="vertical-align: inherit;">除了PHB类选择器。</font><font style="vertical-align: inherit;">每个PHB可能因工具参数而异，但稍后会更多。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们说，在无负载的网络上，不需要QoS。</font><font style="vertical-align: inherit;">他们说，通过扩展链接可以解决任何QoS问题。</font><font style="vertical-align: inherit;">他们说，有了以太网和DWDM，我们将永远不会遇到线路拥塞的情况。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们是那些不了解什么是QoS的人。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是现实打击了ILV上的VPN。</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并非到处都有光学器件。</font><font style="vertical-align: inherit;">RRL是我们的现实。</font><font style="vertical-align: inherit;">有时，在事故发生时（不仅如此），在狭窄的无线电链路中，希望抓取所有网络流量。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交通突发是我们的现实。</font><font style="vertical-align: inherit;">短期流量突发很容易排队，从而迫使丢弃非常必要的数据包。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电话，视频会议，在线游戏是我们的现实。</font><font style="vertical-align: inherit;">如果队列至少有点忙，延迟就会开始。</font></font></li></ol><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我的实践中，有一些示例在网络负载不超过40％的情况下将电话转换为摩尔斯电码。</font><font style="vertical-align: inherit;">只需在EF中重新标记即可立即解决该问题。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 是时候使用允许您为不同的类提供不同的服务的工具了。 </font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PHB工具 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 实际上，只有三组QoS工具可以有效地操作程序包： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免拥塞-要做的事还不错。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 拥塞管理-已经很糟糕时该怎么办。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 速率限制-如何在网络上不增加过多的内容，如何释放不可接受的内容。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是，如果不是要排队的话，所有这些都将毫无用处。 </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.队列 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在游乐园中，如果您不为付更多钱的人安排单独的队列，就不能给予某人优先权。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络中的情况相同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果所有流量都在一个队列中，则您将无法从其中间拉出重要数据包以使其具有优先级。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是为什么在分类之后将数据包放置在与此类别相对应的队列中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，一个队列（带有语音数据）将快速移动，但带宽有限，另一队列变慢（流），但带宽较大，并且某些资源将根据剩余原理移动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是在每个单独队列的限制内，应用相同的规则-您不能从中间提取数据包-只能从其头部提取数据包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个队列都有一定的限制长度。一方面，这是由硬件限制决定的，另一方面，将数据包保留在队列中的时间过长是没有意义的。如果VoIP数据包延迟了200毫秒，则不需要此数据包。 RTT到期（在sysctl中配置）后，TCP将有条件地请求转发。因此，丢弃并不总是坏的。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络设备的开发人员和设计人员必须在尝试尽可能长时间保存程序包与试图避免浪费带宽，尝试提供不再需要的程序包之间寻求折衷。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在正常情况下，当接口/芯片未过载时，缓冲区利用率接近零。它们吸收短期爆发，但这不会导致其长时间充盈。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果流量超出交换芯片或输出接口的处理能力，则队列开始占满。</font><font style="vertical-align: inherit;">超过20-30％的长期利用率已经是需要解决的情况。</font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.避免拥塞 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在任何路由器的生命周期中，都会出现队列已满的情况。</font><font style="vertical-align: inherit;">将包裹放在哪里，如果绝对没有地方可放-就是这样，缓冲区已经过去了，即使看起来不错，即使您支付了额外的费用，缓冲区也不会在那里。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种方法：要么丢弃此数据包，要么丢弃已经转弯的数据包。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果这些已经在队列中，请考虑缺少什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果是这样，那就认为他没有来。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这两种方法称为“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尾巴掉落”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">头部掉落”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 尾巴和头部掉落 </font></font></h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尾部丢弃</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -最简单的队列管理机制-丢弃所有不适合缓冲区的新到达数据包。</font></font><br><br><img src="https://habrastorage.org/webt/gu/qu/lv/guqulvedyuzoyytzzbybxrzua9g.png" width="500"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Head Drop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丢弃已排队很长时间的数据包。最好将它们丢弃而不是保存，因为它们很可能毫无用处。但是，到达队列末尾的相关性更高的软件包将有更多机会按时到达。另外，Head Drop允许您不使用不必要的程序包加载网络。自然，最早的软件包是那些位于队列开头的软件包，因此是方法的名称。</font></font><br><br><img src="https://habrastorage.org/webt/6h/0d/rq/6h0drqorglxgq9mjocqjm_bpwby.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丢头还有另一个明显的优点-如果您在队列开始处丢弃数据包，接收者将迅速发现网络上的拥塞并通知发送者。对于“尾巴丢弃”，有关丢弃的数据包的信息可能会在数百毫秒后到达-直到从行尾到她的头部为止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种机制依次与差异化协同工作。也就是说，实际上，不必整个缓冲区都已满。如果第二个队列为空，而零队列为零，则仅丢弃从零开始的数据包。</font></font><br><br><img src="https://habrastorage.org/webt/as/nl/l7/asnll7xgflrxk_mvdxgmglgf2fm.png" width="400"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尾部下降和头部下降可以同时工作。</font></font><br><br><img src="https://habrastorage.org/webt/bn/n1/wv/bnn1wvl9qene8f4xysetig6hemg.png" width="500"><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尾巴和头部掉落是避免拥塞的“前额”。您甚至可以说-这是他的缺席。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在队列100％充满之前，我们什么也不做。之后，我们开始丢弃所有新到达（或延迟很长时间）的数据包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您不需要采取任何措施来实现目标，那么在某处会有细微差别。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而这种细微差别就是TCP。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回想一下（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更深入</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">更</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深入</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）TCP如何工作-我们正在谈论现代实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个滑动窗口（滑动窗口或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rwnd-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收件人</font><b><font style="vertical-align: inherit;">的广告窗口</font></b><font style="vertical-align: inherit;">），由接收者控制，告诉发送者可以发送多少。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且有一个过载窗口（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWND-拥塞窗口</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），它可以响应网络问题并由发送方控制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据传输过程以</font><font style="vertical-align: inherit;">CWND呈指数增长</font><font style="vertical-align: inherit;">的慢启动（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slow Start</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><b><font style="vertical-align: inherit;">开始</font></b><font style="vertical-align: inherit;">。对于每个确认的段，将1个MSS大小添加到CWND，实际上，它在等于RTT（数据在那里，ACK返回）的时间内加倍（有关Reno / NewReno的语音）。</font></font><br><br> 举个例子 <br><br><img src="https://habrastorage.org/webt/5n/5a/nd/5n5andpbm8lvmyeaio0i565c_ek.png" width="200"><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指数</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增长继续达到称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssthreshold</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（慢启动阈值）的值，该值在主机的TCP配置中指定。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，</font><font style="vertical-align: inherit;">对于每个已确认的分段，将开始</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增长1 / CWND，直到其抵御RWND或开始亏损（通过重新确认（重复ACK）或完全没有确认的损失）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一旦检测到段丢失，就会发生</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP Backoff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -TCP大大减小了窗口，实际上降低了发送速度-并且</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速恢复</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机制启动</font><font style="vertical-align: inherit;">：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发送丢失的段（快速重传）， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 窗户翻了一倍， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ssthreshold值也等于所到达窗口的一半， </font></font></li><li><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增长</font><font style="vertical-align: inherit;">再次开始，</font><font style="vertical-align: inherit;">直到第一次亏损，</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 再说一次 </font></font></li></ol><br><img src="https://habrastorage.org/webt/of/0p/ar/of0park6tnishwa25_v_dgzwaya.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丢失可能意味着某个网络段完全崩溃，然后认为它已丢失，或者线路拥塞（读取缓冲区溢出并丢弃此会话的一部分）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是TCP最大限度地利用可用带宽并处理拥塞的方法。</font><font style="vertical-align: inherit;">而且非常有效。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，拖尾会导致什么？</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设通过路由器存在数千个TCP会话的路径。</font><font style="vertical-align: inherit;">在某个时刻，会话流量达到1.1 Gb / s，输出接口速度-1 Gb / s。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交通自带快于叶，缓冲区已填满</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vsklyan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启用尾部丢弃功能，直到调度员从队列中取出一些数据包为止。 </font></font></li><li>           Fast Recovery (    Slow Start). </li><li>    ,  , Tail Drop . </li><li>   TCP-  ,          . </li><li>  . </li><li> Fast Recovery/Slow Start. </li><li> . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 2001中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TCP机制更改的更多信息</font><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP慢启动，拥塞避免，快速重传和快速恢复算法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一种称为“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全局TCP同步</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/webt/wr/co/oq/wrcooqd2fjrix9jbimh-8si97h4.png" width="500"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全局</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”的情况的典型说明，</font><font style="vertical-align: inherit;">因为通过此节点建立的许多会话都会受到影响。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同步</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它们同时受苦。情况将一直重复，直到出现过载为止。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为没有拥塞控制机制的UDP不受它的影响。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，如果不引起条带的次优使用（锯齿之间的缝隙）和浪费的钱，就不会有任何不好的事情发生。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个问题是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP饥饿</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -TCP耗尽。尽管TCP放慢了速度以减轻负载（首先不让我们拆开-首先，一定要传输数据），但UDP，数据报一般会带来的所有道德苦难-会发送尽可能多的内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，减少了TCP流量，并且UDP不断增长（可能），下一个丢失周期-快速恢复发生在较低的阈值。 UDP占用空间。 TCP流量总量下降。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何解决问题，最好避免。</font><font style="vertical-align: inherit;">让我们尝试使用快速恢复/缓慢启动来减少在队列填满之前的负载，这对我们不利。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RED-随机早期检测 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果我们在缓冲区的某些部分上拍摄并涂抹了液滴，该怎么办？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相对而言，当队列已满80％时，开始丢弃随机数据包，从而迫使某些TCP会话减少窗口并相应地降低速度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果队列已满90％，我们将开始随机丢弃50％的数据包。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90％-概率增加到“尾巴丢弃”（100％的新数据包被丢弃）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现这种队列管理的机制称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AQM-自适应（或活动）队列管理，</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RED的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作方式</font><font style="vertical-align: inherit;">。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">早期检测</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -解决潜在的过载；</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><b><font style="vertical-align: inherit;">随机</font></b><font style="vertical-align: inherit;">丢弃数据包。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时它们会像随机随机早期丢弃一样解码RED（在我看来，从语义上来说更正确）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从图形上看，它看起来像这样：</font></font><br><br><img src="https://habrastorage.org/webt/1n/zs/5v/1nzs5vsexsokkaepdxe_mo-klsg.png" width="600"><br><br><img src="https://habrastorage.org/webt/lp/rl/m7/lprlm7iiurfwklhdnun20iqdoci.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在缓冲区满80％之前，不会完全丢弃数据包-概率为0％。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从80到100个数据包开始被丢弃，并且队列填充的次数越多，该数据包就越高。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此百分比从0增加到30。RED </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的副作用是，激进的TCP会话更有可能减慢速度，这仅仅是因为有很多数据包，而且它们很有可能被丢弃。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用RED胶条的效率低下，可通过钝化较小部分的牙齿，而不会引起牙齿之间的严重牵伸而解决。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正是出于同样的原因，UDP无法占据所有内容。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WRED-加权随机早期检测 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是在所有人的听证中，可能仍然是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WRED</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。敏锐的linkmeup读者已经建议这是相同的RED，但要依次加权。而且他不太正确。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RED在同一队列中操作。如果BE已满，则回顾EF没有任何意义。因此，依次称重不会带来任何东西。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，丢弃优先权才有效。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在同一队列中，具有不同丢弃优先级的数据包将具有不同的曲线。优先级越低，就越有可能遭到抨击。</font></font><br><br><img src="https://habrastorage.org/webt/ef/rg/_v/efrg_vx4xacb4uwjrkvcdutemho.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里有3条曲线：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色-优先级较低的流量（根据丢弃），黄色-优先级较高，绿色-最大。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当缓冲区已满20％时，红色流量开始被丢弃，从20降低到40，然后下降到20％，然后是尾部丢弃。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黄色从稍后开始-从30到50，最多丢弃10％，然后-拖尾。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绿色是最不易受影响的：从50到100，它可以平滑增长到5％。接下来是尾巴掉落。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于DSCP，可能是AF11，AF12和AF13，分别是绿色，黄色和红色。</font></font><br><br><img src="https://habrastorage.org/webt/jv/jm/9q/jvjm9qul8wyhrhncvx8iylnbl5s.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，它与TCP一起使用非常重要，并且绝对不适用于UDP。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者，使用UDP的应用程序会忽略损失，例如电话或视频流，这会对用户的观看体验产生负面影响。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者应用程序本身控制交付，并要求您重新发送相同的程序包。但是，不必要求信号源降低传输速率。而不是减少负载，而是由于重传而增加。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是为什么只有尾巴落下用于EF的原因。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于CS6，CS7，还使用了“尾巴掉落”，因为没有假定高速，并且WRED无法解决任何问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于AF，将应用WRED。 AFxy，其中x是服务的类别，即服务所属的队列，而y是放置优先级-相同的颜色。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于BE，将基于此队列中的主要流量来做出决策。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在单个路由器中，使用了特殊的内部数据包标签，与承载标头的标签不同。</font><font style="vertical-align: inherit;">因此，无法在丢弃优先级进行编码的MPLS和802.1q可以在具有不同丢弃优先级的队列中进行处理。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，一个MPLS数据包到达一个节点，它不带有Drop Precedence标签，但是根据抛光的结果，它变成黄色，可以在放入队列之前被丢弃（可以由Traffic Class字段确定）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得记住的是，整个彩虹只存在于节点内部。</font><font style="vertical-align: inherit;">邻居之间的线没有颜色的概念。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，尽管可以在DSCP的“丢弃优先级”部分中编码颜色。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 丢弃也可能出现在未加载的网络中，在该网络中似乎没有队列溢出。 </font></font>怎么了 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">造成这种情况的原因可能是流量短暂爆发。</font><font style="vertical-align: inherit;">最简单的示例-同时有5个应用程序决定将流量传输到一个终端主机。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个例子更加复杂-发送器通过10 Gb / s接口连接，接收器为1 Gb / s。</font><font style="vertical-align: inherit;">环境本身使您可以在发件人上更快地制作包裹。</font><font style="vertical-align: inherit;">接收器的以太网流控制请求最近的主机减速，并且数据包开始在缓冲区中累积。</font></font><br></blockquote><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 好吧，当情况变得更糟时该怎么办？ </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.拥塞管理 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当一切都不好时，应将处理优先级分配给更重要的流量。每个包装的重要性在分类阶段确定。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是什么不好呢？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并非所有缓冲区都需要阻塞才能使应用程序开始遇到问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最简单的示例是语音数据包，该语音数据包挤满了正在下载文件的应用程序的大包大包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这将增加延迟，破坏抖动，并可能导致掉线。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，在没有实际拥塞的情况下，我们在提供优质服务方面存在问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此问题旨在解决拥塞管理机制。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，不同应用程序的流量分为多个队列。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但只有这样，所有内容都应再次合并为一个接口。</font><font style="vertical-align: inherit;">序列化仍然依序进行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的队列如何管理以提供不同级别的服务？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以不同的方式从不同的队列中删除数据包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调度员参与其中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从最简单的开始，我们将考虑当今的大多数调度员：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FIFO-仅一行，BE，C中的所有内容-不公正。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PQ-通往寡头，走狗的道路让步。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FQ-全部相等。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DWRR-都相等，但有些甚至更均匀。 </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FIFO-先进先出 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，最简单的情况是没有QoS，即所有流量都以相同的方式处理-在一个队列中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据包完全按照到达队列的顺序离开队列，因此名称为：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一次进入-首先并且离开</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIFO既不是真正意义上的调度程序，也不是DiffServ机制，因为它实际上并不分离类。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果队列开始填满，延迟和抖动开始增加，则您将无法对其进行管理，因为您无法从队列中间拉出重要的数据包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据包大小为1,500字节的激进TCP会话可能会占用整个队列，从而导致较小的语音数据包受损。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在FIFO中，所有类都合并到CS0中。</font></font><br><br><img src="https://habrastorage.org/webt/am/-w/0k/am-w0kosnvx3ucg3qpdbnou1blk.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，尽管存在所有这些缺点，但现在这就是Internet的工作方式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，大多数FIFO供应商都是默认的调度程序，其中一个队列用于所有传输流量，而另一个队列用于本地生成的服务数据包。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很简单，很便宜。如果渠道很宽而且流量很少，那么一切都很好。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS（针对穷人）扩大了带宽范围，客户将得到满足，您的薪水将成倍增长，这是最典型的想法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有这样，网络设备才能正常工作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是很快世界就面临着一个事实，那就是根本无法解决问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着融合网络的发展趋势，很明显，不同类型的流量（服务，语音，多媒体，互联网冲浪，文件共享）具有根本不同的网络要求。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIFO不够，因此他们创建了多个队列并开始制定流量调度方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，FIFO永远不会消失：在每个队列中，始终根据FIFO原则处理数据包。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PQ-优先排队 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二种最复杂的机制，是将服务划分为类的尝试是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优先级队列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，根据类别-优先级（例如，尽管不一定，相同的BE，AF1-4，EF，CS6-7），将流量分配到几个队列中。调度程序经过另一个队列。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，它会从优先级最高的队列中跳过所有数据包，然后从较少的队列中跳过，然后从较少的队列中跳过。</font></font>以此类推。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在高优先级队列为空之前，调度程序不会开始检索低优先级数据包。</font></font><br><br><img src="https://habrastorage.org/webt/4g/l0/sl/4gl0slzp0q6kybjw14xpvvs5xt0.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在处理低优先级数据包时，某个数据包到达了较高优先级队列，则调度程序将切换到该队列，并且只有在清空后，该调度程序才会返回到其他队列。</font></font><br><br><img src="https://habrastorage.org/webt/xm/qk/v1/xmqkv1cbt_uidd4yj1nntt2jehq.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PQ的工作原理与FIFO差不多。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于协议包和语音之类的流量非常有用，在这些流量中，延迟至关重要，并且总流量不是很大。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，您必须承认，由于来自YouTube的几个大视频块，您不应该保持BFD Hello。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但这就是缺少PQ的原因-如果优先级队列中加载了流量，调度程序将永远不会切换到其他队列。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果某个邪恶的医生在寻找征服世界的方法时，决定用最高的黑标来标记他的所有恶行，那么其他所有将尽职地等待然后被丢弃。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也不必谈论每条线的保证车道。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高优先级队列可以通过在其中处理的流量的速度来削减。</font><font style="vertical-align: inherit;">这样别人就不会饿死了。</font><font style="vertical-align: inherit;">但是，控制它并不容易。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下机制依次遍历所有队列，从它们中获取一定数量的数据，从而提供更为真实的条件。</font><font style="vertical-align: inherit;">但他们的做法有所不同。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 公平排队 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想调度员的下一个竞争者是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公平排队机制</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FQ-公平排队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它的历史始于1985年，当时John Nagle建议为每个数据流创建一个队列。从本质上讲，这与IntServ方法很接近，并且很容易通过以下事实来解释：像DiffServ这样的服务类概念就不存在了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FQ从每个队列中依次提取相同数量的数据。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诚实的事实在于，调度程序</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font><b><font style="vertical-align: inherit;">数据包</font></b><font style="vertical-align: inherit;">的数量进行</font><b><font style="vertical-align: inherit;">操作，而是以</font></b><font style="vertical-align: inherit;">每个队列可以传输</font><b><font style="vertical-align: inherit;">的位数</font></b><font style="vertical-align: inherit;">进行操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，激进的TCP流无法淹没该接口，并且每个人都有平等的机会。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从理论上讲。在实践中，FQ从未实现为在网络设备中分配队列的机制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有三个缺点：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个-很明显-非常昂贵-为每个流启动一个队列，计算每个数据包的权重，并始终担心要跳过的位和数据包的大小。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个-不那么明显-所有线程在带宽方面都有平等的机会。如果我想要不平等？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三点-不明显-FQ诚实是绝对的：每个人都有相同的延迟，但是有些线程比延迟更重要。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，在256个流中有语音流，这意味着它们中的每个仅将到达256个线程中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不清楚如何处理它们。</font></font><br><br><img src="https://habrastorage.org/webt/o_/cg/au/o_cgau4ggmorq1cj28jn3hf26iq.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里您可以看到，由于第3阶段的数据包很大，在前两个周期中，我们处理了前两个数据包中的一个。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对Round Robin和GPS的逐位机制的描述已经超出了本文的范围，我建议读者进行</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独立研究</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WFQ-加权公平排队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FQ的第二个缺陷和第三个缺陷试图关闭1989年发布的WFQ。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个队列都被赋予权重，因此有权在一个周期内以权重的倍数分配流量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">权重是根据两个参数计算得出的：仍然相关然后是IP优先级和数据包长度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在WFQ中，权重越大，效果越差。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，IP优先级越高，数据包权重越低。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包装尺寸越小，重量越轻。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，高优先级的小数据包获得最多的资源，而低优先级的大数据包则在等待。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下面的图示中，数据包接收的权重如下：首先跳过来自第一个队列的一个数据包，然后跳过第二个队列的两个数据包，再次跳过第一个队列，然后才处理第三个队列。因此，例如，如果第二阶段中的数据包大小相对较小，则可能会发生这种情况。</font></font><br><br><img src="https://habrastorage.org/webt/dd/z9/v7/ddz9v7nahrtmewfrul4mbflc5b0.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于WFQ的苛刻工程设计，其包完成时间，虚拟时间和假发定理，您可以阅读一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好奇的彩色文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，这并没有解决第一个和第三个问题。基于流的方法也很不方便，需要短延迟和稳定抖动的流没有收到它们。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，这并不能阻止WFQ在某些（大多数是旧的）Cisco设备中使用。</font><font style="vertical-align: inherit;">最多有256个队列根据其标头的哈希值放置线程。</font><font style="vertical-align: inherit;">基于流的范式和有限的资源之间的折衷。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CBWFQ-基于类的WFQ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着DiffServ的出现，CBWFQ提出了解决复杂性问题的方法。 “行为汇总”将所有流量类别分为8类，并因此将其分为队列。这给了他一个名字，大大简化了排队。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBWFQ中的权重具有不同的含义。</font><font style="vertical-align: inherit;">应管理员的要求，在配置中将</font><font style="vertical-align: inherit;">权重</font><font style="vertical-align: inherit;">手动</font><font style="vertical-align: inherit;">分配给</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（不是线程），因为DSCP字段已经用于分类。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，DSCP确定要放入哪个队列以及配置的权重-该队列可使用多少个通道。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的是，这间接地使生活变得更轻松和低延迟流，这些流现在聚集在一个（2-3个）队列中，并且更频繁地获得其高分。</font><font style="vertical-align: inherit;">生活已经变得更好，但仍然不是很好-根本没有保证-总的来说，在WFQ中，就延误而言，一切仍然相等。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且，对包大小，包的碎片和碎片整理的持续监控的需求并没有消失。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CBWFQ + LLQ-低延迟队列 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后的方法是逐位方法的最终结果，是CBWFQ与PQ的结合。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列之一成为所谓的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（低延迟队列），而所有其他队列均由CBWFQ管理器处理，而PQ管理器则在LLQ与其余队列之间运行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，尽管LLQ中有数据包，但其余队列正在等待，但它们的延迟却在增加。</font><font style="vertical-align: inherit;">LLQ中的数据包一经用完，我们便开始处理其余的数据包。</font><font style="vertical-align: inherit;">数据包出现在LLQ中-他们忘记了剩下的，返回给它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIFO也可以在LLQ内部使用，因此您不应该在没有到达那里就推销一切，同时增加缓冲区利用率和延迟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，为了使非优先级队列不会饿死，值得在LLQ中设置带宽限制。</font></font><br><br><img src="https://habrastorage.org/webt/c6/4m/vt/c64mvts-kr2ij0o_zf2kfxy2cbu.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，绵羊吃饱了，狼也很安全。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RR-轮循 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与FQ同行和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并驾齐驱</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个很诚实，但并不简单。</font><font style="vertical-align: inherit;">另一个则相反。</font></font><br><br><img src="https://habrastorage.org/webt/8p/nh/de/8pnhdeko9l5nkiss6mbtxbg9jvk.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RR经过队列，从队列中提取了相等数量的数据包。</font><font style="vertical-align: inherit;">该方法比FQ更原始，因此在各种流程方面都不诚实。</font><font style="vertical-align: inherit;">激进的资源很容易用1500字节大小的数据包淹没该条。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，它实现起来非常简单-您无需知道队列中数据包的大小，对其进行分段然后将其收集回来。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，他在地带分配上的不公正性阻碍了他通往世界的道路-在网络世界中，纯轮循并未得到实施。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WRR-加权循环 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WRR具有相同的命运，它基于IP优先级增加了队列的权重。</font><font style="vertical-align: inherit;">在WRR中，不是取出相等数量的数据包，而是队列权重的倍数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以为具有较小数据包的队列赋予更大的权重，但是动态地做到这一点是不可能的。</font></font><br><br><img src="https://habrastorage.org/webt/lx/4b/an/lx4bancel1tl9stwbeay0s6n1ma.png" width="800"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DWRR-赤字加权循环法 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突然之间，M。Shreedhar和G. Varghese在1995年提出了一种非常奇怪的方法。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每行都有一个单独的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信用额度（</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以位为单位）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从队列中传递时，将发出尽可能多的信用包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从贷款额中减去队列开头的包裹大小。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果差异大于零，则删除此数据包并检查下一个数据包。因此直到差值小于零为止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果即使第一个包裹也没有足够的信誉，well ，,，泥泞不堪，他仍然会排队。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一次通过之前，每行的功劳会增加一定的量，称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">量子</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于不同的队列，量子量是不同的-您需要赋予的频带越大，量子量就越大。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，无论队列中数据包的大小如何，所有队列都将获得保证的带宽。</font></font><br><br><img src="https://habrastorage.org/webt/vr/hv/vk/vrhvvk-1opimw_vofynmrkosbv8.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从上面的解释中，我不清楚这是如何工作的。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们画出步骤...</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们分析一下球形情况： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRR（无W）， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4线 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在第0位，所有数据包各为500个字节， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1日-每个1000 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在2至1500年， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在第三个中放着一根4000欧元的香肠， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 量子-1600字节。 </font></font></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/64d/911/64e/64d91164edc5867e9009f54de10a50da.png"><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 周期1 </font></font></h5><br> <b> 1.  0</b> <br>   ,     1600  () <br>    0- .  : <br>      —  (1600 — 500 = 1100). <br>  —  —  (1100 — 500 = 600). <br>  —  —  (600 — 500 = 100). <br>  —    (100 — 500 = -400).    . <br>   — 100 . <br><br><img src="https://habrastorage.org/webt/9y/4x/al/9y4xalhqrwwayufvjfcxlfevl20.png"><br><br> <b> 1.  1</b> <br>    —  (1600 — 1000 = 600). <br>    (600 — 1000 = -400).    . <br>   — 600 . <br><br><img src="https://habrastorage.org/webt/yw/mr/qh/ywmrqhm_deusdb04dez-3gjermc.png"><br><br> <b> 1.  2</b> <br>    —  (1600 — 1500 = 100). <br>    (100 — 1000 = -900).    . <br>   — 100 . <br><br><img src="https://habrastorage.org/webt/aj/el/k6/ajelk6xd9tpkl70r5hgt6q9q2u0.png"><br><br> <b> 1.  3</b> <br>     . (1600 — 4000 = -2400). <br>    . <br>   —   1600 . <br><br><img src="https://habrastorage.org/webt/jw/fo/3e/jwfo3eobllx5--quzb9qqt3zt0c.png"><br><br> ,       : <br><br><ul><li>  0 — 1500 </li><li>  1 — 1000 </li><li>  2 — 1500 </li><li>  3 — 0 </li></ul><br>  : <br><br><ul><li>  0 — 100 </li><li>  1 — 600 </li><li>  2 — 100 </li><li>  3 — 1600 </li></ul><br><h5>  2 </h5><br>          —   1600 . <br><br> <b> 2.  0</b> <br>    1700 (100 + 1600). <br>       —   (1700 — 3*500 = 200). <br>     . <br>   — 200 . <br><br><img src="https://habrastorage.org/webt/4z/di/2s/4zdi2se_gcciq1rbfkqqzzrumsa.png"><br><br> <b> 2.  1</b> <br>    2200 (600 + 1600). <br>       —   (2200 — 2*1000 = 200). <br>    . <br>   — 200 . <br><img src="https://habrastorage.org/webt/9e/1z/sl/9e1zsl63ko7jxqjjuv4snupl6kw.png"><br><br> <b> 2.  2</b> <br>    1700 (100 + 1600). <br>      —   (2200 — 1500 = 200). <br>   —  . <br>   — 200 . <br><br><img src="https://habrastorage.org/webt/xf/v5/ni/xfv5nifo1wqvxfrhjqlfoygdk1w.png"><br><br> <b> 2.  3</b> <br>    3200 (1600 + 1600). <br>       (3200 — 4000 = -800) <br>   — 3200 . <br><img src="https://habrastorage.org/webt/wn/wj/pe/wnwjpenhub6ir2d8vi69oxan8-s.png"><br><br> ,       : <br><br><ul><li>  0 — 3000 </li><li>  1 — 3000 </li><li>  2 — 3000 </li><li>  3 — 0 </li></ul><br>  : <br><br><ul><li>  0 — 200 </li><li>  1 — 200 </li><li>  2 — 200 </li><li>  3 — 3200 </li></ul><br><h5>  3 </h5><br>          — 1600 . <br><br> <b> 3.  0</b> <br>    1800 (200 + 1600). <br>        —   (1800 — 3*500 = 300). <br>     . <br>   — 300 . <br><br><img src="https://habrastorage.org/webt/lk/sk/tq/lksktqj1g_7q6m2p8jwq0olnfuw.png"><br><br> <b> 3.  1</b> <br>    1800 (200 + 1600). <br>    —  (1800 — 1000 = 800). <br>   — 800 . <br><br><img src="https://habrastorage.org/webt/fg/bd/jd/fgbdjdmydatamvpzxome7reb5pc.png"><br><br> <b> 3.  2</b> <br>    1800 (200 + 1600). <br>    —  (1800 — 1500 = 300). <br>   — 300 . <br><br><img src="https://habrastorage.org/webt/s1/a7/iv/s1a7iv6mpfy1kesgzuazx9hsgkk.png"><br><br> <b> 3.  3</b> <br>    3-  ! <br>    4800 (3200 + 1600). <br>    —  (4800 — 4000 = 800). <br>   — 800 . <br><br><img src="https://habrastorage.org/webt/fm/fh/tn/fmfhtnvh1utrr0yovddsambv_fe.png"><br><br> ,       : <br><br><ul><li>  0 — 4500 </li><li>  1 — 4000 </li><li>  2 — 4500 </li><li>  3 — 4000 </li></ul><br>  : <br><br><ul><li>  0 — 300 </li><li>  1 — 800 </li><li>  2 — 300 </li><li>  3 — 800 </li></ul><br><img src="https://habrastorage.org/webt/q5/q9/pj/q5q9pjzqa1be-uluk_eucxwga9w.png"><br><br>     DRR.          . <br><br>    ,  . <br><br><img src="https://habrastorage.org/webt/5l/6o/nd/5l6onduvx4djvafmxj7bhsoxwwm.gif"><br><br>  DWRR  DRR   ,        ,   ,     . <br><br><hr><br>     DRR,        —    ,   . <br><br>     :  ,     .           . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于DWRR，问题仍然在于保证延迟和抖动-权重无法以任何方式解决。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从理论上讲，您可以执行与CB-WFQ相同的操作，添加LLQ。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，这只是当今日益流行的可能方案之一。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PB-DWRR-基于优先级的DWRR </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，当今的主流正在成为PB-DWRR-基于优先级的赤字加权循环法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这与旧的邪恶DWRR相同，在其中添加了另一个队列-优先级，其中以更高的优先级处理数据包。</font><font style="vertical-align: inherit;">这并不意味着给她更大的带子，而是要从那里更频繁地拿走包裹。</font></font><br><br><img src="https://habrastorage.org/webt/wg/6g/ui/wg6guiijtoscyckwdwr49gkp0fq.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有几种实现PB-DWRR的方法。</font><font style="vertical-align: inherit;">在某些情况下，如在PQ中一样，到达优先级队列的所有数据包都会立即被删除。</font><font style="vertical-align: inherit;">在其他情况下，调度程序每次在队列之间移动时都可以访问它。</font><font style="vertical-align: inherit;">第三，为此引入了信用和数量，从而优先级队列不能挤压整个条带。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，我们不会分析它们。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 调度机制的简短摘要 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几十年来，人类一直在努力解决最困难的问题，即确保适当的服务水平和公平分配乐队。队列是主要工具；唯一的问题是如何从队列中获取数据包，并将其推入一个接口。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从FIFO开始，它发明了PQ-声音能够与冲浪共存，但是毫无疑问要保证频段。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现了几个怪异的FQ，WFQ，即使不是按流运行，也是如此。 CB-WFQ进入了阶级社会，但这并没有变得容易。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为替代，他开发了RR。它成为WRR，然后成为DWRR。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每个调度员的深处都有FIFO。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，正如您所看到的，没有通用调度程序可以按需处理所有类。</font><font style="vertical-align: inherit;">它始终是调度程序的组合，其中一个解决了确保延迟，抖动和丢失少的问题，另一个解决了分配频带的问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBWFQ + LLQ或PB-WDRR或WDRR + PQ。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在实际设备上，您可以指定要与哪个调度程序一起处理的队列。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBWFQ，WDRR及其衍生物是当今的最爱。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PQ，FQ，WFQ，RR，WRR-我们不会感到悲伤和不记得（当然，除非我们正在为CCIE Clipper做准备）。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此，调度员能够保证速度，但如何从上方限制速度呢？ </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.速度限制 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 乍一看，限制流量速度的需求很明显-根据协议，不要让客户离开自己的乐队。 </font></font><br><br> 是的 但不仅如此。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设通过1Gb / s端口连接的RRL跨度为620 Mb / s。如果将整个千兆放入其中，那么RRL上的某个地方（很可能不了解队列和QoS）将开始出现随机性的巨大下降，而与流量的实际优先级无关。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果您在路由器上启用了高达600 Mb / s的整形，那么EF，CS6，CS7将完全不会被丢弃，在BE，AFx中，频段和丢包将根据其权重进行分配。 RRL将达到600 Mb / s，我们将获得可预测的图像。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个例子是准入控制。例如，除了CS7（如果CS7中有东西），两家运营商同意彼此信任彼此的标记。对于CS6和EF-单独分配一个队列，以确保延迟和不丢失。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果狡猾的合作伙伴开始将种子注入这些行呢？</font><font style="vertical-align: inherit;">再见电话。</font><font style="vertical-align: inherit;">协议很可能会崩溃。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，与合作伙伴就试条达成共识是合乎逻辑的。</font><font style="vertical-align: inherit;">符合合同的所有内容都会被跳过。</font><font style="vertical-align: inherit;">不适合的内容-丢弃或转移到另一个队列-例如BE。</font><font style="vertical-align: inherit;">因此，我们保护我们的网络和服务。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度限制有两种根本不同的方法：抛光和整形。</font><font style="vertical-align: inherit;">他们解决了一个问题，但是方式不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此类流量配置文件的示例来考虑差异：</font></font><br><br><img src="https://habrastorage.org/webt/5b/sj/st/5bsjstoglxkg7dspcxjrphdjsye.png" width="500"><br><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 流量监管 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警务通过丢弃多余的流量来限制速度。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超出设置值的所有内容，polyser都将被丢弃。</font></font><br><br><img src="https://habrastorage.org/webt/a3/dl/xa/a3dlxapkcptfnfejftde0qxycjc.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被割的东西被遗忘了。图片显示红色数据包在polyser之后没有流量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是在polyser之后选定的配置文件的样子：</font></font><br><br><img src="https://habrastorage.org/webt/jb/rw/52/jbrw52md7mynstgrt9-o1a1mo1s.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于所采取措施的严重性，这称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬监管</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，还有其他可能的操作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警察通常与流量表配合工作。如您所记得，仪表会以绿色，黄色或红色为袋子上色。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且已经基于此颜色，polyser可能不会丢弃该数据包，而是将其放在另一个类中。这些是软措施- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软策略</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它既可以应用于传入流量，也可以应用于传出流量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">polyser的一个独特功能是能够吸收流量突发并通过令牌桶机制确定最大允许速度。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就是说，实际上，不超过设定值的所有内容都不会被切断-允许超出设定值-跳过短脉冲或分配频带的少量过量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“管制”的名称由该工具与过剩流量的相当严格的比率决定-丢弃或降级到较低等级。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 流量整形 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整形通过缓冲多余的流量来限制速度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有传入的流量都通过缓冲区。整形器以恒定速度从此缓冲区中删除数据包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果数据包到达缓冲区的速率低于输出速率，则它们不会在缓冲区中延迟-它们会一直通过。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果到达率高于输出，则它们开始累积。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出速度始终相同。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，流量突发会添加到缓冲区中，并在到达队列时发送。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，与队列中的调度一起，整形是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导致总延迟</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的第二个工具</font><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/in/gc/vh/ingcvhgya0fzfiw2sxbeiix7hfw.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该图清楚地显示了到达时间t2的数据包如何在时间t3到达输出。</font><font style="vertical-align: inherit;">t3-t2是整形器引入的延迟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整形器通常应用于传出流量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是轮廓在修整器之后的外观。</font></font><br><br><img src="https://habrastorage.org/webt/iv/b7/sl/ivb7slyamvreja97npdjyr3ctwk.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名称“整形”表示该工具为路况配置文件提供形状，使其平滑。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种方法的主要优点是可以最佳地利用现有频段-我们不会推迟过多的流量，而是将其推迟了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主要缺点是无法预料的延迟-当缓冲区已满时，数据包将在其中滞留很长时间。</font><font style="vertical-align: inherit;">因此，整形不适用于所有类型的流量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整形使用“漏桶”机制。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 塑造与抛光 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">polyser的工作类似于一把刀，它沿着油的表面移动，切除了结节的锋利侧面。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整形器的工作类似于滚子，它使结节变得光滑，均匀地分布在表面上。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在缓存数据包时，Shaper尝试不丢弃数据包，但这会增加延迟。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抛光器不会引入延迟，但是更容易丢弃数据包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对延迟不敏感，但不希望损失的应用程序应限于整形器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于那些迟到的包裹与丢失的包裹相同的人，最好将其立即丢弃-然后进行抛光。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整形器不会影响包头及其在节点外部的命运，而抛光后，设备可以在头中对类进行重新分类。</font><font style="vertical-align: inherit;">例如，在输入端，数据包的等级为AF11，在设备内部通过计量将其涂成黄色，在输出端，数据包将其等级重新标记为AF12-在下一个节点，丢弃的可能性更高。</font></font><br><br><img src="https://habrastorage.org/webt/za/y6/kh/zay6khb7cgviroz-zbumfppdtz8.png" width="600"><br><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 练习抛光和整形 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案相同：</font></font><br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置文件。</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">观察此图片时没有施加限制：</font></font><br><br><img src="https://habrastorage.org/webt/mg/nz/mv/mgnzmvc_36gtmgf5t3vi0wob1uk.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将按以下步骤进行：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在输入接口Linkmeup_R2（e0 / 1）上，我们将配置抛光-这将是输入控件。</font><font style="vertical-align: inherit;">根据协议，我们给出10 Mb / s。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在输出接口Linkmeup_R4（e0 / 2）上，将整形配置为20 Mb / s。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linkmeup_R4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上的整形器开始</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">匹配所有内容：</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_ALL_CM match <span class="hljs-keyword"><span class="hljs-keyword">any</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 形状高达20Mb / s： </font></font><br><br><pre> <code class="hljs swift"> policy-<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> <span class="hljs-type"><span class="hljs-type">TRISOLARANS_SHAPING</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRISOLARANS_ALL_CM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shape</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">average</span></span></span><span class="hljs-class"> 20000000</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 适用于输出接口： </font></font><br><br><pre> <code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ethernet0</span></span></span><span class="hljs-class">/2 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">service</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">policy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">output</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRISOLARANS_SHAPING</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切应该离开（输出）Ethernet0 / 2接口的设备，形状最高可达20 Mb / s。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成型器配置文件。</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果如下：</font></font><br><br><img src="https://habrastorage.org/webt/tz/1i/sr/tz1isrb6mnjnirkxe46wbzed2yu.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，每个单独的流的总吞吐量和图形残缺都相当平坦。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实是，我们将整形器限制在常规范围内。</font><font style="vertical-align: inherit;">但是，根据平台的不同，单个流也可以单独成形，从而获得平等的机会。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在在Linkmeup_R2上配置抛光。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在现有政策中添加一个polyser。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-map TRISOLARANS_ADMISSION_CONTROL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_TCP_CM police cir <span class="hljs-number"><span class="hljs-number">10000000</span></span> bc <span class="hljs-number"><span class="hljs-number">1875000</span></span> conform-action transmit exceed-action <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该策略已应用于接口： </font></font><br><br><pre> <code class="hljs pgsql"> interface Ethernet0/<span class="hljs-number"><span class="hljs-number">1</span></span> service-<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> TRISOLARANS_ADMISSION_CONTROL</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们指出平均允许速度CIR（10Mb / s）和允许突发Bc（1,875,000字节，约14.6 MB）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稍后，在解释polyser的工作原理后，我将告诉您CIR和Bc是什么以及如何确定这些值。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyser配置文件。</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这张照片是通过聚晶观察的。</font><font style="vertical-align: inherit;">速度水平的突然变化是显而易见的：</font></font><br><br><img src="https://habrastorage.org/webt/wg/vb/iv/wgvbiv6biiv27f99npxfupqjdla.png" width="900"><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是，如果我们将允许的突发大小设置得太小，例如10,000字节，就会获得如此有趣的图像。 </font></font><br><br><pre> <code class="hljs powershell"> police cir <span class="hljs-number"><span class="hljs-number">10000000</span></span> bc <span class="hljs-number"><span class="hljs-number">10000</span></span> conform<span class="hljs-literal"><span class="hljs-literal">-action</span></span> transmit exceed<span class="hljs-literal"><span class="hljs-literal">-action</span></span> drop</code> </pre> <br><img src="https://habrastorage.org/webt/3a/cn/l0/3acnl01957rqgxcsonokebamdim.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整体速度立即下降到大约2Mb / s。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意脉冲串的设置:) </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试表。</font></font></a> <br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 漏斗和令牌桶 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">听起来很简单清晰。</font><font style="vertical-align: inherit;">但是它如何在实践中工作并在硬件中实现？</font></font><br><br> 一个例子。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">400 Mb / s的限制是否很多（或少一点）？</font><font style="vertical-align: inherit;">平均而言，一个客户端仅使用320。但是有时5分钟会上升到410。</font><font style="vertical-align: inherit;">有时高达每分钟460。</font><font style="vertical-align: inherit;">有时长达500秒。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如合同提供者linkmeup所说的-400就是这样！</font><font style="vertical-align: inherit;">如果您想要更多，请连接到1Gb / s + 27个动漫频道的资费。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果不增加这种影响，我们可以提高客户忠诚度。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何只允许一分钟460 Mb / s，而不是30或永远？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果频段是免费的，如何允许500 Mb / s，如果出现其他消费者，如何压至400 Mb / s？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在休息一下，倒一桶浓酒。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从成型机使用的更简单的机制开始-漏斗。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 漏斗算法 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">漏斗是漏斗。</font></font><br><br><img src="https://habrastorage.org/webt/te/qj/jv/teqjjvam2gz-gwlvfcfr1osqj5q.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一个在底部有给定尺寸的孔的水桶。将袋子从上方倒入/倒入该桶中。从下方开始，它们以恒定的比特率流动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当存储桶已满时，新的数据包开始被丢弃。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">孔的大小由指定的速度限制确定，对于漏斗，速度限制以每秒位数为单位进行测量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">铲斗的体积，饱满度和输出速度决定了整形机引入的延迟。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为方便起见，铲斗体积通常以ms或μs为单位。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在实现方面，“漏桶”是基于SD-RAM的常规缓冲区。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即使未明确配置整形，在没有传入接口的突发的情况下，数据包也会在接口释放时被临时缓冲和传输。</font><font style="vertical-align: inherit;">这也在塑造。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">漏斗仅用于整形，不适合抛光。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 令牌桶算法 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多人认为令牌桶和泄漏桶是同一回事。</font><font style="vertical-align: inherit;">只有爱因斯坦犯了错误，增加了宇宙常数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换芯片并不真正了解现在的时间，更糟糕的是每单位时间传输多少位。</font><font style="vertical-align: inherit;">他们的工作是脱粒。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是每秒接近400,000,000位，还是已经接近400,000 001？</font></font><br><br><img src="https://habrastorage.org/webt/kh/pu/i6/khpui6xw0sle9wconrc6ouoeedg.png" width="400"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASIC开发人员面临着不小的工程挑战。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它分为两个子任务：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过基于非常简单的条件丢弃不必要的数据包来实际限制速度。</font><font style="vertical-align: inherit;">在交换芯片上执行。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建此简单条件将处理更复杂（更专业）的芯片，并跟踪时间。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决第二个问题的算法称为令牌桶。</font><font style="vertical-align: inherit;">他的想法优雅而简单（不）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌桶的任务是在限制范围内通过流量，否则将其丢弃/涂上红色。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许流量爆发很重要，因为这是正常现象。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且，如果在“泄漏桶”中，突发是通过缓冲区进行缓冲的，那么令牌桶将不会缓冲任何内容。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单率-两种颜色标记 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，不要关注名称=）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一个桶，硬币以恒定的速度掉入其中-例如每秒400兆字节。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桶的数量是6亿个硬币。也就是说，它充满了一个半秒。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附近有两条传送带：一条传送包裹，第二条传送带。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要到达传送带，包裹必须付款。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，他根据自己的大小从桶中取出硬币。粗略地说-多少位-这么多硬币。</font></font><br><br><img src="https://habrastorage.org/webt/2m/lh/kz/2mlhkzj9j1vezkils69vlszdgc0.png" width="800"><br><br><img src="https://habrastorage.org/webt/hj/o5/nn/hjo5nn2u7omtuighgtohqpx1y1k.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果桶是空的并且袋子中没有足够的硬币，则将桶涂成红色信号色并丢弃。 las，Selyava。在这种情况下，不会从桶中取出硬币。</font></font><br><br><img src="https://habrastorage.org/webt/d-/bf/q9/d-bfq9l2tnj90-58kvi38zl3ufy.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个硬币包装可能已经足够了-首先，包装可能会更小，其次，在此期间它会攻击更多的硬币。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果存储桶已满，则所有新硬币将被丢弃。</font></font><br><br><img src="https://habrastorage.org/webt/cs/yn/yq/csynyq7ig1pfozdswqkxt59dt2e.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这完全取决于数据包的到达速率及其大小。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果它稳定地低于或等于每秒400 MB，则将始终有足够的硬币。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果更高，则某些数据包将丢失。</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们都喜欢的一个带有gif的更具体示例。 </font></font><br><br><img src="https://habrastorage.org/webt/o1/ds/ek/o1dsekpsi9nhg-plchkoivxrwm4.gif"><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个容量为2500字节的存储桶。</font><font style="vertical-align: inherit;">最初，它包含550个令牌。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管道上有三个要发送到接口的1000字节的数据包。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每个时隙中，有500个字节落入存储桶（500 * 8 = 4,000位/时隙-polyser限制）。</font></font></li><li>         500 .       .   1000 ,    1050  — <b></b> .       . 1000    . <br>    50 . </li><li>          500  —  550.     — 1000 — <b> </b> . <br>     ,   . </li><li>         500  —  1050.    — 1000 — <b></b> . <br>      ,    . </li></ul><br>    2500   ,             2500  —      .        MTU    ,      ,  ,  1,5-2 . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> : <br><br> CBS = CIR (  )*1,5 ()/8 (  ) <br><br>       ,     (Bc),   ,     (1 875 000 )    .    (10 000 ),   ,     MTU,           . <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么要用桶装水？比特流并不总是统一的，这是显而易见的。限制为400 Mb / s不是渐近线-流量可以穿越它。所存储硬币的数量允许小脉冲串飞过而不会被丢弃，但将平均速度保持在400Mb / s。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，在600秒内稳定的399 Mb / s的流量将使铲斗充满边缘。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，流量可以上升到1000Mb / s，并在此级别停留1秒钟-600 Mm（Megamonet）的库存和400 Mm / s的保证频带。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者，流量可以达到410 Mb / s，并保持60秒。</font></font><br><br><img src="https://habrastorage.org/webt/hq/yl/ib/hqylibyhmxkhepdt9mcf04m7rnk.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就是说，硬币的供应使您可以长时间长时间超出限制，或者抛出短暂但高昂的波动。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在到术语。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储桶中硬币的接收</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速率-CIR-承诺信息速率</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（保证的平均速度）。以每秒位数为单位。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以存储在存储桶中的硬币数量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-CBS承诺的突发大小</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。允许的最大突发大小。以字节为单位。您可能已经注意到，有时将其称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tc-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桶</font><font style="vertical-align: inherit;">（CBS）中的</font><font style="vertical-align: inherit;">硬币数量（令牌）</font><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/nm/rr/iv/nmrrivc2sdktqp4cfyhwfayjuze.png" width="600"><br><blockquote>      " <b>Tc</b> ",  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 2697</a> ( <i>A Single Rate Three Color Marker</i> ). <br>     Tc,    ,       . <br>    . <br>    ,    ,     Token Bucket,    <b>TDM</b> (Time-Division Multiplexing) —         . <br>          —  , , . <br>          CIR .    . <br>   ,    —   ,  —   ,  —   . <br>         ,      . <br>      (    Cisco) <b>Tc</b> ,     — <b>Bc</b> .   <b>Bc = CIR*Tc</b> . <br>       Tc    Bc . <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是最简单的情况。</font><font style="vertical-align: inherit;">它被称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单一速率-两种颜色</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“单一费率”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示只有一种平均允许速度，“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种颜色”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -您可以使用两种颜色之一对交通进行着色：绿色或红色。</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果存储桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中可用硬币（位数）</font><font style="vertical-align: inherit;">的数量大于此刻需要跳过的位数，则该数据包显示为绿色-将来掉线的可能性很小。</font><font style="vertical-align: inherit;">从桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中取出</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬币</font><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否则，包装将涂成红色-掉落的可能性很高（或更常见的是瞬间掉落）。</font><font style="vertical-align: inherit;">硬币从而桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C被撤回</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于PHB CS和EF中的抛光，在这些抛光中不会出现加速现象，但如果确实会出现加速现象，则最好立即将其丢弃。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，我们将考虑更困难：单率-三种颜色。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单率-三色标记 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先前方案的缺点是只有两种颜色。如果我们不想让一切都超出允许的平均速度，而是希望更加忠诚，该怎么办？</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中医-SR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单速率-三个颜色扣分</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）进入第二桶- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ë</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此时，硬币不会被放置在充满桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，倒入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ë</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">EBS已</font></b></font><br><br><img src="https://habrastorage.org/webt/xq/wq/fb/xqwqfblgko9sadvpv_zg2khhoma.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到CIR和CBS中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-超出突发大小</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -峰值期间允许的突发大小。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -硬币在桶数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ë</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/un/tb/1v/untb1vhnskpben6jqecdqinvx4q.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设有一个大小为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的数据包</font><font style="vertical-align: inherit;">沿着管道进入。</font></font>然后 <br><br><ol><li>     <b>C</b> ,      .   <b>C</b>  <b>B</b>  (: Tc — B). </li><li>     <b>C</b>  ,   <b>E</b> .     ,     (  ),   <b>E</b>  <b>B</b> . <br><br><img src="https://habrastorage.org/webt/oi/my/if/oimyif_nplc0auqsknrlbtatqe0.png" width="800"><br></li><li>     <b>E</b>   ,     ,    . <br><br><img src="https://habrastorage.org/webt/tn/44/ct/tn44ctwmh8zxmekxrr9y6sv4avm.png" width="800"><br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意，对于特定的封装，Tc和Te </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是累积的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，即使在存储桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有3000个硬币，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -7000个</font><font style="vertical-align: inherit;">硬币中</font><font style="vertical-align: inherit;">，一个8000字节大小的数据包也不会通过</font><font style="vertical-align: inherit;">。在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C中，这是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不够的，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E中，这是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不够的-我们从此处打上红色标记-shurai。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个非常优雅的设计。所有落在平均CIR + CBS限制之内的流量（作者知道不可能直接添加位/ s和字节）-变为绿色。在高峰时段，当客户</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桶中的硬币用完时，</font><font style="vertical-align: inherit;">在停机期间，他仍然在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桶中积累了Te库存</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，您可以略微跳过一些，但是在拥塞的情况下，它们更有可能被丢弃。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sr-TCM在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 2697中进行了</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于PHB AF中的抛光。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，最后一个系统是最灵活的，因此也是最复杂的-两个比率-三种颜色。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 二率-三色标记 </font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tr-TCM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型的</font><font style="vertical-align: inherit;">诞生是因为它不会损害其他用户和流量类型，为什么不给客户带来更多愉悦的机会或更好地销售。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">告诉他，保证给他400 Mb / s，如果有免费资源，则保证500 Mb / s。您准备多付30卢布吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加了另一个桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此：</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIR-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证平均速度。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是相同的允许飞溅大小（桶体积</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIR-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">峰值信息速率-最大平均速度。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBS-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">峰值期间允许的突发大小（桶体积</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与sr-TCM不同，在tr-TCM中，硬币现在独立地输送到两个桶中。</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以CIR的速度在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -PIR中。</font></font><br><br><img src="https://habrastorage.org/webt/xd/gk/_d/xdgk_dfz6sd-mw6lsw_adkipcve.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有什么规则？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个大小为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字节的</font><font style="vertical-align: inherit;">数据包到达</font><font style="vertical-align: inherit;">。</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果存储桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">没有足够的</font><font style="vertical-align: inherit;">硬币</font><font style="vertical-align: inherit;">，则该包将标记为红色。</font><font style="vertical-align: inherit;">硬币</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有被拔出</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font>否则： </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果存储桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">没有足够的</font><font style="vertical-align: inherit;">硬币</font><font style="vertical-align: inherit;">，则将数据包标记为黄色，然后</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储桶</font><b><font style="vertical-align: inherit;">P中取出B个</font></b><font style="vertical-align: inherit;">硬币</font><b><font style="vertical-align: inherit;">。</font></b></font>否则： </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包装上用绿色标记，并且从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个桶中抽出B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬币。</font></font></li></ol><br><img src="https://habrastorage.org/webt/xz/ac/xl/xzacxlryw2kkvf1ms-nkgufteba.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，tr-TCM中的规则是不同的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只要交通量处于保证的速度之内，就会从两个桶中都卸下硬币。</font><font style="vertical-align: inherit;">因此，当</font><font style="vertical-align: inherit;">硬币</font><font style="vertical-align: inherit;">在存储桶</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用完时，它们将保留在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但不会超过PIR（如果仅从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取出</font><font style="vertical-align: inherit;">，则</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会填满更多的东西并提供更快的速度）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，如果它高于保证水平但低于峰值，则仅从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中删除硬币</font><font style="vertical-align: inherit;">，因为在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中已经没有任何东西。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr-TCM不仅监视突发，而且还监视恒定的峰值速度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr-TCM在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 2698中进行了</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 也用于PHB AF中的抛光。 </font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 限速摘要 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整形会在流量超出时阻止流量，而抛光则会丢弃流量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整形不适用于对延迟和抖动敏感的应用。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了在硬件中实现抛光，使用令牌桶算法进行整形-泄漏桶。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌桶可以是：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一桶-单率-两种颜色标记。</font><font style="vertical-align: inherit;">允许有效的突发。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两个铲斗-单速-三色标记（sr-TCM）。</font><font style="vertical-align: inherit;">铲斗C（CBS）的多余部分倒入铲斗E。允许浪涌和冗余浪涌。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两个铲斗-两个等级-三个颜色标记（tr-TCM）。</font><font style="vertical-align: inherit;">铲斗C和P（PBS）以不同的速度独立补充。</font><font style="vertical-align: inherit;">允许峰值速度以及允许和过度的爆发。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sr-TCM着重于超出限制的流量。 tr-TCM-以到达的速度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在设备的输入和输出处使用抛光。成型主要在出口处。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于PHB CS和EF，使用单速率两种颜色标记。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于AF，sr-TCM或tr-TCM。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了更好地理解，我建议参考原始RFC或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读</font><font style="vertical-align: inherit;">。</font></font><br><blockquote>  Token Bucket     . ,       ,   ,       ,       . <br>     ,         — ,  .   ,    ,       ,    —  . <br>      ,     .          —   .         . <br></blockquote><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面，我介绍了QoS的所有基本机制，如果不深入介绍分层QoS。</font><font style="vertical-align: inherit;">复杂的系统，带有许多活动部件。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止一切都很好（对吗？）听起来不错，但是路由器的香草外部面板下发生了什么？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多年来，供应商一方面增加了轮廓，开发了先进的芯片，扩展了缓冲区，以适应不断增长的流量及其新类别，另一方面则解决了由第一段引起的日益增长的问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在进行的比赛。</font><font style="vertical-align: inherit;">如果竞争对手没有丢包，则一定不能丢包。</font><font style="vertical-align: inherit;">如果对手在客户的门下站着，您将无法拒绝其功能。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">艾达进入独资企业的巢穴！</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. QoS的硬件实现 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本章中，我承担了不感恩的任务。如果您尽可能简单地描述它，那么总会有人说现实并非如此。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果按原样描述，则读者会丢弃该文章，因为它将变成一张海底图画，更准确地说，是一张在一张纸上用不同颜色的铅笔绘制的三艘船的图画。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总的来说，我将声明现实中的一切与现实都不相同，并且我将按照一个简单演示的版本进行操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请原谅我的完美主义者。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是什么控制节点的行为并触发与包有关的适当机制？它在标题之一中具有优先级吗？</font></font>是的，没有。 <br><br><img src="https://habrastorage.org/webt/th/ie/l1/thiel1p000d6rgwchs-xo1hl4ys.png" width="250"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，在网络设备内，标准交换报头通常不复存在。</font></font><br><br><img src="https://habrastorage.org/webt/nj/h5/aq/njh5aquhoyypydjzrdttbespgr4.png" width="1000"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据包一到达交换芯片，就会立即从中删除标头并发送以进行分析，并且有效负载会在某种临时缓冲区中消失。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于标题，将进行分类（BA或MF），并做出有关转发的决定。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片刻之后，带有有关该程序包的元数据的内部标头被挂在该程序包上。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该元数据包含许多重要信息-发送方和接收方的地址，输出芯片，信元序列号，如果有数据包分段，则必须具有类标记（CoS）和丢弃优先级。仅以内部格式标记-它可能与DSCP一致，也可能不一致。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则上，在包装盒内您可以设置任意的标记长度，而不必依赖于标准，并且可以在包装中定义非常灵活的动作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在思科，内部标记称为QoS组，在瞻博网络-转发类，华为尚未决定：在其内部称为内部优先级，在本地优先级，在服务级以及仅在CoS的位置。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在评论中添加其他供应商的名称-我将添加。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据节点执行的分类来分配此内部标记。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是，除非另有说明，否则内部标签仅在节点内部起作用，而不会出现在将从节点发送的数据包的报头中的标签上-内部标签将保持不变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，在分类后进入DS域的入口处，通常对该网络中接受的特定服务类别进行重新标记。然后，内部标签将转换为网络上该类别所接受的值，并记录在要发送的数据包的报头中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoS和Drop Precedence内部标记仅在给定节点内定义行为，除非重新标记头，否则不会显式传递给邻居。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoS和丢弃优先级定义了PHB，其机制和参数：拥塞预防，拥塞管理，调度和重新标记。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过该圆通过我已经在所考虑的输入和输出接口之间的数据包</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的前条</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际上，事实证明这是计划外的，因​​为在某些时候，很明显，如果不了解体系结构，谈论QoS还为时过早。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，让我们重复一遍。</font></font><br><br><img src="https://habrastorage.org/webt/3k/s1/3e/3ks13e4uzagzrbopm5juuyun4j8.png" width="1000"><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信号到达物理输入接口及其芯片（PIC）。</font><font style="vertical-align: inherit;">比特流从中流过，然后是带有所有报头的数据包。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在输入交换芯片（FE）旁边，标头与数据包主体分开。</font><font style="vertical-align: inherit;">进行分类，并确定需要将数据包进一步发送到何处。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入队列旁边（TM / VOQ）。</font><font style="vertical-align: inherit;">此处已经根据包的类别将包布置在不同的队列中。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 到交换工厂（如果有）的地方。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在输出队列（TM）旁边。 </font></font></li><li>      (FE),    . </li><li>     (,    ) (PIC). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，路由器必须求解一个复杂的方程式。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将所有内容扩展到类中，为某人提供宽带，某人低延迟，某人确保没有损失。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且在可能的情况下，同时有时间跳过所有流量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，您需要进行整形，也可能需要抛光。</font><font style="vertical-align: inherit;">如果突然发生过载，请进行处理。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这不包括查找，ACL处理，统计信息的计数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令人羡慕的份额。</font><font style="vertical-align: inherit;">但是，机器人注入的不是人。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，QoS机制仅在两个地方起作用-交换芯片和流量管理芯片/队列。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同时，在交换芯片上进行的操作需要分析或对标头进行操作。</font></font><br><br><ul><li> 分类 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 打磨 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 重新贴标签 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TM负责其余的工作。</font><font style="vertical-align: inherit;">基本上，这些是具有预定义算法和自定义参数的常规操作：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预防拥塞 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 拥塞管理 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 塑形 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TM是一个智能缓冲区，通常基于SD-RAM。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他很聪明，因为，a）可编程，b）他可以使用队列来完成各种棘手的事情。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它通常是分布式的-SD-RAM芯片位于每个接口板上，并将它们组合在一起成为VOQ（虚拟输出队列），从而解决了行头阻塞问题。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实是，如果交换芯片或输出接口被阻塞，它们会要求输入芯片减速，并且一段时间内不发送流量。如果在所有方向上只有一个队列，那么所有其他队列都受一个输出接口的困扰是非常令人失望的。这是行阻塞的负责人。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入接口板上的VOQ为每个现有的输出接口创建多个虚拟输出队列。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，现代设备中的这些生产线还考虑了包装的标签。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关VOQ的详细说明，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的一系列说明</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，它们实际上是放置在队列中，正在被提升，不是从它们本身中取出数据包本身，而只是从它们中取出记录了。用大位数组进行这么多手势是没有意义的。当在记录上模拟QoS时，数据包完美地存储在它们的内存中，并从该地址处检索到。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VOQ是一个软件队列（英文术语Software Queue更准确）。在此之后，紧接在接口之前，还有一个硬件队列，该队列始终严格按照FIFO工作。几乎不可能控制其任何参数（例如，Cisco允许您使用tx-ring-limit命令仅配置深度）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在软件和硬件队列之间，您可以运行任意调度程序。 Head / Tail-drop和AQM，抛光和定型工作在程序队列中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬件队列的大小非常小（以数据包为单位），因为调度程序会完成所有堆叠线速的工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，您可以在这里进行很多保留，并确实用红笔划掉了所有内容，并说“供应商X并非如此”。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想再谈一下服务包。它们的处理方式不同于中转用户数据包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于是在本地生成的，因此不会检查它们是否符合ACL规则和速度限制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于协议类型，来自外部的数据包将从输出交换芯片发送给CPU，这些数据包进入其他队列-到达CPU。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，BFD具有最高优先级，OSPF可以等待更长的时间，并且ICMP通常不会令人恐惧。也就是说，数据包对于网络而言越重要，发送到CPU时其服务等级就越高。这就是为什么在ping或跟踪过程中在传输跃点上看到变化的延迟是正常的-ICMP不是CPU的优先级流量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，协议包被应用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoPP-控制平面保护</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或管制）-避免CPU高利用率的速度限制-同样，在问题开始之前，低优先级队列中的可预测下降更好。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当大量广播流量开始进入设备时，CoPP将从目标DoS和异常网络行为（例如环路）中获得帮助。</font></font><br><br><hr><br><h1> 有用的链接 </h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关QoS的理论和哲学的最佳书籍：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启用QOS的网络：工具和基础</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某些摘录可在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读</font><font style="vertical-align: inherit;">，但我建议从头至尾阅读，不要交换。</font></font></li><li>         QoS  Huawei: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Special Edition QoS(v6.0)</a> .        PHB   . </li><li>    sr-TCM  tr-TCM  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Understanding Single-Rate and Dual-Rate Traffic Policing</a> . </li><li>  VOQ: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">What is VOQ and why you should care?</a> </li><li>  QoS  MPLS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MPLS and Quality of Service</a> . </li><li>     QoS   Juniper: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Juniper CoS notes</a> . </li><li>   QoS       TCP  UDP.       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">The TCP/IP Guide</a> </li><li>    ,          ,       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">         TCP</a> . </li><li>    ,        FQ: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Queuing and Scheduling</a> . <br>      ,     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">An Introduction to Computer Networks</a> ,  ,     Introduction,      .    . <br></li><li>  WFQ  ,    , , ,   ,    : Weighted Fair Queueing: a packetized approximation for FFS/GP. <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，我也没有涉及LFI机制，因为在我们现有的100 GB接口中，这也很困难，但熟悉一下它可能会很有趣：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接分段和交织</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，RFC套件...</font></font></b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc791</a> ( <i>INTERNET PROTOCOL</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc1349</a> ( <i>Type of Service in the Internet Protocol Suite</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc1633</a> ( <i>Integrated Services in the Internet Architecture: an Overview</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc2474</a> ( <i>Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc2475</a> ( <i>An Architecture for Differentiated Services</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc2597</a> ( <i>Assured Forwarding PHB Group</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc2697</a> ( <i>A Single Rate Three Color Marker</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc2698</a> ( <i>A Two Rate Three Color Marker</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc3031</a> ( <i>Multiprotocol Label Switching Architecture</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc3168</a> ( <i>The Addition of Explicit Congestion Notification (ECN) to IP</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc3246</a> ( <i>An Expedited Forwarding PHB (Per-Hop Behavior)</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc3260</a> ( <i>New Terminology and Clarifications for Diffserv</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc3662</a> ( <i>A Lower Effort Per-Domain Behavior (PDB) for Differentiated Services</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc4594</a> ( <i>Configuration Guidelines for DiffServ Service Classes</i> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tools.ietf.org/html/rfc5462</a> ( <i>Multiprotocol Label Switching (MPLS) Label Stack Entry: «EXP» Field Renamed to «Traffic Class» Field</i> ) </li></ul><br></div></div><br><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此版本有许多评论者。 </font></font><br> 谢谢啦 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fatin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;">LoxmatiyMamont</font></a><font style="vertical-align: inherit;">）的介绍性文字和有关文本表达力和清晰度的宝贵建议。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Clipper（@ metallicat20）进行了同行评审。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亚历山大·克里姆年科（@ v00lk）提出了严厉的批评和最近几天发生的最大变化。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrey Glazkov（@glazgoo）对结构，术语和逗号进行了评论。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KDPV的Artyom Chernobay。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anton Klochkov（@NAT_GTX）与Miran联络。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Miran（miran.ru）用于用Eva组织服务器并进行广播。</font><font style="vertical-align: inherit;">传统上，我的家人这次遭受的损失最少，因为在最困难的时刻她不在附近。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420525/">https://habr.com/ru/post/zh-CN420525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420515/index.html">基于GMM-UBM模型和MAP自适应算法的数字化</a></li>
<li><a href="../zh-CN420517/index.html">FPGA整数FFT实现</a></li>
<li><a href="../zh-CN420519/index.html">科学普及</a></li>
<li><a href="../zh-CN420521/index.html">现在正式发布：TLS 1.3被认可为标准</a></li>
<li><a href="../zh-CN420523/index.html">二元期权图表分析或我再次向自己证明免费赠品不存在</a></li>
<li><a href="../zh-CN420527/index.html">可以发出微笑并具有感染力</a></li>
<li><a href="../zh-CN420529/index.html">提前使用Geeta还是六个月前如何退休？</a></li>
<li><a href="../zh-CN420533/index.html">使用Java 8方法参考模拟属性文字</a></li>
<li><a href="../zh-CN420537/index.html">关于扩音器如何相对诚实地赚钱的另一个故事</a></li>
<li><a href="../zh-CN420539/index.html">用于规范化和重置样式的自定义方法（custom-reset.css）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>