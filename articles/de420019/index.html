<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ä üíÉüèø üöì Client-Server-Interaktion in einem neuen mobilen PvP-Shooter und Spieleserver: Probleme und L√∂sungen ü§¶üèª üë©‚Äçüöí üë©üèø‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fr√ºheren Artikeln der Serie (alle Links am Ende des Artikels) √ºber die Entwicklung eines neuen schnellen Shooters haben wir die Mechanismen der Hau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Client-Server-Interaktion in einem neuen mobilen PvP-Shooter und Spieleserver: Probleme und L√∂sungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/420019/">  In fr√ºheren Artikeln der Serie (alle Links am Ende des Artikels) √ºber die Entwicklung eines neuen schnellen Shooters haben wir die Mechanismen der Hauptarchitektur der auf ECS basierenden Spielelogik und die Merkmale der Arbeit mit einem Shooter auf dem Client untersucht, insbesondere die Implementierung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systems zur Vorhersage lokaler Spieleraktionen</a> zur Steigerung der Reaktionsf√§higkeit des Spiels .  Dieses Mal werden wir uns eingehender mit Fragen der Client-Server-Interaktion unter Bedingungen einer schlechten Verbindung von Mobilfunknetzen und M√∂glichkeiten zur Verbesserung der Spielqualit√§t f√ºr den Endbenutzer befassen.  Ich werde auch kurz die Architektur des Spielservers beschreiben. <br><br><img src="https://habrastorage.org/webt/py/lp/8q/pylp8q_ki2el3odmsmd_h5ppqh0.jpeg"><br><a name="habracut"></a><br><br>  Bei der Entwicklung des neuen synchronen PvP f√ºr mobile Ger√§te stie√üen wir auf typische Probleme des Genres: <br><br><ol><li>  Die Verbindungsqualit√§t von mobilen Clients ist schlecht.  Dies ist ein relativ hoher durchschnittlicher Ping im Bereich von 200 bis 250 ms und eine instabile Zeitverteilung des Pings unter Ber√ºcksichtigung der √Ñnderung der Zugangspunkte (obwohl der Prozentsatz des Paketverlusts in 3G + Mobilfunknetzen entgegen der landl√§ufigen Meinung ziemlich niedrig ist - etwa 1%). </li><li>  Bestehende technische L√∂sungen sind monstr√∂se Frameworks, die Entwickler in enge Frameworks treiben. </li></ol><br>  Wir haben den ersten Prototyp bei UNet hergestellt, obwohl er die Skalierbarkeit, die Kontrolle √ºber die Netzwerkkomponente und die Abh√§ngigkeit von der launischen Verbindung von Master-Clients einschr√§nkte.  Dann haben wir auf einen selbst geschriebenen Netcode √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Photon Server</a> umgestellt, aber dazu sp√§ter mehr. <br><br>  Betrachten Sie die Mechanismen zum Organisieren von Interaktionen zwischen Clients in synchronen PvP-Spielen.  Die beliebtesten von ihnen: <br><br><ul><li>  <b>P2P oder Peer-to-Peer</b> .  Die gesamte Logik des Spiels wird auf einem der Kunden gehostet und erfordert von uns fast keine Verkehrskosten.  Aufgrund des Spielraums f√ºr Betr√ºger und der hohen Anforderungen an den Kunden, der das Spiel ausrichtet, sowie der Einschr√§nkungen von NAT konnten wir diese L√∂sung jedoch nicht f√ºr ein Handyspiel verwenden. </li><li>  <b>Client-Server</b> .  Im Gegensatz dazu k√∂nnen Sie mit einem dedizierten Server alles, was im Spiel passiert (auf Wiedersehen, Betr√ºger), vollst√§ndig kontrollieren, und mit seiner Leistung k√∂nnen Sie einige f√ºr unser Projekt spezifische Dinge berechnen.  Au√üerdem haben viele gro√üe Hosting-Anbieter eine eigene Subnetzstruktur, die dem Endbenutzer eine minimale Verz√∂gerung bietet. </li></ul><br>  Es wurde beschlossen, einen autorit√§ren Server zu schreiben. <br><br><img src="https://habrastorage.org/webt/x4/a4/ku/x4a4kunfi3lnbjqeghpddh-hsz8.jpeg"><br>  <i>Netzwerk mit Peer-to-Peer (links) und Client-Server (rechts)</i> <br><br>
<h3>  Daten√ºbertragung zwischen Client und Server </h3><br>  Wir verwenden <b>Photon Server</b> - dies erm√∂glichte es uns, die f√ºr das Projekt erforderliche Infrastruktur schnell auf der Grundlage eines Schemas bereitzustellen, das bereits im Laufe der Jahre ausgearbeitet wurde (in War Robots verwenden wir es). <br><br>  Photon Server ist f√ºr uns ausschlie√ülich eine Transportl√∂sung ohne High-Level-Designs, die stark an eine bestimmte Spiel-Engine gebunden sind.  Dies bietet einige Vorteile, da die Daten√ºbertragungsbibliothek jederzeit ausgetauscht werden kann. <br><br>  Der Spieleserver ist eine Multithread-Anwendung im Photon-Container.  F√ºr jede √úbereinstimmung wird ein separater Stream erstellt, der die gesamte Arbeitslogik zusammenfasst und den Einfluss einer √úbereinstimmung auf eine andere verhindert.  Alle Serververbindungen werden von Photon gesteuert, und die von Clients eingehenden Daten werden der Warteschlange hinzugef√ºgt, die dann in ECS analysiert wird. <br><br><img src="https://habrastorage.org/webt/j-/ws/wm/j-wswmt08qutnwc1jha0dgazkfo.jpeg"><br>  <i>Allgemeines Schema der √úbereinstimmungsstr√∂me im Photon Server-Container</i> <br><br>  Jedes Spiel besteht aus mehreren Phasen: <br><br><ol><li>  Der Spielclient stellt sich im sogenannten Match-Making-Service in die Warteschlange.  Sobald die erforderliche Anzahl von Spielern, die bestimmte Bedingungen erf√ºllen, darin gesammelt ist, meldet er dies dem Spielserver unter Verwendung von gRPC.  Gleichzeitig werden alle zum Erstellen des Spiels erforderlichen Daten √ºbertragen. <br><br><img src="https://habrastorage.org/webt/e_/rq/qp/e_rqqp5kiwrz-mxwbtkeuqptfpy.jpeg"><br>  <i>Allgemeines Schema zum Erstellen einer √úbereinstimmung</i> </li><li>  Auf dem Spielserver beginnt die Initialisierung des Spiels.  Alle Match-Parameter werden verarbeitet und vorbereitet, einschlie√ülich Kartendaten sowie aller Kundendaten, die vom Match-Erstellungsservice empfangen wurden.  Das Verarbeiten und Vorbereiten von Daten bedeutet, dass wir alle erforderlichen Daten analysieren und in eine spezielle Teilmenge von Entit√§ten schreiben, die wir RuleBook nennen.  Es speichert √úbereinstimmungsstatistiken (die sich w√§hrend des Verlaufs nicht √§ndern) und wird w√§hrend des Verbindungs- und Autorisierungsprozesses einmal oder beim erneuten Verbinden nach Verbindungsverlust an alle Clients √ºbertragen.  Zu den statischen √úbereinstimmungsdaten geh√∂ren die Kartenkonfiguration (Darstellung der Karte durch ECS-Komponenten, die sie mit der physischen Engine verbinden), Kundendaten (Spitznamen, eine Reihe von Waffen, die sie haben und die sie w√§hrend des Kampfes nicht √§ndern usw.). </li><li>  Ein Match laufen lassen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ECS-Systeme</a> , aus denen das Spiel auf dem Server besteht, beginnen zu funktionieren.  Alle Systeme ticken 30 Bilder pro Sekunde. </li><li>  Jeder Frame liest und entpackt die Eingaben oder Kopien des Spielers, wenn die Spieler ihre Eingaben nicht innerhalb eines bestimmten Intervalls gesendet haben. </li><li>  Dann wird im gleichen Rahmen die Eingabe im ECS-System verarbeitet, n√§mlich: √Ñnderung des Spielerstatus;  die Welt, die er mit seinem Input beeinflusst;  und den Status anderer Spieler. </li><li>  Am Ende des Frames wird der resultierende Weltzustand f√ºr den Player verpackt und √ºber das Netzwerk gesendet. </li><li>  Am Ende des Spiels werden die Ergebnisse an die Kunden und an den Microservice gesendet, der die Belohnungen f√ºr den Kampf mithilfe von gRPC verarbeitet, sowie an den Analysten f√ºr das Spiel. </li><li>  Danach keilt sich der Match-Flow und der Flow schlie√üt sich. </li></ol><br><img src="https://habrastorage.org/webt/02/8i/jl/028ijlnhor-evm6llkmfbiguf3s.jpeg"><br>  <i>Die Reihenfolge der Aktionen auf dem Server innerhalb eines Frames</i> <br><br>  Auf der Clientseite wird die Verbindung zu einem Match wie folgt hergestellt: <br><br><ol><li>  Zun√§chst wird eine Anforderung f√ºr die Warteschlange im Dienst zum Erstellen von √úbereinstimmungen √ºber den Websocket mit Serialisierung √ºber Protobuf gestellt. </li><li>  Beim Erstellen eines Spiels informiert dieser Dienst den Client √ºber die Adresse des Spielservers und √ºbertr√§gt die zus√§tzliche Nutzlast, die der Client vor dem Spiel ben√∂tigt.  Jetzt ist der Client bereit, den Autorisierungsprozess auf dem Spielserver zu starten. </li><li>  Der Client erstellt einen UDP-Socket und sendet eine Anforderung an den Spielserver, um zusammen mit einigen Anmeldeinformationen eine Verbindung zum Spiel herzustellen.  Der Server wartet bereits auf diesen Client.  Wenn er verbunden ist, gibt er ihm alle notwendigen Daten, um das Spiel zu starten und die Welt zum ersten Mal anzuzeigen.  Dazu geh√∂ren: RuleBook (eine Liste statischer Daten f√ºr das Spiel) sowie StringIntMap, die wir als Daten zu den im Spiel verwendeten Zeilen bezeichnen, die w√§hrend des Spiels durch Ganzzahlen identifiziert werden.  Dies ist notwendig, um Verkehr zu sparen, weil  Durch das √úbergeben von Linien in jedem Frame wird das Netzwerk erheblich belastet.  Beispielsweise werden alle Spielernamen, Klassennamen, Waffenkennungen, Konten und dergleichen in StringIntMap geschrieben, wo sie mit einfachen ganzzahligen Daten codiert werden. </li></ol><br>  Wenn ein Spieler andere Benutzer direkt beeinflusst (Schaden verursacht, Effekte anwendet usw.), wird auf dem Server ein Statusverlauf durchsucht, um die Spielwelt, die der Client in einem bestimmten Simulations-Tick tats√§chlich sieht, mit dem zu vergleichen, was zu diesem Zeitpunkt auf dem Server mit anderen passiert ist Spieleinheiten. <br><br>  Zum Beispiel schie√üen Sie auf Ihren Kunden.  F√ºr Sie geschieht dies sofort, aber der Kunde ist im Vergleich zur umgebenden Welt, die er anzeigt, bereits einige Zeit ‚Äûweggelaufen‚Äú.  Aufgrund der lokalen Vorhersage des Verhaltens des Spielers muss der Server daher verstehen, wo und in welchem ‚Äã‚ÄãZustand sich die Gegner zum Zeitpunkt des Schusses befanden (m√∂glicherweise waren sie bereits tot oder umgekehrt unverwundbar).  Der Server √ºberpr√ºft alle Faktoren und urteilt √ºber den verursachten Schaden. <br><br><img src="https://habrastorage.org/webt/os/fb/hh/osfbhh4iwrw6gk2hvtpqp8co2sw.jpeg"><br>  <i>Anfrage zum Erstellen eines Matches, Herstellen einer Verbindung zu einem Spieleserver und Autorisierung</i> <br><br><h3>  Serialisierung und Deserialisierung, Packen und Entpacken der ersten Bytes der √úbereinstimmung </h3><br>  Wir haben eine propriet√§re bin√§re Datenserialisierung und f√ºr die Daten√ºbertragung verwenden wir UDP. <br><br>  UDP ist die naheliegendste Option zum schnellen Senden von Nachrichten zwischen Client und Server. In der Regel ist es viel wichtiger, die Daten so schnell wie m√∂glich anzuzeigen, als sie im Prinzip anzuzeigen.  Verlorene Pakete nehmen Anpassungen vor, aber die Probleme werden f√ºr jeden Fall einzeln gel√∂st, wie  Da die Daten st√§ndig vom Client zum Server und zur√ºck kommen, k√∂nnen Sie das Konzept einer Verbindung zwischen dem Client und dem Server eingeben. <br><br>  Um einen optimalen und bequemen Code basierend auf der deklarativen Beschreibung der Struktur unseres ECS zu erstellen, verwenden wir die Codegenerierung.  Beim Erstellen von Komponenten werden auch Serialisierungs- und Deserialisierungsregeln f√ºr diese generiert.  Die Serialisierung basiert auf einem benutzerdefinierten Bin√§rpacker, mit dem Sie Daten auf wirtschaftlichste Weise packen k√∂nnen.  Der w√§hrend des Betriebs erhaltene Bytesatz ist nicht der optimalste, aber Sie k√∂nnen einen Stream erstellen, aus dem Sie einige Paketdaten lesen k√∂nnen, ohne dass eine vollst√§ndige Deserialisierung erforderlich ist. <br><br>  Das Daten√ºbertragungslimit von 1500 Byte (auch bekannt als MTU) ist in der Tat die maximale Paketgr√∂√üe, die √ºber Ethernet √ºbertragen werden kann.  Diese Eigenschaft kann f√ºr jeden Hop des Netzwerks und h√§ufig sogar unter 1500 Byte konfiguriert werden.  Was passiert, wenn ich ein Paket mit mehr als 1500 Byte sende?  Die Paketfragmentierung beginnt.  Das hei√üt,  Jedes Paket wird zwangsweise in mehrere Fragmente aufgeteilt, die separat von einer Schnittstelle zur anderen gesendet werden.  Sie k√∂nnen auf v√∂llig unterschiedlichen Wegen gesendet werden, und die Zeit zum Empfangen solcher Pakete kann sich erheblich verl√§ngern, bevor die Netzwerkschicht ein geklebtes Paket an Ihre Anwendung ausgibt. <br><br>  Im Fall von Photon beginnt die Bibliothek zwangsweise, solche Pakete im zuverl√§ssigen UDP-Modus zu senden.  Das hei√üt,  Photon wartet auf jedes Fragment des Pakets und leitet die fehlenden Fragmente weiter, wenn sie w√§hrend der Weiterleitung verloren gehen.  Eine solche Arbeit des Netzwerkteils ist jedoch in Spielen, in denen eine minimale Netzwerkverz√∂gerung erforderlich ist, nicht akzeptabel.  Daher wird empfohlen, die Gr√∂√üe der weitergeleiteten Pakete auf ein Minimum zu reduzieren und die empfohlenen 1500 Bytes nicht zu √ºberschreiten (in unserem Spiel √ºberschreitet die Gr√∂√üe eines vollst√§ndigen Zustands der Welt 1000 Bytes nicht; die Gr√∂√üe des Pakets mit Delta-Komprimierung betr√§gt 200 Bytes). <br><br>  Jedes Paket vom Server hat einen kurzen Header, der mehrere Bytes enth√§lt, die den Pakettyp beschreiben.  Der Client entpackt zuerst diesen Satz von Bytes und bestimmt, um welches Paket es sich handelt.  Wir verlassen uns bei der Autorisierung stark auf diese Eigenschaft unseres Deserialisierungsmechanismus: Um die empfohlene Paketgr√∂√üe von 1500 Byte nicht zu √ºberschreiten, unterteilen wir die Pakete RuleBook und StringIntMap in mehrere Stufen.  und um zu verstehen, was genau wir vom Server bekommen haben - die Spielregeln oder den Status selbst - verwenden wir den Paket-Header. <br><br>  Bei der Entwicklung neuer Funktionen des Projekts w√§chst die Paketgr√∂√üe stetig.  Als wir auf dieses Problem stie√üen, wurde beschlossen, ein eigenes Delta-Komprimierungssystem sowie ein kontextbezogenes Abschneiden von Daten zu schreiben, die der Client nicht ben√∂tigte. <br><br><h3>  Kontextsensitive Optimierung des Netzwerkverkehrs.  Delta-Komprimierung </h3><br>  Das Beschneiden von Kontextdaten wird manuell geschrieben, basierend auf den Daten, die der Client ben√∂tigt, um die Welt korrekt anzuzeigen, und der lokalen Vorhersage seiner eigenen Daten, um korrekt zu funktionieren.  Dann wird die Delta-Komprimierung auf die verbleibenden Daten angewendet. <br><br>  Unser Spiel jeder Tick erzeugt einen neuen Zustand der Welt, der verpackt und an die Kunden weitergegeben werden muss.  In der Regel besteht die Delta-Komprimierung darin, zuerst einen vollst√§ndigen Status mit allen erforderlichen Daten an den Client zu senden und dann nur √Ñnderungen an diesen Daten zu senden.  Dies kann wie folgt dargestellt werden: <br><br>  <i>deltaGameState = newGameState - prevGameState</i> <br><br>  F√ºr jeden Client werden jedoch unterschiedliche Daten gesendet, und der Verlust von nur einem Paket kann dazu f√ºhren, dass Sie den gesamten Status der Welt weiterleiten m√ºssen. <br><br>  Die Weiterleitung des gesamten Zustands der Welt ist eine ziemlich teure Aufgabe f√ºr das Netzwerk.  Aus diesem Grund haben wir den Ansatz ge√§ndert und die Differenz zwischen dem aktuell verarbeiteten Zustand der Welt und dem Zustand, der genau vom Kunden empfangen wird, gesendet.  Zu diesem Zweck sendet der Client in seinem Paket mit der Eingabe auch eine Tick-Nummer, die eine eindeutige Kennung des Spielstatus ist, den er bereits genau erhalten hat.  Jetzt wei√ü der Server anhand des Status, in dem die Delta-Komprimierung erstellt werden muss.  Der Client hat normalerweise keine Zeit, dem Server die angekreuzte Tick-Nummer zu senden, bevor der Server den n√§chsten Frame mit den Daten vorbereitet.  Daher gibt es auf dem Client einen Verlauf der Serverzust√§nde der Welt, auf den der vom Server generierte deltaGameState-Patch angewendet wird. <br><br><img src="https://habrastorage.org/webt/ji/uo/ka/jiuokasgdo-wgmgmzbmchlb1gvm.jpeg"><br>  <i>Darstellung der H√§ufigkeit der Client-Server-Interaktion im Projekt</i> <br><br>  Lassen Sie uns genauer darauf eingehen, was der Kunde sendet.  Bei klassischen Sch√ºtzen hei√üt ein solches Paket ClientCmd und enth√§lt Informationen √ºber die gedr√ºckten Tasten des Spielers und die Zeit, zu der das Team erstellt wurde.  Innerhalb des Eingabepakets senden wir viel mehr Daten: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputSample</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,        public uint WorldTick; // ,      ,     public uint PlayerSimulationTick; //   .  (idle, , ) public MovementMagnitude MovementMagnitude; //  ,   public float MovementAngle; //    public AimMagnitude AimMagnitude; //    public float AimAngle; //   ,       public uint ShotTarget; //    ,        public float AimMagnitudeCompressed; }</span></span></code> </pre> <br><br>  Es gibt einige interessante Punkte.  Zun√§chst teilt der Client dem Server mit, in welchem ‚Äã‚ÄãTick er alle Objekte der ihn umgebenden Spielwelt sieht, die er nicht vorhersagen kann (WorldTick).  Es scheint, dass der Kunde in der Lage ist, die Zeit f√ºr die Welt anzuhalten und alle aufgrund lokaler Vorhersagen selbst zu rennen und zu erschie√üen.  Es ist nicht so.  Wir vertrauen nur einem begrenzten Satz von Werten des Kunden und lassen ihn nicht l√§nger als 1 Sekunde in die Vergangenheit schie√üen.  Das WorldTick-Feld wird auch als Best√§tigungspaket verwendet, auf dessen Grundlage die Delta-Komprimierung erstellt wird. <br><br>  Sie k√∂nnen Gleitkommazahlen in einem Paket finden.  Normalerweise werden solche Werte h√§ufig verwendet, um Messwerte vom Joystick des Players zu erfassen. Sie werden jedoch nicht sehr gut √ºber das Netzwerk √ºbertragen, da sie einen gro√üen ‚ÄûSprung‚Äú aufweisen und normalerweise zu genau sind.  Wir quantisieren solche Zahlen und packen sie mit einem Bin√§rpacker, damit sie einen ganzzahligen Wert nicht √ºberschreiten, der je nach Gr√∂√üe in mehrere Bits passen kann.  Somit ist die Verpackung der Eingabe vom Ziel-Joystick unterbrochen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(s.AimMagnitudeCompressed) &lt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.Epsilon) { packer.PackByte(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { packer.PackByte(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> step = <span class="hljs-number"><span class="hljs-number">0.001f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000    , //          //     packer.PackUInt32((uint)((s.AimMagnitudeCompressed - min)/step), CalcFloatRangeBits(min, max, step)); }</span></span></code> </pre> <br><br>  Ein weiteres interessantes Merkmal beim Senden von Eingaben ist, dass einige Befehle mehrmals gesendet werden k√∂nnen.  Sehr oft werden wir gefragt, was zu tun ist, wenn eine Person die ultimative F√§higkeit gedr√ºckt hat und das Paket mit seiner Eingabe verloren gegangen ist.  Wir senden diese Eingabe nur mehrmals.  Dies sieht nach garantierter Lieferung aus, ist jedoch flexibler und schneller.  Weil  Die Gr√∂√üe des Eingangspakets ist sehr klein. Wir k√∂nnen mehrere benachbarte Player-Eing√§nge in das resultierende Paket packen.  Im Moment betr√§gt die Fenstergr√∂√üe, die ihre Anzahl bestimmt, f√ºnf. <br><br><img src="https://habrastorage.org/webt/gi/08/0g/gi080gxlym3kf7n801ah19gjeq8.jpeg"><br>  <i>Eingabepakete, die in jedem Tick auf dem Client generiert und an den Server gesendet werden</i> <br><br>  Die √úbertragung dieser Art von Daten ist am schnellsten und zuverl√§ssigsten genug, um unsere Probleme zu l√∂sen, ohne zuverl√§ssiges UDP zu verwenden.  Wir gehen von der Tatsache aus, dass die Wahrscheinlichkeit, eine solche Anzahl von Paketen hintereinander zu verlieren, sehr gering ist und ein Indikator f√ºr eine ernsthafte Verschlechterung der Qualit√§t des gesamten Netzwerks ist.  In diesem Fall kopiert der Server einfach die zuletzt vom Player empfangenen Eingaben und wendet sie an, in der Hoffnung, dass sie unver√§ndert bleiben. <br><br>  Wenn der Client feststellt, dass er sehr lange keine Pakete √ºber das Netzwerk empfangen hat, wird der Vorgang des erneuten Verbindens mit dem Server gestartet.  Der Server √ºberwacht seinerseits, dass die Eingabewarteschlange des Players vollst√§ndig ist. <br><br><h3>  Anstelle von Schlussfolgerung und Referenz </h3><br>  Es gibt viele andere Systeme auf dem Spieleserver, die f√ºr das Erkennen, Debuggen und Bearbeiten von √úbereinstimmungen verantwortlich sind. Spieleentwickler aktualisieren die Konfiguration, ohne den Status der Server neu zu starten, zu protokollieren und zu √ºberwachen.  Wir m√∂chten auch ausf√ºhrlicher dar√ºber schreiben, jedoch separat. <br><br>  Bei der Entwicklung eines Netzwerkspiels auf mobilen Plattformen sollten Sie zun√§chst auf den korrekten Betrieb Ihres Clients mit hohen Pings (ca. 200 ms), etwas h√§ufigerem Datenverlust sowie der Gr√∂√üe der gesendeten Daten achten.  Und Sie m√ºssen eindeutig in das Paketlimit von 1500 Byte passen, um Fragmentierung und Verkehrsverz√∂gerungen zu vermeiden. <br><br>  N√ºtzliche Links: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://gafferongames.com/post/udp_vs_tcp/</a> ist ein gro√üartiger Artikel zur Auswahl zwischen TCP und UDP f√ºr Netzwerkspiele. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://api.unrealengine.com/udk/Three/NetworkingOverview.html</a> - eine Beschreibung des Servermodells in Unreal Engine. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://ieeexplore.ieee.org/document/5360721</a> - Studie zur Netzwerkqualit√§t mobiler Verbindungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://ithare.com/mmog-rtt-input-lag-and-how-to-mitigate-them/</a> - Netzwerkinteraktion in schnelllebigen Spielen. </li></ul><br>  Fr√ºhere Artikel zum Projekt: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie wir uns auf einem mobilen Fast-Paced-Shooter bewegten: Technologie und Ans√§tze</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie und warum haben wir unser ECS geschrieben?"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420019/">https://habr.com/ru/post/de420019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420009/index.html">Die Feinheiten des Produktdesigns</a></li>
<li><a href="../de420011/index.html">So w√§hlen Sie einen 3D-Drucker aus: Ein Leitfaden f√ºr Anf√§nger</a></li>
<li><a href="../de420013/index.html">MAC-Adressensuche auf Juniper-Switches</a></li>
<li><a href="../de420015/index.html">So messen Sie die Geschwindigkeit des Internetkanals richtig und sehen in den Augen Ihres Anbieters nicht mehr wie ein Idiot aus</a></li>
<li><a href="../de420017/index.html">Die Kunst, Passw√∂rter zu sammeln</a></li>
<li><a href="../de420021/index.html">Warum brauchst du Splunk? Internet der Dinge und Industriedaten</a></li>
<li><a href="../de420023/index.html">Speichern von Status in Android-Anwendungen</a></li>
<li><a href="../de420025/index.html">Intelligente Farm. Wie wird sie sein?</a></li>
<li><a href="../de420029/index.html">Wie wir bei 1C: Enterprise Systeme algebraischer Gleichungen l√∂sen</a></li>
<li><a href="../de420031/index.html">Zeichnen mit Renderzielen in Unreal Engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>