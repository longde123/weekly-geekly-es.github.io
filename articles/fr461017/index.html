<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÇ üê∏ üïã Nouvel algorithme de suivi du GPU: suivi du chemin du front d'onde üìÇ üßúüèæ üïç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous explorons l'important concept utilis√© dans la plate-forme Lighthouse 2 r√©cemment publi√©e. Le tra√ßage de front d'onde , comme il...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouvel algorithme de suivi du GPU: suivi du chemin du front d'onde</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461017/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_x/t8/rw/_xt8rwehj6jymumaisqg5ehgkro.png"></div><br>  Dans cet article, nous explorons l'important concept utilis√© dans la plate-forme Lighthouse 2 r√©cemment publi√©e. Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tra√ßage de front d'onde</a> , comme il s'appelle Lane, Karras et Aila de NVIDIA, ou le tra√ßage de chemin en streaming, comme il √©tait initialement appel√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la th√®se de ma√Ætrise de</a> Van Antwerp, joue un r√¥le crucial dans le d√©veloppement de traceurs de chemin efficaces sur le GPU, et potentiellement de traceurs de chemin sur le CPU.  Cependant, il est assez contre-intuitif, donc, pour le comprendre, il est n√©cessaire de repenser les algorithmes de tra√ßage de rayons. <br><a name="habracut"></a><br><h2>  Occupation </h2><br>  L'algorithme de suivi de chemin est √©tonnamment simple et peut √™tre d√©crit en quelques lignes de pseudocode: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( vec3 O, vec3 D )</span></span></span><span class="hljs-function"> IntersectionData i </span></span>= Scene::Intersect( O, D ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == NoHit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec3( <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// ray left the scene if (i == Light) return i.material.color // lights do not reflect vec3 R, pdf = RandomDirectionOnHemisphere( i.normal ), 1 / 2PI return Trace( i.position, R ) * i.BRDF * dot( i.normal, R ) / pdf</span></span></code> </pre> <br>  L'entr√©e est le <em>rayon principal</em> passant de la cam√©ra au pixel de l'√©cran.  Pour ce faisceau, nous d√©terminons l'intersection la plus proche avec la primitive de sc√®ne.  S'il n'y a pas d'intersections, le faisceau dispara√Æt dans le vide.  Sinon, si le faisceau atteint la source de lumi√®re, alors nous avons trouv√© le chemin lumineux entre la source et la cam√©ra.  Si nous trouvons autre chose, nous effectuons alors une r√©flexion et une r√©cursivit√©, en esp√©rant que le faisceau r√©fl√©chi trouvera toujours la source d'√©clairage.  Notez que ce processus ressemble au chemin (de retour) d'un photon se refl√©tant sur la surface d'une sc√®ne. <br><br>  Les GPU sont con√ßus pour effectuer cette t√¢che en mode multithread.  Au d√©but, il pourrait sembler que le lancer de rayons est id√©al pour cela.  Donc, nous utilisons OpenCL ou CUDA pour cr√©er un flux pour un pixel, chaque flux ex√©cute un algorithme qui fonctionne r√©ellement comme pr√©vu, et est assez rapide: il suffit de regarder quelques exemples avec ShaderToy pour comprendre √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quelle</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vitesse le</a> lancer de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rayons</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√™tre</a> sur le GPU.  Quoi qu'il en soit, la question est diff√©rente: ces traceurs de rayons sont-ils vraiment <em>aussi rapides que possible</em> ? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/61d/07d/ce561d07daa3437927ab8ad5a6744ec9.jpg"></div><br>  Cet algorithme a un probl√®me.  Le rayon primaire peut trouver la source lumineuse imm√©diatement, ou apr√®s une r√©flexion al√©atoire, ou apr√®s cinquante r√©flexions.  Le programmeur du CPU remarquera un d√©bordement de pile potentiel ici;  le programmeur GPU devrait voir <em>le probl√®me d'occupation</em> .  Le probl√®me est caus√© par une r√©cursion de queue conditionnelle: le chemin peut se terminer √† la source de lumi√®re ou continuer.  Transf√©rons cela √† de nombreux threads: certains threads s'arr√™teront et l'autre partie continuera √† fonctionner.  Apr√®s quelques r√©flexions, nous aurons plusieurs threads qui doivent continuer √† calculer, et la plupart des threads attendront que ces derniers threads finissent de fonctionner.  <em>L'emploi</em> est une mesure de la partie des threads GPU qui font un travail utile. <br><br>  Le probl√®me de l'emploi s'applique au mod√®le d'ex√©cution des p√©riph√©riques GPU SIMT.  Les flux sont organis√©s en groupes, par exemple, dans le GPU Pascal (classe d'√©quipement NVidia 10xx) 32 threads sont combin√©s en une <em>cha√Æne</em> .  Les threads dans warp ont un compteur de programme commun: ils sont ex√©cut√©s avec une √©tape fixe, donc chaque instruction de programme est ex√©cut√©e simultan√©ment par 32 threads.  SIMT signifie <em>single instruction multiple thread</em> , qui d√©crit bien le concept.  Pour un processeur SIMT, un code avec conditions est complexe.  Ceci est clairement indiqu√© dans la documentation officielle de Volta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/1c0/cb0/9bb1c0cb0c4916e8a7989edeb466d3dd.jpg"></div><br>  <i>Ex√©cution de code avec conditions dans SIMT.</i> <br><br>  Lorsqu'une certaine condition est vraie pour certains threads dans warp, les branches de l' <em>instruction if sont</em> s√©rialis√©es.  Une alternative √† l'approche ¬´tous les threads font la m√™me chose¬ª est ¬´certains threads sont d√©sactiv√©s¬ª.  Dans le bloc if-then-else, l'occupation moyenne de la cha√Æne sera de 50%, sauf si tous les threads ont une coh√©rence concernant la condition. <br><br>  Malheureusement, le code avec des conditions dans le ray tracer n'est pas si rare.  Des rayons d'ombres ne sont √©mis que si la source de lumi√®re n'est pas derri√®re le point d'ombrage, diff√©rents chemins peuvent entrer en collision avec diff√©rents mat√©riaux, l'int√©gration avec la m√©thode de la roulette russe peut d√©truire ou laisser le chemin en vie, etc.  Il s'av√®re que l'occupation devient la principale source d'inefficacit√©, et il n'est pas si facile de la pr√©venir sans mesures d'urgence. <br><br><h2>  Suivi du chemin de streaming </h2><br>  L'algorithme de suivi du chemin de diffusion en continu est con√ßu pour traiter la cause premi√®re du probl√®me occup√©.  Le tra√ßage de chemin de streaming divise l'algorithme de tra√ßage de chemin en quatre √©tapes: <br><br><ol><li>  <strong>G√©n√©rer</strong> </li><li>  <strong>√âtendre</strong> </li><li>  <strong>Ombre</strong> </li><li>  <strong>Connecter</strong> </li></ol><br>  Chaque √©tape est mise en ≈ìuvre comme un programme distinct.  Par cons√©quent, au lieu d'ex√©cuter un traceur de chemin complet en tant que programme GPU unique (¬´noyau¬ª, noyau), nous devrons travailler avec <em>quatre</em> c≈ìurs.  De plus, comme nous le verrons bient√¥t, ils sont ex√©cut√©s en boucle. <br><br>  <b>L'√©tape 1 (¬´G√©n√©rer¬ª)</b> est responsable de la g√©n√©ration des rayons primaires.  Il s'agit d'un noyau simple qui cr√©e les points de d√©part et les directions des rayons en une quantit√© √©gale au nombre de pixels.  La sortie de cette √©tape est un grand tampon de rayons et un compteur informant la prochaine √©tape du nombre de rayons √† traiter.  Pour les rayons primaires, cette valeur est √©gale √† la <em>largeur de l'√©cran</em> multipli√©e par la <em>hauteur de l'√©cran</em> . <br><br>  <strong>L'√©tape 2 (¬´Renouveler¬ª)</strong> est le deuxi√®me noyau.  Il n'est ex√©cut√© qu'apr√®s la fin de l'√©tape 1 pour tous les pixels.  Le noyau lit le tampon g√©n√©r√© √† l'√©tape 1 et traverse chaque rayon avec la sc√®ne.  La sortie de cette √©tape est le r√©sultat de l'intersection pour chaque rayon stock√© dans le tampon. <br><br>  <strong>L'√©tape 3 ("Shadow")</strong> est effectu√©e apr√®s l'ach√®vement de l'√©tape 2. Elle re√ßoit le r√©sultat de l'intersection de l'√©tape 2 et calcule le mod√®le d'ombrage pour chaque chemin.  Cette op√©ration peut ou non g√©n√©rer de nouveaux rayons, selon que le chemin est termin√© ou non.  Les chemins qui g√©n√®rent le nouveau rayon (le chemin ¬´s'√©tend¬ª) √©crit le nouveau rayon (le ¬´segment de chemin¬ª) dans le tampon.  Les chemins qui √©chantillonnent directement les sources de lumi√®re (¬´√©chantillonnent explicitement l'√©clairage¬ª ou ¬´calculent l'√©v√©nement suivant¬ª) √©crivent un faisceau d'ombre dans un deuxi√®me tampon. <br><br>  <strong>L'√©tape 4 (¬´Connect¬ª)</strong> trace les rayons d'ombre g√©n√©r√©s √† l'√©tape 3. Ceci est similaire √† l'√©tape 2, mais avec une diff√©rence importante: les rayons de l'ombre doivent trouver <em>n'importe quelle</em> intersection, tandis que les rayons qui s'√©tendent doivent trouver l'intersection la plus proche.  Par cons√©quent, un noyau distinct a √©t√© cr√©√© pour cela. <br><br>  Apr√®s avoir termin√© l'√©tape 4, nous obtenons un tampon contenant des rayons qui √©tendent le chemin.  Apr√®s avoir pris ces rayons, nous passons √† l'√©tape 2. Nous continuons √† le faire jusqu'√† ce qu'il n'y ait pas de rayons d'extension ou jusqu'√† ce que nous atteignions le nombre maximal d'it√©rations. <br><br><h2>  Sources d'inefficacit√© </h2><br>  Un programmeur soucieux des performances verra beaucoup de moments dangereux dans un tel sch√©ma d'algorithmes de tra√ßage de chemin de streaming: <br><br><ul><li>  Au lieu d'un seul appel de noyau, nous avons maintenant <em>trois appels par it√©ration</em> , plus un noyau de g√©n√©ration.  D√©fier les c≈ìurs signifie une certaine augmentation de la charge, donc c'est mauvais. </li><li>  Chaque c≈ìur lit un √©norme tampon et √©crit un √©norme tampon. </li><li>  Le CPU a besoin de savoir combien de threads g√©n√©rer pour chaque c≈ìur, donc le GPU doit dire au CPU combien de rayons ont √©t√© g√©n√©r√©s √† l'√©tape 3. Le d√©placement des informations du GPU vers le CPU est une mauvaise id√©e, et cela doit √™tre fait au moins une fois par it√©ration. </li><li>  Comment l'√©tape 3 √©crit-elle les rayons dans le tampon sans cr√©er d'espace partout?  Il n'utilise pas de compteur atomique pour √ßa? </li><li>  Le nombre de chemins actifs diminue toujours, alors comment ce sch√©ma peut-il aider du tout? </li></ul><br>  Commen√ßons par la derni√®re question: si nous transf√©rons un million de t√¢ches vers le GPU, il ne g√©n√©rera pas un million de threads.  Le nombre r√©el de threads ex√©cut√©s simultan√©ment d√©pend de l'√©quipement, mais dans le cas g√©n√©ral, des dizaines de milliers de threads sont ex√©cut√©s.  Ce n'est que lorsque la charge tombe en dessous de ce nombre que nous remarquerons des probl√®mes d'emploi caus√©s par un petit nombre de t√¢ches. <br><br>  Une autre pr√©occupation concerne les E / S √† grande √©chelle des tampons.  C'est en effet une difficult√©, mais pas aussi grave que vous ne le pensez: l'acc√®s aux donn√©es est hautement pr√©visible, en particulier lors de l'√©criture dans des tampons, donc le retard ne pose pas de probl√®me.  En fait, les GPU ont √©t√© principalement d√©velopp√©s pour ce type de traitement de donn√©es. <br><br>  Les compteurs atomiques sont un autre aspect que les GPU g√®rent tr√®s bien, ce qui est assez inattendu pour les programmeurs travaillant dans le monde du CPU.  Le z-buffer n√©cessite un acc√®s rapide et, par cons√©quent, la mise en ≈ìuvre de compteurs atomiques dans les GPU modernes est extr√™mement efficace.  En pratique, une op√©ration d'√©criture atomique est tout aussi co√ªteuse qu'une √©criture non mise en cache dans la m√©moire globale.  Dans de nombreux cas, le retard sera masqu√© par une ex√©cution parall√®le √† grande √©chelle dans le GPU. <br><br>  Deux questions demeurent: les appels du noyau et le transfert de donn√©es bidirectionnel pour les compteurs.  Ce dernier est en fait un probl√®me, nous avons donc besoin d'un autre changement architectural: <em>les threads persistants</em> . <br><br><h2>  Les cons√©quences </h2><br>  Avant de plonger dans les d√©tails, nous examinerons les implications de l'utilisation de l'algorithme de tra√ßage de chemin de front d'onde.  Tout d'abord, disons √† propos des tampons.  Nous avons besoin d'un tampon pour sortir les donn√©es de l'√©tape 1, c'est-√†-dire  rayons primaires.  Pour chaque poutre, nous avons besoin de: <br><br><ul><li>  Origine du rayon: trois valeurs flottantes, soit 12 octets </li><li>  Direction du rayon: trois valeurs flottantes, soit 12 octets </li></ul><br>  En pratique, il est pr√©f√©rable d'augmenter la taille du tampon.  Si vous stockez 16 octets pour le d√©but et la direction du faisceau, le GPU pourra les lire en une seule op√©ration de lecture de 128 bits.  Une alternative est une op√©ration de lecture 64 bits suivie d'une op√©ration 32 bits pour obtenir float3, ce qui est presque deux fois plus lent.  Autrement dit, pour un √©cran de 1920 √ó 1080, nous obtenons: 1920x1080x32 = ~ 64 Mo.  Nous avons √©galement besoin d'un tampon pour les r√©sultats d'intersection cr√©√©s par le noyau Extend.  Il s'agit d'un autre 128 bits par √©l√©ment, soit 32 Mo.  De plus, le noyau ¬´Shadow¬ª peut cr√©er jusqu'√† 1920 √ó 1080 extensions de chemin (limite sup√©rieure), et nous ne pouvons pas les √©crire dans le tampon √† partir duquel nous lisons.  C'est encore 64 Mo.  Et enfin, si notre traceur de chemin √©met des rayons d'ombre, alors c'est un autre tampon de 64 Mo.  Apr√®s avoir tout r√©sum√©, nous obtenons 224 Mo de donn√©es, et ce uniquement pour l'algorithme de front d'onde.  Ou environ 1 Go en r√©solution 4K. <br><br>  Ici, nous devons nous habituer √† une autre fonctionnalit√©: nous avons beaucoup de m√©moire.  Cela peut sembler.  que 1 Go, c'est beaucoup, et il existe des moyens de r√©duire ce nombre, mais si vous approchez cela de mani√®re r√©aliste, alors au moment o√π nous avons vraiment besoin de tracer les chemins en 4K, l'utilisation de 1 Go sur un GPU avec 8 Go sera le moindre de nos probl√®mes. <br><br>  Plus grave que les besoins en m√©moire, les cons√©quences seront pour l'algorithme de rendu.  Jusqu'√† pr√©sent, j'ai sugg√©r√© que nous devons g√©n√©rer un rayon d'extension et, √©ventuellement, un rayon d'ombre pour chaque thread dans le noyau Shadow.  Mais que se passe-t-il si nous voulons effectuer une occlusion ambiante en utilisant 16 rayons par pixel?  16 rayons AO doivent √™tre stock√©s dans le tampon, mais, pire encore, ils n'appara√Ætront qu'√† la prochaine it√©ration.  Un probl√®me similaire se pose lors du tra√ßage des rayons dans le style Whited: √©mettre un faisceau d'ombre pour plusieurs sources de lumi√®re ou diviser un faisceau lors d'une collision avec du verre est presque impossible √† r√©aliser. <br><br>  D'un autre c√¥t√©, le suivi du chemin du front d'onde r√©sout les probl√®mes que nous avons r√©pertori√©s dans la section Occupation: <br><br><ul><li>  √Ä l'√©tape 1, tous les flux sans conditions cr√©ent des rayons primaires et les √©crivent dans le tampon. </li><li>  Au stade 2, tous les flux sans conditions coupent les rayons avec la sc√®ne et √©crivent les r√©sultats de l'intersection dans le tampon. </li><li>  √Ä l'√©tape 3, nous commen√ßons √† calculer les r√©sultats d'intersection avec 100% d'occupation. </li><li>  √Ä l'√©tape 4, nous traitons une liste continue de rayons d'ombre sans espaces. </li></ul><br>  Au moment o√π nous revenons √† l'√©tape 2 avec les rayons survivants d'une longueur de 2 segments, nous avons √† nouveau obtenu un tampon de rayons compact, qui garantit le plein emploi au d√©marrage du noyau. <br><br>  De plus, il existe un avantage suppl√©mentaire qui ne doit pas √™tre sous-estim√©.  Le code est isol√© en quatre √©tapes distinctes.  Chaque c≈ìur peut utiliser toutes les ressources GPU disponibles (cache, m√©moire partag√©e, registres) sans tenir compte des autres c≈ìurs.  Cela peut permettre au GPU d'ex√©cuter le code d'intersection avec la sc√®ne dans plus de threads, car ce code ne n√©cessite pas autant de registres que le code de shader.  Plus il y a de threads, mieux vous pouvez masquer les retards. <br><br>  Masquage des retards √† temps plein am√©lior√©, enregistrement en streaming: tous ces avantages sont directement li√©s √† l'√©mergence et √† la nature de la plate-forme GPU.  Pour le GPU, l'algorithme de suivi de chemin de front d'onde est tr√®s naturel. <br><br><h2>  Est-ce que √ßa vaut le coup? </h2><br>  Bien s√ªr, nous avons une question: un emploi optimis√© justifie-t-il les E / S des tampons et le co√ªt de l'appel de c≈ìurs suppl√©mentaires? <br><br>  La r√©ponse est oui, mais prouver que ce n'est pas si facile. <br><br>  Si nous revenons aux traceurs de piste avec ShaderToy pendant une seconde, nous verrons que la plupart d'entre eux utilisent une sc√®ne simple et cod√©e en dur.  Le remplacer par une sc√®ne √† part enti√®re n'est pas une t√¢che triviale: pour des millions de primitives, l'intersection du faisceau et la sc√®ne devient un probl√®me complexe, dont la solution est souvent laiss√©e √† NVidia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optix</a> ), AMD ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Radeon-Rays</a> ) ou Intel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embree</a> ).  Aucune de ces options ne peut facilement remplacer la sc√®ne cod√©e en dur dans le traceur de rayons artificiels CUDA.  Dans CUDA, l'analogue le plus proche (Optix) n√©cessite un contr√¥le sur l'ex√©cution du programme.  Embree dans le CPU vous permet de tracer des faisceaux individuels √† partir de votre propre code, mais le co√ªt de ceci est un surd√©bit de performance significatif: il pr√©f√®re tracer de grands groupes de faisceaux plut√¥t que des faisceaux individuels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/2a2/409/fb42a240924ba04871abb70421d16cdf.png"></div><br>  <i>√âcran de It's About Time rendu avec Brigade 1.</i> <br><br>  Le tra√ßage du chemin du front d'onde sera-t-il plus rapide que son alternative (le m√©gac≈ìur, comme Lane et ses coll√®gues l'appellent) d√©pend du temps pass√© dans les c≈ìurs (les grandes sc√®nes et les shaders co√ªteux r√©duisent le d√©passement de co√ªt relatif par l'algorithme du front d'onde), sur la longueur maximale du chemin , l'emploi m√©ga-core et les diff√©rences de charge sur les registres en quatre √©tapes.  Dans une premi√®re version du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brigade Path Tracer original,</a> nous avons constat√© que m√™me une sc√®ne simple avec un m√©lange de surfaces r√©fl√©chissantes et Lambert fonctionnant sur la GTX480 avait avantage √† utiliser le front d'onde. <br><br><h2>  Tra√ßage de chemin de streaming dans le phare 2 </h2><br>  La plate-forme Lighthouse 2 poss√®de deux traceurs de tra√ßage de chemin de front d'onde.  Le premier utilise Optix Prime pour la mise en ≈ìuvre des √©tapes 2 et 4 (√©tapes de l'intersection des rayons et des sc√®nes);  dans le second, Optix est utilis√© directement pour impl√©menter cette fonctionnalit√©. <br><br>  Optix Prime est une version simplifi√©e d'Optix qui ne traite que de l'intersection d'un ensemble de faisceaux avec une sc√®ne compos√©e de triangles.  Contrairement √† la biblioth√®que Optix compl√®te, elle ne prend pas en charge le code d'intersection personnalis√© et ne recoupe que les triangles.  Cependant, c'est exactement ce qui est requis pour le traceur de chemin de front d'onde. <br><br>  Le traceur de chemin de front d'onde bas√© sur Optix Prime est impl√©ment√© dans <code>rendercore.cpp</code> projet <code>rendercore.cpp</code> .  L'initialisation d'Optix Prime commence dans la fonction <code>Init</code> et utilise <code>rtpContextCreate</code> .  La sc√®ne est cr√©√©e √† l'aide de <code>rtpModelCreate</code> .  Divers tampons de rayons sont cr√©√©s dans la fonction <code>SetTarget</code> l'aide de <code>rtpBufferDescCreate</code> .  Notez que pour ces tampons, nous fournissons les pointeurs de p√©riph√©rique habituels: cela signifie qu'ils peuvent √™tre utilis√©s √† la fois dans Optix et dans des c≈ìurs CUDA standard. <br><br>  Le rendu commence dans la m√©thode <code>Render</code> .  Pour remplir le tampon de rayon primaire, un noyau CUDA appel√© <code>generateEyeRays</code> .  Apr√®s avoir rempli le tampon, Optix Prime est appel√© √† l'aide de <code>rtpQueryExecute</code> .  Avec lui, les r√©sultats d'intersection sont √©crits dans <code>extensionHitBuffer</code> .  Notez que tous les tampons restent dans le GPU: √† l'exception des appels du noyau, il n'y a pas de trafic entre le CPU et le GPU.  L'√©tape ¬´Shadow¬ª est impl√©ment√©e dans le noyau d' <code>shade</code> CUDA habituel.  Son impl√©mentation est dans <code>pathtracer.cu</code> . <br><br>  Certains d√©tails d'impl√©mentation pour <code>optixprime_b</code> m√©ritent d'√™tre mentionn√©s.  Premi√®rement, les rayons d'ombre sont trac√©s en dehors du cycle du front d'onde.  C'est vrai: un rayon d'ombre n'affecte un pixel que s'il n'est pas bloqu√©, mais dans tous les autres cas, son r√©sultat n'est n√©cessaire nulle part ailleurs.  Autrement dit, le faisceau d'ombre est <em>jetable</em> , il peut √™tre trac√© √† tout moment et dans n'importe quel ordre.  Dans notre cas, nous utilisons cela en regroupant les rayons de l'ombre afin que le lot finalement trac√© soit le plus grand possible.  Cela a une cons√©quence d√©sagr√©able: avec <em>N</em> it√©rations de l'algorithme du front d'onde et <em>X</em> rayons primaires, la limite sup√©rieure du nombre de rayons d'ombre est √©gale √† <em>XN</em> . <br><br>  Un autre d√©tail est le traitement des diff√©rents compteurs.  Les √©tapes ¬´Renouveler¬ª et ¬´Ombre¬ª devraient savoir combien de chemins sont actifs.  Les compteurs pour cela sont mis √† jour dans le GPU (atomiquement), ce qui signifie qu'ils sont utilis√©s dans le GPU, m√™me sans retourner au CPU.  Malheureusement, dans l'un des cas, cela est impossible: la biblioth√®que Optix Prime doit conna√Ætre le nombre de rayons trac√©s.  Pour ce faire, nous devons renvoyer les informations des compteurs une fois par it√©ration. <br><br><h2>  Conclusion </h2><br>  Cet article explique ce qu'est le tra√ßage de chemin de front d'onde et pourquoi il est n√©cessaire d'effectuer efficacement le tra√ßage de chemin sur le GPU.  Son impl√©mentation pratique est pr√©sent√©e dans la plateforme Lighthouse 2, qui est open source et <a href="">disponible sur Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461017/">https://habr.com/ru/post/fr461017/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461005/index.html">Test pour l'entreprise: poser les bonnes questions lors de l'entretien</a></li>
<li><a href="../fr461007/index.html">Prise en main de l'analyseur statique PVS-Studio pour Visual C ++</a></li>
<li><a href="../fr461009/index.html">Comment faire un standard en 10 jours. Deuxi√®me partie Ennuyeux</a></li>
<li><a href="../fr461013/index.html">R√©servation d'une connexion Internet</a></li>
<li><a href="../fr461015/index.html">Vivez et apprenez. Partie 2. Universit√©: 5 ans ou 5 couloirs?</a></li>
<li><a href="../fr461019/index.html">Comment est la vie des d√©veloppeurs en Iran</a></li>
<li><a href="../fr461027/index.html">Java REPL vous n'avez pas ScriptEngine</a></li>
<li><a href="../fr461029/index.html">Un lac de donn√©es marketing - des tableaux monstrueux aux rapports et visualisations</a></li>
<li><a href="../fr461031/index.html">Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 1 - Cartes raster standard</a></li>
<li><a href="../fr461033/index.html">D'o√π vient cette config? [Debian / Ubuntu]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>