<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüíº ü•à ‚ôãÔ∏è OS1: um kernel primitivo no Rust para x86. Parte 3. Cart√£o de mem√≥ria, exce√ß√£o de falha de p√°gina, pilha e aloca√ß√µes üåò ‚èèÔ∏è üö∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Primeira parte 
 Segunda parte 


 O t√≥pico da conversa de hoje est√° trabalhando com mem√≥ria. Vou falar sobre como inicializar o diret√≥rio da p√°gina, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: um kernel primitivo no Rust para x86. Parte 3. Cart√£o de mem√≥ria, exce√ß√£o de falha de p√°gina, pilha e aloca√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446214/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primeira parte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segunda parte</a> </p><br><p>  O t√≥pico da conversa de hoje est√° trabalhando com mem√≥ria.  Vou falar sobre como inicializar o diret√≥rio da p√°gina, mapear a mem√≥ria f√≠sica, gerenciar o virtual e o heap da minha organiza√ß√£o para o alocador. </p><br><p>  Como disse no primeiro artigo, decidi usar p√°ginas de 4 MB para simplificar minha vida e n√£o ter que lidar com tabelas hier√°rquicas.  No futuro, espero ir para p√°ginas de 4 KB, como a maioria dos sistemas modernos.  Eu poderia usar um j√° pronto (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um alocador de blocos</a> ), mas escrever o meu pr√≥prio era um pouco mais interessante e eu queria entender um pouco mais como a mem√≥ria vive, ent√£o tenho algo a lhe dizer. </p><a name="habracut"></a><br><p> A √∫ltima vez que me deparei com o m√©todo setup_pd, dependente da arquitetura, e queria continuar com ele, no entanto, havia mais um detalhe que n√£o cobri no artigo anterior - sa√≠da VGA usando Rust e a macro println padr√£o.  Como sua implementa√ß√£o √© trivial, vou remov√™-lo sob o spoiler.  O c√≥digo est√° no pacote de depura√ß√£o. </p><br><div class="spoiler">  <b class="spoiler_title">Macro println</b> <div class="spoiler_text"><pre><code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> print { ($($arg:tt)*) =&gt; ($crate::debug::_print(<span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> println { () =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)); ($($arg:tt)*) =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; vga::VGA_WRITER.lock().write_fmt(args).unwrap(); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; <span class="hljs-comment"><span class="hljs-comment">// vga::VGA_WRITER.lock().write_fmt(args).unwrap(); }</span></span></code> </pre> </div></div><br><p>  Agora, com a consci√™ncia limpa, volto √† mem√≥ria. </p><br><h1 id="inicializaciya-direktorii-stranic">  Inicializa√ß√£o do diret√≥rio de p√°ginas </h1><br><p>  Nosso m√©todo kmain recebeu tr√™s argumentos como entrada, um dos quais √© o endere√ßo virtual da tabela de p√°ginas.  Para us√°-lo posteriormente para aloca√ß√£o e gerenciamento de mem√≥ria, voc√™ precisa designar a estrutura de registros e diret√≥rios.  Para x86, o diret√≥rio Page e a tabela Page s√£o descritas muito bem, ent√£o vou me limitar a um pequeno introdut√≥rio.  A entrada do diret√≥rio Page √© uma estrutura de tamanho de ponteiro, para n√≥s √© de 4 bytes.  O valor cont√©m um endere√ßo f√≠sico de 4KB da p√°gina.  O byte menos significativo do registro √© reservado para sinalizadores.  O mecanismo para converter um endere√ßo virtual em um f√≠sico se parece com o seguinte (no caso da minha granularidade de 4 MB, o deslocamento ocorre em 22 bits. Para outras granularidades, o deslocamento ser√° diferente e tabelas hier√°rquicas ser√£o usadas!): </p><br><blockquote>  Endere√ßo virtual 0xC010A110 -&gt; Obtenha o √≠ndice no diret√≥rio movendo o endere√ßo 22 bits para a direita -&gt; √≠ndice 0x300 -&gt; Obtenha o endere√ßo f√≠sico da p√°gina pelo √≠ndice 0x300, verifique sinalizadores e status -&gt; 0x1000000 -&gt; Leve os 22 bits inferiores do endere√ßo virtual como um deslocamento, adicione para o endere√ßo f√≠sico da p√°gina -&gt; 0x1000000 + 0x10A110 = endere√ßo f√≠sico na mem√≥ria 0x110A110 </blockquote><p>  Para acelerar o acesso, o processador usa o TLB - buffer lookaside de tradu√ß√£o, que armazena em cache os endere√ßos das p√°ginas. </p><br><p>  Ent√£o, aqui est√° como meu diret√≥rio e suas entradas s√£o descritos, e o pr√≥prio m√©todo setup_pd √© implementado.  Para escrever uma p√°gina, o m√©todo "construtor" √© implementado, o que garante o alinhamento em 4 KB e a configura√ß√£o de sinalizadores, al√©m de um m√©todo para obter o endere√ßo f√≠sico da p√°gina.  Um diret√≥rio √© apenas uma matriz de 1024 entradas de quatro bytes.  O diret√≥rio pode associar um endere√ßo virtual a uma p√°gina usando o m√©todo set_by_addr. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectoryEntry</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_phys_address</span></span></span></span>(address: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flags: PDEntryFlags) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { PDirectoryEntry((address <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) &amp; ADDRESS_MASK | flags.bits()) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flags</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; PDEntryFlags { PDEntryFlags::from_bits_truncate(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_address</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &amp; ADDRESS_MASK } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbg</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectory</span></span></span></span> { entries: [PDirectoryEntry; <span class="hljs-number"><span class="hljs-number">1024</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectory { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_by_addr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set(PDirectory::to_idx(logical_addr), entry); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] = entry; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { invalidate_page(idx); } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_logical_addr</span></span></span></span>(idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (idx &lt;&lt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_idx</span></span></span></span>(logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (logical_addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> PAGE_DIRECTORY: Mutex&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory&gt; = Mutex::new( <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC0000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory) } ); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pd</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> data = PAGE_DIRECTORY.lock(); *data = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(pd <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory); }</code> </pre> <br><p>  Desajeitadamente, tornei a inicializa√ß√£o est√°tica inicial um endere√ßo inexistente; portanto, ficaria grato se voc√™ me escrevesse como √© habitual na comunidade Rust fazer essas inicializa√ß√µes com a reatribui√ß√£o de links. </p><br><p>  Agora que podemos gerenciar p√°ginas a partir de c√≥digo de alto n√≠vel, podemos prosseguir para a compila√ß√£o da inicializa√ß√£o da mem√≥ria.  Isso acontecer√° em duas etapas: processando o cart√£o de mem√≥ria f√≠sico e inicializando o gerenciador virtual </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mb_magic { <span class="hljs-number"><span class="hljs-number">0x2BADB002</span></span> =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"multibooted v1, yeah, reading mb info"</span></span>); boot::init_with_mb1(mb_pointer); }, . . . . . . } memory::init();</code> </pre> <br><h1 id="karta-pamyati-grub-i-karta-fizicheskoy-pamyati-os1">  Cart√£o de mem√≥ria GRUB e cart√£o de mem√≥ria f√≠sica OS1 </h1><br><p>  Para obter um cart√£o de mem√≥ria do GRUB, no est√°gio de inicializa√ß√£o, defino o sinalizador correspondente no cabe√ßalho, e o GRUB me deu o endere√ßo f√≠sico da estrutura.  Eu o transportei da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o oficial</a> para a nota√ß√£o Rust e tamb√©m adicionei m√©todos para iterar confortavelmente no cart√£o de mem√≥ria.  A maior parte da estrutura do GRUB n√£o ser√° preenchida e, neste est√°gio, n√£o √© muito interessante para mim.  O principal √© que eu n√£o quero determinar a quantidade de mem√≥ria dispon√≠vel manualmente. </p><br><p>  Ao inicializar atrav√©s da inicializa√ß√£o m√∫ltipla, primeiro convertemos o endere√ßo f√≠sico em virtual.  Teoricamente, o GRUB pode posicionar a estrutura em qualquer lugar; portanto, se o endere√ßo se estender al√©m da p√°gina, voc√™ precisar√° alocar uma p√°gina virtual no diret√≥rio Page.  Na pr√°tica, a estrutura quase sempre fica pr√≥xima ao primeiro megabyte, que j√° alocamos no est√°gio de inicializa√ß√£o.  Por precau√ß√£o, verificamos a bandeira de que o cart√£o de mem√≥ria est√° presente e procedemos √† sua an√°lise. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot2; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_pointer</span></span></span></span>(mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-comment"><span class="hljs-comment">//if in first 4 MB - map to kernel address space if mb_pointer &lt; 0x400000 { arch::KERNEL_BASE | mb_pointer } else { arch::paging::allocate_page(mb_pointer, arch::MB_INFO_BASE, arch::paging::PDEntryFlags::PRESENT | arch::paging::PDEntryFlags::WRITABLE | arch::paging::PDEntryFlags::HUGE_PAGE ); arch::MB_INFO_BASE | mb_pointer } } pub fn init_with_mb1(mb_pointer: usize) { let ln_pointer = unsafe { process_pointer(mb_pointer) }; println!("mb pointer 0x{:X}", ln_pointer); let mb_info = multiboot::from_ptr(ln_pointer); println!("mb flags: {:?}", mb_info.flags().unwrap()); if mb_info.flags().unwrap().contains(multiboot::MBInfoFlags::MEM_MAP) { multiboot::parse_mmap(mb_info); println!("Multiboot memory map parsed, physical memory map has been built"); } else { panic!("MB mmap is not presented"); } }</span></span></code> </pre> <br><p>  Um cart√£o de mem√≥ria √© uma lista vinculada para a qual o endere√ßo f√≠sico inicial √© especificado na estrutura b√°sica (n√£o se esque√ßa de converter tudo em virtual) e o tamanho da matriz em bytes.  Voc√™ precisa percorrer a lista com base no tamanho de cada elemento, pois <em>teoricamente</em> seus tamanhos podem ser diferentes.  √â assim que a itera√ß√£o se parece: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> MultibootInfo { . . . . . . <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mmap</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, index: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry&gt; { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::arch::get_mb_pointer_base; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> base: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = get_mb_pointer_base(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry = (base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..index { iter = ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + ((*iter).size <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) - base) &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_lenght) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {} } <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(iter) } }</code> </pre> <br><p>  Ao analisar um cart√£o de mem√≥ria, iteramos na estrutura do GRUB e o convertemos em um bitmap, com o qual o OS1 trabalhar√° para gerenciar a mem√≥ria f√≠sica.  Decidi me limitar a um pequeno conjunto de valores dispon√≠veis para controle - livre, ocupado, reservado, indispon√≠vel, embora o GRUB e o BIOS forne√ßam mais op√ß√µes.  Portanto, iteramos sobre as entradas do mapa e convertemos seu estado dos valores do GRUB / BIOS em valores para OS1: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_mmap</span></span></span></span>(mbi: &amp;MultibootInfo) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmap_opt = mbi.get_mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = mmap_opt.unwrap(); crate::memory::physical::map((*mmap).addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, (*mmap).len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, translate_multiboot_mem_to_os1(&amp;(*mmap).mtype)); mmap_opt = mbi.get_mmap(i); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mmap_opt { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, _ =&gt; i += <span class="hljs-number"><span class="hljs-number">1</span></span>, } } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translate_multiboot_mem_to_os1</span></span></span></span>(mtype: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::memory::physical::{RESERVED, UNUSABLE, USABLE}; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mtype { &amp;MULTIBOOT_MEMORY_AVAILABLE =&gt; USABLE, &amp;MULTIBOOT_MEMORY_RESERVED =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_ACPI_RECLAIMABLE =&gt; RESERVED, &amp;MULTIBOOT_MEMORY_NVS =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_BADRAM =&gt; UNUSABLE, _ =&gt; UNUSABLE } }</code> </pre> <br><p>  A mem√≥ria f√≠sica √© gerenciada no m√≥dulo memory :: physical, para o qual chamamos o m√©todo map acima, passando o endere√ßo da regi√£o, seu comprimento e estado.  Todos os 4 GB de mem√≥ria potencialmente dispon√≠veis para o sistema e divididos em quatro p√°ginas de megabytes s√£o representados por dois bits em um bitmap, o que permite armazenar 4 estados para 1024 p√°ginas.  No total, essa constru√ß√£o leva 256 bytes.  Um bitmap leva a uma terr√≠vel fragmenta√ß√£o da mem√≥ria, mas √© compreens√≠vel e f√°cil de implementar, o que √© a principal coisa para o meu prop√≥sito. </p><br><p>  Vou remover a implementa√ß√£o de bitmap sob o spoiler para n√£o bagun√ßar o artigo.  A estrutura √© capaz de contar o n√∫mero de classes e liberar mem√≥ria, marcar p√°ginas por √≠ndice e endere√ßo e tamb√©m procurar por p√°ginas livres (isso ser√° necess√°rio no futuro para implementar o heap).  O cart√£o em si √© uma matriz de 64 elementos u32, para isolar os dois bits necess√°rios (blocos), √© usada a convers√£o para o chamado peda√ßo (√≠ndice na matriz, empacotamento de 16 blocos) e bloco (posi√ß√£o do bit no peda√ßo). </p><br><div class="spoiler">  <b class="spoiler_title">Bitmap de mem√≥ria f√≠sica</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESERVED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UNUSABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEAD: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0xDEAD</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysMemoryInfo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> total: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, used: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, reserved: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunks: [<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>], } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PhysMemoryInfo { <span class="hljs-comment"><span class="hljs-comment">// returns (chunk, page) pub fn find_free(&amp;self) -&gt; (usize, usize) { for chunk in 0..64 { for page in 0.. 16 { if ((self.chunks[chunk] &gt;&gt; page * 2) &amp; 3) ^ 3 == 3 { return (chunk, page) } else {} } } (DEAD, 0) } // marks page to given flag and returns its address pub fn mark(&amp;mut self, chunk: usize, block: usize, flag: usize) -&gt; usize { self.chunks[chunk] = self.chunks[chunk] ^ (3 &lt;&lt; (block * 2)); let mask = (0xFFFFFFFC ^ flag).rotate_left(block as u32 * 2); self.chunks[chunk] = self.chunks[chunk] &amp; (mask as u32); if flag == USED { self.used += 1; } else if flag == UNUSABLE || flag == RESERVED { self.reserved += 1; } else { if self.used &gt; 0 { self.used -= 1; } } (chunk * 16 + block) &lt;&lt; 22 } pub fn mark_by_addr(&amp;mut self, addr: usize, flag: usize) { let block_num = addr &gt;&gt; 22; let chunk: usize = (block_num / 16) as usize; let block: usize = block_num - chunk * 16; self.mark(chunk, block, flag); } pub fn count_total(&amp; mut self) { let mut count: usize = 0; for i in 0..64 { let mut chunk = self.chunks[i]; for _j in 0..16 { if chunk &amp; 0b11 != 0b11 { count += 1; } chunk = chunk &gt;&gt; 2; } } self.total = count; } pub fn get_total(&amp;self) -&gt; usize { self.total } pub fn get_used(&amp;self) -&gt; usize { self.used } pub fn get_reserved(&amp;self) -&gt; usize { self.reserved } pub fn get_free(&amp;self) -&gt; usize { self.total - self.used - self.reserved } }</span></span></code> </pre> </div></div><br><p>  E agora chegamos √† an√°lise de um elemento do mapa.  Se um elemento do mapa descrever uma √°rea de mem√≥ria menor que uma p√°gina de 4 MB ou igual a ela, marcaremos essa p√°gina como um todo.  Se houver mais - bata em peda√ßos de 4 MB e marque cada peda√ßo separadamente por recurs√£o.  No est√°gio de inicializa√ß√£o do bitmap, consideramos inacess√≠veis todas as se√ß√µes da mem√≥ria, para que, quando o cart√£o acabar, por exemplo, com 128 MB, as demais se√ß√µes sejam marcadas como inacess√≠veis. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> RAM_INFO: Mutex&lt;PhysMemoryInfo&gt; = Mutex::new(PhysMemoryInfo { total: <span class="hljs-number"><span class="hljs-number">0</span></span>, used: <span class="hljs-number"><span class="hljs-number">0</span></span>, reserved: <span class="hljs-number"><span class="hljs-number">0</span></span>, chunks: [<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>] }); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flag: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// if len &lt;= 4MiB then mark whole page with flag if len &lt;= 4 * 1024 * 1024 { RAM_INFO.lock().mark_by_addr(addr, flag); } else { let pages: usize = len &gt;&gt; 22; for map_page in 0..(pages - 1) { map(addr + map_page &lt;&lt; 22, 4 * 1024 * 1024, flag); } map(addr + (pages &lt;&lt; 22), len - (pages &lt;&lt; 22), flag); } }</span></span></code> </pre> <br><h1 id="kucha-i-upravlenie-ey">  Empilhe e gerencie-a </h1><br><p>  Atualmente, o gerenciamento de mem√≥ria virtual est√° limitado apenas ao gerenciamento de heap, pois o kernel n√£o sabe muito mais.  No futuro, √© claro, ser√° necess√°rio gerenciar toda a mem√≥ria, e esse pequeno gerente ser√° reescrito.  No entanto, no momento, tudo o que preciso √© de mem√≥ria est√°tica, que cont√©m o c√≥digo execut√°vel e a pilha, e mem√≥ria din√¢mica de heap, onde alocarei as estruturas para multithreading.  Alocamos mem√≥ria est√°tica no est√°gio de inicializa√ß√£o (e at√© agora limitamos 4 MB, porque o kernel se encaixa nelas) e, em geral, n√£o h√° problemas com isso agora.  Al√©m disso, nesta fase, eu n√£o tenho dispositivos DMA, ent√£o tudo √© extremamente simples, mas compreens√≠vel. </p><br><p>  Dei 512 MB do espa√ßo de mem√≥ria do kernel mais alto (0xE0000000) ao heap, armazenei o mapa de uso do heap (0xDFC00000) 4 MB mais baixo.  Eu uso um bitmap para descrever o estado, assim como para a mem√≥ria f√≠sica, mas existem apenas 2 estados nele - ocupado / livre.  O tamanho do bloco de mem√≥ria √© de 64 bytes - isso √© muito para pequenas vari√°veis ‚Äã‚Äãcomo u32, u8, mas, talvez, seja ideal para armazenar estruturas de dados.  Ainda assim, √© improv√°vel que precisamos armazenar vari√°veis ‚Äã‚Äã√∫nicas no heap, agora seu principal objetivo √© armazenar estruturas de contexto para multitarefa. </p><br><p>  Blocos de 64 bytes s√£o agrupados em estruturas que descrevem o estado de uma p√°gina inteira de 4 MB, para que possamos alocar pequenas e grandes quantidades de mem√≥ria para v√°rias p√°ginas.  Uso os seguintes termos: bloco - 64 bytes, pacote - 2 KB (um u32 - 64 bytes * 32 bits por pacote), p√°gina - 4 MB. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(packed)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeapPageInfo</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], }</span></span></code> </pre> <br><p>  Ao solicitar mem√≥ria de um alocador, considero tr√™s casos, dependendo da granularidade: </p><br><ul><li>  Uma solicita√ß√£o de mem√≥ria com menos de 2 KB veio do alocador.  Voc√™ precisa encontrar um pacote no qual ele estar√° livre [tamanho / 64, qualquer resto diferente de zero adiciona um] peda√ßos seguidos, marque esses peda√ßos como ocupados, retorne o endere√ßo do primeiro peda√ßo. </li><li>  Uma solicita√ß√£o veio do alocador para mem√≥ria com menos de 4 MB, mas com mais de 2 KB.  Voc√™ precisa encontrar uma p√°gina que tenha [tamanho / 2048, qualquer restante diferente de zero adicione um] pacotes seguidos.  Marque os pacotes [tamanho / 2048] como ocupados; se houver um restante, marque os peda√ßos [restantes] no √∫ltimo como ocupados. </li><li>  Uma solicita√ß√£o de mem√≥ria com mais de 4 MB veio do alocador.  Localize [tamanho / 4 Mi, qualquer saldo diferente de zero adiciona uma] p√°gina em uma linha, marque as p√°ginas [tamanho / 4 Mi] como ocupadas, se houver uma marca de equil√≠brio [marca] como ocupada.  No √∫ltimo pacote, marque o restante dos peda√ßos como ocupado. </li></ul><br><p>  A pesquisa de √°reas livres tamb√©m depende da granularidade - uma matriz √© selecionada para itera√ß√£o ou m√°scaras de bits.  Sempre que voc√™ vai para o exterior, o OOM acontece.  Quando a desaloca√ß√£o, um algoritmo semelhante √© usado, apenas para a marca√ß√£o liberada.  A mem√≥ria liberada n√£o √© redefinida.  Todo o c√≥digo √© grande, vou coloc√°-lo sob o spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Bitmap de mem√≥ria virtual</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//512 MiB should be enough for kernel heap. If not - ooops... pub const KHEAP_START: usize = 0xE0000000; //I will keep 1MiB info about my heap in separate 4MiB page before heap at this point pub const KHEAP_INFO_ADDR: usize = 0xDFC00000; pub const KHEAP_CHUNK_SIZE: usize = 64; pub fn init() { KHEAP_INFO.lock().init(); } #[repr(packed)] #[derive(Copy, Clone)] struct HeapPageInfo { //every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } impl HeapPageInfo { pub fn init(&amp;mut self) { for i in 0..2048 { self._4mb_by_64b[i] = 0; } } pub fn mark_chunks_used(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] | mask; } pub fn mark_chunks_free(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] ^ mask; } pub fn empty(&amp;self) -&gt; bool { for i in 0..2048 { if self._4mb_by_64b[i] != 0 { return false } } true } } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], } impl HeapInfo { pub fn init(&amp;mut self) { for i in 0..128 { self._512mb_by_4mb[i].init(); } } // returns page number pub fn find_free_pages_of_size(&amp;self, n: usize) -&gt; usize { if n &gt;= 128 { 0xFFFFFFFF } else { let mut start_page: usize = 0xFFFFFFFF; let mut current_page: usize = 0xFFFFFFFF; for page in 0..128 { if self._512mb_by_4mb[page].empty() { if current_page - start_page == n { return start_page } if start_page == 0xFFFFFFFF { start_page = page; } current_page = page; } else { start_page = 0xFFFFFFFF; current_page = 0xFFFFFFFF; } } 0xFFFFFFFF } } // returns (page number, 32pack number) pub fn find_free_packs_of_size(&amp;self, n: usize) -&gt; (usize, usize) { if n &lt; 2048 { for page in 0..128 { let mut start_pack: usize = 0xFFFFFFFF; let mut current_pack: usize = 0xFFFFFFFF; for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; if _32pack_info == 0 { if current_pack - start_pack == n { return (page, start_pack) } if start_pack == 0xFFFFFFFF { start_pack = _32pack; } current_pack = _32pack; } else { start_pack = 0xFFFFFFFF; current_pack = 0xFFFFFFFF; } } } (0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF) } } // returns (page number, 32pack number, chunk number) pub fn find_free_chunks_of_size(&amp;self, n: usize) -&gt; (usize, usize, usize) { if n &lt; 32 { for page in 0..128 { for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n); for chunk in 0..(32-n) { if ((_32pack_info &gt;&gt; chunk) &amp; mask) ^ mask == mask { return (page, _32pack, chunk) } } } } (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } } fn mark_chunks_used(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_used(_32pack, chunk, n); } fn mark_chunks_free(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_free(_32pack, chunk, n); } fn mark_packs_used(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0xFFFFFFFF; } } fn mark_packs_free(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0; } } } use lazy_static::lazy_static; use spin::Mutex; lazy_static! { static ref KHEAP_INFO: Mutex&lt;&amp;'static mut HeapInfo&gt; = Mutex::new(unsafe { &amp;mut *(KHEAP_INFO_ADDR as *mut HeapInfo) }); } fn allocate_n_chunks_less_than_pack(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let (page, _32pack, chunk) = heap_info.find_free_chunks_of_size(n); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + _32pack * 32 * 64 + chunk * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_chunks_used(page, _32pack, chunk, n); uptr as *mut u8 } else { core::ptr::null_mut() } } } fn allocate_n_chunks_less_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let (page, pack) = heap_info.find_free_packs_of_size(packs_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + pack * 32 * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_packs_used(page, pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_used(page, pack + packs_to_alloc, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } //unsupported yet fn allocate_n_chunks_more_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let pages_n: usize = packs_to_alloc / 2048; let mut lost_packs = packs_to_alloc - pages_n * 2048; let mut pages_to_alloc = pages_n; if lost_packs != 0 { pages_to_alloc += 1; } if lost_chunks != 0 { lost_packs -= 1; } let page = heap_info.find_free_pages_of_size(pages_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B * n //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { for i in page..(page + pages_n) { heap_info.mark_packs_used(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_used(page + pages_to_alloc, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_used(page + pages_to_alloc, lost_packs, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } // returns pointer pub fn allocate_n_chunks(n: usize, align: usize) -&gt; *mut u8 { if n &lt; 32 { allocate_n_chunks_less_than_pack(n, align) } else if n &lt; 32 * 2048 { allocate_n_chunks_less_than_page(n, align) } else { allocate_n_chunks_more_than_page(n, align) } } pub fn free_chunks(ptr: usize, n: usize) { let page: usize = (ptr - KHEAP_START) / 0x400000; let _32pack: usize = ((ptr - KHEAP_START) - (page * 0x400000)) / (32 * 64); let chunk: usize = ((ptr - KHEAP_START) - (page * 0x400000) - (_32pack * (32 * 64))) / 64; let mut heap_info = KHEAP_INFO.lock(); if n &lt; 32 { heap_info.mark_chunks_free(page, _32pack, chunk, n); } else if n &lt; 32 * 2048 { let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; heap_info.mark_packs_free(page, _32pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_free(page, _32pack + packs_n, 0, lost_chunks); } } else { let packs_n: usize = n / 32; let pages_n: usize = packs_n / 2048; let lost_packs: usize = packs_n - pages_n * 2048; let lost_chunks = n - packs_n * 32; for i in page..(page + pages_n) { heap_info.mark_packs_free(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_free(page + pages_n, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_free(page + pages_n, packs_n, 0, lost_chunks); } } }</span></span></code> </pre> </div></div><br><h1 id="allokaciya-i-page-fault">  Aloca√ß√£o e falha de p√°gina </h1><br><p>  Para usar o heap, voc√™ precisa de um alocador.  Adicion√°-lo abrir√° para n√≥s um vetor, √°rvores, tabelas de hash, caixas e muito mais, sem o qual √© quase imposs√≠vel viver.  Assim que conectarmos o m√≥dulo de aloca√ß√£o e declararmos um alocador global, a vida se tornar√° imediatamente mais f√°cil. </p><br><p>  A implementa√ß√£o do alocador √© muito simples - refere-se simplesmente ao mecanismo descrito acima. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::alloc::{GlobalAlloc, Layout}; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Os1Allocator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator {} <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GlobalAlloc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, layout: Layout) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, allocate_n_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } allocate_n_chunks(chunk_count, layout.align()) } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dealloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ptr: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, layout: Layout) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, free_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } free_chunks(ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunk_count); } }</code> </pre> <br><p>  O alocador em lib.rs est√° ativado da seguinte maneira: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(alloc, alloc_error_handler)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> alloc; <span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOCATOR: memory::allocate::Os1Allocator = memory::allocate::Os1Allocator;</code> </pre> <br><p>  E quando tentamos nos alocar dessa maneira, obtemos uma exce√ß√£o de falha de p√°gina, porque ainda n√£o calculamos a aloca√ß√£o de mem√≥ria virtual.  Bem, como sim!  Bem, voc√™ precisa voltar ao material do artigo anterior e adicionar exce√ß√µes.  Decidi implementar uma aloca√ß√£o lenta da mem√≥ria virtual, ou seja, que a p√°gina fosse alocada n√£o no momento da solicita√ß√£o de mem√≥ria, mas no momento de uma tentativa de acess√°-la.  Felizmente, o processador x86 permite e at√© incentiva isso.   Page fault     ,   ,    ,          ‚Äî      ,     ,    CR2 ‚Äî  ,    . </p><br><p>    ,      .        32 (     ,     ,     32 ),    .           Rust.           ,        .  ,   ,   iret    ,    ,     Page fault   Protection fault.        Protection fault ‚Äî ,        . </p><br><pre> <code class="plaintext hljs">eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret</code> </pre> <br><p>  Rust         ,    .     ,     .            .            . </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">bitflags!</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PFErrorCode</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PROTECTION = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 - protection caused, 0 - not present page caused const WRITE = 1 &lt;&lt; 1; //1 - write caused, 0 - read caused const USER_MODE = 1 &lt;&lt; 2; //1 - from user mode, 0 - from kernel const RESERVED = 1 &lt;&lt; 3; //1 - reserved page (PAE/PSE), 0 - not const INSTRUCTION = 1 &lt;&lt; 4; //1 - instruction fetch caused, 0 - not } } impl PFErrorCode { pub fn to_pd_flags(&amp;self) -&gt; super::super::paging::PDEntryFlags { use super::super::paging; let mut flags = paging::PDEntryFlags::empty(); if self.contains(PFErrorCode::WRITE) { flags.set(paging::PDEntryFlags::WRITABLE, true); } if self.contains(PFErrorCode::USER_MODE) { flags.set(paging::PDEntryFlags::USER_ACCESSIBLE, true); } flags } } #[no_mangle] pub unsafe extern fn kE_page_fault(ptr: usize, code: usize) { use super::super::paging; println!("Page fault occured at addr 0x{:X}, code {:X}", ptr, code); let phys_address = crate::memory::physical::alloc_page(); let code_flags: PFErrorCode = PFErrorCode::from_bits(code).unwrap(); if !code_flags.contains(PFErrorCode::PROTECTION) { //page not presented, we need to allocate the new one let mut flags: paging::PDEntryFlags = code_flags.to_pd_flags(); flags.set(paging::PDEntryFlags::HUGE_PAGE, true); paging::allocate_page(phys_address, ptr, flags); println!("Page frame allocated at Paddr {:#X} Laddr {:#X}", phys_address, ptr); } else { panic!("Protection error occured, cannot handle yet"); } }</span></span></code> </pre> <br><p>        ,   .  ,       .           .          ,      .    ,      ,        : </p><br><pre> <code class="rust hljs"> <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free()); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::vec::<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000</span></span> { vec.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec len {}, ptr is {:?}"</span></span>, vec.len(), vec.as_ptr()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works, check reusage!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec2: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span> { vec2.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec2 len {}, ptr is {:?}, vec is still here? {}"</span></span>, vec2.len(), vec2.as_ptr(), vec.get(<span class="hljs-number"><span class="hljs-number">1000</span></span>).unwrap()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free());</code> </pre> <br><p>     : <br><img src="https://habrastorage.org/webt/7x/y3/bs/7xy3bs8m91uxbmexphxpelzc2cs.jpeg" alt="Pilha OS1"></p><br><p>  ,   ,           .          3,5  + 3 ,   .          3,5     . </p><br><p> IRQ 1    ‚Äî        Alt + PrntScrn :) </p><br><p> ,    ,      Rust ‚Äî       ,   ‚Äî    ,    ! </p><br><p>       ,                . </p><br><p>  Obrigado pela aten√ß√£o! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446214/">https://habr.com/ru/post/pt446214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446204/index.html">Previs√£o de como as restri√ß√µes da Internet ser√£o superadas</a></li>
<li><a href="../pt446206/index.html">Tutorial Reagir Parte 26: Arquitetura de Aplicativos, Padr√£o de Container / Componente</a></li>
<li><a href="../pt446208/index.html">Tutorial Reagir Parte 25: Workshop sobre formul√°rios</a></li>
<li><a href="../pt446210/index.html">ADAM-3600 - um controlador industrial multifuncional</a></li>
<li><a href="../pt446212/index.html">Profundidades do SIEM: correla√ß√µes prontas para uso. Parte 5. Metodologia para o desenvolvimento de regras de correla√ß√£o</a></li>
<li><a href="../pt446218/index.html">O designer de jogos n√£o √© muito diferente de um psicopata. Como fizemos o jogo CMAN</a></li>
<li><a href="../pt446222/index.html">Uso de potenciais t√©rmicos para an√°lise de territ√≥rio</a></li>
<li><a href="../pt446228/index.html">Melhorando a qualidade da classifica√ß√£o de texto conectando a Wikipedia</a></li>
<li><a href="../pt446230/index.html">Monitoramento e gerenciamento remotos de dispositivos baseados em Linux / OpenWrt / Lede atrav√©s da porta 80, continua√ß√£o</a></li>
<li><a href="../pt446234/index.html">Como volunt√°rios de todo o mundo criam transmiss√µes ao vivo do ICPC-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>