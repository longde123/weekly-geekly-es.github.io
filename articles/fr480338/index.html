<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèø üå∫ üèÜ Fonctionnement du rendu de jeu 3D: pixellisation et lancer de rayons ‚òπÔ∏è üôÜüèæ üõ•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie 1: traitement des sommets 

 Dans cet article, nous allons voir de plus pr√®s ce qui arrive au monde 3D une fois tous ses sommets trait√©s. Nous ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement du rendu de jeu 3D: pixellisation et lancer de rayons</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480338/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png" alt="image"></div><br>  <a href="https://habr.com/ru/post/472688/">Partie 1: traitement des sommets</a> <br><br>  Dans cet article, nous allons voir de plus pr√®s ce qui arrive au monde 3D une fois tous ses sommets trait√©s.  Nous devrons √† nouveau secouer la poussi√®re des manuels de math√©matiques, nous habituer √† la g√©om√©trie des pyramides de troncature et r√©soudre le myst√®re des perspectives.  Nous plongerons √©galement bri√®vement dans la physique du lancer de rayons, de l'√©clairage et des mat√©riaux. <br><br>  Le sujet principal de cet article est une √©tape de rendu importante, dans laquelle le monde tridimensionnel de points, segments et triangles devient une grille bidimensionnelle de blocs multicolores.  Tr√®s souvent, ce processus semble invisible, car la conversion de 3D en 2D est invisible, contrairement au processus d√©crit dans l' <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">article pr√©c√©dent</a> , o√π l'on pouvait imm√©diatement voir l'influence des vertex shaders et de la tessellation.  Si vous n'√™tes pas encore pr√™t pour cela, vous pouvez commencer avec notre article <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">3D Game Rendering 101</a> . <br><br><h2>  Pr√©paration pour deux mesures </h2><br>  La grande majorit√© des lecteurs lisent ce site Web sur un √©cran ou un √©cran de smartphone compl√®tement plat;  mais m√™me si vous avez une technique moderne - un moniteur incurv√©, l'image affich√©e par lui se compose √©galement d'une grille plate de pixels multicolores.  Cependant, lorsque vous jouez au nouveau Call of Mario: Deathduty Battleyard, les images semblent tridimensionnelles.  Les objets se d√©placent dans la sc√®ne, deviennent plus ou moins grands, s'approchant et s'√©loignant de la cam√©ra. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46b/506/855/46b506855796dd802382dc4fde347751.jpg"></div><br>  En prenant <a href="https://www.techspot.com/review/1089-fallout-4-benchmarks/">Fallout 4 de</a> Bethesda comme exemple, sorti en 2014, nous pouvons facilement voir comment les pics sont trait√©s, cr√©ant un sentiment de profondeur et de distance;  Cela est particuli√®rement visible en mode filaire (voir ci-dessus). <br><br>  Si vous prenez n'importe quel jeu 3D au cours des deux derni√®res d√©cennies, presque chacun d'eux ex√©cute la m√™me s√©quence d'actions pour convertir le monde 3D des sommets en un tableau de pixels 2D.  Cette conversion est souvent appel√©e <em>rast√©risation</em> , mais ce n'est qu'une des nombreuses √©tapes de l'ensemble du processus. <br><br>  Nous devons analyser les diff√©rentes √©tapes et √©tudier les techniques et les calculs qui y sont utilis√©s.  Comme r√©f√©rence, nous utiliserons la s√©quence utilis√©e dans Direct3D.  L'image ci-dessous montre ce qui se passe avec chaque sommet du monde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/621/43c/77462143c6d436fe0ad9145815956cf5.png"></div><br>  <i>Pipeline de conversion Direct3D</i> <br><br>  Dans le <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">premier article,</a> nous avons vu ce qui se passe dans l'espace mondial (espace mondial): ici, √† l'aide de diff√©rents calculs matriciels, les sommets sont transform√©s et color√©s.  Nous allons sauter l'√©tape suivante, car dans l'espace de la cam√©ra, seuls les sommets sont convertis et ajust√©s apr√®s le d√©placement, de sorte que la cam√©ra devient un point de r√©f√©rence. <br><br>  Les √©tapes suivantes sont trop compliqu√©es √† ignorer, car elles sont absolument n√©cessaires pour la transition de la 3D √† la 2D - si elles sont correctement mises en ≈ìuvre, notre cerveau regardera un √©cran plat, mais ¬´verra¬ª une sc√®ne avec profondeur et √©chelle.  Si tout est mal fait, l'image sera tr√®s √©trange! <br><br><h2>  Tout est question de perspective </h2><br>  La premi√®re √©tape de cette s√©quence consiste √† d√©finir la port√©e du point de vue de la cam√©ra.  Pour ce faire, vous devez d'abord d√©finir les angles du champ de vision horizontal et vertical - le premier change souvent dans les jeux, car les gens ont d√©velopp√© une vision p√©riph√©rique horizontale meilleure que verticale. <br><br>  Nous pouvons comprendre cela en regardant l'image avec le champ de vision d'une personne: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/37e/69b/75437e69be055c93670bb139fc2e47d9.png"></div><br>  Deux coins du champ de vision (champ de vision, fov) d√©finissent la forme de la pyramide <em>tronconique</em> - une pyramide 3D avec une base carr√©e √©manant de la cam√©ra.  Le premier coin d√©finit la fov <em>verticale</em> , le deuxi√®me <em>horizontal</em> ;  nous les d√©signons par les symboles <em>Œ±</em> et <em>Œ≤</em> .  En fait, nous voyons le monde pas tout √† fait comme √ßa, mais du point de vue des calculs, il est beaucoup plus facile de travailler avec la pyramide de troncature plut√¥t que d'essayer de g√©n√©rer une visibilit√© r√©aliste. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cc/62f/e5f/0cc62fe5fdb171e47cc3428fa5bdd427.png"></div><br>  Vous devez √©galement sp√©cifier deux autres param√®tres: l'emplacement des <em>plans de d√©tourage</em> proches (ou avant) et √©loign√©s (arri√®re) <em>(plans de d√©tourage)</em> .  La premi√®re coupe le sommet de la pyramide, mais d√©termine essentiellement √† quelle distance de la position de la cam√©ra tout est dessin√©;  ce dernier fait de m√™me, mais d√©termine √† quelle distance de la cam√©ra les primitives seront rendues. <br><br>  La taille et l'emplacement du plan de troncature proche sont tr√®s importants car ils deviennent ce qu'on appelle <em>une fen√™tre</em> .  En fait, c'est ce que nous voyons sur le moniteur, c'est-√†-dire  cadre rendu, et dans la plupart des API graphiques, la fen√™tre est dessin√©e √† partir du coin sup√©rieur gauche.  Dans l'image ci-dessous, le point (a1, b2) sera l'origine du plan: la largeur et la hauteur du plan sont mesur√©es par rapport √† lui. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf8/d66/f95/cf8d66f95ab085a290a35d996f94ed3d.png"></div><br>  <em>Le rapport hauteur / largeur de</em> la fen√™tre d'affichage est important non seulement pour afficher le monde rendu, mais √©galement pour correspondre au rapport hauteur / largeur du moniteur.  Pendant de nombreuses ann√©es, la norme √©tait de 4: 3 (ou 1,3333 ... en d√©cimal).  Cependant, aujourd'hui, la majorit√© joue dans un rapport d'aspect 16: 9 ou 21: 9, appel√© √©cran large et √©cran ultra large. <br><br>  Les coordonn√©es de chaque sommet dans l'espace de la cam√©ra doivent √™tre transform√©es afin qu'elles s'adaptent toutes au plan de troncature proche, comme indiqu√© ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/73f/69c/ba373f69c98de8b0000785606d1d56df.png"></div><br>  <i>Garniture lat√©rale et sup√©rieure de la pyramide</i> <br><br>  La transformation est effectu√©e √† l'aide d'une autre matrice appel√©e <em>matrice de projection en perspective</em> .  Dans l'exemple ci-dessous, pour effectuer les transformations, nous utilisons les angles de l'oscilloscope et la position des plans de troncature;  cependant, vous pouvez utiliser la taille de la fen√™tre √† la place. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/32e/2e1/d7632e2e15dd515df9f624a62f8fdce9.png"></div><br>  Le vecteur de position du sommet est multipli√© par cette matrice, ce qui nous donne un nouvel ensemble de coordonn√©es transform√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/8d6/a1d/2678d6a1d623c710e22675d54d05eaa2.png"></div><br>  Voila!  Maintenant, tous les sommets sont √©crits de telle mani√®re que le monde source est pr√©sent√© comme une perspective 3D, et les primitives pr√®s du plan de troncature avant semblent plus grandes que celles plus proches du plan lointain. <br><br>  Bien que la taille de la fen√™tre d'affichage et les angles d'angle de vue soient li√©s, ils peuvent √™tre trait√©s individuellement.  En d'autres termes, vous pouvez d√©finir la pyramide de troncature de mani√®re √† obtenir un plan de troncature proche dont la taille et le rapport d'aspect diff√®rent de la fen√™tre.  Pour ce faire, une √©tape suppl√©mentaire est n√©cessaire dans la cha√Æne d'op√©rations, √† laquelle les sommets dans le plan de troncature proche doivent √™tre √† nouveau transform√©s pour tenir compte de cette diff√©rence. <br><br>  Cependant, cela peut entra√Æner une distorsion de la perspective visible.  En utilisant le jeu Bethesda <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">Skyrim 2011 comme</a> exemple <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">,</a> nous pouvons voir comment la modification de l'angle horizontal de la zone de visibilit√© <em>Œ≤</em> tout en conservant le m√™me rapport hauteur / largeur de la fen√™tre affecte grandement la sc√®ne: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/2b8/4f7/fe92b84f7381a559d307517a2d46258a.jpg"></div><br>  Dans cette premi√®re image, nous avons d√©fini <em>Œ≤</em> = 75 ¬∞, et la sc√®ne semble compl√®tement normale.  Essayons maintenant de d√©finir <em>Œ≤</em> = 120 ¬∞: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e0/bf9/a3b/4e0bf9a3b44c400447fb73393a26916d.jpg"></div><br>  Deux diff√©rences sont imm√©diatement perceptibles - premi√®rement, maintenant nous voyons beaucoup plus des c√¥t√©s de notre "champ de vision";  deuxi√®mement, les objets semblent d√©sormais beaucoup plus √©loign√©s (surtout les arbres).  Cependant, l'effet visuel sur la surface de l'eau semble maintenant faux, car le processus n'a pas √©t√© con√ßu pour une telle zone de visibilit√©. <br><br>  Imaginons maintenant que notre personnage ait des yeux extraterrestres, et r√©glons <em>Œ≤</em> = 180 ¬∞! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6e/548/b9f/a6e548b9faa9cba6e3fa80a33a95444d.jpg"></div><br>  Une telle zone de visibilit√© cr√©e une sc√®ne presque panoramique, mais vous devez la payer avec une s√©rieuse distorsion des objets rendus sur les bords.  Cela s‚Äôest produit √† nouveau du fait que les concepteurs du jeu n‚Äôont pas pr√©vu une telle situation et n‚Äôont pas cr√©√© les ressources et les effets visuels du jeu pour un tel angle de vision (la valeur standard est d‚Äôenviron 70 ¬∞). <br><br>  Il peut sembler que dans les images ci-dessus, la cam√©ra a boug√©, mais ce n'est pas le cas - le seul changement est de modifier la pyramide de troncature, qui √† son tour a chang√© les dimensions du plan de troncature proche.  Sur chaque image, le rapport d'aspect de la fen√™tre reste le m√™me, de sorte que la matrice de mise √† l'√©chelle est appliqu√©e aux sommets afin que tout y rentre. <br><br><h2>  Alors, restez-vous ou partez-vous? </h2><br>  Apr√®s avoir effectu√© les transformations au stade de la projection, nous passons √† ce qu'on appelle un <em>espace de clip</em> .  Bien que cela se fasse <em>apr√®s la</em> projection, il est plus facile de montrer ce qui se passe si nous effectuons les op√©rations √† l'avance: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d1/5aa/921/8d15aa92153b56847f0a3eaba62000a0.png"></div><br>  Dans la figure ci-dessus, nous voyons que dans le canard en caoutchouc, l'une des chauves-souris et une partie des arbres, les triangles sont √† l'int√©rieur de la pyramide de troncature;  cependant, l'autre chauve-souris et l'arbre le plus √©loign√© sont en dehors des limites de la pyramide de troncature.  Bien que les sommets qui composent ces objets aient d√©j√† √©t√© trait√©s, nous ne les verrons pas dans la fen√™tre.  Cela signifie qu'ils <em>sont coup√©s</em> . <br><br>  Lors de la <em>troncature le long de la pyramide (√©cr√™tage tronconique),</em> toutes les primitives en dehors de la pyramide de troncature sont compl√®tement supprim√©es et celles situ√©es aux fronti√®res sont converties en nouvelles primitives.  La troncature n'am√©liore pas consid√©rablement les performances, car tous ces sommets invisibles ont d√©j√† √©t√© trait√©s avant cette √©tape dans les vertex shaders, etc.  Si n√©cessaire, l'√©tape de troncature enti√®re peut m√™me √™tre compl√®tement ignor√©e, mais cette fonctionnalit√© n'est pas prise en charge par toutes les API (par exemple, l'OpenGL standard ne permettra pas qu'elle soit ignor√©e, mais cela peut √™tre fait en utilisant l'extension API). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e07/57c/7a5e0757c7f8368a6d419c59468ec03e.png"></div><br>  Il convient de noter que la position du plan de troncature √©loign√©e dans les jeux n'est pas toujours √©gale √† la <em>distance de tirage</em> , car celle-ci est contr√¥l√©e par le moteur de jeu lui-m√™me.  Le moteur effectue √©galement un <em>√©cr√™tage sur la pyramide (tri s√©lectif)</em> - il ex√©cute un code qui d√©termine si l'objet sera dessin√© dans la pyramide de troncature et s'il affectera les objets visibles;  si la r√©ponse est <em>non</em> , l'objet n'est pas transf√©r√© au rendu.  Ce n'est pas la m√™me chose que l'√©cr√™tage frustrum car il supprime √©galement les primitives en dehors de la pyramide, mais elles ont d√©j√† franchi l'√©tape de traitement des sommets.  Lors de l'abattage, ils ne sont pas du tout trait√©s, ce qui √©conomise pas mal de ressources. <br><br>  Nous avons fait toutes les transformations et la troncature, et il semble que les sommets soient enfin pr√™ts pour la prochaine √©tape de la s√©quence de rendu.  Mais en fait, ce n'est pas le cas, car tous les calculs effectu√©s au stade du traitement des sommets et dans les op√©rations de transformation de l'espace mondial en espace de troncature doivent √™tre effectu√©s dans un syst√®me de coordonn√©es uniforme (c'est-√†-dire que chaque sommet a 4 composantes, pas 3) .  Cependant, la fen√™tre d'affichage est enti√®rement bidimensionnelle, c'est-√†-dire que l'API s'attend √† ce que les informations de sommet contiennent uniquement les valeurs de <em>x, y</em> (bien que la valeur de la profondeur <em>z soit</em> enregistr√©e). <br><br>  Pour se d√©barrasser du quatri√®me composant, une <em>division en perspective</em> est effectu√©e, dans laquelle chaque composant est divis√© par la valeur de <em>w</em> .  Cette op√©ration restreint <em>x</em> et <em>y √† l'</em> intervalle de valeurs possibles [-1,1] et <em>z</em> √† l'intervalle [0,1].  Celles-ci sont appel√©es <em>coordonn√©es de p√©riph√©rique normalis√©es</em> (NDC). <br><br>  Si vous voulez en savoir plus sur ce que nous venons d'expliquer et que vous aimez les math√©matiques, alors lisez l' <a href="http://www.songho.ca/opengl/gl_transform.html">excellent tutoriel</a> sur ce sujet Song Ho An.  Maintenant, transformons ces sommets en pixels! <br><br><h2>  Nous ma√Ætrisons la rast√©risation </h2><br>  Comme dans le cas des transformations, nous examinerons les r√®gles et processus utilis√©s pour transformer une fen√™tre en grille de pixels, en utilisant Direct3D comme exemple.  Ce tableau ressemble √† une feuille de calcul Excel avec des lignes et des colonnes, dans laquelle chaque cellule contient diff√©rentes valeurs de donn√©es (telles que la couleur, les valeurs de profondeur, les coordonn√©es de texture, etc.).  Habituellement, cette grille est appel√©e <em>image raster</em> , et le processus de sa g√©n√©ration est appel√© <em>rasterisation</em> .  Dans l'article <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">Rendu 3D 101,</a> nous avons simplifi√© cette proc√©dure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/01f/0e7/3b601f0e71774ce64eeb0a8f75a83f67.png"></div><br>  L'image ci-dessus donne l'impression que les primitives sont simplement coup√©es en petits blocs, mais en r√©alit√© il y a beaucoup plus d'op√©rations.  La toute premi√®re √©tape consiste √† d√©terminer si la primitive fait face √† la cam√©ra - par exemple, dans l'image ci-dessus avec une pyramide de troncature, les primitives qui composent le dos du lapin gris ne seront pas visibles.  Par cons√©quent, bien qu'ils soient pr√©sents dans la fen√™tre, ils n'ont pas besoin d'√™tre rendus. <br><br>  Nous pouvons √† peu pr√®s imaginer √† quoi il ressemble en regardant le diagramme ci-dessous.  Le cube a subi diverses transformations pour placer le mod√®le 3D dans l'espace 2D de l'√©cran et du point de vue de la cam√©ra, certaines faces du cube ne sont pas visibles.  Si nous supposons que toutes les surfaces sont opaques, alors certaines de ces primitives peuvent √™tre ignor√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/60a/bf9/69360abf9888e28d60622cf189cbb6c3.png"></div><br>  <i>De gauche √† droite: espace monde&gt; espace cam√©ra&gt; espace projection&gt; espace √©cran</i> <br><br>  Dans Direct3D, cela peut √™tre impl√©ment√© en indiquant au syst√®me quel sera l' <em>√©tat de rendu</em> , et cette instruction indiquera clairement qu'il est n√©cessaire de supprimer ( <em>couper</em> ) les c√¥t√©s de chaque primitive en regardant vers l'avant ou vers l'arri√®re (ou de ne pas couper compl√®tement, par exemple, en mode <em>filaire</em> ) .  Mais comment sait-elle de quel c√¥t√© regarde en avant ou en arri√®re?  Lorsque nous avons examin√© les <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">math√©matiques du traitement des sommets</a> , nous avons vu que les triangles (ou plut√¥t les sommets) ont des vecteurs normaux indiquant au syst√®me dans quelle direction il regarde.  Gr√¢ce √† ces informations, vous pouvez effectuer une simple v√©rification, et si la primitive √©choue, elle est supprim√©e de la cha√Æne de rendu. <br><br>  Il est maintenant temps d'appliquer la grille de pixels.  Il s'agit l√† encore d'un processus d'une complexit√© inattendue, car le syst√®me doit comprendre si le pixel est √† l'int√©rieur de la primitive - compl√®tement, partiellement ou pas du tout.  Pour ce faire, le processus de <em>test de couverture</em> est effectu√©.  La figure ci-dessous montre comment les triangles sont pixellis√©s dans Direct3D 11: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/858/967/ee6/858967ee6e11144896c35c2c726ec606.png"></div><br>  La r√®gle est assez simple: un pixel est consid√©r√© comme √©tant √† l'int√©rieur du triangle si le centre du pixel passe une v√©rification, ce que Microsoft appelle la <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">r√®gle ¬´en haut √† gauche¬ª</a> .  ¬´Haut¬ª fait r√©f√©rence √† la v√©rification de la ligne horizontale;  le centre du pixel doit √™tre <em>sur</em> cette ligne.  ¬´Gauche¬ª fait r√©f√©rence √† des lignes non horizontales et le centre du pixel doit √™tre √† gauche d'une telle ligne.  Il existe d'autres r√®gles li√©es aux non-primitives, par exemple, des segments et des points simples, et lors de l'utilisation du <em>multi</em> - <em>√©chantillonnage</em> , des conditions suppl√©mentaires apparaissent si dans les r√®gles. <br><br>  Si vous regardez attentivement la documentation de Microsoft, vous pouvez voir que les formes cr√©√©es par les pixels ne sont pas tr√®s similaires aux primitives d'origine.  En effet, les pixels sont trop grands pour cr√©er un triangle r√©aliste - l'image bitmap ne contient pas suffisamment de donn√©es sur les objets d'origine, ce qui provoque un ph√©nom√®ne appel√© <em>aliasing</em> . <br><br>  Regardons l'alias avec un exemple de <a href="https://benchmarks.ul.com/legacy-benchmarks">UL Benchmark 3DMark03</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f11/9d2/289/f119d2289c67082f66e4467385bc07be.jpg"></div><br>  <i>Pixellisation de 720 x 480 pixels</i> <br><br>  Dans la premi√®re image, l'image raster a une tr√®s faible r√©solution - 720 x 480 pixels.  Le repliement est clairement visible sur la balustrade et l'ombre projet√©e par les armes du soldat sup√©rieur.  Comparez cela avec le r√©sultat obtenu pendant la pixellisation avec une augmentation de 24 fois du nombre de pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/eba/d3a/ea8ebad3a86c108326f069fc343baed7.jpg"></div><br>  <i>Pixellisation 3840 x 2160 pixels</i> <br><br>  On voit ici que l'aliasing sur la balustrade et l'ombre a compl√®tement disparu.  Il semble que vous devez toujours utiliser un grand bitmap, mais la taille de la grille doit √™tre prise en charge par le moniteur sur lequel le cadre sera affich√©.  Et compte tenu du fait que tous ces pixels doivent √™tre trait√©s, il est √©vident qu'il y aura une diminution des performances. <br><br>  Le multi-√©chantillonnage peut aider ici.  Voici comment cela fonctionne dans Direct3D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/79e/62f/64b79e62fbcd12197ba9ff2c769045ae.png"></div><br>  Au lieu de v√©rifier si le centre du pixel correspond aux r√®gles de pixellisation, plusieurs points √† l'int√©rieur de chaque pixel (appel√©s √©chantillons ou sous-√©chantillons de sous-pixels) sont <em>v√©rifi√©s</em> , et si certains d'entre eux satisfont aux exigences, ils font partie de la figure.  Il peut sembler qu'il n'y ait aucun avantage et que l'aliasing est m√™me am√©lior√©, mais lors de l'utilisation du multi-√©chantillonnage, les informations sur les sous-√©chantillons couverts par la primitive et les r√©sultats du traitement des pixels sont stock√©es dans un tampon en m√©moire. <br><br>  Ce tampon est ensuite utilis√© pour m√©langer ces sous-√©chantillons et pixels afin que les bords de la primitive soient moins d√©chir√©s.  Nous examinerons plus en d√©tail l'aliasing dans un autre article, mais pour l'instant, ces informations nous suffisent pour comprendre ce que le multi-√©chantillonnage peut faire lorsqu'il est utilis√© pour pixelliser trop peu de pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/703/466/b61/703466b61fe655bfe9956003b707d9d5.jpg"></div><br>  Comme vous pouvez le voir, la quantit√© d'aliasing sur les bords de diff√©rentes formes a consid√©rablement diminu√©.  Une rast√©risation √† haute r√©solution est certainement meilleure, mais la d√©gradation des performances peut vous inciter √† utiliser le multi-√©chantillonnage. <br><br>  √âgalement pendant la pixellisation, un <em>test d'occlusion</em> est effectu√©.  Cela est n√©cessaire car la fen√™tre sera remplie de primitives superpos√©es les unes aux autres - par exemple, dans la figure ci-dessus, les triangles prospectifs qui composent le soldat au premier plan chevauchent les m√™mes triangles d'un autre soldat.  En plus de v√©rifier si la primitive recouvre un pixel, vous pouvez √©galement comparer les profondeurs relatives, et si une surface est derri√®re une autre, elle doit √™tre supprim√©e du processus de rendu restant. <br><br>  Cependant, si la primitive proche est transparente, alors la primitive lointaine restera visible, bien qu'elle ne r√©ussisse pas le test de chevauchement.  C'est pourquoi presque tous les moteurs 3D effectuent des v√©rifications de chevauchement <em>avant d'</em> envoyer des donn√©es au GPU et cr√©ent √† la place quelque chose appel√© un <em>z-buffer</em> , qui fait partie du processus de rendu.  Ici, le cadre est cr√©√© de la mani√®re habituelle, mais au lieu d'enregistrer les couleurs de pixels pr√™tes √† l'emploi dans la m√©moire, le GPU enregistre uniquement les valeurs de profondeur.  Plus tard, ils peuvent √™tre utilis√©s dans des shaders pour v√©rifier la visibilit√© et avec un grand contr√¥le et une grande pr√©cision des aspects li√©s aux objets qui se chevauchent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/2bc/c01/f532bcc017258005f427aaed4e3e482e.png"></div><br>  Dans l'image ci-dessus, plus la couleur des pixels est sombre, plus le sujet est proche de l'appareil photo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cadre est rendu une fois pour cr√©er un z-buffer, puis rendu √† nouveau, mais cette fois pendant le traitement des pixels, un shader est lanc√©, v√©rifiant les valeurs dans le z-buffer. S'il est invisible, la couleur des pixels n'est pas √©crite dans le tampon de l'image finie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, notre derni√®re √©tape principale sera l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolation des attributs des sommets</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dans le sch√©ma simplifi√© d'origine, la primitive √©tait un triangle complet, mais n'oubliez pas que la fen√™tre de vue est remplie uniquement avec les coins des figures, et non avec les figures elles-m√™mes. Autrement dit, le syst√®me doit d√©terminer la couleur, la profondeur et la texture de la primitive entre les sommets, et cette op√©ration est appel√©e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Comme vous l'avez peut-√™tre devin√©, il s'agit d'un autre calcul, et ce n'est pas si simple.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgr√© le fait que l'√©cran tram√© soit pr√©sent√© en 2D, les structures √† l'int√©rieur repr√©sentent une perspective 3D. </font><font style="vertical-align: inherit;">Si les lignes √©taient vraiment bidimensionnelles, nous pourrions utiliser une simple </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©quation lin√©aire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour calculer les couleurs et d'autres choses </font><font style="vertical-align: inherit;">, car nous nous d√©pla√ßons d'un sommet √† un autre. </font><font style="vertical-align: inherit;">Mais en raison de l'aspect 3D de la sc√®ne, l'interpolation doit tenir compte de cette perspective; </font><font style="vertical-align: inherit;">Pour en savoir plus sur ce processus, lisez l' </font></font><a href="http://simonstechblog.blogspot.com/2012/04/software-rasterizer-part-2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excellent article de Simon Young</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, la t√¢che est termin√©e - de sorte que le monde 3D des sommets se transforme en une grille 2D de blocs color√©s. </font><font style="vertical-align: inherit;">Mais nous n'avons pas encore tout √† fait termin√©.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De l'avant √† l'arri√®re (√† quelques exceptions pr√®s) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de terminer l'examen de la pixellisation, nous devons parler de l'ordre de la s√©quence de rendu. Nous ne parlons pas de l'√©tape o√π, par exemple, la tessellation appara√Æt dans la s√©quence de traitement; nous voulons dire l'ordre dans lequel les primitives sont trait√©es. Les objets sont g√©n√©ralement trait√©s dans l'ordre dans lequel ils se trouvent dans le tampon d'index (un bloc de m√©moire indiquant au syst√®me comment les sommets sont regroup√©s) et cela peut affecter de mani√®re significative la fa√ßon dont les objets et les effets transparents sont trait√©s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La raison en est que les primitives sont trait√©es une √† la fois, et si vous rendez d'abord celles devant, alors toutes celles qui se trouvent derri√®re elles seront invisibles (c'est l√† que l'abattage d'occlusion entre en jeu) et peuvent √™tre rejet√©es du processus (aidant √† sauver performances). Ceci est g√©n√©ralement appel√© rendu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant-arri√®re</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et pour ce processus, le tampon d'index doit √™tre ordonn√© de cette mani√®re. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, si certaines de ces primitives sont transparentes devant la cam√©ra, le rendu d'avant en arri√®re entra√Ænera la perte d'objets qui se trouvent derri√®re la transparence. Une solution consiste √† effectuer un rendu vers l'arri√®re, dans lequel les primitives et les effets transparents sont calcul√©s en dernier.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/c02/6f7/3cac026f78b545088b8de84fcdd11ee4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De gauche √† droite: l'ordre dans la sc√®ne, le rendu d'avant en arri√®re, le rendu d'arri√®re en avant</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est-√†-dire que dans tous les jeux modernes, le rendu est effectu√© d'arri√®re en avant? Dans tous les cas, n'oubliez pas que le rendu de chaque primitive individuelle entra√Ænera une diminution des performances beaucoup plus importante que le rendu uniquement de ce que nous voyons. Il existe d'autres fa√ßons de traiter des objets transparents, mais dans le cas g√©n√©ral, il n'y a pas de solution id√©ale adapt√©e √† n'importe quel syst√®me, et chaque situation doit √™tre consid√©r√©e s√©par√©ment.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, cela nous permet de comprendre les principaux avantages et inconv√©nients de la pixellisation - sur un √©quipement moderne, c'est un processus rapide et efficace, mais c'est toujours un reflet approximatif de ce que nous voyons. </font><font style="vertical-align: inherit;">Dans le monde r√©el, chaque objet peut absorber, r√©fl√©chir et parfois r√©fracter la lumi√®re, et tout cela affecte l'apparence finale de la sc√®ne affich√©e. </font><font style="vertical-align: inherit;">Divisant le monde en primitives et n'en rendant que des parties, nous obtenons rapidement. </font><font style="vertical-align: inherit;">mais un r√©sultat tr√®s approximatif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, s'il y avait un autre moyen ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une autre fa√ßon est: le lancer de rayons! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a pr√®s de cinquante ans, un informaticien du nom d'Arthur Eppel a travaill√© sur un syst√®me de rendu d'images sur un ordinateur dans lequel un faisceau de lumi√®re √©tait √©mis par la cam√©ra en ligne droite jusqu'√† ce qu'il entre en collision avec un objet. Apr√®s la collision, les propri√©t√©s du mat√©riau (sa couleur, sa r√©flectivit√©, etc.) ont modifi√© la luminosit√© du faisceau lumineux. Pour chaque pixel de l'image rendue, il y avait un rayon √©mis et l'algorithme a effectu√© une cha√Æne de calculs pour d√©terminer la couleur du pixel. Le processus d'Eppel est appel√© </font></font><a href="https://en.wikipedia.org/wiki/Ray_casting"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lancer de rayons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Environ dix ans plus tard, un autre scientifique nomm√© </font></font><a href="https://en.wikipedia.org/wiki/J._Turner_Whitted"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Whited</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a d√©velopp√© un algorithme math√©matique qui met en ≈ìuvre le processus Eppel, mais lorsqu'un rayon entre en collision avec un objet, il g√©n√®re des rayons suppl√©mentaires divergeant dans diff√©rentes directions, selon le mat√©riau de l'objet. Comme ce syst√®me g√©n√©rait de nouveaux faisceaux √† chaque interaction avec des objets, l'algorithme √©tait par nature r√©cursif et beaucoup plus complexe sur le plan des calculs; cependant, elle avait un avantage significatif sur la m√©thode d'Eppel, car il pouvait correctement prendre en compte les r√©flexions, les r√©fractions et les ombres. Cette proc√©dure est appel√©e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raytracing (ray tra√ßage)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( √† </font><font style="vertical-align: inherit;">proprement parler, il est </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'inverse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raytracing parce que nous suivons le faisceau de la cam√©ra et non par les objets) et depuis lors , </font><font style="vertical-align: inherit;">il est devenu un saint graal pour l' </font><font style="vertical-align: inherit;">infographie et des </font></font><a href="https://graphics.pixar.com/library/RayTracingCars/paper.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">films</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/733/8a8/5f07338a8846abdebe390b99bd364ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä partir de l'image ci-dessus, vous pouvez comprendre le fonctionnement de l'algorithme Whited. Pour chaque pixel du cadre, un faisceau est √©mis par la cam√©ra et se d√©place jusqu'√† ce qu'il atteigne la surface. Dans cet exemple, la surface est translucide, de sorte que la lumi√®re peut √™tre r√©fl√©chie et r√©fract√©e √† travers elle. Dans les deux cas, des rayons secondaires sont g√©n√©r√©s qui voyagent jusqu'√† ce qu'ils entrent en collision avec la surface. De nouveaux rayons secondaires sont √©galement g√©n√©r√©s pour tenir compte de la couleur des sources lumineuses et des ombres qu'elles cr√©ent.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La nature r√©cursive du processus est que des rayons secondaires peuvent √™tre g√©n√©r√©s chaque fois qu'un nouveau rayon √©mis coupe la surface. Cela peut rapidement devenir incontr√¥lable, de sorte que le nombre de rayons secondaires g√©n√©r√©s est toujours limit√©. Une fois le trajet du faisceau termin√©, la couleur √† chaque point final est calcul√©e en fonction des propri√©t√©s du mat√©riau de cette surface. Cette valeur est ensuite transmise le long du rayon pr√©c√©dent, en changeant la couleur de cette surface, et ainsi de suite, jusqu'√† ce que nous atteignions le point de d√©part du rayon primaire, √† savoir le pixel dans le cadre.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tel syst√®me peut √™tre extr√™mement complexe et m√™me des sc√®nes simples peuvent g√©n√©rer une grande quantit√© de calcul. Heureusement, il existe des astuces qui simplifient le travail - tout d'abord, vous pouvez utiliser un √©quipement sp√©cialement con√ßu pour acc√©l√©rer ces op√©rations math√©matiques, semblable √† la fa√ßon dont cela se passe avec les math√©matiques matricielles dans le traitement des vertex (plus de d√©tails plus loin). Une autre astuce importante est une tentative d'acc√©l√©rer le processus de d√©termination de l'objet dans lequel le rayon est tomb√© et de l'endroit exact de leur intersection - si l'objet est compos√© de nombreux triangles, cette t√¢che peut √™tre √©tonnamment difficile:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/3f8/dac/de43f8dac76ca9bda84700c168cde9ff.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source: Ray tracing en temps r√©el avec Nvidia RTX.Au</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lieu de v√©rifier chaque triangle individuel dans chaque objet, une liste de volumes englobants (BV) est g√©n√©r√©e avant d'effectuer le ray tracing - ce sont des parall√©l√©pip√®des ordinaires qui d√©crivent un objet. Pour diverses structures √† l'int√©rieur de l'objet, des volumes de d√©limitation plus petits sont cr√©√©s de mani√®re cyclique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, le premier BV sera le lapin entier. Le couple suivant d√©crira sa t√™te, ses jambes, son corps, sa queue, etc.; chaque volume √† son tour sera une autre collection de volumes pour des structures plus petites de la t√™te, du corps, etc., et le dernier niveau de volume contiendra un petit nombre de triangles pour v√©rification. Tous ces volumes sont souvent organis√©s dans une liste ordonn√©e (appel√©e la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hi√©rarchie BV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou BVH); </font><font style="vertical-align: inherit;">gr√¢ce √† cela, le syst√®me v√©rifie √† chaque fois une quantit√© relativement faible de BV:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/319/454/3453194547f780d91a4231529f6f68b4.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que l'utilisation de BVH, √† proprement parler, n'acc√©l√®re pas le lancer de rayons lui-m√™me, g√©n√©rer une hi√©rarchie et l'algorithme de recherche subs√©quent requis dans le cas g√©n√©ral est beaucoup plus rapide que de v√©rifier l'intersection d'un rayon avec l'un des millions de triangles dans le monde 3D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aujourd'hui, des programmes tels que </font></font><a href="https://www.blender.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="http://www.povray.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POV-ray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisent le ray tracing avec des algorithmes suppl√©mentaires (tels que le photon tracing et la radiosit√©) pour g√©n√©rer des images tr√®s r√©alistes:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/b2c/bf6/cfab2cbf6216eaa3e007bdd38f867cd6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La question √©vidente peut se poser: si le lancer de rayons est si bon, pourquoi n‚Äôest-il pas utilis√© partout? La r√©ponse r√©side dans deux domaines: premi√®rement, m√™me un simple tra√ßage des rayons cr√©e des millions de rayons qui doivent √™tre calcul√©s encore et encore. Le syst√®me d√©marre avec un seul faisceau par pixel d'√©cran, c'est-√†-dire qu'avec une r√©solution de 800 x 600, il g√©n√®re 480 000 rayons primaires, puis chacun g√©n√®re de nombreux rayons secondaires. C'est un travail tr√®s difficile, m√™me pour les PC de bureau modernes. Le deuxi√®me probl√®me est que le simple lancer de rayons n'est pas tr√®s r√©aliste et pour sa bonne mise en ≈ìuvre, vous avez besoin de tout un tas d'√©quations tr√®s complexes suppl√©mentaires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√™me avec un √©quipement moderne, la quantit√© de travail dans les jeux 3D est inaccessible pour une impl√©mentation en temps r√©el. En </font></font><a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendu 3D 101</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons vu qu'un rep√®re de lancer de rayons prend des dizaines de secondes pour cr√©er une seule image basse r√©solution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment le premier </font></font><a href="https://www.techspot.com/downloads/5842-wolfenstein-3d.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfenstein 3D a-t-il</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effectu√© le lancer de rayons en 1992, et pourquoi des jeux comme </font></font><a href="https://www.techspot.com/review/1759-ray-tracing-benchmarks-vol-2/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battlefield V</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metro Exodus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sortis en 2019, offrent-ils des capacit√©s de </font><font style="vertical-align: inherit;">lancer de rayons </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">R√©alisent-ils une pixellisation ou un lancer de rayons? </font><font style="vertical-align: inherit;">Peu √† peu des deux.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une approche hybride pour le pr√©sent et l'avenir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En mars 2018, Microsoft a annonc√© la sortie d'une nouvelle extension d'API pour Direct3D 12 appel√©e DXR (DirectX Raytracing). </font><font style="vertical-align: inherit;">Il s'agissait d'un nouveau pipeline graphique qui compl√®te les pipelines de tramage et de calcul standard. </font><font style="vertical-align: inherit;">Des fonctionnalit√©s suppl√©mentaires ont √©t√© fournies par l'ajout de shaders, de structures de donn√©es, etc., mais n'ont pas n√©cessit√© de prise en charge mat√©rielle, √† l'exception de celle qui √©tait d√©j√† n√©cessaire pour Direct3D 12.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c9/b88/e83/7c9b88e83184b2412b431ff990e39f89.png"></div><br>  Lors de la m√™me conf√©rence des d√©veloppeurs de jeux, au cours de laquelle <a href="https://devblogs.microsoft.com/directx/wp-content/uploads/sites/42/2018/03/GDC_DXR_deck.pdf">Microsoft a parl√© de DXR</a> , Electronic Arts a parl√© de son <a href="https://www.ea.com/seed/news/seed-project-picapica">projet Pica Pica</a> - une exp√©rience avec un moteur 3D utilisant DXR.  La soci√©t√© a montr√© que le lancer de rayons peut √™tre utilis√©, mais pas pour rendre le cadre entier.  La majeure partie du travail utilise des techniques de tramage traditionnelles et des shaders de calcul, tandis que DXR est utilis√© dans des domaines sp√©cifiques.  Autrement dit, le nombre de rayons g√©n√©r√©s est bien inf√©rieur √† ce qu'il serait pour toute la sc√®ne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png"></div><br>  Cette approche hybride a √©t√© utilis√©e dans le pass√©, quoique dans une moindre mesure.  Par exemple, Wolfenstein 3D a <a href="https://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/">utilis√© le lancer de rayons</a> pour rendre un cadre, mais il a √©t√© effectu√© avec un faisceau par colonne de pixels, pas un pixel.  Cela peut encore sembler impressionnant, √† moins que vous vous souveniez que le jeu a fonctionn√© avec une r√©solution de 640 x 480 [env.  transl.: en fait 320 x 200], c'est-√†-dire qu'en m√™me temps pas plus de 640 rayons ont √©t√© √©mis. <br><br>  Les cartes graphiques du d√©but de 2018 comme l'AMD Radeon RX 580 ou la Nvidia GeForce 1080 Ti r√©pondaient aux exigences du DXR, mais m√™me avec leurs capacit√©s informatiques, on craignait qu'elles ne soient pas assez puissantes pour donner un sens au DXR. <br><br>  La situation a chang√© en ao√ªt 2018 lorsque Nvidia a publi√© sa derni√®re architecture GPU <a href="http://www.techspot.com/news/75952-nvidia-turing-here-next-gen-architecture-first-real.html">, nomm√©e Turing</a> .  La caract√©ristique la plus importante de cette puce √©tait l'apparition des soi-disant noyaux RT: des blocs logiques s√©par√©s pour acc√©l√©rer les calculs de l'intersection rayon-triangle et le passage de la hi√©rarchie des volumes englobants (BVH).  Ces deux processus sont des proc√©dures chronophages pour d√©terminer les points d'interaction de la lumi√®re avec les triangles qui composent les objets de la sc√®ne.  √âtant donn√© que les c≈ìurs RT √©taient des unit√©s de processeur Turing uniques, leur acc√®s ne pouvait se faire que via l'API propri√©taire Nvidia. <br><br>  Le premier jeu √† prendre en charge cette fonctionnalit√© √©tait Battlefield V. d'EA  <a href="https://www.techspot.com/review/1749-battlefield-ray-tracing-benchmarks/">Lorsque nous y avons test√© le DXR</a> , nous avons √©t√© impressionn√©s par l'am√©lioration des r√©flexions dans l'eau, sur l'herbe et les m√©taux, ainsi que par une diminution correspondante des performances: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/e3e/aa1/1cce3eaa1c5db3688910ec0a1c052ce4.png"></div><br>  Pour √™tre honn√™te, les correctifs ult√©rieurs ont am√©lior√© la situation, mais il y avait toujours une diminution de la vitesse de rendu des images (et c'est toujours le cas).  En 2019, d'autres jeux prenaient en charge cette API et effectuaient le lancer de rayons pour des parties individuelles du cadre.  Nous avons test√© <a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/">Metro Exodus</a> et <a href="https://www.techspot.com/article/1814-sotr-ray-tracing/">Shadow of the Tomb Raider</a> , confront√©s √† la m√™me situation - l'utilisation active de DXR r√©duit consid√©rablement la fr√©quence d'images. <br><br>  Vers la m√™me √©poque, UL Benchmarks a <a href="https://benchmarks.ul.com/news/3dmark-port-royal-ray-tracing-benchmark-now-available">annonc√©</a> la cr√©ation d'un test de fonction DXR pour <a href="https://www.techspot.com/downloads/5775-3dmark.html">3DMark</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/60a/a0d/61260aa0d10ef6ed6c69731a6a3038f2.jpg"></div><br>  <i>DXR est utilis√© dans la carte graphique Nvidia Titan X (Pascal) - oui, le r√©sultat est de 8 ips</i> <br><br>  Cependant, une √©tude des jeux avec prise en charge DXR et le test 3DMark ont ‚Äã‚Äãmontr√© que le ray tracing m√™me en 2019 reste une t√¢che tr√®s difficile pour le GPU, m√™me √† un prix de plus de 1000 $.  Est-ce √† dire que nous n'avons pas de r√©elle alternative √† la tramage? <br><br>  Les fonctionnalit√©s progressives des technologies graphiques 3D grand public sont souvent tr√®s co√ªteuses et leur prise en charge initiale des nouvelles fonctionnalit√©s API peut √™tre assez fragment√©e ou lente (comme nous l'avons d√©couvert <a href="https://www.techspot.com/review/537-max-payne-3-performance/page6.html">lors du test de Max Payne 3</a> sur diff√©rentes versions de Direct3D en 2012).  Ce dernier probl√®me se pose g√©n√©ralement parce que les d√©veloppeurs de jeux essaient d'incorporer autant de fonctionnalit√©s modernes que possible dans leurs produits, parfois sans exp√©rience suffisante. <br><br>  Cependant, les shaders de vertex et de pixels, la tessellation, le rendu HDR et l'occlusion ambiante de l'espace √† l'√©cran √©taient √©galement des techniques co√ªteuses adapt√©es uniquement aux GPU puissants, et maintenant ils sont la norme pour les jeux et de nombreuses cartes graphiques sont prises en charge.  La m√™me chose se produira avec le lancer de rayons;  au fil du temps, il se transformera simplement en un autre param√®tre de d√©tail, activ√© par d√©faut pour la plupart des joueurs. <br><br><h2>  En conclusion </h2><br>  Nous sommes donc arriv√©s √† la fin de la deuxi√®me partie de l'analyse, dans laquelle nous avons approfondi le monde des graphiques 3D.  Nous avons appris comment les sommets des mondes et des mod√®les sont transf√©r√©s de trois dimensions et se transforment en une image 2D plate.  Nous avons vu que nous devons prendre en compte la port√©e et r√©alis√© son impact.  Nous avons examin√© le processus de conversion de ces v√©rines en pixels et avons termin√© avec un bref aper√ßu des alternatives au processus de tramage traditionnel. <br><br>  Comme dans l'article pr√©c√©dent, il √©tait peu probable que nous soyons en mesure de r√©v√©ler tous les sujets, et nous avons manqu√© quelques d√©tails - au final, ce n'est pas un manuel!  Mais nous esp√©rons que vous avez appris quelque chose de nouveau et respectez maintenant le travail des programmeurs et des ing√©nieurs qui ont utilis√© l'informatique et la science pour impl√©menter tout cela dans vos jeux 3D pr√©f√©r√©s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480338/">https://habr.com/ru/post/fr480338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480326/index.html">F5 Networks Corporation envoie des lettres √† ses clients pour les informer de la situation actuelle avec NGINX</a></li>
<li><a href="../fr480328/index.html">Comment se faire des amis PyTorch et C ++. Utilisation de TorchScript</a></li>
<li><a href="../fr480330/index.html">Outil d'√©valuation id√©al des employ√©s</a></li>
<li><a href="../fr480332/index.html">Analyse des donn√©es du vote blockchain 2019 √† la Douma de Moscou</a></li>
<li><a href="../fr480334/index.html">Panneau QtQML / Quick correlation</a></li>
<li><a href="../fr480340/index.html">Je me suis oppos√© √† un gestionnaire incomp√©tent, puis il a √©t√© promu</a></li>
<li><a href="../fr480342/index.html">Paradigme de d√©veloppement par le commentaire</a></li>
<li><a href="../fr480348/index.html">Deep Fake Science, la crise de la reproductibilit√© et d'o√π viennent les r√©f√©rentiels vides</a></li>
<li><a href="../fr480350/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 326 (du 9 au 15 d√©cembre)</a></li>
<li><a href="../fr480352/index.html">Un g√©n√©ticien de Harvard d√©veloppe un prototype d'application de datation pour l'analyse d'ADN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>