<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏀 🌥️ 🤾🏿 Gambaran umum emulator terminal ✌🏽 👩🏽‍🏫 🥇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa kata dari biro terjemahan kami: biasanya semua orang ingin menerjemahkan bahan dan publikasi terbaru, dan kami tidak terkecuali. Tetapi termi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gambaran umum emulator terminal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/463785/"> <i>Beberapa kata dari biro terjemahan kami: biasanya semua orang ingin menerjemahkan bahan dan publikasi terbaru, dan kami tidak terkecuali.</i>  <i>Tetapi terminal bukanlah sesuatu yang diperbarui seminggu sekali.</i>  <i>Oleh karena itu, kami menerjemahkan untuk Anda sebuah artikel oleh Antoine Bopre yang diterbitkan pada musim semi 2018: meskipun “zaman” yang solid menurut standar modern, menurut pendapat kami, materi tersebut belum sepenuhnya kehilangan relevansinya.</i>  <i>Selain itu, yang asli adalah serangkaian dua artikel, tetapi kami memutuskan untuk menggabungkannya menjadi satu posting besar.</i> <br><br><img src="https://habrastorage.org/webt/_4/qm/3j/_4qm3jhmwxnoyxqc6jblinmiuoa.jpeg"><br><br>  Terminal menempati tempat khusus dalam sejarah komputer, tetapi dalam beberapa dekade terakhir mereka telah "dipaksa" untuk benar-benar bertahan hidup bersama dengan baris perintah dengan latar belakang antarmuka grafis di mana-mana.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terminal emulator</a> menggantikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perangkat kerasnya</a> , yang, pada gilirannya, merupakan modifikasi sistem pada kartu punch dan sakelar sakelar.  Distribusi modern hadir dengan sejumlah emulator terminal dari semua bentuk dan warna.  Dan sementara banyak diam-diam puas dengan terminal standar yang disediakan oleh lingkungan kerja mereka, beberapa dengan bangga menggunakan perangkat lunak yang terus terang eksotis untuk meluncurkan shell atau editor teks favorit mereka.  Tetapi, seperti yang akan kita lihat dari artikel ini, tidak semua terminal dibuat dalam satu gambar dan rupa: mereka sangat bervariasi dalam fungsi, ukuran dan kinerja. <br><a name="habracut"></a><br><br>  Beberapa terminal memiliki lubang keamanan yang luar biasa, ditambah, sebagian besar memiliki serangkaian fungsi yang sama sekali berbeda, dari dukungan antarmuka tab hingga scripting.  Meskipun kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihat emulator terminal di masa lalu</a> , artikel ini adalah pembaruan untuk materi sebelumnya yang akan membantu pembaca menentukan terminal mana yang akan digunakan pada 2018.  Paruh pertama artikel membandingkan fungsi, dan babak kedua mengevaluasi kinerja. <br><br>  Berikut adalah terminal yang saya ulas: <br><br><img src="https://habrastorage.org/webt/c4/3l/gy/c43lgydftmr0spxf35oq3vgyozy.jpeg"><br><br>  Mungkin ini bukan versi terbaru, karena saya membatasi diri saya untuk membangun stabil pada saat penulisan, yang saya dapat meluncurkan di Debian 9 atau Fedora 27. Satu-satunya pengecualian adalah Alacritty.  Dia adalah keturunan terminal dengan akselerasi GPU dan ditulis dalam bahasa yang tidak biasa dan baru untuk tugas ini - Rust.  Saya mengecualikan terminal web dari ulasan saya (termasuk pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Electron</a> ), karena tes pendahuluan menunjukkan kinerjanya yang sangat buruk. <br><br><h4>  Dukungan Unicode </h4><br>  Saya memulai pengujian dengan dukungan Unicode.  Tes terminal pertama adalah menampilkan string Unicode dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Wikipedia</a> : "é, Δ ,,, ק, م, ๗, あ, 叶, 葉, 葉, dan 말."  Tes sederhana ini menunjukkan apakah terminal dapat bekerja dengan benar di seluruh dunia.  Terminal xterm tidak menampilkan simbol Arab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mem</a> dalam konfigurasi default: <br><br><img src="https://habrastorage.org/webt/gv/no/zm/gvnozm-mh17i-33qam74-r2i8n0.png"><br><br>  Secara default, xterm menggunakan font "tetap" klasik, yang, menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wiki</a> , memiliki "cakupan Unicode yang signifikan sejak 1997."  Sesuatu terjadi di font ini yang menyebabkan karakter muncul sebagai bingkai kosong dan hanya ketika font teks meningkat menjadi 20+ poin karakter akhirnya mulai ditampilkan dengan benar.  Namun, "perbaikan" tersebut merusak tampilan karakter Unicode lainnya: <br><br><img src="https://habrastorage.org/webt/ke/lt/oe/keltoepwoz-dt_388rrmzaw7xy0.png"><br><br>  Tangkapan layar ini diambil di Fedora 27, karena memberikan hasil yang lebih baik daripada Debian 9, di mana beberapa terminal versi lama (khususnya mlterm) tidak dapat berfungsi dengan baik dengan font.  Untungnya, ini telah diperbaiki di versi yang lebih baru. <br><br>  Sekarang perhatikan pemetaan string di xterm.  Ternyata simbol Mem dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qof</a> Semit berikutnya milik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip</a> RTL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kanan-ke-kiri</a> ), jadi secara teknis mereka harus ditampilkan dari kanan ke kiri.  Browser web, seperti Firefox 57, menangani dengan benar baris di atas.  Versi sederhana dari teks RTL adalah kata " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sarah</a> " dalam bahasa Ibrani ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">שרה</a> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman wiki dua arah</a> mengatakan yang berikut: <br><blockquote>  “Banyak program komputer tidak dapat menampilkan teks dua arah dengan benar.  Misalnya, nama Ibrani "Sarah" terdiri dari simbol sin (ש) (yang muncul di sebelah kanan), kemudian resh (ר) dan, akhirnya, heh (ה) (yang seharusnya muncul di sebelah kiri). " </blockquote><br>  Banyak terminal gagal tes ini: Alacritty, terminal yang diturunkan VTE Gnome dan XFCE, urxvt, st dan xterm menampilkan "Sarah" dalam urutan terbalik, seolah-olah kita mengeja nama ini sebagai "Aras". <br><br><img src="https://habrastorage.org/webt/z4/yw/gi/z4ywgic4drs6yom_j1xxlnvgh5e.png"><br><br>  Masalah lain dengan teks dua arah adalah bahwa mereka perlu disejajarkan dengan cara tertentu, terutama ketika menyangkut pencampuran teks RTL dan LTR.  Script RTL harus dijalankan di sisi kanan jendela terminal, tetapi apa yang seharusnya terjadi untuk terminal yang menggunakan bahasa Inggris LTR?  Kebanyakan dari mereka tidak memiliki mekanisme khusus dan menyelaraskan seluruh teks ke kiri (termasuk Konsole).  Pengecualiannya adalah pterm dan mlterm, yang mematuhi standar dan menyelaraskan garis-garis tersebut ke kanan. <br><br><img src="https://habrastorage.org/webt/ji/9b/xx/ji9bxx3oy7oqjavtph7zjajxwhq.png"><br><br><h4>  Perlindungan penyisipan </h4><br>  Fitur penting berikutnya yang telah saya tentukan sendiri adalah perlindungan terhadap penyisipan.  Meskipun secara luas diketahui bahwa mantra itu seperti: <br><br><pre><code class="plaintext hljs">$ curl http://example.com/ | sh</code> </pre> <br>  adalah perintah eksekusi kode push, beberapa orang tahu bahwa perintah tersembunyi dapat menembus konsol saat menyalin dan menempel dari browser web, bahkan setelah pemeriksaan menyeluruh.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs tes Gianna Horne dengan</a> cemerlang menunjukkan betapa tidak berbahaya penampilan tim: <br><br><pre> <code class="plaintext hljs">git clone git: //git.kernel.org/pub/scm/utils/kup/kup.git</code> </pre> <br>  itu berubah menjadi gangguan ketika menempelkan dari situs web Horn ke terminal: <br><br><pre> <code class="plaintext hljs">git clone /dev/null; clear; echo -n "Hello "; whoami|tr -d '\n'; echo -e '!\nThat was a bad idea. Don'"'"'t copy code from websites you don'"'"'t trust! \ Here'"'"'s the first line of your /etc/passwd: '; head -n1 /etc/passwd git clone git://git.kernel.org/pub/scm/utils/kup/kup.git</code> </pre> <br>  Bagaimana cara kerjanya?  Kode berbahaya ditempatkan di blok <b>&lt;span&gt;</b> , yang dipindahkan dari bidang penglihatan pengguna menggunakan CSS. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mode pasta braket</a> jelas dirancang untuk menetralkan serangan tersebut.  Dalam mode ini, terminal melampirkan teks yang disisipkan dalam sepasang urutan pelarian khusus untuk menginformasikan shell tentang asal usul teks ini.  Jadi shell menerima sinyal bahwa ia dapat mengabaikan karakter khusus yang berisi teks yang dimasukkan.  Semua terminal, hingga xterm terhormat, mendukung fungsi ini, tetapi penyisipan dalam mode Bracketed memerlukan dukungan untuk shell atau aplikasi yang berjalan di terminal.  Misalnya, perangkat lunak yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU Readline</a> (Bash yang sama) membutuhkan file <b>~ / .inputrc</b> : <br><br><pre> <code class="plaintext hljs">set enable-bracketed-paste on</code> </pre> <br>  Sayangnya, situs uji Horn juga menunjukkan cara mengatasi perlindungan ini dengan memformat teks itu sendiri dan secara prematur mengakhiri penerapan mode Bracketed untuk itu.  Ini berfungsi karena beberapa terminal tidak dengan benar menyaring urutan keluar sebelum menambahkan mereka sendiri.  Misalnya, di saya, saya tidak berhasil menyelesaikan tes Konsole, bahkan dengan mempertimbangkan konfigurasi yang benar dari file <b>.inputrc</b> .  Ini berarti Anda dapat dengan mudah mendapatkan kerusakan konfigurasi sistem karena aplikasi yang tidak didukung atau shell yang tidak dikonfigurasi dengan benar.  Ini sangat berbahaya ketika memasuki server jauh, di mana studi konfigurasi yang cermat kurang umum, terutama jika Anda memiliki banyak mesin jarak jauh tersebut. <br><br>  Solusi yang baik untuk masalah ini adalah plugin konfirmasi tempel untuk terminal <b>urxvt</b> , yang hanya meminta izin untuk menempelkan teks yang berisi baris baru.  Saya tidak menemukan opsi yang lebih aman untuk serangan teks yang dijelaskan oleh Horn. <br><br><h4>  Tab dan Profil </h4><br>  Fitur populer sekarang adalah untuk mendukung antarmuka tab, yang akan kita definisikan sebagai satu jendela terminal yang berisi beberapa terminal lagi.  Untuk terminal yang berbeda, fungsi ini berbeda, dan meskipun terminal tradisional seperti xterm tidak mendukung tab sama sekali, inkarnasi terminal yang lebih modern diwakili oleh Terminal Xfce, Terminal GNOME dan Konsole memiliki fungsi ini.  Urxvt juga memiliki dukungan tab, tetapi hanya jika plugin digunakan.  Tetapi dalam hal tab pendukung seperti itu, Terminator adalah pemimpin yang tidak perlu dipersoalkan: ia tidak hanya mendukung tab, tetapi juga dapat mengatur terminal dalam urutan apa pun (lihat gambar di bawah). <br><br><img src="https://habrastorage.org/webt/eq/2s/_f/eq2s_fad0t8_7v6uymzkg7xndvs.png"><br><br>  Fitur lain dari Terminator adalah kemampuan untuk "mengelompokkan" tab-tab ini bersama-sama dan mengirim penekanan tombol yang sama ke beberapa terminal secara bersamaan, yang menyediakan alat kasar untuk melakukan operasi massal pada beberapa server secara bersamaan.  Fitur serupa juga diterapkan di Konsole.  Untuk menggunakan fungsi ini di terminal lain, Anda harus menggunakan perangkat lunak pihak ketiga seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cluster SSH</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xlax</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tmux</a> . <br><br>  Tab bekerja sangat baik bersama dengan profil: misalnya, Anda dapat memiliki satu tab untuk email, lainnya untuk obrolan dan sebagainya.  Ini didukung dengan baik oleh Konsole dan Terminal GNOME.  Keduanya memungkinkan setiap tab untuk secara otomatis meluncurkan profilnya.  Terminator juga mendukung profil, tetapi saya tidak dapat menemukan cara untuk secara otomatis meluncurkan program tertentu ketika saya membuka tab tertentu.  Terminal lain tidak memiliki konsep profil sama sekali. <br><br><h4>  Ryushechki </h4><br>  Hal terakhir yang akan saya pertimbangkan di bagian pertama artikel ini adalah penampilan terminal.  Misalnya, GNOME, Xfce, dan urxvt mendukung transparansi, tetapi baru-baru ini menghapus dukungan untuk gambar latar belakang, memaksa beberapa pengguna untuk beralih ke terminal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tilix</a> .  Secara pribadi, saya senang hanya dengan <b>Xresources</b> , yang menetapkan set dasar warna latar belakang untuk urxvt.  Namun, tema warna khusus dapat menyebabkan masalah.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solarized</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak berfungsi</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">htop</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IPTraf</a> , karena mereka sudah menggunakan warna mereka sendiri. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terminal VT100 asli</a> tidak mendukung warna, dan yang baru sering terbatas pada palet 256-warna.  Untuk pengguna tingkat lanjut yang menata terminal mereka, permintaan shell atau bilah status dengan beberapa cara rumit bisa menjadi batasan yang tidak menyenangkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gist</a> melacak terminal mana yang memiliki dukungan True Color.  Tes saya mengkonfirmasi bahwa terminal berbasis st, Alacritty, dan VTE sangat mendukung True Color.  Terminal lain dalam hal ini tidak terasa sangat baik dan bahkan tidak menampilkan 256 warna.  Di bawah ini Anda dapat melihat perbedaan antara dukungan True Color di terminal GNOME, st dan xterm, yang melakukan pekerjaan dengan baik dengan palet 256-warna, dan urxvt, yang tidak hanya gagal dalam tes, tetapi bahkan menunjukkan beberapa karakter yang berkedip sebagai gantinya mereka. <br><br><img src="https://habrastorage.org/webt/3u/go/mq/3ugomq0evrr7ql1h9xsapwjp_om.png"><br><br>  Beberapa terminal juga menganalisis teks untuk pola URL untuk membuat tautan dapat diklik.  Ini berlaku untuk semua terminal yang diturunkan VTE, sementara urxvt memerlukan plug-in khusus yang mengubah URL dengan klik atau pintasan keyboard.  Terminal lain saya menguji URL tayangan dengan cara lain. <br><br>  Akhirnya, tren baru untuk terminal adalah opsi buffer gulir.  Sebagai contoh, di st tidak ada buffer gulir;  Diasumsikan bahwa pengguna akan menggunakan terminal multiplexer seperti tmux dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layar GNU</a> . <br><br>  Alacritty juga tidak memiliki buffer gulir terbalik, tetapi dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan segera ditambahkan</a> karena "umpan balik yang luas" pada topik ini dari pengguna.  Selain pemula ini, setiap terminal saya menguji bahwa saya dapat menemukan dukungan bergulir ke belakang. <br><br><h4>  Subtotal </h4><br>  Pada bagian kedua dari materi ( <i>dalam aslinya, ini adalah dua artikel yang berbeda, - kira-kira Per.</i> ) Kami akan membandingkan kinerja, penggunaan memori dan penundaan.  Tetapi kita sudah melihat bahwa beberapa terminal yang dimaksud memiliki kekurangan yang serius.  Sebagai contoh, pengguna yang secara teratur bekerja dengan skrip RTL dapat memperhatikan mlterm dan pterm, karena mereka mengatasi tugas-tugas seperti itu lebih baik daripada yang lain.  Konsole juga tampil dengan baik.  Pengguna yang tidak bekerja dengan skrip RTL dapat memilih sesuatu yang lain. <br><br>  Dari sudut pandang keamanan terhadap penyisipan kode berbahaya, urxvt berdiri terpisah karena penerapan perlindungan khusus terhadap serangan jenis ini, yang menurut saya pasti nyaman.  Mereka yang mencari lonceng dan peluit harus melihat Konsole.  Akhirnya, perlu dicatat bahwa VTE adalah basis yang bagus untuk terminal, yang menjamin dukungan warna, pengenalan URL, dan sebagainya.  Pada pandangan pertama, terminal default yang datang dengan lingkungan favorit Anda dapat memenuhi semua persyaratan, tetapi mari kita biarkan pertanyaan ini terbuka sampai kita mengetahui kinerja. <br><br><h4>  <i>Lanjutkan pembicaraan</i> </h4><br>  Secara umum, kinerja terminal itu sendiri mungkin tampak seperti masalah yang dibuat-buat, namun, ternyata, beberapa dari mereka menunjukkan penundaan yang sangat besar untuk perangkat lunak dari tipe fundamental ini.  Kami juga akan melihat lebih jauh pada apa yang secara tradisional disebut "kecepatan" (pada kenyataannya, ini adalah kecepatan gulir) dan konsumsi memori oleh terminal (mengingat hari ini tidak sepenting beberapa dekade yang lalu). <br><br><h4>  Tunda </h4><br>  Setelah mempelajari secara menyeluruh kinerja terminal, saya sampai pada kesimpulan bahwa parameter yang paling penting dalam hal ini adalah ukuran delay (ping).  Dalam artikelnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Kami mencetak dengan senang hati”,</a> Pavel Fatin memeriksa keterlambatan berbagai editor teks dan mengisyaratkan bahwa terminal dalam hal ini dapat bekerja lebih lambat daripada editor teks tercepat.  Petunjuk inilah yang membuat saya, pada akhirnya, meluncurkan tes saya sendiri dan menulis artikel ini. <br><br>  Tapi apa itu penundaan, dan mengapa itu begitu penting?  Dalam artikelnya, Fatin mendefinisikannya sebagai "penundaan antara menekan tombol dan pembaruan layar yang sesuai" dan mengutip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Manual tentang interaksi manusia-komputer" yang</a> mengatakan: "Keterlambatan umpan balik visual pada tampilan komputer memiliki efek penting pada perilaku juru ketik dan kepuasannya. ". <br><br>  Fatin menjelaskan bahwa ping seperti itu memiliki konsekuensi yang lebih dalam dari sekadar kepuasan: "mengetik menjadi lebih lambat, lebih banyak kesalahan terjadi, ketegangan mata dan otot meningkat."  Dengan kata lain, penundaan besar dapat menyebabkan kesalahan ketik, serta penurunan kualitas kode, karena mengarah pada beban kognitif tambahan pada otak.  Tetapi yang lebih buruk, ping "meningkatkan ketegangan mata dan otot", yang, tampaknya, menyiratkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perkembangan cedera profesional</a> di masa depan ( <i>tampaknya, penulis berarti masalah dengan otot mata, punggung, lengan dan, tentu saja, penglihatan, - sekitar Per.</i> ) Karena stres berulang. <br><br>  Beberapa dari efek ini telah dikenal sejak lama, dan hasil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelitian yang</a> diterbitkan kembali pada tahun 1976 dalam jurnal Ergonomics mengatakan bahwa penundaan 100 milidetik "secara signifikan memperburuk kecepatan panggilan."  Baru-baru ini, <a href="">waktu respons</a> 10 milidetik yang dapat diterima diperkenalkan dalam panduan pengguna GNOME, dan jika kita melangkah lebih jauh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Research</a> menunjukkan bahwa 1 milidetik ideal. <br><br>  Fatin melakukan tes pada editor teks;  dia menciptakan alat portabel yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Typometer</a> , yang saya gunakan untuk menguji ping di terminal emulator.  Ingatlah bahwa pengujian dilakukan dalam mode simulasi: pada kenyataannya, kita juga perlu mempertimbangkan penundaan input (keyboard, pengontrol USB, dll.) Dan output (buffer kartu video, monitor).  Menurut Fatin, dalam konfigurasi tipikal adalah sekitar 20 ms.  Jika Anda memiliki peralatan game, Anda hanya dapat mencapai indikator 3 milidetik.  Karena kita sudah memiliki peralatan yang begitu cepat, aplikasi seharusnya tidak memperkenalkan penundaannya juga.  Tujuan Fatin adalah untuk menunda aplikasi hingga 1 milidetik, atau untuk mencapai panggilan tanpa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penundaan yang terukur</a> , seperti dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IntelliJ IDEA 15</a> . <br><br>  Dan berikut ini adalah hasil pengukuran saya, serta beberapa hasil Fatin untuk menunjukkan bahwa percobaan saya konsisten dengan tes-tesnya: <br><br><img src="https://habrastorage.org/webt/4s/u-/vn/4su-vnzyvqb35-uwp0ywpq2g76e.jpeg"><br><br>  Hal pertama yang mengejutkan saya adalah waktu respons terbaik untuk program yang lebih lama seperti xterm dan mlterm.  Dengan latensi register terburuk (2,4 ms), mereka menunjukkan hasil yang lebih baik daripada terminal modern tercepat (10,6 ms untuk st).  Tidak ada terminal modern yang jatuh di bawah ambang 10 milidetik.  Secara khusus, Alacritty tidak memenuhi persyaratan untuk "emulator terminal tercepat yang ada", meskipun hasilnya telah meningkat sejak pemeriksaan pertama pada tahun 2017.  Memang, penulis proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyadari situasi</a> dan berupaya memperbaiki tampilan.  Perlu juga dicatat bahwa Vim menggunakan GTK3 adalah urutan besarnya lebih lambat dari rekan GTK2-nya.  Dari sini kita dapat menyimpulkan bahwa GTK3 menciptakan penundaan tambahan, dan ini tercermin di semua terminal lain yang menggunakannya (Terminator, Xfce4 Terminal dan Terminal GNOME). <br><br>  Namun, perbedaan mungkin tidak terlihat oleh mata.  Seperti yang dijelaskan Fatin: "Tidak perlu mewaspadai keterlambatan agar hal itu berdampak pada Anda."  Fatin juga memperingatkan deviasi standar: "Setiap penyimpangan dalam jangka waktu keterlambatan (jitter) menciptakan beban tambahan karena tidak dapat diprediksi." <br><br><img src="https://habrastorage.org/webt/dq/a4/0v/dqa40vpdfz4k9uctottd6h9j2we.png"><br><br>  Grafik di atas diambil pada Debian 9 murni (stretch) dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manajer jendela i3</a> .  Lingkungan ini memberikan hasil terbaik dalam tes penundaan.  Ternyata, GNOME menciptakan ping tambahan 20 ms untuk semua dimensi.  Penjelasan yang mungkin untuk ini adalah keberadaan program dengan pemrosesan peristiwa input secara sinkron.  Fatin mengutip contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Workrave</a> untuk kasus ini, yang menambahkan penundaan dengan memproses semua peristiwa input secara sinkron.  Secara default, GNOME juga memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mutter</a> window manager yang menciptakan level tambahan buffering, yang memengaruhi ping dan menambahkan penundaan minimal 8 milidetik. <br><br><img src="https://habrastorage.org/webt/ec/t9/ap/ect9apxhg0v5l0_q04qujn5xu4k.png"><br><br><h4>  Kecepatan gulir </h4><br>  Tes berikutnya adalah tes tradisional "kecepatan" atau "bandwidth", yang mengukur seberapa cepat terminal dapat menggulir halaman, menampilkan sejumlah besar teks pada layar.  Mekanisme tes bervariasi;  tes asli adalah hanya menghasilkan string teks yang sama dengan perintah seq.  Tes lain termasuk tes oleh Thomas E. Dickey (pengelola xterm), yang berulang kali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh file terminfo.src</a> .  Dalam ulasan kinerja terminal lain, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Den Luu</a> menggunakan string byte acak yang disandikan, yang di-output ke terminal menggunakan cat.  Luu menganggap tes semacam itu sebagai "tidak berguna karena dapat dibayangkan" dan menyarankan menggunakan respons terminal sebagai indikator utama.  Dickey juga menyebut tesnya menyesatkan.  Namun, kedua penulis mengakui bahwa bandwidth jendela terminal dapat menjadi masalah.  Luu menemukan Emacs Eshell membeku ketika menampilkan file-file besar, dan Dickie mengoptimalkan terminal untuk menghilangkan kelambatan visual xtrerm.  Oleh karena itu, masih ada beberapa alasan untuk pengujian ini, tetapi karena proses rendering sangat berbeda dari terminal ke terminal, itu juga dapat digunakan sebagai komponen uji untuk memeriksa parameter lainnya. <br><br><img src="https://habrastorage.org/webt/4z/ov/rx/4zovrxmlnbnwpbzhnebcp412yf0.png"><br><br>  Di sini kita melihat bahwa rxvt dan st berada di depan di depan kompetisi, diikuti oleh Alacritty yang jauh lebih baru, yang sedang dikembangkan dengan fokus pada kecepatan.  Selanjutnya datang Xfce (keluarga VTE) dan Konsole, yang bekerja hampir dua kali lebih cepat.  Yang terakhir adalah xterm dengan indeks lima kali lebih lambat dari rxvt.  Selama pengujian, xterm juga berdesir, sulit untuk melihat teks yang lewat, bahkan jika itu adalah baris yang sama.  Konsole ternyata cepat, tetapi kadang-kadang itu "rumit": layar tergantung dari waktu ke waktu, menunjukkan sebagian teks atau tidak menampilkannya sama sekali.  Terminal lain menampilkan string dengan jelas, termasuk st, Alacritty, dan rxvt. <br><br>  Dickie menjelaskan bahwa perbedaan kinerja terkait dengan desain buffer gulir di terminal yang berbeda.  Secara khusus, ia menuduh rxvt dan terminal lainnya “tidak mengikuti aturan umum”: <br><blockquote>  “Tidak seperti xterm, rxvt tidak mencoba menampilkan semua pembaruan.  Jika dia ketinggalan, dia akan membuang beberapa pembaruan untuk mengejar ketinggalan.  Ini memiliki efek yang lebih besar pada kecepatan gulir imajiner daripada pada organisasi memori internal.  Satu kekurangannya adalah bahwa animasi ASCII agak tidak akurat. ” </blockquote><br>  Untuk memperbaiki kelambatan xterm yang tampaknya ini, Dickey menyarankan untuk menggunakan sumber daya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fastScroll</a> , yang memungkinkan xterm untuk membuang beberapa pembaruan layar untuk mengikuti arus.  Pengujian saya mengonfirmasi bahwa fastScroll meningkatkan kinerja dan membawa xterm ke tingkat yang sama dengan rxvt.  Namun, ini adalah penopang yang agak kasar, seperti yang dijelaskan Dickey sendiri: "kadang-kadang xterm - seperti konsole - tampaknya berhenti karena mengharapkan serangkaian pembaruan layar baru setelah beberapa dari mereka telah dihapus."  Dalam nada ini, tampaknya terminal lain telah menemukan kompromi terbaik antara kecepatan dan integritas layar. <br><br><h4>  Konsumsi sumber daya </h4><br>  Terlepas dari kesesuaian mempertimbangkan kecepatan gulir sebagai indikator kinerja, tes ini memungkinkan Anda untuk mensimulasikan beban pada terminal, yang, pada gilirannya, memungkinkan kami untuk mengukur parameter lain, seperti memori atau penggunaan disk.  Metrik diperoleh dengan menjalankan tes <b>seq yang</b> ditentukan di bawah pemantauan proses Python.  Dia mengumpulkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getrusage ()</a> data penghitung untuk <b>ru_maxrss</b> , jumlah <b>ru_oublock</b> dan <b>ru_inblock,</b> dan timer sederhana. <br><br><img src="https://habrastorage.org/webt/e7/ay/fm/e7ayfmzkluchtlybqvqjwmijobs.png"><br><br>  Dalam tes ini, ST mengambil tempat pertama dengan konsumsi memori rata-rata terkecil 8 MB, yang tidak mengejutkan ketika Anda menganggap bahwa ide utama dari proyek ini adalah kesederhanaan.  Mlterm, xterm dan rxvt mengkonsumsi sedikit lebih banyak - sekitar 12 MB.  Alacritty memiliki hasil penting lainnya, yang membutuhkan 30 MB untuk bekerja.  Lalu ada terminal keluarga VTE dengan indikator dari 40 hingga 60 MB, yang cukup banyak.  Konsumsi semacam itu dapat dijelaskan oleh fakta bahwa terminal ini menggunakan pustaka tingkat yang lebih tinggi, misalnya, GTK.  Konsole hadir dengan konsumsi memori sebesar 65 MB selama pengujian, meskipun hal ini dapat dibenarkan dengan berbagai fungsinya yang sangat luas. <br><br>  Dibandingkan dengan hasil sebelumnya yang diperoleh sepuluh tahun yang lalu, semua program mulai mengkonsumsi lebih banyak memori.  Sebelumnya, Xterm membutuhkan 4 MB, tetapi sekarang - 15 MB hanya untuk dijalankan.  Rxvt memiliki peningkatan konsumsi yang serupa, yang sekarang membutuhkan 16 MB di luar kotak.  Terminal Xfce menempati 34 MB, yang tiga kali lebih banyak dari sebelumnya, tetapi Terminal GNOME hanya membutuhkan 20 MB.  Tentu saja, semua tes sebelumnya dilakukan pada arsitektur 32-bit.  Pada LCA 2012, Rusty Russell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa ada banyak alasan yang lebih halus yang dapat menjelaskan peningkatan konsumsi memori.  Dengan semua ini, kita sekarang hidup di masa ketika kita memiliki seluruh memori gigabytes, sehingga kita dapat menanganinya. <br><br>  Namun demikian, saya tidak dapat menahan perasaan bahwa mengalokasikan lebih banyak memori ke perangkat lunak mendasar seperti terminal adalah pemborosan sumber daya.        ,       «»,  ,   -   ,      Linux- (  ,     ).                 ,          .   , GNOME Terminal, Konsole, urxvt, Terminator  Xfce Terminal  Daemon-,        ,     . <br><br><img src="https://habrastorage.org/webt/bx/h6/dc/bxh6dcm-ahulyqaioo5vhmuwmea.png"><br><br>              -:       ,  ,         . ,  VTE       (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    2010 </a> ,      ).      , ,   ,      AES256 GCM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  0.39.2</a> ).    ,       VTE,        … <br><br><h4>  Kesimpulan </h4><br>      ,     VTE    ,    ,          .     ,    VTE-    Daemon-,    .   ,  ,          ,  -      ,       .   VTE         (),             GNOME. ,  VTE   .     ,      Linux    ,          .                         -   .  ,   xterm  mlterm        10 ,    . <br><br>    ,  -    Linux      .        ,       .  ,  Wayland    :  Typometer,   ,    ,  Wayland   —    .  ,   Wayland   ,  X.org,      ,    -        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463785/">https://habr.com/ru/post/id463785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463771/index.html">[Peter] Bertemu JUG.ru dengan Sebastian Dashner - Jadikan tes menulis perusahaan lebih menyenangkan</a></li>
<li><a href="../id463773/index.html">Bagaimana perlindungan anak-anak dari informasi diatur - dan kisah yang mempesona tentang dari mana asalnya (18+)</a></li>
<li><a href="../id463775/index.html">Siapa yang menggunakan protokol otentikasi SAML 2.0</a></li>
<li><a href="../id463777/index.html">Pemantauan Ketersediaan Host Powershell</a></li>
<li><a href="../id463781/index.html">Komponen Terpencil Zen dalam Arsitektur Android</a></li>
<li><a href="../id463787/index.html">Kejutan besar HP</a></li>
<li><a href="../id463789/index.html">Kekuatan generik di Swift. Bagian 2</a></li>
<li><a href="../id463791/index.html">Pegangan besi: kinematika pendaratan burung tergantung pada geometri dan tekstur permukaan</a></li>
<li><a href="../id463795/index.html">Nuansa makna dalam bahasa Inggris: cara menggunakan kata kerja Advise, Recommend, Suggest</a></li>
<li><a href="../id463799/index.html">Apa yang saya tidak suka tentang Windows 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>