<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòπ üïµüèª üñ§ System.IO.Pipelines - un outil peu connu pour les amateurs de hautes performances üè¶ üè∏ üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour lecteur. Beaucoup de temps s'est √©coul√© depuis la sortie de .NET Core 2.1. Et des innovations int√©ressantes comme Span et Memory ont d√©j√† √©t√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines - un outil peu connu pour les amateurs de hautes performances</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464921/">  Bonjour lecteur.  Beaucoup de temps s'est √©coul√© depuis la sortie de .NET Core 2.1.  Et des innovations int√©ressantes comme Span et Memory ont d√©j√† √©t√© largement prises en compte, vous pouvez les lire, les voir et en entendre beaucoup parler.  Cependant, malheureusement, une biblioth√®que appel√©e System.IO.Pipelines n'a pas re√ßu la m√™me attention.  Presque tout ce qui est sur ce sujet est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">seul message</a> que beaucoup ont traduit et publi√© √† la maison.  Il devrait certainement y avoir plus d'informations pour que les personnes int√©ress√©es puissent regarder la technologie sous diff√©rents angles. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Ainsi, cette biblioth√®que vise √† acc√©l√©rer le travail avec le traitement des donn√©es en streaming.  Il a √©t√© initialement cr√©√© et utilis√© par l'√©quipe de d√©veloppement de Kestrel (un serveur Web multiplateforme pour ASP.NET Core), mais est actuellement fourni via un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package de nuget</a> distinct. <br>  Avant de nous plonger dans le sujet, nous pouvons imaginer le m√©canisme de biblioth√®que comme un analogue am√©lior√© de MemoryStream.  Le probl√®me avec le MemoryStream d'origine est un nombre excessif de copies, ce qui est √©vident si vous vous souvenez qu'un tableau d'octets priv√© est utilis√© √† l'int√©rieur comme tampon.  Par exemple, dans les m√©thodes de <a href="">lecture</a> et d' <a href="">√©criture</a> , la copie est clairement visible.  Ainsi, pour l'objet que nous voulons √©crire dans le flux, une copie sera cr√©√©e dans le tampon interne, et lors de la lecture, une copie de la copie interne sera remise au consommateur.  Cela ne ressemble pas √† l'utilisation la plus rationnelle de l'espace. <br>  System.IO.Pipelines n'a pas pour objectif de remplacer tous les flux, c'est un outil suppl√©mentaire dans l'arsenal d'un d√©veloppeur √©crivant du code performant.  Je vous sugg√®re de vous familiariser avec les m√©thodes et classes de base, de voir comment elles sont organis√©es √† l'int√©rieur et d'analyser des exemples de base. <br><br>  Commen√ßons par le p√©riph√©rique interne, en examinant en m√™me temps de simples fragments de code.  Apr√®s cela, il deviendra clair quoi et comment cela fonctionne, et comment il doit √™tre utilis√©.  Lorsque vous travaillez avec System.IO.Pipelines, il convient de se rappeler que le concept de base est que toutes les op√©rations de lecture-√©criture doivent avoir lieu sans allocations suppl√©mentaires.  Mais certaines m√©thodes s√©duisantes √† premi√®re vue contredisent cette r√®gle.  Par cons√©quent, le code que vous essayez si fort d'acc√©l√©rer commence √† allouer de la m√©moire pour les nouvelles et nouvelles donn√©es, en chargeant le garbage collector. <br><br>  La biblioth√®que interne de la biblioth√®que utilise les possibilit√©s les plus √©tendues des derni√®res versions de la langue et de la dur√©e, de l‚Äô√©tendue, de la m√©moire, des pools d‚Äôobjets, de ValueTask, etc.  Cela vaut au moins le coup d‚Äô≈ìil pour un excellent exemple d‚Äôutilisation de ces fonctionnalit√©s en production. <br>  √Ä un moment donn√©, certains n'√©taient pas satisfaits de l'impl√©mentation de flux en C #, car une classe √©tait utilis√©e √† la fois pour la lecture et l'√©criture.  Mais, comme on dit, vous ne pouvez pas jeter des m√©thodes hors d'une classe.  M√™me si le flux ne prenait pas en charge la lecture / l'√©criture / le d√©placement du pointeur, les propri√©t√©s CanRead, CanWrite et CanSeek prenaient effet, ce qui ressemblait √† une petite b√©quille.  Ici, les choses sont diff√©rentes. <br>  Pour travailler avec des tuyaux, 2 classes sont utilis√©es: <a href="">PipeWriter</a> et <a href="">PipeReader</a> .  Ces classes contiennent environ 50 lignes chacune et sont des pseudo-fa√ßades (pas ses incarnations les plus classiques, car il y a une seule classe cach√©e derri√®re elles, et pas beaucoup) pour la classe <a href="">Pipe</a> , qui contient toute la logique de base pour travailler avec des donn√©es.  Parmi les membres publics - 2 constructeurs, 2 propri√©t√©s get-only - Reader et Writer, la m√©thode Reset (), qui r√©initialise les champs internes √† leur √©tat initial afin que la classe puisse √™tre r√©utilis√©e.  D'autres m√©thodes de travail sont appel√©es √† l'aide de pseudo-fa√ßades. <br><br><h2>  Pour commencer sur la classe Pipe </h2><br>  L'instance de classe occupe 320 octets, ce qui est beaucoup (presque un tiers de kilo-octet, 2 de ces objets ne pouvaient pas tenir dans la m√©moire de Manchester Mark I).  Donc, l'allouer en grande quantit√© est une mauvaise id√©e.  De plus, la signification de l'objet est destin√©e √† une utilisation √† long terme.  L'utilisation de pools cr√©e √©galement un argument pour cette d√©claration.  Apr√®s tout, les objets utilis√©s dans la piscine vivront pour toujours (dans tous les cas, dans la norme). <br>  Notez que la classe est marqu√©e comme scell√©e et qu'elle est thread-safe - de nombreuses sections du code sont une section critique et sont entour√©es de verrous. <br>  Pour commencer, cr√©ez une instance de la classe Pipe et obtenez les objets PipeReader et PipeWriter en utilisant les propri√©t√©s mentionn√©es. <br><br><div class="spoiler">  <b class="spoiler_title">Initialisation facile</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Consid√©rez les m√©thodes de travail avec les tuyaux: <br>  Pour l'enregistrement via PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br>  Pour lire via PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Comme indiqu√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article</a> , la classe utilise une liste de tampons li√©s individuellement.  Mais, √©videmment, ils ne sont pas transmis entre PipeReader et PipeWriter - toute la logique est dans une classe.  Cette liste est utilis√©e √† la fois pour la lecture et l'√©criture.  De plus, les donn√©es retourn√©es sont stock√©es dans cette liste. <br>  Il existe √©galement des objets qui indiquent le d√©but des donn√©es √† lire (ReadHead et index), la fin des donn√©es √† lire (ReadTail et index) et le d√©but de l'emplacement √† √©crire (WriteHead et le nombre d'octets mis en m√©moire tampon √©crits).  Ici, ReadHead, ReadTail et WriteHead sont un segment sp√©cifique de la liste et l'index indique une position sp√©cifique dans le segment.  Ainsi, l'enregistrement peut commencer au milieu d'un segment, capturer tout le segment suivant et se terminer au milieu du troisi√®me.  Ces pointeurs se d√©placent de diff√©rentes mani√®res. <br><br><h2>  Prise en main des m√©thodes PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (source ReadOnlyMemory &lt;byte&gt;, CancellationToken cancelToken)</a> </h3><br>  Juste cette m√©thode tentante.  A une signature tr√®s appropri√©e et √† la mode - accepte ReadOnlyMemory, asynchrone.  Et beaucoup peuvent √™tre tent√©s, surtout en se souvenant que la port√©e et la m√©moire sont si rapides et cool.  Mais ne vous flattez pas.  Tout ce que cette m√©thode fait est de copier le ReadOnlyMemory qui lui est pass√© dans la liste interne.  Et ¬´copier¬ª signifie un appel √† la m√©thode CopyTo, et non la copie de l'objet lui-m√™me.  Autrement dit, toutes les donn√©es que nous voulons enregistrer seront copi√©es, chargeant ainsi la m√©moire.  Cette m√©thode ne doit √™tre √©tudi√©e que pour s'assurer qu'il vaut mieux ne pas l'utiliser.  Eh bien, et peut-√™tre pour certaines situations rares, ce comportement est appropri√©. <br>  Le corps de la m√©thode est une section critique dont l'acc√®s est synchronis√© via un moniteur. <br><br>  Ensuite, la question peut se poser, comment √©crire quelque chose, sinon par la m√©thode la plus √©vidente et la seule appropri√©e. <br><br><h3>  # 2 <a href="">M√©moire &lt;octet&gt; GetMemory (int sizeHint)</a> </h3><br>  La m√©thode prend un param√®tre d'un type entier.  Nous devons y indiquer combien d'octets nous voulons √©crire (ou plus, mais en aucun cas moins).  Cette m√©thode v√©rifie s'il y a suffisamment d'espace pour √©crire dans le fragment de m√©moire actuel stock√© dans _writingHeadMemory.  Si suffisant, _writingHeadMemory est retourn√© en tant que m√©moire.  Sinon, pour les donn√©es √©crites dans le tampon, mais pour lesquelles la m√©thode FlushAsync n'a pas √©t√© appel√©e, elle est appel√©e et un autre BufferSegment est s√©lectionn√©, qui est connect√© au pr√©c√©dent (voici la liste).  En l'absence de _writingHeadMemory, il est initialis√© avec un nouveau BufferSegment.  Et l'allocation du prochain tampon est une section critique et se fait sous le verrou. <br>  Je sugg√®re de regarder un tel exemple.  √Ä premi√®re vue, il peut sembler que le compilateur (ou runtime) a s√©duit le d√©mon. <br><br><div class="spoiler">  <b class="spoiler_title">Devilry</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048  4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Mais tout dans cet exemple est compr√©hensible et simple. <br>  Lors de la cr√©ation d'une instance Pipe, nous pouvons passer un objet <a href="">PipeOptions</a> avec des options pour le cr√©er au constructeur. <br><br>  PipeOptions a un champ de taille de segment minimum par d√©faut.  Il n'y a pas si longtemps, c'√©tait 2048, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce commit</a> a tout chang√©, maintenant 4096. Au moment d'√©crire ces lignes, la version avec 4096 √©tait un package pr√©liminaire, dans la derni√®re version, c'√©tait 2048. Cela explique le comportement du premier exemple.  Si vous √™tes critique quant √† l'utilisation d'une taille plus petite pour le tampon standard, vous pouvez la sp√©cifier dans une instance du type PipeOptions. <br><br>  Mais dans le deuxi√®me exemple, o√π la taille minimale est indiqu√©e, la longueur ne correspond pas de toute fa√ßon.  Et cela se produit d√©j√† car la cr√©ation d'un nouveau BufferSegment se produit √† l'aide de pools.  L'une des options de PipeOptions est le pool de m√©moire.  Apr√®s cela, le pool sp√©cifi√© sera utilis√© pour cr√©er un nouveau segment.  Si vous n'avez pas sp√©cifi√© votre pool de m√©moire, le ArrayPool standard sera utilis√©, qui, comme vous le savez, a plusieurs compartiments pour diff√©rentes tailles de tableaux (chacun suivant est 2 fois plus grand que le pr√©c√©dent) et, lorsqu'on lui demande une taille sp√©cifique, il recherche un compartiment avec des tableaux de taille appropri√©e (puis il y a le plus grand ou √©gal le plus proche).  Par cons√©quent, le nouveau tampon sera certainement plus volumineux que ce que vous avez demand√©.  La taille minimale du tableau dans le ArrayPool standard (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) est de 16. Mais ne vous inqui√©tez pas, c'est un pool de tableaux.  Par cons√©quent, dans la grande majorit√© des cas, la baie ne met pas √† rude √©preuve le ramasse-miettes et sera r√©utilis√©e. <br><br><h3>  # 2.5 <a href="">Span &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Il fonctionne de la m√™me fa√ßon, offrant une √©tendue de la m√©moire. <br><br>  Ainsi GetMemory () ou GetSpan () sont les principales m√©thodes d'√©criture.  Ils nous donnent un objet sur lequel nous pouvons √©crire.  Pour ce faire, nous n'avons pas besoin d'allouer de m√©moire pour de nouveaux tableaux de valeurs, nous pouvons √©crire directement dans la structure interne.  Laquelle utiliser d√©pendra principalement de l'API que vous utilisez et de la m√©thode asynchrone.  Cependant, au vu de ce qui pr√©c√®de, une question se pose.  Comment le lecteur saura-t-il combien nous avons √©crit?  Si nous avons toujours utilis√© une impl√©mentation sp√©cifique du pool, qui donne un tableau de la m√™me taille que celle demand√©e, alors le lecteur pourrait lire la totalit√© du tampon √† la fois.  Cependant, comme nous l'avons d√©j√† dit, on nous alloue un tampon avec une forte probabilit√© d'une taille plus grande.  Cela conduit √† la m√©thode suivante requise pour le fonctionnement. <br><br><h3>  # 3 <a href="">void Advance (int octets)</a> </h3><br>  Une terrible m√©thode simple.  Il prend le nombre d'octets √©crits comme argument.  Ils incr√©mentent les compteurs internes - _unflushedBytes et _writingHeadBytesBuffered, dont les noms parlent d'eux-m√™mes.  Il tronque √©galement _writingHeadMemory exactement au nombre d'octets √©crits (√† l'aide de la m√©thode Slice).  Par cons√©quent, apr√®s avoir appel√© cette m√©thode, vous devez demander un nouveau bloc de m√©moire sous forme de m√©moire ou d'√©tendue, vous ne pouvez pas √©crire sur le pr√©c√©dent.  Et le corps entier de la m√©thode est une section critique et s'ex√©cute sous un verrou. <br><br>  Il semblerait qu'apr√®s cela, le lecteur puisse recevoir des donn√©es.  Mais une √©tape suppl√©mentaire est n√©cessaire. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken cancelToken)</a> </h3><br>  La m√©thode est appel√©e apr√®s que nous ayons √©crit les donn√©es n√©cessaires dans la m√©moire re√ßue et indiqu√© combien nous y avons √©crit.  La m√©thode renvoie une ValueTask, mais elle n'est pas asynchrone (contrairement √† son descendant StreamPipeWriter).  ValueTask est un type sp√©cial (structure en lecture seule) utilis√© dans le cas o√π la plupart des appels n'utiliseront pas l'asynchronie, c'est-√†-dire que toutes les donn√©es n√©cessaires seront disponibles au moment de son appel et la m√©thode se terminera de mani√®re synchrone.  √Ä l'int√©rieur, il contient des donn√©es ou une t√¢che (au cas o√π cela ne fonctionnerait pas de mani√®re synchrone).  Cela d√©pend de l'√©tat de la propri√©t√© _writerAwaitable.IsCompleted.  Si nous recherchons ce qui change l'√©tat de cet objet en attente, nous verrons que cela se produit √† la condition que la quantit√© de donn√©es non trait√©es (non consomm√©es) (ce n'est pas exactement la m√™me chose que non lues (non examin√©es), sera expliqu√© plus loin) d√©passe un certain seuil (_pauseWriterThreshold).  La valeur par d√©faut est 16 tailles de segment.  Si vous le souhaitez, la valeur peut √™tre modifi√©e dans PipeOptions.  En outre, cette m√©thode d√©marre la continuation de la m√©thode ReadAsync, si une a √©t√© bloqu√©e. <br><br>  Renvoie un FlushResult contenant 2 propri√©t√©s - IsCanceled et IsCompleted.  IsCanceled indique si le vidage a √©t√© annul√© (appel CancelPendingFlush).  IsCompleted indique si le PipeReader s'est termin√© (en appelant les m√©thodes Complete () ou CompleteAsync ()). <br>  La partie principale de la m√©thode est r√©alis√©e sous Locke Skywalker. <br><br>  D'autres m√©thodes de PipeWriter ne pr√©sentent pas d'int√©r√™t du point de vue de la mise en ≈ìuvre et sont utilis√©es beaucoup moins souvent, par cons√©quent, seule une br√®ve description sera donn√©e. <br><br><h3>  # 5 void Complete (Exception exception = null) ou ValueTask CompleteAsync (Exception exception = null) </h3><br>  Marque le tuyau ferm√© pour √©criture.  Une fois termin√©, une exception sera lev√©e lors de la tentative d'utilisation des m√©thodes d'√©criture.  Si PipeReader est d√©j√† termin√©, l'instance de tuyau enti√®re est √©galement termin√©e.  La plupart du travail se fait sous la serrure. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Comme son nom l'indique, il termine l'op√©ration FlushAsync () en cours.  Il y a un lok. <br><br><h3>  # 7 void OnReaderCompleted (Action &lt;Exception, objet&gt; rappel, √©tat de l'objet) </h3><br>  Ex√©cute le d√©l√©gu√© d√©l√©gu√© √† la fin du lecteur.  Il y a aussi une serrure. <br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> indique actuellement que cette m√©thode peut ne pas √™tre appel√©e sur certains descendants de PipeWriter et sera supprim√©e √† l'avenir.  Par cons√©quent, vous ne devez pas lier la logique √† ces m√©thodes. <br><br><h2>  Allez sur PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (jeton CancellationToken)</a> </h3><br>  Ici, comme FlushAsync, une ValueTask est retourn√©e, ce qui indique que la m√©thode est principalement synchrone, mais pas toujours.  D√©pend de l'√©tat de _readerAwaitable.  Comme avec FlushAsync, vous devez trouver quand _readerAwaitable est d√©fini sur incomplet.  Cela se produit lorsque PipeReader lit tout dans la liste (ou qu'il contient des donn√©es qui ont √©t√© marqu√©es comme examin√©es et ont besoin de plus de donn√©es pour continuer).  Ce qui, en fait, est logique.  En cons√©quence, nous pouvons conclure qu'il est souhaitable d'affiner Pipe √† votre travail, de d√©finir toutes ses options de mani√®re r√©fl√©chie, sur la base de statistiques identifi√©es empiriquement.  Une configuration appropri√©e r√©duira la probabilit√© d'une branche d'ex√©cution asynchrone et permettra un traitement plus efficace des donn√©es.  Presque toute la m√©thode est entour√©e d'un verrou. <br><br>  Renvoie un myst√©rieux <a href="">ReadResult</a> .  En fait, il s'agit simplement d'un tampon + indicateurs indiquant l'√©tat de l'op√©ration (IsCanceled - si ReadAsync a √©t√© annul√© et IsCompleted indiquant si le PipeWriter a √©t√© ferm√©).  Dans ce cas, IsCompleted est une valeur indiquant si les m√©thodes PipeWriter Complete () ou CompleteAsync () ont √©t√© appel√©es.  Si ces m√©thodes ont √©t√© appel√©es avec une exception, elles seront lev√©es lors de la tentative de lecture. <br><br>  Le tampon a de nouveau un type myst√©rieux - <a href="">ReadOnlySequence</a> .  Ceci, √† son tour, est un objet pour contenir des <a href="">segments (ReadOnlySequenceSegment) des</a> indices <a href="">de</a> d√©but et de fin + d√©but et fin √† l'int√©rieur des segments correspondants.  Ce qui ressemble en fait √† la structure de la classe Pipe elle-m√™me.  Soit dit en passant, BufferSegment est le successeur de ReadOnlySequenceSegment, ce qui sugg√®re qu'il y est utilis√©.  Gr√¢ce √† cela, vous pouvez simplement vous d√©barrasser des allocations de m√©moire inutiles pour le transfert de donn√©es de l'√©crivain au lecteur. <br>  ReadOnlySpan peut √™tre obtenu √† partir du tampon pour un traitement ult√©rieur.  Pour terminer l'image, vous pouvez v√©rifier si le tampon contient un seul ReadOnlySpan.  S'il contient, nous n'avons pas besoin d'it√©rer sur la collection d'un √©l√©ment et nous pouvons l'obtenir en utilisant la propri√©t√© First.  Sinon, vous devez parcourir tous les segments du tampon et traiter chaque ReadOnlySpan. <br><br>  Sujet de discussion - dans la classe ReadOnlySequence, les types de r√©f√©rence nullables sont activement utilis√©s et il y a goto (pas pour quitter l'imbrication et pas dans le code g√©n√©r√©) - en particulier <br><br>  Apr√®s le traitement, vous devez indiquer clairement √† l'instance Pipe que nous avons lu les donn√©es. <br><br><h3>  # 2 <a href="">bool TryRead (r√©sultat ReadResult)</a> </h3><br>  Version synchrone.  Vous permet d'obtenir le r√©sultat s'il l'est.  S'il n'est pas d√©j√† l√†, contrairement √† ReadAsync, il ne bloque pas, mais renvoie false.  Aussi dans la serrure. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition consomm√©, SequencePosition examin√©)</a> </h3><br>  Dans cette m√©thode, vous pouvez sp√©cifier combien d'octets nous lisons et combien trait√©s.  Les donn√©es lues mais non trait√©es seront renvoy√©es lors de la prochaine lecture.  Cette fonctionnalit√© peut sembler √©trange √† premi√®re vue, mais lors du traitement d'un flux d'octets, il est rarement n√©cessaire de traiter chaque octet individuellement.  En r√®gle g√©n√©rale, les donn√©es sont √©chang√©es √† l'aide de messages.  Il peut arriver que le lecteur, lors de la lecture, re√ßoive un message entier et une partie du second.  Le tout doit √™tre trait√©, et une partie du second doit √™tre laiss√©e la prochaine fois afin qu'elle accompagne la partie restante.  La m√©thode AdvanceTo accepte une SequencePosition, qui est en fait un segment + index.  Lors du traitement de tout ce que ReadAsync a lu, vous pouvez sp√©cifier buffer.End.  Sinon, vous devrez cr√©er explicitement une position, indiquant le segment et l'index auquel le traitement a √©t√© arr√™t√©.  Sous le capot lok. <br>  De plus, si la quantit√© d'informations brutes est inf√©rieure √† la faille install√©e (_resumeWriterThreshold), il d√©marre la poursuite de PipeWriter s'il √©tait bloqu√©.  Par d√©faut, ce seuil est de 8 volumes de segment (la moiti√© du seuil de blocage). <br><br><h3>  # 4 void Complete (Exception exception = null) </h3><br>  Termine PipeReader.  Si PipeWriter est termin√© √† ce stade, l'instance Pipe enti√®re se termine.  Verrouillez √† l'int√©rieur. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Vous permet d'annuler la lecture actuellement attendue.  Locke. <br><br><h3>  # 6 void OnWriterCompleted (Action &lt;Exception, objet&gt; rappel, √©tat de l'objet) </h3><br>  Vous permet de sp√©cifier le d√©l√©gu√© √† ex√©cuter √† la fin du PipeWriter. <br>  Comme la m√©thode similaire pour PipeWriter, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation a</a> la m√™me note qui sera supprim√©e.  Serrure sous le capot. <br><br><h2>  Exemple </h2><br><br>  La liste ci-dessous montre un exemple de travail avec des tuyaux. <br>  Depuis l'introduction de .NET Core Span and Memory, de nombreuses classes pour travailler avec des donn√©es ont √©t√© compl√©t√©es par des surcharges utilisant ces types.  Le sch√©ma d'interaction g√©n√©ral sera donc √† peu pr√®s le m√™me.  Dans mon exemple, j'ai utilis√© des pipelines pour travailler avec des tuyaux (j'aime les mots racines), c'est-√†-dire  canaux - objets OS pour la communication interprocessus.  L'API de canal vient d'√™tre √©tendue en cons√©quence pour lire les donn√©es dans la port√©e et la m√©moire.  La version asynchrone utilise la m√©moire, car la m√©thode asynchrone sera convertie en m√©thode de mod√®le √† l'aide d'une machine √† √©tats finis g√©n√©r√©e automatiquement, dans laquelle toutes les variables locales et les param√®tres de m√©thode sont stock√©s, et puisque Span est une structure en lecture seule ref, elle ne peut pas √™tre sur le tas, respectivement, en utilisant Span dans une m√©thode asynchrone n'est pas possible.  Mais il existe √©galement une version synchrone de la m√©thode qui vous permet d'utiliser Span.  Dans mon exemple, j'ai essay√© les deux et il s'est av√©r√© que la version synchrone dans cette situation se montre mieux.  Lorsque vous l'utilisez, moins de r√©cup√©ration de place se produit et le traitement des donn√©es est plus rapide.  Mais c'√©tait uniquement parce qu'il y avait beaucoup de donn√©es.  Dans le cas o√π une situation est probable dans laquelle il n'y aura pas de donn√©es au moment de la demande pour le prochain lot, vous devez utiliser la version asynchrone afin de ne pas forcer le processeur au repos. <br>  L'exemple contient des commentaires qui expliquent certains points.  J'attire votre attention sur le fait que malgr√© le fait que les fragments du programme responsable de la lecture du tube et du traitement soient s√©par√©s, lors de l'√©criture dans un fichier, les donn√©es sont lues exactement de l'endroit o√π elles sont √©crites lors de la lecture du tube. <br><br><div class="spoiler">  <b class="spoiler_title">Des ann√©es d'√©volution pour une fonction puissante - Maine asynchrone</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/         -       . //int readBytes = await _namedPipe.ReadAsync(buffer, token); //         PipeWriter Span //         -       . int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); //      ,        //         if (readBytes == 0) { await Task.Delay(500, token); continue; } // ,       _pipeWriter.Advance(readBytes); //  ,      PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); //  PipeReader  ,       //        ,      if (result.IsCompleted) { break; } } //  _pipeWriter     Pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Processeur de donn√©es</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">//     Pipe ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; //      await _bytesProcessor.ProcessBytesAsync(buffer, token); // ,      .       ,   //  ,               //    IBytesProcessor.ProcessBytesAsync   ,    _pipeReader.AdvanceTo(buffer.End); //  PipeWriter  ,      //      ,      if (result.IsCompleted) { break; } } //  _pipeReader     Pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprocessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//,         IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464921/">https://habr.com/ru/post/fr464921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464909/index.html">¬´Ils nous regardent¬ª: ce qui peut arriver dans une mini-fourgonnette discr√®te juste sous votre fen√™tre</a></li>
<li><a href="../fr464913/index.html">"Know kaizen": quelle est cette philosophie pour am√©liorer les processus de production</a></li>
<li><a href="../fr464915/index.html">Optimisation de la r√©cursivit√© de la queue JavaScript</a></li>
<li><a href="../fr464917/index.html">Apr√®s le cyberpunk: ce que vous devez savoir sur les genres actuels de science-fiction moderne</a></li>
<li><a href="../fr464919/index.html">Contr√¥le int√©gr√© des ressources de la RAM utilis√©e dans l'application</a></li>
<li><a href="../fr464925/index.html">Guide vocal UX: situations, mod√®les, outils (et un peu de soutien moral)</a></li>
<li><a href="../fr464927/index.html">Mineur ASIC d'occasion: risques, v√©rification et hashrate rec√¢bl√©</a></li>
<li><a href="../fr464929/index.html">Chargement d'image de navigateur paresseux (attribut de chargement)</a></li>
<li><a href="../fr464931/index.html">Assembleur ins√®re ... en C #?</a></li>
<li><a href="../fr464933/index.html">Applications pour les livres √©lectroniques sur le syst√®me d'exploitation Android. Partie 4. Jeux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>