<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèø ‚óΩÔ∏è üàπ Une br√®ve introduction au d√©veloppement d'applications de microcontr√¥leur stm32 üôÖ üëµüèΩ ‚ùáÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tr√®s souvent, les gens se tournent vers moi pour leur demander de les aider √† d√©marrer avec les microcontr√¥leurs de la famille stm32. En r√©pondant √† l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une br√®ve introduction au d√©veloppement d'applications de microcontr√¥leur stm32</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/407045/">  Tr√®s souvent, les gens se tournent vers moi pour leur demander de les aider √† d√©marrer avec les microcontr√¥leurs de la famille stm32.  En r√©pondant √† leurs questions et en les aidant dans leurs projets, j'ai r√©alis√© qu'il valait mieux √©crire un article qui serait utile √† tous ceux qui veulent commencer √† programmer des microcontr√¥leurs stm32.  Malgr√© toutes ses nombreuses fonctionnalit√©s, les contr√¥leurs stm32 ont un seuil d'entr√©e assez √©lev√©, qui pour beaucoup reste indisponible.  Dans cet article, je vais essayer de donner au lecteur un guide d√©taill√© sur la fa√ßon de cr√©er des projets sur stm32 et d'organiser votre programme. <br><br>  En utilisant le microcontr√¥leur stm32f103c8t6 et le module Blue pill comme exemple, nous examinerons la structure d'un projet typique pour l'environnement de d√©veloppement IAR et cr√©erons un firmware fonctionnel. <br><br>  Tous ceux qui sont int√©ress√©s √† commencer √† travailler avec stm32, bienvenue sur cat. <br><a name="habracut"></a><br><h4>  De quoi avons-nous besoin pour poursuivre nos travaux </h4><br>  Tous les exemples suivants ont √©t√© r√©alis√©s dans l'environnement de travail IAR Embedded pour ARM v7.30.  L'environnement est install√© sur Windows XP, qui est install√© dans la machine virtuelle VirtualBOX lanc√©e √† partir du capitaine Mac OS X El.  Le programmateur ST-LINK est √©galement utilis√©, qui se connecte √† la carte de pilule bleue achet√©e sur AliExpress pour ~ 120‚ÇΩ. <br><br>  Pour cr√©er un projet typique, vous aurez besoin de: <br><br><ul><li>  <b>Module Blue Pill ou similaire</b> <br><br>  Ils sont facilement localis√©s sur AliExpress avec la demande ¬´carte stm32f103c8t6¬ª et co√ªtent environ 100 roubles. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/729/f10/a78/729f10a784994ac5ba9c0f2ed34731ab.jpg" width="500"></div><br></li><li>  <b>Programmeur ST-Link</b> <br><br>  Il est √©galement facilement disponible sur AliExpress sur demande de "stlink v2" et co√ªte √©galement environ 100 roubles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ca3/e8f/74b/ca3e8f74bb65475eb9b93fb6c9c4f7ba.jpg" width="500"></div><br>  Il existe une version plus compl√®te, con√ßue pour connecter un connecteur ruban standard IDC20 <br><div style="text-align:center;"><img src="https://habrastorage.org/web/fda/5fb/237/fda5fb237daf4826a9375fb34c7e548e.jpg" width="500"></div><br></li><li>  <b>Environnement de d√©veloppement IAR 7.30 ou version ult√©rieure</b> <br><br>  La version limit√©e 8.10 peut √™tre t√©l√©charg√©e sur le site officiel. <br></li><li>  <b>Un mod√®le de projet qui contient tous les composants n√©cessaires</b> <br><br>  Le mod√®le peut √™tre t√©l√©charg√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> <br></li><li>  <b>R√©f√©rence de la fonction STDPeripheralLibrary3.5.0</b> <br><br>  Le projet comprend une biblioth√®que de fonctions StdPeriph3.5.0.  Un peu vieux pour les projets s√©rieux, mais pour les d√©butants c'est assez simple et √©vite un mal de t√™te en travaillant avec la p√©riph√©rie du microcontr√¥leur.  Le manuel au format WinHelp (CHM) peut √™tre t√©l√©charg√© <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D'ici</a> <br></li><li>  <b>RM0008 Manuel de r√©f√©rence</b> <br><br>  Manuel de r√©f√©rence pour les microcontr√¥leurs de la famille stm32f103c8.  Le livre de r√©f√©rence contient une description du c≈ìur et de la p√©riph√©rie du microcontr√¥leur, son architecture et des descriptions des registres.  Il est conseill√©, au fil du temps, de lire et de traverser et de savoir comment fonctionne chaque composant p√©riph√©rique.  Si vous √™tes un partisan du CMSIS nu, alors sans ce PDF, vous ne pouvez pas le faire.  Si le d√©butant qui utilise Perlib, vous devez toujours lire comment fonctionne tel ou tel module p√©riph√©rique.  Vous pouvez t√©l√©charger la r√©f√©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site Web de STMicroelectonics</a> <br></li></ul><br><h4>  Mod√®le de projet </h4><br>  Le mod√®le de projet ci-joint n'a pas √©t√© enti√®rement extrait de quelque part sur Internet, mais a √©t√© cr√©√© de nos propres mains √† partir d'exemples qui sont all√©s √† PeripheralLibrary, de fichiers du package CMSIS et de nos propres am√©liorations.  Le mod√®le de projet ne contient pas de fichiers qui appartiennent √† n'importe quel environnement de d√©veloppement et peuvent √™tre utilis√©s pour chacun d'entre eux (je ne l'ai pas test√©, mais je suppose que oui). <br><br>  Une description d√©taill√©e de la structure du r√©pertoire peut sembler trop compliqu√©e pour les d√©butants, cependant, pour l'√©tudier, elle sera √©galement utile. <br><br><div class="spoiler">  <b class="spoiler_title">Structure du r√©pertoire du projet</b> <div class="spoiler_text"><ul><li>  <b>config</b> <br>  <i>stm32f10x_conf.h</i> <br><br>  Ce fichier appartient au package StdPeripheral et contient l'inclusion de fichiers d'en-t√™te utilis√©s dans le projet p√©riph√©rique du microcontr√¥leur.  Il est suppos√© que le programmeur commentera les fichiers inutilis√©s, selon le projet.  Par d√©faut, tous les fichiers sont inclus. <br></li><li>  <b>noyau</b> <br><br>  Ce r√©pertoire contient des fichiers CMSIS sp√©cifiques au c≈ìur du processeur ARM CortexM3. <br></li><li>  <b>perlib</b> <br><br>  Ce r√©pertoire contient les fichiers d'en-t√™te et le code source de la biblioth√®que Perlib dans les r√©pertoires <i>inc</i> et <i>src</i> . <br></li><li>  <b>d√©marrage</b> <br><br>  Voici les fichiers avec le code d'initialisation principal du contr√¥leur, qui installent les gestionnaires d'interruption du noyau ARM et appellent les fonctions d'initialisation du syst√®me d'horloge du noyau et l'initialisation PLL.  Chaque type de microcontr√¥leur poss√®de son propre fichier distinct. <br><br>  Le code de ce fichier est ex√©cut√© AVANT l'appel de la fonction main () de votre programme. <br>  Les gestionnaires d'interruption du noyau ARM, ainsi que les fonctions d'initialisation de l'horloge, ne sont pas stock√©s dans ces fichiers, ils sont uniquement appel√©s.  Et ils sont stock√©s dans les fichiers du r√©pertoire syst√®me, qui seront discut√©s plus tard. <br><br>  Par exemple, pour que le microcontr√¥leur stm32f103c8t6 fonctionne √† 72 MHz et non √† 8 MHz par d√©faut, vous devez connecter le fichier <i>startup_stm32f10x_md.s</i> dans le projet. <br></li><li>  <b>syst√®me</b> <br><br>  Ce r√©pertoire contient des fichiers qui contiennent toutes les fonctions de l'initialisation initiale du syst√®me, des gestionnaires d'interruption pour le noyau ARM, ainsi que des descriptions des noms et des champs des registres du microcontr√¥leur. <br><br>  <i>stm32f10x.h</i> <br><br>  Il s'agit d'un fichier du package CMSIS qui contient les adresses, les noms des registres et leurs champs pour la p√©riph√©rie du microcontr√¥leur.  Chaque module p√©riph√©rique est pr√©sent√© ici comme une structure dont les champs sont des registres.  Il d√©finit √©galement des constantes et des masques de bits pour les champs de registre. <br><br>  <i>stm32f10x_it</i> <br><br>  Les gestionnaires d'interruption du noyau ARM sont √©crits ici.  √Ä l'exception du gestionnaire SysTick, que j'ai utilis√© pour calculer les intervalles de temps, ces gestionnaires d'interruption sont vides.  Si, soudainement, votre projet n√©cessite la gestion des interruptions du noyau, alors ce fichier est fait pour vous. <br><br>  <b>Ne confondez pas la gestion des interruptions du c≈ìur du processeur et la gestion des interruptions p√©riph√©riques.</b>  <b>Les interruptions p√©riph√©riques, telles qu'une minuterie ou USART, doivent √™tre effectu√©es dans vos propres fichiers de projet, que vous √©crivez vous-m√™me et ajoutez √† la racine du r√©pertoire du projet.</b> <br><br>  <i>system_stm32f10x</i> <br><br>  Ces deux fichiers contiennent les m√™mes fonctions d'initialisation de l'horloge du noyau et de la PLL qui sont appel√©es √† partir du fichier d'initialisation dans le r√©pertoire de d√©marrage.  √Ä savoir, les fonctions SystemInit et SystemCoreClockUpdate. <br></li></ul><br></div></div><br><h4>  Cr√©er un projet </h4><br>  Pour cr√©er notre premier projet, vous devez d'abord cr√©er un dossier pour celui-ci.  Appelons cela EX01. <br>  Nous lan√ßons IAR et dans le menu <b>Projet</b> , s√©lectionnez <b>Cr√©er un nouveau projet</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figure 1. Cr√©ation d'un nouveau projet</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/c67/e37/c9c/c67e37c9c977478bacbf677bd8891e63.jpg"><br></div></div><br>  La valeur de la cha√Æne d'outils doit √™tre laiss√©e √† ARM, et nous s√©lectionnons le mod√®le de projet C ‚Üí principal.  Cliquez ensuite sur OK. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 2. Enregistrement d'un projet vide</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/bcb/580/f3c/bcb580f3cf9345988716dc873e1ccde0.jpg"><br></div></div><br>  Une fen√™tre de sauvegarde du projet appara√Ætra.  Dans ce document, vous devez s√©lectionner le dossier cr√©√© pr√©c√©demment.  Appelons le projet ex01.  Maintenant, vous pouvez cliquer sur <b>Enregistrer</b> . <br><br>  En cons√©quence, un fichier principal vide et un projet vide seront cr√©√©s, qui ne contiennent pas encore de param√®tres.  L'√©tape suivante consiste √† enregistrer l'espace de travail afin qu'il n'interf√®re pas avec nos questions √† l'avenir.  Cliquez sur <b>Fichier ‚Üí Enregistrer l'espace de travail</b> .  Appelez-le ex01 et cliquez sur <b>Enregistrer</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figure 3. Enregistrement de l'espace de travail</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/318/79b/2e5/31879b2e57824c01845fbf01a107f25b.png"><br></div></div><br>  Nous sommes maintenant pr√™ts √† utiliser le mod√®le de projet.  Copiez-le de l'archive dans notre dossier EX01. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 4. Copie de fichiers d'un mod√®le vers un nouveau projet</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/857/328/568/8573285685844c26b24171bd6e22efcc.jpg"><br></div></div><br>  Les fichiers principaux qui ont cr√©√© le mod√®le de projet doivent √™tre remplac√©s par des fichiers du projet. <br><br>  Apr√®s avoir copi√© le mod√®le de projet, vous devez configurer le projet lui-m√™me. <br><br>  Pour ce faire, s√©lectionnez le menu <b>Projet ‚Üí Options</b> .  Une fen√™tre s'ouvrira qui contiendra une liste de cat√©gories d'options sur la gauche, chacune ayant certains signets. <br><br>  S√©lectionnez la cat√©gorie <b>Options g√©n√©rales</b> et l'onglet <b>Cible</b> .  Dans le groupe <b>Variante</b> du <b>processeur</b> , s√©lectionnez l'option <b>P√©riph√©rique</b> et cliquez sur le bouton pour s√©lectionner un p√©riph√©rique sp√©cifique √† c√¥t√© de lui.  Dans notre cas, ce sera ST ‚Üí STM32F103 ‚Üí ST STM32F103x8. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 5. S√©lection du p√©riph√©rique cible pour le projet</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/fc8/d85/19a/fc8d8519a25742309611690c941e4853.jpg"><br></div></div><br>  La cat√©gorie suivante qui requiert notre attention est la cat√©gorie du <b>compilateur C / C ++</b> et l'onglet <b>Pr√©processeur</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figure 6. Param√®tres des signets du pr√©processeur</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/993/df8/ed3/993df8ed3a04468692671738119e9347.jpg"><br></div></div><br>  Le bloc <b>Additionner les r√©pertoires</b> doit √™tre rempli avec des liens vers les r√©pertoires du mod√®le de projet. <br><br>  <b>PreInclude file,</b> vous devez s√©lectionner le fichier de configuration de la biblioth√®que PerLib et les <b>symboles d√©finis doivent √™tre</b> sp√©cifi√©s avec STM32F10X_MD afin que les fichiers d'initialisation √©tablissent l'horloge du noyau correcte et configurent correctement la PLL. <br><br>  Puisque nous utilisons ST-Link v2 en tant que programmeur, vous devez choisir le pilote que l'environnement de d√©veloppeur utilisera.  S√©lectionnez la cat√©gorie <b>D√©bogage</b> et l'onglet <b>Configuration</b> , sur lesquels s√©lectionnez <b>Driver ST-Link</b> dans la liste d√©roulante. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 7. Choix d'un outil de d√©bogage</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/280/f5c/b81/280f5cb81ba84c0790fd3f7f7d413015.jpg"><br></div></div><br>  Vous devez maintenant configurer le t√©l√©chargement du firmware sur le contr√¥leur.  Vous pouvez le faire dans la m√™me cat√©gorie, sur l'onglet <b>T√©l√©chargement</b> .  Nous sommes int√©ress√©s par les options <b>V√©rifier le t√©l√©chargement</b> et <b>Utiliser le (s) chargeur (s) flash</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Figure 8. Configuration des param√®tres de t√©l√©chargement du micrologiciel dans le microcontr√¥leur</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/330/0af/4d7/3300af4d78fe436687c4a39dfc530d2f.jpg"><br></div></div><br>  Puisque nous avons choisi ST-Link comme moyen de t√©l√©charger le firmware sur le contr√¥leur et de d√©boguer, vous devez configurer son pilote pour qu'il fonctionne avec notre contr√¥leur.  La carte Blue Pill n'a pas de connecteur JTAG √† part enti√®re qui pourrait fonctionner en utilisant le protocole JTAG complet.  √Ä la place, nous utiliserons son mode simplifi√©, appel√© SWD.  Ce mode JTAG utilise seulement trois lignes.  Ce sont GND, SWDCLK et SWDIO.  Par d√©faut, le mode JTAG complet est activ√©, nous devons donc le changer en SWD et d√©finir la fr√©quence de base sur 72 MHz. <br>  Dans la liste des cat√©gories, s√©lectionnez <b>ST-LINK</b> et changez l'option dans le groupe <b>Interface</b> en SWD. <br><br>  Vous pouvez maintenant cliquer sur <b>OK</b> , notre projet est configur√©. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 9. Configuration du pilote ST-LINK</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/60e/e90/b49/60ee90b49dce4987bbca7c96ff28e25a.jpg"><br></div></div><br>  Il reste maintenant √† faire la derni√®re, mais tr√®s importante action, avant de commencer √† compiler notre premier programme.  Vous devez ajouter des fichiers du mod√®le au projet. <br><br>  Les fichiers sont ajout√©s au projet dans le panneau Espace de travail.  Il y a d√©j√† un fichier principal, cependant nous devons ajouter PerLib, ainsi qu'un des fichiers d'initialisation du r√©pertoire de d√©marrage et les fichiers d'initialisation du r√©pertoire syst√®me.  Nous pourrions simplement jeter un tas, mais alors nous aurions √† souffrir et si le projet devenait trop grand, alors un tel vidage serait tr√®s g√™nant. <br><br>  L'environnement de d√©veloppement IAR vous permet de cr√©er des groupes de fichiers.  Les groupes sont un concept purement virtuel.  Ils vous permettent uniquement d'organiser des fichiers dans un projet.  Les groupes n'ont rien √† voir avec les r√©pertoires de disques. <br><br>  Nous allons cr√©er des groupes pour chaque r√©pertoire √† partir du mod√®le de projet et y placer les fichiers de mod√®le. <br><br>  Commencez par cr√©er le groupe de configuration et placez-y le fichier stm32f10x_conf.h du r√©pertoire de configuration. <br>  Pour ce faire, cliquez avec le bouton droit sur le nom du projet dans la fen√™tre Espace de travail et s√©lectionnez Ajouter ‚Üí Ajouter un groupe dans le menu d√©roulant.  Nommez le groupe Config. <br><br>  Pour ajouter des fichiers √† ce groupe, faites un clic droit dessus et s√©lectionnez Ajouter ‚Üí Ajouter des fichiers.  Dans la fen√™tre qui s'ouvre, ouvrez le dossier config et s√©lectionnez le fichier stm32f10x_conf.h. <br><br><img src="https://habrastorage.org/web/e13/e92/013/e13e92013b8e4a96b544d5626dcda21f.jpg"><br><br>  De m√™me, nous ajoutons le contenu des dossiers Perlib, D√©marrage et Syst√®me.  Vous n'avez pas besoin d'ajouter le dossier Core, seuls les fichiers d'en-t√™te sont disponibles √† partir de la biblioth√®que Perlib ajout√©e. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 11. Vue compl√®te d'un projet vide et enti√®rement configur√©</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/02f/09d/d52/02f09dd5286d4b17a1e2ea6d6c1e3542.jpg"><br></div></div><br>  Maintenant, le projet est compl√®tement pr√™t pour un d√©veloppement ult√©rieur. <br><br><h4>  Un peu de th√©orie </h4><br>  De nombreux programmeurs d√©butants sont habitu√©s au fait que le programme se compose d'un cycle dans lequel les fonctions sont appel√©es les unes apr√®s les autres.  La fonction suivante n'est appel√©e qu'apr√®s que la pr√©c√©dente a compl√®tement termin√© son travail.  Ce paradigme est propos√© par Arduino ou divers articles avec des le√ßons pour d√©butants.  Cependant, les grands projets sont rarement monothread.  En r√®gle g√©n√©rale, un firmware plus ou moins s√©rieux peut avoir plusieurs threads. <br><br>  Les microcontr√¥leurs, pour organiser le multithreading, utilisent des syst√®mes d'exploitation en temps r√©el (RTOS), tels que ThreadX ou FreeRTOS.  Tous vous permettent de cr√©er de nombreux cycles de ce type dans lesquels les fonctions sont ex√©cut√©es les unes apr√®s les autres, seuls les cycles fonctionnent en m√™me temps.  Comme plusieurs Arduins enfonc√©s dans un microcontr√¥leur. <br><br>  Malgr√© toute sa puissance, les RTOS introduisent certaines difficult√©s.  Par exemple, chaque thread a sa propre pile, sa propre zone de m√©moire.  Si plusieurs threads doivent acc√©der au m√™me emplacement m√©moire, ils doivent synchroniser leurs actions √† l'aide de mutex ou de s√©maphores.  Une mauvaise utilisation des objets de synchronisation peut entra√Æner des blocages ou une inversion des priorit√©s des threads.  De plus, le traitement des interruptions de la p√©riph√©rie n√©cessite √©galement une attention particuli√®re dans un environnement multi-thread, car le probl√®me se pose de sauvegarder la pile et de choisir les conditions dans lesquelles l'appel d'interruption ne d√©truit pas la pile de flux interrompue.  Et le gestionnaire d'interruption lui-m√™me doit √©galement fonctionner jusqu'√† la fin. <br><br>  Le RTOS alloue un petit intervalle de temps √† chaque thread.  Apr√®s cet intervalle, le RTOS passe au flux suivant (peu importe si le pr√©c√©dent a termin√© ses actions ou non) et ainsi de suite.  Diff√©rents flux peuvent recevoir des intervalles de temps diff√©rents, selon leur priorit√©.  Ce type de multithreading est appel√© √©viction. <br><br>  Pour trier les flux et leur transf√©rer le contr√¥le pendant un court intervalle de temps, le composant RTOS, appel√© ¬´ordonnanceur¬ª, est responsable. <br><br>  Il est difficile pour les programmeurs d√©butants de ma√Ætriser imm√©diatement les p√©riph√©riques √©normes et complexes de stm32 tout en apprenant le RTOS. <br><br>  Heureusement, il existe des moyens de cr√©er des applications multithreads sans aucun RTOS.  Pour cela, le ¬´multithreading coop√©ratif¬ª vient √† notre secours.  Le multithreading coop√©ratif vous permet de r√©aliser des projets multithread relativement petits sans la participation de RTOS. <br><br>  Quelle est l'essence du multithreading coop√©ratif?  Avec un tel multithreading, chaque thread prend autant de temps processeur qu'il en a besoin, mais pas assez pour terminer sa t√¢che en une seule fois.  Cela met en avant des exigences tr√®s strictes pour le style d'√©criture des applications coop√©ratives multi-thread. <br><br>  Le multithreading coop√©ratif pr√©sente plusieurs avantages et inconv√©nients.  Le choix du paradigme multithreading d√©pend enti√®rement du d√©veloppeur et des exigences de la t√¢che qu'il effectue. <br>  Les principaux avantages du multithreading coop√©ratif sont l'absence d'un planificateur, d'une pile unique pour tous les threads, l'absence de la n√©cessit√© de synchroniser les threads et la simplicit√© du traitement des interruptions depuis la p√©riph√©rie. <br><br>  Malheureusement, il existe √©galement des inconv√©nients.  En particulier, le gel de l'un des threads entra√Ænera le gel de l'ensemble du programme dans son ensemble.  En outre, l'orthographe incorrecte d'un ou de plusieurs threads peut entra√Æner un retard dans l'ex√©cution du reste.  Et ce n'est pas une liste compl√®te. <br><br><h4>  Structure d'application coop√©rative multi-thread </h4><br>  Les applications coop√©ratives multi-thread sont bas√©es sur une machine d'√©tat.  Je ne le d√©crirai pas en d√©tail, car <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> il est d√©j√† d√©crit en d√©tail.  Cependant, je vais expliquer bri√®vement l'essentiel.  Une machine √† √©tats est un objet abstrait dont le nombre d'√©tats est fini.  Un objet passe d'un √©tat √† un autre soit sous l'influence de facteurs externes, soit √† cause de processus internes.  Dans notre cas, un thread d'application coop√©rative est une impl√©mentation d'une machine d'√©tat. <br><br>  Un flux a une liste d'√©tats.  Dans chaque √©tat, soit une action courte soit rien n'est effectu√©e.  La commutation d'√©tats peut √™tre effectu√©e soit en appelant des fonctions externes, soit lorsque surviennent des conditions dans lesquelles il n'est plus possible que le flux soit dans l'√©tat actuel et qu'il soit n√©cessaire de passer √† un autre √©tat. <br><br>  Depuis plusieurs ann√©es de travail avec les microcontr√¥leurs stm32, j'ai d√©velopp√© une structure d'application coop√©rative multi-thread, que je souhaite vous pr√©senter. <br><br>  Chaque flux est un module distinct (fichier d'en-t√™te et fichier de code). <br><br>  Le module a des fonctions publiques, dont les prototypes sont enregistr√©s dans le fichier d'en-t√™te et priv√©s, dont l'appel est impossible de l'ext√©rieur.  Chaque module a au moins deux fonctions publiques: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XXX_Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XXX_Control</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  La fonction XXX_Init () est appel√©e avant la boucle principale dans la fonction main () et la fonction XXX_Control () est appel√©e dans la boucle principale de la fonction principale. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   XXX XXX_Init(); //   YYY YYY_Init(); //   ZZZ ZZZ_Init(); while(true){ XXX_Control(); YYY_Control(); ZZZ_Control(); } }</span></span></code> </pre><br>  Un fichier de module XXX pourrait ressembler √† ceci: <br><br>  <b>xxx.c</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xxx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXX_WATER_MAX_THRESHOLD 100500 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXX_WATER_MIN_THRESHOLD 9000 typedef enum{ idle, state1, state2, : stateX, }XXX_States; static XXX_States xxxCurrentState = idle; static int xxxToiletWaterLevel=0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//---------    -------- void private_init1() { } void private_init2() { } void private_measureLevel() { } void private_flush() { } void private_superFlush() { } //--------    --------- void XXX_Init() { xxxCurrentState=idle; } void XXX_Reset() { private_superFlush(); xxxCurrentState=idle; } void XXX_Control() { switch(xxxCurrentState) { case idle: private_measureLevel(); if(xxxToiletWaterLevel&gt;XXX_WATER_MIN_THRESHOLD) xxxCurrentState=state1; break; case state1: if(xxxToiletWaterLevel&lt;XXX_WATER_MAX_THRESHOLD) { private_flush(); xxxCurrentState=idle; } else xxxCurrentState=state2; break; case state2: //   break; } }</span></span></span></span></code> </pre><br><h4>  Exemple d'application coop√©rative multithread </h4><br>  Afin de ne pas √™tre trop abstrait, imaginons un vrai d√©fi.  Supposons que nous ayons un flux qui clignote une LED (deux fois par seconde), qui est connect√© par une cathode au port PC13.  Nous avons √©galement un flux qui re√ßoit des commandes via le port s√©rie.  Si le caract√®re ¬´0¬ª (0x30) arrive, le clignotement s'arr√™te et un signe ¬´-¬ª est envoy√© au client.  Si le caract√®re ¬´1¬ª (0x31) arrive, le clignotement s'allume et le caract√®re ¬´*¬ª est renvoy√© au client.  Une pression sur une autre touche renvoie le caract√®re ¬´E¬ª. <br><br>  Nous placerons le flux de contr√¥le de la LED clignotante dans les fichiers modLed.h et modLed.c.  Ce thread est initialement inactif et ne fait rien.  Cependant, sa fonction publique MODLED_command, lorsque l'argument modled_on est re√ßu, bascule l'√©tat du flux sur <br>  modled_st_on.  Dans cet √©tat, le flux allume la LED, se souvient de la valeur initiale du compteur global_count et entre dans l'√©tat de veille modled_st_wait1.  Dans cet √©tat, il v√©rifie en permanence la valeur actuelle du compteur global_count, et lorsque la diff√©rence entre le compte courant et le compte initial est MODLED_BLINK_DELAY_ON, le flux passe √† l'√©tat modled_st_off.  Dans cet √©tat, le flux √©teint la LED, se souvient de la valeur actuelle du compte et passe √† l'√©tat modled_st_wait2.  Dans cet √©tat, le thread compare √©galement la valeur actuelle du compteur global_count avec le compteur initial, et lorsque la diff√©rence est MODLED_BLINK_DELAY_OFF, il passe √† l'√©tat modled_st_on.  Et ainsi, cela continuera jusqu'√† ce que quelqu'un appelle la fonction MODLED_command avec l'argument modled_off.  Ensuite, la fonction basculera l'√©tat du flux vers modled_st_clamp.  Le thread √©teindra la LED et passera √† l'√©tat modled_st_idle. <br><br>  L'initialisation du flux modul√© commence dans la fonction principale en appelant la fonction MODLED_init ().  Cette fonction initialise le port GPIOC et d√©finit l'√©tat initial du flux.  Ensuite, dans la boucle, la fonction MODLED_control () est constamment appel√©e, ce qui en une it√©ration effectue une v√©rification de l'√©tat actuel et effectue de petites actions pour elle. <br><br>  Le flux de contr√¥le du port s√©rie est identique. <br><br>  Il dispose de fonctions d'initialisation de port GPIO priv√© et d'un module USART1.  De plus, √† l'int√©rieur, il est cach√© un gestionnaire d'interruption du module p√©riph√©rique USART1, dans lequel l'octet re√ßu en cours est stock√© et l'√©tat du flux est d√©fini sur moduart_st_command. <br><br>  Initialement, le flux moduart est dans l'√©tat moduart_st_idle, dans lequel il attend la r√©ception d'un octet.  D√®s qu'un octet est re√ßu et stock√© dans une variable, le gestionnaire d'interruption change l'√©tat du flux en moduart_st_command et le flux v√©rifie l'octet re√ßu.  Si l'octet re√ßu est la commande ¬´0¬ª, la fonction MODLED_command est appel√©e avec l'argument modled_off et le caract√®re ¬´-¬ª est renvoy√©.  Si l'octet re√ßu est la commande ¬´1¬ª, la fonction MODLED_command est appel√©e avec l'argument modled_on et le caract√®re ¬´*¬ª est renvoy√©.  Dans d'autres cas, le caract√®re ¬´E¬ª est simplement renvoy√©. <br><br>  L'initialisation du flux MODUART se produit √©galement dans le fichier principal, en appelant la fonction MODUART_init ().  Cette fonction initialise le port et le module p√©riph√©rique USART1 et met le flux en mode veille.  Dans la boucle principale, la fonction de contr√¥le du flux MODUART_control () est appel√©e, qui v√©rifie l'√©tat actuel et ex√©cute un petit morceau de code associ√© √† son traitement. <br><br>  Tout le secret des applications coop√©ratives multi-thread est pr√©cis√©ment de cr√©er de petits morceaux de code pour chaque √©tat. <br><br>  <b>Variable Global_count</b> <br><br>  Cela vaut probablement une discussion s√©par√©e sur cette variable global_count. <br><br>  Le fichier d'initialisation <i>startup \ startup_stm32f10x_md.s</i> contient une table d'interruption du microcontr√¥leur.  Il contient les adresses des gestionnaires pour toutes les interruptions p√©riph√©riques <br>  et les noyaux.  Cependant, les interruptions de la p√©riph√©rie ne se produisent que lorsque la p√©riph√©rie est initialis√©e.  Par cons√©quent, initialement, les gestionnaires pointent vers des talons temporaires.  Mais les gestionnaires d'interruption du noyau Cortex M3 existent vraiment et sont contenus dans le <i>fichier system \ stm32f10x_it</i> .  Une telle interruption est l'interruption de la minuterie du syst√®me SysTick.  Ce temporisateur est utilis√© par le RTOS pour appeler le planificateur de t√¢ches.  Mais, je l'utilise pour appeler la fonction TimingDelay_Decrement, qui est vraiment d√©finie dans le fichier principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------- //   volatile unsigned long global_count=0; //       SysTick,  //    stm32f10x_it.c void TimingDelay_Decrement(void) { //    global_count++; if (TimingDelay != 0x00) { TimingDelay--; } }</span></span></code> </pre><br>  Au d√©but de la fonction principale, la fr√©quence du minuteur SysTick est r√©gl√©e sur 1 ms.  Par cons√©quent <br>  tous les milli√®mes de seconde dans le gestionnaire d'interruption SysTick, le compteur augmente. <br><br>  Il suffit de se souvenir des valeurs de ce compteur et leur diff√©rence donnera l'intervalle de temps entre les v√©rifications en millisecondes.  Ainsi, un compteur peut √™tre utilis√© pour r√©sister √† des intervalles de temps dans n'importe quel nombre de threads sans appeler un d√©lai de blocage. <br><br><h4>  √âpilogue </h4><br>  Il est possible qu'il existe des solutions plus simples pour connecter PeripheralLib et les fichiers d'initialisation d'horloge initiale.  Par exemple, les options des param√®tres de projet d'autres environnements de d√©veloppement ou constantes qui forcent l'environnement de d√©veloppement √† les charger automatiquement lors de la compilation.  Cependant, cette m√©thode, que j'ai cit√©e ici √† titre d'exemple, est assez visuelle en soi et permet, si n√©cessaire, de changer assez rapidement les param√®tres d'initialisation du microcontr√¥leur.  Par exemple, refaites l'horloge du g√©n√©rateur interne. <br><br>  Compar√© √† d'autres ¬´feux clignotants de LED sur stm32¬ª similaires, qui se trouvent sur Internet, le mien s'est av√©r√© assez lourd.  Cependant, sur un tel mod√®le, je d√©marre des projets nouveaux et complexes et passer 2 √† 5 minutes √† le cr√©er ne me semble pas une perte aussi terrible. <br><br><div class="spoiler">  <b class="spoiler_title">Le code source du fichier modLed.h</b> <div class="spoiler_text">  Fichier ModLed.h <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __MODLED_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MODLED_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> typedef enum{ modled_off, modled_on, }MODLED_Commands; void MODLED_init(); void MODLED_command(MODLED_Commands aCmd); void MODLED_control(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Le code source du fichier modLed.c</b> <div class="spoiler_text">  Fichier ModLed.c <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modLed.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      #define MODLED_BLINK_DELAY_ON 250 #define MODLED_BLINK_DELAY_OFF 250 //   typedef enum{ modled_st_idle, modled_st_on, modled_st_wait1, modled_st_off, modled_st_wait2, modled_st_clamp, }MODLED_States; //  ,    1  . extern unsigned long global_count; static MODLED_States modledState=modled_st_idle; static uint32_t modledStart, modledEnd; /* PC13 - led (Open drain) */ void modled_init_gpio() { //    GPIOC RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); GPIO_DeInit(GPIOC); GPIO_InitTypeDef gpio; GPIO_StructInit(&amp;gpio); /*  Blue Pill    ,   PC13. :  PC13      (3 )           .    . */ //   ,  . gpio.GPIO_Mode=GPIO_Mode_Out_OD; gpio.GPIO_Speed=GPIO_Speed_2MHz; gpio.GPIO_Pin=GPIO_Pin_13; GPIO_Init(GPIOC, &amp;gpio); //   GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_SET); } void MODLED_init() { modled_init_gpio(); modledState=modled_st_idle; modledStart=global_count; } //   . void MODLED_command(MODLED_Commands aCmd) { switch(aCmd) { case modled_on: modledState=modled_st_on; break; case modled_off: modledState=modled_st_clamp; break; } } void MODLED_control() { switch(modledState) { case modled_st_idle: break; case modled_st_on: //     GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_RESET); //     modledStart=global_count; //       modledState=modled_st_wait1; break; case modled_st_wait1: //    modledEnd=global_count; //           if((modledEnd-modledStart)&gt;=MODLED_BLINK_DELAY_ON) { //         modledState=modled_st_off; } break; case modled_st_off: //   GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_SET); //     modledStart=global_count; //       modledState=modled_st_wait2; break; case modled_st_wait2: //    modledEnd=global_count; //           if((modledEnd-modledStart)&gt;=MODLED_BLINK_DELAY_OFF) { //         modledState=modled_st_on; } break; case modled_st_clamp: //       GPIO_WriteBit(GPIOC, GPIO_Pin_13, Bit_SET); modledState=modled_st_idle; break; default: modledState=modled_st_idle; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Le code source du fichier modUart.h</b> <div class="spoiler_text">  Fichier ModUart.h <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __MOD_UART_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __MOD_UART_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> void MODUART_init(); void MODUART_control(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Le code source du fichier modUart.c</b> <div class="spoiler_text">  Fichier ModUart.c <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modUart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modLed.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODUART_BAUDRATE 115200 typedef enum{ moduart_st_idle, moduart_st_command, }MODUART_STATES; static MODUART_STATES moduartState=moduart_st_idle; static uint16_t moduartCmd=0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PA9 UART1_TX PA10 UART1_RX */</span></span></span><span class="hljs-meta"> void moduart_init_gpio() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //    GPIOA RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef gpio; GPIO_StructInit(&amp;gpio); gpio.GPIO_Mode=GPIO_Mode_AF_PP; gpio.GPIO_Speed=GPIO_Speed_2MHz; gpio.GPIO_Pin=GPIO_Pin_9; GPIO_Init(GPIOA, &amp;gpio); gpio.GPIO_Mode=GPIO_Mode_IN_FLOATING; gpio.GPIO_Pin=GPIO_Pin_10; GPIO_Init(GPIOA, &amp;gpio); } void moduart_init_uart1() { //     UART1 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); USART_InitTypeDef uart; USART_StructInit(&amp;uart); uart.USART_BaudRate=MODUART_BAUDRATE; uart.USART_HardwareFlowControl=USART_HardwareFlowControl_None; uart.USART_Mode=USART_Mode_Rx|USART_Mode_Tx; uart.USART_Parity=USART_Parity_No; uart.USART_StopBits=USART_StopBits_1; uart.USART_WordLength=USART_WordLength_8b; USART_Init(USART1, &amp;uart); //     // --     USART1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //         NVIC_EnableIRQ(USART1_IRQn); //   USART1. USART_Cmd(USART1, ENABLE); } //    USART1 void USART1_IRQHandler() { //    if(USART_GetITStatus(USART1, USART_IT_RXNE)!=RESET) { //    USART_ClearITPendingBit(USART1, USART_IT_RXNE); //    moduartCmd = USART_ReceiveData(USART1); moduartState = moduart_st_command; } } void moduart_processCmd() { //   uint16_t r = 'E'; switch(moduartCmd) { //    case '0': { MODLED_command(modled_off); r = '-'; } break; //    case '1': { MODLED_command(modled_on); r = '*'; } break; } //    USART_SendData(USART1, r); moduartCmd=0; } void MODUART_init() { moduartState=moduart_st_idle; moduart_init_gpio(); moduart_init_uart1(); } void MODUART_control() { switch(moduartState) { case moduart_st_idle: break; case moduart_st_command: moduart_processCmd(); moduartState=moduart_st_idle; break; default: moduartState=moduart_st_idle; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Le code source du fichier main.c</b> <div class="spoiler_text">  Fichier main.c <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modUart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"modLed.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Imported value static __IO uint32_t TimingDelay; RCC_ClocksTypeDef RCC_Clocks; int main() { RCC_GetClocksFreq(&amp;RCC_Clocks); //   SysTick      SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000); //    MODLED_init(); //     MODUART_init(); do{ //      MODLED_control(); //      MODUART_control(); }while(1); #pragma diag_suppress=Pe111 return 0; } //------------------------------------------------------------------- void Delay(__IO uint32_t nCount) { TimingDelay = nCount; while(TimingDelay != 0); } //------------------------------------------------------------------- //   volatile unsigned long global_count=0; //       SysTick,  //    stm32f10x_it.c void TimingDelay_Decrement(void) { //    global_count++; if (TimingDelay != 0x00) { TimingDelay--; } } //------------------------------------------------------------------- #ifdef USE_FULL_ASSERT void assert_failed(uint8_t *file, uint32_t line) { while(1){} } #endif</span></span></span></span></code> </pre><br></div></div><br>  Le projet complet peut √™tre t√©l√©charg√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr407045/">https://habr.com/ru/post/fr407045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr407035/index.html">En Russie - plus cher. Comment √©conomiser de l'argent sur l'achat d'un iPhone 8</a></li>
<li><a href="../fr407037/index.html">Silicon Valley: ce qui a chang√© en trois ans, partie 2</a></li>
<li><a href="../fr407039/index.html">Lockheed Martin r√©v√®le le plan de la station orbitale et de l'atterrisseur martien</a></li>
<li><a href="../fr407041/index.html">Toujours de l'eau chaude avec la bouilloire intelligente Xiaomi MiJia</a></li>
<li><a href="../fr407043/index.html">Dr Fraudster: l'ascension et la chute d'un c√©l√®bre scientifique qui a tromp√© presque tout le monde</a></li>
<li><a href="../fr407047/index.html">IP57 vs IPX8, ou √Ä propos du seul lecteur v√©ritablement ¬´tout-terrain¬ª au monde</a></li>
<li><a href="../fr407049/index.html">Mauvaise nouvelle: les poissons mangent beaucoup de plastique; mais pire encore, ils pourraient l'aimer</a></li>
<li><a href="../fr407051/index.html">Le jour o√π la Terre s'est disput√©e</a></li>
<li><a href="../fr407053/index.html">Un peu sur la chaleur int√©rieure</a></li>
<li><a href="../fr407055/index.html">Vous vous d√©placez plus vite que la vitesse de la lumi√®re? - Rien de plus simple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>