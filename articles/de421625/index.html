<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏻 🍫 ⏯️ Asynchrones Python: verschiedene Formen des Wettbewerbs 👨🏿‍🎤 👼🏼 🐉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit dem Aufkommen von Python 3 wird viel über „Asynchronismus“ und „Parallelität“ geredet. Wir können davon ausgehen, dass Python diese Funktionen / K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrones Python: verschiedene Formen des Wettbewerbs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421625/">  Mit dem Aufkommen von Python 3 wird viel über „Asynchronismus“ und „Parallelität“ geredet. Wir können davon ausgehen, dass Python diese Funktionen / Konzepte kürzlich eingeführt hat.  Aber das ist nicht so.  Wir haben diese Operationen viele Male benutzt.  Darüber hinaus denken Anfänger möglicherweise, dass Asyncio die einzige oder beste Möglichkeit ist, asynchrone / parallele Operationen neu zu erstellen und zu verwenden.  In diesem Artikel werden verschiedene Möglichkeiten zur Erzielung von Parallelität sowie deren Vor- und Nachteile untersucht. <br><a name="habracut"></a><br><h4>  Begriffsdefinition: </h4><br>  Bevor wir uns mit den technischen Aspekten befassen, ist es wichtig, ein grundlegendes Verständnis der in diesem Zusammenhang häufig verwendeten Begriffe zu haben. <br><br>  <b>Synchron und asynchron:</b> <br><br>  Bei <b>synchronen</b> Vorgängen werden Aufgaben nacheinander ausgeführt.  In <b>asynchronen</b> Aufgaben können unabhängig voneinander gestartet und ausgeführt werden.  Eine asynchrone Aufgabe kann gestartet und fortgesetzt werden, während die Ausführung zu einer neuen Aufgabe wechselt.  Asynchrone Aufgaben blockieren keine Vorgänge (erzwingen Sie nicht das Warten auf den Abschluss der Aufgabe) und werden normalerweise im Hintergrund ausgeführt. <br><br>  Sie sollten sich beispielsweise an ein Reisebüro wenden, um Ihren nächsten Urlaub zu planen.  Sie müssen einen Brief an Ihren Vorgesetzten senden, bevor Sie fliegen.  Im synchronen Modus rufen Sie zuerst das Reisebüro an. Wenn Sie aufgefordert werden zu warten, warten Sie, bis sie Ihnen antworten.  Dann werden Sie beginnen, einen Brief an den Führer zu schreiben.  So erledigen Sie die Aufgaben nacheinander.  <i>[synchrone Ausführung, ca.</i>  <i>Übersetzer]</i> Aber wenn Sie schlau sind, haben sie Sie gebeten zu warten <i>.</i>  <i>Übersetzer]</i> Sie beginnen mit dem Schreiben von E-Mails. Wenn Sie erneut sprechen, unterbrechen Sie das Schreiben, sprechen und fügen dann den Brief hinzu.  Sie können auch einen Freund bitten, die Agentur anzurufen und selbst einen Brief zu schreiben.  Dies ist Asynchronität, Aufgaben blockieren sich nicht gegenseitig. <br><br>  <b>Wettbewerbsfähigkeit und Parallelität:</b> <br><br>  Wettbewerbsfähigkeit bedeutet, dass zwei Aufgaben <u>gemeinsam ausgeführt werden</u> .  In unserem vorherigen Beispiel haben wir, als wir das asynchrone Beispiel betrachteten, schrittweise einen Brief geschrieben und dann ein Gespräch mit einer Tour geführt.  Agentur.  Das ist <b>Wettbewerbsfähigkeit</b> . <br><br>  Als wir darum baten, einen Freund anzurufen, und selbst einen Brief schrieben, wurden die Aufgaben <b>parallel ausgeführt</b> . <br><br>  Parallelität ist im Wesentlichen eine Form des Wettbewerbs.  Die Parallelität ist jedoch hardwareabhängig.  Wenn die CPU beispielsweise nur einen Kern hat, können zwei Aufgaben nicht parallel ausgeführt werden.  Sie teilen einfach die Prozessorzeit untereinander.  Dann ist dies Wettbewerb, aber keine Parallelität.  Aber wenn wir mehrere Kerne haben <i>[als Freund im vorherigen Beispiel, das der zweite Kern ist, ca.</i>  <i>Übersetzer] können</i> wir mehrere Operationen (abhängig von der Anzahl der Kerne) gleichzeitig ausführen. <br><br>  Zusammenfassend: <br><br><ul><li>  Synchronisation: Blockiert Operationen (Blockieren) </li><li>  Asynchronität: Blockiert keine Operationen (nicht blockierend) </li><li>  Wettbewerbsfähigkeit: gemeinsamer Fortschritt (gemeinsam) </li><li>  Parallelität: paralleler Fortschritt (parallel) </li></ul><br>  Parallelität impliziert Wettbewerb.  Wettbewerb bedeutet jedoch nicht immer Parallelität. <br><br><h4>  Themen und Prozesse </h4><br>  Python unterstützt Threads seit sehr langer Zeit.  Mit Threads können Sie Vorgänge wettbewerbsfähig ausführen.  Es gibt jedoch ein Problem mit der <b>globalen Interpreter-Sperre (GIL),</b> aufgrund dessen Threads keine echte Parallelität bieten konnten.  Mit dem Aufkommen der Mehrfachverarbeitung können Sie jedoch mit Python mehrere Kerne verwenden. <br><br>  <b>Themen</b> <br><br>  Betrachten Sie ein kleines Beispiel.  Im folgenden Code wird die <i>Worker-</i> Funktion auf mehreren Threads asynchron und gleichzeitig ausgeführt. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = threading.Thread(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Threads are queued, let's see when they finish!"</span></span>)</code> </pre> <br>  Und hier ist eine Beispielausgabe: <br><br><pre> <code class="python hljs">$ python thread_test.py All Threads are queued, let<span class="hljs-string"><span class="hljs-string">'s see when they finish! I am Worker 1, I slept for 1 seconds I am Worker 3, I slept for 4 seconds I am Worker 4, I slept for 5 seconds I am Worker 2, I slept for 7 seconds I am Worker 0, I slept for 9 seconds</span></span></code> </pre><br>  Daher haben wir 5 Threads für die Zusammenarbeit gestartet. Nach dem Start (d. H. Nach dem Ausführen der Worker-Funktion) <b>wartet</b> der Vorgang <b>nicht auf</b> den Abschluss der Threads, bevor mit der nächsten Druckanweisung fortgefahren wird.  Dies ist eine asynchrone Operation. <br><br>  In unserem Beispiel haben wir die Funktion an den Thread-Konstruktor übergeben.  Wenn wir wollten, könnten wir eine Unterklasse mit einer Methode (OOP-Stil) implementieren. <br><br>  <u>Weiterführende Literatur:</u> <br><br>  Um mehr über Streams zu erfahren, verwenden Sie den folgenden Link: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pymotw.com/3/threading/index.html</a> </li></ul><br>  <b>Global Interpreter Lock (GIL)</b> <br><br>  GIL wurde eingeführt, um die Speicherbehandlung von CPython zu vereinfachen und die beste Integration mit C (z. B. mit Erweiterungen) zu ermöglichen.  GIL ist ein Sperrmechanismus, wenn der Python-Interpreter jeweils nur einen Thread ausführt.  Das heißt,  Es kann jeweils nur ein Thread in Python-Bytecode ausgeführt werden.  GIL stellt sicher, dass nicht mehrere Threads <b>parallel ausgeführt werden</b> . <br><br>  GIL Schnelle Details: <br><br><ul><li>  Es kann jeweils ein Thread ausgeführt werden. </li><li>  Der Python-Interpreter wechselt zwischen Threads, um Wettbewerbsfähigkeit zu erzielen. </li><li>  GIL gilt für CPython (Standardimplementierung).  Aber wie zum Beispiel Jython und IronPython haben keine GIL. </li><li>  GIL macht Single-Threaded-Programme schnell. </li><li>  GIL stört normalerweise nicht die E / A. </li><li>  GIL macht es einfach, thread-sichere Bibliotheken in C zu integrieren. Dank GIL haben wir viele leistungsstarke Erweiterungen / Module in C geschrieben. </li><li>  Bei CPU-abhängigen Aufgaben überprüft der Interpreter alle N Ticks und wechselt die Threads.  Daher blockiert ein Thread die anderen nicht. </li></ul><br>  Viele sehen GIL als Schwäche.  Ich betrachte dies als Segen, da Bibliotheken wie NumPy, SciPy geschaffen wurden, die eine besondere, einzigartige Position in der wissenschaftlichen Gemeinschaft einnehmen. <br><br>  <u>Weiterführende Literatur:</u> <br><br>  Mit diesen Ressourcen können Sie sich mit der GIL befassen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.dabeaz.com/python/UnderstandingGIL.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Artikel ist in russischer Sprache.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>[ca.</i></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Übersetzer]</i></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein bisschen mehr über GIL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>[ca.</i></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Übersetzer]</i></a> </li></ul><br>  <b>Prozesse</b> <br><br>  Um Parallelität in Python zu erreichen, wurde ein <b>Multiprozessor-</b> Modul hinzugefügt, das eine API bereitstellt und sehr ähnlich aussieht, wenn Sie zuvor <b>Threading verwendet</b> haben. <br><br>  Lassen Sie uns einfach das vorherige Beispiel ändern.  Jetzt verwendet die geänderte Version den <b>Prozess</b> anstelle des <b>Streams</b> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = multiprocessing.Process(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Processes are queued, let's see when they finish!"</span></span>)</code> </pre><br>  Was hat sich geändert?  Ich habe gerade das <b>Multiprocessing-</b> Modul anstelle von <b>Threading</b> importiert.  Und dann habe ich anstelle eines Threads einen Prozess verwendet.  Das ist alles!  Anstelle vieler Threads verwenden wir jetzt Prozesse, die auf verschiedenen CPU-Kernen ausgeführt werden (es sei denn, Ihr Prozessor verfügt natürlich über mehrere Kerne). <br><br>  Mit der Pool-Klasse können wir auch die Ausführung einer Funktion auf mehrere Prozesse für unterschiedliche Eingabewerte verteilen.  Ein Beispiel aus den offiziellen Dokumenten: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pool <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: p = Pool(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(p.map(f, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]))</code> </pre><br>  Anstatt die Werteliste zu durchlaufen und die Funktion f einzeln aufzurufen, führen wir die Funktion tatsächlich in verschiedenen Prozessen aus.  Ein Prozess macht f (1), der andere f (2) und der andere f (3).  Schließlich werden die Ergebnisse wieder zu einer Liste zusammengefasst.  Dies ermöglicht es uns, schwere Berechnungen in kleinere Teile zu zerlegen und diese für eine schnellere Berechnung parallel auszuführen. <br><br>  <u>Weiterführende Literatur:</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pymotw.com/3/multiprocessing/index.html</a> </li></ul><br>  <b>Concurrent.futures-Modul</b> <br><br>  Das concurrent.futures-Modul ist groß und erleichtert das Schreiben von asynchronem Code.  Meine Favoriten sind <b>ThreadPoolExecutor</b> und <b>ProcessPoolExecutor</b> .  Diese Künstler unterstützen einen Pool von Threads oder Prozessen.  Wir senden unsere Aufgaben an den Pool und er führt die Aufgaben in einem zugänglichen Thread / Prozess aus.  Es wird ein <b>Future-</b> Objekt zurückgegeben, mit dem das Ergebnis nach Abschluss der Aufgabe abgefragt und abgerufen werden kann. <br><br>  Und hier ist ein Beispiel für ThreadPoolExecutor: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent.futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ThreadPoolExecutor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sleep <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_after_5_secs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message pool = ThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">3</span></span>) future = pool.submit(return_after_5_secs, (<span class="hljs-string"><span class="hljs-string">"hello"</span></span>)) print(future.done()) sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(future.done()) print(future.result())</code> </pre><br>  Ich habe einen Artikel über concurrent.futures <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html</a> .  Dies kann für eine eingehendere Untersuchung dieses Moduls hilfreich sein. <br><br>  <u>Weiterführende Literatur:</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pymotw.com/3/concurrent.futures</a> </li></ul><br><h4>  Asyncio - was, wie und warum? </h4><br>  Sie haben wahrscheinlich eine Frage, die viele Leute in der Python-Community haben - was bringt Asyncio Neues?  Warum gab es eine andere Möglichkeit, asynchrone E / A zu verwenden?  Hatten wir nicht schon Threads und Prozesse?  Mal sehen! <br><br>  <b>Warum brauchen wir Asyncio?</b> <br><br>  Prozesse sind sehr teuer <i>[in Bezug auf den Ressourcenverbrauch ca.</i>  <i>Übersetzer]</i> zu erstellen.  Daher werden für E / A-Operationen hauptsächlich Threads ausgewählt.  Wir wissen, dass E / A von externen Faktoren abhängt - langsame Laufwerke oder unangenehme Netzwerkverzögerungen machen E / A oft unvorhersehbar.  Angenommen, wir verwenden Threads für E / A.  3 Threads führen verschiedene E / A-Aufgaben aus.  Der Dolmetscher müsste zwischen den Wettbewerbsströmen wechseln und jedem von ihnen nacheinander etwas Zeit geben.  Nennen Sie die Flüsse T1, T2 und T3.  Drei Threads haben ihre E / A-Operation gestartet.  T3 schließt es zuerst ab.  T2 und T1 warten noch auf I / O.  Der Python-Interpreter wechselt zu T1, wartet aber noch.  Nun, der Interpreter wechselt zu T2, und der Interpreter wartet noch und wechselt dann zu T3, das bereit ist und den Code ausführt.  Sehen Sie das als Problem? <br><br>  T3 war bereit, aber der Dolmetscher wechselte zuerst zwischen T2 und T1 - dies verursachte Schaltkosten, die wir hätten vermeiden können, wenn der Dolmetscher zuerst auf T3 gewechselt hätte, oder? <br><br>  <b>Was ist Asynio?</b> <br><br>  Asyncio bietet uns eine Event-Schleife zusammen mit anderen coolen Sachen.  Die Ereignisschleife überwacht E / A-Ereignisse und wechselt Aufgaben, die bereit sind und auf E / A-Vorgänge warten. <i>[Die Ereignisschleife ist ein Softwarekonstrukt, das auf die Ankunft wartet und Ereignisse oder Nachrichten im Programm sendet.</i>  <i>Übersetzer]</i> . <br><br>  Die Idee ist sehr einfach.  Es gibt eine Ereignisschleife.  Und wir haben Funktionen, die asynchrone E / A ausführen.  Wir übertragen unsere Funktionen in die Ereignisschleife und bitten ihn, sie für uns auszuführen.  Die Ereignisschleife gibt uns ein Future-Objekt zurück, wie ein Versprechen, dass wir in Zukunft etwas bekommen werden.  Wir halten an einem Versprechen fest, prüfen von Zeit zu Zeit, ob es wichtig ist (wir können wirklich nicht warten), und schließlich verwenden wir es, wenn der Wert empfangen wird, in einigen anderen Operationen <i>[d.h.</i>  <i>Wir schickten eine Anfrage, bekamen sofort ein Ticket und mussten warten, bis das Ergebnis eintrifft.</i>  <i>Wir überprüfen das Ergebnis regelmäßig und sobald es eingegangen ist, nehmen wir ein Ticket und erhalten einen Wert darauf, ca.</i>  <i>Übersetzer]</i> . <br><br>  Asyncio verwendet Generatoren und Coroutinen, um Aufgaben zu stoppen und fortzusetzen.  Sie können die Details hier lesen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html</a> </li></ul><br>  <b>Wie benutzt man Asyncio?</b> <br><br>  Bevor wir anfangen, schauen wir uns ein Beispiel an: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_sleep_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_date</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num, loop)</span></span></span><span class="hljs-function">:</span></span> end_time = loop.time() + <span class="hljs-number"><span class="hljs-number">50.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Loop: {} Time: {}"</span></span>.format(num, datetime.datetime.now())) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loop.time() + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) &gt;= end_time: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_sleep_func() loop = asyncio.get_event_loop() asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">1</span></span>, loop)) asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">2</span></span>, loop)) loop.run_forever()</code> </pre><br>  Beachten Sie, dass die Syntax async / await nur für Python 3.5 und höher gilt.  Lassen Sie uns den Code durchgehen: <br><br><ul><li>  Wir haben eine asynchrone display_date-Funktion, die eine Zahl (als Bezeichner) und eine Ereignisschleife als Parameter verwendet. </li><li>  Die Funktion hat eine Endlosschleife, die nach 50 Sekunden unterbrochen wird.  Aber während dieser Zeit druckt sie wiederholt Zeit und pausiert.  Die Wartefunktion kann warten, bis andere asynchrone Funktionen abgeschlossen sind (Coroutine). </li><li>  Wir übergeben die Funktion an die Ereignisschleife (unter Verwendung der Methode verify_future). </li><li>  Wir beginnen einen Zyklus von Ereignissen. </li></ul><br>  Immer wenn "wait" aufgerufen wird, erkennt asyncio, dass die Funktion wahrscheinlich einige Zeit dauern wird.  Daher wird die Ausführung angehalten, die Überwachung aller damit verbundenen E / A-Ereignisse gestartet und Sie können Aufgaben ausführen.  Wenn asyncio feststellt, dass die angehaltene Funktions-E / A bereit ist, wird die Funktion fortgesetzt. <br><br><h4>  Die richtige Wahl treffen. </h4><br>  Wir haben gerade die beliebtesten Formen der Wettbewerbsfähigkeit durchlaufen.  Aber die Frage bleibt - was sollte gewählt werden?  Dies hängt von den Anwendungsfällen ab.  Aus meiner Erfahrung folge ich eher diesem Pseudocode: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_bound: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_very_slow: print(<span class="hljs-string"><span class="hljs-string">"Use Asyncio"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Use Threads"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Multi Processing"</span></span>)</code> </pre><br><ul><li>  CPU Bound =&gt; Multi Processing </li><li>  E / A-gebunden, schnelle E / A, begrenzte Anzahl von Verbindungen =&gt; Multi-Threading </li><li>  E / A gebunden, langsame E / A, viele Verbindungen =&gt; Asyncio </li></ul><br>  <i>[Anmerkung</i>  <i>Übersetzer]</i> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vortrag (Präsentation) in russischer Sprache über Multithreading und GIL.</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421625/">https://habr.com/ru/post/de421625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421607/index.html">"Wir versuchen nicht einmal, den alten Code auszuführen, wir haben im Prinzip keine solche Aufgabe" - Roman Elizarov über die Entwicklung von Kotlin</a></li>
<li><a href="../de421611/index.html">Wie World of Warcraft geschaffen wurde: Ein Einblick in 20 Jahre Entwicklung</a></li>
<li><a href="../de421613/index.html">Wie wir Artikel über Habr schreiben: Erfahrungen von EastBanc Technologies-Entwicklern</a></li>
<li><a href="../de421615/index.html">Die Lösung für das Fehlen von prevProps in getDerivedStateFromProps</a></li>
<li><a href="../de421619/index.html">Autonome Systeme der Zukunft. Klassifizierung, Merkmale und Anforderungen</a></li>
<li><a href="../de421629/index.html">Werden Roboter meinen Job annehmen? (Und wenn ich ein Humanist bin?)</a></li>
<li><a href="../de421631/index.html">Test Lenovo ThinkPad X1 Carbon (2018) Notebook: leicht, komfortabel, leistungsstark</a></li>
<li><a href="../de421633/index.html">Wie man in 10 Tagen einen Standard macht</a></li>
<li><a href="../de421637/index.html">Kinderuhr mit GPS bis 1. September: worauf Sie achten können</a></li>
<li><a href="../de421639/index.html">Chinesischer Laptop Jumper EZBook X4 - Tastatur mit Hintergrundbeleuchtung und die neue Gemini Lake-Plattform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>