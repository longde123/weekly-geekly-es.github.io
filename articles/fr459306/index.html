<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüé§ üôãüèΩ üïß Rendu de serveur dans un environnement sans serveur ‚òîÔ∏è üòö üßù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur du mat√©riel, dont nous publions la traduction, est l'un des fondateurs du projet Webiny - un CMS sans serveur bas√© sur React, GraphQL et Node...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendu de serveur dans un environnement sans serveur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459306/">  L'auteur du mat√©riel, dont nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publions</a> la traduction, est l'un des fondateurs du projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Webiny</a> - un CMS sans serveur bas√© sur React, GraphQL et Node.js.  Il dit que la prise en charge d'une plate-forme cloud sans serveur multi-locataire est une entreprise qui a des t√¢ches sp√©cifiques.  De nombreux articles ont d√©j√† √©t√© √©crits dans lesquels des technologies standard pour l'optimisation de projets Web sont discut√©es.  Parmi eux, le rendu de serveur, l'utilisation de technologies avanc√©es de d√©veloppement d'applications Web, diverses fa√ßons d'am√©liorer la cr√©ation d'applications, et bien plus encore.  Cet article, d'une part, est similaire aux autres, et d'autre part, il en diff√®re.  Le fait est qu'il est d√©di√© √† l'optimisation de projets s'ex√©cutant dans un environnement sans serveur. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/45/ve/ub/45veubaub6xbivpsjj3_1r7zmx0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">La pr√©paration</font> </h2><br>  Afin de faire des mesures qui aideront √† identifier les probl√®mes du projet, nous utiliserons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webpagetest.org</a> .  Avec l'aide de cette ressource, nous r√©pondrons aux demandes et collecterons des informations sur le temps d'ex√©cution de diverses op√©rations.  Cela nous permettra de mieux comprendre ce que les utilisateurs voient et ressentent lorsqu'ils travaillent avec le projet. <br><br>  Nous sommes particuli√®rement int√©ress√©s par l'indicateur ¬´First view¬ª, c'est-√†-dire combien de temps faut-il pour charger un site √† partir d'un utilisateur qui le visite pour la premi√®re fois.  Il s'agit d'un indicateur tr√®s important.  Le fait est que le cache du navigateur est capable de masquer de nombreux goulots d'√©tranglement des projets Web. <br><br><h2>  <font color="#3AC1EF">Indicateurs refl√©tant les caract√©ristiques du chargement du site - identification des probl√®mes</font> </h2><br>  Jetez un ≈ìil au tableau suivant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc9/8a5/669/cc98a56691adf056e19086280e24cd11.png"></div><br>  <i><font color="#999999">Analyse des anciens et nouveaux indicateurs d'un projet web</font></i> <br><br>  Ici, l'indicateur le plus important peut √™tre reconnu comme ¬´Time to Start Render¬ª - le temps avant le d√©but du rendu.  Si vous regardez attentivement cet indicateur, vous pouvez voir que c'est seulement pour commencer le rendu de la page, dans l'ancienne version du projet, que cela prenait presque 2 secondes.  La raison de cela r√©side dans l'essence m√™me de la Single Page Application (SPA).  Pour afficher la page d'une telle application √† l'√©cran, vous devez d'abord charger le volumineux JS-bundle (cette √©tape de chargement de la page est marqu√©e dans la figure suivante par 1).  Ensuite, ce bundle doit √™tre trait√© dans le thread principal (2).  Et seulement apr√®s cela, quelque chose peut appara√Ætre dans la fen√™tre du navigateur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/025/675/6b2/0256756b2e402f3ffbc06a426e8e03c1.png"></div><br>  <i><font color="#999999">(1) T√©l√©chargez le pack JS.</font></i>  <i><font color="#999999">(2) En attente du traitement du bundle dans le thread principal</font></i> <br><br>  Cependant, ce n'est qu'une partie de l'image.  Une fois que le thread principal a trait√© le bundle JS, il envoie plusieurs requ√™tes √† l'API Gateway.  √Ä ce stade du traitement de la page, l'utilisateur voit un indicateur de chargement rotatif.  La vue n'est pas des plus agr√©ables.  Cependant, l'utilisateur n'a encore vu aucun contenu de page.  Voici un storyboard du processus de chargement de page. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/a62/b12/f27a62b12f800e4f3622583ca9f078a1.png"></div><br>  <i><font color="#999999">Chargement de la page</font></i> <br><br>  Tout cela sugg√®re que l'utilisateur qui a visit√© un tel site ne ressent pas des sensations particuli√®rement agr√©ables en travaillant avec lui.  √Ä savoir, il est oblig√© de regarder une page vierge pendant 2 secondes, puis une autre seconde - √† l'indicateur de t√©l√©chargement.  Cette seconde est ajout√©e au temps de pr√©paration de la page car, apr√®s le chargement et le traitement, les demandes d'API JS-bundle sont ex√©cut√©es.  Ces requ√™tes sont n√©cessaires pour charger les donn√©es et, par cons√©quent, afficher la page termin√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/c77/350/bf6c77350326268fbc01ff092a831549.png"></div><br>  <i><font color="#999999">Chargement de la page</font></i> <br><br>  Si le projet √©tait h√©berg√© sur un VPS normal, le temps n√©cessaire pour ex√©cuter ces demandes d'API serait g√©n√©ralement pr√©visible.  Cependant, les projets ex√©cut√©s dans un environnement sans serveur sont affect√©s par le probl√®me notoire du ¬´d√©marrage √† froid¬ª.  Dans le cas de la plateforme cloud Webiny, la situation est encore pire.  Les fonctionnalit√©s AWS Lambda font partie de VPC (Virtual Private Cloud).  Cela signifie que pour chaque nouvelle instance d'une telle fonction, vous devez initialiser ENI (Elastic Network Interface, interface r√©seau √©lastique).  Cela augmente consid√©rablement le temps de d√©marrage √† froid des fonctions. <br><br>  Voici quelques d√©lais pour le chargement des fonctionnalit√©s AWS Lambda dans les VPC et en dehors des VPC. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/1e5/30b/6421e530b2330c5c4bf63d473fa93cfb.png"></div><br>  <i><font color="#999999">Analyse de charge de la fonction AWS Lambda √† l'int√©rieur du VPC et √† l'ext√©rieur du VPC (image prise √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> )</font></i> <br><br>  De cela, nous pouvons conclure que dans le cas o√π la fonction est lanc√©e √† l'int√©rieur du VPC, cela donne une augmentation de 10 fois le temps de d√©marrage √† froid. <br><br>  De plus, ici un autre facteur doit √™tre pris en compte - les retards de transmission des donn√©es du r√©seau.  Leur dur√©e est d√©j√† incluse au moment o√π il faut pour ex√©cuter les requ√™tes API.  Les demandes sont lanc√©es par le navigateur.  Par cons√©quent, il s'av√®re qu'au moment o√π l'API r√©pond √† ces demandes, le temps n√©cessaire pour envoyer la demande du navigateur √† l'API et le temps n√©cessaire √† la r√©ponse pour passer de l'API au navigateur sont ajout√©s.  Ces retards surviennent lors de chaque demande. <br><br><h2>  <font color="#3AC1EF">T√¢ches d'optimisation</font> </h2><br>  Sur la base de l'analyse ci-dessus, nous avons formul√© plusieurs t√¢ches que nous devions r√©soudre pour optimiser le projet.  Les voici: <br><br><ul><li>  Am√©lioration de la vitesse d'ex√©cution des demandes d'API ou r√©duction du nombre de demandes d'API qui bloquent le rendu. </li><li>  R√©duire la taille du bundle JS ou convertir ce bundle en ressources qui ne sont pas n√©cessaires pour la sortie de la page. </li><li>  D√©verrouillage du fil principal. </li></ul><br><h2>  <font color="#3AC1EF">Approches √† probl√®mes</font> </h2><br>  Voici quelques approches pour r√©soudre les probl√®mes que nous avons envisag√©s: <br><br><ol><li>  Optimisation du code en vue d'acc√©l√©rer son ex√©cution.  Cette approche n√©cessite beaucoup d'efforts, elle a un co√ªt √©lev√©.  Les avantages qui peuvent √™tre obtenus √† la suite d'une telle optimisation sont douteux. </li><li>  Augmentez la quantit√© de RAM disponible pour les fonctionnalit√©s AWS Lambda.  C'est facile √† faire, le co√ªt d'une telle solution se situe entre moyen et √©lev√©.  Seuls de petits effets positifs peuvent √™tre attendus de l'application de cette solution. </li><li>  L'utilisation d'une autre fa√ßon de r√©soudre le probl√®me.  Certes, √† ce moment-l√†, nous ne savions pas encore quelle √©tait cette m√©thode. </li></ol><br>  Au final, nous avons choisi le troisi√®me √©l√©ment de cette liste.  Nous avons raisonn√© comme ceci: ¬´Et si nous n'avons absolument pas besoin d'appels API?  Et si nous pouvions nous passer du bundle JS?  Cela nous permettrait de r√©soudre tous les probl√®mes du projet. ¬ª <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/476/84a/f6947684a7a537bba4b9dfeb24f524e6.jpg"></div><br>  La premi√®re id√©e que nous avons trouv√©e int√©ressante √©tait de cr√©er un instantan√© HTML de la page rendue et de partager l'instantan√© avec les utilisateurs. <br><br><h2>  <font color="#3AC1EF">Tentative infructueuse</font> </h2><br>  Webiny Cloud est une infrastructure sans serveur bas√©e sur AWS Lambda qui prend en charge les sites Webiny.  Notre syst√®me peut d√©tecter les bots.  Lorsqu'il s'av√®re que la demande a √©t√© effectu√©e par le bot, cette demande est redirig√©e vers l'instance <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Puppeteer</a> , qui rend la page √† l'aide de Chrome sans interface utilisateur.  Le code HTML pr√™t √† l'emploi de la page est envoy√© au bot.  Cela a √©t√© fait principalement pour des raisons de r√©f√©rencement, car de nombreux robots ne savent pas comment ex√©cuter JavaScript.  Nous avons d√©cid√© d'utiliser la m√™me approche pour pr√©parer des pages destin√©es aux utilisateurs ordinaires. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/698/219/8bd698219b68cccfa5db9f9f81611111.png"></div><br>  Cette approche fonctionne bien dans les environnements qui ne prennent pas en charge JavaScript.  Cependant, si vous essayez de donner des pages pr√©-rendues √† un client dont le navigateur prend en charge JS, la page s'affiche, mais ensuite, apr√®s avoir t√©l√©charg√© les fichiers JS, les composants React ne savent tout simplement pas o√π les monter.  Cela se traduit par un tas de messages d'erreur dans la console.  En cons√©quence, une telle d√©cision ne nous convenait pas. <br><br><h2>  <font color="#3AC1EF">Pr√©sentation de la SSR</font> </h2><br>  Le c√¥t√© fort du rendu c√¥t√© serveur (SSR) est que toutes les demandes d'API sont ex√©cut√©es au sein du r√©seau local.  Puisqu'ils sont trait√©s par un certain syst√®me ou fonction qui s'ex√©cute √† l'int√©rieur du VPC, les retards qui se produisent lors de l'ex√©cution des requ√™tes du navigateur vers le backend de ressource ne sont pas caract√©ristiques.  Bien que dans ce sc√©nario, le probl√®me d'un ¬´d√©marrage √† froid¬ª demeure. <br><br>  Un avantage suppl√©mentaire de l'utilisation de SSR est que nous donnons au client une telle version HTML de la page, lors de l'utilisation avec laquelle, apr√®s le chargement des fichiers JS, les composants React n'ont pas de probl√®mes de montage. <br><br>  Et enfin, nous n'avons pas besoin d'un tr√®s grand ensemble JS.  De plus, nous pouvons nous passer d'appels API pour afficher la page.  Un bundle peut √™tre charg√© de mani√®re asynchrone et cela ne bloquera pas le thread principal. <br><br>  En g√©n√©ral, nous pouvons dire que le rendu du serveur aurait d√ª r√©soudre la plupart de nos probl√®mes. <br><br>  Voici √† quoi ressemble l'analyse de site apr√®s l'application du rendu c√¥t√© serveur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/5df/38e/3705df38e8b3a2c697f04bed1d0d577e.png"></div><br>  <i><font color="#999999">Mesures du site apr√®s application du rendu du serveur</font></i> <br><br>  D√©sormais, les demandes d'API ne sont pas ex√©cut√©es et la page peut √™tre consult√©e avant le chargement du grand ensemble JS.  Mais si vous regardez attentivement la premi√®re demande, vous pouvez voir qu'il faut presque 2 secondes pour obtenir un document du serveur.  Parlons-en. <br><br><h2>  <font color="#3AC1EF">Probl√®me avec TTFB</font> </h2><br>  Nous discutons ici de la m√©trique TTFB (Time To First Byte, temps jusqu'au premier octet).  Voici les d√©tails de la premi√®re demande. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/19e/9ec/8d319e9eca081b8cba644d7829ccf56e.png"></div><br>  <i><font color="#999999">D√©tails de la premi√®re demande</font></i> <br><br>  Pour traiter cette premi√®re demande, nous devons proc√©der comme suit: lancer le serveur Node.js, effectuer le rendu du serveur, effectuer des requ√™tes API et ex√©cuter du code JS, puis renvoyer le r√©sultat final au client.  Le probl√®me ici est que tout cela, en moyenne, prend 1-2 secondes. <br><br>  Notre serveur, qui effectue le rendu du serveur, doit faire tout ce travail et ce n'est qu'apr√®s cela qu'il pourra transmettre le premier octet de la r√©ponse au client.  Cela conduit au fait que le navigateur a un temps tr√®s long pour attendre le d√©but de la r√©ponse √† la demande.  En cons√©quence, il s'av√®re que maintenant, pour la sortie de la page, vous devez produire presque la m√™me quantit√© de travail qu'auparavant.  La seule diff√©rence est que ce travail est effectu√© non pas c√¥t√© client, mais sur le serveur, dans le processus de rendu du serveur. <br><br>  Ici, vous pouvez avoir une question sur le mot "serveur".  Nous avons toujours parl√© du syst√®me sans serveur.  D'o√π vient ce ¬´serveur¬ª?  Nous avons bien s√ªr essay√© de rendre le rendu du serveur dans les fonctions AWS Lambda.  Mais il s'est av√©r√© qu'il s'agit d'un processus tr√®s consommateur de ressources (en particulier, il √©tait n√©cessaire d'augmenter consid√©rablement la quantit√© de m√©moire afin d'obtenir plus de ressources processeur).  En outre, le probl√®me du ¬´d√©marrage √† froid¬ª, que nous avons d√©j√† mentionn√©, est √©galement ajout√© ici.  En cons√©quence, la solution id√©ale √©tait alors d'utiliser un serveur Node.js qui chargerait les documents du site et effectuerait leur rendu c√¥t√© serveur. <br><br>  Revenons aux cons√©quences de l'utilisation du rendu c√¥t√© serveur.  Jetez un ≈ìil au storyboard suivant.  Il est facile de voir qu'il n'est pas particuli√®rement diff√©rent de celui obtenu lors de l'√©tude du projet, rendu au client. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/ed3/8c4/fc5ed38c4250cfe6592af448b7f0fd30.png"></div><br>  <i><font color="#999999">Chargement de la page lors de l'utilisation du rendu c√¥t√© serveur</font></i> <br><br>  L'utilisateur est oblig√© de regarder une page vierge pendant 2,5 secondes.  C'est triste. <br><br>  Bien qu'en regardant ces r√©sultats, on pourrait penser que nous n'avons absolument rien obtenu, ce n'est en fait pas le cas.  Nous avions un instantan√© HTML de la page contenant tout ce dont nous avions besoin.  Ce clich√© √©tait pr√™t √† fonctionner avec React.  Dans le m√™me temps, lors du traitement de la page sur le client, il n'√©tait pas n√©cessaire d'effectuer des requ√™tes API.  Toutes les donn√©es n√©cessaires ont d√©j√† √©t√© int√©gr√©es dans HTML. <br><br>  Le seul probl√®me √©tait que la cr√©ation de cet instantan√© HTML prenait trop de temps.  √Ä ce stade, nous pourrions investir plus de temps dans l'optimisation du rendu du serveur, ou simplement mettre en cache ses r√©sultats et donner aux clients un instantan√© de la page √† partir de quelque chose comme un cache Redis.  C'est exactement ce que nous avons fait. <br><br><h2>  <font color="#3AC1EF">Mise en cache des r√©sultats de rendu du serveur</font> </h2><br>  Apr√®s qu'un utilisateur visite le site Web Webiny, nous v√©rifions tout d'abord le cache Redis centralis√© pour voir s'il existe un instantan√© HTML de la page.  Si oui, nous donnons √† l'utilisateur une page du cache.  En moyenne, cela a abaiss√© le TTFB √† 200-400 ms.  C'est apr√®s l'introduction du cache que nous avons commenc√© √† remarquer des am√©liorations significatives dans les performances du projet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01e/28d/37e/01e28d37ec4b2586d8a9d8d5187716c9.png"></div><br>  <i><font color="#999999">Chargement de la page lors de l'utilisation du rendu et du cache c√¥t√© serveur</font></i> <br><br>  M√™me l'utilisateur qui visite le site pour la premi√®re fois, voit le contenu de la page en moins d'une seconde. <br><br>  Voyons maintenant √† quoi ressemble le diagramme en cascade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/40f/f4c/62940ff4c6f1136c2534c3c299b343c9.png"></div><br>  <i><font color="#999999">Mesures du site apr√®s application du rendu et de la mise en cache c√¥t√© serveur</font></i> <br><br>  La ligne rouge indique un horodatage de 800 ms.  C'est l√† que le contenu de la page est compl√®tement charg√©.  De plus, ici, vous pouvez voir que les bundles JS sont charg√©s √† environ 1,3 s.  Mais cela n'affecte pas le temps dont l'utilisateur a besoin pour voir la page.  Dans le m√™me temps, vous n'avez pas besoin d'appeler l'API et de charger le thread principal pour afficher la page. <br><br>  Faites attention au fait que les indicateurs temporaires concernant le chargement du bundle JS, l'ex√©cution des requ√™tes API et l'ex√©cution des op√©rations dans le thread principal jouent toujours un r√¥le important dans la pr√©paration de la page pour le travail.  Cet investissement de temps et de ressources est n√©cessaire pour que la page devienne ¬´interactive¬ª.  Mais cela ne joue aucun r√¥le, d'une part, pour les robots des moteurs de recherche, et d'autre part, pour cr√©er le sentiment de ¬´chargement rapide des pages¬ª parmi les utilisateurs. <br><br>  Supposons qu'une page soit ¬´dynamique¬ª.  Par exemple, il affiche un lien dans l'en-t√™te pour acc√©der au compte d'utilisateur dans le cas o√π l'utilisateur qui consulte la page est connect√©.  Apr√®s le rendu c√¥t√© serveur, la page √† usage g√©n√©ral sera envoy√©e au navigateur.  C'est-√†-dire celui qui est affich√© pour les utilisateurs qui ne sont pas connect√©s.  Le titre de cette page changera, refl√©tant le fait que l'utilisateur s'est connect√©, uniquement apr√®s le chargement du bundle JS et les appels d'API.  Il s'agit ici de l'indicateur <a href="">TTI</a> (Time To Interactive, time to the first interactivity). <br><br>  Quelques semaines plus tard, nous avons constat√© que notre serveur proxy ne ferme pas la connexion avec le client l√† o√π elle est n√©cessaire, au cas o√π le rendu du serveur serait lanc√© en arri√®re-plan.  La correction de litt√©ralement une ligne de code a conduit au fait que l'indicateur TTFB a √©t√© r√©duit au niveau de 50 √† 90 ms.  En cons√©quence, le site a commenc√© √† s'afficher dans le navigateur apr√®s environ 600 ms. <br><br>  Cependant, nous avons fait face √† un autre probl√®me ... <br><br><h2>  <font color="#3AC1EF">Probl√®me d'invalidation du cache</font> </h2><br>  <i><font color="#999999">"En informatique, il n'y a que deux choses complexes: l'invalidation du cache et la d√©nomination d'entit√©."</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Phil Carleton</font></i> <br><br>  L'invalidation du cache est en effet une t√¢che tr√®s difficile.  Comment le r√©soudre?  Premi√®rement, vous pouvez souvent mettre √† jour le cache en d√©finissant un temps de stockage tr√®s court pour les objets mis en cache (TTL, Time To Live, dur√©e de vie).  Cela entra√Ænera parfois le chargement des pages plus lentement que d'habitude.  Deuxi√®mement, vous pouvez cr√©er un m√©canisme d'invalidation du cache bas√© sur certains √©v√©nements. <br><br>  Dans notre cas, ce probl√®me a √©t√© r√©solu en utilisant un tr√®s petit TTL de 30 secondes.  Mais nous avons √©galement r√©alis√© la possibilit√© de fournir aux clients des donn√©es obsol√®tes √† partir du cache.  Au moment o√π les clients re√ßoivent ces donn√©es, le cache est mis √† jour en arri√®re-plan.  Gr√¢ce √† cela, nous nous sommes d√©barrass√©s des probl√®mes, tels que les retards et le "d√©marrage √† froid", qui sont typiques des fonctions AWS Lambda. <br><br>  Voici comment cela fonctionne.  Un utilisateur visite le site Web Webiny.  Nous v√©rifions le cache HTML.  S'il y a une capture d'√©cran de la page, nous la donnons √† l'utilisateur.  L'√¢ge d'une photo peut m√™me √™tre de quelques jours.  En transmettant cet ancien instantan√© √† l'utilisateur en quelques centaines de millisecondes, nous lan√ßons simultan√©ment la t√¢che de cr√©er un nouvel instantan√© et de mettre √† jour le cache.  Cela prend g√©n√©ralement quelques secondes pour terminer cette t√¢che, car nous avons cr√©√© un m√©canisme gr√¢ce auquel nous avons toujours un certain nombre de fonctions AWS Lambda qui sont d√©j√† en cours d'ex√©cution et pr√™tes √† fonctionner.  Par cons√©quent, nous n'avons pas √†, lors de la cr√©ation de nouvelles images, passer du temps sur le d√©marrage √† froid des fonctions. <br><br>  Par cons√©quent, nous renvoyons toujours les pages du cache aux clients, et lorsque l'√¢ge des donn√©es mises en cache atteint 30 secondes, le contenu du cache est mis √† jour. <br><br>  La mise en cache est certainement un domaine dans lequel nous pouvons encore am√©liorer quelque chose.  Par exemple, nous envisageons la possibilit√© de mettre √† jour automatiquement le cache lorsque l'utilisateur publie une page.  Cependant, un tel m√©canisme de mise √† jour du cache n'est pas id√©al non plus. <br><br>  Par exemple, supposons que la page d'accueil d'une ressource affiche les trois articles de blog les plus r√©cents.  Si le cache est mis √† jour lors de la publication d'une nouvelle page, alors, d'un point de vue technique, seul le cache de cette nouvelle page sera g√©n√©r√© apr√®s publication.  Le cache de la page d'accueil sera obsol√®te. <br><br>  Nous recherchons toujours des moyens d'am√©liorer le syst√®me de mise en cache de notre projet.  Mais jusqu'√† pr√©sent, l'accent a √©t√© mis sur le tri des probl√®mes de performances existants.  Nous pensons que nous avons fait du bon travail pour r√©soudre ces probl√®mes. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Au d√©but, nous avons utilis√© le rendu c√¥t√© client.  Ensuite, en moyenne, l'utilisateur pouvait voir la page en 3,3 secondes.  Maintenant, ce chiffre est tomb√© √† environ 600 ms.  Il est √©galement important que nous supprimions maintenant l'indicateur de t√©l√©chargement. <br><br>  Pour atteindre ce r√©sultat, nous avons √©t√© autoris√©s, principalement, √† utiliser le rendu serveur.  Mais sans un bon syst√®me de mise en cache, il s'av√®re que les calculs sont simplement transf√©r√©s du client vers le serveur.  Et cela conduit au fait que le temps n√©cessaire √† l'utilisateur pour voir la page ne change pas beaucoup. <br><br>  L'utilisation du rendu serveur a une autre qualit√© positive, non mentionn√©e pr√©c√©demment.  Nous parlons du fait que cela facilite la visualisation des pages sur les appareils mobiles faibles.  La vitesse de pr√©paration d'une page √† visualiser sur de tels appareils d√©pend des modestes capacit√©s de leurs processeurs.  Le rendu du serveur vous permet d'en supprimer une partie de la charge.  Il convient de noter que nous n'avons pas men√© d'√©tude sp√©ciale sur ce probl√®me, mais le syst√®me dont nous disposons devrait permettre d'am√©liorer la visualisation du site sur les t√©l√©phones et les tablettes. <br><br>  En g√©n√©ral, nous pouvons dire que la mise en ≈ìuvre du rendu de serveur n'est pas une t√¢che facile.  Et le fait que nous utilisons un environnement sans serveur ne fait que compliquer cette t√¢che.  La solution √† nos probl√®mes n√©cessitait des changements de code, une infrastructure suppl√©mentaire.  Nous devions cr√©er un m√©canisme de mise en cache bien con√ßu.  Mais en retour, nous avons eu beaucoup de bien.  La chose la plus importante est que les pages de notre site se chargent et se pr√©parent au travail beaucoup plus rapidement qu'auparavant.  Nous pensons que nos utilisateurs l'appr√©cieront. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous des technologies de mise en cache et de rendu serveur pour optimiser vos projets? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459306/">https://habr.com/ru/post/fr459306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459296/index.html">Prix ‚Äã‚ÄãJavaScript 2019</a></li>
<li><a href="../fr459298/index.html">Angulaire: statut en 2019</a></li>
<li><a href="../fr459300/index.html">Quasar 1.0: un nouvel outil utile pour les d√©veloppeurs de Vue et pas seulement pour eux</a></li>
<li><a href="../fr459302/index.html">Nouvelle tentative de requ√™tes HTTP ayant √©chou√© dans Angular</a></li>
<li><a href="../fr459304/index.html">Contournement angulaire de l'√©cueil et gain de temps</a></li>
<li><a href="../fr459308/index.html">Le r√©f√©rencement ne fonctionne pas en 2019?</a></li>
<li><a href="../fr459310/index.html">Outils d'automatisation de test ou testeur de st√©ro√Ødes mobile</a></li>
<li><a href="../fr459312/index.html">Cher Agile, j'en ai marre de faire semblant</a></li>
<li><a href="../fr459314/index.html">Visualisez et traitez avec Hash Match Join</a></li>
<li><a href="../fr459316/index.html">Hydra 2019: diffusion gratuite de la premi√®re salle et un peu sur ce qui sera √† la conf√©rence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>