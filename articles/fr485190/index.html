<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍶 🍘 👨‍🎓 Andrew Eun "Passion pour l'apprentissage automatique." Traduction des chapitres 47 à 58 👩🏻‍🤝‍👨🏿 👨🏽‍✈️ 🕳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceci est le deuxième article avec une traduction de chapitres individuels du livre d'Andrew Un, Passion for Machine Learning. Vous pouvez lire la trad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Andrew Eun "Passion pour l'apprentissage automatique." Traduction des chapitres 47 à 58</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485190/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/87/qr/4t87qrmbsuxfltahjbm9iunonx4.png"></div><br><br>  Ceci est le deuxième article avec une traduction de chapitres individuels du livre d'Andrew Un, Passion for Machine Learning.  Vous pouvez lire la traduction des chapitres précédents <a href="https://habr.com/ru/post/485070/">ici</a> . <br><br>  Cet article se concentrera sur l'apprentissage en profondeur de bout en bout, et l'auteur du livre partagera quelques façons d'analyser les erreurs d'algorithme d'apprentissage. <br><a name="habracut"></a><br><h1>  Apprentissage en profondeur de bout en bout </h1><br><hr><h3>  <font color="#548dd4">Chapitre 47. La croissance de l'apprentissage de bout en bout</font> </h3><hr><br>  Supposons que vous souhaitiez créer un système de vérification des avis sur les produits sur Internet, qui vous dira automatiquement si l'auteur de l'avis a aimé ou non ce produit.  Par exemple, vous espérez reconnaître l'examen suivant comme très positif: <br><br><ul><li>  "Ceci est une grande vadrouille!" </li></ul><br>  et ce qui suit est extrêmement négatif: <br><br><ul><li>  "Ce balai est de mauvaise qualité, désolé pour l'achat" </li></ul><br>  Le problème de la reconnaissance des opinions positives et négatives est appelé «classification des humeurs».  Pour créer ce système, vous pouvez créer un «pipeline» de deux composants: <br><br><ol><li>  <b>Analyseur</b> : <b>Un</b> système qui annote le texte avec des informations, identifiant les mots les plus importants.  <sup>1</sup> Par exemple, vous pouvez utiliser l'analyseur pour désigner tous les adjectifs et noms.  Par conséquent, vous recevrez le texte annoté suivant: <br><br><ul><li>  Ceci est une grande vadrouille! </li></ul><br><blockquote>  <sup>1</sup> En fait, l'analyseur annote le texte beaucoup plus riche que décrit, mais cette description simplifiée suffira à expliquer le deep learning de bout en bout. </blockquote><br></li><li>  <b>Sentiment Classifier</b> : un algorithme d'apprentissage qui prend en entrée du texte annoté et prédit son humeur générale.  Les annotations de l'analyseur peuvent être d'une grande aide pour cet algorithme: en donnant plus de poids aux adjectifs, votre algorithme peut être rapidement évoqué en traitant des mots importants tels que "excellent" et en ignorant des mots moins importants tels que "ceci". </li></ol><br>  Nous pouvons visualiser ce pipeline de deux composants comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/3f/wy/zt3fwy4_ibclomuquousi_mxe4m.png"></div><br><br>  Récemment, il y a eu une tendance à remplacer les pipelines par un seul algorithme d'apprentissage.  Un algorithme d'apprentissage de bout en bout pour cette tâche prendrait simplement le texte brut et original "Ceci est une grande vadrouille!" En entrée et essayez de reconnaître directement son humeur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5l/eo/qv/5leoqvedvmnp8dr7fab15gz3n_e.png"></div><br><br>  Les réseaux de neurones sont couramment utilisés dans les systèmes d'apprentissage de bout en bout.  Le terme «pass-through» fait référence au fait que nous demandons à l'algorithme d'apprentissage de passer directement de l'entrée au résultat souhaité.  C'est-à-dire que l'algorithme d'apprentissage relie directement "l'extrémité d'entrée" du système à "l'extrémité de sortie". <br><br>  Dans les tâches où il y a beaucoup de données, les systèmes de bout en bout ont été extrêmement efficaces.  Mais ce n'est pas toujours un bon choix.  Les prochains chapitres donneront plus d'exemples de systèmes transversaux, ainsi que des conseils sur quand et quand ne pas les utiliser. <br><br><hr><h3>  <font color="#548dd4">Chapitre 48. Autres exemples d'apprentissage transversal</font> </h3><hr><br>  Imaginez que vous souhaitiez créer un système de reconnaissance vocale.  Vous pouvez construire un système de trois composants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Les composants fonctionnent comme suit: <br><br><ol><li>  Fonctions de calcul: récupérez des fonctionnalités conçues manuellement, telles que MFCC ( <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">Mel-Frequency cepstrum coefficients</a> ), qui tentent de capturer le contenu d'une instruction tout en ignorant les propriétés moins importantes telles que la hauteur dans la dynamique. </li><li>  Reconnaissance des phonèmes: Certains linguistes pensent qu'il existe des unités de base du son appelées «phonèmes».  Par exemple, le son initial «k» dans «garder» est le même phonème que le son «c» dans «gâteau».  Ce système tente de reconnaître des phonèmes individuels dans les enregistrements audio. </li><li>  End Recognizer: prend une séquence de phonèmes reconnus et essaie de les relier ensemble dans un enregistrement de sortie. </li></ol><br>  Contrairement à ce «pipeline», le système de bout en bout peut recevoir un enregistrement audio à l'entrée et essaiera de le transférer directement vers l'enregistrement de sortie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Jusqu'à présent, nous n'avons décrit que des «convoyeurs» complètement linéaires d'apprentissage automatique: la sortie est transmise séquentiellement d'un étage à l'autre.  Mais les convoyeurs peuvent être plus complexes.  Par exemple, voici une architecture simple pour un véhicule sans pilote: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Ce convoyeur comprend trois composants: l'un détecte les autres voitures à l'aide de l'image de la caméra, le second détecte les piétons, et enfin, le dernier composant calcule le chemin de notre voiture pour éviter les collisions avec d'autres voitures et piétons. <br><br>  Tous les composants de ce pipeline ne seront pas formés.  Par exemple, la littérature sur la "planification du mouvement des robots" décrit de nombreux algorithmes pour le calcul final du trajet d'une voiture.  Beaucoup de ces algorithmes ne nécessitent aucune formation. <br><br>  Au contraire, l'approche de bout en bout peut essayer de recevoir des lectures de capteur et donner directement au volant un tour dans la bonne direction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Bien que la formation de bout en bout ait conduit à de nombreux succès, ce n'est pas toujours la meilleure approche.  Par exemple, la reconnaissance vocale de bout en bout fonctionne bien.  Mais je suis sceptique quant à la formation transversale de la conduite autonome pour les systèmes sans pilote.  Les prochains chapitres expliquent pourquoi. <br><br><hr><h3>  <font color="#548dd4">Chapitre 49. Formation transversale: avantages et inconvénients</font> </h3><hr><br>  Prenons l'exemple précédent du pipeline de reconnaissance vocale: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Beaucoup de ses pièces sont conçues "manuellement": <br><br><ul><li>  MFCC est un ensemble de fonctionnalités audio spécialement conçues.  Et bien qu'ils fournissent un résumé raisonnable de tout l'audio reçu à l'entrée, ils simplifient également le signal entrant en supprimant certaines informations. </li><li>  Les phonèmes sont une invention des linguistes.  Ils sont une représentation imparfaite des sons de la parole.  Étant donné que les phonèmes sont une mauvaise approximation de la réalité, un algorithme qui utilise des phonèmes pour représenter la parole limitera l'efficacité de l'ensemble du système de reconnaissance vocale. </li></ul><br><ul><li>  Les signes de MFCC sont résistants à certaines propriétés de la parole qui n'affectent pas le contenu, comme la hauteur du locuteur.  Ainsi, ils aident à simplifier la tâche de l'algorithme d'apprentissage. </li><li>  Dans la mesure où les phonèmes sont une représentation raisonnable de la parole, ils peuvent également aider l'algorithme d'apprentissage à comprendre les composants sonores de base et, par conséquent, à augmenter son efficacité. </li></ul><br>  Le fait d'avoir plus de composants conçus à la main permet le plus souvent à un système de reconnaissance vocale d'apprendre de moins de données.  Les connaissances obtenues «manuellement» à l'aide de MFCC et de phonèmes «complètent» les connaissances que notre algorithme obtient des données.  Lorsque nous avons peu de données, cette connaissance est utile. <br><br>  Considérons maintenant le système de bout en bout: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Ce système ne possède pas suffisamment de connaissances obtenues "manuellement".  Par conséquent, lorsque l'ensemble d'entraînement est petit, ce système peut fonctionner moins bien qu'un convoyeur conçu manuellement. <br><br>  Cependant, lorsque l'ensemble de formation est volumineux, il n'y a aucune restriction due à l'utilisation de MFCC ou de phonèmes.  Si l'algorithme d'apprentissage est un réseau neuronal suffisamment grand, et s'il est entraîné sur un ensemble d'entraînement suffisamment grand, il a un grand potentiel, et peut-être même approche le taux d'erreur optimal. <br><br>  Les systèmes de bout en bout ont tendance à réussir quand il y a beaucoup de données marquées pour les deux extrémités - «l'extrémité d'entrée» et «l'extrémité de sortie».  Dans cet exemple, nous avons besoin d'un grand ensemble de ces paires (audio et transcription).  Lorsque des données de ce type ne vous sont pas disponibles, approchez-les par l'apprentissage avec grand soin. <br><br>  Si vous travaillez sur une tâche d'apprentissage automatique dans laquelle l'ensemble de formation est très petit, la plupart des informations qui seront disponibles pour votre algorithme seront obtenues grâce à votre compréhension humaine, c'est-à-dire  à partir de composants conçus manuellement. <br><br>  Si vous préférez ne pas utiliser un système de bout en bout, vous devez décider quelles étapes seront dans votre pipeline et comment elles devraient s'emboîter.  Dans le chapitre suivant, nous proposerons quelques idées pour concevoir de tels systèmes. <br><br><hr><h3>  <font color="#548dd4">Chapitre 50. Sélection des composants de pipeline: disponibilité des données</font> </h3><hr><br>  Lorsque vous construisez un convoyeur qui n'est pas un système de bout en bout, quels composants de ce convoyeur seront un bon choix?  La façon dont vous concevez le convoyeur affectera considérablement les performances globales du système.  Un facteur important est la capacité de collecter facilement des données pour la formation de chaque composant. <br><br>  Par exemple, considérons cette architecture de conduite autonome: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Vous pouvez utiliser des algorithmes d'apprentissage automatique pour détecter les voitures et les piétons.  De plus, il n'est pas difficile pour eux de collecter des données: il existe de nombreux ensembles prêts à l'emploi de données de vision par ordinateur avec un grand nombre de voitures et de piétons balisés.  Vous pouvez également utiliser le crowdsourcing (comme Amazon Mechanical Turk) pour obtenir des ensembles de données encore plus volumineux.  Par conséquent, il sera relativement facile de collecter des données d'entraînement pour créer un détecteur de voiture et un détecteur de piéton. <br><br>  Au contraire, considérons un système propre de bout en bout: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Pour entraîner ce système, nous avons besoin d'un large ensemble d'éléments déjà cartographiés (image = volant tournant dans le bon sens).  Il s'agit d'une tâche très longue et coûteuse.  Pour collecter ces données, il est nécessaire que les gens conduisent des voitures et enregistrent des données sur chaque tour de volant.  Vous aurez besoin de toute une flotte de voitures spécialement équipées et d'un grand nombre d'heures de conduite pour couvrir le plus large éventail possible de situations.  Cela rend le système de bout en bout très difficile à apprendre.  Il est beaucoup plus facile de prendre un grand nombre d'images étiquetées de voitures et de piétons. <br><br>  De manière plus générale, s'il y a beaucoup de données disponibles pour la formation de modules de convoyeurs «intermédiaires» (comme un détecteur de voiture ou un détecteur de piétons), alors vous devez penser à utiliser un convoyeur composé de plusieurs composants.  Cette méthode pourrait mieux fonctionner, car  Vous pouvez utiliser toutes les données disponibles pour la formation des modules intermédiaires. <br><br>  Jusqu'à ce qu'il y ait plus de données pour les modèles de bout en bout, je pense que l'approche traditionnelle est beaucoup plus prometteuse pour la conduite autonome: son architecture correspond mieux à la disponibilité actuelle des données. <br><br><hr><h3>  <font color="#548dd4">Chapitre 51. Choix des composants du convoyeur: simplicité des tâches</font> </h3><hr><br>  En plus de la disponibilité des données, vous devez également considérer le deuxième facteur lors du choix des composants de pipeline: à quel point les tâches que les composants individuels résolvent sont-elles simples?  Vous devez essayer de sélectionner les composants du convoyeur afin qu'ils soient faciles à construire ou faciles à apprendre.  Mais qu'est-ce que cela signifie pour un composant d'être facile à apprendre? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fc/bg/fy/fcbgfyb4ggr4u6m79xy01h6gtqa.png"></div><br><br>  Considérez les tâches d'apprentissage automatique suivantes, répertoriées par ordre croissant de complexité: <br><br><ol><li>  La définition est surexposée à l'image présentée (comme dans l'exemple ci-dessus). </li><li>  Déterminer si une image est prise à l'intérieur ou à l'extérieur. </li><li>  Déterminer s'il y a un chat dans l'image. </li><li>  Déterminer s'il y a un chat dans l'image avec une fourrure noire et blanche. </li><li>  Détermination de la présence d'un chat siamois dans l'image (toute race particulière de chats). </li></ol><br>  Pour chacune de ces tâches de classification binaire, vous devez obtenir une image à l'entrée et à la sortie 0 ou 1. Mais les tâches répertoriées plus haut dans la liste semblent aux réseaux de neurones être «plus faciles» à apprendre.  Vous pouvez entraîner l'algorithme pour des tâches plus simples avec moins d'exemples de formation. <br><br>  Au stade actuel de l'apprentissage automatique, il n'existe pas de bonne définition formelle de ce qui rend une tâche simple facile ou difficile.  <sup>2</sup> Avec la croissance de l'apprentissage profond et des réseaux de neurones multicouches, nous appelons parfois le problème facile s'il peut être résolu avec moins d'étapes de calcul (par exemple, en utilisant des réseaux de neurones avec un petit nombre de couches), et nous appelons la tâche difficile si elle nécessite plus d'étapes l'informatique (qui correspond à un réseau neuronal profond).  Mais c'est une définition informelle. <br><blockquote>  <sup>2</sup> Dans la théorie algorithmique de l'information, il y a le concept de complexité de Kolmogorov, qui stipule que la complexité de la fonction étudiée est la longueur du programme informatique le plus court qui peut produire cette fonction.  Ce concept théorique a trouvé plusieurs applications pratiques en IA. </blockquote><br>  Si vous avez la possibilité de décomposer une tâche complexe en sous-tâches plus simples, puis en encodant avec précision chaque sous-tâche, vous donnerez à l'algorithme des connaissances plus importantes qui pourront l'aider à résoudre plus efficacement l'ensemble du problème. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cm/so/cmcmsoncvrly_eqnmdswoqxyqcc.png"></div><br><br>  Imaginez que vous concevez un détecteur de chat siamois.  Voici une architecture de bout en bout propre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/ex/em/3gexemhnlou8qon3qwpprhtcidm.png"></div><br><br>  Au contraire, vous pouvez utiliser un convoyeur à deux composants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  Dans la première étape (détecteur de chat), tous les chats de l'image seront reconnus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9q/a4/wu/9qa4wugiqcvqysomntw52alpy8q.png"></div><br><br>  Ensuite, dans la deuxième étape, les images recadrées de chacun des chats détectés, une à la fois, sont transférées au classificateur de race.  Et enfin, si l'un des chats détectés est un chat siamois, nous obtenons "1" à la sortie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/oj/ii/nsojiirbbbuni7qkmrokqmuksfm.png"></div><br><br>  Comparé à l'enseignement d'un classificateur purement intermédiaire qui n'utilise que des balises 0/1, chacun des deux composants du pipeline (détecteur de chat et classificateur de race) semble plus facile à apprendre et nécessite beaucoup moins de données.  <sup>3</sup> <br><blockquote>  <sup>3</sup> Si vous êtes familier avec les algorithmes de détection d'objets qui sont réellement utilisés dans la pratique, vous comprendrez qu'ils sont formés non seulement avec les étiquettes d'image 0/1.  Au lieu de cela, ils sont formés en utilisant le cadre restrictif fourni dans le cadre des données de formation.  Leur discussion dépasse le cadre de ce chapitre. </blockquote><br>  Et le dernier exemple, rappelons à nouveau le pipeline pour la tâche de conduite autonome: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  En utilisant ce convoyeur, vous dites à l'algorithme qu'il y a trois étapes clés dans la conduite d'une voiture: <br><br><ul><li>  Reconnaissez les autres voitures. </li><li>  Reconnaissez les piétons. </li><li>  Planifiez la direction du mouvement ultérieur. </li></ul><br>  Chacune de ces étapes est une tâche plus simple et peut être formée sur moins de données qu'avec une approche purement transversale. <br><br>  Par conséquent, lorsque vous décidez quels doivent être les composants du pipeline, essayez de créer un pipeline où chaque composant est une fonction relativement «simple» qui ne peut être formée que sur une petite quantité de données. <br><br><hr><h3>  <font color="#548dd4">Chapitre 52. Apprendre avec des informations immersives</font> </h3><hr><br>  L'algorithme de classification d'image prend une image d'entrée X et produit un entier, qui est une étiquette pour la catégorie de l'objet.  L'algorithme peut-il produire à la place une phrase entière décrivant l'image? <br><br>  Par exemple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/12/z6/-v/12z6-votwnq7mu2j9rwukqce52k.png"></div><br><br>  Y = "Un bus jaune roule sur la route au milieu des arbres et de l'herbe verte." <br><br>  L'application traditionnelle de l'enseignement avec un enseignant implique la présence d'une fonction formée h: X → Y, où la sortie (y) est généralement représentée par un nombre entier ou naturel.  Par exemple: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Défi </th><th>  X </th><th>  Oui </th></tr><tr><td>  <b>Antispam</b> </td><td>  Courriel </td><td>  Spam / Pas de spam (0/1) </td></tr><tr><td>  <b>Reconnaissance d'image</b> </td><td>  Image </td><td>  Étiquette entière </td></tr><tr><td>  <b>Prévisions des prix de l'immobilier</b> </td><td>  Caractéristiques de la maison </td><td>  Prix ​​en dollars </td></tr><tr><td>  <b>Recommandation de produit</b> </td><td>  Spécifications du produit et du client </td><td>  Probabilité d'achat </td></tr></tbody></table></div><br><br>  L'un des aspects les plus passionnants de l'apprentissage en profondeur transversal est qu'il nous permet d'apprendre directement Y, ce qui est beaucoup plus compliqué que les chiffres.  Dans l'exemple avec la tâche de description d'image mentionnée ci-dessus, vous pouvez appliquer une image (x) à l'entrée du réseau neuronal et obtenir une description immédiate (y) à la sortie. <br><br>  Voici quelques exemples: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Défi </th><th>  X </th><th>  Oui </th><th>  Citation du travail </th></tr><tr><td>  <b>Description des images</b> </td><td>  Image </td><td>  Texte </td><td>  Mao et autres, 2014 </td></tr><tr><td>  <b>Traduction automatique</b> </td><td>  Texte anglais </td><td>  Texte français </td><td>  Suskever et autres, 2014 </td></tr><tr><td>  <b>Réponses aux questions</b> </td><td>  Paire (texte + question) </td><td>  Réponse à la question </td><td>  Bordes et autres, 2015 </td></tr><tr><td>  <b>Reconnaissance vocale</b> </td><td>  Audio </td><td>  Transcription </td><td>  Hannun et autres, 2015 </td></tr><tr><td>  <b>Synthèse vocale</b> </td><td>  Balises de texte </td><td>  Audio </td><td>  Van der Oord et al., 2016 </td></tr></tbody></table></div><br><br>  C'est une tendance croissante dans l'apprentissage en profondeur: lorsque vous avez les paires étiquetées (entrée, sortie) correctes, vous pouvez parfois choisir une formation de bout en bout, même si la sortie est une phrase, une image, un audio ou toute autre sortie qui contient beaucoup plus d'informations, que de simples numéros d'étiquette. <br><br><h1>  Analyse d'erreur partielle </h1><hr><h3>  <font color="#548dd4">Chapitre 53. Analyse des erreurs dans les pièces</font> </h3><hr><br>  Supposons que votre système soit construit à l'aide d'un pipeline d'apprentissage automatique sophistiqué et que vous souhaitez améliorer l'efficacité du système.  Quelle partie du convoyeur faut-il améliorer?  En attribuant des erreurs à des parties spécifiques du pipeline, vous pouvez décider comment hiérarchiser votre travail. <br><br>  Utilisons notre exemple de classificateur de chats siamois: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  La première partie, un détecteur de chat, détecte les chats et les découpe de l'image entière.  La deuxième partie, le classificateur de race de chat, décide si ce chat est un chat siamois.  Vous pouvez passer des années à travailler pour améliorer l'un de ces deux composants du convoyeur.  Comment décidez-vous sur quel composant se concentrer? <br><br>  En effectuant l'analyse des erreurs dans les parties, vous pouvez essayer d'attribuer chaque erreur de l'algorithme à l'une des deux parties du pipeline (et parfois les deux à la fois).  Par exemple, l'algorithme classe incorrectement cette image comme ne contenant pas de chat siamois (y = 0), bien que l'étiquette correcte soit y = 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/ju/2g/hjju2gw3fble1fcgc8fblrenkms.png"></div><br><br>  Vérifions manuellement ce que fait l'algorithme dans chacune des deux étapes.  Supposons qu'un détecteur de chat siamois ait détecté un chat comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/0l/rx/oe0lrx5ysvmznqkmbl83m_k_46g.png"></div><br><br>  Cela signifie que le classificateur de race de chat recevra cette image: <br><br><img src="https://habrastorage.org/webt/ft/wm/vs/ftwmvsdrnvpp2f9vrds36flldzo.png"><br><br>  Le classificateur de race classe correctement cette image comme ne contenant pas de chat siamois.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, le classificateur de race de chat est innocent: il a reçu un tas de pierres à l'entrée et a donné une note très raisonnable y = 0. En fait, une personne qui classe l'image recadrée ci-dessus prédirait également y = 0. Ainsi, vous pouvez clairement attribuer cette erreur à détecteur de chat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En revanche, si un détecteur de chat affiche la boîte englobante suivante:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/qu/no/ozqunon7ny51kw1ukglsfl3hjj8.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alors vous concluriez que le détecteur de chat a fait son travail correctement, et l'erreur s'est produite à cause du classificateur de race. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que vous ayez parcouru 100 images classées incorrectement d'un échantillon de validation et trouvé que 90 erreurs liées à un détecteur de chat, et seulement 10 erreurs liées à un classificateur de race de chat. Vous pouvez conclure en toute sécurité que vous devez vous concentrer davantage sur l'amélioration de votre détecteur de chat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, vous avez également réussi à trouver 90 exemples où le détecteur de chat a fait apparaître la mauvaise boîte de délimitation. Vous pouvez utiliser ces 90 exemples pour une </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analyse </font><font style="vertical-align: inherit;">plus </font><font style="vertical-align: inherit;">approfondie des erreurs de détection de chat pour voir comment l'améliorer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre description de la façon d'attribuer l'erreur à une partie du pipeline a jusqu'à présent été informelle: vous regardez la sortie de chaque partie et voyez si vous pouvez décider laquelle a commis l'erreur. </font><font style="vertical-align: inherit;">Cette méthode informelle peut suffire. </font><font style="vertical-align: inherit;">Mais dans le chapitre suivant, vous verrez également une manière plus formelle d'attribuer les erreurs.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 54. Attribution d'erreur à une partie spécifique</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Continuons avec notre exemple: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Supposons que le détecteur de chat ait produit cette boîte englobante: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/_d/8k/bc_d8kmcijt314qterhumctdyyq.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, le classificateur de race a reçu cette image recadrée, après quoi il a incorrectement émis y = 0, c'est-à-dire </font><font style="vertical-align: inherit;">qu'il n'y a pas de chat sur la photo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/71/mu/ld/71muldvuqnfx0cd_a6bpo41xzvc.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le détecteur de chat a fait un mauvais travail. </font><font style="vertical-align: inherit;">Alors qu'une personne formée sera sans aucun doute capable de reconnaître le chat siamois dans cette image recadrée. </font><font style="vertical-align: inherit;">Par conséquent, nous attribuons cette erreur à un détecteur de chat, à un classificateur de race ou aux deux? </font><font style="vertical-align: inherit;">Pas clair. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le nombre de ces cas controversés est faible, nous pouvons prendre n'importe quelle décision et obtenir un résultat similaire. </font><font style="vertical-align: inherit;">Mais voici un test plus formel, qui nous permet d'attribuer plus précisément l'erreur à exactement une partie:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remplacez la sortie du détecteur de chat par un cadre marqué manuellement. </font></font><br><img src="https://habrastorage.org/webt/np/8f/zy/np8fzyx2lfbh1cdbd-o7iiykpvq.png"></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passez l'image recadrée correspondante à travers le classificateur de race. </font><font style="vertical-align: inherit;">Si le classificateur de race ne classe toujours pas l'image correctement, attribuez l'erreur au classificateur de race. </font><font style="vertical-align: inherit;">Sinon, attribuez l'erreur au détecteur de chat.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En d'autres termes, effectuez une expérience dans laquelle vous soumettez des données idéales à l'entrée du classificateur de roche. </font><font style="vertical-align: inherit;">Dans ce cas, 2 options sont possibles:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Même avec un cadre idéal, le classificateur de race y = 0 par erreur. Dans ce cas, le classificateur est sans aucun doute à blâmer. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ayant reçu un cadre idéal, le classificateur de race correctement y = 1. Cela montre que si seulement le détecteur de chat produisait une boîte de délimitation plus parfaite, alors la conclusion générale du système serait correcte. </font><font style="vertical-align: inherit;">Ainsi, nous attribuons l'erreur au détecteur de chat.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir effectué une telle analyse d'images classées incorrectement à partir de l'échantillon de validation, vous pouvez désormais attribuer sans ambiguïté chaque erreur à un composant. </font><font style="vertical-align: inherit;">Cela vous permet d'estimer la proportion d'erreurs associées à chaque composant du pipeline et, par conséquent, de décider sur quoi concentrer votre attention.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 55. Le cas principal des erreurs d'attribution</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici les étapes générales d'attribution des erreurs. </font><font style="vertical-align: inherit;">Supposons que le pipeline comporte trois étapes A, B et C, où A est directement alimenté en B et B est directement alimenté en C.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ok/tz/0i/oktz0iqvw81g6gbnxdwvehsmo50.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour chaque erreur que le système fait sur l'échantillon de validation: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez de remplacer manuellement la sortie de l'étage A par une sortie «idéale» (c'est-à-dire une boîte de délimitation «idéale» pour le chat) et continuez avec le reste du convoyeur B, C avec une telle sortie. </font><font style="vertical-align: inherit;">Si l'algorithme produit maintenant le résultat correct, cela indique que seule la phase A devrait améliorer sa propre sortie afin que l'algorithme entier fonctionne correctement. </font><font style="vertical-align: inherit;">Ainsi, vous pouvez attribuer cette erreur au composant A. Sinon, passez à l'étape 2.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez de remplacer manuellement la sortie de l'étage B par une sortie «parfaite». </font><font style="vertical-align: inherit;">Si l'algorithme entier a commencé à fonctionner correctement, attribuez l'erreur au composant B. Sinon, passez à l'étape 3.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attribuez l'erreur au composant C. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetez un œil à un exemple plus complexe: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre drone utilise ce convoyeur. </font><font style="vertical-align: inherit;">Comment, à l'aide d'une analyse d'erreur fragmentaire, déterminer sur quel composant se concentrer? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez marquer les composants comme suit:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Reconnaître les voitures. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Reconnaissez les piétons. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Planifiez le chemin. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En suivant la procédure décrite ci-dessus, supposons que vous testiez votre voiture sur un terrain d'entraînement fermé et que vous trouviez un cas où la voiture choisit une manœuvre dans une direction plus nette que ne le ferait un conducteur expérimenté. </font><font style="vertical-align: inherit;">Dans le monde de la conduite sans pilote, un tel événement est généralement appelé script. </font><font style="vertical-align: inherit;">Dans ce cas:</font></font><br><br><ol><li>      A ( )  «»  (..     ).     B  C   ,    C ( )  «»   A.        ,    ,     A   ,     .        A.     2. </li><li>      B ( )  «» .      ,      B.     3. </li><li>    C. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les composants du pipeline d'apprentissage automatique doivent être organisés selon un graphique acyclique dirigé (DAG), ce qui signifie que vous devriez pouvoir les calculer dans un ordre fixe de gauche à droite, et les composants ultérieurs ne devraient dépendre que des sorties des composants précédents. </font><font style="vertical-align: inherit;">Tant que la </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disposition des composants dans l'ordre A → B → C correspond à l'ordre du DAG, l'analyse d'erreur se déroulera correctement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez obtenir des résultats légèrement différents si vous échangez A et B:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Reconnaître les piétons (anciennement reconnaissance automobile) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Reconnaître les voitures (anciennement reconnaissance des piétons) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Planifiez votre chemin de voiture </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais le résultat de cette analyse restera vrai et donnera de bonnes indications sur ce sur quoi vous devez concentrer votre attention. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 56. Analyse des erreurs dans les pièces et comparaison avec l'efficacité au niveau humain</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La réalisation d'une analyse d'erreurs dans un algorithme d'apprentissage est similaire à l'utilisation de la science des données pour analyser les erreurs du système ML afin de se faire une idée de ce qu'il faut faire ensuite. </font><font style="vertical-align: inherit;">Dans la plupart des cas, une analyse d'erreur fragmentaire nous dira quel composant mérite d'être amélioré avant tout.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disons que vous disposez d'un ensemble de données sur les clients qui achètent des choses sur un site Web. Un data scientist peut analyser les données de différentes manières. Il peut tirer de nombreuses conclusions différentes sur la question de savoir si le site devrait augmenter les prix, sur la valeur des clients acquis grâce à diverses campagnes de marketing, etc. Il n'y a pas une seule et même «bonne» façon d'analyser un ensemble de données, de nombreuses idées utiles peuvent surgir. De même, il n'y a pas de «bonne» façon d'analyser les erreurs. Dans ces chapitres, vous avez appris certains des modèles de conception les plus courants pour obtenir des informations utiles sur votre système ML, mais vous pouvez également expérimenter librement d'autres méthodes d'analyse d'erreurs.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retour à l'application de véhicule sans pilote, dans laquelle l'algorithme de détection de voiture affiche l'emplacement (et éventuellement la vitesse) des voitures à proximité, l'algorithme de détection des piétons affiche l'emplacement des piétons les plus proches, et ces deux sorties sont finalement utilisées pour planifier le chemin de la voiture. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour déboguer ce pipeline et ne pas suivre strictement la procédure que vous avez vue dans le chapitre précédent, vous pouvez poser les questions suivantes: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans quelle mesure l'algorithme de reconnaissance de voiture est-il loin de l'efficacité humaine pour résoudre un problème similaire? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans quelle mesure l'algorithme de reconnaissance des piétons est-il loin des performances humaines pour résoudre un problème similaire? </font></font></li><li>         ?      ,       ,          (      ).  ,    « »    ,        ? </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous constatez que l'un des composants du système est loin de l'efficacité humaine, vous aurez alors une bonne occasion de vous concentrer sur l'amélioration de l'efficacité de ce composant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De nombreux processus d'analyse d'erreurs fonctionnent mieux lorsque nous essayons d'automatiser quelque chose qu'une personne peut faire, nous comparons donc les résultats avec les résultats d'une personne. La plupart de nos exemples précédents avaient cette hypothèse implicite. Si vous construisez un système ML dans lequel la sortie finale ou certains des composants intermédiaires font des choses que même une personne ne peut pas bien faire, alors certaines de ces procédures ne s'appliqueront pas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est un autre avantage de travailler sur des problèmes que les gens peuvent résoudre - vous disposez d'outils plus puissants pour analyser les erreurs et, par conséquent, vous pouvez hiérarchiser plus efficacement le travail de votre équipe. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 57. Détection d'erreurs dans le pipeline ML</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il si chaque composant individuel de votre convoyeur ML montre une efficacité au niveau humain ou un peu plus faible, mais le convoyeur général ne correspond pas jusqu'à présent au niveau humain? </font><font style="vertical-align: inherit;">Cela signifie généralement que le convoyeur a des défauts et doit être repensé. </font><font style="vertical-align: inherit;">L'analyse des erreurs peut également vous aider à déterminer si votre pipeline doit être repensé.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le chapitre précédent, nous avons posé la question: chacune des trois composantes montre-t-elle une efficacité au niveau humain? </font><font style="vertical-align: inherit;">Supposons que la réponse aux trois questions soit oui. </font><font style="vertical-align: inherit;">Ensuite:</font></font><br><br><ol><li> ,  ,   ()           . </li><li> ,  ,   ()           . </li><li> ,   ,     ,    ,      ,                (     ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Néanmoins, votre véhicule sans pilote fait face à une conduite bien pire qu'une personne. Autrement dit, les personnes qui ont accès aux images de la caméra peuvent mieux planifier le trajet de la voiture. Quelle conclusion pouvez-vous tirer? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La seule conclusion possible est que votre pipeline ML n'est pas conçu correctement. Dans ce cas, le composant qui planifie le trajet de la voiture fonctionne aussi bien qu'il autorise les données entrantes qui ne contiennent pas suffisamment d'informations. Vous devez vous demander quelles autres informations qui ne figurent pas dans la sortie des deux composants précédents sont nécessaires pour une excellente planification du parcours de la voiture. En d'autres termes, quelles autres informations sont utilisées par un conducteur expérimenté?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que vous compreniez qu'un conducteur humain doit également voir les marquages ​​routiers. Cela suggère que vous devez inverser l'ingénierie du pipeline comme suit: </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/qa/wy/msqawygb_nyn4twj9cnbbiqlad0.png"></div><br><blockquote> <sup>4</sup>       ,     ,         .       «Task simplicity»,    51,            ,          .     «  »    —               ,        /  . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En fin de compte, si vous pensez que votre pipeline dans son ensemble ne pourra pas atteindre l'efficacité humaine, même si chaque composant individuel a une efficacité au niveau humain (rappelez-vous que vous comparez avec une personne qui a la même entrée que le composant) , alors un tel convoyeur présente des inconvénients et doit être repensé. </font></font><br><br><h1>  Conclusion </h1><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 58. Construisez une super équipe, partagez ces connaissances avec vos camarades</font></font></font> </h3><hr><br>  Félicitations pour avoir terminé ce livre! <br>  Dans le chapitre 2, nous avons expliqué comment ce livre peut vous aider à devenir un super-héros dans votre équipe. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/8d/ta/ms8dta_asiaioa6tttb3dsl4syo.png"></div><br><br>  La seule chose qui peut être meilleure que d'être un super-héros est de faire partie d'une équipe de super-héros.  J'espère que vous partagez des exemplaires de ce livre avec vos amis et coéquipiers et que vous aidez à créer d'autres super-héros! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485190/">https://habr.com/ru/post/fr485190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485178/index.html">Méthodologie de reconstruction des bâtiments perdus à partir de photographies</a></li>
<li><a href="../fr485180/index.html">Avons-nous besoin d'un lac de données? Que faire de l'entrepôt de données?</a></li>
<li><a href="../fr485182/index.html">Sennheiser en 2020 - casque sans fil mis à jour pour l'anniversaire</a></li>
<li><a href="../fr485184/index.html">Résultats du sondage par onglets</a></li>
<li><a href="../fr485186/index.html">Démarrage d'un billion de dollars ou naissance des entreprises les plus prospères de Valley</a></li>
<li><a href="../fr485194/index.html">Arborescence des segments: rapide et facile</a></li>
<li><a href="../fr485196/index.html">AvitoTech On Tour: rendez-vous et rendez-vous frontend à Kazan</a></li>
<li><a href="../fr485198/index.html">Une autre façon de mesurer les performances des méthodes d'application .NET</a></li>
<li><a href="../fr485200/index.html">Désordre au départ: post-mortem sur la vitesse de lancement d'une application iOS</a></li>
<li><a href="../fr485202/index.html">Système de suppression</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>