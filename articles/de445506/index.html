<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìô üò† üëÜüèæ OS1: Primitiver Kernel auf Rust f√ºr x86 üé∑ üë©üèø‚Äçüíª üÜé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich beschloss, einen Artikel und, wenn m√∂glich, eine Reihe von Artikeln zu schreiben, um meine Erfahrungen mit der unabh√§ngigen Forschung sowohl des B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: Primitiver Kernel auf Rust f√ºr x86</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445506/"><p>  Ich beschloss, einen Artikel und, wenn m√∂glich, eine Reihe von Artikeln zu schreiben, um meine Erfahrungen mit der unabh√§ngigen Forschung sowohl des Bare Bone x86-Ger√§ts als auch der Organisation von Betriebssystemen zu teilen.  Im Moment kann mein Hack nicht einmal als Betriebssystem bezeichnet werden - es ist ein kleiner Kernel, der von Multiboot (GRUB) booten, realen und virtuellen Speicher verwalten und im Multitasking-Modus mehrere nutzlose Funktionen auf einem einzelnen Prozessor ausf√ºhren kann. </p><br><p>  W√§hrend der Entwicklung habe ich mir nicht das Ziel gesetzt, ein neues Linux zu schreiben (obwohl ich zugegebenerma√üen vor ungef√§hr 5 Jahren davon getr√§umt habe) oder jemanden zu beeindrucken, deshalb bitte ich Sie, nicht mehr besonders beeindruckt auszusehen.  Was ich wirklich tun wollte, war herauszufinden, wie die i386-Architektur auf der grundlegendsten Ebene funktioniert und wie genau die Betriebssysteme ihre Magie entfalten und den Hype Rust ausgraben. </p><br><p>  In meinen Notizen werde ich versuchen, nicht nur die Ausgangstexte (sie sind auf GitLab zu finden) und die blo√üe Theorie (sie sind auf vielen Ressourcen zu finden) zu teilen, sondern auch den Weg, den ich gegangen bin, um nicht offensichtliche Antworten zu finden.  In diesem Artikel werde ich speziell √ºber <strong>das Erstellen, Laden und Initialisieren einer Kernel-Datei</strong> sprechen. </p><br><p>  Mein Ziel ist es, die Informationen in meinem Kopf zu strukturieren und denen zu helfen, die einen √§hnlichen Weg gehen.  Ich verstehe, dass √§hnliche Materialien und Blogs bereits im Netzwerk vorhanden sind, aber um zu meiner aktuellen Situation zu gelangen, musste ich sie lange Zeit zusammen sammeln.  Alle Quellen (auf jeden Fall, an die ich mich erinnere) werde ich jetzt teilen. </p><a name="habracut"></a><br><h1 id="literatura-i-istochniki">  Literatur und Quellen </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nat√ºrlich habe</a> ich das meiste davon aus der exzellenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OSDev-</a> Ressource erhalten, sowohl aus dem Wiki als auch aus dem Forum.  Zweitens werde ich Philip Opperman mit seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog nennen</a> - viele Informationen √ºber den Haufen Rost und Eisen. </p><br><p>  Einige Punkte werden im Linux-Kernel ausspioniert, Minix ist nicht ohne die Hilfe spezieller Literatur, wie Tanenbaums Buch ‚Äû <em>Operating Systems.</em>  <em>Design und Implementierung</em> ‚Äú, Robert Love-Buch‚Äû <em>The Linux Kernel.</em>  <em>Beschreibung des Entwicklungsprozesses</em> . ‚Äú  Schwierige Fragen zur Organisation der x86-Architektur wurden mit dem Handbuch ‚Äû <em>Entwicklerhandbuch f√ºr Intel 64- und IA-32-Architekturen - Software Band 3 (3A, 3B, 3C und 3D): Systemprogrammierungshandbuch</em> ‚Äú gel√∂st.  Zum Verst√§ndnis des Formats von Bin√§rdateien sind Layouts Hilfslinien f√ºr ld, llvm, nm, nasm, make. <br>  UPD  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">CoreTeamTech</a> , der mich an das wunderbare Redox OS-System erinnert hat.  Ich bin nicht aus seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle herausgekommen</a> .  Leider ist das offizielle GitLab-System nicht √ºber die russische IP verf√ºgbar, sodass Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ansehen k√∂nnen. </p><br><h1 id="esche-odno-predislovie">  Ein weiteres Vorwort </h1><br><p>  Mir ist klar, dass ich in Rust kein guter Programmierer bin. Au√üerdem ist dies mein erstes Projekt in dieser Sprache (nicht der beste Weg, um mit dem Dating zu beginnen, oder?).  Daher scheint Ihnen die Implementierung v√∂llig falsch zu sein - ich m√∂chte im Voraus um Nachsicht f√ºr meinen Code bitten und werde gerne Kommentare und Vorschl√§ge abgeben.  Wenn mir ein angesehener Leser sagen kann, wo und wie ich weitermachen soll, bin ich auch sehr dankbar.  Einige Codefragmente k√∂nnen aus den Tutorials kopiert und leicht modifiziert werden. Ich werde jedoch versuchen, solche Abschnitte so klar wie m√∂glich zu erkl√§ren, damit Sie nicht die gleichen Fragen haben, die ich beim Parsen hatte.  Ich gebe auch nicht vor, die richtigen Ans√§tze im Design zu verwenden. Wenn mein Speichermanager Sie dazu bringt, ver√§rgerte Kommentare zu schreiben, verstehe ich warum. </p><br><h1 id="instrumentariy">  Toolkit </h1><br><p>  Ich werde also zun√§chst in die von mir verwendeten Entwicklungswerkzeuge eintauchen.  Als Umgebung habe ich einen guten und praktischen VS-Code-Editor mit Plugins f√ºr Rust und einen GDB-Debugger ausgew√§hlt.  VS-Code ist mit RLS manchmal nicht sehr gut, insbesondere wenn er in einem bestimmten Verzeichnis neu definiert wird. Daher musste ich RLS nach jedem n√§chtlichen Rust-Update neu installieren. </p><br><p>  Rust wurde aus mehreren Gr√ºnden gew√§hlt.  Erstens seine wachsende Popularit√§t und angenehme Philosophie.  Zweitens seine F√§higkeit, mit einem niedrigen Niveau zu arbeiten, aber mit einer geringeren Wahrscheinlichkeit, ‚Äûsich selbst in den Fu√ü zu schie√üen‚Äú.  Drittens bin ich als Liebhaber von Java und Maven sehr s√ºchtig nach Systemen und Abh√§ngigkeitsmanagement, und Fracht ist bereits in die Toolchain-Sprache integriert.  Viertens wollte ich nur etwas Neues, nicht wie C. </p><br><p>  F√ºr Low-Level-Code habe ich NASM als  Ich bin von der Intel-Syntax √ºberzeugt und arbeite auch gerne mit den Anweisungen.  Ich habe Assembler-Inserts in Rust bewusst aufgegeben, um die Arbeit explizit mit Eisen- und High-Level-Logik zu trennen. <br>  Make und der Linker aus dem LLVM LLD-Angebot (als schnellerer und besserer Linker) wurden als allgemeine Montage und Layout verwendet - dies ist Geschmackssache.  Es war m√∂glich, Skripte f√ºr Fracht zu erstellen. </p><br><p>  Qemu wurde zum Starten verwendet - ich mag seine Geschwindigkeit, den interaktiven Modus und die F√§higkeit, GDB zu verkn√ºpfen.  Um zu booten und sofort alle Hardware-Informationen zu haben - nat√ºrlich GRUB (Legacy ist einfacher, den Header zu organisieren, also nimm ihn). </p><br><h1 id="linkovka-i-komponovka">  Verkn√ºpfung und Layout </h1><br><p>  Seltsamerweise stellte sich f√ºr mich heraus, dass es eines der schwierigsten Themen war.  Nach langen Versuchen mit x86-Segmentregistern war es √§u√üerst schwierig zu erkennen, dass Segmente und Abschnitte nicht dasselbe sind.  Bei der Programmierung f√ºr die vorhandene Umgebung m√ºssen Sie nicht dar√ºber nachdenken, wie das Programm im Speicher abgelegt werden soll. F√ºr jede Plattform und jedes Format verf√ºgt der Linker bereits √ºber ein vorgefertigtes Rezept, sodass kein Linker-Skript geschrieben werden muss. </p><br><p>  Im Gegensatz dazu muss f√ºr blankes Eisen angegeben werden, wie der Programmcode im Speicher abgelegt und adressiert werden soll.  Hier m√∂chte ich betonen, dass es sich um eine lineare (virtuelle) Adresse handelt, die den Seitenmechanismus verwendet.  OS1 verwendet einen Seitenmechanismus, aber ich werde im entsprechenden Abschnitt des Artikels separat darauf eingehen. </p><br><div class="spoiler">  <b class="spoiler_title">Logisch, linear, virtuell, physisch ...</b> <div class="spoiler_text"><p>  Logische, lineare, virtuelle, physische Adressen.  Ich habe mir bei dieser Frage den Kopf gebrochen, also f√ºr die Details, die ich zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgezeichneten Artikel</a> ansprechen m√∂chte </p></div></div><br><p>  Bei Betriebssystemen, die Paging verwenden, verf√ºgt jede Task in einer 32-Bit-Umgebung √ºber 4 GB adressierbaren Speicherplatz, selbst wenn 128 MB RAM installiert sind.  Dies geschieht nur aufgrund der Paging-Organisation des Speichers, das Fehlen von Seiten im Hauptspeicher wird entsprechend behandelt. </p><br><p>  In der Realit√§t sind Anwendungen jedoch normalerweise mit etwas weniger als 4 GB verf√ºgbar.  Dies liegt daran, dass das Betriebssystem Interrupts und Systemaufrufe verarbeiten muss, was bedeutet, dass sich mindestens ihre Handler in diesem Adressraum befinden m√ºssen.  Wir stehen vor der Frage: Wo genau in diesen 4 GB sollten die Kerneladressen platziert werden, damit Programme korrekt funktionieren k√∂nnen? </p><br><p>  In der modernen Programmwelt wird ein solches Konzept verwendet: Jede Aufgabe glaubt, dass sie √ºber dem Prozessor steht und das einzige laufende Programm auf dem Computer ist (in dieser Phase sprechen wir nicht √ºber die Kommunikation zwischen Prozessen).  Wenn Sie sich genau ansehen, wie die Compiler Programme in der Verkn√ºpfungsphase sammeln, stellt sich heraus, dass sie mit einer linearen Adresse von Null oder nahe Null beginnen.  Dies bedeutet, dass, wenn das Kernel-Image einen Speicherplatz nahe Null belegt, auf diese Weise zusammengestellte Programme nicht ausgef√ºhrt werden k√∂nnen, jeder jmp-Befehl im Programm zum Eintritt in den gesch√ºtzten Speicher des Kernels und zu einem Schutzfehler f√ºhrt.  Wenn wir in Zukunft nicht nur selbst geschriebene Programme verwenden m√∂chten, ist es daher sinnvoll, der Anwendung so viel Speicher wie m√∂glich nahe Null zu geben und das Kernel-Image h√∂her zu platzieren. </p><br><p>  Dieses Konzept hei√üt Higher-Half-Kernel (hier verweise ich Sie auf osdev.org, wenn Sie verwandte Informationen w√ºnschen).  Welche Erinnerung Sie w√§hlen sollten, h√§ngt nur von Ihrem Appetit ab.  512 MB sind genug f√ºr jemanden, aber ich habe beschlossen, mir 1 GB zu schnappen, sodass sich mein Kernel auf 3 GB + 1 MB befindet (+ 1 MB werden ben√∂tigt, um die niedrigeren und h√∂heren Speichergrenzen einzuhalten, GRUB l√§dt uns nach 1 MB in den physischen Speicher). . <br>  Es ist f√ºr uns auch wichtig, den Einstiegspunkt in unsere ausf√ºhrbare Datei anzugeben.  F√ºr meine ausf√ºhrbare Datei ist dies die in Assembler geschriebene _loader-Funktion, auf die ich im n√§chsten Abschnitt n√§her eingehen werde. </p><br><div class="spoiler">  <b class="spoiler_title">√úber den Einstiegspunkt</b> <div class="spoiler_text"><p>  Wussten Sie, dass Sie Ihr ganzes Leben lang gelogen haben, dass main () der Einstiegspunkt in das Programm ist?  Tats√§chlich ist main () eine Konvention der C-Sprache und der von ihr erzeugten Sprachen.  Wenn Sie herumgraben, stellt sich Folgendes heraus. </p><br><p>  Erstens hat jede Plattform ihre eigene Spezifikation und ihren eigenen Einstiegspunktnamen: F√ºr Linux ist es normalerweise _start, f√ºr Windows ist mainCRTStartup.  Zweitens k√∂nnen diese Punkte neu definiert werden, aber dann funktioniert es nicht, die Freuden von libc zu nutzen.  Drittens stellt der Compiler diese Einstiegspunkte standardm√§√üig bereit und sie befinden sich in den Dateien crt0..crtN (CRT - C RunTime, N - Anzahl der Hauptargumente). </p><br><p>  Was machen Compiler wie gcc oder vc? Sie w√§hlen ein plattformspezifisches Link-Skript aus, das einen Standardeinstiegspunkt definiert, w√§hlen die gew√ºnschte Objektdatei mit der vorgefertigten C-Initialisierungsfunktion aus und rufen die Hauptfunktion auf und verkn√ºpfen die Ausgabe in Form einer Datei des gew√ºnschten Formats mit einem Standardeinstiegspunkt. </p><br><p>  F√ºr unsere Zwecke sollten daher der Standardeinstiegspunkt und die CRT-Initialisierung deaktiviert werden, da wir absolut nichts als nacktes Eisen haben. </p></div></div><br><p>  Was m√ºssen Sie noch zum Verkn√ºpfen wissen?  Wie werden die Datenabschnitte (.rodata, .data), nicht initialisierten Variablen (.bss, common) lokalisiert und denken Sie auch daran, dass GRUB die Position von Multiboot-Headern in den ersten 8 KB der Bin√§rdatei erfordert. </p><br><p>  Jetzt k√∂nnen wir ein Linker-Skript schreiben! </p><br><pre><code class="plaintext hljs">ENTRY(_loader) OUTPUT_FORMAT(elf32-i386) SECTIONS { . = 0xC0100000; .text ALIGN(4K) : AT(ADDR(.text) - 0xC0000000) { *(.multiboot1) *(.multiboot2) *(.text) } .rodata ALIGN(4K) : AT(ADDR(.rodata) - 0xC0000000) { *(.rodata*) } .data ALIGN (4K) : AT(ADDR(.data) - 0xC0000000) { *(.data) } .bss : AT(ADDR(.bss) - 0xC0000000) { _sbss = .; *(COMMON) *(.bss) _ebss = .; } }</code> </pre> <br><h1 id="zagruzka-posle-grub">  Nach GRUB herunterladen </h1><br><p>  Wie oben erw√§hnt, erfordert die Multiboot-Spezifikation, dass sich der Header in den ersten 8 KB des Boot-Images befindet.  Die vollst√§ndige Spezifikation ist hier zu sehen, aber ich werde nur auf die Details von Interesse eingehen. </p><br><ul><li>  Die 32-Bit-Ausrichtung (4 Byte) muss eingehalten werden </li><li>  Es muss eine magische Zahl 0x1BADB002 geben </li><li>  Es ist notwendig, dem Multibooter mitzuteilen, welche Informationen wir erhalten m√∂chten und wie die Module platziert werden sollen (in meinem Fall m√∂chte ich, dass das Kernelmodul auf einer 4-KB-Seite ausgerichtet wird und ich eine Speicherkarte bekomme, um mir Zeit und M√ºhe zu sparen). </li><li>  Geben Sie eine Pr√ºfsumme an (Pr√ºfsumme + magische Zahl + Flags sollten Null ergeben) </li></ul><br><pre> <code class="plaintext hljs">MB1_MODULEALIGN equ 1&lt;&lt;0 MB1_MEMINFO equ 1&lt;&lt;1 MB1_FLAGS equ MB1_MODULEALIGN | MB1_MEMINFO MB1_MAGIC equ 0x1BADB002 MB1_CHECKSUM equ -(MB1_MAGIC + MB1_FLAGS) section .multiboot1 align 4 dd MB1_MAGIC dd MB1_FLAGS dd MB1_CHECKSUM</code> </pre> <br><p>  Nach dem Booten garantiert Multiboot einige Bedingungen, die wir ber√ºcksichtigen m√ºssen. </p><br><ul><li>  Das EAX-Register enth√§lt die magische Nummer 0x2BADB002, die besagt, dass der Download erfolgreich war </li><li>  Das EBX-Register enth√§lt die physikalische Adresse der Struktur mit Informationen zu den Ergebnissen des Ladens (wir werden viel sp√§ter dar√ºber sprechen). </li><li>  Der Prozessor befindet sich im gesch√ºtzten Modus, der Seitenspeicher ist ausgeschaltet, die Segmentregister und der Stapel befinden sich in einem (f√ºr uns) undefinierten Zustand. GRUB hat sie f√ºr seine Anforderungen verwendet und muss so schnell wie m√∂glich neu definiert werden. </li></ul><br><p>  Das erste, was wir tun m√ºssen, ist das Paging zu aktivieren, den Stapel zu optimieren und schlie√ülich die Kontrolle auf den √ºbergeordneten Rust-Code zu √ºbertragen. <br>  Ich werde nicht im Detail auf die Seitenorganisation von Speicher, Seitenverzeichnis und Seitentabelle eingehen, da dar√ºber ausgezeichnete Artikel geschrieben wurden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer von ihnen</a> ).  Die Hauptsache, die ich teilen m√∂chte, ist, dass Seiten keine Segmente sind!  Bitte wiederholen Sie meinen Fehler nicht und laden Sie die Seitentabellenadresse nicht in GDTR!  F√ºr die Seitentabelle ist CR3!  Die Seite kann in verschiedenen Architekturen eine unterschiedliche Gr√∂√üe haben. Um die Arbeit zu vereinfachen (um nur eine Seitentabelle zu haben), habe ich aufgrund der Einbeziehung von PSE eine Gr√∂√üe von 4 MB gew√§hlt. </p><br><p>  Wir m√∂chten also den virtuellen Seitenspeicher aktivieren.  Dazu ben√∂tigen wir eine Seitentabelle und ihre physikalische Adresse, die in CR3 geladen sind.  Gleichzeitig wurde unsere Bin√§rdatei verkn√ºpft, um in einem virtuellen Adressraum mit einem Versatz von 3 GB zu arbeiten.  Dies bedeutet, dass alle variablen Adressen und Beschriftungen einen Versatz von 3 GB haben.  Die Seitentabelle ist nur ein Array, in dem die Seitenadresse ihre reale Adresse enth√§lt, die an der Seitengr√∂√üe ausgerichtet ist, sowie Zugriffs- und Statusflags.  Da ich 4 MB Seiten verwende, ben√∂tige ich nur eine PD-Seitentabelle mit 1024 Eintr√§gen: </p><br><pre> <code class="plaintext hljs">section .data align 0x1000 BootPageDirectory: dd 0x00000083 times (KERNEL_PAGE_NUMBER - 1) dd 0 dd 0x00000083 times (1024 - KERNEL_PAGE_NUMBER - 1) dd 0</code> </pre> <br><p>  Was ist in der Tabelle? </p><br><ol><li>  Die allererste Seite sollte zum aktuellen Codeabschnitt f√ºhren (0-4 MB physischer Speicher), da alle Adressen im Prozessor physisch sind und die √úbersetzung in virtuell noch nicht durchgef√ºhrt wurde.  Das Fehlen dieses Seitendeskriptors f√ºhrt zu einem sofortigen Absturz, da der Prozessor nach dem Einschalten der Seiten die n√§chste Anweisung nicht ausf√ºhren kann.  Flags: Bit 0 - die Tabelle ist vorhanden, Bit 1 - die Seite ist geschrieben, Bit 7 - Seitengr√∂√üe 4 MB.  Nach dem Einschalten der Seiten wird der Datensatz zur√ºckgesetzt. </li><li>  √úberspringen Sie bis zu 3 GB - Nullen stellen sicher, dass sich die Seite nicht im Speicher befindet </li><li>  Die 3-GB-Marke ist unser Kern im virtuellen Speicher und verweist auf 0 im physischen Speicher.  Nach dem Umbl√§ttern werden wir hier arbeiten.  Flags √§hneln dem ersten Datensatz. </li><li>  √úberspringen Sie bis zu 4 GB. </li></ol><br><p>  Also haben wir die Tabelle deklariert und wollen nun ihre physikalische Adresse in CR3 laden.  Vergessen Sie nicht den Adressoffset von 3 GB in der Verbindungsphase.  Wenn Sie versuchen, die Adresse so zu laden, wie sie ist, werden wir an die tats√§chliche Adresse mit 3 GB + variablem Offset gesendet und f√ºhren zu einem sofortigen Absturz.  Daher nehmen wir die Adresse von BootPageDirectory und subtrahieren 3 GB davon, setzen sie in CR3.  Wir schalten die PSE im CR4-Register ein, schalten die Arbeit mit Seiten im CR0-Register ein: </p><br><pre> <code class="plaintext hljs"> mov ecx, (BootPageDirectory - KERNEL_VIRTUAL_BASE) mov cr3, ecx mov ecx, cr4 or ecx, 0x00000010 mov cr4, ecx mov ecx, cr0 or ecx, 0x80000000 mov cr0, ecx</code> </pre> <br><p>  Bisher l√§uft alles gut, aber sobald wir die erste Seite zur√ºcksetzen, um endlich in die obere H√§lfte von 3 GB zu gelangen, wird alles zusammenbrechen, da das EIP-Register noch eine physikalische Adresse im Bereich des ersten Megabytes hat.  Um dies zu beheben, f√ºhren wir eine einfache Manipulation durch: Setzen Sie eine Markierung an die n√§chstgelegene Stelle, laden Sie ihre Adresse (sie hat bereits einen Versatz von 3 GB, denken Sie daran) und machen Sie einen bedingungslosen Sprung durch sie.  Danach kann eine unn√∂tige Seite f√ºr zuk√ºnftige Anwendungen zur√ºckgesetzt werden. </p><br><pre> <code class="plaintext hljs"> lea ecx, [StartInHigherHalf] jmp ecx StartInHigherHalf: mov dword [BootPageDirectory], 0 invlpg [0]</code> </pre> <br><p>  Jetzt dreht sich alles um das sehr Kleine: Initialisieren Sie den Stack, √ºbergeben Sie die GRUB-Struktur und Assembler ist genug! </p><br><pre> <code class="plaintext hljs"> mov esp, stack+STACKSIZE push eax push ebx lea ecx, [BootPageDirectory] push ecx call kmain hlt section .bss align 32 stack: resb STACKSIZE</code> </pre> <br><p>  Was Sie √ºber diesen Code wissen m√ºssen: </p><br><ol><li>  Gem√§√ü der C-Konvention von Aufrufen (gilt auch f√ºr Rust) werden Variablen in umgekehrter Reihenfolge √ºber den Stapel an die Funktion √ºbertragen.  Alle Variablen werden in x86 um 4 Byte ausgerichtet. </li><li>  Der Stapel w√§chst vom Ende an, daher sollte der Zeiger auf den Stapel zum Ende des Stapels f√ºhren (f√ºgen Sie der Adresse STACKSIZE hinzu).  Die Stapelgr√∂√üe, die ich nahm, war 16 KB, sollte ausreichen. </li><li>  Folgendes wird auf den Kernel √ºbertragen: die magische Nummer von Multiboot, die physische Adresse der Bootloader-Struktur (f√ºr uns liegt eine wertvolle Speicherkarte), die virtuelle Adresse der Seitentabelle (irgendwo in 3 GB Speicherplatz) </li></ol><br><p>  Vergessen Sie auch nicht zu erkl√§ren, dass kmain extern und _loader global ist. </p><br><h1 id="dalneyshie-shagi">  Weitere Schritte </h1><br><p>  In den folgenden Anmerkungen werde ich √ºber das Einrichten von Segmentregistern sprechen, kurz die Ausgabe von Informationen √ºber einen VGA-Puffer durchgehen, Ihnen erkl√§ren, wie ich die Arbeit mit Interrupts, Seitenverwaltung und dem s√º√üesten - Multitasking - organisiert habe. Ich werde zum Nachtisch gehen. </p><br><p>  Der vollst√§ndige Projektcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist auf GitLab verf√ºgbar</a> . </p><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p><br><p>  UPD2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  UPD2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445506/">https://habr.com/ru/post/de445506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445488/index.html">Monaden aus Sicht der Programmierer (und ein bisschen Kategorietheorie)</a></li>
<li><a href="../de445496/index.html">Wie das CSS-Markup-Fragment den C ++ - Compiler kaputt machte</a></li>
<li><a href="../de445500/index.html">Informationen zu Open Distros, Open Source und Elastic</a></li>
<li><a href="../de445502/index.html">Vivaldi 2.4 - Bewegen Sie die Kn√∂pfe mit zwei H√§nden</a></li>
<li><a href="../de445504/index.html">IT Service Management (ITSM) mit Tools f√ºr maschinelles Lernen effizienter</a></li>
<li><a href="../de445510/index.html">Erwartungen managen oder nein sagen</a></li>
<li><a href="../de445512/index.html">Wie wir PHP 7 doppelt so schnell wie PHP 5 gemacht haben. Teil 2: Optimierung des Bytecodes in PHP 7.1</a></li>
<li><a href="../de445514/index.html">Das interessanteste auf der Ausstellung Securika Moskau 2019</a></li>
<li><a href="../de445516/index.html">Neuronale Quantenzust√§nde - Darstellung einer Wellenfunktion durch ein neuronales Netzwerk</a></li>
<li><a href="../de445518/index.html">Altes Eisen: elektronische Werkzeuge, die in den Tiefen der Geschichte verloren gehen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>