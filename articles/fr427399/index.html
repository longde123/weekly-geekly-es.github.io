<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèº üìÉ üë®üèΩ‚Äç‚öñÔ∏è Utilisation de donn√©es lors de la cr√©ation d'une API bas√©e sur GraphQL üç∏ üë®üèø‚Äçüöí üïì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©ambule 


 Tout d'abord, cet article est con√ßu pour les lecteurs qui connaissent d√©j√† GraphQL et plus sur les subtilit√©s et les nuances de son util...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de donn√©es lors de la cr√©ation d'une API bas√©e sur GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427399/"><h3 id="preambula">  Pr√©ambule </h3><br><p>  Tout d'abord, cet article est con√ßu pour les lecteurs qui connaissent d√©j√† GraphQL et plus sur les subtilit√©s et les nuances de son utilisation.  J'esp√®re n√©anmoins qu'il sera utile aux d√©butants. </p><br><p>  GraphQL est un excellent outil.  Je pense que beaucoup de gens connaissent et comprennent d√©j√† ses avantages.  Cependant, il y a quelques nuances √† prendre en compte lors de la cr√©ation de vos API bas√©es sur GraphQL. </p><br><p> Par exemple, GraphQL vous permet de retourner au consommateur (utilisateur ou programme) en demandant les donn√©es uniquement la partie qui l'int√©resse.  N√©anmoins, lors de la construction d'un serveur, il est assez facile de se tromper, ce qui conduit au fait qu'√† l'int√©rieur du serveur (qui peut √™tre, entre autres, distribu√©), les donn√©es s'ex√©cuteront en bundles complets.  Cela est principalement d√ª au fait que GraphQL lui-m√™me ne fournit pas d'outils pratiques pour analyser une requ√™te entrante et que les interfaces qui y sont pos√©es ne sont pas bien document√©es. </p><a name="habracut"></a><br><h3 id="istochnik-problemy">  Source du probl√®me </h3><br><p>  Regardons un exemple typique d'une impl√©mentation non optimale (ouvrez l'image dans une fen√™tre s√©par√©e si elle est mal lue): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/497/409/cb6/497409cb638a09186c79f0c60e49154c.png" alt="image"></p><br><p>  Supposons que notre consommateur soit une certaine application ou composante du "r√©pertoire t√©l√©phonique" qui ne demande √† notre API que l'identifiant, le nom et le num√©ro de t√©l√©phone des utilisateurs stock√©s par nous.  Dans le m√™me temps, notre API est beaucoup plus √©tendue, elle permettra d'acc√©der √† d'autres donn√©es, telles que l'adresse physique de la r√©sidence et l'adresse e-mail des utilisateurs. </p><br><p>  Au moment de l'√©change de donn√©es entre le consommateur et l'API, GraphQL fait parfaitement tout le travail dont nous avons besoin - seules les donn√©es demand√©es seront envoy√©es en r√©ponse √† la demande.  Le probl√®me dans ce cas est au point d'√©chantillonnage des donn√©es de la base de donn√©es - c'est-√†-dire  dans l'impl√©mentation interne de notre serveur, et cela consiste dans le fait que pour chaque requ√™te entrante nous s√©lectionnons toutes les donn√©es utilisateur de la base de donn√©es, malgr√© le fait que nous n'en ayons pas besoin.  Cela g√©n√®re une charge excessive sur la base de donn√©es et conduit √† la circulation d'un trafic excessif au sein du syst√®me.  Avec un nombre important de requ√™tes, vous pouvez obtenir une optimisation significative en modifiant l'approche d'√©chantillonnage des donn√©es et en s√©lectionnant uniquement les champs qui ont √©t√© demand√©s.  En m√™me temps, peu importe quelle est notre source de donn√©es - une base de donn√©es relationnelle, la technologie NoSQL ou un autre service (interne ou externe).  Tout comportement non optimal peut √™tre affect√© par n'importe quelle impl√©mentation.  MySQL dans ce cas est s√©lectionn√© simplement √† titre d'exemple. </p><br><h3 id="reshenie">  Solution </h3><br><p> Il est possible d'optimiser ce comportement de serveur si nous analysons les arguments qui viennent √† la fonction <code>resolve()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve(source, args, context, info) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  C'est le dernier argument, <code>info</code> , qui nous int√©resse particuli√®rement dans ce cas.  Nous nous tournons vers la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> et analysons en d√©tail en quoi consistent la fonction <code>resolve()</code> et l'argument qui nous int√©resse: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLFieldResolveFn</span></span></span><span class="hljs-class"> = ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">?: {[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">argName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">}, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">?: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> ) =&gt; any </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldNodes</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Array</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">returnType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLOutputType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parentType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLCompositeType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schema</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLSchema</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragments</span></span></span><span class="hljs-class">: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragmentName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FragmentDefinition</span></span></span><span class="hljs-class"> }, rootValue: any, operation: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OperationDefinition</span></span></span><span class="hljs-class">, variableValues: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variableName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> }, }</span></span></code> </pre> <br><p>  Ainsi, les trois premiers arguments transmis au r√©solveur sont la <code>source</code> - les donn√©es transmises par le n≈ìud parent dans l'arborescence GraphQL du sch√©ma, <code>args</code> - les arguments de requ√™te (qui proviennent de la requ√™te) et le <code>context</code> - l'objet de contexte d'ex√©cution d√©fini par le d√©veloppeur, souvent appel√© pour transmettre des donn√©es globales dans les ¬´r√©solveurs¬ª.  Et enfin, le quatri√®me argument est la m√©ta-information sur la demande. </p><br><p>  Que pouvons-nous extraire de <code>GraphQLResolveInfo</code> pour r√©soudre notre probl√®me? </p><br><p>  Ses parties les plus int√©ressantes sont: </p><br><ul><li>  <code>fieldName</code> est le nom de champ actuel de leur sch√©ma GraphQL.  C'est-√†-dire  il correspond au nom de champ sp√©cifi√© dans le sch√©ma pour ce r√©solveur.  Si nous interceptons l'objet <code>info</code> sur le champ <code>users</code> , comme dans notre exemple ci-dessus, alors ce sont les "utilisateurs" qui seront contenus comme la valeur de <code>fieldName</code> </li><li>  <code>fieldNodes</code> - collection (tableau) de n≈ìuds qui ont √©t√© DEMAND√âS dans la requ√™te.  Exactement ce qui est n√©cessaire! </li><li>  <code>fragments</code> - une collection de fragments de la demande (dans le cas o√π la demande a √©t√© fragment√©e).  Informations importantes √©galement pour r√©cup√©rer les champs de donn√©es finaux. </li></ul><br><p>  Donc, comme solution, nous devons analyser l'outil d' <code>info</code> et s√©lectionner la liste des champs qui nous sont venus de la requ√™te, puis les transmettre √† la requ√™te SQL.  Malheureusement, le package GraphQL de Facebook ¬´pr√™t √† l'emploi¬ª ne nous donne rien pour simplifier cette t√¢che.  Dans l'ensemble, comme la pratique l'a montr√©, cette t√¢che n'est pas si simple, √©tant donn√© que les demandes peuvent √™tre fragment√©es.  Et d'ailleurs, une telle analyse a une solution universelle, qui est ensuite simplement copi√©e de projet en projet. </p><br><p>  J'ai donc d√©cid√© de l'√©crire en tant que biblioth√®que open source sous licence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ISC</a> .  Avec son aide, la solution pour analyser les champs de requ√™te entrants est r√©solue tout simplement, par exemple, dans notre cas comme ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsList } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... async resolve(source, args, context, info) { const requestedFields = fieldsList(info); return await database.query(`SELECT ${requestedFields.join(',')} FROM users`) }</span></span></code> </pre> <br><p>  <code>fieldsList(info)</code> dans ce cas fait tout le travail pour nous et retourne un tableau "plat" de champs enfants pour ce r√©solveur, c'est-√†-dire  notre requ√™te SQL finale ressemblera √† ceci: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  Si nous modifions la demande entrante en: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } }</code> </pre> <br><p>  alors la requ√™te SQL se transformera en: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone, email <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  Cependant, il n'est pas toujours possible de faire avec un d√©fi aussi simple.  Souvent, les applications r√©elles ont une structure beaucoup plus complexe.  Dans certaines impl√©mentations, nous pouvons avoir besoin de d√©crire le r√©solveur au niveau sup√©rieur par rapport aux donn√©es dans le sch√©ma GraphQL final.  Par exemple, si nous d√©cidons d'utiliser la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Relay</a> , nous aimerions utiliser un m√©canisme pr√™t √† l'emploi pour diviser les collections d'objets de donn√©es en pages, ce qui conduit au fait que notre sch√©ma GraphQL sera construit selon certaines r√®gles.  Par exemple, nous retravaillons notre sch√©ma de cette fa√ßon (TypeScript): </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { GraphQLObjectType, GraphQLSchema, GraphQLString } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connectionDefinitions, connectionArgs, nodeDefinitions, fromGlobalId, globalIdField, connectionFromArray, GraphQLResolveInfo, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-relay'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { fieldsList } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { nodeInterface, nodeField } = nodeDefinitions(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (globalId: string) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type, id } = fromGlobalId(globalId); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node: any = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type === <span class="hljs-string"><span class="hljs-string">'User'</span></span>) { node = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> database.select(<span class="hljs-string"><span class="hljs-string">`SELECT id FROM user WHERE id="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">"`</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">interfaces</span></span>: [nodeInterface], <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: globalIdField(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, (user: any) =&gt; user.id), <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, } }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">connectionType</span></span>: userConnection } = connectionDefinitions({ <span class="hljs-attr"><span class="hljs-attr">nodeType</span></span>: User }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Query'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">node</span></span>: nodeField, <span class="hljs-attr"><span class="hljs-attr">users</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: userConnection, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: { ...connectionArgs }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve( source: any, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: {[argName: string]: any}, <span class="hljs-attr"><span class="hljs-attr">context</span></span>: any, <span class="hljs-attr"><span class="hljs-attr">info</span></span>: GraphQLResolveInfo, ) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement }, }, }); export const schema = new GraphQLSchema({ query: Query });</span></span></code> </pre> <br><p>  Dans ce cas, <code>connectionDefinition</code> from Relay ajoutera des <code>edges</code> , des <code>node</code> , des informations de page et des n≈ìuds de <code>cursor</code> au sch√©ma, c'est-√†-dire  nous devrons maintenant reconstruire nos requ√™tes diff√©remment (nous ne nous attarderons pas sur la pagination maintenant): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-section"><span class="hljs-section">edges</span></span> { <span class="hljs-section"><span class="hljs-section">node</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } } } }</code> </pre> <br><p>  Ainsi, <code>resolve()</code> fonction impl√©ment√©e sur le n≈ìud des <code>users</code> devra maintenant d√©terminer quels champs sont demand√©s non pas pour lui-m√™me, mais pour son n≈ìud de <code>node</code> enfant imbriqu√©, qui, comme nous le voyons, est relatif aux <code>users</code> long du chemin <code>edges.node</code> . </p><br><p>  <code>fieldsList</code> de la <code>graphql-fields-list</code> aidera √† r√©soudre ce probl√®me, pour cela vous devez lui passer l'option de <code>path</code> correspondante.  Par exemple, voici l'impl√©mentation dans notre cas: </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  Dans le monde r√©el, il se peut √©galement que dans le sch√©ma GraphQL nous ayons d√©fini un seul nom de champ, et dans le sch√©ma de base de donn√©es, d'autres noms de champ leur correspondent.  Par exemple, supposons que la table utilisateur de la base de donn√©es ait √©t√© d√©finie diff√©remment: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> AUTO_INCREMENT, fullName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), email <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), phoneNumber <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), address <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) );</code> </pre> <br><p>  Dans ce cas, les champs de la requ√™te GraphQL doivent √™tre renomm√©s avant d'√™tre incorpor√©s dans la requ√™te SQL.  <code>fieldsList</code> y aidera si vous lui passez une mappe de traduction de nom dans l'option de <code>transform</code> correspondante: </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>: { phone: <span class="hljs-string"><span class="hljs-string">'phoneNumber'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'fullName'</span></span> }, }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  Et pourtant, parfois, la conversion en un tableau plat de champs n'est pas suffisante (par exemple, si la source de donn√©es renvoie une structure complexe avec imbrication).  Dans ce cas, la fonction <code>fieldsMap</code> de la <code>graphql-fields-list</code> viendra √† la rescousse, qui retourne l'arborescence enti√®re des champs demand√©s en tant qu'objet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info); /* RESULT: { edges: { node: { id: false, name: false, phone: false, } } } */ }</span></span></code> </pre> <br><p>  Si nous supposons que l'utilisateur est d√©crit par une structure complexe, nous aurons tout.  Cette m√©thode peut √©galement prendre l'argument de <code>path</code> facultatif, qui vous permet d'obtenir une carte de la branche n√©cessaire uniquement de l'arborescence enti√®re, par exemple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info, 'edges.node'); /* RESULT: { id: false, name: false, phone: false, } */ }</span></span></code> </pre> <br><p>  La transformation des noms sur les cartes n'est actuellement pas prise en charge et reste √† la merci du d√©veloppeur. </p><br><h2 id="fragmentaciya-zaprosov">  Fragmentation de la demande </h2><br><p>  GraphQL prend en charge la fragmentation des requ√™tes, par exemple, nous pouvons nous attendre √† ce que le consommateur nous envoie une telle demande (ici, nous nous r√©f√©rons au sch√©ma d'origine, un peu farfelu, mais syntaxiquement correct): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UsersFragmentedQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> ...NamesFramgment ...ContactsFragment } } fragment NamesFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } fragment AddressFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">address</span></span> } fragment ContactsFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">phone</span></span> email ...AddressFragment }</code> </pre> <br><p>  Ne vous inqui√©tez pas dans ce cas, et <code>fieldsList(info)</code> , et <code>fieldsMap(info)</code> dans ce cas <code>fieldsMap(info)</code> le r√©sultat attendu, car ils prennent en compte la possibilit√© de fragmenter les demandes.  Ainsi, <code>fieldsList(info)</code> renverra <code>['id', 'name', 'phone', 'email', 'address']</code> , et <code>fieldsMap(info)</code> , respectivement, renverra: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h2 id="ps">  PS </h2><br><p>  J'esp√®re que cet article a aid√© √† faire la lumi√®re sur certaines des nuances du travail avec GraphQL sur le serveur, et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que graphql-fields-list</a> peut vous aider √† cr√©er des solutions optimales √† l'avenir. </p><br><h2 id="upd-1">  UPD 1 </h2><br><p>  La version 1.1.0 de la biblioth√®que a √©t√© publi√©e - la prise en <code>@include</code> <code>@skip</code> et <code>@include</code> dans les requ√™tes a √©t√© ajout√©e.  Par d√©faut, l'option est activ√©e, si n√©cessaire, d√©sactivez-la comme ceci: </p><br><pre> <code class="javascript hljs">fieldsList(info, { <span class="hljs-attr"><span class="hljs-attr">withDirectives</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) fieldsMap(info, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427399/">https://habr.com/ru/post/fr427399/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427389/index.html">Op√©ration Vk 2.0. Un projet de loi sur les agr√©gateurs de nouvelles a √©t√© pr√©sent√©. Yandex.News sera ferm√© si le service ne change pas de propri√©taire</a></li>
<li><a href="../fr427391/index.html">Conseils pour les juniors: construire de bonnes habitudes</a></li>
<li><a href="../fr427393/index.html">Analyse de s√©curit√© sans fil d'entreprise</a></li>
<li><a href="../fr427395/index.html">"Expliquons: ou pourquoi un programmeur math√©maticien." Un livre sur la fa√ßon de ne pas manquer les cours de math√©matiques</a></li>
<li><a href="../fr427397/index.html">D√©veloppement d'un ensemble de donn√©es acoustiques pour la formation d'un r√©seau neuronal</a></li>
<li><a href="../fr427401/index.html">Shaders de dissolution et exploration du monde</a></li>
<li><a href="../fr427403/index.html">API ReportingObserver: un regard sur le code des pages web sous un nouvel angle</a></li>
<li><a href="../fr427405/index.html">ES2018 - enfin promet m√©thode</a></li>
<li><a href="../fr427407/index.html">M√©ta-clustering avec minimisation des erreurs, et pourquoi je pense que le cerveau fonctionne de cette fa√ßon</a></li>
<li><a href="../fr427409/index.html">Le livre "The Brilliant Agile. Gestion de projet flexible avec Agile, Scrum et Kanban ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>