<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏾 😓 💆🏻 Der verborgene Preis von CSS-in-JS-Bibliotheken in React-Anwendungen 🛑 🚪 ☝🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In modernen Front-End-Anwendungen ist die CSS-in-JS-Technologie sehr beliebt. Die Sache ist, dass es Entwicklern einen Mechanismus zum Arbeiten mit St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der verborgene Preis von CSS-in-JS-Bibliotheken in React-Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/480358/">  In modernen Front-End-Anwendungen ist die CSS-in-JS-Technologie sehr beliebt.  Die Sache ist, dass es Entwicklern einen Mechanismus zum Arbeiten mit Stilen gibt, der bequemer ist als normales CSS.  Versteh mich nicht falsch.  Ich mag CSS sehr, aber eine gute CSS-Architektur zu erstellen ist keine leichte Aufgabe.  Die CSS-in-JS-Technologie bietet einige wesentliche <a href="https://gist.github.com/threepointone/731b0c47e78d8350ae4e105c1a83867d">Vorteile</a> gegenüber herkömmlichen CSS-Stilen.  Leider kann die Verwendung von CSS-in-JS in bestimmten Anwendungen zu Leistungsproblemen führen.  In diesem Artikel werde ich versuchen, die allgemeinen Funktionen der beliebtesten CSS-in-JS-Bibliotheken zu analysieren, einige der Probleme zu erläutern, die manchmal bei ihrer Verwendung auftreten, und Möglichkeiten zur Minderung dieser Probleme vorzuschlagen. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/480358/"><img src="https://habrastorage.org/webt/u6/f3/cr/u6f3crp6pcjspyohewwxptq84ve.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Situationsübersicht</font> </h2><br>  In meiner Firma wurde beschlossen, eine UI-Bibliothek zu erstellen.  Dies würde uns erhebliche Vorteile bringen und es uns ermöglichen, Standardfragmente von Schnittstellen in verschiedenen Projekten wiederzuverwenden.  Ich war einer der Freiwilligen, die diese Aufgabe übernommen haben.  Ich habe mich für die CSS-in-JS-Technologie entschieden, da ich bereits mit der Styling-API der gängigsten CSS-in-JS-Bibliotheken vertraut war.  Im Laufe der Arbeit habe ich mich bemüht, vernünftig zu handeln.  Ich habe wiederverwendbare Logik entworfen und gemeinsame Eigenschaften in Komponenten angewendet.  Deshalb habe ich die Zusammensetzung der Komponenten aufgegriffen.  Beispielsweise hat die <code>&lt;IconButton /&gt;</code> -Komponente die <code>&lt;IconButton /&gt;</code> -Komponente erweitert, bei der es sich wiederum um eine Implementierung einer einfachen <code>styled.button</code> Entität handelte.  Leider stellte sich heraus, dass <code>IconButton</code> ein eigenes Styling benötigt. <code>IconButton</code> habe ich diese Komponente in eine stilisierte Komponente konvertiert: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IconButton</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">styled</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">BaseButton</span></span>)`  <span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>; `;</code> </pre> <br>  Da immer mehr Komponenten in unserer Bibliothek erschienen, verwendeten wir immer mehr Kompositionsoperationen.  Das schien nicht unnatürlich.  Schließlich ist Komposition die Grundlage von React.  Bis zur Erstellung der <code>Table</code> Komponente war alles in Ordnung.  Ich begann zu spüren, dass diese Komponente langsam gerendert wurde.  Besonders in Situationen, in denen die Anzahl der Zeilen in der Tabelle 50 überschritt. Dies war falsch.  Daher begann ich das Problem zu verstehen, indem ich auf die Entwicklertools zurückgriff. <br><br>  Übrigens, wenn Sie sich jemals gefragt haben, warum CSS-Regeln nicht mit dem Developer Tool Inspector bearbeitet werden können, sollten Sie sich darüber im Klaren sein, dass diese <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule">CSSStyleSheet.insertRule () verwenden</a> .  Dies ist eine sehr schnelle Möglichkeit, Stylesheets zu ändern.  Ein Nachteil ist jedoch, dass die entsprechenden Stylesheets nicht mehr vom Inspector bearbeitet werden können. <br><br>  Unnötig zu erwähnen, dass der von React erzeugte Baum wirklich riesig war.  Die Anzahl der <code>Context.Consumer</code> Komponenten war so groß, dass mir der Schlaf <code>Context.Consumer</code> werden konnte.  Tatsache ist, dass jedes Mal, wenn eine einzelne gestaltete Komponente mithilfe von <a href="https://www.styled-components.com/">gestalteten Komponenten</a> oder <a href="https://emotion.sh/">Emotionen</a> gerendert wird, zusätzlich zum Erstellen einer regulären React-Komponente eine zusätzliche <code>Context.Consumer</code> Komponente <code>Context.Consumer</code> .  Dies ist erforderlich, damit das entsprechende Skript (die meisten CSS-in-JS-Bibliotheken hängen von Skripten ab, die ausgeführt werden, während die Seite ausgeführt wird) die generierten Stilregeln korrekt verarbeiten kann.  Normalerweise verursacht dies keine besonderen Probleme, aber wir dürfen nicht vergessen, dass die Komponenten Zugriff auf das Thema haben müssen.  Dies bedeutet, <code>Context.Consumer</code> für jedes stilisierte Element ein zusätzlicher <code>Context.Consumer</code> muss, mit dem Sie das Thema aus der <code>ThemeProvider</code> Komponente "lesen" <code>ThemeProvider</code> .  Wenn Sie eine stilisierte Komponente in einer Anwendung mit einem Design erstellen, werden 3 Komponenten erstellt.  Dies ist eine <code>StyledXXX</code> Komponente und zwei weitere <code>Context.Consumer</code> Komponenten. <br><br>  Hier gibt es zwar nichts besonders Schreckliches, da React seine Arbeit schnell erledigt, was bedeutet, dass wir uns in den meisten Fällen keine Sorgen machen müssen.  Was aber, wenn mehrere stilisierte Komponenten zusammengefügt werden, um eine komplexere Komponente zu erstellen?  Was ist, wenn diese komplexe Komponente Teil einer langen Liste oder einer großen Tabelle ist, in der mindestens 100 dieser Komponenten gerendert werden?  Hier stehen wir in solchen Situationen vor Problemen ... <br><br><h2>  <font color="#3AC1EF">Profiling</font> </h2><br>  Um verschiedene CSS-in-JS-Lösungen zu testen, habe ich eine einfache Anwendung erstellt.  Es zeigt den <code>Hello World</code> Text 50 Mal an.  In der <a href="https://gist.github.com/3nvi/a47c22872d85d584662e1dbed09dab34">ersten</a> Version dieser Anwendung habe ich diesen Text in ein reguläres <code>div</code> Element eingeschlossen.  In der <a href="https://gist.github.com/3nvi/fed37f5286be2575b8203ec37ff00c99">zweiten habe</a> ich die <code>styled.div</code> Komponente verwendet.  Außerdem habe ich der Anwendung eine Schaltfläche hinzugefügt, mit der alle 50 Elemente neu gerendert werden. <br><br>  Nach dem Rendern der <code>&lt;App /&gt;</code> -Komponente wurden zwei verschiedene Reaktionsbäume angezeigt.  Die folgenden Abbildungen zeigen die von React abgeleiteten Elementbäume. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b7/4c1/161/5b74c11614f8364a88d3cf204c12c7f3.png"></div><br>  <i><font color="#999999">Ein Baum, der in einer Anwendung angezeigt wird, die ein reguläres div-Element verwendet</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/d8b/513/370d8b51371c91ac2c3106c636522711.png"></div><br>  <i><font color="#999999">Ein Baum, der in einer Anwendung angezeigt wird, die styled.div verwendet</font></i> <br><br>  Anschließend habe ich mit der Schaltfläche 10-mal <code>&lt;App /&gt;</code> gerendert, um Daten zur Systemlast zu erfassen, die zusätzliche Komponenten von <code>Context.Consumer</code> .  Hier finden Sie Informationen zum wiederholten Rendern einer Anwendung mit regulären <code>div</code> Elementen im Entwurfsmodus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c25/5ef/c20/c255efc205d63352d9e966a8aefbbff7.png"></div><br>  <i><font color="#999999">Erneutes Rendern der Anwendung mit regulären div-Elementen im Entwurfsmodus.</font></i>  <i><font color="#999999">Der Mittelwert beträgt 2,54 ms.</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/5b1/14a/ddc5b114a6e93cc4dbd7fe52ddf8aa26.png"></div><br>  <i><font color="#999999">Erneutes Rendern der Anwendung mit styled.div-Elementen im Entwicklungsmodus.</font></i>  <i><font color="#999999">Der Durchschnittswert beträgt 3,98 ms.</font></i> <br><br>  Sehr interessant ist, dass eine CSS-in-JS-Anwendung im Durchschnitt 56,6% langsamer ist als üblich.  Aber es war ein Entwicklungsmodus.  Was ist mit dem Produktionsmodus? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/937/07d/34d/93707d34db954762fda1fb82f41fa4ec.png"></div><br>  <i><font color="#999999">Erneutes Rendern der Anwendung mit den üblichen div-Elementen im Produktionsmodus.</font></i>  <i><font color="#999999">Der Durchschnittswert beträgt 1,06 ms.</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d66/b66/400/d66b66400375542ed0644cfd7c962e11.png"></div><br>  <i><font color="#999999">Erneutes Rendern der Anwendung mit styled.div-Elementen im Produktionsmodus.</font></i>  <i><font color="#999999">Der Durchschnittswert beträgt 2,27 ms.</font></i> <br><br>  Wenn der Produktionsmodus aktiviert ist, scheint die div-Implementierung der Anwendung im Vergleich zur gleichen Version im Entwicklungsmodus mehr als 50% schneller zu sein.  Eine styled.div-Anwendung ist nur 43% schneller.  Und hier ist nach wie vor klar, dass die CSS-in-JS-Lösung fast doppelt so langsam ist wie die übliche Lösung.  Was verlangsamt ihn? <br><br><h2>  <font color="#3AC1EF">Analyse der Anwendung während ihrer Ausführung</font> </h2><br>  Die offensichtliche Antwort auf die Frage, was eine CSS-in-JS-Anwendung verlangsamt, <code>Context.Consumer</code> folgt: „Es wurde gesagt, dass hundert CSS-in-JS-Bibliotheken zwei <code>Context.Consumer</code> pro Komponente rendern.“  Wenn Sie dies alles <code>Context.Consumer</code> ist <code>Context.Consumer</code> nur ein Mechanismus für den Zugriff auf eine JS-Variable.  Natürlich muss React einige Arbeiten ausführen, um herauszufinden, wo der entsprechende Wert abgelesen werden soll. Dies allein erklärt jedoch nicht die obigen Messergebnisse.  Die eigentliche Antwort auf diese Frage können Sie finden, indem Sie den Grund für die Verwendung von <code>Context.Consumer</code> .  Tatsache ist, dass die meisten CSS-in-JS-Bibliotheken auf Skripts angewiesen sind, die während der Seitenausgabe im Browser ausgeführt werden und die Bibliotheken dabei unterstützen, Komponentenstile dynamisch zu aktualisieren.  Diese Bibliotheken erstellen während der Seitenmontage keine CSS-Klassen.  Stattdessen generieren und aktualisieren sie dynamisch <code>&lt;style&gt;</code> -Tags im Dokument.  Dies geschieht, wenn die Komponenten montiert werden oder wenn sich ihre Eigenschaften ändern.  Diese Tags enthalten normalerweise eine einzelne CSS-Klasse, deren Hash-Name einer einzelnen React-Komponente zugeordnet ist.  Wenn sich die Eigenschaften dieser Komponente ändern, muss sich auch das entsprechende <code>&lt;style&gt;</code> -Tag ändern.  So beschreiben Sie, was während dieses Vorgangs geschieht: <br><br><ul><li>  Die CSS-Regeln, die das <code>&lt;style&gt;</code> -Tag haben muss, werden neu generiert. </li><li>  Es wird ein neuer Hash-Klassenname erstellt, der zum Speichern der oben genannten CSS-Regeln verwendet wird. </li><li>  Die <code>classname</code> der entsprechenden React-Komponente wird auf eine neue aktualisiert, die die gerade erstellte Klasse angibt. </li></ul><br>  Betrachten Sie beispielsweise die Bibliothek mit <code>styled-components</code> .  Beim Erstellen der <code>styled.div</code> Komponente <code>styled.div</code> Bibliothek dieser Komponente <a href="">einen</a> internen Bezeichner (ID) zu und fügt dem HTML-Tag <code>&lt;head&gt;</code> ein neues <code>&lt;style&gt;</code> -Tag hinzu.  Dieses Tag enthält einen einzelnen Kommentar, der auf die interne Kennung der React-Komponente verweist, zu der der entsprechende Stil gehört: <br><br><pre> <code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">data-styled-components</span></span>&gt;   <span class="hljs-comment"><span class="hljs-comment">/* sc-component-id: sc-bdVaJa */</span></span> &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span>&gt;</code> </pre> <br>  Und hier sind die Aktionen, die die Bibliothek für gestaltete Komponenten ausführt, wenn die entsprechende React-Komponente angezeigt wird: <br><br><ol><li>  Analysiert CSS-Regeln aus der Vorlagenzeichenfolge für gestaltete Komponenten. </li><li>  <a href="">Generiert einen</a> neuen CSS-Klassennamen (oder ermittelt, ob <a href="">der</a> vorherige Name beibehalten werden soll). </li><li>  <a href="">Führt die</a> Vorverarbeitung von Stilen mithilfe von Stiften durch. </li><li>  <a href="">Bettet das</a> aus der Vorverarbeitung resultierende CSS in das entsprechende <code>&lt;style&gt;</code> -Tag des HTML- <code>&lt;head&gt;</code> . </li></ol><br>  Um das Thema in Schritt 1 dieses Prozesses verwenden zu können, ist <a href="">Context.Consumer erforderlich</a> .  Dank dieser Komponente werden die Werte aus dem Thema in der Vorlagenzeichenfolge gelesen.  Um das mit dieser Komponente <code>Context.Consumer</code> <code>&lt;style&gt;</code> -Tag ändern zu können, ist ein weiterer <code>Context.Consumer</code> aus der Komponente erforderlich.  Hiermit können Sie auf eine Instanz eines Stylesheets zugreifen.  Aus diesem Grund stoßen wir in den meisten CSS-in-JS-Bibliotheken auf zwei Instanzen von <code>Context.Consumer</code> . <br><br>  Da sich alle diese Berechnungen auf die Benutzeroberfläche auswirken, ist außerdem zu beachten, dass sie während der Rendering-Phase der Komponenten ausgeführt werden müssen.  Sie können nicht im Code von Ereignishandlern für den Lebenszyklus von React-Komponenten ausgeführt werden (auf diese Weise kann ihre Ausführung verzögert werden und sieht für den Benutzer nach langsamer Seitenbildung aus).  Deshalb ist das Rendern von styled.div-Anwendungen langsamer als das Rendern einer normalen Anwendung. <br><br>  All dies wurde von Design-Komponenten-Entwicklern bemerkt.  Sie haben die Bibliothek optimiert, um die Zeit für das erneute Rendern von Komponenten zu reduzieren.  Insbesondere stellt die Bibliothek fest, ob die stilisierte Komponente „statisch“ ist.  Das heißt, ob die Stile der Komponente vom Thema oder von den Eigenschaften abhängen, die an sie übergeben werden.  Die statische Komponente ist beispielsweise wie folgt dargestellt: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">StaticStyledDiv</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">styled</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.div</span></span>`  <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:red</span></span> `;</code> </pre> <br>  Und diese Komponente ist nicht statisch: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DynamicStyledDiv</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">styled</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.div</span></span>`  <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: ${props =&gt; props.color} `;</code> </pre> <br>  Wenn die Bibliothek feststellt, dass die Komponente statisch ist, werden die obigen <a href="">4 Schritte</a> übersprungen, um zu erkennen, dass der generierte Klassenname niemals geändert werden muss (da kein dynamisches Element vorhanden ist, für das möglicherweise CSS-Regeln geändert werden müssen).  In dieser Situation zeigt die Bibliothek außerdem <a href="">nicht</a> <code>ThemeContext.Consumer</code> die stilisierte Komponente an, da die <code>ThemeContext.Consumer</code> nicht mehr zulässt, dass die Komponente als "statisch" betrachtet wird. <br><br>  Wenn Sie bei der Analyse zuvor dargestellter Screenshots vorsichtig genug waren, können Sie feststellen, dass auch im Produktionsmodus für jedes <code>styled.div</code> zwei <code>Context.Consumer</code> Komponenten <code>Context.Consumer</code> .  Interessanterweise war die gerenderte Komponente "statisch", da mit ihr keine dynamischen CSS-Regeln verknüpft waren.  In einer solchen Situation würde man erwarten, dass dieses Beispiel, wenn es mit der Bibliothek für gestaltete Komponenten geschrieben wurde, nicht <code>Context.Consumer</code> für die Arbeit mit dem Thema erforderlich ist.  Der Grund, warum genau zwei <code>Context.Consumer</code> hier angezeigt werden, ist, dass das Experiment, dessen Daten oben angegeben sind, mit emotion durchgeführt wurde - einer weiteren CSS-in-JS-Bibliothek.  Diese Bibliothek verwendet fast den gleichen Ansatz wie gestaltete Komponenten.  Die Unterschiede zwischen ihnen sind gering.  Daher analysiert die Emotionsbibliothek die Vorlagenzeichenfolge, verarbeitet die Stile mithilfe von <a href="https://stylis.js.org/">Stilen vor</a> und aktualisiert den Inhalt des entsprechenden <code>&lt;style&gt;</code> .  Hierbei ist jedoch ein wesentlicher Unterschied zwischen Stilelementen und Emotionen zu beachten.  Es besteht darin, dass die Emotionsbibliothek <a href="">immer</a> alle Komponenten in <code>ThemeContext.Consumer</code> - unabhängig davon, ob sie das Thema verwenden oder nicht (dies erklärt das Erscheinungsbild des obigen Screenshots).  Interessanterweise <a href="https://medium.com/%40tkh44/emotion-ad1c45c6d28b">übertreffen</a> Emotionen gestaltete Komponenten in Bezug auf die Leistung, obwohl Emotionen mehr Verbraucherkomponenten als gestaltete Komponenten darstellen.  Dies weist darauf hin, dass die Anzahl der <code>Context.Consumer</code> Komponenten kein wesentlicher Faktor für die Verlangsamung des Renderns ist.  Es ist anzumerken, dass zum Zeitpunkt des Schreibens dieses Materials eine Beta-Version von styled-components v5.xx veröffentlicht wurde, die laut den Entwicklern der Bibliothek <a href="https://medium.com/styled-components/announcing-styled-components-v5-beast-mode-389747abd987">die</a> Emotionen in Bezug auf die Leistung <a href="https://medium.com/styled-components/announcing-styled-components-v5-beast-mode-389747abd987">umgeht</a> . <br><br>  Fassen Sie zusammen, worüber wir gesprochen haben.  Es stellt sich heraus, dass eine Kombination vieler <code>Context.Consumer</code> Elemente (was bedeutet, dass React die Arbeit zusätzlicher Elemente koordinieren muss) und interne dynamische Styling-Mechanismen die Anwendung verlangsamen können.  Ich muss sagen, dass alle <code>&lt;style&gt;</code> -Tags, die der <code>&lt;head&gt;</code> für jede Komponente hinzugefügt wurden, niemals gelöscht werden.  Dies ist auf die Tatsache zurückzuführen, dass Elemententfernungsvorgänge das DOM stark belasten (z. B. muss der Browser die Seite aus diesem Grund neu anordnen).  Diese Belastung ist höher als die zusätzliche Belastung des Systems, die durch das Vorhandensein unnötiger <code>&lt;style&gt;</code> -Elemente auf der Seite verursacht wird.  Um ehrlich zu sein, kann ich nicht mit Sicherheit sagen, dass unnötige <code>&lt;style&gt;</code> -Tags zu Leistungsproblemen führen können.  Sie speichern einfach nicht verwendete Klassen, die während des Betriebs der Seite generiert wurden (dh diese Daten wurden nicht über das Netzwerk übertragen).  Sie sollten jedoch über diese Funktion der Verwendung der CSS-in-JS-Technologie Bescheid wissen. <br><br>  Ich muss sagen, dass die <code>&lt;style&gt;</code> -Tags nicht alle CSS-in-JS-Bibliotheken erstellen, da nicht alle auf den Mechanismen basieren, die funktionieren, wenn Seiten in Browsern funktionieren.  Beispielsweise führt die <a href="https://github.com/callstack/linaria">Linaria-</a> Bibliothek überhaupt nichts aus, während die Seite im Browser ausgeführt wird. <br><br>  Es definiert eine Reihe fester CSS-Klassen während des Erstellungsprozesses des Projekts und passt die Entsprechung aller dynamischen Regeln in der Vorlagenzeichenfolge (dh CSS-Regeln, die von den Eigenschaften der Komponente abhängen) mit benutzerdefinierten CSS-Eigenschaften an.  Wenn sich eine Komponenteneigenschaft ändert, ändert sich daher die CSS-Eigenschaft und das Aussehen der Benutzeroberfläche.  Dank dessen ist Linaria viel schneller als Bibliotheken, die auf Mechanismen angewiesen sind, die funktionieren, während Seiten ausgeführt werden.  Die Sache ist, dass bei Verwendung dieser Bibliothek das System beim Rendern von Komponenten viel weniger Berechnungen durchführen muss.  Wenn Sie beim Rendern Linaria verwenden, müssen Sie nur daran denken, <a href="">die</a> benutzerdefinierte CSS-Eigenschaft zu <a href="">aktualisieren</a> .  Gleichzeitig ist dieser Ansatz jedoch nicht mit IE11 kompatibel, bietet nur eingeschränkte Unterstützung für gängige CSS-Eigenschaften und erlaubt Ihnen ohne zusätzliche Konfiguration nicht, Designs zu verwenden.  Wie in anderen Bereichen der Webentwicklung gibt es auch in CSS-in-JS-Bibliotheken keine ideale, für alle Gelegenheiten geeignete. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Die CSS-in-JS-Technologie sah früher wie eine Revolution im Bereich des Stylings aus.  Es hat vielen Entwicklern das Leben erleichtert und es ermöglicht, ohne zusätzlichen Aufwand viele Probleme zu lösen, wie z. B. Namenskollisionen und die Verwendung von Präfixen der Browserhersteller.  Dieser Artikel beleuchtet die Frage, wie beliebte CSS-in-JS-Bibliotheken (die Stile steuern, während eine Seite ausgeführt wird) die Leistung von Webprojekten beeinflussen können.  Ich möchte besonders darauf hinweisen, dass der Einfluss dieser Bibliotheken auf die Performance nicht immer zu spürbaren Problemen führt.  Tatsächlich ist dieser Effekt in den meisten Anwendungen völlig unsichtbar.  In Anwendungen mit Seiten, die Hunderte komplexer Komponenten enthalten, können Probleme auftreten. <br><br>  Die Vorteile von CSS-in-JS überwiegen normalerweise die potenziellen negativen Auswirkungen der Verwendung dieser Technologie.  Die Nachteile von CSS-in-JS sollten jedoch von den Entwicklern in Betracht gezogen werden, deren Anwendungen große Datenmengen wiedergeben, deren Projekte viele sich ständig ändernde Oberflächenelemente enthalten.  Wenn Sie den Verdacht haben, dass Ihre Anwendung den negativen Auswirkungen von CSS-in-JS ausgesetzt ist, lohnt es sich, vor dem Umgestalten alles richtig zu bewerten und zu messen. <br><br>  Im Folgenden finden Sie einige Tipps zur Verbesserung der Anwendungsleistung, die die beliebten CSS-in-JS-Bibliotheken verwenden, die ihre Aufgabe erfüllen, wenn Seiten in einem Browser ausgeführt werden: <br><br><ol><li>  Lassen Sie sich nicht zu sehr von der Zusammensetzung der stilisierten Komponenten mitreißen.  Versuchen Sie nicht, den Fehler zu wiederholen, von dem ich zu Beginn gesprochen habe, und versuchen Sie nicht, eine Komposition aus drei stilisierten Komponenten zu erstellen, um eine unglückliche Schaltfläche zu erstellen.  Wenn Sie den Code "wiederverwenden" möchten, verwenden Sie die CSS-Eigenschaft und erstellen Sie Vorlagenzeichenfolgen.  Auf diese Weise können Sie auf die vielen unnötigen Komponenten von <code>Context.Consumer</code> .  Infolgedessen muss React weniger Komponenten verwalten, was die Projektproduktivität erhöht. </li><li>  Bemühen Sie sich, "statische" Komponenten zu verwenden.  Einige CSS-in-JS-Bibliotheken optimieren den generierten Code, wenn die Stile der Komponente nicht vom Thema oder von den Eigenschaften abhängen.  Je „statischer“ die Vorlagenzeichenfolgen sind, desto höher ist die Wahrscheinlichkeit, dass Skripts in CSS-in-JS-Bibliotheken schneller ausgeführt werden. </li><li>  Vermeiden Sie unnötige Neuerstellungen Ihrer React-Anwendungen.  Bemühen Sie sich, nur zu rendern, wenn Sie es wirklich brauchen.  Dank dessen werden weder React-Aktionen noch CSS-in-JS-Bibliotheksaktionen geladen.  Das erneute Rendern ist eine Operation, die nur in Ausnahmefällen durchgeführt werden sollte.  Zum Beispiel - bei gleichzeitiger Entnahme einer großen Anzahl "schwerer" Bauteile. </li><li>  Finden Sie heraus, ob eine CSS-in-JS-Bibliothek für Ihr Projekt geeignet ist, die keine Skripts verwendet, die ausgeführt werden, während die Seite im Browser ausgeführt wird.  Manchmal entscheiden wir uns für die CSS-in-JS-Technologie, weil es für den Entwickler bequemer ist, sie zu verwenden, und nicht für verschiedene JavaScript-APIs.  Wenn Ihre Anwendung keine Unterstützung benötigt, wenn sie die CSS-Eigenschaften nicht intensiv nutzt, können Sie möglicherweise eine CSS-in-JS-Bibliothek wie Linaria verwenden, die keine Skripts verwendet, die ausgeführt werden, während die Seite ausgeführt wird.  Durch diesen Ansatz wird außerdem die Größe des Anwendungsbündels um etwa 12 KB verringert.  Tatsache ist, dass die Codegröße der meisten CSS-in-JS-Bibliotheken in 12-15 KB passt und der Code derselben Linaria weniger als 1 KB beträgt. </li></ol><br>  <b>Sehr geehrte Leser!</b>  Verwenden Sie CSS-in-JS-Bibliotheken? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480358/">https://habr.com/ru/post/de480358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480348/index.html">Deep Fake Science, die Krise der Reproduzierbarkeit und woher kommen leere Repositories?</a></li>
<li><a href="../de480350/index.html">Die Zusammenstellung interessanter Materialien für den mobilen Entwickler # 326 (9. - 15. Dezember)</a></li>
<li><a href="../de480352/index.html">Der Harvard-Genetiker entwickelt eine Prototyp-DNA-Analyse-Dating-App</a></li>
<li><a href="../de480354/index.html">Erste Schritte mit den JavaScript-Array-Methoden .map (), .filter () und .reduce ()</a></li>
<li><a href="../de480356/index.html">Nützliche Python-Tipps, die Sie noch nicht kennengelernt haben</a></li>
<li><a href="../de480362/index.html">Abenteuer von deutschem abgereichertem Uranhexafluorid in Russland. Teil 1. Geschichte und Anreicherungstechnologien</a></li>
<li><a href="../de480364/index.html">Metaphysik der Abhängigkeitsinjektion</a></li>
<li><a href="../de480368/index.html">Abfangen von Speicherverlusten in C / C ++</a></li>
<li><a href="../de480376/index.html">Von Computerspielen bis zu geheimen Nachrichten: Diskutieren Sie Ostereier in Vinyl-Veröffentlichungen</a></li>
<li><a href="../de480386/index.html">Auto-Backups von Netzwerkgeräten und deren Speicherung im Versionskontrollsystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>