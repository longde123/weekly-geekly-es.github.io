<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍺 🐆 👩🏻‍✈️ Unity中的六边形图：路径查找器，播放器小队，动画 🤴 👦🏻 🖖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第1-3部分：网格，颜色和像元高度 

 第4-7部分：颠簸，河流和道路 

 第8-11部分：水，地貌和城墙 

 第12-15部分：保存和加载，纹理，距离 

 第16-19部分：找到道路，队员，动画 

 第20-23部分：战争迷雾，地图研究，程序生成 

 第24-27部分：水循环，侵蚀，生...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity中的六边形图：路径查找器，播放器小队，动画</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426481/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1-3部分：网格，颜色和像元高度</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4-7部分：颠簸，河流和道路</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8-11部分：水，地貌和城墙</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第12-15部分：保存和加载，纹理，距离</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第16-19部分：找到道路，队员，动画</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20-23部分：战争迷雾，地图研究，程序生成</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24-27部分：水循环，侵蚀，生物群落，圆柱图</a> <br><br><h1> 第16部分：寻找方法 </h1><br><ul><li> 突出显示单元格 </li><li> 选择搜索目标 </li><li> 找到最短的路径 </li><li> 创建优先级队列 </li></ul><br> 在计算了单元之间的距离之后，我们开始寻找它们之间的路径。 <br><br> 从这一部分开始，将在Unity 5.6.0中创建六角形图教程。 应当指出，在5.6中，存在一个错误，该错误会破坏多个平台的程序集中的纹理数组。 您可以通过在纹理数组检查器中包含<em>“可读”</em>来解决此问题。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/165/c4e/1d9165c4e1862b050015df3c9dcc48cd.jpg"></div><br>  <i>计划行程</i> <br><a name="habracut"></a><br><h2> 突出显示的单元格 </h2><br> 要搜索两个单元格之间的路径，我们首先需要选择这些单元格。 这不仅仅是选择一个单元并监视地图上的搜索。 例如，我们将首先选择初始单元格，然后选择最后一个单元格。 在这种情况下，突出显示它们将很方便。 因此，让我们添加这样的功能。 在我们创建复杂或有效的突出显示方式之前，我们只是创建一些东西来帮助我们进行开发。 <br><br><h3> 轮廓纹理 </h3><br> 选择单元格的一种简单方法是为其添加路径。 最简单的方法是使用包含六边形轮廓的纹理。  <a href="">在这里</a>您可以下载这样的纹理。 除六角形的白色轮廓外，它是透明的。 将其制成白色后，将来我们将能够根据需要对其进行着色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/4u/vs/0j4uvsbyjtxiavcwaajn73csp68.png"></div><br>  <i>在黑色背景上的单元格轮廓</i> <br><br> 导入纹理并将其<em>纹理类型</em>设置为<em>Sprite</em> 。 她的<em>Sprite Mode</em>将使用默认设置设置为<em>Single</em> 。 由于这是一种非常白色的纹理，因此我们无需转换为<em>sRGB</em> 。  Alpha通道表示透明度，因此启用<em>Alpha为Transparency</em> 。 我还将“ <em>过滤器模式”</em>纹理设置为<em>Trilinear</em> ，因为否则路径的mip过渡可能会变得太明显。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebb/e4a/a88/ebbe4aa88f93b71cf5946c4c011339dc.png"></div><br>  <i>纹理导入选项</i> <br><br><h3> 每个单元格一个精灵 </h3><br> 最快的方法是在单元格中添加可能的轮廓，并添加每个自己的精灵。 创建一个新的游戏对象，向其添加Image组件（ <em>Component / UI / Image</em> ），并为其分配轮廓精灵。 然后将“ <em>十六进制单元标签”</em>预制实例插入场景，使精灵对象成为其子级，将更改应用于预制，然后摆脱预制。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/7f6/7f4/5c27f67f4596673f5b2e73b2db5073cd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/f7c/ea8/5daf7cea84e2ff46829460e0523bfa91.png"></div><br>  <i>预制子选择元素</i> <br><br> 现在，每个单元都有一个精灵，但是它会太大。 为了使轮廓与单元格的中心匹配，请将精灵的变换分量的“ <em>宽度”</em>和“ <em>高度</em> ”更改为17。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/069/e42/bc1069e4216435f1a30af953af5b948a.png"></div><br>  <i>选择精灵被浮雕部分隐藏</i> <br><br><h3> 在一切之上绘图 </h3><br> 由于轮廓叠加在像元边缘的区域上，因此它通常出现在凸版的几何形状下方。 因此，部分电路消失了。 可以通过在垂直方向略微提升精灵来避免这种情况，但在中断的情况下则不能避免。 相反，我们可以执行以下操作：始终在其他所有对象上绘制精灵。 为此，请创建自己的精灵着色器。 复制标准的Unity Sprite着色器并对其进行一些更改就足够了。 <br><br><pre><code class="hljs powershell">Shader <span class="hljs-string"><span class="hljs-string">"Custom/Highlight"</span></span> { Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">MaterialToggle</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PixelSnap</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Pixel snap"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RendererColor</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"RendererColor"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Flip"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"External Alpha"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableExternalAlpha</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Enable External Alpha"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"PreviewType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Plane"</span></span> <span class="hljs-string"><span class="hljs-string">"CanUseSpriteAtlas"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> } Cull Off ZWrite Off Blend One OneMinusSrcAlpha Pass { CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">#pragma vertex SpriteVert #pragma fragment SpriteFrag #pragma target 2.0 #pragma multi_compile_instancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #include "UnitySprites.cginc" ENDCG } } }</span></span></code> </pre> <br> 第一个变化是我们忽略了深度缓冲区，从而使Z测试始终成功。 <br><br><pre> <code class="hljs pgsql"> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span></code> </pre> <br> 第二个变化是我们在其余透明几何图形之后进行渲染。 足以将10添加到透明度队列中。 <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+10"</span></span></code> </pre> <br> 创建此材质球将使用的新材质。 我们可以忽略其所有属性，并遵循默认值。 然后使精灵预制件使用这种材料。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/d01/812/15bd01812d94f52ced67308dd000c430.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/393/e24/ef5393e241252d81513a0ff5f8972b50.png"></div><br>  <i>我们使用自己的精灵材质</i> <br><br> 现在，选择的轮廓始终可见。 即使该单元格隐藏在较高的浮雕下，其轮廓仍将绘制在其他所有元素之上。 它可能看起来不漂亮，但是所选单元格始终可见，这对我们很有用。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/8bc/418/ce28bc418dc0ec116cff1bcbaddf0363.png"></div><br>  <i>忽略深度缓冲区</i> <br><br><h3> 选择控制 </h3><br> 我们不希望同时突出显示所有单元格。 实际上，一开始它们都应该未被选中。 我们可以通过禁用<em>Highlight</em>预制对象的Image组件来实现。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/00e/164/82f00e164316900fb9d9694030298bcc.png"></div><br>  <i>禁用的图像组件</i> <br><br> 要启用单元格选择，请将<code>HexCell</code>方法添加到<code>EnableHighlight</code> 。 它应采用<code>uiRect</code>的唯一子项，并包括其Image组件。 我们还将创建<code>DisableHighlight</code>方法。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 最后，我们可以指定颜色，以便在打开时为背光赋予色调。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.color = color; highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 找路 </h2><br> 现在我们可以选择单元格，我们需要继续并选择两个单元格，然后找到它们之间的路径。 首先，我们需要选择单元格，然后将搜索限制在它们之间的路径上，最后显示此路径。 <br><br><h3> 搜索开始 </h3><br> 我们需要选择两个不同的单元格，即搜索的起点和终点。 假设要选择初始搜索单元格，请在单击鼠标的同时按住左Shift键。 在这种情况下，单元格将突出显示为蓝色。 我们需要保存指向该单元格的链接以进行进一步搜索。 此外，在选择新的起始单元格时，必须禁用旧单元格的选择。 因此，我们将<code>HexMapEditor</code>字段添加到<code>searchFromCell</code> 。 <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell;</code> </pre> <br> 在<code>HandleInput</code>内部<code>HandleInput</code>我们可以使用<code>Input.GetKey(KeyCode.LeftShift)</code>测试按下的Shift键。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/a63/1c3/d50a631c3f4701e414b2e9a9078a57a2.png"></div><br>  <i>在哪里看</i> <br><br><h3> 搜索终点 </h3><br> 现在，我们正在寻找两个特定像元之间的路径，而不是寻找到一个像元的所有距离。 因此，将<code>HexGrid.FindDistancesTo</code>重命名为<code>HexGrid.FindPath</code>并<code>HexGrid.FindPath</code>提供第二个<code>HexCell</code>参数，并更改<code>Search</code>方法。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(fromCell); … }</code> </pre> <br> 现在， <code>HexMapEditor.HandleInput</code>应该使用<code>searchFromCell</code>和<code>currentCell</code>作为参数来调用修改后的方法。 另外，我们只有在知道从哪个单元格进行搜索时才可以搜索。 而且，我们不必费心搜索起点和终点是否重合。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { hexGrid.FindPath(searchFromCell, currentCell); }</code> </pre> <br> 转向搜索，我们首先需要摆脱所有先前的选择。 因此，使<code>HexGrid.Search</code>在重置距离时关闭选择。 由于这也会关闭初始电池的照明，因此请再次打开它。 在这一阶段，我们还可以突出显示终点。 让她变红。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].DisableHighlight(); } fromCell.EnableHighlight(Color.blue); toCell.EnableHighlight(Color.red); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/01c/5e5/18101c5e578322ea99598cbca70f60a9.png"></div><br>  <i>潜在路径的端点</i> <br><br><h3> 极限搜索 </h3><br> 此时，我们的搜索算法仍会计算从起始像元到所有可到达像元的距离。 但是我们不再需要它了。 一旦找到到最终单元的最终距离，我们就可以停下来。 也就是说，当当前单元格有限时，我们可以退出算法循环。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/424/6e0/d49/4246e0d491a1938dfb1e9b3a00080e42.png"></div><br>  <i>停在终点</i> <br><br><div class="spoiler">  <b class="spoiler_title">如果无法到达端点会怎样？</b> <div class="spoiler_text"> 然后，该算法将继续起作用，直到找到所有可到达的小区为止。 不可能过早退出，它将作为旧的<code>FindDistancesTo</code>方法工作。 </div></div><br><h3> 路径显示 </h3><br> 我们可以找到路径起点和终点之间的距离，但尚不知道真正的路径是什么。 要找到它，您需要跟踪如何到达每个单元格。 但是怎么做呢？ <br><br> 当将一个单元格添加到边界时，我们这样做是因为它是当前单元格的邻居。 一个例外是起始单元格。 通过当前单元格已到达所有其他单元格。 如果我们跟踪每个单元是从哪个单元到达的，那么结果就是一个单元网络。 更准确地说，是一个树状网络，其根源是起点。 到达终点后，我们可以使用它来构建路径。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a71/331/153/a713311534e05f46c6fd22a632100494.png"></div><br>  <i>描述中心路径的树形网络</i> <br><br> 我们可以通过添加指向<code>HexCell</code>另一个单元格的链接来保存此信息。 我们不需要序列化此数据，因此我们为此使用标准属性。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell PathFrom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br> 在<code>HexGrid.Search</code>将其添加到边框时，将其邻居的<code>PathFrom</code>值设置为当前单元格。 此外，当我们找到通往邻居的更短路径时，我们需要更改此链接。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; neighbor.PathFrom = current; }</code> </pre> <br> 到达终点后，我们可以通过将这些链接跟随回到起始单元格并选择它们来可视化路径。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/9cc/8de/f899cc8de04e0c5666a2a05558b28042.png"></div><br>  <i>找到路径</i> <br><br> 值得考虑的是，通常有几种最短的路径。 找到的一个取决于细胞的处理顺序。 有些路径可能看起来不错，而另一些则可能很糟糕，但是从来没有更短的路径。 我们待会儿会再谈这个。 <br><br><h3> 更改搜索开始 </h3><br> 选择起点后，更改终点将触发新的搜索。 选择新的起始单元格时，应该发生相同的事情。 为了使之成为可能， <code>HexMapEditor</code>还必须记住端点。 <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell, searchToCell;</code> </pre> <br> 使用此字段，我们还可以在选择新的开始时启动新的搜索。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell); }</code> </pre> <br> 另外，我们需要避免起点和终点相等。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { … }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 更智能的搜索 </h2><br> 尽管我们的算法找到了最短的路径，但它花费大量时间来探索显然不会成为该路径一部分的点。 至少对我们来说很明显。 该算法无法在地图上往下看；它无法看到在某些方向上进行搜索是没有意义的。 尽管道路正朝着与终点相反的方向行驶，但他还是喜欢在道路上行驶。 是否可以使搜索更智能？ <br><br> 目前，在选择下一个要处理的单元格时，我们仅考虑从单元格到起点的距离。 如果我们想做得更聪明，那么我们还必须考虑到终点的距离。 不幸的是，我们还不认识他。 但是我们可以创建剩余距离的估计值。 将此估算值添加到到单元的距离，可以使我们了解通过该单元的路径的总长度。 然后，我们可以使用它来优先进行单元格搜索。 <br><br><h3> 搜索启发式 </h3><br> 当我们使用估计或猜测而不是完全已知的数据时，这称为使用搜索启发式。 此启发式表示对剩余距离的最佳猜测。 我们必须为要搜索的每个单元格确定该值，因此我们将<code>HexCell</code>添加一个<code>HexCell</code>整数属性。 我们不需要序列化它，因此另一个标准属性就足够了。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchHeuristic { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br> 我们如何对剩余距离做出假设？ 在最理想的情况下，我们将有一条直通终点的道路。 如果是这样，则该距离等于此像元与最终像元之间坐标的不变距离。 让我们在启发式方法中加以利用。 <br><br> 由于启发式方法不依赖于先前经过的路径，因此它在搜索过程中是恒定的。 因此，当<code>HexGrid.Search</code>将一个单元格添加到边框时，我们只需要计算一次。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); frontier.Add(neighbor); }</code> </pre> <br><h3> 搜索优先级 </h3><br> 从现在开始，我们将根据与单元格的距离及其启发式方法确定搜索的优先级。 让我们在<code>HexCell</code>为此值添加一个属性。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance + SearchHeuristic; } }</code> </pre> <br> 为此，请<code>HexGrid.Search</code> ，以使其使用此属性对边框进行排序。 <br><br><pre> <code class="cs hljs"> frontier.Sort( (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/a22/c9a/b58a22c9a65a2088309a46c6cbc2d102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br>  <i>无启发式搜索和有启发式搜索</i> <br><br><h3> 有效启发式 </h3><br> 由于有了新的搜索优先级，因此实际上我们将访问较少的单元。 但是，在统一的地图上，该算法仍会处理方向错误的单元。 这是因为，默认情况下，每个移动步骤的成本为5，并且每个步骤的启发式方法仅增加1。也就是说，启发式方法的影响不是很大。 <br><br> 如果移动所有卡的成本相同，那么在确定启发式算法时我们可以使用相同的成本。 在我们的情况下，这将是当前的启发式方法乘以5。这将大大减少已处理单元的数量。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a4/6c7/ac3/9a46c7ac3c0df63797bfda1f143f9409.png"></div><br>  <i>使用启发式×5</i> <br><br> 但是，如果地图上有道路，那么我们可以高估剩余的距离。 结果，该算法可能会出错，并创建实际上并非最短的路径。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/7bb/dc7/cd27bbdc7043804a8d2a21ac096a6409.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/017/2a2/0af0172a264285358f99b0ece93833a3.png"></div><br>  <i>高估和有效的启发式</i> <br><br> 为了确保找到最短路径，我们需要确保永远不要高估剩余距离。 这种方法称为有效启发式。 由于最小移动成本为1，我们别无选择，只能使用相同的成本来确定启发式方法。 <br><br> 严格来说，使用更低的成本是很正常的，但这只会使启发式方法变弱。 可能的最小启发式为零，这仅是Dijkstra的算法。 对于非零启发式算法，该算法称为A <sup>*</sup> （发音为“ A star”）。 <br><br><div class="spoiler">  <b class="spoiler_title">为什么叫A *？</b> <div class="spoiler_text">  Niels Nilsson首先提出了在Dijkstra的算法中添加启发式算法的想法。 他将他的版本命名为A1。  Bertram Rafael后来提出了他称为A2的最佳版本。 然后彼得·哈特（Peter Hart）证明，具有良好的启发式A2是最佳的，也就是说，没有更好的版本。 这迫使他称算法A <sup>*</sup>表示无法改进，即不会出现A3或A4。 是的，A <sup>*</sup>算法是我们可以获得的最佳算法，但它与启发式算法一样好。 </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 优先队列 </h2><br> 尽管A <sup>*是一种</sup>很好的算法，但我们的实现效果并不理想，因为我们使用列表来存储边界，该边界需要在每次迭代时进行排序。 如前一部分所述，我们需要一个优先级队列，但是它的标准实现不存在。 因此，让我们自己创建它。 <br><br> 轮到我们应该支持基于优先级的设置和从队列中排除的操作。 它还应支持更改队列中已有单元的优先级。 理想情况下，我们实现它，以最小化排序和分配内存的搜索。 另外，它应该保持简单。 <br><br><h3> 创建自己的队列 </h3><br> 使用所需的通用方法创建一个新的<code>HexCellPriorityQueue</code>类。 我们使用一个简单的列表来跟踪队列的内容。 另外，我们将向其添加<code>Clear</code>方法以清除队列，以便可以重复使用它。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellPriorityQueue</span></span> { List&lt;HexCell&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); } }</code> </pre> <br> 我们将单元优先级存储在单元本身中。 也就是说，在将单元添加到队列之前，必须设置其优先级。 但是，如果发生优先级更改，了解旧优先级可能会很有用。 因此，我们将其添加为<code>Change</code>作为参数。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br> 知道队列中有多少个单元格也很有用，因此我们为此添加<code>Count</code>属性。 只需使用我们将执行相应增量和减量的字段即可。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3> 添加到队列 </h3><br> 将单元格添加到队列后，我们首先将其优先级用作索引，将列表视为简单数组。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; list[priority] = cell; }</code> </pre> <br> 但是，这仅在列表足够长的情况下有效，否则我们将超越国界。 您可以通过将空项目添加到列表中直到达到所需的长度来避免这种情况。 这些空元素不引用该单元格，因此您可以通过将<code>null</code>添加到列表中来创建它们。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priority &gt;= list.Count) { list.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e77/000/fec/e77000feca5c0bfdb769062356ca9935.png"></div><br>  <i>带孔清单</i> <br><br> 但这是我们每个优先级仅存储一个单元格的方式，很可能将有几个。 要跟踪具有相同优先级的所有单元，我们需要使用另一个列表。 尽管我们可以为每个优先级使用真实列表，但是我们也可以向<code>HexCell</code>添加属性以将它们绑定在一起。 这使我们可以创建称为链表的单元链。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell NextWithSamePriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br> 若要创建链，请让<code>HexCellPriorityQueue.Enqueue</code>强制新添加的单元在删除之前引用具有相同优先级的当前值。 <br><br><pre> <code class="cs hljs"> cell.NextWithSamePriority = list[priority]; list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/082/87c/45b08287cf76c4636d7a673869aa39b5.png"></div><br>  <i>链表清单</i> <br><br><h3> 从队列中删除 </h3><br> 要从优先级队列中获取单元格，我们需要以最低的非空索引访问链接列表。 因此，我们将循环遍历该列表，直到找到它为止。 如果找不到，则队列为空，并返回<code>null</code> 。 <br><br> 从找到的链中，我们可以返回任何单元，因为它们都具有相同的优先级。 最简单的方法是从链的开头返回单元格。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { HexCell cell = list[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> 要保持到其余链的链接，请使用与新起点相同优先级的下一个单元。 如果在此优先级上只有一个像元，则该元素将为<code>null</code> ，以后将被跳过。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[i] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre> <br><h3> 最小跟踪 </h3><br> 这种方法有效，但是每次接收到一个单元时都会遍历列表。 我们无法避免找到最小的非空索引，但是并不需要每次都从头开始。 相反，我们可以跟踪最低优先级并以此开始搜索。 最初，最小值基本上等于无穷大。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; }</code> </pre> <br> 将单元格添加到队列时，我们会根据需要更改最小值。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority &lt; minimum) { minimum = priority; } … }</code> </pre> <br> 从队列中退出时，我们至少将列表用于迭代，而不是从头开始。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; minimum &lt; list.Count; minimum++) { HexCell cell = list[minimum]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[minimum] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> 这大大减少了在优先级列表循环中绕过的时间。 <br><br><h3> 变更优先级 </h3><br> 更改单元格的优先级时，必须将其从其所属的链表中删除。 为此，我们需要遵循链条，直到找到它。 <br><br> 让我们首先声明旧优先级列表的开头将是当前单元格，我们还将跟踪下一个单元格。 我们可以立即获取下一个单元格，因为我们知道此索引至少有一个单元格。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; }</code> </pre> <br> 如果当前单元格是更改的单元格，则这是头部单元格，我们可以将其切断，就好像我们已将其从队列中拉出一样。 <br><br><pre> <code class="cs hljs"> HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; }</code> </pre> <br> 如果不是这种情况，那么我们需要遵循链条，直到我们位于更改后的单元格前面的单元格中。 它包含指向已修改单元格的链接。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } }</code> </pre> <br> 此时，我们可以从链接列表中删除更改的单元格，并跳过它。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } current.NextWithSamePriority = cell.NextWithSamePriority;</code> </pre> <br> 删除单元格后，您需要再次添加它，以使其出现在其新优先级列表中。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { … Enqueue(cell); }</code> </pre> <br>  <code>Enqueue</code>方法使计数器增加，但实际上我们没有添加新的单元格。 因此，为了补偿这一点，我们将不得不减少计数器。 <br><br><pre> <code class="cs hljs"> Enqueue(cell); count -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h3> 队列使用 </h3><br> 现在，我们可以利用<code>HexGrid</code>的优先级队列。 可以使用单个实例完成此操作，该实例可用于所有搜索操作。 <br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开始循环之前，</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须先将</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">添加到队列中</font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且每次迭代都从队列中单元的输出开始。</font><font style="vertical-align: inherit;">这将替换旧的边界代码。</font></font><br><br><pre> <code class="cs hljs"> WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// List&lt;HexCell&gt; frontier = new List&lt;HexCell&gt;(); fromCell.Distance = 0; // frontier.Add(fromCell); searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { yield return delay; HexCell current = searchFrontier.Dequeue(); // frontier.RemoveAt(0); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改代码，以便添加和更改邻居。</font><font style="vertical-align: inherit;">更改之前，我们会记住旧的优先级。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); <span class="hljs-comment"><span class="hljs-comment">// frontier.Add(neighbor); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此外，我们不再需要对边框进行排序。 </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// frontier.Sort( // (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) // );</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用优先级队列进行搜索</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如前所述，找到的最短路径取决于单元的处理顺序。</font><font style="vertical-align: inherit;">轮到我们创建与排序列表顺序不同的顺序，因此我们可以采用其他方法。</font><font style="vertical-align: inherit;">由于我们为每个优先级从链接列表的开头添加和删除，因此它们更像是堆栈而不是队列。</font><font style="vertical-align: inherit;">最后添加的单元格首先被处理。</font><font style="vertical-align: inherit;">这种方法的副作用是该算法容易产生锯齿形。</font><font style="vertical-align: inherit;">因此，之字形路径的可能性也会增加。</font><font style="vertical-align: inherit;">幸运的是，这样的路径通常看起来更好，所以这种副作用对我们有利。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/1e9/cc5/9081e9cc5b0ea1d6f4309b6221eab1ac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已排序的列表和队列具有</font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">unitypackage </font></a><i><font style="vertical-align: inherit;">优先级</font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第17部分：运动受限 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们找到逐步移动的方法。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 立即显示路径。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们创建一个更有效的搜索。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们仅可视化路径。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这一部分中，我们将运动分为多个动作，并尽可能加快搜索速度。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/572/9cc/c4d5729ccbf9cc994b7c8328950e6f5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几步走</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 逐步运动 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用六角网的战略游戏几乎总是回合制的。</font><font style="vertical-align: inherit;">在地图上移动的单位的速度有限，这限制了一圈的行驶距离。</font></font><br><br><h3> 速度 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了在有限的运动，附加提供支撑</font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数参数</font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它确定一动的运动范围。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell, speed)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏中不同类型的单位使用不同的速度。</font><font style="vertical-align: inherit;">骑兵快，步兵慢，等等。</font><font style="vertical-align: inherit;">我们还没有单位，所以现在我们将使用恒定速度。</font><font style="vertical-align: inherit;">让我们取值为24。这是一个相当大的值，不能被5整除（默认移动成本）。</font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恒定速度</font><font style="vertical-align: inherit;">添加作为参数</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 动作 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了跟踪沿路径移动的总成本外，我们现在还需要知道沿路径移动需要多少次移动。但是我们不需要在每个单元格中存储此信息。可以通过将行进距离除以速度来获得。由于这些是整数，因此我们将使用整数除法。即，总距离不超过24对应于路线0。这意味着整个路径可以在当前路线中完成。如果终点距离为30，则必须为转弯1。要到达终点，设备必须在当前转弯以及下一转弯的一部分中花费所有运动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们确定当前单元格及其内部所有邻居的路线</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">就在邻居循环之前，当前单元格的路线只能计算一次。</font><font style="vertical-align: inherit;">我们只要找到与邻居的距离，就可以确定邻居的举动。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = current.Distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 机芯丢失 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果邻居的移动大于当前移动，则我们越过了移动的边界。</font><font style="vertical-align: inherit;">如果到达邻居的必要运动为1，则一切正常。</font><font style="vertical-align: inherit;">但是，如果转移到下一个单元格比较昂贵，那么一切都会变得更加复杂。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我们沿着同质图移动，也就是说，要进入每个像元，您需要5个移动单位。</font><font style="vertical-align: inherit;">我们的速度是24，经过4个步骤，我们从机芯中花了20个单位，剩下4个，在下一步中，又需要5个单位，即比可用单位多一个。</font><font style="vertical-align: inherit;">我们现阶段需要做什么？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种方法可以解决这种情况。第一个是即使我们没有足够的移动，也允许部队在当前回合进入第五个格。第二个是在当前移动期间禁止移动，也就是说，剩余的移动点将无法使用，并且将丢失。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项的选择取决于游戏。通常，第一种方法更适合于单位每转只能移动几步的游戏，例如，《文明》系列的游戏。这确保了单位每转始终可以移动至少一个单元。如果单位每回合可以移动许多格，例如《奇迹时代》或《韦诺之战》，那么第二种选择更好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们使用速度24，因此我们选择第二种方法。</font><font style="vertical-align: inherit;">为了使其开始工作，我们需要在将其添加到当前距离之前隔离进入下一个单元的成本。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int distance = current.Distance; int moveCost; if (current.HasRoadThroughEdge(d)) { moveCost = 1; } else if (current.Walled != neighbor.Walled) { continue; } else { moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } int distance = current.Distance + moveCost; int turn = distance / speed;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，如果我们越过了移动的边界，那么首先我们将使用当前移动的所有移动点。</font><font style="vertical-align: inherit;">我们可以通过简单地将移动乘以速度来实现。</font><font style="vertical-align: inherit;">在那之后，我们增加了搬家的成本。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们将在第四个单元格中使用4个未使用的移动点来完成第一步移动。</font><font style="vertical-align: inherit;">这些丢失的点被添加到第五个像元的成本中，因此它的距离变为29，而不是25。因此，该距离比以前更大。</font><font style="vertical-align: inherit;">例如，第十个单元格的距离为50。但是现在进入该单元格，我们需要越过两个动作的边界，失去8个运动点，也就是说，到它的距离现在变为58。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/7f4/1f1/ff37f41f11c85f7f759367fd2b33334d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超出预期的时间</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于未使用的移动点被添加到到像元的距离中，因此在确定最短路径时要考虑它们。</font><font style="vertical-align: inherit;">最有效的方法是浪费尽可能少的分数。</font><font style="vertical-align: inherit;">因此，以不同的速度，我们可以获得不同的路径。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 显示移动而不是距离 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在玩游戏时，我们对用于查找最短路径的距离值并不十分感兴趣。</font><font style="vertical-align: inherit;">我们对达到终点所需的移动次数感兴趣。</font><font style="vertical-align: inherit;">因此，让我们显示移动而不是距离。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，摆脱</font></font><code>UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他的电话</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// UpdateDistanceLabel(); } } … // void UpdateDistanceLabel () { // UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); // label.text = distance == int.MaxValue ? "" : distance.ToString(); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相反，我们将添加到</font><font style="vertical-align: inherit;">接收任意字符串</font><font style="vertical-align: inherit;">的</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规方法</font></font><code>SetLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = text; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用这种新方法</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清洁细胞。</font><font style="vertical-align: inherit;">要隐藏单元格，只需为其分配</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); cells[i].DisableHighlight(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们为邻居的标记分配其移动的值。</font><font style="vertical-align: inherit;">之后，我们将能够看到一路走下去还需要多少额外的动作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/6d6/97d/0d46d697d7c08be6d3381ce030541e4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿</font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">unitypackage </font></a><i><font style="vertical-align: inherit;">路径移动所需的移动</font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次数</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 即时路径 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，在玩游戏时，我们不在乎路径搜索算法如何找到方式。</font><font style="vertical-align: inherit;">我们希望立即看到请求的路径。</font><font style="vertical-align: inherit;">目前，我们可以确定该算法有效，因此让我们摆脱搜索可视化的困扰。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 没有corutin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了让算法缓慢通过，我们使用了Corutin。</font><font style="vertical-align: inherit;">我们不再需要这样做，因此我们将摆脱通话</font></font><code>StartCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>StopAllCoroutines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c的困扰</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">相反，我们只是将其</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为常规方法</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// StopAllCoroutines(); … } public void FindPath (HexCell fromCell, HexCell toCell, int speed) { // StopAllCoroutines(); // StartCoroutine(Search(fromCell, toCell, speed)); Search(fromCell, toCell, speed); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们不再将其</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用作协程，因此不需要产量，因此我们将摆脱此运算符。</font><font style="vertical-align: inherit;">这意味着我们还将删除声明</font></font><code>WaitForSeconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并将方法的返回类型更改为</font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// WaitForSeconds delay = new WaitForSeconds(1 / 60f); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { // yield return delay; HexCell current = searchFrontier.Dequeue(); … } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即时结果</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 搜索时间定义 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以立即获取路径，但是它们的计算速度有多快？短路径几乎立即出现，但是大地图上的长路径似乎有点慢。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们测量一下查找和显示路径需要花费多少时间。我们可以使用事件探查器来确定搜索时间，但这有点过多，并且会产生额外的费用。让我们改用</font></font><code>Stopwatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命名空间中的</font></font><code>System.Diagnostics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于我们只是暂时使用它，因此我不会将构造添加</font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到脚本的开头。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在搜索之前，创建一个新的秒表并启动它。搜索完成后，停止秒表并在控制台中显示经过的时间。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们为算法选择最坏的情况-从大地图的左下角到右上角进行搜索。最糟糕的是统一地图，因为该算法将必须处理所有4,800个地图单​​元。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/c03/524/ce1c0352479d7d8cddcff0b014291662.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最坏的情况下进行</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">搜索搜索所花费</font><i><font style="vertical-align: inherit;">的时间</font></i><font style="vertical-align: inherit;">可能会有所不同，因为Unity编辑器不是计算机上唯一运行的进程。因此，请对其进行多次测试以了解平均持续时间。以我为例，搜索大约需要45毫秒。这不是很多，相当于每秒22.22条路径。表示为22 pps（每秒路径数）。这意味着在计算此路径时，该帧中游戏的帧速率也将最大降低22 fps。而且这没有考虑其他所有工作，例如渲染框架本身。也就是说，我们得到了相当大的帧率降低，它将降至20 fps。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在执行这种性能测试时，您需要考虑到Unity编辑器的性能将不如最终应用程序的性能高。</font><font style="vertical-align: inherit;">如果我对装配体执行相同的测试，则平均只需15毫秒。</font><font style="vertical-align: inherit;">那是66 pps，这要好得多。</font><font style="vertical-align: inherit;">不过，这仍然是每帧分配的资源的很大一部分，因此帧速率将低于60 fps。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在哪里可以看到程序集的调试日志？</font></font></b> <div class="spoiler_text">  Unity     ,    .     .  ,       ,   Unity  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Log Files</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 仅在必要时搜索。 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以进行简单的优化-仅在需要时执行搜索。</font><font style="vertical-align: inherit;">在我们按住鼠标按钮的每个帧中启动新搜索时。</font><font style="vertical-align: inherit;">因此，拖放时的帧频将不断被低估。</font><font style="vertical-align: inherit;">通过</font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在我们真正在处理新端点时才</font><font style="vertical-align: inherit;">启动新搜索，可以避免这种情况</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果不是，则当前可见路径仍然有效。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 仅显示路径标签 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示旅行标记是一项相当昂贵的操作，尤其是因为我们使用了未优化的方法。</font><font style="vertical-align: inherit;">对所有单元执行此操作肯定会减慢执行速度。</font><font style="vertical-align: inherit;">因此，让我们跳过中的标签</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; <span class="hljs-comment"><span class="hljs-comment">// neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们只需要为找到的路径查看此信息。</font><font style="vertical-align: inherit;">因此，到达终点后，我们将计算路线并仅为途中的那些单元格设置标签。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/f8f/2f1/090f8f2f121b6fafdb7b95d48fb41c8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅显示路径单元的标签</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们仅在开始和结束之间包括单元标签。</font><font style="vertical-align: inherit;">但是终点是最重要的，我们还必须为其设置标签。</font><font style="vertical-align: inherit;">您可以通过从目标单元格而不是从其前面的单元格开始路径循环来做到这一点。</font><font style="vertical-align: inherit;">在这种情况下，端点的照明将从红色变为白色，因此在循环过程中我们将消除其背光。</font></font><br><br><pre> <code class="cs hljs"> fromCell.EnableHighlight(Color.blue); <span class="hljs-comment"><span class="hljs-comment">// toCell.EnableHighlight(Color.red); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); if (current == toCell) { // current = current.PathFrom; while (current != fromCell) { int turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } toCell.EnableHighlight(Color.red); break; } … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/273/ea9/dda273ea9b4aa1767db16c19abf512cd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进度信息对于端点而言最重要，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些更改之后，最坏情况的时间在编辑器中减少为23毫秒，在完成的装配体中减少为6毫秒。</font><font style="vertical-align: inherit;">这些分别是43 pps和166 pps-更好。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最聪明的搜索 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上一部分中，我们通过实现A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法使搜索过程更智能</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，实际上，我们仍未以最佳方式执行搜索。</font><font style="vertical-align: inherit;">在每次迭代中，我们计算从当前像元到其所有邻居的距离。</font><font style="vertical-align: inherit;">对于尚未或当前属于搜索边界的单元格，这是正确的。</font><font style="vertical-align: inherit;">但是，已经不再需要从边界中删除的像元了，因为我们已经找到了通往这些像元的最短路径。</font><font style="vertical-align: inherit;">A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确实现会</font><font style="vertical-align: inherit;">跳过这些单元格，因此我们可以执行相同的操作。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 小区搜索阶段 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们如何知道一个牢房是否已经离开边界？</font><font style="vertical-align: inherit;">虽然我们无法确定这一点。</font><font style="vertical-align: inherit;">因此，您需要跟踪单元格处于搜索的哪个阶段。</font><font style="vertical-align: inherit;">她尚未去过边界，或者现在已经在边界，或者在国外。</font><font style="vertical-align: inherit;">我们可以通过添加一个</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单的integer属性</font><font style="vertical-align: inherit;">来对此进行跟踪</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPhase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 例如，0表示尚未到达单元格，1表示该单元格现在处于边界，2表示已从边界中删除。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 击中边界 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其中，</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以将所有单元格重置为0，并始终使用1作为边框。</font><font style="vertical-align: inherit;">或者，我们可以在每次进行新搜索时增加边界数量。</font><font style="vertical-align: inherit;">因此，如果每次将边界数量增加两个，我们将不必处理单元格的转储。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们需要在将单元格添加到边界时设置单元格搜索的阶段。</font><font style="vertical-align: inherit;">该过程从初始单元格开始，然后将其添加到边界。</font></font><br><br><pre> <code class="cs hljs"> fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 而且每次我们向边界添加邻居时。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 边境检查 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，为验证尚未将单元格添加到边界，我们使用了等于的距离</font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，我们可以将单元格搜索的阶段与当前边界进行比较。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// if (neighbor.Distance == int.MaxValue) { if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这意味着我们不再需要在搜索之前重置像元距离，也就是说，我们将需要做的工作更少，这很好。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// cells[i].Distance = int.MaxValue; cells[i].SetLabel(null); cells[i].DisableHighlight(); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 离开边界 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当一个单元格从边界中移出时，我们通过增加其搜索阶段来表示这一点。</font><font style="vertical-align: inherit;">这使她超出了当前边界，处于下一个边界之前。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在我们可以跳过从边界删除的像元，从而避免了无意义的计算和距离比较。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一点上，我们的算法仍然产生相同的结果，但是效率更高。</font><font style="vertical-align: inherit;">在我的机器上，最坏情况下的搜索在编辑器中花费20毫秒，而程序集中花费5毫秒。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还可以计算该算法处理了单元格的次数，从而在计算到单元格的距离时增加了计数器。</font><font style="vertical-align: inherit;">以前，在最坏的情况下，我们的算法计算出28,239个距离。</font><font style="vertical-align: inherit;">在现成的A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法中，</font><font style="vertical-align: inherit;">我们计算出它的14120距离。</font><font style="vertical-align: inherit;">数量减少了50％。</font><font style="vertical-align: inherit;">这些指标对生产率的影响程度取决于计算搬迁成本时的成本。</font><font style="vertical-align: inherit;">在我们的例子中，这里的工作量不大，因此装配的改进不是很大，但是在编辑器中却非常明显。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 扫清道路 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动新搜索时，我们首先需要清除先前路径的可视化。</font><font style="vertical-align: inherit;">在执行此操作时，请关闭选择并从每个网格单元中删除标签。</font><font style="vertical-align: inherit;">这是一个非常困难的方法。</font><font style="vertical-align: inherit;">理想情况下，我们只需要丢弃属于先前路径的那些单元。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 仅搜索 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们首先从中完全删除可视化代码</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他只需要执行路径搜索，而不必知道我们将如何处理此信息。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // cells[i].SetLabel(null); // cells[i].DisableHighlight(); // } // fromCell.EnableHighlight(Color.blue); fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += 1; if (current == toCell) { // while (current != fromCell) { // int turn = current.Distance / speed; // current.SetLabel(turn.ToString()); // current.EnableHighlight(Color.white); // current = current.PathFrom; // } // toCell.EnableHighlight(Color.red); // break; } … } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了报告</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们找到了一种方法，我们将返回布尔值。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } … } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 记住方式 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到路径后，我们需要记住它。</font><font style="vertical-align: inherit;">因此，将来我们将能够对其进行清洁。</font><font style="vertical-align: inherit;">因此，我们将跟踪端点以及端点之间是否存在路径。</font></font><br><br><pre> <code class="cs hljs"> HexCell currentPathFrom, currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentPathExists; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 再次显示路径 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用记录的搜索数据再次可视化路径。</font><font style="vertical-align: inherit;">让我们为此创建一个新方法</font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它将从路径的末端到路径的起​​点进行遍历，突出显示单元格并将笔划值分配给它们的标签。</font><font style="vertical-align: inherit;">为此，我们需要知道速度，因此将其设置为参数。</font><font style="vertical-align: inherit;">如果我们没有路径，则该方法只需选择端点即可。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } } currentPathFrom.EnableHighlight(Color.blue); currentPathTo.EnableHighlight(Color.red); }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">搜索后</font><font style="vertical-align: inherit;">调用此方法</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 扫一扫 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们再次看到了这条路，但是现在它并没有消失。</font><font style="vertical-align: inherit;">要清除它，请创建一个method </font></font><code>ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际上，它是一个副本</font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，除了它禁用选择和标签，但不包括它们。</font><font style="vertical-align: inherit;">完成此操作后，他必须清除已不再有效的记录路径数据。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { current.SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); current.DisableHighlight(); current = current.PathFrom; } current.DisableHighlight(); currentPathExists = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } currentPathFrom = currentPathTo = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此方法，我们可以通过仅访问必需的单元格来清除旧路径的可视化，地图的大小不再重要。</font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开始新搜索之前，</font><font style="vertical-align: inherit;">我们会先调用它</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { ShowPath(speed); } sw.Stop();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此外，我们将在创建新地图时清除路径。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 并且在加载另一张卡之前。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与更改之前一样，再次清除路径可视化。</font><font style="vertical-align: inherit;">但是现在我们正在使用一种更有效的方法，并且在最坏的搜索情况下，时间已减少到14毫秒。</font><font style="vertical-align: inherit;">仅由于更智能的清洁，才有足够的改进。</font><font style="vertical-align: inherit;">组装时间降至3 ms，即333 pps。</font><font style="vertical-align: inherit;">因此，搜索路径是完全实时的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们已经快速搜索了路径，我们可以删除临时调试代码。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); // sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed); // sw.Stop(); // Debug.Log(sw.ElapsedMilliseconds); }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第18部分：单元 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将小队放置在地图上。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存并加载小队。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们找到部队的方法。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们移动单位。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，我们已经找到了搜索路径的方法，让我们将小队放置在地图上。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/881/316/9bb/8813169bb32795f4ea1d0c4696fddde2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">援军到达</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 建立小队 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们只处理了单元格及其固定对象。</font><font style="vertical-align: inherit;">单位与它们的区别在于它们是可移动的。</font><font style="vertical-align: inherit;">小队可以指任何规模的事物，从一个人或一个交通工具到整个军队。</font><font style="vertical-align: inherit;">在本教程中，我们将自己限制为简单的通用单元类型。</font><font style="vertical-align: inherit;">之后，我们将继续支持多种类型的单元的组合。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预制小队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用小队，请创建一种新型的component </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，让我们从一个空的开始</font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后为它添加功能。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此组件创建一个空的游戏对象，该对象应该成为预制的。</font><font style="vertical-align: inherit;">这将是小队的根对象。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8de/c85/2f2/8dec852f21d7aaa2c3002dc119d890ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制小队。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将象征该分离的3D模型添加为子对象。</font><font style="vertical-align: inherit;">我使用了一个简单的缩放立方体，并为其创建了蓝色材质。</font><font style="vertical-align: inherit;">根对象决定了分离的地面水平，因此，我们相应地移动了子元素。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子多维数据集元素</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向小队添加一个对撞机，以便将来更容易选择。</font><font style="vertical-align: inherit;">标准立方体的对撞机非常适合我们，只需使对撞机适合一个单元即可。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建小队实例 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们还没有游戏性，因此单位的创建在编辑模式下进行。</font><font style="vertical-align: inherit;">因此，这应该解决</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此，他需要一个预制件，因此添加一个字段</font></font><code>HexUnit unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并连接它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b00/4bd/85cb004bd7bae06a6feaa8c93f144de9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接预制件</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建单元时，我们将其放置在光标下方的单元格上。</font><font style="vertical-align: inherit;">有</font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个用于在编辑地形时查找此单元格的代码。</font><font style="vertical-align: inherit;">现在，小队也需要它，因此我们将相应的代码移至单独的方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以使用此方法来</font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); // RaycastHit hit; // if (Physics.Raycast(inputRay, out hit)) { // HexCell currentCell = hexGrid.GetCell(hit.point); HexCell currentCell = GetCellUnderCursor(); if (currentCell) { … } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，添加一个</font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也使用</font><font style="vertical-align: inherit;">的新方法</font></font><code>GetCellUnderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果有一个小室，我们将创建一个新的小队。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { Instantiate(unitPrefab); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了保持层次结构整洁，让我们将网格用作班组中所有游戏对象的父级。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对创建单元的支持</font><font style="vertical-align: inherit;">的最简单方法</font><font style="vertical-align: inherit;">是按一个键。</font><font style="vertical-align: inherit;">更改方法</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使其</font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在按U键时</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">，与c一样</font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果光标不在GUI元素上方，则应发生这种情况。</font><font style="vertical-align: inherit;">首先，我们将检查是否应编辑地图，否则，将检查是否应添加小队。</font><font style="vertical-align: inherit;">如果是这样，请致电</font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// if ( // Input.GetMouseButton(0) &amp;&amp; // !EventSystem.current.IsPointerOverGameObject() // ) { // HandleInput(); // } // else { // previousCell = null; // } if (!EventSystem.current.IsPointerOverGameObject()) { if (Input.GetMouseButton(0)) { HandleInput(); return; } if (Input.GetKeyDown(KeyCode.U)) { CreateUnit(); return; } } previousCell = null; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55e/b48/c86/55eb48c8601711d74720f29cfba7a4f3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建小队的实例</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 部队安置 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以创建单位，但它们会出现在地图的原点。</font><font style="vertical-align: inherit;">我们需要将它们放在正确的位置。</font><font style="vertical-align: inherit;">为此，有必要让部队知道他们的位置。</font><font style="vertical-align: inherit;">因此，我们添加了</font><font style="vertical-align: inherit;">表示它们所占据的单元格</font><font style="vertical-align: inherit;">的</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">设置属性时，我们将更改小队的位置，以使其与单元格的位置匹配。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } } HexCell location;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我</font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须指定小队在光标下方的位置。</font><font style="vertical-align: inherit;">然后单位将在应有的位置。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/71f/92d/bf671f92d2e587bebec2bf08efafadbc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图上的小队</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单元方向 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，所有单元都具有相同的方向，这看起来很不自然。</font><font style="vertical-align: inherit;">要恢复它们，请添加到</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性中</font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个浮点值，指示小队沿着Y轴以度为单位的旋转。</font><font style="vertical-align: inherit;">设置它时，我们将相应地更改游戏对象本身的旋转。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Orientation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { orientation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从0到360度分配随机的旋转。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/c4a/8c9/74fc4a8c943830b4abd6049889b41843.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的单位方向</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 每个小队一小队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果未在一个单元中创建单位，则它们看起来会很好。</font><font style="vertical-align: inherit;">在这种情况下，我们得到了一组看起来很奇怪的立方体。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/a68/4b6/9f8a684b6425be20e23ac65901bf5888.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叠加单元</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有些游戏允许将多个单元放置在一个位置，而其他游戏则不允许。</font><font style="vertical-align: inherit;">由于每个单元只需要一个小队，因此我将选择此选项。</font><font style="vertical-align: inherit;">这意味着仅当当前单元未被占用时，我们才应该创建一个新的小队。</font><font style="vertical-align: inherit;">这样您可以找出并添加到</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standard属性</font></font><code>Unit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit Unit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用此属性</font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来让单元格知道单元是否在其上。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，它</font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以检查当前单元是否空闲。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { HexUnit unit = Instantiate(unitPrefab); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编辑繁忙的单元格 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初，单元放置正确，但是如果以后对其单元格进行编辑，一切都会改变。</font><font style="vertical-align: inherit;">如果单元格的高度发生变化，则占据该单元格的单元将悬挂在其上方或陷入其中。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/b7d/1c1/27bb7d1c120bc1546dfa0fd42823d66c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悬吊和溺水的小队</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案是在进行更改后检查小队的位置。</font><font style="vertical-align: inherit;">为此，将方法添加到</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">到目前为止，我们只对小队的位置感兴趣，所以再问一遍。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateLocation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition = location.Position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新单元格时，我们必须协调分离的位置，当</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">方法</font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">时会发生什么</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当然，仅当单元中确实存在分离时才需要这样做。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 去除小队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了创建单位之外，销毁它们也会很有用。</font><font style="vertical-align: inherit;">因此，添加到</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他必须检查光标下方的单元格中是否存在分离，如果存在，则销毁分离的游戏对象。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { Destroy(cell.Unit.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，要进入小队，我们要经过牢房。</font><font style="vertical-align: inherit;">要与小队互动，只需将鼠标移到其单元上方。</font><font style="vertical-align: inherit;">因此，要使其正常工作，小队不必有对撞机。</font><font style="vertical-align: inherit;">但是，添加对撞机使它们更易于选择，因为它会阻挡否则会与班组后面的单元碰撞的光线。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结合使用Shift + U </font><font style="vertical-align: inherit;">销毁小队</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { DestroyUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CreateUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在创建和销毁多个单元的情况下，请小心并在删除单元时清除属性。</font><font style="vertical-align: inherit;">也就是说，我们明确清除了到小队的单元链接。</font><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">用于处理此问题</font><font style="vertical-align: inherit;">的</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>Die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及销毁自己的游戏对象。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在中调用此方法</font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是直接销毁小队。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// Destroy(cell.Unit.gameObject); cell.Unit.Die(); } }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存和加载小队 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以在地图上显示单位了，我们必须将它们包括在保存和加载过程中。</font><font style="vertical-align: inherit;">我们可以通过两种方式处理此任务。</font><font style="vertical-align: inherit;">第一种是在记录单元时记录小队数据，以便将单元和小队数据混合。</font><font style="vertical-align: inherit;">第二种方法是分别保存像元和小队数据。</font><font style="vertical-align: inherit;">尽管第一种方法似乎更容易实现，但是第二种方法为我们提供了更多的结构化数据。</font><font style="vertical-align: inherit;">如果我们共享数据，那么将来与他们合作将更加容易。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单位追踪 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使所有单元保持在一起，我们需要对其进行跟踪。</font><font style="vertical-align: inherit;">我们将通过添加到</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单位列表</font><font style="vertical-align: inherit;">来完成此操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此列表应包含地图上的所有单位。</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexUnit&gt; units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexUnit&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在创建或加载新地图时，我们需要摆脱地图上的所有单位。</font><font style="vertical-align: inherit;">为了简化此过程，请创建一种方法</font></font><code>ClearUnits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该方法</font><font style="vertical-align: inherit;">将杀死列表中的每个人并将其清除。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearUnits</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Die(); } units.Clear(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在</font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和中</font><font style="vertical-align: inherit;">调用此方法</font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们在清理道路后再做。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … ClearPath(); ClearUnits(); … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将小队添加到网格 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在创建新单位时，我们需要将它们添加到列表中。</font><font style="vertical-align: inherit;">让我们为此设置一个方法，该方法</font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还将处理小队的位置及其父对象的参数。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font></font><code>HexMapEditor.CreatUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，调用</font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个新的分离实例，其位置和随机方向</font><font style="vertical-align: inherit;">就足够了</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// HexUnit unit = Instantiate(unitPrefab); // unit.transform.SetParent(hexGrid.transform, false); // unit.Location = cell; // unit.Orientation = Random.Range(0f, 360f); hexGrid.AddUnit( Instantiate(unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从网格删除小队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加一种方法来删除小队和c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">只需从列表中删除小队并命令其死亡即可。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { units.Remove(unit); unit.Die(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在中调用此方法</font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是直接销毁小队。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// cell.Unit.Die(); hexGrid.RemoveUnit(cell.Unit); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存单位 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们将所有单元放在一起，因此我们需要记住它们占据了哪些单元格。</font><font style="vertical-align: inherit;">最可靠的方法是保存其位置的坐标。</font><font style="vertical-align: inherit;">为了使之成为可能，我们将</font><font style="vertical-align: inherit;">字段X和Z </font><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">编写它</font><font style="vertical-align: inherit;">的</font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(x); writer.Write(z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在可以记录单元的坐标和方向。</font><font style="vertical-align: inherit;">这是我们目前拥有的所有单位数据。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { location.coordinates.Save(writer); writer.Write(orientation); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于它</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪单位，因此其方法</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将记录单位数据。</font><font style="vertical-align: inherit;">首先，记下单位总数，然后循环遍历所有单位。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } writer.Write(units.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们更改了存储的数据，因此将版本号</font></font><code>SaveLoadMenu.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加到2。旧的引导代码仍然可以使用，因为它根本不会读取小队数据。</font><font style="vertical-align: inherit;">但是，您需要增加版本号以指示文件中包含单元信息。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">2</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 装小队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于它</font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种结构，因此向其中添加常规方法没有多大意义</font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们使其成为一个静态方法，该方法读取并返回存储的坐标。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates c; cx = reader.ReadInt32(); cz = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于单位数量是可变的，因此我们没有可以将数据加载到其中的预先存在的单位。</font><font style="vertical-align: inherit;">我们可以在加载单元数据之前创建新的单元实例，但这将要求我们</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在启动时创建新单元的实例。</font><font style="vertical-align: inherit;">所以最好离开它</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们还使用静态方法</font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们从简单阅读这些小队开始。</font><font style="vertical-align: inherit;">为了读取方向浮点的值，我们使用方法</font></font><code>BinaryReader.ReadSingle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么单身？</font></font></b> <div class="spoiler_text">  <code>float</code>        ,     .     ,   <code>double</code> ,     .  Unity   . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步是创建新小队的实例。</font><font style="vertical-align: inherit;">但是，为此，我们需要一个链接到设备的预制件。</font><font style="vertical-align: inherit;">为了不使其复杂化，我们为此添加一个</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静态方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexUnit unitPrefab;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要设置此链接，请像使用</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">噪声纹理一样</font><font style="vertical-align: inherit;">再次使用它</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当我们需要支持多种类型的单元时，我们将继续寻求更好的解决方案。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; CreateMap(cellCountX, cellCountZ); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/e2e/9c0/251e2e9c0e0f9ec8c6da0a0a7bce6f85.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过了单位的预制件。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在连接场地之后，我们不再需要直接链接到</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">相反，他可以使用</font></font><code>HexUnit.unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public HexUnit unitPrefab; … void CreateUnit () { HexCell cell = GetCellUnderCursor(); if (cell &amp;&amp; !cell.Unit) { hexGrid.AddUnit( Instantiate(HexUnit.unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以在中创建新小队的实例</font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">除了返回它，我们还可以使用加载的坐标和方向将其添加到网格中。</font><font style="vertical-align: inherit;">为此，请添加一个参数</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, HexGrid grid</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); grid.AddUnit( Instantiate(unitPrefab), grid.GetCell(coordinates), orientation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，</font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们计算单位数量并使用它来加载所有存储的单位，并将自身作为附加参数传递。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当然，这仅适用于版本不低于2的保存文件，在较新的版本中，没有要加载的单元。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以正确上传版本2的文件，因此可以</font></font><code>SaveLoadMenu.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将支持的版本数增加到2。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 部队运动 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小队是可移动的，因此我们必须能够在地图上移动小队。</font><font style="vertical-align: inherit;">我们已经有一个路径搜索代码，但是到目前为止，我们仅在任意地方对其进行了测试。</font><font style="vertical-align: inherit;">现在，我们需要删除旧的测试用户界面，并创建新的用户界面以进行小队管理。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 地图编辑器清理 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿路径移动单位是游戏的一部分，不适用于地图编辑器。</font><font style="vertical-align: inherit;">因此，我们将摆脱</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与查找路径相关的所有代码。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// HexCell previousCell, searchFromCell, searchToCell; HexCell previousCell; … void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } if (editMode) { EditCells(currentCell); } // else if ( // Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell // ) { // if (searchFromCell != currentCell) { // if (searchFromCell) { // searchFromCell.DisableHighlight(); // } // searchFromCell = currentCell; // searchFromCell.EnableHighlight(Color.blue); // if (searchToCell) { // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } // } // else if (searchFromCell &amp;&amp; searchFromCell != currentCell) { // if (searchToCell != currentCell) { // searchToCell = currentCell; // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除此代码后，当我们不处于编辑模式时，使编辑器处于活动状态不再有意义。</font><font style="vertical-align: inherit;">因此，代替模式跟踪字段，我们可以简单地启用或禁用component </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，编辑器现在不必处理UI标签。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// bool editMode; … public void SetEditMode (bool toggle) { // editMode = toggle; // hexGrid.ShowUI(!toggle); enabled = toggle; } … void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } // if (editMode) { EditCells(currentCell); // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 由于默认情况下我们不处于地图编辑模式，因此在Awake中我们将禁用编辑器。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑地图和管理单位时，必须使用raycast搜索光标下方的当前单元格。</font><font style="vertical-align: inherit;">也许将来对我们来说还有其他用途。</font><font style="vertical-align: inherit;">让我们将射线投射逻辑从</font><font style="vertical-align: inherit;">具有波束参数</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的新方法</font><font style="vertical-align: inherit;">转移</font><font style="vertical-align: inherit;">到新方法</font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> <code>HexMapEditor.GetCellUniderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可能只是用光标束调用此方法。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏界面 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了控制游戏模式的用户界面，我们将使用一个新组件。</font><font style="vertical-align: inherit;">而他只会处理单位的选择和移动。</font><font style="vertical-align: inherit;">为它创建一个新的组件类型</font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要完成他的工作，对他来说，到网格的链接就足够了。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGameUI</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将此组件添加到UI层次结构中的新游戏对象。</font><font style="vertical-align: inherit;">他不必拥有自己的对象，但是对我们来说，很明显，游戏有单独的UI。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/515/769/bdd/515769bdd0b6fbee9cb8451348595a57.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b3/b7c/0d7/9b3b7c0d719d05862a76ba8e70409970.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏UI对象</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如中所示</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当我们不处于编辑模式时，应打开游戏UI。</font><font style="vertical-align: inherit;">另外，由于游戏UI可以使用路径，因此此处需要包含标签。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在编辑模式开关的事件列表中添加游戏UI方法。</font><font style="vertical-align: inherit;">这意味着当播放器更改模式时，将同时调用这两种方法。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92b/dde/778/92bdde778bfc97ae4b5bdc1d49a2bb6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 几种事件方法。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 跟踪当前单元格 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据情况，</font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要知道光标当前位于哪个单元格下。</font><font style="vertical-align: inherit;">因此，我们向其添加一个字段</font></font><code>currentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> HexCell currentCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个</font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游标束更新此字段的方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { currentCell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新当前单元格时，我们可能需要找出它是否已更改。</font><font style="vertical-align: inherit;">强制</font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回此信息。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != currentCell) { currentCell = cell; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单位选择 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在移动小队之前，必须对其进行选择和跟踪。</font><font style="vertical-align: inherit;">因此，添加一个字段</font></font><code>selectedUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> HexUnit selectedUnit;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们尝试进行选择时，我们需要先更新当前单元格。</font><font style="vertical-align: inherit;">如果当前单元是当前单元，则占据该单元的单元将成为所选单元。</font><font style="vertical-align: inherit;">如果单元格中没有单位，则不会选择任何单位。</font><font style="vertical-align: inherit;">让我们为此创建一个方法</font></font><code>DoSelection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只需单击鼠标，即可实现单位的​​选择。</font><font style="vertical-align: inherit;">因此，我们添加了一种</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在激活鼠标按钮时进行选择</font><font style="vertical-align: inherit;">的方法</font><font style="vertical-align: inherit;">，当然，仅当光标不在GUI元素上方时才需要执行该选择。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此阶段，我们学习了如何通过单击鼠标一次选择一个单位。</font><font style="vertical-align: inherit;">当您单击一个空单元格时，将删除任何单位的选择。</font><font style="vertical-align: inherit;">但是，尽管我们没有对此进行任何视觉确认。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 小队搜寻 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择一个单位后，我们可以将其位置用作寻找路径的起点。</font><font style="vertical-align: inherit;">要激活它，我们不需要再次单击鼠标按钮。</font><font style="vertical-align: inherit;">相反，我们将自动查找并显示小队位置与当前像元之间的路径。</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除非做出选择，否则</font><font style="vertical-align: inherit;">我们将始终在中执行此操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此，当我们有一个分队时，我们调用method </font></font><code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { DoPathfinding(); } } }</code> </pre> <br> <code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是更新当前单元格，</font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有端点则</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们再次使用24的恒定速度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 请注意，我们不应在每次更新时都找到新路径，而应仅在当前单元格更改时才能找到新路径。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/8d1/ce9/39f8d1ce9040ae5370fd12f447ecd8e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找小队</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的路径现在，我们看到选择小队后移动光标时出现的路径。</font><font style="vertical-align: inherit;">因此，很明显选择了哪个单位。</font><font style="vertical-align: inherit;">但是，并非总是正确清除路径。</font><font style="vertical-align: inherit;">首先，如果光标在地图外，让我们清除旧路径。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，这要求它</font></font><code>HexGrid.ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是通用的，因此我们进行了这样的更改。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其次，在选择一个分队时，我们将清除旧的路径。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { grid.ClearPath(); UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最后，我们将在更改编辑模式时清除路径。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 仅搜索有效端点 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不能总是找到方法，因为有时不可能到达最终单元。</font><font style="vertical-align: inherit;">这很正常。</font><font style="vertical-align: inherit;">但是有时最终的单元格本身是不能接受的。</font><font style="vertical-align: inherit;">例如，我们决定路径不能包含水下细胞。</font><font style="vertical-align: inherit;">但这可能取决于单位。</font><font style="vertical-align: inherit;">让我们添加一个</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">告诉我们单元格是否为有效端点的方法。</font><font style="vertical-align: inherit;">水下细胞不是。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，我们只允许一个单元站立在牢房中。</font><font style="vertical-align: inherit;">因此，如果最后一个单元繁忙，则它将无效。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用此方法</font></font><code>HexGameUI.DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来忽略无效的端点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 移至终点 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们有一个有效的路径，那么我们就可以将小队移动到终点。</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知道什么时候可以做到。</font><font style="vertical-align: inherit;">我们使它在新的只读属性中传递此信息</font></font><code>HasPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPathExists; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要移动小队，请添加到</font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法中</font></font><code>DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">发出命令并选择单位时将调用此方法。</font><font style="vertical-align: inherit;">因此，他必须检查是否有办法，如果有，请更改分队的位置。</font><font style="vertical-align: inherit;">当我们立即将小队传送到终点时。</font><font style="vertical-align: inherit;">在以下教程之一中，我们将使小队一路走好。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { selectedUnit.Location = currentCell; grid.ClearPath(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们使用鼠标按钮1（右键单击）提交命令。</font><font style="vertical-align: inherit;">如果选择了一个分队，我们将进行检查。</font><font style="vertical-align: inherit;">如果未按下按钮，则我们搜索路径。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { DoMove(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DoPathfinding(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以移动单位了！</font><font style="vertical-align: inherit;">但是有时他们拒绝找到通往某些牢房的方法。</font><font style="vertical-align: inherit;">特别地，对于过去曾经脱离的那些细胞。</font><font style="vertical-align: inherit;">发生这种情况是因为</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在设置新位置时，</font><font style="vertical-align: inherit;">它</font><font style="vertical-align: inherit;">不会更新旧位置。</font><font style="vertical-align: inherit;">要解决此问题，我们将清除到该小队旧位置的链接。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免小队 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在找到正确的方法，单位可以在地图上传送。</font><font style="vertical-align: inherit;">尽管它们无法移动到已经有小队的牢房，但妨碍前进的支队将被忽略。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/3d8/7dd/5193d87dd25bfa2fbc9e0ba26529b926.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在途中忽略部队</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一派小队通常可以互相移动，但到目前为止，我们还没有派系。</font><font style="vertical-align: inherit;">因此，让我们将所有单元视为彼此断开连接并阻塞路径。</font><font style="vertical-align: inherit;">这可以通过跳过中的繁忙单元来实现</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater || neighbor.Unit) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3c/f3b/698/f3cf3b698191010f55c0c994d3e324d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避免分队</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第19部分：动作动画 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在单元之间移动单位。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可视化行进的路径。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们沿着曲线移动部队。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们强迫部队朝行动方向看。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这一部分中，我们将迫使单位而不是隐形传送沿着轨道移动。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a08/e41/a4f/a08e41a4fd0e90ea26dc11f16ff518f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小队在路上</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一路走来 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上一部分中，我们添加了单位以及移动单位的功能。</font><font style="vertical-align: inherit;">尽管我们使用搜索路径来确定有效端点，但是在发出命令后，部队只是简单地传送到了最后一个牢房。</font><font style="vertical-align: inherit;">为了使他们实际上遵循找到的路径，我们需要跟踪此路径并创建一个动画过程，以迫使小队在一个单元之间移动。</font><font style="vertical-align: inherit;">由于查看动画很难注意到小队的运动方式，因此我们还可以在小控件的帮助下可视化行进路径。</font><font style="vertical-align: inherit;">但是在继续之前，我们需要修复错误。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 转弯错误 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于疏忽，我们错误地计算了到达该单元格的路线。</font><font style="vertical-align: inherit;">现在我们通过将总距离除以小队速度来确定路线</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-5"><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并丢弃其余部分。</font><font style="vertical-align: inherit;">当进入单元格时，您需要精确地花费所有剩余的移动点数，从而发生错误。</font><font style="vertical-align: inherit;">例如，当每个步骤的成本为1，速度为3时，则每转可以移动三个单元。</font><font style="vertical-align: inherit;">但是，使用现有的计算，我们第一步只能采取两个步骤，因为对于第三步</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.407ex" height="2.66ex" viewBox="0 -832 3189.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-73" x="2719" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">t = d / s</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-17"><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-19"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-21"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.254ex" height="2.66ex" viewBox="0 -832 7859.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-73" x="2719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="3466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-33" x="4523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2F" x="5023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-33" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="6302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-31" x="7358" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2">t = d / s = 3 / 3 = 1</script>  。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/9ec/098/d809ec098cac1850cf16d47ce45ed030.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误定义的移动速度3进行移动的总成本</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了正确计算移动，我们需要将边界从初始像元移动一级。</font><font style="vertical-align: inherit;">我们可以通过在计算移动之前将距离减小1来完成此操作，然后第三步的移动将是</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-28"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.686ex" height="2.66ex" viewBox="0 -832 5031.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-32" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2F" x="2196" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-33" x="2696" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="3474" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-30" x="4531" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">t = 2 / 3 = 0</script><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/291/37e/65629137e3267e033d1f5f6d3fd1f724.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的动作</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过将计算公式更改为</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.219ex" height="2.66ex" viewBox="0 -832 5691.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-28" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-64" x="2085" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2212" x="2830" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-31" x="3831" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-29" x="4332" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2F" x="4721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-73" x="5222" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4">t = (d - 1) / s</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将更改为</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; } … } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们还更改了动作的标记。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; … } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意，使用这种方法，初始单元路径为-1。</font><font style="vertical-align: inherit;">这是正常现象，因为我们没有显示它，并且搜索算法仍可运行。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 出路 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿着小路前进是小队的任务。</font><font style="vertical-align: inherit;">为了使他做到这一点，他需要知道方法。</font><font style="vertical-align: inherit;">我们有此信息</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此让我们向其添加一个方法以单元格列表的形式获取当前路径。</font><font style="vertical-align: inherit;">他可以从列表池中获取它，如果确实存在路径，则返回。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentPathExists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过遵循从最后一个单元格到第一个单元格的链接路径来填充列表，就像在可视化路径时所做的那样。 </font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这种情况下，我们需要整个路径，其中包括初始单元格。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } path.Add(currentPathFrom); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了相反的路径。</font><font style="vertical-align: inherit;">我们可以和他一起工作，但这不是很直观。</font><font style="vertical-align: inherit;">让我们翻转列表，使其从头到尾。</font></font><br><br><pre> <code class="cs hljs"> path.Add(currentPathFrom); path.Reverse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运动要求 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以添加该</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法，命令他遵循该路径。</font><font style="vertical-align: inherit;">最初，我们只是让他传送到最后一个牢房。</font><font style="vertical-align: inherit;">我们不会立即将列表返回到池中，因为它对我们一段时间有用。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了请求移动，我们对其进行了更改，</font></font><code>HexGameUI.DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便它使用当前路径调用新方法，而不仅仅是设置单元的位置。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { <span class="hljs-comment"><span class="hljs-comment">// selectedUnit.Location = currentCell; selectedUnit.Travel(grid.GetPath()); grid.ClearPath(); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 路径可视化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开始对小队进行动画处理之前，让我们检查路径是否正确。</font><font style="vertical-align: inherit;">我们将通过命令</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记住它必须沿其移动的路径</font><font style="vertical-align: inherit;">来做到这一点</font><font style="vertical-align: inherit;">，以便可以使用Gizmos将其可视化。</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; pathToTravel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加方法</font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以显示要走的最后一条路径（如果存在）。</font><font style="vertical-align: inherit;">如果单元尚未移动，则路径应相等</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是由于在Play模式下重新编译后在编辑过程中对Unity进行了序列化，因此它也可能是一个空列表。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示路径的最简单方法是为路径的每个单元格绘制一个Gizmo球。</font><font style="vertical-align: inherit;">半径为2个单位的球体适合我们。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pathToTravel.Count; i++) { Gizmos.DrawSphere(pathToTravel[i].Position, <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 由于我们将显示分离的路径，因此我们将能够同时查看其所有最后路径。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/907/a7d/dac907a7da12a75436c7ae26956884bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gizmos将显示最后经过的路径，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了更好地显示单元格的连接，请在先前单元格和当前单元格之间的直线上画出多个球体。</font><font style="vertical-align: inherit;">为此，我们需要从第二个单元格开始该过程。</font><font style="vertical-align: inherit;">可以使用线性插值以0.1个单位的增量来排列球体，这样每段可以得到十个球体。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/46a/11c/5c246a11c0753d03b2572de5bfc297a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更明显的方法</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一路下滑 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用相同的方法移动单位。</font><font style="vertical-align: inherit;">让我们为此创建一个协程。</font><font style="vertical-align: inherit;">代替绘制小控件，我们将设置小队的位置。</font><font style="vertical-align: inherit;">而不是增加，我们将使用0.1时间增量，并且将对每次迭代执行yield。</font><font style="vertical-align: inherit;">在这种情况下，小队将在一秒钟内从一个牢房移动到下一个牢房。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们在方法的最后开始协程</font></font><code>Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是首先，我们将停止所有现有的协程。</font><font style="vertical-align: inherit;">因此，我们保证两个协程不会同时启动，否则会导致非常奇怪的结果。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每秒移动一个单元格非常慢。</font><font style="vertical-align: inherit;">游戏中的玩家不想等待那么久。</font><font style="vertical-align: inherit;">您可以将小队的移动速度作为配置选项，但是现在，让我们使用一个常量。</font><font style="vertical-align: inherit;">我为她分配了每秒4个单元的值；</font><font style="vertical-align: inherit;">它的速度非常快，但请注意发生了什么。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> travelSpeed = <span class="hljs-number"><span class="hljs-number">4f</span></span>; … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如我们可以同时可视化多个路径一样，我们可以使多个单元同时行驶。</font><font style="vertical-align: inherit;">从游戏状态的角度来看，运动仍然是隐形传送，动画是唯一的视觉效果。</font><font style="vertical-align: inherit;">单位立即占据了最后一个牢房。</font><font style="vertical-align: inherit;">您甚至可以找到方法并在它们到达之前开始新的动作。</font><font style="vertical-align: inherit;">在这种情况下，它们将在视觉上传送到新路径的起点。</font><font style="vertical-align: inherit;">可以通过在移动单元时阻止单元甚至整个UI来避免这种情况，但是在开发和测试运动时，这种快速反应非常方便。</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 移动单位。 </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度的差异如何？</font></font></b> <div class="spoiler_text">        ,      .       ,           .        ,    .   ,      .      ,  Endless Legend,   ,         .     ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编译后的位置 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutin的缺点之一是，在Play模式下重新编译时，它们不会“生存”。</font><font style="vertical-align: inherit;">尽管游戏状态始终为真，但如果在移动过程中开始重新编译，这可能会导致小队陷入最后路径的某个位置。</font><font style="vertical-align: inherit;">为了减轻后果，让我们确保在重新编译之后，单元始终处于正确的位置。</font><font style="vertical-align: inherit;">这可以通过更新其在中的位置来完成</font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运动平稳 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从单元的中心到中心的移动看起来过于机械化，并且会导致方向发生急剧变化。</font><font style="vertical-align: inherit;">对于许多游戏来说，这是正常现象，但是如果您至少需要稍微逼真的动作，这是不可接受的。</font><font style="vertical-align: inherit;">因此，让我们更改运动以使其看起来更自然。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从肋骨移到肋骨 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小队从牢房的中心开始旅程。</font><font style="vertical-align: inherit;">它传递到单元格边缘的中间，然后进入下一个单元格。</font><font style="vertical-align: inherit;">他不必直奔中心，而可以直奔他必须越过的下一条边缘。</font><font style="vertical-align: inherit;">实际上，该单元将在需要改变方向时切断路径。</font><font style="vertical-align: inherit;">对于路径终点以外的所有像元，这都是可能的。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8f0/1b9/2bc8f01b93b55b7acab8d9f56dd6f4be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从边缘移动到边缘的三种方法</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们适应</font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">于显示以这种方式生成的路径。</font><font style="vertical-align: inherit;">它必须在单元格的边缘之间进行插值，这可以通过平均相邻单元格的位置来找到。</font><font style="vertical-align: inherit;">对我们来说，每次迭代计算一条边就足够了，重新使用前一次迭代的值。</font><font style="vertical-align: inherit;">因此，我们可以使该方法适用于初始单元格，但是取而代之的是边缘而不是边缘。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += 0.1f) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), 2f); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要到达最终像元的中心，我们需要使用像元位置作为最后一点，而不是边缘。</font><font style="vertical-align: inherit;">您可以将这种情况的验证添加到循环中，但是它是如此简单，以至于简单地复制代码并稍作更改将更加明显。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { … } a = b; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/466/4d4/deb4664d4f8bcffcc3839dddfaa0d792.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于肋的</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径生成的路径不太像之字形，并且最大转弯角度从120°减小到90°。</font><font style="vertical-align: inherit;">可以认为这是一种改进，因此我们在协程中应用了相同的更改，</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以查看其在动画中的外观。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } } a = b; b = pathToTravel[pathToTravel.Count - 1].Position; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以变​​化的速度运动</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切割角度后，路径段的长度取决于方向的变化。</font><font style="vertical-align: inherit;">但是我们将速度设置为每秒细胞数。</font><font style="vertical-align: inherit;">结果，分离速度随机变化。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 跟随曲线 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跨越细胞边界时，方向和速度的瞬时变化看起来很难看。</font><font style="vertical-align: inherit;">最好使用逐渐变化的方向。</font><font style="vertical-align: inherit;">我们可以通过迫使部队遵循曲线而不是直线来增加对此的支持。</font><font style="vertical-align: inherit;">您可以为此使用贝塞尔曲线。</font><font style="vertical-align: inherit;">特别是，我们可以采用二次Bezier曲线，在该曲线处，像元的中心将成为中间控制点。</font><font style="vertical-align: inherit;">在这种情况下，相邻曲线的切线将成为彼此的镜像，即整个路径将变为连续的平滑曲线。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/c46/0b8/a94c460b8e7b3fd2ecc3b4ea4e3225a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从一边到</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另</font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一边的曲线使用一种用于获取二次Bezier曲线上的点的方法来</font><font style="vertical-align: inherit;">创建辅助类</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线和样条线”教程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中所述，公式用于</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></span><span class="MJXp-mn" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-47"><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-49" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A </font></font></span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></span><span class="MJXp-mn" id="MJXp-Span-54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-63" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.208ex" height="2.901ex" viewBox="0 -935.7 12575.6 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2212" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="2112" y="0"></use><g transform="translate(2474,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-32" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-41" x="3317" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2B" x="4290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-32" x="5291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-28" x="5791" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-31" x="6181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2212" x="6904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="7904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-29" x="8266" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="8655" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-42" x="9017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2B" x="9998" y="0"></use><g transform="translate(10999,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-32" x="511" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-43" x="11815" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">(1 - t)^2 A + 2(1 - t) t B + t^2 C</script> 在哪里 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0.25ex" viewBox="0 -53.9 0 107.7" role="img" focusable="false" style="vertical-align: -0.125ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"></g></svg></span><script type="math/tex" id="MathJax-Element-6"> </script>  ， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乙</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-42" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> B </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是控制点，t是插值器。</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8">C</script><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bezier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = <span class="hljs-number"><span class="hljs-number">1f</span></span> - t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * r * a + <span class="hljs-number"><span class="hljs-number">2f</span></span> * r * t * b + t * t * c; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetPoint不应该限制为0-1吗？</font></font></b> <div class="spoiler_text">         0-1,    .          .  ,    <code>GetPointClamped</code> ,    <code>t</code> .      ,      <code>GetPointUnclamped</code> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要显示中的曲线路径</font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们需要跟踪的不是两个点，而是三个点。</font><font style="vertical-align: inherit;">另外一个点是我们在当前迭代中使用的单元格的中心，该中心具有索引</font></font><code>i - 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为周期从1开始。收到所有点后，可以将其替换</font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><code>Bezier.GetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开始和结束单元格中，而不是终点和中点，我们可以简单地使用单元格的中心。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/79d/cae/14079dcae70b7b2522c137e0af848883.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用贝塞尔曲线创建的路径弯曲</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径看起来要好得多。</font><font style="vertical-align: inherit;">我们将相同的更改应用于，</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并查看如何使用这种方法对单元进行动画处理。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们沿着曲线移动</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即使分离速度不稳定，动画也变得流畅。</font><font style="vertical-align: inherit;">由于相邻线段的曲线的切线重合，因此速度是连续的。</font><font style="vertical-align: inherit;">速度的变化是逐渐发生的，并在一个分离物穿过细胞时发生，而在改变方向时则变慢。</font><font style="vertical-align: inherit;">如果他直行，则速度保持恒定。</font><font style="vertical-align: inherit;">此外，班组以零速开始和结束旅程。</font><font style="vertical-align: inherit;">这模仿了自然运动，所以就这样吧。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 时间追踪 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们从0开始对每个段进行迭代，一直持续到达到1。在以恒定值递增时效果很好，但是迭代取决于增量时间。当对一个段的迭代完成时，我们可能会超出1个数量，具体取决于时间增量。在高帧频下这是不可见的，但是在低帧频下会导致抖动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了避免浪费时间，我们需要将剩余时间从一个片段转移到另一个片段。这可以通过</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿整个路径而不是仅在每个段中</font><font style="vertical-align: inherit;">进行跟踪来完成</font><font style="vertical-align: inherit;">。然后，在每个段的末尾，我们将从中减去1。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * traveSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果已经在执行此操作，请确保在路径的开头考虑时间增量。</font><font style="vertical-align: inherit;">这意味着我们将立即开始移动，并且不会闲置一帧。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，我们并没有在路径应该结束的时间点准确地完成，而是在那一刻之前。</font><font style="vertical-align: inherit;">在此，差异还可以取决于帧速率。</font><font style="vertical-align: inherit;">因此，让我们让小队在终点处完全完成路径。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … transform.localPosition = location.Position; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 方向动画 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单位开始沿平滑曲线移动，但它们并未根据移动方向改变方向。</font><font style="vertical-align: inherit;">结果，它们似乎在滑行。</font><font style="vertical-align: inherit;">为了使该运动看起来像真实的运动，我们需要旋转它们。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 展望未来 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就像在“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线和样条线”教程中一样</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以使用曲线的导数来确定单位的方向。</font><font style="vertical-align: inherit;">二次贝塞尔曲线的导数公式：</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-70"><span class="MJXp-mn" id="MJXp-Span-71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-72" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></span><span class="MJXp-mn" id="MJXp-Span-74"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-77" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font></span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mo" id="MJXp-Span-87" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-89" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.64ex" height="2.66ex" viewBox="0 -832 12761.8 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-28" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-31" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2212" x="2002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="3002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-29" x="3364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-28" x="3753" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-42" x="4143" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2212" x="5125" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-41" x="6125" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-29" x="6876" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2B" x="7488" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="8488" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-28" x="8850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-43" x="9239" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-2212" x="10222" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-42" x="11223" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-29" x="11982" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-29" x="12372" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9">2 ((1 - t) (B - A) + t (C - B))</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到</font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法来计算它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDerivative</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2f</span></span> * ((<span class="hljs-number"><span class="hljs-number">1f</span></span> - t) * (b - a) + t * (c - b)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导数向量位于运动方向的一条直线上。</font><font style="vertical-align: inherit;">我们可以使用该方法</font></font><code>Quaternion.LookRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将其转换为小队转弯。</font><font style="vertical-align: inherit;">我们将在每一步中执行它</font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; … transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径的开头没有错误吗？</font></font></b> <div class="spoiler_text">    ,        .    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0.285ex" viewBox="0 -61.3 0 122.5" role="img" focusable="false" style="vertical-align: -0.142ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"></g></svg></span><script type="math/tex" id="MathJax-Element-10"> </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">B</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.074ex" viewBox="0 -772.3 759.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-42" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11"> B </script>  ,    .   ,   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">t</span><span class="MJXp-mo" id="MJXp-Span-96" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-97">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.101ex" height="2.074ex" viewBox="0 -772.3 2196.1 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhi-e6PZnmVzWXGRQ0p08VlXvOXgOQ#MJMAIN-30" x="1695" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-12">t = 0</script> ,     ,      <code>Quaternion.LookRotation</code> .  ,    ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">t</span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-101">0</span></span></span><script type="math/tex" id="MathJax-Element-13">t = 0</script>   .     .       ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">t</span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-105">0</span></span></span><script type="math/tex" id="MathJax-Element-14">t > 0</script>    . <br>         ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">t</span><span class="MJXp-mo" id="MJXp-Span-108" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mn" id="MJXp-Span-109">1</span></span></span><script type="math/tex" id="MathJax-Element-15">t < 1</script>  。 </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与分离的位置相反，在路径末端的非理想定向并不重要。</font><font style="vertical-align: inherit;">但是，我们需要确保其方向与最终旋转相对应。</font><font style="vertical-align: inherit;">为此，完成后，我们将其方向等同于其在Y中的旋转。</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = location.Position; orientation = transform.localRotation.eulerAngles.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，这些单元正好在水平和垂直移动方向上看。</font><font style="vertical-align: inherit;">这意味着它们会向前和向后倾斜，从斜坡上下降并爬上它们。</font><font style="vertical-align: inherit;">为了确保它们始终笔直，我们在使用方向矢量的分量Y来确定其旋转单位之前将其强制为零。</font></font><br><br><pre> <code class="cs hljs"> Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); … Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展望未来</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们来看重点 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在整个路径中，单位都在向前看，但是在开始移动之前，它们可以朝另一个方向看。在这种情况下，他们会立即改变方向。如果它们在运动开始之前朝着路径的方向转动会更好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其他情况下，朝正确的方向看可能会很有用，因此让我们创建一种方法</font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来强制小队改变方向以查看特定点。可以使用方法设置所需的旋转</font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，首先将点设置为与分离相同的垂直位置。之后，我们可以检索小队的方向。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使分离实际发生，我们将把该方法转换为另一个corutin，以恒定的速度旋转它。旋转速度也可以调整，但是我们将再次使用该常数。旋转应该很快，大约每秒180°。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed = <span class="hljs-number"><span class="hljs-number">180f</span></span>; … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有必要修补转弯的加速，因为它是不可见的。只要在两个方向之间进行插值就足够了。不幸的是，这不像两个数时那样简单，因为角度是圆形的。例如，从350°到10°的过渡应导致顺时针旋转20°，但是简单的插补将迫使逆时针方向旋转340°。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建正确旋转的最简单方法是使用球面插值在两个四元数之间进行插值。这将导致最短的转弯。为此，我们获取开始和结束的四元数，然后使用进行过渡</font></font><code>Quaternion.Slerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这将起作用，但是插值总是从0到1，无论旋转角度如何。</font><font style="vertical-align: inherit;">为了确保均匀的角速度，我们需要在旋转角度增加时减慢插值速度。</font></font><br><br><pre> <code class="cs hljs"> Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * speed; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * speed ) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 知道角度后，如果转弯为零，我们可以完全跳过转弯。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( … ) { … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在移动</font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个像元</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">位置</font><font style="vertical-align: inherit;">之前简单地执行yield </font><font style="vertical-align: inherit;">来增加单位的旋转</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Unity将自动启动协程</font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待其完成。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您检查代码，则小队将传送到最后一个单元，然后转到那里，然后再传送回到路径的起​​点并开始从那里开始移动。</font><font style="vertical-align: inherit;">发生这种情况是因为我们</font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在协程开始之前</font><font style="vertical-align: inherit;">为属性分配了一个值</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了摆脱隐形传送，我们可以在开始</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时将分离的位置返回到初始单元格。</font></font><br><br><pre> <code class="cs hljs"> Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; transform.localPosition = c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动前先转弯</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 扫一扫 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到了我们需要的动作之后，我们就可以摆脱这种方法了</font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">删除它或注释掉，以备将来需要查看路径时使用。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void OnDrawGizmos () { // … // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们不再需要记住移动的方向，因此最终</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以释放单元格列表。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … ListPool&lt;HexCell&gt;.Add(pathToTravel); pathToTravel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真正的小队动画呢？</font></font></b> <div class="spoiler_text">         ,   .    3D-       .      .        ,     .       Mecanim,     <code>TravelPath</code> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426481/">https://habr.com/ru/post/zh-CN426481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426471/index.html">间谍软件数据如何泄漏</a></li>
<li><a href="../zh-CN426473/index.html">Redux体系结构。 是或否？</a></li>
<li><a href="../zh-CN426475/index.html">宫-智能手机助手</a></li>
<li><a href="../zh-CN426477/index.html">关于RTOS的全部真相。 第十五条 内存分区：服务和数据结构</a></li>
<li><a href="../zh-CN426479/index.html">自制主板测试台</a></li>
<li><a href="../zh-CN426483/index.html">一个超越特斯拉的人。 为了更有利可图</a></li>
<li><a href="../zh-CN426485/index.html">PVS-Studio进行的第三次Qt 5测试</a></li>
<li><a href="../zh-CN426487/index.html">从头开始测试自动化。 第一部分</a></li>
<li><a href="../zh-CN426489/index.html">关于素数和无理数的关系</a></li>
<li><a href="../zh-CN426491/index.html">安全周39：关于Google+的死亡</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>