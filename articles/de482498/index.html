<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóº ‚òùüèΩ üà≥ Entwicklungsgeschichte der Schnittstellen in Java üßñüèæ üöÇ üë®‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Oberfl√§che in Java hat sich im Laufe der Jahre stark weiterentwickelt. Schauen wir uns an, welche Ver√§nderungen im Verlauf der Entwicklung eingetr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklungsgeschichte der Schnittstellen in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482498/"><img src="https://habrastorage.org/webt/db/rm/ac/dbrmacgcmj4awxvvosnyra8kmmo.png" alt="Bild"><br><br>  Die Oberfl√§che in Java hat sich im Laufe der Jahre stark weiterentwickelt.  Schauen wir uns an, welche Ver√§nderungen im Verlauf der Entwicklung eingetreten sind. <br><a name="habracut"></a><br><h2>  Originelle Schnittstellen </h2><br>  Die Schnittstellen in Java 1.0 waren im Vergleich zu den heutigen recht einfach.  Sie k√∂nnen nur zwei Arten von Elementen enthalten: Konstanten und √∂ffentliche abstrakte Methoden. <br><br><h3>  Konstante Felder </h3><br>  Schnittstellen k√∂nnen Felder enthalten, genau wie regul√§re Klassen, jedoch mit ein paar Unterschieden: <br><br><ul><li>  Felder m√ºssen initialisiert werden. </li><li>  Felder gelten als public static final </li><li>  Die Modifikatoren public, static und final m√ºssen nicht explizit angegeben werden (sie werden standardm√§√üig "abgelegt") </li></ul><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MY_CONSTANT = <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre> <br>  Obwohl dies nicht explizit angegeben ist, wird das Feld MY_CONSTANT als √∂ffentliche statische Endkonstante betrachtet.  Sie k√∂nnen diese Modifikatoren hinzuf√ºgen, dies ist jedoch nicht erforderlich. <br><br><h2>  Abstrakte Methoden </h2><br>  Die wichtigsten Elemente einer Schnittstelle sind ihre Methoden.  Schnittstellenmethoden unterscheiden sich auch von regul√§ren Klassenmethoden: <br><br><ul><li>  Methoden haben keinen K√∂rper </li><li>  Die Implementierung der Methode wird von Klassen bereitgestellt, die diese Schnittstelle implementieren. </li><li>  Methoden gelten als √∂ffentlich und abstrakt, auch wenn sie nicht explizit angegeben sind. </li><li>  Methoden k√∂nnen nicht final sein, da die Kombination von abstrakten und finalen Modifikatoren in Java nicht zul√§ssig ist </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingCompletelyDifferent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><h2>  Nisten </h2><br>  In Java 1.1 wurde das Konzept von Klassen eingef√ºhrt, die in andere Klassen eingef√ºgt werden k√∂nnen.  Es gibt zwei Arten solcher Klassen: statische und nicht statische.  Schnittstellen k√∂nnen auch andere Schnittstellen und Klassen enthalten. <br><br>  Auch wenn dies nicht explizit angegeben wird, werden solche Schnittstellen und Klassen als √∂ffentlich und statisch betrachtet. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } interface MyOtherInterface { //... } }</span></span></code> </pre><br><h3>  Aufz√§hlungen und Anmerkungen </h3><br>  In Java 5 wurden zwei weitere Typen eingef√ºhrt: Aufz√§hlungen und Anmerkungen.  Sie k√∂nnen auch in Schnittstellen platziert werden. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> MyEnum { FOO, BAR; } <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> MyAnnotation { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Generische Typen </h2><br>  Java 5 f√ºhrte das Konzept der generischen Typen ein.  Kurz gesagt: Mit Generika k√∂nnen Sie einen generischen Typ verwenden, anstatt einen bestimmten Typ anzugeben.  Auf diese Weise k√∂nnen Sie Code schreiben, der mit einer anderen Anzahl von Typen arbeitet, ohne die Sicherheit zu beeintr√§chtigen und ohne f√ºr jeden Typ eine separate Implementierung bereitzustellen. <br><br>  In Interfaces, die in Java 5 beginnen, k√∂nnen Sie einen generischen Typ definieren und ihn dann als Typ des R√ºckgabewerts einer Methode oder als Typ eines Arguments f√ºr eine Methode verwenden. <br><br>  Die Box-Oberfl√§che funktioniert unabh√§ngig davon, ob Sie sie zum Speichern von Objekten wie String, Integer, List, Shoe oder anderen verwenden. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T item)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoeBox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shoe</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shoe item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Statische Methoden </h2><br>  Ab Java 8 k√∂nnen Sie statische Methoden in Schnittstellen einbinden.  Dieser Ansatz hat die Funktionsweise der Benutzeroberfl√§che f√ºr uns ge√§ndert.  Sie funktionieren jetzt ganz anders als vor Java 8. Zu Beginn waren alle Methoden in den Schnittstellen abstrakt.  Dies bedeutete, dass die Schnittstelle nur eine Signatur, aber keine Implementierung bereitstellte.  Die Implementierung wurde den Klassen √ºberlassen, die Ihre Schnittstelle implementieren. <br><br>  Wenn Sie statische Methoden in Schnittstellen verwenden, m√ºssen Sie auch eine Implementierung des Methodenk√∂rpers bereitstellen.  Um diese Methode in einer Schnittstelle zu verwenden, verwenden Sie einfach das Schl√ºsselwort static.  Statische Methoden werden standardm√§√üig als √∂ffentlich betrachtet. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// This works static int foo() { return 0; } // This does not work, // static methods in interfaces need body static int bar(); }</span></span></code> </pre><br><h3>  Statische Methodenvererbung </h3><br>  Im Gegensatz zu regul√§ren statischen Methoden werden statische Methoden in Schnittstellen nicht vererbt.  Das hei√üt, wenn Sie eine solche Methode aufrufen m√∂chten, m√ºssen Sie sie direkt von der Schnittstelle aus aufrufen und nicht von der Klasse, die sie implementiert. <br><br><pre> <code class="java hljs">MyInterface.staticMethod();</code> </pre><br>  Dieses Verhalten ist sehr n√ºtzlich, um Probleme mit der Mehrfachvererbung zu vermeiden.  Stellen Sie sich vor, Sie haben eine Klasse, die zwei Schnittstellen implementiert.  Jede der Schnittstellen verf√ºgt √ºber eine statische Methode mit demselben Namen und derselben Signatur.  Welches sollte zuerst verwendet werden? <br><br><h3>  Warum ist es n√ºtzlich? </h3><br>  Stellen Sie sich vor, Sie haben eine Schnittstelle und eine ganze Reihe von Hilfsmethoden, die mit Klassen arbeiten, die diese Schnittstelle implementieren. <br><br>  Traditionell gab es einen Ansatz zur Verwendung einer Companion-Klasse.  Zus√§tzlich zur Schnittstelle wurde eine Utility-Klasse mit einem sehr √§hnlichen Namen erstellt, die statische Methoden enth√§lt, die zur Schnittstelle geh√∂ren. <br><br>  Beispiele f√ºr die Verwendung dieses Ansatzes finden Sie direkt im JDK: Die Schnittstelle java.util.Collection und die zugeh√∂rige Dienstprogrammklasse java.util.Collections. <br><br>  Bei statischen Methoden in den Schnittstellen ist dieser Ansatz nicht mehr relevant, wird nicht ben√∂tigt und nicht empfohlen.  Jetzt k√∂nnen Sie alles an einem Ort haben. <br><br><h2>  Standardmethoden </h2><br>  Standardmethoden sind statischen Methoden insofern √§hnlich, als Sie auch einen Body f√ºr sie bereitstellen m√ºssen.  Verwenden Sie zum Deklarieren einer Standardmethode einfach das Standardschl√ºsselwort. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  Im Gegensatz zu statischen Methoden werden Methoden standardm√§√üig von Klassen geerbt, die die Schnittstelle implementieren.  Was wichtig ist, k√∂nnen solche Klassen bei Bedarf ihr Verhalten neu definieren. <br><br>  Obwohl es eine Ausnahme gibt.  Die Schnittstelle darf keine Standardmethoden mit derselben Signatur wie die Methoden toString, equals und hashCode der Object-Klasse haben.  Schauen Sie sich die Antwort von Brian Goetz an, um die G√ºltigkeit einer solchen L√∂sung zu verstehen: <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html">Lassen Sie zu, dass Standardmethoden die Methoden von Object √ºberschreiben.</a> <br><br><h3>  Warum ist es n√ºtzlich? </h3><br>  Die Idee, Methoden direkt in die Oberfl√§che zu implementieren, scheint nicht ganz richtig zu sein.  Warum wurde diese Funktionalit√§t zum ersten Mal eingef√ºhrt? <br><br>  Schnittstellen haben ein Problem.  Sobald Sie Ihre API an andere Personen weitergeben, wird sie f√ºr immer ‚Äûversteinern‚Äú (sie kann nicht schmerzlos ge√§ndert werden). <br><br>  Java nimmt traditionell die Abw√§rtskompatibilit√§t sehr ernst.  Die Standardmethoden bieten eine M√∂glichkeit, vorhandene Schnittstellen mit neuen Methoden zu erweitern.  Vor allem bieten die Standardmethoden bereits eine bestimmte Implementierung.  Dies bedeutet, dass Klassen, die Ihre Schnittstelle implementieren, keine neuen Methoden implementieren m√ºssen.  Bei Bedarf k√∂nnen die Standardmethoden jedoch jederzeit √ºberschrieben werden, wenn ihre Implementierung nicht mehr geeignet ist.  Kurz gesagt, Sie k√∂nnen vorhandenen Klassen, die Ihre Schnittstelle implementieren, neue Funktionen bereitstellen und gleichzeitig die Kompatibilit√§t aufrechterhalten. <br><br><h3>  Konflikte </h3><br>  Stellen wir uns vor, wir haben eine Klasse, die zwei Interfaces implementiert.  Diese Schnittstellen haben eine Standardmethode mit demselben Namen und derselben Signatur. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Nun wird dieselbe Standardmethode mit derselben Signatur von zwei verschiedenen Schnittstellen geerbt.  Jede Schnittstelle hat eine eigene Implementierung dieser Methode. <br><br>  Woher wei√ü unsere Klasse, welche der beiden verschiedenen Implementierungen sie verwenden soll? <br><br>  Er wird es nicht wissen.  Der obige Code f√ºhrt zu einem Kompilierungsfehler.  Wenn es funktionieren soll, m√ºssen Sie die in Konflikt stehende Methode in Ihrer Klasse √ºberschreiben. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Without this the compilation fails @Override public int doSomething() { return 256; } }</span></span></code> </pre><br><h2>  Private Methoden </h2><br>  Mit dem Aufkommen von Java 8 und der Einf√ºhrung von Standardmethoden und statischen Methoden k√∂nnen Schnittstellen nicht nur Methodensignaturen, sondern auch deren Implementierung enthalten.  Beim Schreiben solcher Implementierungen wird empfohlen, komplexe Methoden in einfachere zu unterteilen.  Solcher Code ist einfacher wiederzuverwenden, zu warten und zu verstehen. <br><br>  Zu diesem Zweck w√ºrden Sie private Methoden verwenden, da diese alle Implementierungsdetails enthalten k√∂nnen, die nicht sichtbar sein und von au√üen verwendet werden sollten. <br><br>  In Java 8 kann eine Schnittstelle leider keine privaten Methoden enthalten.  Dies bedeutet, dass Sie Folgendes verwenden k√∂nnen: <br><br><ol><li>  Lange, komplexe und schwer verst√§ndliche K√∂rpertechniken. </li><li>  Hilfsmethoden, die Teil der Schnittstelle sind.  Dies verst√∂√üt gegen das Prinzip der Kapselung und belastet die √∂ffentliche API der Schnittstellen- und Implementierungsklassen. </li></ol><br>  Gl√ºcklicherweise k√∂nnen Sie ab <a href="http://openjdk.java.net/jeps/213">Java 9 private Methoden in Interfaces verwenden</a> .  Sie haben folgende Eigenschaften: <br><br><ul><li>  Private Methoden haben einen K√∂rper, sie sind nicht abstrakt </li><li>  Sie k√∂nnen entweder statisch oder nicht statisch sein </li><li>  Sie werden nicht von Klassen geerbt, die die Schnittstelle und die Schnittstellen implementieren </li><li>  Sie k√∂nnen andere Schnittstellenmethoden aufrufen </li><li>  Private Methoden k√∂nnen andere private, abstrakte, statische oder Standardmethoden aufrufen </li><li>  Private statische Methoden k√∂nnen nur andere statische und private statische Methoden aufrufen </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><h2>  Chronologische Reihenfolge </h2><br>  Das Folgende ist eine chronologische Liste der √Ñnderungen f√ºr Java-Versionen: <br><br><h4>  Java 1.1 </h4><br>  Geschachtelte Klassen <br><br>  Verschachtelte Schnittstellen <br><br><h4>  Java 5 </h4><br>  Generische Typen <br><br>  Anbei Transfers <br><br>  Verschachtelte Anmerkungen <br><br><h4>  Java 8 </h4><br>  Standardmethoden <br><br>  Statische Methoden <br><br><h4>  Java 9 </h4><br>  Private Methoden </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482498/">https://habr.com/ru/post/de482498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482486/index.html">Was ist Misra und wie man es kocht</a></li>
<li><a href="../de482490/index.html">Was ist MISRA und wie kocht man es?</a></li>
<li><a href="../de482492/index.html">Permafrost-Auftauen und Treibhausgasemissionen</a></li>
<li><a href="../de482494/index.html">Umfrageergebnisse aktualisieren</a></li>
<li><a href="../de482496/index.html">Ergebnisse: 9 gro√üe technologische Durchbr√ºche von 2019</a></li>
<li><a href="../de482502/index.html">5,8 Millionen IOPS: warum so viele?</a></li>
<li><a href="../de482504/index.html">Beitrag mit Beitr√§gen: Unsere Ergebnisse f√ºr 2019</a></li>
<li><a href="../de482508/index.html">2019 auf Habr√© in Zahlen: Es gibt mehr Beitr√§ge, abz√ºglich der gleichen, die aktiver kommentieren</a></li>
<li><a href="../de482512/index.html">Sie sind wie wir: Vergessen Sie bei der Einreise nach China die besondere asiatische Mentalit√§t</a></li>
<li><a href="../de482520/index.html">Berechnung der maximal m√∂glichen Rabatte bei auftragsbezogenen Projekten auf Basis der aktuellen Auslastung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>