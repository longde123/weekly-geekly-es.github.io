<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗼 ☝🏽 🈳 Entwicklungsgeschichte der Schnittstellen in Java 🧖🏾 🚂 👨‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Oberfläche in Java hat sich im Laufe der Jahre stark weiterentwickelt. Schauen wir uns an, welche Veränderungen im Verlauf der Entwicklung eingetr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklungsgeschichte der Schnittstellen in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482498/"><img src="https://habrastorage.org/webt/db/rm/ac/dbrmacgcmj4awxvvosnyra8kmmo.png" alt="Bild"><br><br>  Die Oberfläche in Java hat sich im Laufe der Jahre stark weiterentwickelt.  Schauen wir uns an, welche Veränderungen im Verlauf der Entwicklung eingetreten sind. <br><a name="habracut"></a><br><h2>  Originelle Schnittstellen </h2><br>  Die Schnittstellen in Java 1.0 waren im Vergleich zu den heutigen recht einfach.  Sie können nur zwei Arten von Elementen enthalten: Konstanten und öffentliche abstrakte Methoden. <br><br><h3>  Konstante Felder </h3><br>  Schnittstellen können Felder enthalten, genau wie reguläre Klassen, jedoch mit ein paar Unterschieden: <br><br><ul><li>  Felder müssen initialisiert werden. </li><li>  Felder gelten als public static final </li><li>  Die Modifikatoren public, static und final müssen nicht explizit angegeben werden (sie werden standardmäßig "abgelegt") </li></ul><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MY_CONSTANT = <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre> <br>  Obwohl dies nicht explizit angegeben ist, wird das Feld MY_CONSTANT als öffentliche statische Endkonstante betrachtet.  Sie können diese Modifikatoren hinzufügen, dies ist jedoch nicht erforderlich. <br><br><h2>  Abstrakte Methoden </h2><br>  Die wichtigsten Elemente einer Schnittstelle sind ihre Methoden.  Schnittstellenmethoden unterscheiden sich auch von regulären Klassenmethoden: <br><br><ul><li>  Methoden haben keinen Körper </li><li>  Die Implementierung der Methode wird von Klassen bereitgestellt, die diese Schnittstelle implementieren. </li><li>  Methoden gelten als öffentlich und abstrakt, auch wenn sie nicht explizit angegeben sind. </li><li>  Methoden können nicht final sein, da die Kombination von abstrakten und finalen Modifikatoren in Java nicht zulässig ist </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingCompletelyDifferent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><h2>  Nisten </h2><br>  In Java 1.1 wurde das Konzept von Klassen eingeführt, die in andere Klassen eingefügt werden können.  Es gibt zwei Arten solcher Klassen: statische und nicht statische.  Schnittstellen können auch andere Schnittstellen und Klassen enthalten. <br><br>  Auch wenn dies nicht explizit angegeben wird, werden solche Schnittstellen und Klassen als öffentlich und statisch betrachtet. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } interface MyOtherInterface { //... } }</span></span></code> </pre><br><h3>  Aufzählungen und Anmerkungen </h3><br>  In Java 5 wurden zwei weitere Typen eingeführt: Aufzählungen und Anmerkungen.  Sie können auch in Schnittstellen platziert werden. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> MyEnum { FOO, BAR; } <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> MyAnnotation { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Generische Typen </h2><br>  Java 5 führte das Konzept der generischen Typen ein.  Kurz gesagt: Mit Generika können Sie einen generischen Typ verwenden, anstatt einen bestimmten Typ anzugeben.  Auf diese Weise können Sie Code schreiben, der mit einer anderen Anzahl von Typen arbeitet, ohne die Sicherheit zu beeinträchtigen und ohne für jeden Typ eine separate Implementierung bereitzustellen. <br><br>  In Interfaces, die in Java 5 beginnen, können Sie einen generischen Typ definieren und ihn dann als Typ des Rückgabewerts einer Methode oder als Typ eines Arguments für eine Methode verwenden. <br><br>  Die Box-Oberfläche funktioniert unabhängig davon, ob Sie sie zum Speichern von Objekten wie String, Integer, List, Shoe oder anderen verwenden. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T item)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoeBox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shoe</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shoe item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Statische Methoden </h2><br>  Ab Java 8 können Sie statische Methoden in Schnittstellen einbinden.  Dieser Ansatz hat die Funktionsweise der Benutzeroberfläche für uns geändert.  Sie funktionieren jetzt ganz anders als vor Java 8. Zu Beginn waren alle Methoden in den Schnittstellen abstrakt.  Dies bedeutete, dass die Schnittstelle nur eine Signatur, aber keine Implementierung bereitstellte.  Die Implementierung wurde den Klassen überlassen, die Ihre Schnittstelle implementieren. <br><br>  Wenn Sie statische Methoden in Schnittstellen verwenden, müssen Sie auch eine Implementierung des Methodenkörpers bereitstellen.  Um diese Methode in einer Schnittstelle zu verwenden, verwenden Sie einfach das Schlüsselwort static.  Statische Methoden werden standardmäßig als öffentlich betrachtet. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// This works static int foo() { return 0; } // This does not work, // static methods in interfaces need body static int bar(); }</span></span></code> </pre><br><h3>  Statische Methodenvererbung </h3><br>  Im Gegensatz zu regulären statischen Methoden werden statische Methoden in Schnittstellen nicht vererbt.  Das heißt, wenn Sie eine solche Methode aufrufen möchten, müssen Sie sie direkt von der Schnittstelle aus aufrufen und nicht von der Klasse, die sie implementiert. <br><br><pre> <code class="java hljs">MyInterface.staticMethod();</code> </pre><br>  Dieses Verhalten ist sehr nützlich, um Probleme mit der Mehrfachvererbung zu vermeiden.  Stellen Sie sich vor, Sie haben eine Klasse, die zwei Schnittstellen implementiert.  Jede der Schnittstellen verfügt über eine statische Methode mit demselben Namen und derselben Signatur.  Welches sollte zuerst verwendet werden? <br><br><h3>  Warum ist es nützlich? </h3><br>  Stellen Sie sich vor, Sie haben eine Schnittstelle und eine ganze Reihe von Hilfsmethoden, die mit Klassen arbeiten, die diese Schnittstelle implementieren. <br><br>  Traditionell gab es einen Ansatz zur Verwendung einer Companion-Klasse.  Zusätzlich zur Schnittstelle wurde eine Utility-Klasse mit einem sehr ähnlichen Namen erstellt, die statische Methoden enthält, die zur Schnittstelle gehören. <br><br>  Beispiele für die Verwendung dieses Ansatzes finden Sie direkt im JDK: Die Schnittstelle java.util.Collection und die zugehörige Dienstprogrammklasse java.util.Collections. <br><br>  Bei statischen Methoden in den Schnittstellen ist dieser Ansatz nicht mehr relevant, wird nicht benötigt und nicht empfohlen.  Jetzt können Sie alles an einem Ort haben. <br><br><h2>  Standardmethoden </h2><br>  Standardmethoden sind statischen Methoden insofern ähnlich, als Sie auch einen Body für sie bereitstellen müssen.  Verwenden Sie zum Deklarieren einer Standardmethode einfach das Standardschlüsselwort. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  Im Gegensatz zu statischen Methoden werden Methoden standardmäßig von Klassen geerbt, die die Schnittstelle implementieren.  Was wichtig ist, können solche Klassen bei Bedarf ihr Verhalten neu definieren. <br><br>  Obwohl es eine Ausnahme gibt.  Die Schnittstelle darf keine Standardmethoden mit derselben Signatur wie die Methoden toString, equals und hashCode der Object-Klasse haben.  Schauen Sie sich die Antwort von Brian Goetz an, um die Gültigkeit einer solchen Lösung zu verstehen: <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html">Lassen Sie zu, dass Standardmethoden die Methoden von Object überschreiben.</a> <br><br><h3>  Warum ist es nützlich? </h3><br>  Die Idee, Methoden direkt in die Oberfläche zu implementieren, scheint nicht ganz richtig zu sein.  Warum wurde diese Funktionalität zum ersten Mal eingeführt? <br><br>  Schnittstellen haben ein Problem.  Sobald Sie Ihre API an andere Personen weitergeben, wird sie für immer „versteinern“ (sie kann nicht schmerzlos geändert werden). <br><br>  Java nimmt traditionell die Abwärtskompatibilität sehr ernst.  Die Standardmethoden bieten eine Möglichkeit, vorhandene Schnittstellen mit neuen Methoden zu erweitern.  Vor allem bieten die Standardmethoden bereits eine bestimmte Implementierung.  Dies bedeutet, dass Klassen, die Ihre Schnittstelle implementieren, keine neuen Methoden implementieren müssen.  Bei Bedarf können die Standardmethoden jedoch jederzeit überschrieben werden, wenn ihre Implementierung nicht mehr geeignet ist.  Kurz gesagt, Sie können vorhandenen Klassen, die Ihre Schnittstelle implementieren, neue Funktionen bereitstellen und gleichzeitig die Kompatibilität aufrechterhalten. <br><br><h3>  Konflikte </h3><br>  Stellen wir uns vor, wir haben eine Klasse, die zwei Interfaces implementiert.  Diese Schnittstellen haben eine Standardmethode mit demselben Namen und derselben Signatur. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Nun wird dieselbe Standardmethode mit derselben Signatur von zwei verschiedenen Schnittstellen geerbt.  Jede Schnittstelle hat eine eigene Implementierung dieser Methode. <br><br>  Woher weiß unsere Klasse, welche der beiden verschiedenen Implementierungen sie verwenden soll? <br><br>  Er wird es nicht wissen.  Der obige Code führt zu einem Kompilierungsfehler.  Wenn es funktionieren soll, müssen Sie die in Konflikt stehende Methode in Ihrer Klasse überschreiben. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Without this the compilation fails @Override public int doSomething() { return 256; } }</span></span></code> </pre><br><h2>  Private Methoden </h2><br>  Mit dem Aufkommen von Java 8 und der Einführung von Standardmethoden und statischen Methoden können Schnittstellen nicht nur Methodensignaturen, sondern auch deren Implementierung enthalten.  Beim Schreiben solcher Implementierungen wird empfohlen, komplexe Methoden in einfachere zu unterteilen.  Solcher Code ist einfacher wiederzuverwenden, zu warten und zu verstehen. <br><br>  Zu diesem Zweck würden Sie private Methoden verwenden, da diese alle Implementierungsdetails enthalten können, die nicht sichtbar sein und von außen verwendet werden sollten. <br><br>  In Java 8 kann eine Schnittstelle leider keine privaten Methoden enthalten.  Dies bedeutet, dass Sie Folgendes verwenden können: <br><br><ol><li>  Lange, komplexe und schwer verständliche Körpertechniken. </li><li>  Hilfsmethoden, die Teil der Schnittstelle sind.  Dies verstößt gegen das Prinzip der Kapselung und belastet die öffentliche API der Schnittstellen- und Implementierungsklassen. </li></ol><br>  Glücklicherweise können Sie ab <a href="http://openjdk.java.net/jeps/213">Java 9 private Methoden in Interfaces verwenden</a> .  Sie haben folgende Eigenschaften: <br><br><ul><li>  Private Methoden haben einen Körper, sie sind nicht abstrakt </li><li>  Sie können entweder statisch oder nicht statisch sein </li><li>  Sie werden nicht von Klassen geerbt, die die Schnittstelle und die Schnittstellen implementieren </li><li>  Sie können andere Schnittstellenmethoden aufrufen </li><li>  Private Methoden können andere private, abstrakte, statische oder Standardmethoden aufrufen </li><li>  Private statische Methoden können nur andere statische und private statische Methoden aufrufen </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><h2>  Chronologische Reihenfolge </h2><br>  Das Folgende ist eine chronologische Liste der Änderungen für Java-Versionen: <br><br><h4>  Java 1.1 </h4><br>  Geschachtelte Klassen <br><br>  Verschachtelte Schnittstellen <br><br><h4>  Java 5 </h4><br>  Generische Typen <br><br>  Anbei Transfers <br><br>  Verschachtelte Anmerkungen <br><br><h4>  Java 8 </h4><br>  Standardmethoden <br><br>  Statische Methoden <br><br><h4>  Java 9 </h4><br>  Private Methoden </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482498/">https://habr.com/ru/post/de482498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482486/index.html">Was ist Misra und wie man es kocht</a></li>
<li><a href="../de482490/index.html">Was ist MISRA und wie kocht man es?</a></li>
<li><a href="../de482492/index.html">Permafrost-Auftauen und Treibhausgasemissionen</a></li>
<li><a href="../de482494/index.html">Umfrageergebnisse aktualisieren</a></li>
<li><a href="../de482496/index.html">Ergebnisse: 9 große technologische Durchbrüche von 2019</a></li>
<li><a href="../de482502/index.html">5,8 Millionen IOPS: warum so viele?</a></li>
<li><a href="../de482504/index.html">Beitrag mit Beiträgen: Unsere Ergebnisse für 2019</a></li>
<li><a href="../de482508/index.html">2019 auf Habré in Zahlen: Es gibt mehr Beiträge, abzüglich der gleichen, die aktiver kommentieren</a></li>
<li><a href="../de482512/index.html">Sie sind wie wir: Vergessen Sie bei der Einreise nach China die besondere asiatische Mentalität</a></li>
<li><a href="../de482520/index.html">Berechnung der maximal möglichen Rabatte bei auftragsbezogenen Projekten auf Basis der aktuellen Auslastung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>