<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥗 🦈 🚔 为什么物理学家仍然使用Fortran 🥐 👩🏿‍🎓 👩🏾‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我不知道2000年的编程语言会是什么样，但是我知道它会被称为FORTRAN。
 -Charles Anthony Richard Hoar，约。1982年
 在业界，Fortran如今很少使用-在流行语言列表之一中，它排名第28位。但是Fortran仍然是进行大规模物理系统模拟的主要语言-即恒星和星...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为什么物理学家仍然使用Fortran</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/400523/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不知道2000年的编程语言会是什么样，但是我知道它会被称为FORTRAN。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -Charles Anthony Richard Hoar，约。</font><font style="vertical-align: inherit;">1982年</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在业界，Fortran如今很少使用-在流行语言列表之一中，它</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排名第28位</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是Fortran仍然是进行大规模物理系统模拟的主要语言-即恒星和星系的天体物理建模（例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），大规模分子动力学，电子结构计数代码（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIESTA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），气候模型等。在高性能计算领域（其中一部分是大规模数值模拟），如今仅使用两种语言-C / C ++和“现代Fortran”（Fortran 90/95/03/08）。流行的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">开放式MPI</font></a><font style="vertical-align: inherit;">库</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经针对这两种语言开发了代码并行化工具。通常，如果需要在多个处理器上运行的快速代码，则只有两个选择。在现代的Fortran中，有一个名为“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coarray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">的功能</font><font style="vertical-align: inherit;">，它允许在并行编程中直接使用该语言。 Coarray出现在Fortran 95扩展中，后来被整合到Fortran 2008中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理学家对Fortran的积极使用常常使计算机科学家和与该领域无关的其他人感到困惑，他们认为Fortran是历史上的时代错误。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想解释一下为什么Fortran仍然有用。我不鼓励学习物理的学生教Fortran-因为他们中的大多数人都会做研究，所以他们最好学习C / C ++（或者停在Matlab / Octave / Python中）。我想解释为什么仍然使用Fortran，并证明这不仅是因为物理学家“落后于时代”（尽管有时如此）-去年，我看到一名物理专业的学生在研究代码Fortran 77，而他和他的经理都没有听到有关Fortran 90的任何消息。计算机科学家应将Fortran在数值计算领域的主导地位视为挑战。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在深入探讨该主题之前，我想讨论一下这个故事，因为当人们听到“ Fortran”一词时，他们会立即想到打孔卡和带编号行的代码。第一个Fortran规范是1954年编写的。按照现代标准，早期的Fortran（当时的名称用大写字母FORTRAN编写）是一种地狱般的语言，但这是对先前汇编程序编程的不可思议的进步。正如Stony Brook University的Miriam Forman教授回忆说的那样，FORTRAN经常用打孔卡编程。 Fortran有许多版本，其中最著名的是标准66、77、90、95、03和08。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人们常说，由于其速度，Fortran仍在使用。但是他最快吗？在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准游戏.alioth.debian.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">C和Fortran</font></a><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在多种语言中进行了几次测试。</font><font style="vertical-align: inherit;">在大多数情况下，Fortran和C / C ++是最快的。</font><font style="vertical-align: inherit;">最喜欢的Python程序员通常在速度上落后100倍，但这是解释代码的顺序。</font><font style="vertical-align: inherit;">Python不适合用于复杂的数值计算，但非常适合于另一个。</font><font style="vertical-align: inherit;">有趣的是，C / C ++在除两个测试之外的所有测试中均胜过Fortran，尽管通常它们的结果差异不大。</font><font style="vertical-align: inherit;">Fortran获胜的测试中，最“物理”的测试是对n个物体系统的仿真和频谱计算。</font><font style="vertical-align: inherit;">结果取决于处理器内核的数量，例如，Fortran在四核上落后于C / C ++。</font><font style="vertical-align: inherit;">在测试中，Fortran远远落后于C / C ++，它在大多数时间都读取和写入数据，在这一方面，Fortran的运行速度是众所周知的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，C / C ++的速度与Fortran一样快，有时还快一些。</font><font style="vertical-align: inherit;">我们感兴趣的是，“为什么物理学教授继续建议他们的学生使用Fortran而不是C / C ++？”</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortran具有旧代码</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于Fortran的悠久历史，因此上面写着大量的物理代码也就不足为奇了。</font><font style="vertical-align: inherit;">物理学家正在尝试最小化编程时间，因此，如果他们找到更早的代码，他们将使用它。</font><font style="vertical-align: inherit;">即使旧代码不可读，文档记录不充分且效率最高，但使用旧的经过验证的代码比编写新的代码更有可能。</font><font style="vertical-align: inherit;">物理学家的任务不是写代码，而是试图理解现实的本质。</font><font style="vertical-align: inherit;">教授总是手头有继承的代码（通常他们是几十年前编写的），然后将其传递给学生。</font><font style="vertical-align: inherit;">这样可以节省时间，并消除了纠错过程中的不确定性。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理专业的学生比C / C ++更轻松地学习Fortran</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为Fortran比C / C ++更易于学习。 Fortran 90和C非常相似，但是Fortran更易于编写。 C是一种相对原始的语言，因此选择C / C ++的物理学家从事面向对象的编程。 OOP很有用，尤其是在大型软件项目中，但要花更长的时间研究。您需要研究类和继承之类的抽象。 OOP范例与Fortran使用的过程范例大不相同。 Fortran基于一个简单的程序范例，该范例更接近于计算机幕后发生的事情。当优化/矢量化代码以提高速度时，过程范例更易于使用。物理学家通常了解计算机的工作原理，并根据物理过程进行思考，例如，将数据从磁盘传输到RAM，再从RAM传输到处理器缓存。它们不同于数学家，他们更喜欢根据抽象函数和逻辑进行思考。而且，这种想法与面向对象不同。从我的角度来看，OOP代码的优化比过程的更为复杂。与物理学家喜欢的数据结构相比，对象是非常庞大的结构：数组。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亮度一：Fortran阵列工作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数组，或者如物理学家所说的，矩阵，是所有物理计算的核心。</font><font style="vertical-align: inherit;">在Fortran 90+中，您可以找到许多与之合作的机会，类似于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和Matlab / Octave。</font><font style="vertical-align: inherit;">可以复制数组，乘以标量，然后以非常直观的方式在数组之间相乘：</font></font><br>
 <br>
<pre><code class="hljs lisp">A = B<font></font>
A = <span class="hljs-number"><span class="hljs-number">3.24</span></span>*B<font></font>
C = A*B<font></font>
B = exp(<span class="hljs-name"><span class="hljs-name">A</span></span>)<font></font>
norm = sqrt(<span class="hljs-name"><span class="hljs-name">sum</span></span>(<span class="hljs-name"><span class="hljs-name">A**2</span></span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，A，B，C是某个尺寸的数组（例如10x10x10）。如果A和B的大小相同，则C = A * B给我们矩阵的逐元素乘法。对于矩阵乘法，使用C = matmul（A，B）。几乎所有的Fortran内部函数（Sin（），Exp（），Abs（），Floor（）等）都将数组作为参数，这导致了代码简洁明了。 C / C ++中根本没有类似的代码。在基本的C / C ++实现中，仅复制数组就需要在所有元素上运行for循环或调用库函数。如果在C中输入错误的库函数数组，则会发生错误。需要使用库而不是内部函数意味着生成的代码将不是干净，可移植的，也不是易于学习的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Fortran中，通过简单语法A [x，y，z]访问数组的元素，而在C / C ++中则需要编写A [x] [y] [z]。</font><font style="vertical-align: inherit;">数组的元素以1开头，这对应于物理学家对矩阵的理解，并且在C / C ++数组中，编号从零开始。</font><font style="vertical-align: inherit;">以下是在Fortran中使用数组的其他一些功能。</font></font><br>
 <br>
<pre><code class="hljs lisp">A = (<span class="hljs-name"><span class="hljs-name">/</span></span> i , i = <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> /)<font></font>
B = A(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>)<font></font>
C(<span class="hljs-number"><span class="hljs-number">10</span></span>:) = B</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，通过隐式的do循环（也称为数组构造函数）创建向量A。</font><font style="vertical-align: inherit;">然后，使用步骤10创建一个由B的每10个元素组成的向量B。最后，从第10个元素开始将数组B复制到数组C。</font><font style="vertical-align: inherit;">Fortran支持使用零或负索引声明数组：</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, dimension(<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) :: myArray</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，负索引看起来很愚蠢，但是我听说它们的用处-例如，想象一下这是发布任何说明的附加区域。</font><font style="vertical-align: inherit;">Fortran还支持</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矢量索引</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，您可以将元素1,5和7从维度N x 1的数组A转移到维度3 x 1的数组B：</font></font><br>
 <br>
<pre><code class="hljs lisp">subscripts = (<span class="hljs-name"><span class="hljs-name">/</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> /)<font></font>
B = A(<span class="hljs-name"><span class="hljs-name">subscripts</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran </font><font style="vertical-align: inherit;">在所有内部函数中均</font><font style="vertical-align: inherit;">支持</font><font style="vertical-align: inherit;">数组</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掩码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，如果我们需要计算所有大于零的矩阵元素的对数，则使用：</font></font><br>
 <br>
<pre><code class="hljs lisp">log_of_A = log(<span class="hljs-name"><span class="hljs-name">A</span></span>, mask= A .gt. <span class="hljs-number"><span class="hljs-number">0</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或者我们可以在一行中取消数组的所有负元素：</font></font><br>
 <br>
<pre><code class="hljs lisp">where(<span class="hljs-name"><span class="hljs-name">my_array</span></span> .lt. <span class="hljs-number"><span class="hljs-number">0.0</span></span>) my_array = <span class="hljs-number"><span class="hljs-number">0.0</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran使动态分配和释放数组变得容易。</font><font style="vertical-align: inherit;">例如，放置一个二维数组：</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">real</span></span>, dimension(:,:), allocatable :: name_of_array<font></font>
allocate(name_of_array(xdim, ydim))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在C / C ++中，这</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要以下输入</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
 <br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;
<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(nrows * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *));<font></font>
 <font></font>
<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
     <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ncolumns * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Fortran中释放数组</font></font><br>
 <br>
<pre><code class="hljs lisp">deallocate(<span class="hljs-name"><span class="hljs-name">name_of_array</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在C / C ++中为此</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
    <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]);<font></font>
}<font></font>
<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>);</code></pre><br>
<h2> :        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在像C / C ++这样的语言中，所有变量均按值传递，但按引用传递的数组除外。但是在许多情况下，按值传递数组更有意义。例如，让数据由不同时间段的100个分子的位置组成。我们需要分析一个分子的运动。我们获取与该分子中原子的坐标相对应的数组（子数组）的一部分，并将其传递给函数。在其中，我们将处理传输子数组的复杂分析。如果我们通过引用将其传递，则传输的数据将不会连续位于内存中。由于内存访问的性质，使用这种阵列会很慢。如果按值传递它，则将在内存中创建一行排列的新数组。令物理学家高兴的是，编译器承担了优化内存的所有肮脏工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Fortran中，变量通常是按引用而不是按值传递的。</font><font style="vertical-align: inherit;">在后台，Fortran编译器会自动优化其传输，以提高效率。</font><font style="vertical-align: inherit;">从优化内存使用领域的教授的角度来看，编译器应该比学生更受信任！</font><font style="vertical-align: inherit;">其结果是，物理学家很少使用指针，尽管用Fortran 90 + </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortran和C之间差异的更多示例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在进行故障排除和优化时，Fortran有几个用于管理编译器的选项。</font><font style="vertical-align: inherit;">可以在编译阶段而不是执行期间捕获代码中的错误。</font><font style="vertical-align: inherit;">例如，任何变量都可以声明为参数，即常量。</font></font><br>
<br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, parameter :: hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果代码中的参数更改，则编译器将返回错误。</font><font style="vertical-align: inherit;">在C中，这称为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const</font></font></a><br>
<br>
<pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题在于const real与simple real不同。如果接受real的函数获取const real，则它将返回错误。很难想象这会导致代码中的互操作性问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran还具有一个意图规范，该规范告诉编译器传递给函数的参数是输入，输出还是输入和输出参数。这有助于编译器优化代码并提高其可读性和可靠性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran具有在不同频率下使用的其他功能。</font><font style="vertical-align: inherit;">例如，Fortran 95能够使用pure修饰符声明函数。</font><font style="vertical-align: inherit;">这样的函数没有副作用-它仅更改其参数，而不更改全局变量。</font><font style="vertical-align: inherit;">这种函数的一个特例是元素函数，它接受并返回标量。</font><font style="vertical-align: inherit;">它用于处理数组元素。</font><font style="vertical-align: inherit;">该函数是纯函数还是元素函数的信息使编译器可以执行其他优化，尤其是在并行化代码时。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来会发生什么？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在科学计算中，Fortran仍然是主要语言，并且在不久的将来不会消失。</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调查中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在使用该语言的2014年超级计算机大会的访问者中，有100％的人表示他们将在未来5年内使用它。从调查中还可以看出，有90％的人使用了Fortran和C的混合物。Fortran2015规范的创建者预计将增加这些语言的混合使用，其中包括更多的代码互操作性功能。从Python代码越来越多地调用Fortran代码。批评使用Fortran的计算机科学家并不理解该语言仍然是唯一适合其后缀的名称-FOrmula TRANslation，翻译公式，即将物理公式转换为代码。他们中的许多人都不知道该语言正在发展，并且不断包含新功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将旧版本的Fortran 90+称为旧版，就像调用旧的C ++一样，因为C是在1973年开发的。另一方面，即使最新的Fortran 2008标准也具有与Fortran 77和大多数Fortran 66的向后兼容性。因此，语言的发展存在一定的困难。</font><font style="vertical-align: inherit;">最近，麻省理工学院的研究人员决定克服这些困难，从零开始为HPC开发一种名为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Julia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的语言，该语言</font><font style="vertical-align: inherit;">于2012年首次发布。</font><font style="vertical-align: inherit;">朱莉娅是否代替Fortran仍有待观察。</font><font style="vertical-align: inherit;">无论如何，我怀疑这将花费很长时间。</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN400523/">https://habr.com/ru/post/zh-CN400523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN400511/index.html">关于存储乏核燃料的现代方法</a></li>
<li><a href="../zh-CN400513/index.html">20分钟内的哥德尔不完全性定理</a></li>
<li><a href="../zh-CN400515/index.html">区块链者：区块链为那些不适合加密货币的人带来的好处</a></li>
<li><a href="../zh-CN400519/index.html">3D-Start模块化3D打印机成为3D猫感兴趣的来源</a></li>
<li><a href="../zh-CN400521/index.html">苹果修复了该错误并指控消费者报告使用了错误的测试方法</a></li>
<li><a href="../zh-CN400525/index.html">记忆数字记忆系统的开发</a></li>
<li><a href="../zh-CN400527/index.html">重采样II。声音路径中数字和模拟高阶滤波器操作的比较以及问题的答案</a></li>
<li><a href="../zh-CN400529/index.html">手术室视力矫正设备</a></li>
<li><a href="../zh-CN400531/index.html">国家杜马委员会批准了一项有关视听服务监管的法案</a></li>
<li><a href="../zh-CN400533/index.html">意识的主要悖论。为什么复制大脑或性格没有意义</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>