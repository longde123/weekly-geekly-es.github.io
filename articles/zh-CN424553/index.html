<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐸 🏛️ 🗞️ Node.js指南，第6部分：事件循环，调用堆栈，计时器 👩🏾‍🎤 🍼 ⚔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，在Node.js手册翻译的第六部分中，我们将讨论事件循环，调用堆栈， process.nextTick()函数和计时器。 了解这些以及其他Node.js机制是该平台成功开发应用程序的基石之一。 

  

 [我们建议您阅读]周期的其他部分  第1部分： 一般信息和入门 
 第2部分： Jav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js指南，第6部分：事件循环，调用堆栈，计时器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/">今天，在Node.js手册翻译的第六部分中，我们将讨论事件循环，调用堆栈， <code>process.nextTick()</code>函数和计时器。 了解这些以及其他Node.js机制是该平台成功开发应用程序的基石之一。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[我们建议您阅读]周期的其他部分</b> <div class="spoiler_text"> 第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一般信息和入门</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript，V8，一些开发技巧</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管，REPL，使用控制台，模块</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm，package.json和package-lock.json文件</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm和npx</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，调用堆栈，计时器</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步编程</a> <br> 第8部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第8部分：HTTP和WebSocket协议</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，</a>第9 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分：使用文件系统</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第10部分：标准模块，流，数据库，NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南的完整PDF</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">事件循环</font> </h2><br> 如果您想了解JavaScript代码的执行方式，则事件循环是您需要了解的最重要的概念之一。 在这里，我们将讨论JavaScript如何在单线程模式下工作以及如何处理异步函数。 <br><br> 我从事JavaScript的开发已经很多年了，但是我不能说我完全理解一切的工作原理，可以这么说。 程序员可能不知道他工作的环境的内部子系统的设备的复杂性。 但是，通常至少对此类事情有一个大致的了解是有用的。 <br><br> 您编写的JavaScript代码以单线程模式运行。 在某个时间点，仅执行一个动作。 实际上，此限制非常有用。 这极大地简化了程序的工作方式，从而使程序员无需解决特定于多线程环境的问题。 <br><br> 实际上，JS程序员只需要注意代码执行的确切动作，并尽量避免导致主线程阻塞的情况。 例如，以同步模式和无穷<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">循环</a>进行网络呼叫。 <br><br> 通常，浏览器在每个打开的选项卡中都有自己的事件循环。 这样，您就可以在隔离的环境中执行每个页面的代码，并避免某些页面（其中的代码存在无限循环或执行繁重的计算）能够“暂停”整个浏览器，从而避免出现这种情况。 浏览器支持许多同时存在的事件循环的工作，这些事件循环用于例如处理对各种API的调用。 此外，专有事件循环用于支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web Worker</a> 。 <br><br>  JavaScript程序员必须经常记住的最重要的事情是，他的代码使用了自己的事件循环，因此必须编写代码以防止该事件循环被阻塞。 <br><br><h2>  <font color="#3AC1EF">事件循环锁定</font> </h2><br> 任何花费太多时间执行的JavaScript代码（即，长时间不控制事件循环的代码）都会阻止其他任何页面代码的执行。 这甚至导致阻止用户界面事件的处理，这反映在以下事实中：用户无法与页面元素进行交互并且无法正常使用页面元素，例如滚动。 <br><br> 几乎所有基本的JavaScript I / O机制都是非阻塞的。 这适用于浏览器和Node.js。 例如，在这些机制中，我们可以提及在客户端和服务器环境中使用的用于执行网络请求的工具，以及用于处理Node.js文件的工具。 有执行此类操作的同步方法，但仅在特殊情况下使用。 这就是为什么传统的回调和更新的机制（promise和async / await构造）在JavaScript中非常重要的原因。 <br><br><h2>  <font color="#3AC1EF">调用堆栈</font> </h2><br>  JavaScript调用堆栈基于LIFO原理（后进先出-后进先出）。 事件循环不断检查调用堆栈，以查看其是否具有需要执行的功能。 如果在执行代码时调用了一个函数，则有关该函数的信息将添加到调用堆栈中，并执行该函数。 <br><br> 如果甚至在您对“调用堆栈”的概念不感兴趣之前，那么如果您遇到了包含堆栈跟踪的错误消息，您就已经可以想象它的外观了。 例如，此处在浏览器中看起来像这样。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">浏览器错误信息</font></i> <br><br> 当发生错误时，浏览器会报告对函数的调用顺序，有关调用函数的信息存储在调用堆栈中，这使您可以找到错误的根源并了解哪些调用导致了这种情况。 <br><br> 现在，我们已经笼统地讨论了事件循环和调用堆栈，现在考虑一个示例，该示例说明代码片段的执行以及从事件循环和调用堆栈的角度看该过程的外观。 <br><br><h2>  <font color="#3AC1EF">事件循环和调用堆栈</font> </h2><br> 这是我们将尝试的代码： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br> 如果执行此代码，则以下内容将进入控制台： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br> 这样的结果是完全可以预期的。 即，运行此代码时，首先调用<code>foo()</code>函数。 在此函数内部，我们首先调用<code>bar()</code>函数，然后调用<code>baz()</code>函数。 同时，执行此代码期间的调用堆栈将进行下图所示的更改。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">执行调查代码时更改调用堆栈的状态</font></i> <br><br> 在每次迭代时，事件循环都会检查调用栈中是否有任何东西，如果有，它将一直进行到调用栈为空为止。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">事件循环迭代</font></i> <br><br><h2>  <font color="#3AC1EF">排队功能</font> </h2><br> 上面的示例看起来很普通，没有什么特别的：JavaScript查找需要执行的代码并按顺序执行。 我们将讨论如何在清除调用堆栈之前推迟执行函数。 为此，使用以下构造： <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br> 它允许您在执行程序代码中调用的所有其他函数之后，执行传递给<code>setTimeout()</code>函数的函数。 <br><br> 考虑一个例子： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br> 此代码输出的内容似乎是意外的： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br> 在运行此示例时，首先调用<code>foo()</code>函数。 在其中，我们调用<code>setTimeout()</code> ，并将此函数作为第一个参数<code>bar</code>传递。 通过将<code>0</code>作为第二个参数传递，我们通知系统应尽快执行此功能。 然后我们调用<code>baz()</code>函数。 <br><br> 这就是调用堆栈的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">执行代码时更改调用堆栈的状态</font></i> <br><br> 这是我们程序中的功能现在将执行的顺序。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">事件循环迭代</font></i> <br><br> 为什么会这样发生？ <br><br><h2>  <font color="#3AC1EF">事件队列</font> </h2><br> 调用<code>setTimeout()</code>函数时，浏览器或Node.js平台将启动计时器。 在计时器工作之后（在我们的示例中，由于将其设置为0，因此立即发生），传递给<code>setTimeout()</code>的回调函数进入事件队列。 <br><br> 事件队列在涉及浏览器时，包括由用户启动的事件-由鼠标单击页面元素引起的事件，从键盘输入数据时触发的事件。  DOM <code>onload</code>处理程序（如<code>onload</code>会立即出现，该函数在接收异步请求以加载数据的答案时<code>onload</code>函数<code>onload</code> 。 他们在这里等待轮到他们处理。 <br><br> 事件循环优先考虑调用堆栈中的内容。 首先，它执行它设法在堆栈上找到的所有内容，然后在堆栈为空后继续处理事件队列中的内容。 <br><br> 我们不需要等到<code>setTimeout()</code>类的功能完成工作，因为浏览器提供了类似的功能，并且它们使用自己的流。 因此，例如，使用<code>setTimeout()</code>函数将计时器设置为2秒，由于计时器在您的代码之外运行，因此您不应在停止其他代码的执行之后等待这2秒。 <br><br><h2>  <font color="#3AC1EF">ES6作业队列</font> </h2><br>  ECMAScript 2015（ES6）引入了Job Queue的概念，Promise使用了Job Queue（它们也出现在ES6中）。 由于作业队列，可以尽可能快地使用执行异步功能的结果，而无需等待调用堆栈清除。 <br><br> 如果在当前功能结束之前解决了承诺，则将在当前功能完成后立即执行相应的代码。 <br><br> 我发现了一个有趣的类比。 这可以与游乐园中的过山车相提并论。 骑完山又想再做一次之后，您要买票，进入车尾。 这就是事件队列的工作方式。 但是作业队列看起来有所不同。 此概念类似于打折机票，它使您有权在完成上一张票后立即进行下一次旅行。 <br><br> 考虑以下示例： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br> 执行后将输出以下内容： <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br> 您在此处看到的内容展示了promise（以及基于它们的async / await构造）与传统异步函数之间的严重区别，传统异步函数的执行是使用<code>setTimeout()</code>或所用平台的其他API进行组织的。 <br><br><h2>  <font color="#3AC1EF">process.nextTick（）</font> </h2><br>  <code>process.nextTick()</code>方法以特殊方式与事件循环交互。 滴答是一个完整的事件周期。 将函数传递给<code>process.nextTick()</code>方法，我们通知系统需要在事件循环的当前迭代完成之后，下一个函数开始之前调用此函数。 使用此方法如下所示： <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br> 假设事件循环正忙于执行当前功能的代码。 该操作完成后，JavaScript引擎将执行上一个操作期间传递给<code>process.nextTick()</code>所有功能。 使用这种机制，我们努力确保异步执行某个功能（在当前功能之后），但要尽快将其放入队列中。 <br><br> 例如，如果使用<code>setTimeout(() =&gt; {}, 0)</code>构造，则该函数将在事件循环的下一次迭代中执行，即比在相同情况下使用<code>process.nextTick()</code>时要晚得多。 当必须确保在事件循环的下一次迭代的开始执行某些代码时，应使用此方法。 <br><br><h2>  <font color="#3AC1EF">setImmediate（）</font> </h2><br>  Node.js为异步代码执行提供的另一个功能是<code>setImmediate()</code> 。 使用方法如下： <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br> 传递给<code>setImmediate()</code>的回调函数将在事件循环的下一次迭代中执行。 <br><br>  <code>setImmediate()</code>与<code>setTimeout(() =&gt; {}, 0)</code> （即应尽快运行的计时器）和<code>process.nextTick()</code>有何区别？ <br><br> 传递给<code>process.nextTick()</code>的函数将在事件循环的当前迭代完成后执行。 也就是说，将始终在使用<code>setTimeout()</code>或<code>setImmediate()</code>调度执行的功能之前执行该功能。 <br><br> 设置延迟为0 ms调用<code>setTimeout()</code>函数与调用<code>setImmediate()</code>非常相似。 传递给它们的函数的执行顺序取决于各种因素，但是在两种情况下，都将在事件循环的下一次迭代中调用回调。 <br><br><h2>  <font color="#3AC1EF">计时器</font> </h2><br> 我们已经讨论过<code>setTimeout()</code>函数，该函数允许您安排对传递给它的回调的调用。 让我们花一些时间来更详细地描述其功能，并考虑与之相似的另一个函数<code>setInterval()</code> 。 在Node.js中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计时器</a>模块中包含用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计时器的功能</a> ，但是由于它们是全局的，因此无需在代码中连接此模块就可以使用它们。 <br><br><h3>  <font color="#3AC1EF">▍函数setTimeout（）</font> </h3><br> 回想一下，当您调用<code>setTimeout()</code>函数时，它将接收一个回调以及以毫秒为单位的时间，在该时间之后将调用该回调。 考虑一个例子： <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br> 在这里，我们将<code>setTimeout()</code>传递<code>setTimeout()</code>立即描述<code>setTimeout()</code>新函数，但是在这里，我们可以通过将<code>setTimeout()</code>的名称和一组参数传递给它来使用现有函数。 看起来像这样： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  <code>setTimeout()</code>函数返回计时器标识符。 通常不使用它，但是您可以保存它，并且如果不再需要计划的回调，则可以删除计时器： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍零延迟</font> </h3><br> 在前面的部分中，我们将<code>setTimeout()</code>传递给它，作为必须在其后调用回调<code>0</code> 。 这意味着将尽快调用回调，但要在当前函数完成之后： <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br> 这样的代码将输出以下内容： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br> 在执行繁重的计算任务时，我不想阻塞主线程，允许执行其他功能，将这些任务分为几个阶段，以<code>setTimeout()</code>调用执行，这种技术特别有用。 <br><br> 如果我们回想起上面的<code>setImmediate()</code>函数，那么它在Node.js中是标准的，不能在浏览器中说出来（它是在IE和Edge中实现的，但在其他浏览器中却没有实现）。 <br><br><h3>  <font color="#3AC1EF">▍函数setInterval（）</font> </h3><br>  <code>setInterval()</code>函数类似于<code>setTimeout()</code> ，但是它们之间存在差异。  <code>setInterval()</code>不会定期执行传递给它的回调，而是以指定的时间间隔定期调用此回调。 理想情况下，此过程将一直持续到程序员明确停止该过程为止。 使用此功能的方法如下： <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br> 传递给上述函数的回调将每2秒调用一次。 为了提供停止此过程的可能性，您需要获取<code>setInterval()</code>返回的计时器标识符，并使用<code>clearInterval()</code>命令： <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br> 一种常用的技术是在满足特定条件时在传递给<code>setInterval()</code>的回调中调用<code>clearInterval()</code> 。 例如，以下代码将定期运行，直到<code>App.somethingIWait</code>属性<code>App.somethingIWait</code>为<code>arrived</code> ： <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">cur递归设置setTimeout（）</font> </h3><br>  <code>setInterval()</code>函数每隔<code>n</code>毫秒调用一次传递给它的回调，而不必担心该回调在上一次调用之后是否已完成。 <br><br> 如果每次对该回调的调用总是需要少于<code>n</code>时间，则这里不会出现问题。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">定期调用回调，每个执行会话花费相同的时间，属于两次调用之间的间隔</font></i> <br><br> 可能需要花费不同的时间来完成回调，该回调仍小于<code>n</code> 。 例如，如果我们正在谈论执行某些网络操作，那么这种情况是可以预料的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">定期称为回调，每个执行会话花费不同的时间，介于两次调用之间</font></i> <br><br> 当使用<code>setInterval()</code> ，当回调占用的时间大于<code>n</code> ，可能会导致出现这种情况，导致下一个调用在上一个调用完成之前完成。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">定期调用回调，每个会话花费不同的时间，有时不适合两次调用之间的间隔</font></i> <br><br> 为了避免这种情况，可以使用<code>setTimeout()</code>的递归计时器设置技术。 关键是要在上一次调用完成之后计划下一次回调： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br> 使用这种方法，可以实现以下情形： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">对setTimeout（）的递归调用以安排回调执行</font></i> <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 今天，我们讨论了Node.js的内部机制，例如事件循环，调用堆栈，并讨论了如何使用计时器来调度代码执行。 下次，我们将深入探讨异步编程的主题。 <br><br>  <b>亲爱的读者们！</b> 您是否曾经遇到过不得不使用process.nextTick（）的情况？ <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424553/">https://habr.com/ru/post/zh-CN424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424537/index.html">Sberbank推出了自己的运营商SberMobile</a></li>
<li><a href="../zh-CN424539/index.html">Java 11：String中的新增功能</a></li>
<li><a href="../zh-CN424541/index.html">UGJ 2018惨败故事：如何制作没人喜欢的游戏（不要做！）</a></li>
<li><a href="../zh-CN424543/index.html">Java 11 / JDK 11：常规可用性</a></li>
<li><a href="../zh-CN424551/index.html">暖管：关于磁性音频技术的五种法莱卡</a></li>
<li><a href="../zh-CN424555/index.html">Node.js手册，第7部分：异步编程</a></li>
<li><a href="../zh-CN424557/index.html">Node.js指南，第8部分：HTTP和WebSocket协议</a></li>
<li><a href="../zh-CN424559/index.html">大数据抵抗1或难以捉摸的乔。 互联网匿名，反检测，针对您和您的反跟踪</a></li>
<li><a href="../zh-CN424563/index.html">直线将对话的详细信息发送给陌生人</a></li>
<li><a href="../zh-CN424565/index.html">概述：房地产场所的3D扫描</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>