<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèæ üë®üèª üçò UI-Autotests: Wie es geht, lohnt sich nicht üßëüèø‚Äçü§ù‚Äçüßëüèº ‚öôÔ∏è üëâüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Mein Name ist Vitaliy Kotov, ich arbeite in der Testabteilung von Badoo. Ich schreibe viele automatische UI-Tests, aber ich arbeite noch m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UI-Autotests: Wie es geht, lohnt sich nicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/419419/">  Hallo Habr.  Mein Name ist Vitaliy Kotov, ich arbeite in der Testabteilung von Badoo.  Ich schreibe viele automatische UI-Tests, aber ich arbeite noch mehr mit denen zusammen, die dies vor nicht allzu langer Zeit getan haben und es noch nicht geschafft haben, auf alle Rechen zu treten. <br><br>  Nachdem ich meine eigenen Erfahrungen und Beobachtungen anderer Leute hinzugef√ºgt hatte, beschloss ich, f√ºr Sie eine Sammlung von ‚ÄûWie man Tests schreibt, lohnt sich nicht‚Äú vorzubereiten.  Ich habe jedes Beispiel mit einer detaillierten Beschreibung, Codebeispielen und Screenshots unterst√ºtzt. <br><br>  Der Artikel wird f√ºr Anf√§nger von UI-Tests interessant sein, aber Oldtimer in diesem Thema werden wahrscheinlich etwas Neues lernen oder einfach nur l√§cheln und sich "in ihrer Jugend" an sich selbst erinnern.  :) :) <br><br>  Lass uns gehen! <br><br><img width="651" src="https://habrastorage.org/webt/gn/un/vn/gnunvna-dpyr8dzj9gwsh-xinlm.jpeg"><br><br><a name="habracut"></a><br><h2>  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Locators ohne Attribute</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberpr√ºfen Sie, ob ein Artikel fehlt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchen Sie nach einem Artikel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuf√§llige Daten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomizit√§t von Tests (Teil 1)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomizit√§t von Tests (Teil 2)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler beim Klicken auf ein vorhandenes Element</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlertext</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> </li></ul><a name="locators"></a><br><h2>  Locators ohne Attribute </h2><br>  Beginnen wir mit einem einfachen Beispiel.  Da es sich um UI-Tests handelt, spielen Locators eine wichtige Rolle.  Ein Locator ist eine Zeile, die nach einer bestimmten Regel zusammengesetzt ist und ein oder mehrere XML-Elemente (insbesondere HTML-Elemente) beschreibt. <br><br>  Es gibt verschiedene Arten von Locatoren.  Beispielsweise werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Locators</a> zum Kaskadieren von Stylesheets verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XPath-Locators</a> werden zum Arbeiten mit XML-Dokumenten verwendet.  Usw. <br><br>  Eine vollst√§ndige Liste der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selen</a> verwendeten Locator-Typen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seleniumhq.github.io</a> . <br><br>  In UI-Tests werden Locators verwendet, um die Elemente zu beschreiben, mit denen der Treiber interagieren soll. <br><br>  In fast jedem Browser-Inspektor ist es m√∂glich, das f√ºr uns interessante Element auszuw√§hlen und seinen XPath zu kopieren.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img width="650" src="https://habrastorage.org/webt/mw/oi/fz/mwoifzz6ukpjltmexvq6sasxw2c.png"><br><br>  Es stellt sich heraus, ein solcher Locator: <br><br> <code>/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a <br></code> <br>  Es scheint, dass an einem solchen Ortungsger√§t nichts falsch ist.  Schlie√ülich k√∂nnen wir es in einer Konstanten oder einem Feld der Klasse speichern, die durch ihren Namen die Essenz des Elements vermitteln: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FindBy</span></span>(xpath = <span class="hljs-string"><span class="hljs-string">"/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WebElement createAccountButton;</code> </pre><br>  Und wickeln Sie den entsprechenden Fehlertext ein, falls das Element nicht gefunden wird: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCreateAccountButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ By by = By.xpath(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAccountButton); WebDriverWait wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebDriverWait(driver, timeoutInSeconds); wait .withMessage(‚ÄúCannot find Create Account button.‚Äù) .until( ExpectedConditions.presenceOfElementLocated(by) ); }</code> </pre><br>  Dieser Ansatz hat ein Plus: Es ist nicht erforderlich, XPath zu lernen. <br><br>  Es gibt jedoch eine Reihe von Nachteilen.  Erstens gibt es beim √Ñndern des Layouts keine Garantie daf√ºr, dass das Element auf einem solchen Locator gleich bleibt.  Es ist m√∂glich, dass ein anderer seinen Platz einnimmt, was zu unvorhergesehenen Umst√§nden f√ºhrt.  Zweitens besteht die Aufgabe von Autotests darin, nach Fehlern zu suchen und Layout√§nderungen nicht zu √ºberwachen.  Daher sollte das Hinzuf√ºgen eines Wrappers oder anderer Elemente h√∂her im Baum unsere Tests nicht beeinflussen.  Andernfalls ben√∂tigen wir viel Zeit, um die Locators zu aktualisieren. <br><br>  Fazit: Sie sollten Locators erstellen, die das Element korrekt beschreiben und gegen sich √§ndernde Layouts au√üerhalb des getesteten Teils unserer Anwendung resistent sind.  Sie k√∂nnen beispielsweise an ein oder mehrere Attribute eines Elements binden: <br><br> <code>//a[@rel=‚ÄùcreateAccount‚Äù] <br></code> <br>  Ein solcher Locator ist im Code leichter zu erkennen und bricht nur ab, wenn "rel" verschwindet. <br><br>  Ein weiteres Plus eines solchen Locators ist die M√∂glichkeit, im Vorlagen-Repository mit dem angegebenen Attribut zu suchen.  Aber worauf ist zu achten, wenn der Locator im Originalbeispiel aussieht?  :) :) <br><br>  Wenn die Elemente anfangs in der Anwendung keine Attribute haben oder automatisch festgelegt werden (z. B. aufgrund der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschleierung von</a> Klassen), sollten Sie dies mit den Entwicklern besprechen.  Sie sollten nicht weniger an der Automatisierung von Produkttests interessiert sein und werden Sie sicherlich treffen und eine L√∂sung anbieten. <br><a name="no_element"></a><br><h2>  √úberpr√ºfen Sie, ob ein Artikel fehlt </h2><br>  Jeder Badoo-Benutzer hat sein eigenes Profil.  Es enth√§lt Informationen √ºber den Benutzer: (Name, Alter, Fotos) und Informationen dar√ºber, mit wem der Benutzer chatten m√∂chte.  Dar√ºber hinaus ist es m√∂glich, Ihre Interessen anzugeben. <br><br>  Angenommen, wir hatten einmal einen Fehler (obwohl dies nat√ºrlich nicht so ist :)).  Der Benutzer in seinem Profil hat Interessen ausgew√§hlt.  Da er kein geeignetes Interesse aus der Liste fand, entschied er sich, auf "Mehr" zu klicken, um die Liste zu aktualisieren. <br><br>  Erwartetes Verhalten: Alte Interessen sollten verschwinden, neue sollten auftauchen.  Stattdessen tauchte ein ‚Äûunerwarteter Fehler‚Äú auf: <br><br><img width="550" src="https://habrastorage.org/webt/tz/fp/lt/tzfpltsr9rkjpk-qtmoj4ustqjc.png"><br><br>  Es stellte sich heraus, dass auf der Serverseite ein Problem auftrat, die Antwort nicht dieselbe war und der Client diese Angelegenheit durch Anzeigen einer Benachrichtigung verarbeitete. <br><br>  Unsere Aufgabe ist es, einen Autotest zu schreiben, der diesen Fall √ºberpr√ºft. <br><br>  Wir schreiben ungef√§hr das folgende Skript: <br><br><ul><li>  Profil √∂ffnen </li><li>  Offene Interessenliste </li><li>  Klicken Sie auf die Schaltfl√§che "Mehr" </li><li>  Stellen Sie sicher, dass der Fehler nicht aufgetreten ist (z. B. gibt es kein div.error-Element). </li></ul><br>  Wir f√ºhren einen solchen Test durch.  Folgendes passiert jedoch: Nach einigen Tagen / Monaten / Jahren tritt der Fehler erneut auf, obwohl der Test nichts abf√§ngt.  Warum? <br><br>  Es ist ganz einfach: W√§hrend des erfolgreichen Bestehens des Tests hat sich der Locator des Elements ge√§ndert, mit dem wir nach dem Fehlertext gesucht haben.  Es gab ein Refactoring der Vorlagen und anstelle der Klasse "error" haben wir die Klasse "error_new" erhalten. <br><br>  W√§hrend des Refactorings funktionierte der Test wie erwartet weiter.  Das div.error-Element wurde nicht angezeigt, es gab keinen Grund f√ºr den Fall.  Aber jetzt existiert das Element "div.error" √ºberhaupt nicht - daher wird der Test niemals fehlschlagen, egal was in der Anwendung passiert. <br><br>  Fazit: Es ist besser, die Funktionsf√§higkeit der Schnittstelle mit Positivpr√ºfungen zu testen.  In unserem Beispiel sollten wir erwarten, dass sich die Liste der Interessen ge√§ndert hat. <br><br>  Es gibt Situationen, in denen ein negativer Test nicht durch einen positiven ersetzt werden kann.  Wenn Sie beispielsweise mit einem Element interagieren, geschieht in einer ‚Äûguten‚Äú Situation nichts, und in einer ‚Äûschlechten‚Äú Situation tritt ein Fehler auf.  In diesem Fall sollten Sie eine M√∂glichkeit finden, ein ‚Äûschlechtes‚Äú Szenario zu simulieren und auch einen Autotest darauf zu schreiben.  Auf diese Weise √ºberpr√ºfen wir, ob das Fehlerelement im negativen Fall angezeigt wird, und √ºberwachen damit die Relevanz des Locators. <br><a name="element_exists"></a><br><h2>  Suchen Sie nach einem Artikel </h2><br>  Wie kann sichergestellt werden, dass die Testinteraktion mit der Schnittstelle erfolgreich war und alles funktioniert?  Dies zeigt sich am h√§ufigsten an den √Ñnderungen, die an dieser Schnittstelle vorgenommen wurden. <br><br>  Betrachten Sie ein Beispiel.  Sie m√ºssen sicherstellen, dass eine Nachricht beim Senden im Chat angezeigt wird: <br><br><img width="350" src="https://habrastorage.org/webt/ac/uy/ww/acuywwe6rttek93vzdcf0n66th4.png"><br><br>  Das Skript sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><ul><li>  Benutzerprofil √∂ffnen </li><li>  √ñffnen Sie den Chat mit ihm </li><li>  eine Nachricht schreiben </li><li>  Senden </li><li>  Warten Sie, bis die Nachricht angezeigt wird. </li></ul><br>  Wir beschreiben ein solches Szenario in unserem Test.  Angenommen, eine Chat-Nachricht entspricht einem Locator: <br><br> <code>p.message_text <br></code> <br>  So √ºberpr√ºfen wir, ob das Element angezeigt wird: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">'p.message_text'</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find sent message."</span></span>);</code> </pre><br>  Wenn unser Warten funktioniert, ist alles in Ordnung: Chat-Nachrichten werden gezeichnet. <br><br>  Wie Sie vielleicht vermutet haben, wird das Senden von Chat-Nachrichten nach einer Weile unterbrochen, aber unser Test funktioniert weiterhin ohne Unterbrechungen.  Lass es uns richtig machen. <br><br>  Es stellt sich heraus, dass am Tag zuvor ein neues Element im Chat angezeigt wurde: ein Text, der den Benutzer auffordert, die Nachricht hervorzuheben, wenn sie pl√∂tzlich unbemerkt blieb: <br><br><img width="550" src="https://habrastorage.org/webt/ie/yc/82/ieyc82alpp-8kcoblkwyvup60my.png"><br><br>  Und am lustigsten ist, dass es auch unter unseren Locator f√§llt.  Nur hat es eine zus√§tzliche Klasse, die es von gesendeten Nachrichten unterscheidet: <br><br> <code>p.message_text.highlight <br></code> <br>  Unser Test wurde nicht unterbrochen, als dieser Block angezeigt wurde, aber die √úberpr√ºfung "Warten auf das Erscheinen der Nachricht" war nicht mehr relevant.  Das Element, das ein Indikator f√ºr eine erfolgreiche Veranstaltung war, ist jetzt immer da. <br><br>  Schlussfolgerung: Wenn die Logik des Tests auf der √úberpr√ºfung des Erscheinungsbilds eines Elements basiert, muss vor unserer Interaktion mit der Benutzeroberfl√§che √ºberpr√ºft werden, ob es kein solches Element gibt. <br><br><ul><li>  Benutzerprofil √∂ffnen </li><li>  √ñffnen Sie den Chat mit ihm </li><li>  <b>Stellen Sie sicher, dass keine Nachrichten gesendet wurden</b> </li><li>  eine Nachricht schreiben </li><li>  Senden </li><li>  Warten Sie, bis die Nachricht angezeigt wird. </li></ul><br><a name="random_data"></a><h2>  Zuf√§llige Daten </h2><br>  Sehr oft arbeiten UI-Tests mit Formularen, in die sie Daten eingeben.  Zum Beispiel haben wir ein Anmeldeformular: <br><br><img width="550" src="https://habrastorage.org/webt/dd/gv/z2/ddgvz2ss4i8juyv7c5jrgqahd84.png"><br><br>  Daten f√ºr solche Tests k√∂nnen in Konfigurationen gespeichert oder in einem Test fest codiert werden.  Aber manchmal kommt mir der Gedanke: Warum nicht die Daten randomisieren?  Das ist gut, wir werden mehr F√§lle abdecken! <br><br>  Mein Rat: nicht.  Und jetzt sage ich dir warum. <br><br>  Angenommen, unser Test ist bei Badoo registriert.  Wir entscheiden, dass wir das Geschlecht des Benutzers zuf√§llig ausw√§hlen.  Zum Zeitpunkt des Testschreibens ist der Registrierungsablauf f√ºr das M√§dchen und den Jungen nicht anders, sodass unser Test erfolgreich bestanden wurde. <br><br>  Stellen Sie sich nun vor, dass der Registrierungsfluss nach einer Weile anders wird.  Zum Beispiel geben wir dem M√§dchen sofort nach der Registrierung kostenlose Boni, √ºber die wir sie mit einem speziellen Overlay informieren. <br><br>  Im Test gibt es keine Logik zum Schlie√üen der √úberlagerung, diese st√∂rt jedoch alle weiteren im Test vorgeschriebenen Aktionen.  Wir bekommen einen Test, der in 50% der F√§lle f√§llt.  Jedes Automatisierungstool best√§tigt, dass UI-Tests von Natur aus nicht von Natur aus stabil sind.  Und das ist normal, man muss damit leben und st√§ndig zwischen redundanter Logik "f√ºr alle Gelegenheiten" (die die Lesbarkeit des Codes merklich beeintr√§chtigt und dessen Unterst√ºtzung erschwert) und dieser Instabilit√§t selbst wechseln. <br><br>  Wenn der Test das n√§chste Mal f√§llt, haben wir m√∂glicherweise keine Zeit, uns damit zu befassen.  Wir starten es einfach neu und sehen, dass es vorbei ist.  Wir entscheiden, dass in unserer Anwendung alles so funktioniert, wie es sollte, und das Ding ist ein instabiler Test.  Und beruhige dich. <br><br>  Nun gehen wir weiter.  Was ist, wenn diese √úberlagerung bricht?  Der Test wird in 50% der F√§lle weiterhin bestanden, was die Suche nach dem Problem erheblich verz√∂gert. <br><br>  Und es ist gut, wenn wir aufgrund der Randomisierung von Daten eine "50 mal 50" -Situation erstellen.  Aber es passiert anders.  Vor der Registrierung wurde beispielsweise ein Kennwort mit mindestens drei Zeichen als akzeptabel angesehen.  Wir schreiben Code, der ein zuf√§lliges Passwort enth√§lt, das nicht k√ºrzer als drei Zeichen ist (manchmal drei Zeichen und manchmal mehr).  Und dann √§ndert sich die Regel - und das Passwort sollte bereits mindestens vier Zeichen enthalten.  Wie hoch ist in diesem Fall die Wahrscheinlichkeit eines Sturzes?  Und wenn unser Test einen echten Fehler entdeckt, wie schnell werden wir ihn herausfinden? <br><br>  Es ist besonders schwierig, mit Tests zu arbeiten, bei denen viele zuf√§llige Daten eingegeben werden: Name, Geschlecht, Passwort usw. In diesem Fall gibt es auch viele verschiedene Kombinationen, und wenn in einer von ihnen ein Fehler auftritt, ist dies normalerweise schwer zu bemerken. <br><br>  Fazit  Wie ich oben geschrieben habe, ist das Randomisieren von Daten schlecht.  Es ist nat√ºrlich besser, mehr F√§lle auf Kosten der Datenanbieter abzudecken, ohne die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√Ñquivalenzklassen</a> zu vergessen.  Das Bestehen von Tests dauert l√§nger, aber Sie k√∂nnen dagegen ank√§mpfen.  Wir werden jedoch sicher sein, dass ein Problem erkannt wird. <br><a name="atom_tests_1"></a><br><h2>  Atomizit√§t von Tests (Teil 1) </h2><br>  Schauen wir uns das folgende Beispiel an.  Wir schreiben einen Test, der den Z√§hler der Benutzer in der Fu√üzeile √ºberpr√ºft. <br><br><img width="651" src="https://habrastorage.org/webt/9j/n4/ws/9jn4wsd3jlh_wdnoiwrkjdfho9s.png"><br><br>  Das Szenario ist einfach: <br><br><ul><li>  Anwendung √∂ffnen </li><li>  Fu√üzeilenz√§hler finden </li><li>  Stellen Sie sicher, dass es sichtbar ist </li></ul><br>  Wir nennen einen solchen Test testFooterCounter und f√ºhren ihn aus.  Dann muss √ºberpr√ºft werden, ob der Z√§hler keine Null anzeigt.  Wir f√ºgen diesen Test einem vorhandenen Test hinzu. Warum nicht? <br><br>  Dann muss jedoch √ºberpr√ºft werden, ob in der Fu√üzeile ein Link zur Beschreibung des Projekts vorhanden ist (der Link "√úber uns").  Einen neuen Test schreiben oder zu einem bestehenden hinzuf√ºgen?  Im Falle eines neuen Tests m√ºssen wir die Anwendung erneut starten, den Benutzer vorbereiten (wenn wir die Fu√üzeile auf der autorisierten Seite √ºberpr√ºfen), uns anmelden - im Allgemeinen wertvolle Zeit verbringen.  In einer solchen Situation scheint es eine gute Idee zu sein, den Test in testFooterCounterAndLinks umzubenennen. <br><br>  Einerseits hat dieser Ansatz Vorteile: Zeit sparen, alle √úberpr√ºfungen eines Teils unserer Anwendung (in diesem Fall Fu√üzeile) an einem Ort speichern. <br><br>  Aber es gibt ein merkliches Minus.  Wenn der Test beim ersten Test fehlschl√§gt, wird der Rest der Komponente nicht √ºberpr√ºft.  Angenommen, ein Test st√ºrzt in einem Zweig ab, nicht aufgrund von Instabilit√§t, sondern aufgrund eines Fehlers.  Was zu tun ist?  Eine Aufgabe zur√ºckgeben, die nur dieses Problem beschreibt?  Dann laufen wir Gefahr, eine Aufgabe zu bekommen, bei der nur dieser Fehler behoben wird, f√ºhren einen Test durch und stellen fest, dass die Komponente an einer anderen Stelle auch weiter defekt ist.  Und es kann viele solcher Iterationen geben.  Das Hin- und Herwerfen eines Tickets nimmt in diesem Fall viel Zeit in Anspruch und ist unwirksam. <br><br>  Fazit: Wenn m√∂glich, zerst√§uben Sie die Schecks.  In diesem Fall √ºberpr√ºfen wir alle anderen, auch wenn in einem Fall ein Problem vorliegt.  Und wenn Sie das Ticket zur√ºckgeben m√ºssen, k√∂nnen wir sofort alle Problembereiche beschreiben. <br><a name="atom_tests_2"></a><br><h2>  Atomizit√§t von Tests (Teil 2) </h2><br>  Betrachten Sie ein anderes Beispiel.  Wir schreiben einen Chat-Test, der die folgende Logik √ºberpr√ºft.  Wenn Benutzer gegenseitiges Mitgef√ºhl haben, wird im Chat der folgende Promoblock angezeigt: <br><br><img width="550" src="https://habrastorage.org/webt/2o/v8/kp/2ov8kp9mojel1g_txzatwy91nig.png"><br><br>  Das Szenario ist wie folgt: <br><br><ul><li>  Stimmen Sie von Benutzer A f√ºr Benutzer B ab </li><li>  Stimmen Sie von Benutzer B f√ºr Benutzer A ab </li><li>  Benutzer A offener Chat mit Benutzer B. </li><li>  Vergewissern Sie sich, dass das Ger√§t installiert ist </li></ul><br>  F√ºr einige Zeit funktioniert der Test erfolgreich, aber dann passiert Folgendes ... Nein, diesmal √ºbersieht der Test keinen Fehler.  :) :) <br><br>  Nach einiger Zeit stellen wir fest, dass es einen weiteren Fehler gibt, der nicht mit unserem Test zusammenh√§ngt: Wenn Sie einen Chat √∂ffnen, ihn sofort schlie√üen und wieder √∂ffnen, verschwindet der Block.  Nicht der offensichtlichste Fall, und im Test haben wir das nat√ºrlich nicht vorausgesehen.  Aber wir entscheiden, dass wir es auch abdecken m√ºssen. <br><br>  Die gleiche Frage stellt sich: Schreiben Sie einen anderen Test oder f√ºgen Sie einen Test in einen vorhandenen ein?  Ein neues zu schreiben scheint unangemessen, da er in 99% der F√§lle dasselbe tut wie das bestehende.  Und wir beschlie√üen, den Test zu dem bereits vorhandenen Test hinzuzuf√ºgen: <br><br><ul><li>  Stimmen Sie von Benutzer A f√ºr Benutzer B ab </li><li>  Stimmen Sie von Benutzer B f√ºr Benutzer A ab </li><li>  Benutzer A offener Chat mit Benutzer B. </li><li>  Vergewissern Sie sich, dass das Ger√§t installiert ist </li><li>  <b>Chat schlie√üen</b> </li><li>  <b>Chat √∂ffnen</b> </li><li>  Vergewissern Sie sich, dass das Ger√§t installiert ist </li></ul><br>  Ein Problem kann auftreten, wenn wir beispielsweise einen Test nach langer Zeit umgestalten.  Beispielsweise wird ein Projekt neu gestaltet - und Sie m√ºssen viele Tests neu schreiben. <br><br>  Wir werden den Test √∂ffnen und versuchen, uns daran zu erinnern, was er √ºberpr√ºft.  Ein Test hei√üt beispielsweise testPromoAfterMutualAttraction.  Verstehen wir, warum das √ñffnen und Schlie√üen des Chats am Ende geschrieben wird?  H√∂chstwahrscheinlich nicht.  Vor allem, wenn dieser Test nicht von uns geschrieben wurde.  Werden wir dieses St√ºck verlassen?  Vielleicht ja, aber wenn es Probleme mit ihm gibt, werden wir ihn wahrscheinlich einfach l√∂schen.  Und die √úberpr√ºfung geht einfach verloren, weil ihre Bedeutung nicht offensichtlich ist. <br><br>  Ich sehe hier zwei L√∂sungen.  Erstens: F√ºhren Sie immer noch den zweiten Test durch und nennen Sie ihn testCheckBlockPresentAfterOpenAndCloseChat.  Mit einem solchen Namen wird klar, dass wir nicht nur eine bestimmte Reihe von Aktionen ausf√ºhren, sondern eine sehr bewusste √úberpr√ºfung durchf√ºhren, da es eine negative Erfahrung gab.  Die zweite L√∂sung besteht darin, einen detaillierten Kommentar in den Code zu schreiben, warum wir diesen Test in diesem speziellen Test durchf√ºhren.  Es ist auch ratsam, die Fehlernummer im Kommentar anzugeben. <br><a name="click_error"></a><br><h2>  Fehler beim Klicken auf ein vorhandenes Element </h2><br>  Das folgende Beispiel warf mir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Bbidox zu</a> , wof√ºr er ein gro√ües Plus im Karma ist! <br><br>  Es gibt eine sehr interessante Situation, wenn der Testcode bereits ... ein Framework wird.  Angenommen, wir haben eine Methode wie diese: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebElement button_element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForButtonToAppear(); button_element.click(); }</code> </pre><br>  Irgendwann passiert etwas Seltsames mit dieser Methode: Der Test st√ºrzt ab, wenn Sie versuchen, auf eine Schaltfl√§che zu klicken.  Wir √∂ffnen den Screenshot, der zum Zeitpunkt des Testabsturzes aufgenommen wurde, und sehen, dass der Screenshot eine Schaltfl√§che enth√§lt und die waitForButtonToAppear-Methode erfolgreich funktioniert hat.  Frage: Was ist los mit dem Klick? <br><br>  Das Schwierigste in dieser Situation ist, dass der Test manchmal erfolgreich sein kann.  :) :) <br><br>  Lass es uns richtig machen.  Angenommen, die im Beispiel betrachtete Schaltfl√§che befindet sich auf einer solchen √úberlagerung: <br><br><img width="550" src="https://habrastorage.org/webt/pe/77/bd/pe77bddhspi2hdw1eagnzk8iydm.png"><br><br>  Dies ist eine spezielle √úberlagerung, √ºber die ein Benutzer unserer Website Informationen √ºber sich selbst ausf√ºllen kann.  Wenn Sie auf die hervorgehobene √úberlagerungsschaltfl√§che klicken, wird der n√§chste Block gef√ºllt. <br><br>  F√ºgen wir zum Spa√ü eine zus√§tzliche OLOLO-Klasse f√ºr diese Schaltfl√§che hinzu: <br><br><img width="550" src="https://habrastorage.org/webt/ul/qv/fj/ulqvfjphig982sp-ntzfcmwdc0q.png"><br><br>  Danach klicken wir auf diese Schaltfl√§che.  Optisch hat sich nichts ge√§ndert, aber der Knopf selbst ist an Ort und Stelle geblieben: <br><br><img width="550" src="https://habrastorage.org/webt/86/os/3x/86os3xs2ycobeqm75psth6xuidk.png"><br><br>  Was ist passiert?  In der Tat, als JS den Block zu uns neu zeichnete, zeichnete er auch den Knopf neu.  Es ist immer noch auf demselben Locator verf√ºgbar, dies ist jedoch eine andere Schaltfl√§che.  Dies wird durch das Fehlen der von uns hinzugef√ºgten OLOLO-Klasse belegt. <br><br>  Im obigen Code speichern wir das Element in der Variablen $ element.  Wenn ein Element w√§hrend dieser Zeit neu generiert wird, ist es m√∂glicherweise nicht visuell sichtbar, aber Sie k√∂nnen nicht mehr darauf klicken - die click () -Methode schl√§gt fehl. <br><br>  Es gibt verschiedene L√∂sungen: <br><br><ul><li>  Wrap Click in Try Block und in Catch Rebuild Element </li><li>  F√ºgen Sie einem Attribut eine Schaltfl√§che hinzu, um zu signalisieren, dass es sich ge√§ndert hat </li></ul><br><a name="error_message"></a><h2>  Fehlertext </h2><br>  Schlie√ülich ein einfacher, aber nicht weniger wichtiger Punkt. <br><br>  Dieses Beispiel gilt nicht nur f√ºr UI-Tests, sondern tritt auch sehr h√§ufig in diesen auf.  Wenn Sie einen Test schreiben, befinden Sie sich normalerweise im Kontext des Geschehens: Sie beschreiben die √úberpr√ºfung nach der √úberpr√ºfung und verstehen deren Bedeutung.  Und Sie schreiben Fehlertexte im selben Kontext: <br><br><pre> <code class="java hljs">WebElement element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">"a.link"</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find button"</span></span>);</code> </pre><br>  Was k√∂nnte in diesem Code unverst√§ndlich sein?  Der Test erwartet das Erscheinen einer Taste und f√§llt nat√ºrlich ab, wenn sie nicht vorhanden ist. <br><br>  Stellen Sie sich nun vor, der Autor des Tests ist krankgeschrieben und sein Kollege k√ºmmert sich um die Tests.  Anschlie√üend l√∂scht er den TestQuestionsOnProfile-Test und schreibt die folgende Meldung: "Schaltfl√§che kann nicht gefunden werden".  Ein Kollege muss so schnell wie m√∂glich verstehen, was passiert, da die Ver√∂ffentlichung bald kommt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/pe/dv/bapedvs1g2gplrhebyipl0p7cl0.gif"></div><br><br>  Was wird er tun m√ºssen? <br><br>  Es ist sinnlos, die Seite zu √∂ffnen, auf die der Test gefallen ist, und den Locator "a.link" zu √ºberpr√ºfen - es gibt kein Element.  Daher m√ºssen Sie den Test sorgf√§ltig studieren und herausfinden, was er √ºberpr√ºft. <br><br>  Mit einem detaillierteren Fehlertext w√§re es viel einfacher: "Die Schaltfl√§che" Senden "in der Fragen√ºberlagerung kann nicht gefunden werden."  Mit einem solchen Fehler k√∂nnen Sie das Overlay sofort √∂ffnen und sehen, wohin die Schaltfl√§che gegangen ist. <br><br>  Ausgabe zwei.  Erstens lohnt es sich, den Fehlertext an eine beliebige Methode Ihres Testframeworks zu √ºbergeben, und es ist ein erforderlicher Parameter, damit keine Versuchung besteht, ihn zu vergessen.  Zweitens sollte der Fehlertext detailliert gemacht werden.  Dies bedeutet nicht immer, dass es lang sein sollte, es reicht aus, um klar zu machen, was im Test schief gelaufen ist. <br><br>  Wie kann man verstehen, dass der Fehlertext gut geschrieben ist?  Sehr einfach.  Stellen Sie sich vor, Ihre Anwendung ist fehlerhaft und Sie m√ºssen zu den Entwicklern gehen und erkl√§ren, was und wo fehlerhaft ist.  Wenn Sie ihnen nur sagen, was im Fehlertext geschrieben steht, werden sie dann verstehen? <br><a name="summary"></a><br><h2>  Zusammenfassung </h2><br>  Das Schreiben eines Testskripts ist oft eine interessante Aktivit√§t.  Gleichzeitig verfolgen wir viele Ziele.  Unsere Tests sollten: <br><br><ul><li>  decken Sie so viele F√§lle wie m√∂glich ab </li><li>  arbeite so schnell wie m√∂glich </li><li>  verstanden werden </li><li>  einfach erweitern </li><li>  leicht zu pflegen </li><li>  Pizza bestellen </li><li>  usw‚Ä¶ </li></ul><br>  Es ist besonders interessant, mit Tests in einem sich st√§ndig weiterentwickelnden und √§ndernden Projekt zu arbeiten, in dem sie st√§ndig aktualisiert werden m√ºssen: etwas hinzuf√ºgen und etwas schneiden.  Deshalb lohnt es sich, einige Punkte im Voraus zu √ºberdenken und nicht immer Entscheidungen zu treffen.  :) :) <br><br>  Ich hoffe, meine Tipps helfen Ihnen dabei, einige Probleme zu vermeiden und Sie in Fallstudien nachdenklicher zu machen.  Wenn das Publikum den Artikel mag, werde ich versuchen, einige langweiligere Beispiele zu sammeln.  In der Zwischenzeit - tsch√ºss! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419419/">https://habr.com/ru/post/de419419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419409/index.html">Neue Intel NUCs basierend auf Coffee Lake Prozessoren</a></li>
<li><a href="../de419411/index.html">√úber das Feuer in einem Wolkenkratzer. Kino und Realit√§t</a></li>
<li><a href="../de419413/index.html">Mei√üel - (nicht ganz) ein neuer Ansatz zur Entwicklung der digitalen Logik</a></li>
<li><a href="../de419415/index.html">Mattermost und Powershell - gro√üe Leistung oder kleine Automatisierung im Haushalt</a></li>
<li><a href="../de419417/index.html">GDPR: Datenmapping oder wie Kunden l√§ngst vergessene Laptops finden</a></li>
<li><a href="../de419423/index.html">Uns wird ein Echtzeitvideo ohne Friese und Zuckungen versprochen</a></li>
<li><a href="../de419425/index.html">Sicherheitswoche 29. Hacking Reddit, eine Brieftasche f√ºr Kryptow√§hrung und MikroTik-Router</a></li>
<li><a href="../de419427/index.html">Epson l√§dt alle zum Picknick f√ºr Geeks 2018 ein</a></li>
<li><a href="../de419429/index.html">Ich bin 57 und ich bin ein Scrum Master</a></li>
<li><a href="../de419433/index.html">DSW-Berichte - DeepSeeWeb Report Generator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>