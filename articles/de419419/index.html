<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏾 👨🏻 🍘 UI-Autotests: Wie es geht, lohnt sich nicht 🧑🏿‍🤝‍🧑🏼 ⚙️ 👉🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Mein Name ist Vitaliy Kotov, ich arbeite in der Testabteilung von Badoo. Ich schreibe viele automatische UI-Tests, aber ich arbeite noch m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UI-Autotests: Wie es geht, lohnt sich nicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/419419/">  Hallo Habr.  Mein Name ist Vitaliy Kotov, ich arbeite in der Testabteilung von Badoo.  Ich schreibe viele automatische UI-Tests, aber ich arbeite noch mehr mit denen zusammen, die dies vor nicht allzu langer Zeit getan haben und es noch nicht geschafft haben, auf alle Rechen zu treten. <br><br>  Nachdem ich meine eigenen Erfahrungen und Beobachtungen anderer Leute hinzugefügt hatte, beschloss ich, für Sie eine Sammlung von „Wie man Tests schreibt, lohnt sich nicht“ vorzubereiten.  Ich habe jedes Beispiel mit einer detaillierten Beschreibung, Codebeispielen und Screenshots unterstützt. <br><br>  Der Artikel wird für Anfänger von UI-Tests interessant sein, aber Oldtimer in diesem Thema werden wahrscheinlich etwas Neues lernen oder einfach nur lächeln und sich "in ihrer Jugend" an sich selbst erinnern.  :) :) <br><br>  Lass uns gehen! <br><br><img width="651" src="https://habrastorage.org/webt/gn/un/vn/gnunvna-dpyr8dzj9gwsh-xinlm.jpeg"><br><br><a name="habracut"></a><br><h2>  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Locators ohne Attribute</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überprüfen Sie, ob ein Artikel fehlt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchen Sie nach einem Artikel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zufällige Daten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomizität von Tests (Teil 1)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomizität von Tests (Teil 2)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler beim Klicken auf ein vorhandenes Element</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlertext</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> </li></ul><a name="locators"></a><br><h2>  Locators ohne Attribute </h2><br>  Beginnen wir mit einem einfachen Beispiel.  Da es sich um UI-Tests handelt, spielen Locators eine wichtige Rolle.  Ein Locator ist eine Zeile, die nach einer bestimmten Regel zusammengesetzt ist und ein oder mehrere XML-Elemente (insbesondere HTML-Elemente) beschreibt. <br><br>  Es gibt verschiedene Arten von Locatoren.  Beispielsweise werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Locators</a> zum Kaskadieren von Stylesheets verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XPath-Locators</a> werden zum Arbeiten mit XML-Dokumenten verwendet.  Usw. <br><br>  Eine vollständige Liste der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selen</a> verwendeten Locator-Typen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seleniumhq.github.io</a> . <br><br>  In UI-Tests werden Locators verwendet, um die Elemente zu beschreiben, mit denen der Treiber interagieren soll. <br><br>  In fast jedem Browser-Inspektor ist es möglich, das für uns interessante Element auszuwählen und seinen XPath zu kopieren.  Es sieht ungefähr so ​​aus: <br><br><img width="650" src="https://habrastorage.org/webt/mw/oi/fz/mwoifzz6ukpjltmexvq6sasxw2c.png"><br><br>  Es stellt sich heraus, ein solcher Locator: <br><br> <code>/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a <br></code> <br>  Es scheint, dass an einem solchen Ortungsgerät nichts falsch ist.  Schließlich können wir es in einer Konstanten oder einem Feld der Klasse speichern, die durch ihren Namen die Essenz des Elements vermitteln: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FindBy</span></span>(xpath = <span class="hljs-string"><span class="hljs-string">"/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WebElement createAccountButton;</code> </pre><br>  Und wickeln Sie den entsprechenden Fehlertext ein, falls das Element nicht gefunden wird: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCreateAccountButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ By by = By.xpath(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAccountButton); WebDriverWait wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebDriverWait(driver, timeoutInSeconds); wait .withMessage(“Cannot find Create Account button.”) .until( ExpectedConditions.presenceOfElementLocated(by) ); }</code> </pre><br>  Dieser Ansatz hat ein Plus: Es ist nicht erforderlich, XPath zu lernen. <br><br>  Es gibt jedoch eine Reihe von Nachteilen.  Erstens gibt es beim Ändern des Layouts keine Garantie dafür, dass das Element auf einem solchen Locator gleich bleibt.  Es ist möglich, dass ein anderer seinen Platz einnimmt, was zu unvorhergesehenen Umständen führt.  Zweitens besteht die Aufgabe von Autotests darin, nach Fehlern zu suchen und Layoutänderungen nicht zu überwachen.  Daher sollte das Hinzufügen eines Wrappers oder anderer Elemente höher im Baum unsere Tests nicht beeinflussen.  Andernfalls benötigen wir viel Zeit, um die Locators zu aktualisieren. <br><br>  Fazit: Sie sollten Locators erstellen, die das Element korrekt beschreiben und gegen sich ändernde Layouts außerhalb des getesteten Teils unserer Anwendung resistent sind.  Sie können beispielsweise an ein oder mehrere Attribute eines Elements binden: <br><br> <code>//a[@rel=”createAccount”] <br></code> <br>  Ein solcher Locator ist im Code leichter zu erkennen und bricht nur ab, wenn "rel" verschwindet. <br><br>  Ein weiteres Plus eines solchen Locators ist die Möglichkeit, im Vorlagen-Repository mit dem angegebenen Attribut zu suchen.  Aber worauf ist zu achten, wenn der Locator im Originalbeispiel aussieht?  :) :) <br><br>  Wenn die Elemente anfangs in der Anwendung keine Attribute haben oder automatisch festgelegt werden (z. B. aufgrund der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschleierung von</a> Klassen), sollten Sie dies mit den Entwicklern besprechen.  Sie sollten nicht weniger an der Automatisierung von Produkttests interessiert sein und werden Sie sicherlich treffen und eine Lösung anbieten. <br><a name="no_element"></a><br><h2>  Überprüfen Sie, ob ein Artikel fehlt </h2><br>  Jeder Badoo-Benutzer hat sein eigenes Profil.  Es enthält Informationen über den Benutzer: (Name, Alter, Fotos) und Informationen darüber, mit wem der Benutzer chatten möchte.  Darüber hinaus ist es möglich, Ihre Interessen anzugeben. <br><br>  Angenommen, wir hatten einmal einen Fehler (obwohl dies natürlich nicht so ist :)).  Der Benutzer in seinem Profil hat Interessen ausgewählt.  Da er kein geeignetes Interesse aus der Liste fand, entschied er sich, auf "Mehr" zu klicken, um die Liste zu aktualisieren. <br><br>  Erwartetes Verhalten: Alte Interessen sollten verschwinden, neue sollten auftauchen.  Stattdessen tauchte ein „unerwarteter Fehler“ auf: <br><br><img width="550" src="https://habrastorage.org/webt/tz/fp/lt/tzfpltsr9rkjpk-qtmoj4ustqjc.png"><br><br>  Es stellte sich heraus, dass auf der Serverseite ein Problem auftrat, die Antwort nicht dieselbe war und der Client diese Angelegenheit durch Anzeigen einer Benachrichtigung verarbeitete. <br><br>  Unsere Aufgabe ist es, einen Autotest zu schreiben, der diesen Fall überprüft. <br><br>  Wir schreiben ungefähr das folgende Skript: <br><br><ul><li>  Profil öffnen </li><li>  Offene Interessenliste </li><li>  Klicken Sie auf die Schaltfläche "Mehr" </li><li>  Stellen Sie sicher, dass der Fehler nicht aufgetreten ist (z. B. gibt es kein div.error-Element). </li></ul><br>  Wir führen einen solchen Test durch.  Folgendes passiert jedoch: Nach einigen Tagen / Monaten / Jahren tritt der Fehler erneut auf, obwohl der Test nichts abfängt.  Warum? <br><br>  Es ist ganz einfach: Während des erfolgreichen Bestehens des Tests hat sich der Locator des Elements geändert, mit dem wir nach dem Fehlertext gesucht haben.  Es gab ein Refactoring der Vorlagen und anstelle der Klasse "error" haben wir die Klasse "error_new" erhalten. <br><br>  Während des Refactorings funktionierte der Test wie erwartet weiter.  Das div.error-Element wurde nicht angezeigt, es gab keinen Grund für den Fall.  Aber jetzt existiert das Element "div.error" überhaupt nicht - daher wird der Test niemals fehlschlagen, egal was in der Anwendung passiert. <br><br>  Fazit: Es ist besser, die Funktionsfähigkeit der Schnittstelle mit Positivprüfungen zu testen.  In unserem Beispiel sollten wir erwarten, dass sich die Liste der Interessen geändert hat. <br><br>  Es gibt Situationen, in denen ein negativer Test nicht durch einen positiven ersetzt werden kann.  Wenn Sie beispielsweise mit einem Element interagieren, geschieht in einer „guten“ Situation nichts, und in einer „schlechten“ Situation tritt ein Fehler auf.  In diesem Fall sollten Sie eine Möglichkeit finden, ein „schlechtes“ Szenario zu simulieren und auch einen Autotest darauf zu schreiben.  Auf diese Weise überprüfen wir, ob das Fehlerelement im negativen Fall angezeigt wird, und überwachen damit die Relevanz des Locators. <br><a name="element_exists"></a><br><h2>  Suchen Sie nach einem Artikel </h2><br>  Wie kann sichergestellt werden, dass die Testinteraktion mit der Schnittstelle erfolgreich war und alles funktioniert?  Dies zeigt sich am häufigsten an den Änderungen, die an dieser Schnittstelle vorgenommen wurden. <br><br>  Betrachten Sie ein Beispiel.  Sie müssen sicherstellen, dass eine Nachricht beim Senden im Chat angezeigt wird: <br><br><img width="350" src="https://habrastorage.org/webt/ac/uy/ww/acuywwe6rttek93vzdcf0n66th4.png"><br><br>  Das Skript sieht ungefähr so ​​aus: <br><br><ul><li>  Benutzerprofil öffnen </li><li>  Öffnen Sie den Chat mit ihm </li><li>  eine Nachricht schreiben </li><li>  Senden </li><li>  Warten Sie, bis die Nachricht angezeigt wird. </li></ul><br>  Wir beschreiben ein solches Szenario in unserem Test.  Angenommen, eine Chat-Nachricht entspricht einem Locator: <br><br> <code>p.message_text <br></code> <br>  So überprüfen wir, ob das Element angezeigt wird: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">'p.message_text'</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find sent message."</span></span>);</code> </pre><br>  Wenn unser Warten funktioniert, ist alles in Ordnung: Chat-Nachrichten werden gezeichnet. <br><br>  Wie Sie vielleicht vermutet haben, wird das Senden von Chat-Nachrichten nach einer Weile unterbrochen, aber unser Test funktioniert weiterhin ohne Unterbrechungen.  Lass es uns richtig machen. <br><br>  Es stellt sich heraus, dass am Tag zuvor ein neues Element im Chat angezeigt wurde: ein Text, der den Benutzer auffordert, die Nachricht hervorzuheben, wenn sie plötzlich unbemerkt blieb: <br><br><img width="550" src="https://habrastorage.org/webt/ie/yc/82/ieyc82alpp-8kcoblkwyvup60my.png"><br><br>  Und am lustigsten ist, dass es auch unter unseren Locator fällt.  Nur hat es eine zusätzliche Klasse, die es von gesendeten Nachrichten unterscheidet: <br><br> <code>p.message_text.highlight <br></code> <br>  Unser Test wurde nicht unterbrochen, als dieser Block angezeigt wurde, aber die Überprüfung "Warten auf das Erscheinen der Nachricht" war nicht mehr relevant.  Das Element, das ein Indikator für eine erfolgreiche Veranstaltung war, ist jetzt immer da. <br><br>  Schlussfolgerung: Wenn die Logik des Tests auf der Überprüfung des Erscheinungsbilds eines Elements basiert, muss vor unserer Interaktion mit der Benutzeroberfläche überprüft werden, ob es kein solches Element gibt. <br><br><ul><li>  Benutzerprofil öffnen </li><li>  Öffnen Sie den Chat mit ihm </li><li>  <b>Stellen Sie sicher, dass keine Nachrichten gesendet wurden</b> </li><li>  eine Nachricht schreiben </li><li>  Senden </li><li>  Warten Sie, bis die Nachricht angezeigt wird. </li></ul><br><a name="random_data"></a><h2>  Zufällige Daten </h2><br>  Sehr oft arbeiten UI-Tests mit Formularen, in die sie Daten eingeben.  Zum Beispiel haben wir ein Anmeldeformular: <br><br><img width="550" src="https://habrastorage.org/webt/dd/gv/z2/ddgvz2ss4i8juyv7c5jrgqahd84.png"><br><br>  Daten für solche Tests können in Konfigurationen gespeichert oder in einem Test fest codiert werden.  Aber manchmal kommt mir der Gedanke: Warum nicht die Daten randomisieren?  Das ist gut, wir werden mehr Fälle abdecken! <br><br>  Mein Rat: nicht.  Und jetzt sage ich dir warum. <br><br>  Angenommen, unser Test ist bei Badoo registriert.  Wir entscheiden, dass wir das Geschlecht des Benutzers zufällig auswählen.  Zum Zeitpunkt des Testschreibens ist der Registrierungsablauf für das Mädchen und den Jungen nicht anders, sodass unser Test erfolgreich bestanden wurde. <br><br>  Stellen Sie sich nun vor, dass der Registrierungsfluss nach einer Weile anders wird.  Zum Beispiel geben wir dem Mädchen sofort nach der Registrierung kostenlose Boni, über die wir sie mit einem speziellen Overlay informieren. <br><br>  Im Test gibt es keine Logik zum Schließen der Überlagerung, diese stört jedoch alle weiteren im Test vorgeschriebenen Aktionen.  Wir bekommen einen Test, der in 50% der Fälle fällt.  Jedes Automatisierungstool bestätigt, dass UI-Tests von Natur aus nicht von Natur aus stabil sind.  Und das ist normal, man muss damit leben und ständig zwischen redundanter Logik "für alle Gelegenheiten" (die die Lesbarkeit des Codes merklich beeinträchtigt und dessen Unterstützung erschwert) und dieser Instabilität selbst wechseln. <br><br>  Wenn der Test das nächste Mal fällt, haben wir möglicherweise keine Zeit, uns damit zu befassen.  Wir starten es einfach neu und sehen, dass es vorbei ist.  Wir entscheiden, dass in unserer Anwendung alles so funktioniert, wie es sollte, und das Ding ist ein instabiler Test.  Und beruhige dich. <br><br>  Nun gehen wir weiter.  Was ist, wenn diese Überlagerung bricht?  Der Test wird in 50% der Fälle weiterhin bestanden, was die Suche nach dem Problem erheblich verzögert. <br><br>  Und es ist gut, wenn wir aufgrund der Randomisierung von Daten eine "50 mal 50" -Situation erstellen.  Aber es passiert anders.  Vor der Registrierung wurde beispielsweise ein Kennwort mit mindestens drei Zeichen als akzeptabel angesehen.  Wir schreiben Code, der ein zufälliges Passwort enthält, das nicht kürzer als drei Zeichen ist (manchmal drei Zeichen und manchmal mehr).  Und dann ändert sich die Regel - und das Passwort sollte bereits mindestens vier Zeichen enthalten.  Wie hoch ist in diesem Fall die Wahrscheinlichkeit eines Sturzes?  Und wenn unser Test einen echten Fehler entdeckt, wie schnell werden wir ihn herausfinden? <br><br>  Es ist besonders schwierig, mit Tests zu arbeiten, bei denen viele zufällige Daten eingegeben werden: Name, Geschlecht, Passwort usw. In diesem Fall gibt es auch viele verschiedene Kombinationen, und wenn in einer von ihnen ein Fehler auftritt, ist dies normalerweise schwer zu bemerken. <br><br>  Fazit  Wie ich oben geschrieben habe, ist das Randomisieren von Daten schlecht.  Es ist natürlich besser, mehr Fälle auf Kosten der Datenanbieter abzudecken, ohne die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Äquivalenzklassen</a> zu vergessen.  Das Bestehen von Tests dauert länger, aber Sie können dagegen ankämpfen.  Wir werden jedoch sicher sein, dass ein Problem erkannt wird. <br><a name="atom_tests_1"></a><br><h2>  Atomizität von Tests (Teil 1) </h2><br>  Schauen wir uns das folgende Beispiel an.  Wir schreiben einen Test, der den Zähler der Benutzer in der Fußzeile überprüft. <br><br><img width="651" src="https://habrastorage.org/webt/9j/n4/ws/9jn4wsd3jlh_wdnoiwrkjdfho9s.png"><br><br>  Das Szenario ist einfach: <br><br><ul><li>  Anwendung öffnen </li><li>  Fußzeilenzähler finden </li><li>  Stellen Sie sicher, dass es sichtbar ist </li></ul><br>  Wir nennen einen solchen Test testFooterCounter und führen ihn aus.  Dann muss überprüft werden, ob der Zähler keine Null anzeigt.  Wir fügen diesen Test einem vorhandenen Test hinzu. Warum nicht? <br><br>  Dann muss jedoch überprüft werden, ob in der Fußzeile ein Link zur Beschreibung des Projekts vorhanden ist (der Link "Über uns").  Einen neuen Test schreiben oder zu einem bestehenden hinzufügen?  Im Falle eines neuen Tests müssen wir die Anwendung erneut starten, den Benutzer vorbereiten (wenn wir die Fußzeile auf der autorisierten Seite überprüfen), uns anmelden - im Allgemeinen wertvolle Zeit verbringen.  In einer solchen Situation scheint es eine gute Idee zu sein, den Test in testFooterCounterAndLinks umzubenennen. <br><br>  Einerseits hat dieser Ansatz Vorteile: Zeit sparen, alle Überprüfungen eines Teils unserer Anwendung (in diesem Fall Fußzeile) an einem Ort speichern. <br><br>  Aber es gibt ein merkliches Minus.  Wenn der Test beim ersten Test fehlschlägt, wird der Rest der Komponente nicht überprüft.  Angenommen, ein Test stürzt in einem Zweig ab, nicht aufgrund von Instabilität, sondern aufgrund eines Fehlers.  Was zu tun ist?  Eine Aufgabe zurückgeben, die nur dieses Problem beschreibt?  Dann laufen wir Gefahr, eine Aufgabe zu bekommen, bei der nur dieser Fehler behoben wird, führen einen Test durch und stellen fest, dass die Komponente an einer anderen Stelle auch weiter defekt ist.  Und es kann viele solcher Iterationen geben.  Das Hin- und Herwerfen eines Tickets nimmt in diesem Fall viel Zeit in Anspruch und ist unwirksam. <br><br>  Fazit: Wenn möglich, zerstäuben Sie die Schecks.  In diesem Fall überprüfen wir alle anderen, auch wenn in einem Fall ein Problem vorliegt.  Und wenn Sie das Ticket zurückgeben müssen, können wir sofort alle Problembereiche beschreiben. <br><a name="atom_tests_2"></a><br><h2>  Atomizität von Tests (Teil 2) </h2><br>  Betrachten Sie ein anderes Beispiel.  Wir schreiben einen Chat-Test, der die folgende Logik überprüft.  Wenn Benutzer gegenseitiges Mitgefühl haben, wird im Chat der folgende Promoblock angezeigt: <br><br><img width="550" src="https://habrastorage.org/webt/2o/v8/kp/2ov8kp9mojel1g_txzatwy91nig.png"><br><br>  Das Szenario ist wie folgt: <br><br><ul><li>  Stimmen Sie von Benutzer A für Benutzer B ab </li><li>  Stimmen Sie von Benutzer B für Benutzer A ab </li><li>  Benutzer A offener Chat mit Benutzer B. </li><li>  Vergewissern Sie sich, dass das Gerät installiert ist </li></ul><br>  Für einige Zeit funktioniert der Test erfolgreich, aber dann passiert Folgendes ... Nein, diesmal übersieht der Test keinen Fehler.  :) :) <br><br>  Nach einiger Zeit stellen wir fest, dass es einen weiteren Fehler gibt, der nicht mit unserem Test zusammenhängt: Wenn Sie einen Chat öffnen, ihn sofort schließen und wieder öffnen, verschwindet der Block.  Nicht der offensichtlichste Fall, und im Test haben wir das natürlich nicht vorausgesehen.  Aber wir entscheiden, dass wir es auch abdecken müssen. <br><br>  Die gleiche Frage stellt sich: Schreiben Sie einen anderen Test oder fügen Sie einen Test in einen vorhandenen ein?  Ein neues zu schreiben scheint unangemessen, da er in 99% der Fälle dasselbe tut wie das bestehende.  Und wir beschließen, den Test zu dem bereits vorhandenen Test hinzuzufügen: <br><br><ul><li>  Stimmen Sie von Benutzer A für Benutzer B ab </li><li>  Stimmen Sie von Benutzer B für Benutzer A ab </li><li>  Benutzer A offener Chat mit Benutzer B. </li><li>  Vergewissern Sie sich, dass das Gerät installiert ist </li><li>  <b>Chat schließen</b> </li><li>  <b>Chat öffnen</b> </li><li>  Vergewissern Sie sich, dass das Gerät installiert ist </li></ul><br>  Ein Problem kann auftreten, wenn wir beispielsweise einen Test nach langer Zeit umgestalten.  Beispielsweise wird ein Projekt neu gestaltet - und Sie müssen viele Tests neu schreiben. <br><br>  Wir werden den Test öffnen und versuchen, uns daran zu erinnern, was er überprüft.  Ein Test heißt beispielsweise testPromoAfterMutualAttraction.  Verstehen wir, warum das Öffnen und Schließen des Chats am Ende geschrieben wird?  Höchstwahrscheinlich nicht.  Vor allem, wenn dieser Test nicht von uns geschrieben wurde.  Werden wir dieses Stück verlassen?  Vielleicht ja, aber wenn es Probleme mit ihm gibt, werden wir ihn wahrscheinlich einfach löschen.  Und die Überprüfung geht einfach verloren, weil ihre Bedeutung nicht offensichtlich ist. <br><br>  Ich sehe hier zwei Lösungen.  Erstens: Führen Sie immer noch den zweiten Test durch und nennen Sie ihn testCheckBlockPresentAfterOpenAndCloseChat.  Mit einem solchen Namen wird klar, dass wir nicht nur eine bestimmte Reihe von Aktionen ausführen, sondern eine sehr bewusste Überprüfung durchführen, da es eine negative Erfahrung gab.  Die zweite Lösung besteht darin, einen detaillierten Kommentar in den Code zu schreiben, warum wir diesen Test in diesem speziellen Test durchführen.  Es ist auch ratsam, die Fehlernummer im Kommentar anzugeben. <br><a name="click_error"></a><br><h2>  Fehler beim Klicken auf ein vorhandenes Element </h2><br>  Das folgende Beispiel warf mir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Bbidox zu</a> , wofür er ein großes Plus im Karma ist! <br><br>  Es gibt eine sehr interessante Situation, wenn der Testcode bereits ... ein Framework wird.  Angenommen, wir haben eine Methode wie diese: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebElement button_element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForButtonToAppear(); button_element.click(); }</code> </pre><br>  Irgendwann passiert etwas Seltsames mit dieser Methode: Der Test stürzt ab, wenn Sie versuchen, auf eine Schaltfläche zu klicken.  Wir öffnen den Screenshot, der zum Zeitpunkt des Testabsturzes aufgenommen wurde, und sehen, dass der Screenshot eine Schaltfläche enthält und die waitForButtonToAppear-Methode erfolgreich funktioniert hat.  Frage: Was ist los mit dem Klick? <br><br>  Das Schwierigste in dieser Situation ist, dass der Test manchmal erfolgreich sein kann.  :) :) <br><br>  Lass es uns richtig machen.  Angenommen, die im Beispiel betrachtete Schaltfläche befindet sich auf einer solchen Überlagerung: <br><br><img width="550" src="https://habrastorage.org/webt/pe/77/bd/pe77bddhspi2hdw1eagnzk8iydm.png"><br><br>  Dies ist eine spezielle Überlagerung, über die ein Benutzer unserer Website Informationen über sich selbst ausfüllen kann.  Wenn Sie auf die hervorgehobene Überlagerungsschaltfläche klicken, wird der nächste Block gefüllt. <br><br>  Fügen wir zum Spaß eine zusätzliche OLOLO-Klasse für diese Schaltfläche hinzu: <br><br><img width="550" src="https://habrastorage.org/webt/ul/qv/fj/ulqvfjphig982sp-ntzfcmwdc0q.png"><br><br>  Danach klicken wir auf diese Schaltfläche.  Optisch hat sich nichts geändert, aber der Knopf selbst ist an Ort und Stelle geblieben: <br><br><img width="550" src="https://habrastorage.org/webt/86/os/3x/86os3xs2ycobeqm75psth6xuidk.png"><br><br>  Was ist passiert?  In der Tat, als JS den Block zu uns neu zeichnete, zeichnete er auch den Knopf neu.  Es ist immer noch auf demselben Locator verfügbar, dies ist jedoch eine andere Schaltfläche.  Dies wird durch das Fehlen der von uns hinzugefügten OLOLO-Klasse belegt. <br><br>  Im obigen Code speichern wir das Element in der Variablen $ element.  Wenn ein Element während dieser Zeit neu generiert wird, ist es möglicherweise nicht visuell sichtbar, aber Sie können nicht mehr darauf klicken - die click () -Methode schlägt fehl. <br><br>  Es gibt verschiedene Lösungen: <br><br><ul><li>  Wrap Click in Try Block und in Catch Rebuild Element </li><li>  Fügen Sie einem Attribut eine Schaltfläche hinzu, um zu signalisieren, dass es sich geändert hat </li></ul><br><a name="error_message"></a><h2>  Fehlertext </h2><br>  Schließlich ein einfacher, aber nicht weniger wichtiger Punkt. <br><br>  Dieses Beispiel gilt nicht nur für UI-Tests, sondern tritt auch sehr häufig in diesen auf.  Wenn Sie einen Test schreiben, befinden Sie sich normalerweise im Kontext des Geschehens: Sie beschreiben die Überprüfung nach der Überprüfung und verstehen deren Bedeutung.  Und Sie schreiben Fehlertexte im selben Kontext: <br><br><pre> <code class="java hljs">WebElement element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">"a.link"</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find button"</span></span>);</code> </pre><br>  Was könnte in diesem Code unverständlich sein?  Der Test erwartet das Erscheinen einer Taste und fällt natürlich ab, wenn sie nicht vorhanden ist. <br><br>  Stellen Sie sich nun vor, der Autor des Tests ist krankgeschrieben und sein Kollege kümmert sich um die Tests.  Anschließend löscht er den TestQuestionsOnProfile-Test und schreibt die folgende Meldung: "Schaltfläche kann nicht gefunden werden".  Ein Kollege muss so schnell wie möglich verstehen, was passiert, da die Veröffentlichung bald kommt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/pe/dv/bapedvs1g2gplrhebyipl0p7cl0.gif"></div><br><br>  Was wird er tun müssen? <br><br>  Es ist sinnlos, die Seite zu öffnen, auf die der Test gefallen ist, und den Locator "a.link" zu überprüfen - es gibt kein Element.  Daher müssen Sie den Test sorgfältig studieren und herausfinden, was er überprüft. <br><br>  Mit einem detaillierteren Fehlertext wäre es viel einfacher: "Die Schaltfläche" Senden "in der Fragenüberlagerung kann nicht gefunden werden."  Mit einem solchen Fehler können Sie das Overlay sofort öffnen und sehen, wohin die Schaltfläche gegangen ist. <br><br>  Ausgabe zwei.  Erstens lohnt es sich, den Fehlertext an eine beliebige Methode Ihres Testframeworks zu übergeben, und es ist ein erforderlicher Parameter, damit keine Versuchung besteht, ihn zu vergessen.  Zweitens sollte der Fehlertext detailliert gemacht werden.  Dies bedeutet nicht immer, dass es lang sein sollte, es reicht aus, um klar zu machen, was im Test schief gelaufen ist. <br><br>  Wie kann man verstehen, dass der Fehlertext gut geschrieben ist?  Sehr einfach.  Stellen Sie sich vor, Ihre Anwendung ist fehlerhaft und Sie müssen zu den Entwicklern gehen und erklären, was und wo fehlerhaft ist.  Wenn Sie ihnen nur sagen, was im Fehlertext geschrieben steht, werden sie dann verstehen? <br><a name="summary"></a><br><h2>  Zusammenfassung </h2><br>  Das Schreiben eines Testskripts ist oft eine interessante Aktivität.  Gleichzeitig verfolgen wir viele Ziele.  Unsere Tests sollten: <br><br><ul><li>  decken Sie so viele Fälle wie möglich ab </li><li>  arbeite so schnell wie möglich </li><li>  verstanden werden </li><li>  einfach erweitern </li><li>  leicht zu pflegen </li><li>  Pizza bestellen </li><li>  usw… </li></ul><br>  Es ist besonders interessant, mit Tests in einem sich ständig weiterentwickelnden und ändernden Projekt zu arbeiten, in dem sie ständig aktualisiert werden müssen: etwas hinzufügen und etwas schneiden.  Deshalb lohnt es sich, einige Punkte im Voraus zu überdenken und nicht immer Entscheidungen zu treffen.  :) :) <br><br>  Ich hoffe, meine Tipps helfen Ihnen dabei, einige Probleme zu vermeiden und Sie in Fallstudien nachdenklicher zu machen.  Wenn das Publikum den Artikel mag, werde ich versuchen, einige langweiligere Beispiele zu sammeln.  In der Zwischenzeit - tschüss! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419419/">https://habr.com/ru/post/de419419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419409/index.html">Neue Intel NUCs basierend auf Coffee Lake Prozessoren</a></li>
<li><a href="../de419411/index.html">Über das Feuer in einem Wolkenkratzer. Kino und Realität</a></li>
<li><a href="../de419413/index.html">Meißel - (nicht ganz) ein neuer Ansatz zur Entwicklung der digitalen Logik</a></li>
<li><a href="../de419415/index.html">Mattermost und Powershell - große Leistung oder kleine Automatisierung im Haushalt</a></li>
<li><a href="../de419417/index.html">GDPR: Datenmapping oder wie Kunden längst vergessene Laptops finden</a></li>
<li><a href="../de419423/index.html">Uns wird ein Echtzeitvideo ohne Friese und Zuckungen versprochen</a></li>
<li><a href="../de419425/index.html">Sicherheitswoche 29. Hacking Reddit, eine Brieftasche für Kryptowährung und MikroTik-Router</a></li>
<li><a href="../de419427/index.html">Epson lädt alle zum Picknick für Geeks 2018 ein</a></li>
<li><a href="../de419429/index.html">Ich bin 57 und ich bin ein Scrum Master</a></li>
<li><a href="../de419433/index.html">DSW-Berichte - DeepSeeWeb Report Generator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>