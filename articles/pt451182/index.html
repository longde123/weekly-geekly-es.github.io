<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüîß ‚òùüèΩ üßíüèø Como os tamanhos de matrizes C se tornaram parte da interface bin√°ria da biblioteca üëéüèΩ ‚ùóÔ∏è üë©‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A maioria dos compiladores C permite acessar uma matriz extern com limites indefinidos, por exemplo: 



 extern int external_array[]; int array_get (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como os tamanhos de matrizes C se tornaram parte da interface bin√°ria da biblioteca</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451182/"> A maioria dos compiladores C permite acessar uma matriz <code>extern</code> com limites indefinidos, por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_get</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> external_array[index]; }</code> </pre> <br>  A defini√ß√£o de external_array pode estar em outra unidade de tradu√ß√£o e pode ser assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  A quest√£o √© o que acontece se essa defini√ß√£o separada mudar assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Ou ent√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <a name="habracut"></a><br>  A interface bin√°ria ser√° preservada (desde que exista um mecanismo que permita ao aplicativo determinar o tamanho da matriz em tempo de execu√ß√£o)? <br><br>  Curiosamente, em muitas arquiteturas, <i>aumentar o tamanho da matriz</i> viola a compatibilidade de interface bin√°ria (ABI).  Reduzir o tamanho da matriz tamb√©m pode causar problemas de compatibilidade.  Neste artigo, examinaremos mais de perto a compatibilidade com a ABI e explicaremos como evitar problemas. <br><br><h1>  Links na se√ß√£o de dados do arquivo execut√°vel </h1><br>  Para entender como o tamanho da matriz se torna parte da interface bin√°ria, primeiro precisamos examinar os links na se√ß√£o de dados do arquivo execut√°vel.  Obviamente, os detalhes dependem da arquitetura espec√≠fica, e aqui vamos nos concentrar na arquitetura x86-64. <br><br>  A arquitetura x86-64 suporta endere√ßamento relativo ao contador do programa, ou seja, o acesso √† vari√°vel global da matriz, como na fun√ß√£o <code>array_get</code> mostrada anteriormente, pode ser compilado em uma √∫nica instru√ß√£o <code>movl</code> : <br><br><pre> <code class="cpp hljs">array_get: <span class="hljs-function"><span class="hljs-function">movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">external_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(,%rdi,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, %eax ret</span></span></code> </pre> <br>  A partir disso, o assembler cria um arquivo de objeto no qual a instru√ß√£o √© marcada como <code>R_X86_64_32S</code> . <br><br><pre> <code class="plaintext hljs">0000000000000000 : 0: mov 0x0(,%rdi,4),%eax 3: R_X86_64_32S external_array 7: retq</code> </pre> <br>  Essa movimenta√ß√£o informa ao vinculador ( <code>ld</code> ) como preencher o local correspondente da vari√°vel <code>external_array</code> durante a vincula√ß√£o ao criar o execut√°vel. <br><br>  Isso tem duas consequ√™ncias importantes. <br><br><ul><li>  Como o deslocamento da vari√°vel √© determinado no tempo de constru√ß√£o, no tempo de execu√ß√£o, n√£o h√° custos indiretos para determin√°-lo.  O √∫nico pre√ßo √© o acesso √† pr√≥pria mem√≥ria. <br></li><li>  Para determinar o deslocamento, voc√™ precisa conhecer os tamanhos de todos os dados vari√°veis.  Caso contr√°rio, seria imposs√≠vel calcular o formato da se√ß√£o de dados durante o layout. </li></ul><br>  Para implementa√ß√µes em C orientadas ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Executable e Link Format (ELF)</a> , como no GNU / Linux, as refer√™ncias a vari√°veis <code>extern</code> n√£o cont√™m tamanhos de objeto.  No exemplo <code>array_get</code> tamanho do objeto √© desconhecido at√© para o compilador.  De fato, o arquivo assembler inteiro se parece com isso (omitindo apenas as informa√ß√µes de promo√ß√£o de <code>-fno-asynchronous-unwind-tables</code> , que s√£o tecnicamente necess√°rias para a conformidade com o psABI): <br><br><pre> <code class="plaintext hljs"> .file "get.c" .text .p2align 4,,15 .globl array_get .type array_get, @function array_get: movl external_array(,%rdi,4), %eax ret .size array_get, .-array_get .ident "GCC: (GNU) 8.3.1 20190223 (Red Hat 8.3.1-2)" .section .note.GNU-stack,"",@progbits</code> </pre> <br>  N√£o h√° informa√ß√µes de tamanho para <code>external_array</code> nesse arquivo assembler: a √∫nica refer√™ncia de caractere est√° na linha com a instru√ß√£o <code>movl</code> e os √∫nicos dados num√©ricos na instru√ß√£o s√£o o tamanho do elemento da matriz (impl√≠cito em <code>movl</code> multiplicado por 4). <br><br>  Se o ELF exigir tamanhos para vari√°veis ‚Äã‚Äãindefinidas, ser√° imposs√≠vel compilar a fun√ß√£o <code>array_get</code> . <br><br>  Como o vinculador obt√©m o tamanho real dos caracteres?  Ele examina a defini√ß√£o do s√≠mbolo e usa as informa√ß√µes de tamanho que encontra l√°.  Isso permite que o compilador calcule o layout da se√ß√£o de dados e preencha os movimentos de dados com as compensa√ß√µes apropriadas. <br><br><h1>  Objetos ELF comuns </h1><br>  As implementa√ß√µes C para ELF n√£o exigem que o programador adicione marca√ß√µes ao c√≥digo-fonte para indicar se a fun√ß√£o ou vari√°vel est√° localizada no objeto atual (que pode ser a biblioteca ou o arquivo execut√°vel principal) ou em outro objeto.  O vinculador e o carregador din√¢mico cuidar√£o disso. <br><br>  Ao mesmo tempo, havia um desejo de arquivos execut√°veis ‚Äã‚Äãpara n√£o reduzir o desempenho alterando o modelo de compila√ß√£o.  Isso significa que, ao compilar o c√≥digo-fonte do programa principal (ou seja, sem <code>-fPIC</code> e, neste caso espec√≠fico, sem <code>-fPIE</code> ), a fun√ß√£o <code>array_get</code> compilada <i>exatamente na mesma</i> sequ√™ncia de comandos antes de introduzir objetos compartilhados din√¢micos.  Al√©m disso, n√£o importa se a vari√°vel <code>external_array</code> est√° definida no arquivo execut√°vel mais b√°sico ou se algum objeto compartilhado √© carregado separadamente no tempo de execu√ß√£o.  As instru√ß√µes criadas pelo compilador s√£o as mesmas nos dois casos. <br><br>  Como isso √© poss√≠vel?  Afinal, objetos ELF comuns s√£o independentes de posi√ß√£o.  Eles s√£o carregados em <i>endere√ßos aleat√≥rios imprevis√≠veis</i> em tempo de execu√ß√£o.  No entanto, o compilador gera uma sequ√™ncia de c√≥digo de m√°quina que requer que essas vari√°veis ‚Äã‚Äãsejam localizadas em um <i>deslocamento fixo calculado durante a vincula√ß√£o</i> , muito antes do in√≠cio do programa. <br><br>  O fato √© que apenas um objeto carregado (o principal arquivo execut√°vel) usa esses deslocamentos corrigidos.  Todos os outros objetos (o pr√≥prio carregador din√¢mico, a biblioteca de tempo de execu√ß√£o C e qualquer outra biblioteca usada pelo programa) s√£o compilados e compilados como objetos completamente independentes da posi√ß√£o (PICs).  Para esses objetos, o compilador carrega o endere√ßo real de cada vari√°vel da tabela de deslocamento global (GOT).  Podemos ver essa rotat√≥ria se compilarmos o exemplo <code>array_get</code> com <code>-fPIC</code> , o que leva a esse c√≥digo de montagem: <br><br><pre> <code class="plaintext hljs">array_get: movq external_array@GOTPCREL(%rip), %rax movl (%rax,%rdi,4), %eax ret</code> </pre> <br>  Como resultado, o endere√ßo da vari√°vel <code>external_array</code> n√£o √© mais codificado e pode ser alterado no tempo de execu√ß√£o, inicializando adequadamente o registro GOT.  Isso significa que, no tempo de execu√ß√£o, a defini√ß√£o de <code>external_array</code> pode estar no mesmo objeto compartilhado, em outro objeto compartilhado ou no programa principal.  O carregador din√¢mico encontrar√° a defini√ß√£o apropriada com base nas regras de pesquisa de caracteres ELF e associar√° a refer√™ncia de s√≠mbolo indefinida √† sua defini√ß√£o, atualizando o registro GOT para seu endere√ßo real. <br><br>  Retornamos ao exemplo original, onde a fun√ß√£o <code>array_get</code> est√° no programa principal, portanto o endere√ßo da vari√°vel √© especificado diretamente.  A id√©ia principal implementada no vinculador √© que o programa principal forne√ßa uma defini√ß√£o de vari√°vel <code>external_array</code> , <i>mesmo que seja realmente definida em um objeto comum em tempo de execu√ß√£o</i> .  Em vez de indicar a defini√ß√£o original da vari√°vel no objeto compartilhado, o carregador din√¢mico selecionar√° uma <i>c√≥pia da</i> vari√°vel na se√ß√£o de dados do arquivo execut√°vel. <br><br>  Isso tem duas consequ√™ncias importantes.  Antes de tudo, lembre-se de que <code>external_array</code> √© definido da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  H√° um inicializador aqui que deve ser aplicado √† defini√ß√£o no arquivo execut√°vel principal.  Para fazer isso, no arquivo execut√°vel principal, √© colocado um link para o local da <i>c√≥pia de</i> c√≥pia do s√≠mbolo.  O <code>readelf -rW</code> mostra como mover <code>R_X86_64_COPY</code> . <br><br><pre>  A se√ß√£o de realoca√ß√£o '.rela.dyn' no deslocamento 0x408 cont√©m 3 entradas:
     Tipo de informa√ß√£o deslocada Valor do s√≠mbolo Nome do s√≠mbolo + Adenda
 0000000000403ff0 0000000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
 0000000000403ff8 0000000200000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
 0000000000404020 0000000300000005 R_X86_64_COPY 0000000000404020 external_array + 0 </pre><br>  Como outros movimentos, o movimento da c√≥pia √© tratado pelo carregador din√¢mico.  Inclui uma opera√ß√£o de c√≥pia simples, bit a bit.  O destino da c√≥pia √© determinado pelo deslocamento de deslocamento ( <code>0000000000404020</code> no exemplo).  A origem √© determinada no tempo de execu√ß√£o com base no nome do s√≠mbolo ( <code>external_array</code> ) e seu valor.  Ao criar uma c√≥pia, o carregador din√¢mico tamb√©m examinar√° o tamanho do caractere para obter o n√∫mero de bytes que precisam ser copiados.  Para tornar tudo isso poss√≠vel, o s√≠mbolo <code>external_array</code> √© exportado automaticamente do arquivo execut√°vel como um s√≠mbolo espec√≠fico, para que fique vis√≠vel para o carregador din√¢mico em tempo de execu√ß√£o.  A tabela de s√≠mbolos din√¢micos ( <code>.dynsym</code> ) reflete isso, conforme mostrado pelo comando <code>readelf -sW</code> : <br><br><pre>  A tabela de s√≠mbolos '.dynsym' cont√©m 4 entradas:
    Num: Valor Tamanho Tipo Vincula√ß√£o Vis Ndx Name
      0: 0000000000000000 0 0 N√ÉO-PADR√ÉO LOCAL UND 
      1: 0000000000000000 0 PADR√ÉO GLOBAL FUNC UND __libc_start_main@GLIBC_2.2.5 (2)
      2: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__
      3: 0000000000404020 12 PADR√ÉO GLOBAL DE OBJETOS 22 external_array </pre><br>  De onde v√™m as informa√ß√µes sobre o tamanho do objeto (12 bytes, neste exemplo)?  O vinculador abre todos os objetos comuns, procura sua defini√ß√£o e obt√©m informa√ß√µes sobre o tamanho.  Como antes, isso permite que o vinculador calcule o layout da se√ß√£o de dados para que compensa√ß√µes fixas possam ser usadas.  Novamente, o tamanho da defini√ß√£o no execut√°vel principal √© fixo e n√£o pode ser alterado em tempo de execu√ß√£o. <br><br>  O vinculador din√¢mico tamb√©m redireciona links simb√≥licos em objetos compartilhados para a c√≥pia movida no execut√°vel principal.  Isso garante que em todo o programa haja apenas uma c√≥pia da vari√°vel, conforme a sem√¢ntica da linguagem C. Caso contr√°rio, se a vari√°vel for alterada ap√≥s a inicializa√ß√£o, as atualiza√ß√µes do arquivo execut√°vel principal n√£o ser√£o vis√≠veis para objetos compartilhados din√¢micos e vice-versa. <br><br><h1>  Impacto na compatibilidade bin√°ria </h1><br>  O que acontece se alterarmos a defini√ß√£o de <code>external_array</code> em um objeto compartilhado sem vincular (ou recompilar) o programa principal?  Primeiro, considere <i>adicionar</i> um elemento de matriz. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Isso ir√° gerar um aviso do carregador din√¢mico em tempo de execu√ß√£o: <br><br> <code>main-program: Symbol `external_array' has different size in shared object, consider re-linking</code> <br> <br>  O programa principal ainda cont√©m uma defini√ß√£o <code>external_array</code> com espa√ßo para apenas 12 bytes.  Isso significa que a c√≥pia est√° incompleta: apenas os tr√™s primeiros elementos da matriz s√£o copiados.  Como resultado, o acesso ao elemento do array <code>extern_array[3]</code> n√£o <code>extern_array[3]</code> definido.  Essa abordagem afeta n√£o apenas o programa principal, mas tamb√©m todo o c√≥digo no processo, porque todas as refer√™ncias a <code>extern_array</code> foram redirecionadas para a defini√ß√£o no programa principal.  Isso inclui um objeto gen√©rico que fornece uma defini√ß√£o <code>extern_array</code> .  Ele provavelmente n√£o est√° pronto para enfrentar uma situa√ß√£o em que um elemento da matriz em sua pr√≥pria defini√ß√£o desapareceu. <br><br>  Que tal mudar na dire√ß√£o oposta, remover um elemento? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Se o programa evitar acessar o elemento da matriz <code>extern_array[2]</code> , porque de alguma forma detecta o comprimento reduzido da matriz, isso funcionar√°.  Ap√≥s a matriz, h√° alguma mem√≥ria n√£o utilizada, mas isso n√£o interromper√° o programa. <br><br>  Isso significa que obtemos a seguinte regra: <br><br><ul><li>  A adi√ß√£o de elementos a uma vari√°vel de matriz global viola a compatibilidade bin√°ria. <br></li><li>  A remo√ß√£o de itens pode quebrar a compatibilidade se n√£o houver um mecanismo que evite o acesso aos itens exclu√≠dos. </li></ul><br>  Infelizmente, o aviso do carregador din√¢mico parece mais inofensivo do que realmente √©, e para elementos remotos n√£o h√° aviso. <br><br><h1>  Como evitar esta situa√ß√£o </h1><br>  Detectar altera√ß√µes da ABI √© bastante f√°cil com ferramentas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libabigail</a> . <br><br>  A maneira mais f√°cil de evitar essa situa√ß√£o √© implementar uma fun√ß√£o que retorna o endere√ßo da matriz: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_external_array</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_array; }</code> </pre> <br>  Se a defini√ß√£o da matriz n√£o puder ser est√°tica devido √† maneira como √© usada na biblioteca, podemos ocultar sua visibilidade e tamb√©m impedir sua exporta√ß√£o e, portanto, evitar o problema de truncamento: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] __attribute__ ((visibility (<span class="hljs-string"><span class="hljs-string">"hidden"</span></span>))) = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Tudo √© muito mais complicado se a vari√°vel da matriz for exportada por motivos de compatibilidade com vers√µes anteriores.  Como a matriz da biblioteca est√° truncada, o programa principal antigo, com uma defini√ß√£o de matriz mais curta, n√£o poder√° fornecer acesso √† matriz completa para o novo c√≥digo do cliente se for usado com a mesma matriz global.  Em vez disso, a fun√ß√£o de acesso pode usar uma matriz separada (est√°tica ou oculta) ou talvez uma matriz separada para adicionar elementos ao final.  A desvantagem √© que n√£o √© poss√≠vel armazenar tudo em uma matriz cont√≠nua se a vari√°vel da matriz for exportada para compatibilidade com vers√µes anteriores.  O design da interface secund√°ria deve refletir isso. <br><br>  Usando o controle de vers√£o de caracteres, voc√™ pode exportar v√°rias vers√µes com tamanhos diferentes, nunca alterando o tamanho em uma vers√£o espec√≠fica.  Usando esse modelo, novos programas relacionados sempre usar√£o a vers√£o mais recente, presumivelmente com o maior tamanho.  Como a vers√£o e o tamanho do s√≠mbolo s√£o fixados pelo editor de links ao mesmo tempo, eles s√£o sempre consistentes.  A biblioteca GNU C usa essa abordagem para as vari√°veis ‚Äã‚Äãhist√≥ricas <code>sys_errlist</code> e <code>sys_siglist</code> .  No entanto, isso ainda n√£o fornece uma √∫nica matriz cont√≠nua. <br><br>  Em suma, uma fun√ß√£o acessadora (por exemplo, a fun√ß√£o <code>get_external_array</code> acima) √© a melhor abordagem para evitar esse problema de compatibilidade ABI. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451182/">https://habr.com/ru/post/pt451182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451172/index.html">Julia: fun√ß√µes e estruturas-como-fun√ß√µes</a></li>
<li><a href="../pt451174/index.html">Adapta√ß√£o de programas do ZX Spectrum ao TR-DOS por meios modernos. Parte 1</a></li>
<li><a href="../pt451176/index.html">Not√≠cias do mundo do OpenStreetMap n¬∫ 458 (23/04/2019 - 09/04/2019)</a></li>
<li><a href="../pt451178/index.html">Teste de colis√£o com pouso em paraquedas</a></li>
<li><a href="../pt451180/index.html">PCB substitui dois motores lineares</a></li>
<li><a href="../pt451184/index.html">Projeto Blue Origin Blue Moon: Pessoas na Lua at√© 2024</a></li>
<li><a href="../pt451186/index.html">Reposit√≥rio LINSTOR e sua integra√ß√£o com o OpenNebula</a></li>
<li><a href="../pt451188/index.html">Sberbank ou l√° e volta</a></li>
<li><a href="../pt451196/index.html">Separa√ß√£o de perfis de clientes e freelancers</a></li>
<li><a href="../pt451198/index.html">O papel da realidade aumentada e da realidade virtual na NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>