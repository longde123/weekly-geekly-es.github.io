<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåÔ∏è üëè üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ SpaceVIL - plattform√ºbergreifendes GUI-Framework f√ºr die Entwicklung auf .Net Core, .Net Standard und JVM üÖøÔ∏è üêë üïé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich versuchen, √ºber das SpaceVIL-Framework (Space of Visual Items Layout) zu sprechen, mit dem grafische Benutzeroberfl√§chen a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SpaceVIL - plattform√ºbergreifendes GUI-Framework f√ºr die Entwicklung auf .Net Core, .Net Standard und JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448790/"><p>  In diesem Artikel werde ich versuchen, √ºber das SpaceVIL-Framework (Space of Visual Items Layout) zu sprechen, mit dem grafische Benutzeroberfl√§chen auf .Net / .Net Core- und JVM-Plattformen erstellt werden. </p><br><p>  SpaceVIL ist ein plattform√ºbergreifendes und mehrsprachiges Framework, es basiert auf der OpenGL-Grafiktechnologie und die GLFW-Bibliothek ist f√ºr die Erstellung von Fenstern verantwortlich.  Mit diesem Framework k√∂nnen Sie grafische Clientanwendungen unter Linux-, Mac OS X- und Windows-Betriebssystemen bearbeiten und erstellen.  F√ºr C # -Programmierer gilt dies derzeit besonders, da Microsoft WPF nicht auf andere Betriebssysteme portieren wird und Avalonia das einzig m√∂gliche Analogon ist.  Die Besonderheit von SpaceVIL in diesem speziellen Fall ist die Mehrsprachigkeit, dh derzeit kann das .Net Core-Framework in Verbindung mit den folgenden Programmiersprachen verwendet werden: C #, VisualBasic.  Das JVM-Framework kann in Verbindung mit den Sprachen Java und Scala verwendet werden.  Das hei√üt, SpaceVIL kann mit jeder dieser Sprachen verwendet werden, und der resultierende Code sieht gleich aus. Wenn Sie also zu einer anderen Sprache wechseln, m√ºssen Sie ihn nicht erneut lernen. </p><br><p>  SpaceVIL befindet sich noch im Alpha-Stadium, aber trotzdem kann das Framework jetzt vollst√§ndig genutzt werden, da das Framework alles enth√§lt, was Sie zum Erstellen einer komplexen Benutzeroberfl√§che und zum Erstellen v√∂llig neuer visueller Benutzerelemente ben√∂tigen.  Der Zweck dieses Artikels ist genau, Sie davon zu √ºberzeugen. </p><a name="habracut"></a><br><p>  SpaceVIL wurde von Grund auf neu entwickelt und deshalb hat das Framework seine eigenen Prinzipien, die es von Analoga unterscheiden. </p><br><ul><li>  Der SpaceVIL-Benutzer hat die volle Kontrolle dar√ºber, was passiert. </li><li>  Jede in SpaceVIL geschriebene Anwendung sieht auf allen Plattformen genau gleich aus.  Es gibt keine Fallstricke.  Sie k√∂nnen jede Version von SpaceVIL (.Net / JVM, Mac OS X, Linux, Windows) verwenden. Das Ergebnis und das Erscheinungsbild sind immer gleich. </li><li>  Die SpaceVIL-Version f√ºr JVM ist identisch mit der SpaceVIL-Version f√ºr .Net </li><li>  SpaceVIL bietet M√∂glichkeiten zur umfassenden Anpassung eines Elements, da alle interaktiven Objekte Container f√ºr andere interaktive Objekte sind. </li><li>  Das Framework ist sehr flexibel und einfach zu verwenden, da es nur wenige strenge Grundregeln enth√§lt. Das einzige, was Sie verstehen m√ºssen, bevor Sie damit arbeiten, ist, was die Einstellungen f√ºr Auff√ºllen, Rand, Ausrichtung bedeuten (und jeder, der einfache Schnittstellen erstellt hat, kennt sie , in WPF, Android Studio oder schrieb Stile in CSS). </li><li>  SpaceVIL verlangt von Ihnen keine eingehende Untersuchung seiner Innenseiten und es wird genau das tun, was Sie schreiben.  Alle Elemente befolgen die allgemeinen Regeln. Ein Ansatz funktioniert f√ºr alle Elemente.  Wenn Sie sich an die Basis erinnert haben, k√∂nnen Sie sowohl die Zusammensetzung der Elemente als auch die Art und Weise ihrer Gestaltung vorhersagen. </li><li>  Das Framework ist sehr leicht, weniger als ein Megabyte und alles in einer Datei. </li></ul><br><h2 id="vozmozhnosti">  Die M√∂glichkeiten </h2><br><p>  Nun wollen wir sehen, wozu das Framework der aktuellen Version in der Lage ist. </p><br><ul><li>  Es stehen 54 Elemente zur Verf√ºgung, von denen 10 spezialisierte Container, 6 Grundelemente (nicht interaktive Elemente) und 38 interaktive Elemente f√ºr verschiedene Zwecke sind. </li><li>  Basierend auf all diesen Elementen k√∂nnen Sie in Verbindung mit der Implementierung spezieller Schnittstellen Ihre eigenen Elemente beliebiger Komplexit√§t erstellen. </li><li>  Es gibt ein Styling von Elementen, es gibt Optionen zum Erstellen ganzer Stilthemen oder zum √Ñndern / Ersetzen des Stils eines Standardelements im Framework.  Bisher ist in SpaceVIL nur ein Thema vorhanden und es ist standardm√§√üig installiert. </li><li>  Es gibt ein System von Staaten.  Jedem Element kann ein visueller Status f√ºr eine der Methoden der externen Beeinflussung zugewiesen werden: Bewegen des Mauszeigers √ºber das Element, Dr√ºcken der Maustaste, Loslassen der Maustaste, Umschalten, Fokussieren und Ausschalten des Elements. </li><li>  Es gibt eine Ereignisfilterung.  Jedes Element in der Interaktion kann die Ereignisse herausfiltern, die es durchlaufen, wodurch ein Ereignis das Element passieren und vom anderen verworfen werden kann.  In einem Beispiel werde ich genauer darauf eingehen. </li><li>  Implementierung eines Systems schwebender unabh√§ngiger Elemente. </li><li>  Ein System von Dialogfeldern und Dialogelementen wurde implementiert. </li><li>  Unabh√§ngiges Rendern implementiert.  Jedes Fenster verf√ºgt √ºber zwei Streams - einer steuert das Rendern, der andere f√ºhrt Aufgaben aus eingehenden Ereignissen aus, dh das Fenster wird jetzt immer weiter gerendert (und bleibt nicht h√§ngen), unabh√§ngig von der Aufgabe, die nach dem Dr√ºcken einer Taste gestartet wurde. </li></ul><br><h2 id="struktura">  Struktur </h2><br><p>  Betrachten wir nun die Struktur der Elemente.  Die folgenden Arten von Elementen sind im Framework vorhanden: aktive und Dialogfenster, Container zum bequemen Positionieren von Elementen, interaktive Elemente und Grundelemente.  Lassen Sie uns alle oben genannten Punkte kurz durchgehen.  Ich hoffe, dass es nicht n√∂tig ist, solche Fenster zu erkl√§ren. Ich stelle nur fest, dass das Dialogfeld das Fenster blockiert, das es verursacht hat, bis es geschlossen wird. </p><br><h4 id="konteynery">  Container </h4><br><p>  Die folgenden Containertypen werden in SpaceVIL dargestellt: </p><br><ul><li>  Ein gemeinsamer Container (Elemente in einem solchen Container werden aufgrund von Ausrichtungs-, Auff√ºllungs-, Rand-, Gr√∂√üen- und Gr√∂√üenrichtlinienparametern positioniert). </li><li>  Vertikale und horizontale Stapel (Elemente, die einem solchen Container hinzugef√ºgt werden, werden in der richtigen Reihenfolge angeordnet, ohne dass die Parameter, die bei Verwendung des vorherigen Containertyps erforderlich sind, genau eingestellt werden m√ºssen). </li><li>  Gitter - Elemente werden zu den Gitterzellen hinzugef√ºgt und in ihrer Zelle positioniert. </li><li>  List (ListBox, TreeView), ein Container, der auf einem vertikalen Stapel basiert, aber einen Bildlauf durchf√ºhren kann, um Elemente anzuzeigen, die nicht in den Container passen. </li><li>  Separator (SplitArea), ein Container kann von zwei Arten sein - vertikal und horizontal, trennt zwei Bereiche und steuert interaktiv die Gr√∂√üe dieser Bereiche. </li><li>  Tabbed Container (TabView) steuert die Sichtbarkeit der Seite. </li><li>  WrapGrid positioniert Elemente in Zellen einer bestimmten Gr√∂√üe und f√ºllt den gesamten freien Speicherplatz entsprechend der Ausrichtung mit der M√∂glichkeit des Bildlaufs aus (das auff√§lligste Beispiel ist Windows Explorer im Symbolanzeigemodus). </li><li>  Und schlie√ülich ist ein freier Container, wahrscheinlich der seltenste Container, ein unendlicher Bereich, in den Sie Elemente fester Gr√∂√üe einf√ºgen k√∂nnen. Es ist jedoch besser, ihn in Kombination mit einem Element vom Typ ResizableItem zu verwenden. </li></ul><br><h4 id="interaktivnye-elementy">  Interaktive Elemente </h4><br><p>  Elemente dieses Typs akzeptieren viele Zust√§nde und haben verschiedene Ereignisse.  Wenn es einfacher ist, gibt es alles, mit dem Sie interagieren k√∂nnen, und interaktive Elemente, z. B. eine Schaltfl√§che, ein Kontrollk√§stchen, ein Element zur Texteingabe und andere. </p><br><h4 id="primitivy">  Primitive </h4><br><p>  Im Gegensatz zu interaktiven Elementen gibt es Grundelemente, v√∂llig nicht interaktive Elemente, es ist unm√∂glich, sie zu kontaktieren, sie existieren nur, um sich zu zeigen.  Arten von Grundelementen: ein Dreieck, ein Rechteck, eine Ellipse und etwas komplizierter - eine beliebige Figur, die die Form einer beliebigen Komplexit√§t annehmen kann. </p><br><p>  Es gibt auch statische Serviceklassen.  Einige dieser Klassen erm√∂glichen es dem Programmierer, Elemente nach ihren W√ºnschen abzurufen und anzupassen.  Beispielsweise gibt es eine Klasse, die die Stile von Elementen steuert, und eine Klasse, mit der Sie ein beliebiges Anzeigeformular f√ºr ein interaktives Element, eine Klasse von Standardeinstellungen usw. festlegen k√∂nnen. </p><br><h2 id="primer-prostogo-prilozheniya-s-ispolzovaniem-freymvorka-spacevil">  Ein Beispiel f√ºr eine einfache Anwendung mit dem SpaceVIL-Framework </h2><br><p>  Ich habe eine kleine Modeerscheinung √ºber Beispiele.  Sie k√∂nnen immer ein abstraktes und genau reflektierendes Funktionsbeispiel erstellen, aber wenn Sie es von der Seite lesen, sieht es immer sehr wenig √ºberzeugend aus. Als Beispiel versuche ich, kleine, aber vorgefertigte Anwendungen zu erstellen, die einem verst√§ndlichen Zweck dienen. </p><br><p>  Fahren wir mit der Beschreibung der Anwendung fort.  Das Programm ist ein Heldenkarten-Editor f√ºr Spiele wie "Dungeons and Dragons" und tr√§gt den Namen CharacterEditor.  Das Programm generiert zuf√§llig eine bestimmte Anzahl verschiedener Zeichen mit Namen, Alter, Rasse, Geschlecht, Klasse und Merkmalen.  Der Benutzer hat die M√∂glichkeit, eine Biografie zu schreiben und dem Charakter spezielle F√§higkeiten zu vermitteln.  Als Ergebnis k√∂nnen Sie die Heldenkarte als Textdatei speichern.  Kommen wir zur Code-Analyse.  Das Programm ist in C # geschrieben.  Bei Verwendung von Java ist der Code im Wesentlichen derselbe. </p><br><p>  Als Ergebnis erhalten wir eine solche Anwendung: </p><br><p><img src="https://habrastorage.org/webt/sc/hj/tc/schjtchdgjoprbwxcsls0b-x2_m.png"></p><br><h4 id="sozdanie-okna-prilozheniya">  Anwendungsfenster erstellen </h4><br><p>  An dieser Stelle erstellen wir ein Fenster.  Ich m√∂chte Sie daran erinnern, dass SpaceVIL GLFW verwendet. Wenn Sie also eine Anwendung f√ºr die .Net-Plattform schreiben, muss die kompilierte GLFW-Bibliothek neben die ausf√ºhrbare Datei kopiert werden.  Die JVM verwendet den GLFW-Bibliotheks-Wrapper (LWJGL), dessen Zusammensetzung bereits eine kompilierte GLFW enth√§lt. </p><br><p>  F√ºllen Sie anschlie√üend den Rendering-Bereich mit den erforderlichen Elementen und geben Sie ihnen ein sch√∂nes Aussehen.  Die Hauptschritte, um dies zu erreichen, sind wie folgt: </p><br><ul><li>  Initialisieren von SpaceVIL vor der Verwendung.  Schreiben Sie in der Hauptfunktion einfach: </li></ul><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SpaceVIL.Common.CommonService.InitSpaceVILComponents()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><ul><li>  Erstellen Sie nun ein Fenster.  Dazu m√ºssen Sie eine Fensterklasse schreiben, die sie von der <code>SpaceVIL.ActiveWindow</code> Klasse <code>SpaceVIL.ActiveWindow</code> , die <code>InitWindow()</code> -Methode beschreiben und mit mehreren grundlegenden Parametern wie Fenstername, Titelleisten-Text und Abmessungen festlegen.  Als Ergebnis erhalten wir einen Code, der folgenderma√üen aussieht: </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SpaceVIL; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">CharacterEditor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindow</span></span> : <span class="hljs-title"><span class="hljs-title">ActiveWindow</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SetParameters(<span class="hljs-string"><span class="hljs-string">"CharacterEditor"</span></span>, <span class="hljs-string"><span class="hljs-string">"CharacterEditor"</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>); } } }</code> </pre> <br><ul><li>  Es bleibt nur eine Instanz dieser Klasse zu erstellen und aufzurufen.  Dazu erg√§nzen wir die Main-Methode mit folgenden Codezeilen: </li></ul><br><pre> <code class="cs hljs">MainWindow mw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MainWindow(); mw.Show();</code> </pre> <br><p>  Das ist alles, in diesem Stadium k√∂nnen Sie die Anwendung starten und pr√ºfen, ob alles funktioniert. </p><br><h4 id="napolnenie-elementami">  F√ºllen mit Elementen </h4><br><p>  Um CharacterEditor zu implementieren, habe ich beschlossen, eine Titelleiste, eine Symbolleiste und einen vertikalen Teiler in das Fenster einzuf√ºgen.  Die Symbolleiste enth√§lt: eine Schaltfl√§che zum Aktualisieren der Liste der neu generierten Zeichen, eine Schaltfl√§che zum Speichern des Zeichens und ein Element mit der Anzahl der generierten Zeichen.  Auf der linken Seite des vertikalen Trennzeichens befindet sich eine Liste der generierten Zeichen und auf der rechten Seite ein Textbereich zum Bearbeiten eines aus der Liste ausgew√§hlten Zeichens.  Um die Fensterklasse nicht mit Elementeinstellungen zu √ºberladen, k√∂nnen Sie eine statische Klasse schreiben, die uns Elemente bereitstellt, die in Aussehen und Einstellungen bereit sind.  Beachten Sie beim Hinzuf√ºgen, dass jedes interaktive Element, ob es sich um eine Schaltfl√§che oder eine Liste handelt, ein Container ist. Sie k√∂nnen also alles von einer Schaltfl√§che bis zu Primitiven in einen anderen Container einf√ºgen, und jedes komplexe Element ist nur eine Reihe einfacherer Elemente, die insgesamt dienen ein Ziel.  Wenn Sie dies wissen, m√ºssen Sie sich an die erste strenge Regel erinnern - bevor Sie einem Element andere Elemente hinzuf√ºgen, m√ºssen Sie es irgendwo hinzuf√ºgen, entweder zur Fensterklasse selbst (in unserem Fall <code>MainWindow</code> ) oder zu einem Container oder einem anderen interaktiven Element.  Lassen Sie uns anhand eines Beispiels erkl√§ren: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SetParameters(<span class="hljs-string"><span class="hljs-string">"CharacterEditor"</span></span>, <span class="hljs-string"><span class="hljs-string">"CharacterEditor"</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   Frame frame = new Frame(); // ,      frame ButtonCore btn = new ButtonCore("Button"); //    , //      . // frame     , //,   . frame.AddItem(btn); //  frame    AddItem(frame); }</span></span></code> </pre> <br><p>  Es ist richtig, zuerst dem Fenster einen <code>frame</code> hinzuzuf√ºgen und dann dem <code>frame</code> eine Schaltfl√§che hinzuzuf√ºgen.  Es scheint, dass die Regel sehr unpraktisch ist und Sie beim Erstellen eines komplexen Fensters schwitzen m√ºssen. Aus diesem Grund empfiehlt SpaceVIL, eigene Elemente zu erstellen, was das Hinzuf√ºgen von Elementen erheblich vereinfacht.  Ich werde etwas sp√§ter die Entstehung meiner eigenen Elemente zeigen und erkl√§ren.  Kommen wir zur√ºck zur Anwendung.  Hier ist das resultierende Fenster: </p><br><p><img src="https://habrastorage.org/webt/df/lg/kg/dflgkgv6s9jnbaqzsif3zdtkm9k.png"></p><br><p>  Analysieren wir nun den Code: </p><br><div class="spoiler">  <b class="spoiler_title">MainWindow Markup-Zusammenfassungscode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ListBox ItemList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListBox(); <span class="hljs-comment"><span class="hljs-comment">//     internal TextArea ItemText = new TextArea(); //     internal ButtonCore BtnGenerate; //   internal ButtonCore BtnSave; //    internal SpinItem NumberCount; //    public override void InitWindow() { SetParameters("CharacterEditor", "CharacterEditor", 1000, 600); IsBorderHidden = true; //      IsCentered = true; //       //  TitleBar title = new TitleBar(nameof(CharacterEditor)); //     title.SetIcon( DefaultsService.GetDefaultImage(EmbeddedImage.User, EmbeddedImageSize.Size32x32), 20, 20); // ,       VerticalStack layout = ItemFactory.GetStandardLayout(title.GetHeight()); //  HorizontalStack toolbar = ItemFactory.GetToolbar(); //  VerticalSplitArea splitArea = ItemFactory.GetSplitArea(); //  BtnGenerate = ItemFactory.GetToolbarButton(); //  BtnSave = ItemFactory.GetToolbarButton(); //    NumberCount = ItemFactory.GetSpinItem(); //    ItemText.SetStyle(StyleFactory.GetTextAreaStyle()); //     AddItems(title, layout); layout.AddItems(toolbar, splitArea); toolbar.AddItems(BtnGenerate, BtnSave, ItemFactory.GetVerticalDivider(), NumberCount); splitArea.AssignLeftItem(ItemList); splitArea.AssignRightItem(ItemText); //    BtnGenerate.AddItem(ItemFactory.GetToolbarIcon( DefaultsService.GetDefaultImage(EmbeddedImage.Refresh, EmbeddedImageSize.Size32x32))); BtnSave.AddItem(ItemFactory.GetToolbarIcon( DefaultsService.GetDefaultImage(EmbeddedImage.Diskette, EmbeddedImageSize.Size32x32))); }</span></span></code> </pre> </div></div><br><p>  In der <code>ItemFactory</code> Klasse habe ich das Erscheinungsbild und Layout von Elementen beschrieben.  Die <code>ItemFactory.GetToolbarButton()</code> -Methode sieht beispielsweise <code>ItemFactory.GetToolbarButton()</code> aus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ButtonCore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetToolbarButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ButtonCore btn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ButtonCore(); <span class="hljs-comment"><span class="hljs-comment">//     btn.SetBackground(55, 55, 55); // btn.SetHeightPolicy(SizePolicy.Expand); //       btn.SetWidth(30); //  btn.SetPadding(5, 5, 5, 5); //       // ,           btn.AddItemState(ItemStateType.Hovered, new ItemState(Color.FromArgb(30, 255, 255, 255))); //  ItemState   return btn; }</span></span></code> </pre> <br><p>  Die √ºbrigen Elemente werden √§hnlich beschrieben. </p><br><h4 id="sozdanie-i-primenenie-stiley">  Stile erstellen und anwenden </h4><br><p>  Wie Sie vielleicht bemerkt haben, habe ich dem <code>ItemText</code> Element einen Stil <code>ItemText</code> .  Schauen wir uns also an, wie Stile erstellt werden, und schauen wir uns zun√§chst den Stilcode an: </p><br><pre> <code class="cs hljs">Style style = Style.GetTextAreaStyle(); <span class="hljs-comment"><span class="hljs-comment">//       style.Background = Color.Transparent; //   Style textedit = style.GetInnerStyle("textedit"); //     textedit.Foreground = Color.LightGray; //   Style cursor = textedit.GetInnerStyle("cursor"); //     cursor.Background = Color.FromArgb(0, 162, 232);//  </span></span></code> </pre> <br><p>  Wie Sie sehen k√∂nnen, habe ich f√ºr dieses Element einen vorgefertigten Stil aus der <code>SpaceVIL.Style</code> Klasse √ºbernommen und ihn leicht ge√§ndert, um die Farben zu korrigieren.  Jeder Stil kann mehrere interne Stile zum Stylen jedes einzelnen komplexen Elements enthalten.  Ein <code>CheckBox</code> Element besteht beispielsweise aus einem Container, einem Indikator und einem Text, sodass sein Stil interne Stile f√ºr den Indikator ("Indikator") und den Text ("Textzeile") enth√§lt. </p><br><p>  Die <code>Style</code> Klasse deckt alle visuellen Eigenschaften von Elementen ab. Dar√ºber hinaus k√∂nnen Sie mithilfe des Stils die Form eines Elements interaktiv √§ndern, z. B. von einer Ellipse zu einem Rechteck und umgekehrt.  Um einen Stil anzuwenden, m√ºssen Sie die <code>SetStyle(Style style)</code> Methode <code>SetStyle(Style style)</code> f√ºr das Element aufrufen, wie oben bereits gezeigt: </p><br><pre> <code class="cs hljs">ItemText.SetStyle(StyleFactory.GetTextAreaStyle());</code> </pre> <br><h4 id="sozdanie-sobstvennogo-elementa">  Erstellen Sie Ihren eigenen Artikel </h4><br><p>  Fahren wir nun mit der Erstellung des Elements fort.  Das Element selbst muss nicht spezifisch sein, es kann ein regul√§rer Stapel sein, in dem Sie mehrere andere Elemente hinzuf√ºgen.  Im obigen Beispiel habe ich beispielsweise eine Symbolleiste, in der drei Elemente enthalten sind.  Die Symbolleiste selbst ist nur ein horizontaler Stapel.  Alles k√∂nnte als separates Element angeordnet und als ToolBar bezeichnet werden.  An sich tut es nichts, aber in der <code>MainWindow</code> Klasse w√ºrde die Anzahl der Zeilen reduziert und das Verst√§ndnis des Markups w√§re noch einfacher, au√üerdem ist es auch eine M√∂glichkeit, die erste strenge Regel zu schw√§chen, obwohl am Ende nat√ºrlich alles gehorcht.  Okay, wir ber√ºhren die Symbolleiste nicht mehr.  Wir ben√∂tigen ein Element f√ºr die Liste, das das generierte Zeichen anzeigt. </p><br><p>  Um es interessanter zu machen, definieren wir die Zusammensetzung des Elements komplizierter: </p><br><ul><li>  Ein Charaktersymbol, dessen Farbe die Zugeh√∂rigkeit zu einer Fantasy-Rasse anzeigt. </li><li>  Name, Nachname und Rasse des Charakters in Textform. </li><li>  Zeichen-Schnellhilfetaste (wird ben√∂tigt, um Filterereignisse zu demonstrieren). </li><li>  Schaltfl√§che zum L√∂schen des Zeichens, falls es nicht zu uns passt. </li></ul><br><p>  Um eine Klasse Ihres eigenen Elements zu erstellen, m√ºssen Sie sie von jedem interaktiven Element von SpaceVIL erben, wenn mindestens eine Klasse in ihrer Zusammensetzung zu uns passt. F√ºr das aktuelle Beispiel werden wir das Element jedoch von Grund auf neu zusammenstellen und es daher von der abstrakten Basisklasse interaktiver Elemente - <code>SpaceVIL.Prototype</code> - <code>SpaceVIL.Prototype</code> .  Wir m√ºssen auch die <code>InitElements()</code> -Methode implementieren, in der wir das Erscheinungsbild des Elements, die Position und den Typ verschachtelter Elemente sowie die Reihenfolge des Hinzuf√ºgens verschachtelter Elemente beschreiben.  Das Element selbst hei√üt <code>CharacterCard</code> . </p><br><p>  Fahren wir mit dem Parsen des Codes des fertigen Elements fort: </p><br><div class="spoiler">  <b class="spoiler_title">CharacterCard-Artikelcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SpaceVIL; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SpaceVIL.Core; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SpaceVIL.Decorations; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SpaceVIL.Common; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">CharacterEditor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   SpaceVIL.Prototype internal class CharacterCard : Prototype { private Label _name; private CharacterInfo _characterInfo = null; //      CharacterInfo, //       internal CharacterCard(CharacterInfo info) { //      //        SetSizePolicy(SizePolicy.Expand, SizePolicy.Fixed); SetHeight(30); //   SetBackground(60, 60, 60); //  SetPadding(10, 0, 5, 0); //    SetMargin(2, 1, 2, 1); //   AddItemState(ItemStateType.Hovered, new ItemState(Color.FromArgb(30, 255, 255, 255))); _characterInfo = info; //      //      Label _name = new Label(info.Name + " the " + info.Race); } public override void InitElements() { //  ImageItem _race = new ImageItem(DefaultsService.GetDefaultImage( EmbeddedImage.User, EmbeddedImageSize.Size32x32), false); _race.KeepAspectRatio(true); //   // ImageItem   _race.SetWidthPolicy(SizePolicy.Fixed); _race.SetWidth(20); // ImageItem // ImageItem       _race.SetAlignment(ItemAlignment.Left, ItemAlignment.VCenter); //  ()     switch (_characterInfo.Race) { case CharacterRace.Human: //   _race.SetColorOverlay(Color.FromArgb(0, 162, 232)); break; case CharacterRace.Elf: //   _race.SetColorOverlay(Color.FromArgb(35, 201, 109)); break; case CharacterRace.Dwarf: //   _race.SetColorOverlay(Color.FromArgb(255, 127, 39)); break; } // Label _name _name.SetMargin(30, 0, 30, 0); //    //    ButtonCore infoBtn = new ButtonCore("?"); infoBtn.SetBackground(Color.FromArgb(255, 40, 40, 40)); infoBtn.SetWidth(20); infoBtn.SetSizePolicy(SizePolicy.Fixed, SizePolicy.Expand); infoBtn.SetFontStyle(FontStyle.Bold); infoBtn.SetForeground(210, 210, 210); infoBtn.SetAlignment(ItemAlignment.VCenter, ItemAlignment.Right); infoBtn.SetMargin(0, 0, 20, 0); infoBtn.AddItemState(ItemStateType.Hovered, new ItemState(Color.FromArgb(0, 140, 210))); //   // info        infoBtn.SetPassEvents(false); //   //     info //  hover    infoBtn.EventMouseHover += (sender, args) =&gt; { SetMouseHover(true); }; //     info   //      infoBtn.EventMouseClick += (sender, args) =&gt; { //  ImageItem ImageItem race = new ImageItem(DefaultsService.GetDefaultImage( EmbeddedImage.User, EmbeddedImageSize.Size32x32), false); race.SetSizePolicy(SizePolicy.Fixed, SizePolicy.Fixed); race.SetSize(32, 32); race.SetAlignment(ItemAlignment.Left, ItemAlignment.Top); race.SetColorOverlay(_race.GetColorOverlay()); //  PopUpMessage popUpInfo = new PopUpMessage( _characterInfo.Name + "\n" + "Age: " + _characterInfo.Age + "\n" + "Sex: " + _characterInfo.Sex + "\n" + "Race: " + _characterInfo.Race + "\n" + "Class: " + _characterInfo.Class); //    3  popUpInfo.SetTimeOut(3000); popUpInfo.SetHeight(200); //   //  ,    //    popUpInfo.Show(GetHandler()); //      popUpInfo.AddItem(race); }; //   ButtonCore removeBtn = new ButtonCore(); removeBtn.SetBackground(Color.FromArgb(255, 40, 40, 40)); removeBtn.SetSizePolicy(SizePolicy.Fixed, SizePolicy.Fixed); removeBtn.SetSize(10, 10); removeBtn.SetAlignment(ItemAlignment.VCenter, ItemAlignment.Right); removeBtn.SetCustomFigure(new CustomFigure(false, GraphicsMathService.GetCross(10, 10, 2, 45))); removeBtn.AddItemState(ItemStateType.Hovered, new ItemState(Color.FromArgb(200, 95, 97))); //       removeBtn removeBtn.EventMouseClick += (sender, args) =&gt; { RemoveSelf(); //  }; //      CharacterCard AddItems(_race, _name, infoBtn, removeBtn); } internal void RemoveSelf() { //         GetParent().RemoveItem(this); } public override String ToString() { return _characterInfo.ToString(); } } }</span></span></code> </pre> </div></div><br><p>  In dem Beispiel habe ich eine Hilfsklasse verwendet, die alle grundlegenden Merkmale des Charakters wie Name, Nachname, Rasse, Geschlecht, Alter, Spezialisierungsklasse, Merkmale, F√§higkeiten und Biografie enth√§lt.  In dieser Klasse werden alle Parameter au√üer F√§higkeiten und Biografie (es wird davon ausgegangen, dass der Benutzer sie unabh√§ngig erfindet) generiert. </p><br><h4 id="obrabotka-sobytiy-i-ih-filtraciya">  Ereignisverarbeitung und Filterung </h4><br><p>  Im vorherigen Beispiel wurden zwei Arten von Ereignissen beschrieben: MouseHover und MouseClick.  Derzeit gibt es nur 11 Basisereignisse. Hier ist die Liste: </p><br><ul><li>  EventMouseHover </li><li>  EventMouseLeave </li><li>  EventMouseClick </li><li>  EventMouseDoubleClick </li><li>  EventMousePress </li><li>  EventMouseDrag </li><li>  EventScrollUp </li><li>  EventScrollDown </li><li>  EventKeyPress </li><li>  EventKeyRelease </li><li>  EventTextInput </li></ul><br><p>  Komplexe Elemente haben ihre eigenen einzigartigen Ereignisse, aber die oben genannten Ereignisse stehen (mit Vorbehalt) jedem zur Verf√ºgung. </p><br><p>  Die Syntax f√ºr die Ereignisbehandlung ist trivial und sieht folgenderma√üen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// C# item.EventMouseClick += (sender, args) =&gt; { // - };</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java item.eventMouseClick.add((sender, args) -&gt; { // - });</span></span></code> </pre> <br><p>  Fahren wir nun mit dem Filtern von Ereignissen fort.  Standardm√§√üig durchlaufen Ereignisse eine Pyramide von Elementen.  In unserem Beispiel erh√§lt die Schaltfl√§che <code>infoBtn</code> das Ereignis des <code>infoBtn</code> auf die Schaltfl√§che auf der <code>infoBtn</code> Schaltfl√§che. Dieses Ereignis empf√§ngt dann das <code>CharacterCard</code> Element, dann die <code>ListBox</code> in der es sich befindet, dann <code>SplitArea</code> , <code>VerticalStack</code> und am Ende das grundlegende <code>Wontainer</code> Element. </p><br><p>  F√ºr jedes Element k√∂nnen Sie das <code>EventMouseClick</code> Ereignis verarbeiten, und alle diese Aktionen werden in der angegebenen Reihenfolge ausgef√ºhrt. Was ist jedoch, wenn wir beim Klicken auf ein Element nicht m√∂chten, dass dieses Ereignis weiter entlang der Kette verl√§uft?  Daf√ºr gibt es nur eine Ereignisfilterung.  Lassen Sie uns beispielsweise das <code>CharacterCard</code> Element deutlicher darstellen.  Stellen Sie sich vor, <code>CharacterCard</code> beschreibt das <code>EventMouseClick</code> Ereignis, bei dem Informationen aus der verkn√ºpften <code>CharacterInfo</code> in ein Textfeld zum Bearbeiten eines Zeichens <code>EventMouseClick</code> .  Dieses Verhalten ist logisch - wir klicken auf das Element und sehen alle Parameter des Zeichens.  Als n√§chstes bearbeiten wir den Charakter, erfinden eine Biografie und F√§higkeiten oder √§ndern die Eigenschaften.  Irgendwann wollten wir eine kurze Information √ºber ein anderes generiertes Zeichen aus der Liste sehen und auf die Schaltfl√§che infoBtn klicken.  Wenn wir die Ereignisse nicht filtern, wird EventMouseClick nach dem Aufrufen des Tooltips f√ºr das <code>CharacterCard</code> Element selbst ausgef√ºhrt, das, wie wir uns erinnern, Text in das Zeichenbearbeitungsfeld einf√ºgt, was zum Verlust von √Ñnderungen f√ºhrt, wenn wir die Ergebnisse nicht speichern, und das Verhalten der Anwendung selbst wird unlogisch aussehen.  Daher k√∂nnen wir den Filter mit der Methode <code>infoBtn.SetPassEvents(false)</code> , damit das Ereignis nur auf der Schaltfl√§che ausgef√ºhrt wird. </p><br><p>  Wenn Sie diese Methode auf diese Weise aufrufen, √ºberspringt die Schaltfl√§che keine Ereignisse mehr nach sich selbst.  Angenommen, wir m√∂chten nicht nur Mausklickereignisse √ºberspringen, <code>infoBtn.SetPassEvents(false, InputEventType.MousePress, MouseRelease)</code> eine Methode mit anderen Parametern aufrufen, z. B. <code>infoBtn.SetPassEvents(false, InputEventType.MousePress, MouseRelease)</code> . </p><br><p>  Somit ist es m√∂glich, Ereignisse bei jedem Schritt zu filtern, um das gew√ºnschte Ergebnis zu erzielen. </p><br><p>  Sie k√∂nnen sich noch einmal die Anwendung ansehen, die sich am Ende herausgestellt hat.  Nat√ºrlich werden hier Details zur Implementierung der Gesch√§ftslogik weggelassen, insbesondere die Generierung von Charakteren, ihre F√§higkeiten und vieles mehr, was nicht mehr direkt mit SpaceVIL zusammenh√§ngt.  Der vollst√§ndige Anwendungscode kann √ºber den Link zu GitHub eingesehen werden. Dort gibt es bereits einige andere Beispiele f√ºr die Arbeit mit SpaceVIL, sowohl in C # als auch in Java. </p><br><div class="spoiler">  <b class="spoiler_title">Screenshot der fertigen CharacterEditor-Anwendung</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sc/hj/tc/schjtchdgjoprbwxcsls0b-x2_m.png"></p></div></div><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Abschlie√üend m√∂chte ich Sie daran erinnern, dass sich das Framework in der aktiven Entwicklung befindet, sodass Abst√ºrze und Abst√ºrze m√∂glich sind sowie einige Funktionen √ºberarbeitet werden k√∂nnen und das Endergebnis der Verwendung radikal von dem aktuellen abweichen kann. Wenn die aktuelle Version des Frameworks zu Ihnen passt, vergessen Sie dies nicht Backup dieser Version, da ich nicht garantieren kann, dass neue Versionen abw√§rtskompatibel sind.  Einige Punkte k√∂nnen wiederholt werden, um den Komfort und die Geschwindigkeit der Verwendung von SpaceVIL zu erh√∂hen, und m√∂chten bisher keine alten und verworfenen Ideen in die L√§nge ziehen.  Au√üerdem wurde die Arbeit von SpaceVIL aufgrund fehlender Ausr√ºstung nicht auf Grafikkarten von AMD getestet.  Die Tests wurden mit Grafikkarten von Intel und NVidia durchgef√ºhrt.  Die Weiterentwicklung von SpaceVIL wird sich auf das Hinzuf√ºgen neuer Funktionen (zum Beispiel gibt es derzeit keine Unterst√ºtzung f√ºr Farbverl√§ufe) und die Optimierung konzentrieren. </p><br><p>  Ich m√∂chte auch eine Einschr√§nkung erw√§hnen, die beim Schreiben einer plattform√ºbergreifenden Anwendung mit dieser Technologie beachtet werden sollte. Es wird nicht empfohlen, Dialogfelder zu verwenden (und im Allgemeinen aufgrund von Renderfehlern Anwendungen mit mehreren Fenstern unter Linux zu erstellen). Dialogfelder k√∂nnen leicht durch Dialogelemente ersetzt werden.  Mac OS X verbietet im Allgemeinen die Erstellung von Anwendungen mit mehreren Fenstern, da die GUI nur im Hauptanwendungsthread gestartet werden muss. </p><br><p>  Sie k√∂nnen das Framework der erforderlichen Version und alle vorgestellten Beispiele f√ºr Testprogramme unter den folgenden Links herunterladen.  Die erste Version der Dokumentation finden Sie auch hier. </p><br><p>  Zum Schluss noch eine visuelle Demonstration.  Im Folgenden finden Sie Anwendungen, die mit der SpaceVIL-Technologie geschrieben wurden und Ihnen m√∂glicherweise eine Vorstellung davon geben, was Sie mit SpaceVIL erreichen k√∂nnen. </p><br><div class="spoiler">  <b class="spoiler_title">Screenshots von Anwendungen, die mit SpaceVIL geschrieben wurden</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/a-/dx/dl/a-dxdlpcpgm3phqlxmpp1j2cpcw.png"></p><br><p><img src="https://habrastorage.org/webt/jg/c0/6-/jgc06-am6250tpk8csit3idoezy.png"></p><br><p><img src="https://habrastorage.org/webt/uh/ft/_z/uhft_zhswe8ysgmqiaya9dikz5k.png"></p><br><p><img src="https://habrastorage.org/webt/mf/mc/2u/mfmc2uquoyfbevi4_qf9yax2tc8.png"></p><br><p><img src="https://habrastorage.org/webt/8c/wa/ii/8cwaiictybg0oq839xrzqp9vqtm.png"></p></div></div><br><h4 id="ssylki">  Referenzen </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spacevil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Codebeispiele</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448790/">https://habr.com/ru/post/de448790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448778/index.html">Einf√ºhrung in das Zeitreise-Debugging f√ºr Visual Studio Enterprise 2019</a></li>
<li><a href="../de448780/index.html">Was gibt Software f√ºr die Rekrutierung in Geld</a></li>
<li><a href="../de448784/index.html">Neue Funktionen f√ºr Erweiterungsautoren in Visual Studio 2019 Version 16.1</a></li>
<li><a href="../de448786/index.html">Python-Test mit Pytest. KAPITEL 3 Pytest-Vorrichtungen</a></li>
<li><a href="../de448788/index.html">Python-Test mit Pytest. Kapitel 2, Schreiben von Testfunktionen</a></li>
<li><a href="../de448794/index.html">Python-Test mit Pytest. Plugins KAPITEL 5</a></li>
<li><a href="../de448796/index.html">Python-Test mit Pytest. Konfiguration, KAPITEL 6</a></li>
<li><a href="../de448798/index.html">Python-Test mit Pytest. Verwenden von pytest mit anderen Tools, KAPITEL 7</a></li>
<li><a href="../de448800/index.html">Konfigurieren Sie Visual Studio in Ihrer Organisation mit .vsconfig</a></li>
<li><a href="../de448802/index.html">Mit Portalen denken: Portale in Unreal Engine 4 erstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>