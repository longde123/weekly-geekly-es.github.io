<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏻 🔃 🎦 Pengembangan server TELNET berbasis W5500 dan ATMEGA8 🖖🏼 📗 🐥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, kompleks perangkat lunak dan perangkat keras Arduino telah menjadi sangat populer, yang dirancang untuk mengembangkan berbagai desain e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan server TELNET berbasis W5500 dan ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414211/">  Baru-baru ini, kompleks perangkat lunak dan perangkat keras Arduino telah menjadi sangat populer, yang dirancang untuk mengembangkan berbagai desain elektronik yang menarik.  Desain dibuat dengan menghubungkan alas tiang Arduino dengan modul tambahan yang diperlukan.  Pada alas tiang Arduino ada mikrokontroler, firmware yang ditulis dalam lingkungan pengembangan khusus untuk Arduino menggunakan, sebagai aturan, perpustakaan siap pakai untuk satu atau modul lain. <br><br>  Salah satu modul - W5500 - dimaksudkan untuk pembuatan struktur elektronik yang akan terhubung ke Internet.  Dalam hal ini, paling sering, ini berarti kendali jarak jauh dari strukturnya.  Misalnya, itu bisa menjadi "rumah pintar", robot, dan sejenisnya.  Proyek yang paling sepele (kecuali Hello world) adalah penyertaan jarak jauh LED melalui peramban web (Gbr. 1).  Jika, alih-alih LED, saklar transistor dan relay tersambung, beban yang lebih kuat dapat diaktifkan.  Jadi, pada dasarnya, program (firmware) dari desain ini adalah server web yang memproses permintaan http dari pengguna jarak jauh. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qj/xj/w5/qjxjw5zozlcgxty2zaxpld3tfow.jpeg"></div>  <i>Fig.</i>  <i>1. Manajemen LED melalui browser.</i> <br><br>  Modul W5500 didasarkan pada chip W5500 itu sendiri dengan body kitnya, serta konektor BLS untuk MK melalui SPI, konektor RJ-45 untuk menghubungkan ke jaringan komputer, dan regulator tegangan linier untuk 3,3 V (Gbr. 2). <br><br><img src="https://habrastorage.org/webt/ta/sd/nz/tasdnz169igf5gzmdd6geetdsc4.jpeg" width="375" height="375"><br><br>  <i>Fig.</i>  <i>2. Modul W5500.</i> <br><br>  Chip W5500 adalah pengontrol penuh dengan pemrosesan terintegrasi dari setumpuk protokol jaringan, dari Ethernet ke TCP (Gbr. 3).  Menerapkan desain berdasarkan chip ini, programmer tidak perlu menulis kode pemrosesan protokol TCP / IP, cukup hanya menerapkan protokol lapisan aplikasi, yang akan tertanam dalam TCP.  Pada contoh di atas (pada Arduino), http digunakan sebagai protokol aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5n/a0/dx/5na0dx-_xgs06can1rxipmlul7y.jpeg"></div>  <i>Fig.</i>  <i>3. Struktur chip W5500.</i> <br><br>  Tanpa melakukan Arduino, saya memutuskan untuk mempelajari dokumentasi untuk chip W5500 secara rinci dan secara mandiri mengimplementasikan program berdasarkan mikrokontroler Atmega8.  Program ini tidak akan menyertakan pengendali http.  Diperlukan untuk mengimplementasikan pertukaran data paling sederhana (RAW) melalui protokol TCP menggunakan terminal jarak jauh.  Tidak sepenuhnya akurat untuk berbicara tentang protokol Telnet, seperti judul artikel ini.  Ini memiliki fitur spesifiknya sendiri berdasarkan pertukaran informasi tambahan tentang parameter terminal.  Namun, sebagian besar klien telnet mendukung RAW dan tidak memerlukan hal di atas.  Dengan demikian, program Atmega8 MK tidak akan menyertakan pengendali protokol tingkat aplikasi.  Dia hanya akan berurusan dengan inisialisasi W5500, manajemen soket, penerimaan data dan transmisi. <br><br>  Aplikasi utama dari desain ini adalah manajemen perangkat melalui terminal jarak jauh.  Dalam hal ini, desain terhubung ke perangkat yang dikelola melalui antarmuka UART (tiga kabel GND, TxD, RxD).  Manajemen melalui terminal adalah pendekatan profesional klasik di area tertentu tanpa adanya antarmuka grafis.  Misalnya, baris perintah Windows atau Linux, atau cara mengkonfigurasi router melalui terminal menggunakan protokol Telnet.  Contoh terakhir sebenarnya setara dengan ide yang dibahas dalam artikel ini. <br><br>  Saat mengembangkan perangkat ini atau itu, jika perlu, saya membayangkan mengendalikannya dengan perintah teks melalui terminal yang terhubung melalui antarmuka UART.  Ini dapat berupa koneksi ke PC biasa ke port RS-232 COM melalui chip adaptor MAX232, atau ke USB (port COM virtual) melalui chip PL2303.  Anda dapat menggunakan program HyperTerminal standar sebagai terminal.  Dengan penyebaran smartphone Android, menjadi nyaman untuk terhubung melalui Bluetooth: modul Bluetooth (misalnya, HC-06) terhubung ke antarmuka UART perangkat, dan smartphone terhubung ke modul secara nirkabel.  Ada banyak aplikasi di Internet yang mengimplementasikan terminal melalui Bluetooth.  Dengan demikian, Anda dapat mengontrol perangkat melalui terminal dari ponsel melalui Bluetooth dalam jarak dekat.  Desain yang dibahas dalam artikel ini memungkinkan Anda untuk menerapkan kontrol melalui terminal menggunakan Internet.  Terminal bisa menjadi HyperTerminal standar, yang datang dengan Windows XP, atau Anda dapat menjalankan utilitas telnet dari baris perintah Windows dan bekerja di dalamnya.  Jika kita berbicara tentang smartphone, maka Anda dapat memilih salah satu aplikasi di Android (ada juga banyak di antaranya) (Gbr. 4). <br><br><img src="https://habrastorage.org/webt/4g/ia/x7/4giax7dezsah7q-pjb5eso6tftm.jpeg" width="400" height="640"><br><br>  <i>Fig.</i>  <i>4. Aplikasi untuk "terminal TCP" di Google Play.</i> <br><br>  Chip W5500 memiliki 8 soket independen, masing-masing memiliki memori untuk menerima dan mengirimkan informasi lebih dari 2 KB.  Total, total memori adalah 16 KB untuk menerima dan 16 KB untuk mengirim informasi.  Parameter ini digunakan secara default, tetapi jika perlu, pada tahap inisialisasi chip, memori dapat dialokasikan kembali melalui soket.  Aplikasi yang dijelaskan di sini akan menggunakan pengaturan memori default, dan semua 8 soket terlibat.  Setiap soket pada tahap inisialisasi ditetapkan banyak parameter, yang utamanya adalah mode operasinya dan port TCP.  Mode operasi kedelapan soket yang kita butuhkan adalah mode server TCP.  Anda harus menetapkan port yang berbeda untuk setiap soket.  Saya mengambil delapan port berturut-turut, mulai, misalnya, dari 4000. Pada tahap inisialisasi modul W5500, ditugaskan parameter jaringan yang ditransfer ke program Atmega8 MK: alamat IP, subnet mask, alamat IP gateway, dan bahkan alamat fisik MAC.  Pengaturan jaringan W5500 harus cocok dengan pengaturan jaringan rumah yang terhubung.  Saat menghubungkan dari jarak jauh ke perangkat yang kami deskripsikan, pengaturan terminal menunjukkan alamat host (alamat IP atau nama domain) dan port.  Alamat host merujuk ke perangkat W5500, dan port merujuk ke soket di perangkat.  Satu soket dapat bekerja hanya dengan satu koneksi.  Oleh karena itu, dimungkinkan untuk membuat delapan koneksi simultan yang independen.  Gambar 5 menunjukkan parameter koneksi dalam program HyperTerminal standar ke W5500 dengan alamat IP 192.168.0.111 ke soket 0 (port 4000).  Untuk terhubung ke Internet global (dari luar), Anda perlu mengkonfigurasi router rumah Anda dengan benar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gl/xf/dt/glxfdtxvfstq3pbj0_bguqpusm8.jpeg"></div>  <i>Fig.</i>  <i>5. Koneksi melalui TCP / IP dalam HyperTerminal.</i> <br><br>  Saya mencoba berbagai aplikasi terminal TCP, masing-masing memiliki kelebihan dan kekurangan.  Pertama-tama, dengan metode pengemasan paket TCP, dua kasing dapat dibedakan.  Dalam kasus pertama, paket TCP dihasilkan dan dikirim ke server segera ketika karakter dimasukkan di terminal.  Dengan demikian, bidang data dari setiap paket membutuhkan 1 byte dan berisi karakter yang dimasukkan oleh pengguna.  Program HyperTerminal berfungsi hanya dalam mode ini.  Dalam kasus kedua, set karakter (perintah) dimasukkan dalam bidang teks yang terpisah, dan ketika Anda mengklik tombol "Kirim", hanya satu paket dengan bidang data yang terbentuk, yang isinya adalah set karakter yang dimasukkan oleh pengguna.  Ukuran bidang data paket seperti itu dalam byte bertepatan dengan jumlah karakter yang dimasukkan.  Kasus kedua adalah yang paling disukai dan nyaman, serta ekonomis dalam lalu lintas.  Desain kami berfungsi dengan kedua case, mentransfer ke output (TxD) dari UART MK Atmega8 semua karakter yang dimasukkan oleh pengguna jarak jauh dari soket apa pun. <br><br>  Adapun organisasi pengalihan informasi dari server ke klien, di sini juga memiliki karakteristik mereka sendiri.  Dimungkinkan untuk membuat program MK menghasilkan paket TCP byte tunggal juga secara langsung, setelah menerima satu byte (karakter) pada kaki MK RxD UART.  Anda dapat membuat paket TCP dari satu set byte yang masuk ke MK dengan kehadiran sinyal tambahan khusus, yang hanya ada selama transmisi urutan dari perangkat yang terhubung (sinyal pengepakan).  Omong-omong, sinyal ini digunakan untuk mengalihkan MAX485 ke transmisi dalam hal mengubah antarmuka RS-232 menjadi half-duplex RS-485.  Namun, seperti yang saya yakini, akan lebih mudah untuk menggunakan timer, yaitu  penundaan kecil di mana penerimaan karakter dan pembentukan paket TCP akan dilakukan.  Ini adalah metode yang saya terapkan dalam konstruksi yang dijelaskan.  Ini berfungsi sebagai berikut.  Timer (waktunya diatur sekitar 0,3 detik). Dimulai ketika karakter pertama tiba dan direset ketika setiap karakter berikutnya tiba di UART MK.  Jika tidak ada karakter yang tiba dalam waktu yang ditentukan, paket dengan karakter yang diterima dibentuk dan dikirim ke klien, dan penghitung waktu berhenti.  Dalam kasus khusus saya, ada surat massal di semua soket yang terhubung dengan klien. <br><br>  Sekarang tentang privasi.  Terminal jarak jauh yang dijelaskan tidak dilindungi dari penyadapan dengan menggunakan penganalisa lalu lintas.  Bahkan protokol Telnet sendiri tidak menyediakan otentikasi dan enkripsi kata sandi.  Untuk ini, ada protokol terminal jarak jauh modern lainnya.  Dan dalam kasus Telnet, serta dalam kasus RAW (tanpa protokol aplikasi), Anda dapat menerapkan metode otentikasi kata sandi tidak langsung, yang hanya akan tidak efektif dengan intervensi yang disengaja secara sengaja.  Namun, metode otorisasi ini akan melindungi terhadap lalu lintas "kiri" yang tidak terkendali.  Itu bisa berasal dari spyware, yang, menyortir berbagai alamat IP penyedia yang dikenal dan berbagai port, tiba-tiba dapat terhubung ke perangkat kami (jika "mendengarkan" koneksi dari Internet).  Dalam firmware saya, saya menerapkan halaman sambutan klien, jika terhubung ke server, mis.  untuk desain berdasarkan pada modul W5500. <br><br>  Halaman pembuka berisi informasi tentang alamat IP klien, nomor soket (untuk pemantauan) dan permintaan untuk memasukkan kata sandi (Gbr. 6). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ea/nw/2q/eanw2qiq7wtm974w7brndgscqja.jpeg"></div>  <i>Fig.</i>  <i>6. Halaman pembuka untuk server W5500.</i> <br><br>  Setelah terkoneksi di dalam program MK, penghitung waktu dimulai (sekitar 18 detik), di mana pengguna harus memiliki waktu untuk memasukkan kata sandi tertentu (sama pada semua soket).  Jika kata sandi dimasukkan secara salah, setelah waktu yang ditentukan berlalu, pengguna menginformasikan pesan terkait dan server terputus (Gbr. 7). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/i5/rh/qii5rh4vsutckz8oyinxlurdsv8.jpeg"></div>  <i>Fig.</i>  <i>7. Melaporkan kata sandi yang salah.</i> <br><br>  Dalam hal kata sandi yang dimasukkan dengan benar, pengguna juga diperlihatkan pesan yang sesuai (Gbr. 8).  Setelah itu, jembatan "transparan" dibuat antara terminal jarak jauh dan antarmuka UART dari MK, di mana modul W5500 terhubung melalui SPI.  Operasi jembatan semacam itu diuji hanya pada tingkat tim pengguna.  Pertukaran data berkecepatan tinggi penuh mungkin tidak dijamin jika, dalam beberapa kasus, aplikasi klien bukan terminal pengguna, tetapi beberapa program lain.  Dan lebih dari itu, desain yang dijelaskan tidak menjamin (lebih tepatnya, tidak disediakan untuk) pertukaran data full-duplex. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9j/lx/4c/9jlx4c2o2sjavhkdq2gut43oo7m.jpeg"></div>  <i>Fig.</i>  <i>8. Pesan tentang kata sandi yang benar.</i> <br><br>  Ketika kata sandi dimasukkan, pengguna tidak mengembalikan karakter yang mereka masukkan ke terminal, dan juga "Backspace" tidak berfungsi (kembalikan dengan karakter yang dimasukkan salah).  Panjang kata sandi adalah 8 karakter.  Program MK memindai 8 karakter pertama yang diterima dari klien, terlepas dari distribusinya melalui paket TCP.  Tetapi paket apa pun tidak boleh melebihi 10 byte.  Omong-omong, fungsi "Kirim File Teks" di HyperTerminal bekerja dengan cukup menarik.  Ketika diperiksa menggunakan penganalisa lalu lintas, ketika fungsi ini dilakukan, dua paket TCP terbentuk: paket pertama dengan data 1 byte berisi karakter pertama dari file teks yang ditransmisikan, dan paket kedua berisi sisa konten. <br><br>  Server menyediakan dua kata sandi yang berbeda.  Satu kata sandi digunakan untuk membangun jembatan TCP-UART (penggunaan normal), seperti dijelaskan di atas, dan kata sandi kedua digunakan untuk mengontrol modul W5500 atau parameter desain lainnya.  Jika kata sandi ini dimasukkan, pengguna akan ditampilkan halaman selamat datang lain, dan ia memasuki mode kontrol.  Saya sengaja menyediakan bahwa mode ini hanya mungkin pada salah satu soket gratis.  Jika soket dengan mode ini sibuk, dan upaya untuk masuk ke mode ini di soket lain, koneksi akan segera diputuskan oleh server.  Sebelum jeda, pesan akan ditampilkan tentang nomor soket yang sudah berfungsi (sibuk) dalam mode kontrol (Gbr. 9). <br><br>  Mode kontrol menyediakan untuk perintah yang telah saya tentukan, daftar yang dapat dilihat dengan memasukkan perintah bantuan.  Perintah harus diakhiri dengan karakter baris baru (tombol Enter).  Selain itu, jika mode kontrol aktif, server W5500 mengirim pesan layanan ke terminal, misalnya, tentang menghubungkan klien ke soket lain dengan alamat IP mereka atau tentang soket gratis.  Gambar 10 menunjukkan hal di atas.  Daftar tim belum lengkap, itu akan diisi ulang seiring waktu. <br><br><img src="https://habrastorage.org/webt/mb/bu/v_/mbbuv_bfry1kuj83z8wgwzxwbqm.jpeg" width="400" height="340"><br><br>  <i>Fig.</i>  <i>9. Pesan tentang soket yang sibuk saat memasukkan kata sandi mode kontrol.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/es/dk/sn/esdksn_il5ajj_btzatrxlaxeb4.jpeg"></div>  <i>Fig.</i>  <i>10. Mode kontrol W5500.</i> <br><br>  Perintah echo menonaktifkan atau memungkinkan pengembalian karakter yang dicetak ke terminal (swa-monitor).  Dua perintah berikut adalah untuk membaca dan menulis register alamat chip W5500.  Nilai register untuk alamat ditunjukkan dalam dokumentasi untuk chip W5500.  Saya memperkenalkan perintah universal ini, terutama untuk debugging.  Perintah rl segera mem-boot ulang nomor soket yang ditunjukkan setelah.  Demikian pula, perintah sr membaca status soket, memberikan nilainya sebagai nomor HEX.  Perintah "ens" memberikan tabel status untuk setiap soket: status "0" - soket bebas, menunggu klien, menyatakan "1" - soket dalam penggunaan normal, menyatakan "2" - soket dalam mode kontrol.  Anda dapat memasukkan jumlah perintah yang jauh lebih besar.  Akan berguna untuk mengubah parameter yang masuk ke dalam chip pada tahap inisialisasi ketika perangkat dihidupkan (misalnya, parameter jaringan), menyimpannya dalam memori non-volatile dari MK.  Mungkin juga berguna untuk memasukkan perintah khusus yang akan mengontrol pin MK tambahan gratis.  Misalnya, “PC0 = 1,” “PC2 = 0,” dll.  Pastikan Anda membutuhkan perintah konfigurasi antarmuka UART MK. <br><br>  Pertimbangkan rincian pekerjaan Program MK yang lebih halus.  Selain pengatur waktu yang disebutkan di atas, pengatur waktu diaktifkan, yang karenanya, setiap sekitar setengah menit, disebut  Paket kontrol TCP "tetap hidup".  Ini diperlukan untuk memverifikasi koneksi tanpa adanya pertukaran data pengguna.  Jika karena alasan apa pun tidak ada konfirmasi dari klien dalam waktu tertentu yang ditetapkan di dalam W5500, yang disebut  batas waktu dan soket akan reboot.  Koneksi mungkin tiba-tiba hilang, misalnya, karena putus pada tautan data atau lapisan fisik: mereka menarik kabel Ethernet, memutus Internet, atau kehilangan koneksi Wi-Fi, dll. <br><br>  Berdasarkan dokumentasi untuk chip W5500 (lembar data), fungsi-fungsi berikut ini diimplementasikan dalam kode program.  Pertama, fungsi dasar menulis dan membaca register W5500 ke alamat.  Fungsi tingkat atas - reset perangkat keras, inisialisasi chip, inisialisasi soket, membuka soket, mendengarkan soket, melepaskan dan menutup soket, mengirim perintah “keep_alive”, me-reboot soket.  Fungsi terakhir adalah komposisi dari fungsi-fungsi di atas: menutup, membuka, mendengarkan.  Sebagian besar fungsi mengembalikan nilai status soket setelah dijalankan.  Akhirnya, fungsi paling dasar adalah memproses informasi yang diterima (membaca dari buffer RX) dan memproses informasi yang dikirim (menulis ke buffer TX).  Saya mengambil rekomendasi tentang implementasi fungsi-fungsi ini dari situs resmi produsen chip W5500 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ).  Fungsi terima menimpa data yang diterima dari buffer RX ke dalam buffer non-ring 128-byte miliknya.  Ukuran ini cukup untuk aplikasi sederhana, dan Anda tidak bisa mendapatkan banyak dari mikrokontroler Atmega8.  Buffer TX dari W5500 juga mentransfer data dari buffer antara, yang juga berukuran kecil.  Dan pada gilirannya, data dari buffer cincin UART masuk ke dalamnya.  Yang terakhir diimplementasikan secara otomatis di lingkungan pengembangan CVAVR menggunakan utilitas CodeWizardAVR pada tahap pembuatan proyek. <br><br>  W5500 terhubung ke antarmuka MKI SPI (MOSI, MISO, SCK, SCLK).  Selain itu, pin RST (reset perangkat keras) terhubung ke output MK tertentu, dan pin INT yang terkait terhubung ke input interupsi eksternal INT0.  Yang terakhir digunakan untuk tujuan yang dimaksudkan: Ketika suatu peristiwa terjadi dalam modul W5500, ia menghasilkan pulsa di pin INT, yang diproses oleh pengontrol di tubuh interupsi eksternal.  MK mengetahui di mana soket peristiwa itu terjadi, kemudian menulis ulang kode acara untuk setiap soket ke dalam larik tertentu.  Pemrosesan interupsi lebih lanjut terjadi di dalam loop program utama.  Secara total, lima peristiwa didokumentasikan: klien terhubung, klien terputus (lebih tepatnya, mengajukan permintaan putuskan), data diterima dari klien, batas waktu bekerja, data berhasil dikirim.  Di loop utama, semua acara kecuali yang terakhir diproses.  Pernyataan kasus sakelar ditempatkan dalam pemrosesan ini.  Bagian terbesar dari kode C ditemukan di bagian pemrosesan acara ketiga (penerimaan data).  Di dalamnya, setelah fungsi memproses informasi yang diterima, operator switch-case juga ditempatkan, tetapi dalam kasus ini "switch" ini dikaitkan dengan variabel yang bertanggung jawab untuk keadaan soket yang disebutkan di atas (nilai 0, 1, 2).  Bagian pertama bertanggung jawab untuk prosedur pengenalan kata sandi.  Karakter yang diterima ditimpa dalam buffer kata sandi terpisah.  Dalam kondisi tertentu, fungsi membandingkan string yang diterima dengan string konstan yang berisi kata sandi berfungsi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika terjadi kebetulan, negara yang bersangkutan ditugaskan. Bagian kedua adalah yang paling sederhana - isi buffernya sendiri dari informasi yang diterima diarahkan ke UART mikrokontroler. Ini adalah mode penggunaan normal. Bagian ketiga (terbesar) bertanggung jawab untuk memproses perintah - mode kontrol perangkat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain melanjutkan interrupt handler, loop utama program berisi penangan timer virtual - batas waktu untuk memutus koneksi ketika kata sandi tidak berhasil, secara berkala mengirim pesan "tetap hidup" dan mengirim paket yang dibentuk oleh timer TCP ke klien. Fungsi membaca dari UART juga ditempatkan di badan loop utama, di dalamnya karakter yang diterima oleh pengontrol ditransfer ke buffer transmisinya sendiri (perantara) dan timer diatur ulang, yang bertanggung jawab untuk pembentukan paket TCP.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua prosedur soket ditempatkan dalam satu siklus dari 0 sampai 7, iterator yang terikat ke nomor soket. Dengan demikian, pemrosesan sekuensial dari semua soket terjadi. Awalnya, saya maksudkan bahwa jika Anda menetapkan nomor port yang sama untuk masing-masing dari delapan soket, maka Anda dapat menghubungkan hingga delapan pengguna pada port yang sama. Namun, konfigurasi ini tidak berfungsi, dan masalah ini telah ditunda untuk masa depan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat mendesain desain papan sirkuit, saya menyediakan jam waktu nyata (RTC) pada chip DS1307. Atmega8 MK, kuarsa untuk frekuensi 11,0592 MHz (frekuensi dipilih untuk akurasi UART), konektor untuk modul W5500, konektor port MK (termasuk SPI untuk firmware, UART), RTC dengan kompartemen baterai kuarsa dan CR2032 sendiri terletak pada papan sirkuit cetak dua sisi , 5 V regulator linier (7805), konektor daya dan banyak lagi. Sketsa papan sirkuit tercetak dalam program Sprint Layout ditunjukkan pada Gambar 11. Satu-satunya elemen yang ditunjukkan dengan warna merah disolder di sisi belakang, tetapi saya menyoldernya ke sisi depan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/po/fd/zapofdoavvxgcamlagyghd_zkae.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Sketsa papan sirkuit.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Foto-foto konstruksi selesai disajikan pada Gambar 12. Jam dalam konstruksi ini akan digunakan untuk menandai waktu selama berbagai peristiwa soket W5500, dan kali ini akan diberikan kepada pengguna di terminal di sebelah pesan jika pengguna terhubung dalam mode kontrol. Dan juga, jam akan berguna untuk masa depan untuk eksperimen dengan protokol waktu NTP atau untuk tujuan lain apa pun.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/fv/_r/hffv_rfjm1svqdgzmvmauahrmw0.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Foto-foto struktur yang sudah jadi.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebagai kesimpulan, perlu dicatat bahwa desain in-house untuk sebagian besar membenarkan perangkat tingkat industri yang serupa. Keuntungan utama adalah harga. Ternyata jauh lebih murah untuk diproduksi daripada harga perangkat serupa yang sudah jadi. Dan kelemahan seperti fungsi terbatas tidak bisa dihindari. Dalam hal ini, kontroler Atmega8 yang disederhanakan digunakan, karena tujuan yang disederhanakan yang sesuai telah ditetapkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hy/ko/fx/hykofxdictcvxijma6idea8hczq.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Konverter industri TCP / IP - RS-232.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gambar 13 menunjukkan contoh konverter TCP / IP ke RS-232 berdasarkan chip W5100, sangat mirip dengan W5500. Selain antarmuka manajemennya yang fleksibel, ia memiliki satu kelebihan lagi. Selain bekerja dengan terminal TCP / IP, dimungkinkan untuk menggunakan driver khusus yang datang dengan perangkat untuk menginstal port COM virtual di sisi klien. Melalui itu, Anda dapat terhubung menggunakan terminal reguler yang tidak memiliki mode koneksi TCP / IP. Selain itu, perangkat ini dapat mendukung pertukaran data RS-232 yang lengkap jika ada program yang terhubung dan bukan terminal melalui port COM virtual. Artinya, perangkat yang digambarkan dalam Gambar 13 adalah jembatan RS-232 penuh melalui infrastruktur jaringan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414211/">https://habr.com/ru/post/id414211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414199/index.html">Skynet, hai: kecerdasan buatan telah belajar untuk melihat orang melalui dinding</a></li>
<li><a href="../id414201/index.html">Divine Code (kode TUHAN)</a></li>
<li><a href="../id414203/index.html">Scam atau tidak scam? Kami memeriksa ICO dengan lima metode</a></li>
<li><a href="../id414207/index.html">Masalah inovator, atau mengapa Anda perlu beralih ke pengalaman orang lain</a></li>
<li><a href="../id414209/index.html">IGNG - Algoritma Incremental Neural Gas Bertambah</a></li>
<li><a href="../id414213/index.html">Satu, Dua, Tiga! Chatbot dari Google Sheets menggunakan contoh game PvP untuk Alice</a></li>
<li><a href="../id414215/index.html">Blok Kustom dalam Keripik (Silicon IP): Cara Kerja</a></li>
<li><a href="../id414217/index.html">Vertex smartphone lokal: pertama dalam kualitas, pertama dalam chip, pertama dalam desain</a></li>
<li><a href="../id414219/index.html">Pengalaman menggunakan energi surya di wilayah Moskow: untuk, melawan, dan siapa yang membutuhkannya</a></li>
<li><a href="../id414221/index.html">Parsing dan bekerja dengan Codable di Swift 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>