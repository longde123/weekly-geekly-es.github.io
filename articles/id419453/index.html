<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐳 ♏️ 👨‍👨‍👧‍👧 Metode numerik untuk memecahkan sistem persamaan nonlinier 📀 🍂 🧜🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Banyak masalah yang diterapkan mengarah pada kebutuhan untuk menemukan solusi umum untuk sistem persamaan nonlinier. Tidak ada solusi an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode numerik untuk memecahkan sistem persamaan nonlinier</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419453/"><h3>  Pendahuluan </h3><br>  Banyak masalah yang diterapkan mengarah pada kebutuhan untuk menemukan solusi umum untuk sistem persamaan nonlinier.  Tidak ada solusi analitis umum dari sistem persamaan nonlinier yang ditemukan.  Hanya ada metode numerik. <br><br>  Perlu dicatat fakta menarik bahwa sistem persamaan apa pun atas bilangan real dapat diwakili oleh satu persamaan yang setara, jika kita mengambil semua persamaan dalam bentuk <img src="https://habrastorage.org/webt/_q/09/hw/_q09hw6d1qeqerbgr7qhzfdcdfy.png">  , lipat persegi dan lipat. <br><br>  Untuk solusi numerik, metode iteratif dari pendekatan yang berurutan (iterasi sederhana) dan metode Newton dalam berbagai modifikasi digunakan.  Proses berulang secara umum digeneralisasikan ke kasus sistem persamaan nonlinear dari bentuk: <br><br><img src="https://habrastorage.org/webt/zf/ut/do/zfutdol9bhx0jy5lbge4jnfdjyk.png">  (1) <br><br>  Ditunjukkan oleh <img src="https://habrastorage.org/webt/4b/fu/a_/4bfua_k_3kyr5w5cfxvmgxeat_y.png">  vektor tidak diketahui dan mendefinisikan fungsi vektor <img src="https://habrastorage.org/webt/im/cc/m2/imccm2nlbj0rocyhlqidmboiwps.png">  Kemudian sistem (1) ditulis dalam bentuk persamaan: <br><br><img src="https://habrastorage.org/webt/5q/py/ph/5qpyphhrxupuofyzbeoxk8jviti.png">  (2) <br><br>  Sekarang, mari kita kembali ke Python tercinta kita dan catat keunggulannya di antara bahasa pemrograman yang ingin dipelajari [1]. <br><br><img src="https://habrastorage.org/webt/bx/x7/vz/bxx7vzxbfwqa-iaa5buw36pvvim.png"><br><br>  Fakta ini merupakan insentif tambahan untuk mempertimbangkan metode numerik dengan Python.  Namun, ada pendapat di kalangan pecinta Python bahwa fungsi perpustakaan khusus, seperti <b>scipy.optimize.root, spsolve_trianular, newton_krylov</b> , adalah pilihan terbaik untuk memecahkan masalah dengan metode numerik. <br><br>  Sulit untuk tidak setuju dengan ini, jika hanya karena berbagai modul juga mengangkat Python ke puncak popularitas.  Namun, ada kasus ketika, bahkan dengan pemeriksaan sepintas, menggunakan metode langsung dikenal tanpa menggunakan fungsi khusus dari SciPy library juga memberikan hasil yang baik.  Dengan kata lain, yang baru adalah yang lama terlupakan. <br><a name="habracut"></a><br>  Jadi, dalam publikasi [2], berdasarkan percobaan komputasi yang dilakukan, terbukti bahwa fungsi perpustakaan newton_krylov, yang dirancang untuk memecahkan sistem persamaan nonlinier besar, memiliki setengah kecepatan daripada algoritma TSLS + WD <br>  (dua langkah kuadrat terkecil) diimplementasikan oleh perpustakaan NumPy. <br><br>  <b>Tujuan dari publikasi ini</b> adalah untuk membandingkan jumlah iterasi, kecepatan, dan yang paling penting, hasil pemecahan masalah model dalam bentuk sistem seratus persamaan aljabar nonlinier menggunakan fungsi perpustakaan scipy.optimize.root dan metode Newton diimplementasikan menggunakan perpustakaan NumPy. <br><br><h3>  Scipy.optimize.root kemampuan solver untuk memecahkan sistem persamaan aljabar nonlinier secara numerik </h3><br>  Fungsi perpustakaan scipy.optimize.root dipilih sebagai basis perbandingan karena memiliki pustaka metode yang luas yang cocok untuk analisis komparatif. <br><br>  <b>scipy.optimize.root</b> ( <i>fun, x0, args = (), method = 'hybr', jac = Tidak ada, tol = Tidak ada, callback = Tidak ada, pion = Tidak ada</i> ) <br>  <i>fun</i> - Fungsi vektor untuk menemukan root. <br>  <i>x0</i> –Kondisi awal untuk menemukan root <br><br>  <b>metode:</b> <br>  <i>hybr -</i> Powell modifikasi dari metode hybrid digunakan; <br>  <i>lm</i> - memecahkan sistem persamaan nonlinier menggunakan metode kuadrat terkecil. <br>  Sebagai berikut dari dokumentasi [3], metode <b>broyden1, broyden2, anderson, linearmixing, diagbroyden, funmixing, krylov</b> adalah metode tepat Newton.  Parameter yang tersisa adalah "opsional" dan dapat ditemukan dalam dokumentasi. <br><br><h3>  Metode untuk memecahkan sistem persamaan nonlinier </h3><br>  Materi yang diberikan di bawah ini memang dapat dibaca dalam literatur, misalnya, dalam [4], tetapi saya menghormati pembaca saya dan, untuk kenyamanannya, menyajikan derivasi metode ini dalam bentuk singkat, jika mungkin.  Mereka yang <b>tidak suka formula</b> melewatkan bagian ini. <br><br>  Dalam metode Newton, pendekatan baru untuk menyelesaikan sistem persamaan (2) ditentukan dari solusi <b>sistem persamaan linear</b> : <br><br><img src="https://habrastorage.org/webt/oc/q3/_y/ocq3_yonljteqeoun-ep0euxsai.png">  (3) <br><br>  Definisikan matriks Jacobi: <br><br><img src="https://habrastorage.org/webt/iu/60/s-/iu60s-ro-taedqwb3fltgypmspu.png">  (4) <br><br>  Kami menulis (3) dalam bentuk: <br><br><img src="https://habrastorage.org/webt/gj/be/vm/gjbevmxcuhihbxakq57qfxsok6w.png">  (5) <br><br>  Banyak metode satu langkah untuk solusi perkiraan (2) secara analogi dengan metode iteratif dua lapis untuk menyelesaikan sistem persamaan aljabar linier dapat ditulis dalam bentuk: <br><br><img src="https://habrastorage.org/webt/sl/fu/fq/slfufq8wc4qnfmmeclx64qpubjw.png">  (6) <br><br>  dimana <img src="https://habrastorage.org/webt/pa/t0/0a/pat00a2ixfo34e_vfqtlgf_gchg.png">  Apakah parameter berulang, a <img src="https://habrastorage.org/webt/ta/xt/2z/taxt2zyydbeigde-xcqhry0wrtq.png">  - matriks persegi n x n memiliki kebalikannya. <br><br>  Saat menggunakan catatan (6), metode Newton (5) sesuai dengan pilihan: <br><br><img src="https://habrastorage.org/webt/n5/ii/zu/n5iizujlep0bnryijprpz8-bary.png"><br><br>  Sistem persamaan linear (5) untuk menemukan pendekatan baru <img src="https://habrastorage.org/webt/so/88/h5/so88h5-fmrzbs-aplenlaar3oo4.png">  dapat diselesaikan secara iteratif.  Dalam hal ini, kami memiliki proses iteratif dua tahap dengan iterasi eksternal dan internal.  Misalnya, proses iteratif eksternal dapat dilakukan sesuai dengan metode Newton, dan iterasi internal dapat dilakukan berdasarkan <b>metode iteratif Seidel.</b> <br><br>  Ketika memecahkan sistem persamaan nonlinear, seseorang dapat menggunakan analog langsung dari metode iteratif standar yang digunakan untuk menyelesaikan sistem persamaan linear.  Metode Seidel non-linear sebagaimana diterapkan pada solusi (2) memberikan: <br><br><img src="https://habrastorage.org/webt/hx/lf/wk/hxlfwknytaf-n4yc3njkqjjx6lo.png">  (7) <br><br>  Dalam hal ini, setiap komponen perkiraan baru dari solusi persamaan nonlinier dapat diperoleh berdasarkan metode iterasi sederhana dan metode Newton dalam berbagai modifikasi.  Dengan demikian, kita kembali ke metode iteratif dua tahap di mana iterasi eksternal dilakukan sesuai dengan metode Seidel, dan iterasi internal dilakukan menggunakan metode Newton. <br><br>  Kesulitan komputasi utama dalam menerapkan metode Newton untuk solusi perkiraan sistem persamaan nonlinier <b>terkait dengan kebutuhan untuk menyelesaikan sistem persamaan linear dengan matriks Jacobi di setiap iterasi</b> , dan matriks ini berubah dari iterasi ke iterasi.  Dalam metode Newton yang dimodifikasi, matriks Jacobi hanya dibalik satu kali: <br><br><img src="https://habrastorage.org/webt/y-/0p/tv/y-0ptvinni3bzhzirltojgjxkxc.png">  (8) <br><br><h3>  Pemilihan fungsi model </h3><br>  Pilihan seperti itu bukanlah tugas yang sederhana, karena dengan peningkatan jumlah persamaan dalam sistem sesuai dengan peningkatan jumlah variabel, hasil solusi tidak boleh berubah, karena jika tidak, tidak mungkin untuk melacak kebenaran solusi dari sistem persamaan ketika membandingkan dua metode.  Saya membawa solusi berikut untuk fungsi model: <br><br><pre><code class="python hljs">n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f</code> </pre> <br>  <b>Fungsi f menciptakan sistem n persamaan nonlinier, solusinya tidak tergantung pada jumlah persamaan dan sama dengan kesatuan untuk masing-masing variabel n.</b> <br><br><h3>  Suatu program untuk pengujian pada fungsi model dengan hasil penyelesaian sistem persamaan nonlinier aljabar menggunakan fungsi perpustakaan optim.root untuk berbagai metode menemukan akar </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time ti = time.clock() n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f x0 =zeros([n]) sol = optimize.root(f,x0, method=<span class="hljs-string"><span class="hljs-string">'krylov'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Solution:\n'</span></span>, sol.x) print(<span class="hljs-string"><span class="hljs-string">'Krylov method iteration = '</span></span>,sol.nit) print(<span class="hljs-string"><span class="hljs-string">'Optimize root time'</span></span>, round(time.clock()-ti,<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'seconds'</span></span>)</code> </pre> <br>  Hanya salah satu metode yang diberikan dalam dokumentasi [3] yang lulus <b>pengujian pada hasil penyelesaian fungsi model, ini adalah metode 'krylov'</b> . <br><br>  Solusi untuk n = 100: <br><br>  Solusi: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1.] <br>  Metode iterasi Krylov = 4219 <br>  Optimalkan waktu root 7,239 detik: <br><br><div class="spoiler">  <b class="spoiler_title">Solusi untuk n = 200</b> <div class="spoiler_text">  Solusi: <br>  [1.00000018 0.99999972 0.99999985 1.00000001 0.99999992 1.00000049 <br>  0.99999998 0.99999992 0.99999991 1.00000001 1.00000013 1.00000002 <br>  0.9999997 0.99999987 1.00000005 0.99999978 1.0000002 1.00000012 <br>  1,00000023 1,00000017 0,99999979 1,00000012 1,00000026 0,99999987 <br>  1,00000014 0,99999979 0,99999988 1,00000046 1,00000064 1,00000007 <br>  1,00000049 1,00000005 1,00000032 1,00000031 1,00000028 0,99999992 <br>  1,0000003 1,0000001 0,99999971 1,00000023 1,00000039 1,0000003 <br>  1,00000013 0,9999999 0,99999993 0,99999996 1,00000008 1,00000016 <br>  1,00000034 1,00000004 0,99999993 0,99999987 0,99999969 0,99999985 <br>  0.99999981 1.00000051 1.0000004 1.00000035 0.9999998 1.00000065 <br>  1,00000061 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 1,0000006 <br>  1,0000006 1,0000006 1,0000006 1,0000006 1,00000059 1,00000056 <br>  1,00000047 1,00000016 1,00000018 0,99999988 1,00000061 1,00000002 <br>  1,00000033 1,00000034 1,0000004 1,00000046 1,00000009 1,00000024 <br>  1,00000017 1,00000014 1,00000054 1,00000006 0,99999964 0,99999968 <br>  1,00000005 1,00000049 1,0000005 1,00000028 1,00000029 1,00000027 <br>  1,00000027 0,9999998 1,00000005 0,99999974 0,99999978 0,99999988 <br>  1,00000015 1,00000007 1,00000005 0,99999973 1,00000006 0,99999995 <br>  1,00000021 1,00000031 1,00000058 1,00000023 1,00000023 1,00000044 <br>  0.99999985 0.99999948 0.99999977 0.99999991 0.99999974 0.99999978 <br>  0.99999983 1.0000002 1.00000016 1.00000008 1.00000013 1.00000007 <br>  0.99999989 0.99999959 1.00000029 1.0000003 0.99999972 1.00000003 <br>  0.99999967 0.99999977 1.00000017 1.00000005 1.00000029 1.00000034 <br>  0.99999997 0.99999989 0.99999945 0.99999985 0.99999994 0.99999972 <br>  1,00000029 1,00000016] <br>  Pengulangan metode Krylov = 9178 <br>  Optimalkan waktu root 23,397 detik <br></div></div><br>  <b>Kesimpulan:</b> Dengan peningkatan jumlah persamaan hingga setengahnya, tampilan kesalahan dalam solusi terlihat.  Dengan peningkatan lebih lanjut dalam n, solusi menjadi tidak dapat diterima, yang dimungkinkan karena adaptasi otomatis ke langkah, alasan yang sama untuk penurunan tajam dalam kinerja.  Tapi ini hanya dugaanku. <br><br><h3>  Program untuk menguji fungsi model dengan hasil penyelesaian sistem persamaan nonlinier aljabar menggunakan program yang ditulis dalam Python 3 dengan mempertimbangkan hubungan akun (1) - (8) untuk menemukan akar menggunakan metode Newton yang dimodifikasi </h3><br><div class="spoiler">  <b class="spoiler_title">Program untuk menemukan akar sesuai dengan metode Newton yang dimodifikasi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time ti = time.clock() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jacobian</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x)</span></span></span><span class="hljs-function">:</span></span> h = <span class="hljs-number"><span class="hljs-number">1.0e-4</span></span> n = len(x) Jac = zeros([n,n]) f0 = f(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n,<span class="hljs-number"><span class="hljs-number">1</span></span>): tt = x[i] x[i] = tt + h f1= f(x) x[i] = tt Jac [:,i] = (f1 - f0)/h <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Jac, f0 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x, tol=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0e-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> iterMax = <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(iterMax): Jac, fO = jacobian(f, x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sqrt(dot(fO, fO) / len(x)) &lt; tol: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x, i dx = linalg.solve(Jac, fO) x = x - dx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"Too many iterations for the Newton method"</span></span>) n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f x0 =zeros([n]) x, iter = newton(f, x0) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'Solution:\n'</span></span>, x) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'Newton iteration = '</span></span>, iter) print(<span class="hljs-string"><span class="hljs-string">'Newton method time'</span></span>, round(time.clock()-ti,<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'seconds'</span></span>)</code> </pre> <br></div></div><br>  Solusi untuk n = 100: <br><br>  Solusi: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1.] <br>  Iterasi Newton = 13 <br>  Metode Newton waktu 0,496 detik <br><br>  Solusi untuk n = 200: <br><br>  Solusi: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1.] <br>  Iterasi Newton = 14 <br>  Metode Newton waktu 1,869 detik <br><br>  Untuk memastikan bahwa program benar-benar menyelesaikan sistem, kami menulis ulang fungsi model untuk menghindari root dengan nilai 1 dalam formulir <br><br><pre> <code class="python hljs">n=<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i]*sin([i]) - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>+e**-x[i] f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f</code> </pre> <br>  Kami mendapatkan: <br>  Solusi: <br>  [0.96472166 0.87777036 0.48175823 -0.26190496 -0.63693762 0.49232062 <br>  -1.31649896 0.6865098 0.89609091 0.98509235] <br>  Iterasi Newton = 16 <br>  Metode Newton waktu 0,046 detik <br><br>  Kesimpulan: <b>Program juga berfungsi ketika fungsi model berubah.</b> <br><br>  Sekarang kita kembali ke fungsi model awal dan memeriksa rentang yang lebih luas untuk n, misalnya, pada 2 dan 500. <br>  n = 2 <br>  Solusi: <br>  [1.  1.] <br>  Iterasi Newton = 6 <br>  Metode Newton waktu 0,048 detik <br>  n = 500 <br><div class="spoiler">  <b class="spoiler_title">n = 500</b> <div class="spoiler_text">  Solusi: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] <br>  Iterasi Newton = 15 <br>  Metode Newton waktu 11,754 detik <br></div></div><br><h3>  Kesimpulan: </h3><br>  Sebuah program yang ditulis dengan Python menggunakan metode Newton yang dimodifikasi, ketika menyelesaikan sistem persamaan nonlinear dari fungsi model yang diberikan, memiliki stabilitas solusi yang lebih tinggi daripada ketika menyelesaikan menggunakan fungsi perpustakaan mengoptimalkan.root (f, x0, metode = 'krylov') untuk metode Krylov.  Mengenai kecepatan kesimpulan akhir, tidak mungkin untuk menggambar karena pendekatan yang berbeda untuk pengendalian langkah. <br><br>  Referensi: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peringkat bahasa pemrograman 2018.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cooper I.V., Faleychik B.V.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proses iteratif non-matriks dengan penekanan rata-rata akar kuadrat untuk sistem persamaan nonlinier besar.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scipy.optimize.root.</a> </li><li>  Vabishchevich P.N.  Metode numerik: Lokakarya komputasi.  - M .: Book House "LIBROCOM", 2010. - 320 p. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419453/">https://habr.com/ru/post/id419453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419437/index.html">AR - Augmented Reality (artikel plus video)</a></li>
<li><a href="../id419439/index.html">Bagaimana e-commerce bertahan dalam promosi skala besar. Bersiap untuk beban puncak di web [Bagian 2]</a></li>
<li><a href="../id419441/index.html">SpaceX pertama menggunakan kembali roket Falcon 9 Block 5 hari ini</a></li>
<li><a href="../id419449/index.html">API Redux vs. Bereaksi Konteks</a></li>
<li><a href="../id419451/index.html">Buat bundel untuk Symfony 4 langkah demi langkah</a></li>
<li><a href="../id419457/index.html">RabbitMQ - SQL Server</a></li>
<li><a href="../id419459/index.html">Baterai timbal-asam: alfabet pengisian daya pulsa</a></li>
<li><a href="../id419461/index.html">Ventilasi kamar kecil</a></li>
<li><a href="../id419467/index.html">Dari bola lampu hingga penyedot debu dan dengung - bagaimana kami mengajari Alice mengelola ratusan perangkat</a></li>
<li><a href="../id419469/index.html">UE4 | Siklus siang dan malam | Modifikasi SkySphere</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>