<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë¶ ü§õüèø üåâ G√©n√©ration de l'analyseur PEG üëä üìü üë®üèæ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maintenant que j'ai esquiss√© les bases d'un analyseur propri√©taire, passons √† la g√©n√©ration de ses m√©thodes √† partir de la grammaire, comme je l'ai pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√©n√©ration de l'analyseur PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471864/"><p> Maintenant que j'ai esquiss√© les bases d'un analyseur propri√©taire, passons √† la g√©n√©ration de ses m√©thodes √† partir de la grammaire, comme je l'ai promis.  Je montrerai √©galement comment impl√©menter un analyseur packrat en utilisant le d√©corateur <code>@memoize</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Contenu de la s√©rie Python PEG Parser</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyseurs de cheville</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©n√©ration de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visualisation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grammaire r√©cursive gauche du PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajout d'actions √† la grammaire PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©ta grammaire pour l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation des fonctionnalit√©s restantes de PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEG sur Core Developer Sprint</a> </li></ul></div></div><br><p>  La derni√®re fois, nous avons examin√© quelques m√©thodes d'analyse.  Avec certaines restrictions que nous supprimerons un peu plus tard, elles sont faciles √† g√©n√©rer automatiquement √† partir de la grammaire. </p><a name="habracut"></a><br><p>  Nous avons besoin de deux choses: quelque chose qui lit la grammaire et construit une structure de donn√©es appropri√©e;  et quelque chose qui prend cette structure de donn√©es et g√©n√®re un analyseur.  Nous avons √©galement besoin d'autres m√©thodes d'aide, mais elles ne sont pas int√©ressantes, je vais donc les omettre. </p><br><p>  Donc, nous cr√©ons un compilateur de compilateur simple.  Je vais simplifier un peu la notation grammaticale dans la mesure o√π nous n'avons que des r√®gles et des alternatives;  c'est en fait suffisant pour la grammaire du jouet que j'ai utilis√©e dans les parties pr√©c√©dentes: </p><br><pre> <code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  En utilisant la notation compl√®te, nous pouvons d√©crire la grammaire comme: </p><br><pre> <code class="plaintext hljs">grammar: rule+ ENDMARKER rule: NAME ':' alternative ('|' alternative)* NEWLINE alternative: item+ item: NAME | STRING</code> </pre> <br><p>  Il s'agit de notre premi√®re m√©ta-grammaire (grammaire pour les grammaires), et notre g√©n√©rateur d'analyseur sera un m√©ta-compilateur (un compilateur est un programme qui traduit des programmes d'une langue √† une autre; un m√©ta-compilateur est un compilateur o√π l'entr√©e est une grammaire, et la sortie est un analyseur). </p><br><p>  Un moyen simple de d√©crire une m√©ta-grammaire consiste √† utiliser uniquement les types de donn√©es int√©gr√©s: la partie droite de la r√®gle est une liste de listes d'√©l√©ments, chacun pouvant √™tre simplement une cha√Æne.  (Soit dit en passant, nous pouvons s√©parer <code>NAME</code> et <code>STRING</code> en v√©rifiant si le premier caract√®re est un guillemet) </p><br><p>  Pour les r√®gles, j'utilise la classe <code>Rule</code> simple, et toute la grammaire est une liste de ces objets.  Voici la classe <code>Rule</code> , √† l'exclusion de <code>__repr__</code> et <code>__eq__</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rule</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, alts)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.alts = alts</code> </pre> <br><p>  Et voici la classe <code>GrammarParser</code> qui l'utilise: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GrammarParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grammar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rule := self.rule(): rules = [rule] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> rule := self.rule(): rules.append(rule) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.expect(ENDMARKER): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rules <span class="hljs-comment"><span class="hljs-comment"># &lt;------------- final result self.reset(pos) return None def rule(self): pos = self.mark() if name := self.expect(NAME): if self.expect(":"): if alt := self.alternative(): alts = [alt] apos = self.mark() while (self.expect("|") and (alt := self.alternative())): alts.append(alt) apos = self.mark() self.reset(apos) if self.expect(NEWLINE): return Rule(name.string, alts) self.reset(pos) return None def alternative(self): items = [] while item := self.item(): items.append(item) return items def item(self): if name := self.expect(NAME): return name.string if string := self.expect(STRING): return string.string return None</span></span></code> </pre> <br><p>  Faites attention √† l'utilisation de <code>ENDMARKER</code> .  L√†, je m'assure qu'il ne reste rien apr√®s la derni√®re r√®gle (et cela peut arriver s'il y a une faute de frappe dans la grammaire).  J'ai √©galement indiqu√© l'endroit o√π la m√©thode <code>grammar()</code> renvoie une liste de r√®gles.  Tout le reste est tr√®s similaire √† la classe <code>ToyParser</code> du dernier article, donc je ne m'y attarderai pas.  Notez simplement que <code>item()</code> retourne une cha√Æne, <code>alternative()</code> retourne une liste de cha√Ænes, et la variable <code>alts</code> int√©rieur de <code>rule()</code> recueille une liste de liste de cha√Ænes.  Ensuite, la m√©thode <code>rule()</code> combine le nom de la r√®gle (cha√Æne) et le convertit en objet <code>Rule</code> . </p><br><p>  Si nous appliquons cet algorithme √† notre grammaire du jouet, la m√©thode <code>grammar()</code> renverra la liste de r√®gles suivante: </p><br><pre> <code class="plaintext hljs">[ Rule('statement', [['assignment'], ['expr'], ['if_statement']]), Rule('expr', [['term', "'+'", 'expr'], ['term', "'-'", 'term'], ['term']]), Rule('term', [['atom', "'*'", 'term'], ['atom', "'/'", 'atom'], ['atom']]), Rule('atom', [['NAME'], ['NUMBER'], ["'('", 'expr', "')'"]]), Rule('assignment', [['target', "'='", 'expr']]), Rule('target', [['NAME']]), Rule('if_statement', [["'if'", 'expr', "':'", 'statement']]), ]</code> </pre> <br><p>  Maintenant que nous avons la partie d'analyse de notre m√©ta-compilateur, cr√©ons un g√©n√©rateur de code.  Ensemble, ils forment un m√©ta-compilateur √©l√©mentaire: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_parser_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rules)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">f"class ToyParser(Parser):"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rules: print() print(<span class="hljs-string"><span class="hljs-string">f" @memoize"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" def </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name}</span></span></span><span class="hljs-string">(self):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" pos = self.mark()"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: items = [] print(<span class="hljs-string"><span class="hljs-string">f" if (True"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> alt: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'"'</span></span>, <span class="hljs-string"><span class="hljs-string">"'"</span></span>): print(<span class="hljs-string"><span class="hljs-string">f" and self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: var = item.lower() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items: var += str(len(items)) items.append(var) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item.isupper(): print(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">())"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" ):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"return Node(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name!r}</span></span></span><span class="hljs-string">, [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">', '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.join(items)}</span></span></span><span class="hljs-string">])"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" self.reset(pos)"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" return None"</span></span>)</code> </pre> <br><p>  Ce code est assez moche, mais il fonctionne (en quelque sorte), et √† l'avenir je le r√©√©crirai quand m√™me. </p><br><p>  Certaines lignes √† l'int√©rieur de la <code>for alt in rule.alts</code> peuvent n√©cessiter une explication: pour chaque √©l√©ment de l'alternative, nous choisissons l'une des 3 options: </p><br><ul><li>  si l'√©l√©ment est un litt√©ral de cha√Æne, par exemple <code>'+'</code> , nous g√©n√©rons <code>self.expect('+')</code> </li><li>  si l'√©l√©ment est enti√®rement en majuscule, par exemple <code>NAME</code> , nous g√©n√©rons <code>(name := self.expect(NAME))</code> </li><li>  sinon, par exemple, si elle est <code>expr</code> , nous g√©n√©rons <code>(expr := self.expr())</code> </li></ul><br><p>  S'il y a plusieurs √©l√©ments avec le m√™me nom dans une variante (par exemple, le <code>term '-' term</code> ), alors nous ajoutons un chiffre √† la seconde.  Il y a aussi une petite erreur que je corrigerai dans le prochain √©pisode. </p><br><p>  Voici un peu le r√©sultat de son travail (toute la classe serait tr√®s ennuyeuse).  Ne vous inqui√©tez pas du code redondant <code>if (True and</code> ... <code>)</code> qui est n√©cessaire pour que chaque condition g√©n√©r√©e puisse commencer par <code>and</code> .  Le compilateur d'octets Python optimise cela. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> @memoize <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (assignment := self.assignment()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [assignment]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (expr := self.expr()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [expr]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (if_statement := self.if_statement()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [if_statement]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ...</code> </pre> <br><p>  Faites attention au d√©corateur <code>@memoize</code> : je l'ai introduit pour passer √† un autre sujet: utiliser la m√©morisation pour rendre l'analyseur g√©n√©r√© assez rapidement. </p><br><p>  Voici la fonction <code>memoize()</code> qui impl√©mente ce d√©corateur: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  Comme dans d'autres d√©corateurs, il contient une fonction imbriqu√©e qui remplace (ou enveloppe) une fonction d√©cor√©e, par exemple, la m√©thode <code>statement()</code> de la classe <code>ToyParser</code> .  √âtant donn√© que la fonction encapsul√©e est une m√©thode, l'encapsuleur est √©galement une m√©thode: son premier argument est appel√© <code>self</code> et fait r√©f√©rence √† l'instance <code>ToyParser</code> pour laquelle la m√©thode d√©cor√©e est appel√©e. </p><br><p>  L'encapsuleur met en cache le r√©sultat de l'appel de m√©thode pour chaque position d'entr√©e - c'est pourquoi il est appel√© l'analyseur packrat!  [env.  trans.  packrat est un ¬´voleur¬ª, mais ce terme n'est pas traduit dans les sources en russe.] Cache est un dictionnaire de dictionnaires, qui est stock√© dans une instance <code>Parser</code> .  La cl√© du dictionnaire externe est la position dans le flux de donn√©es d'entr√©e;  J'ai √©galement ajout√© <code>self.memos = {}</code> √† <code>Parser .__ init__()</code> pour l'initialiser.  Des dictionnaires internes sont ajout√©s au besoin;  leurs cl√©s consistent en une m√©thode et ses arguments.  (Il n'y a pas d'arguments dans la conception actuelle, mais nous pourrions m√©moriser la fonction <code>expect()</code> qui en a une, ce qui est assez trivial) </p><br><p>  Le r√©sultat de la m√©thode d'analyse est pr√©sent√© sous la forme d'un tuple, car il y a vraiment deux valeurs: le r√©sultat lui-m√™me (pour nos m√©thodes g√©n√©r√©es, c'est <code>Node</code> pour la r√®gle de correspondance) et un pointeur vers la position actuelle dans le flux d'entr√©e, que nous obtenons de <code>self.mark()</code> .  Ainsi, nous mettons en cache √† la fois la valeur de retour ( <code>res</code> ) et la nouvelle position ( <code>endpos</code> ) dans le dictionnaire interne avec des valeurs m√©moris√©es.  Lors des appels ult√©rieurs √† la m√™me m√©thode d'analyse avec les m√™mes arguments dans la m√™me position d'entr√©e, nous les retirerons du cache.  Pour ce faire, d√©placez simplement le pointeur sur la position d'entr√©e √† l'aide de <code>self.reset()</code> et regardez dans le cache. </p><br><p>  Il est √©galement important de mettre en cache les r√©sultats n√©gatifs - en fait, la plupart des appels seront n√©gatifs.  Dans ce cas, la valeur de retour est <code>None</code> et la position d'entr√©e ne change pas.  Vous pouvez ajouter <code>assert</code> pour v√©rifier cela. </p><br><p>  Remarque  En Python, il est habituel d'impl√©menter un cache dans une variable locale dans la fonction <code>memoize()</code> .  Dans notre cas, cela ne fonctionnera pas: comme je l'ai d√©couvert √† la toute fin du d√©bogage, chaque instance de <code>Parser</code> doit avoir son propre cache.  Cependant, vous pouvez vous d√©barrasser des dictionnaires imbriqu√©s en utilisant ( <code>pos</code> , <code>func</code> , <code>args</code> ) comme cl√©. </p><br><p>  La semaine prochaine, je pr√©parerai du code et des traces pour montrer comment tout cela est r√©ellement assembl√© et ex√©cut√© lors de l'analyse d'un exemple de programme.  Je suis toujours √† la recherche d'un meilleur moyen de visualiser la collaboration du tampon de tokenisation, de l'analyseur et du cache.  Je pourrai peut-√™tre cr√©er un gif anim√© en ASCII au lieu d'afficher simplement les listes de trace sous forme de texte. </p><br><p>  Licence pour cet article et code cit√©: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471864/">https://habr.com/ru/post/fr471864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471854/index.html">Heat Death 5G</a></li>
<li><a href="../fr471856/index.html">Nous r√©solvons les 42 versions du puzzle de potion Harry Potter</a></li>
<li><a href="../fr471858/index.html">RabbitMQ contre Kafka: basculement et haute disponibilit√© dans les clusters</a></li>
<li><a href="../fr471860/index.html">Analyseurs de cheville</a></li>
<li><a href="../fr471862/index.html">Impl√©mentation de l'analyseur PEG</a></li>
<li><a href="../fr471866/index.html">Visualisation de l'analyseur PEG</a></li>
<li><a href="../fr471868/index.html">G√©n√©tique de l'amour: le conflit entre les sexes comme base de coop√©ration dans des couples d'oiseaux monogames</a></li>
<li><a href="../fr471872/index.html">Interfaces en C # 8: hypoth√®ses dangereuses dans l'impl√©mentation par d√©faut</a></li>
<li><a href="../fr471874/index.html">Comment nous avons contourn√© les directives d'examen et lanc√© un serveur par t√©l√©phone</a></li>
<li><a href="../fr471876/index.html">PDU et All-All-All: distribution d'alimentation en rack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>