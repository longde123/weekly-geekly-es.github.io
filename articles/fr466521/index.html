<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ§ üî∞ ‚ÜòÔ∏è C for Metal - m√©tal pr√©cieux pour l'informatique sur les cartes graphiques Intel üê∂ üôÜüèª üè•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Combien de c≈ìurs de processeur Intel avez-vous sur votre ordinateur? Si vous utilisez un syst√®me bas√© sur Intel, dans la grande majorit√© des cas, vous...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C for Metal - m√©tal pr√©cieux pour l'informatique sur les cartes graphiques Intel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/466521/">  Combien de c≈ìurs de processeur Intel avez-vous sur votre ordinateur?  Si vous utilisez un syst√®me bas√© sur Intel, dans la grande majorit√© des cas, vous devrez en ajouter un √† votre r√©ponse.  Presque tous les processeurs Intel - d'Atom √† Xeon E3, bien s√ªr, sans manquer le Core, incluent depuis de nombreuses ann√©es le noyau graphique int√©gr√© Intel Graphics, qui est essentiellement un processeur √† part enti√®re et, par cons√©quent, capable non seulement d'afficher des images √† l'√©cran et d'acc√©l√©rer la vid√©o, mais aussi effectuer des calculs √† usage g√©n√©ral "ordinaires".  Comment cela peut-il √™tre utilis√© efficacement?  Regardez sous la coupe. <br><br><img src="https://habrastorage.org/webt/od/zy/qg/odzyqgwdoyvgvhlbsvulnty_doo.jpeg"><br><a name="habracut"></a><br>  Tout d'abord, nous expliquerons bri√®vement pourquoi le recours √† un processeur graphique Intel en vaut la peine.  Bien s√ªr, les performances du processeur dans le syst√®me d√©passent presque toujours de mani√®re significative le GPU, car il s'agit √©galement du processeur central. <br><br>  Mais il est int√©ressant de noter que les performances des processeurs graphiques int√©gr√©s Intel au cours de la derni√®re d√©cennie ont augment√© en pourcentage beaucoup plus que celles du processeur, et cette tendance se poursuivra certainement avec l'av√®nement de nouvelles cartes graphiques Intel discr√®tes.  De plus, le GPU, de par son architecture (de nombreux dispositifs d'ex√©cution vectorielle), est beaucoup mieux adapt√© √† l'ex√©cution d'un certain type de t√¢ches - le traitement d'images, c'est-√†-dire, en fait, √† effectuer toutes op√©rations du m√™me type sur des tableaux de donn√©es.  Le GPU le fait avec une parall√©lisation interne compl√®te, y d√©pense moins d'√©nergie que le CPU et, dans certains cas, le d√©passe m√™me en vitesse absolue.  Enfin, le GPU et le CPU peuvent fonctionner en parall√®le, chacun sur ses propres t√¢ches, offrant des performances maximales et / ou une consommation d'√©nergie minimale de l'ensemble du syst√®me. <br><br>  - D'accord, Intel.  Nous avons d√©cid√© d'utiliser le GPU Intel pour les calculs √† usage g√©n√©ral, comment le faire? <br>  - La mani√®re la plus simple qui ne n√©cessite aucune connaissance particuli√®re en graphisme (shaders Direct3D et OpenGL) est OpenCL. <br><br>  Les noyaux OpenCL sont ind√©pendants de la plate-forme et s'ex√©cuteront automatiquement sur tous les p√©riph√©riques informatiques disponibles dans le syst√®me - CPU, GPU, FPGA, etc.  Mais le prix d'une telle polyvalence est loin des performances maximales possibles sur chaque type d'appareil, et notamment sur le GPU Intel int√©gr√©.  Ici, nous pouvons donner un exemple: lors de l'ex√©cution de code sur n'importe quel GPU Intel qui transpose une matrice 16x16 octets, l'avantage de performance de la programmation directe du GPU Intel sera 8 fois plus √©lev√© qu'avec la version OpenCL! <br><br>  De plus, certaines des fonctionnalit√©s requises pour impl√©menter des algorithmes courants (par exemple, des "filtres larges" qui utilisent des donn√©es provenant d'un grand groupe de pixels dans une seule transformation), OpenCL ne le prend tout simplement pas en charge. <br><br>  Par cons√©quent, si vous avez besoin d'une vitesse maximale sur le GPU et / ou de quelque chose de plus compliqu√© que de travailler ind√©pendamment avec chaque √©l√©ment de la matrice et ses voisins les plus proches, alors Intel C for Metal (ICM), un outil pour d√©velopper des applications fonctionnant sur Intel Graphics, vous aidera . <br><br><h2>  <font color="#0071c5">ICM - bienvenue dans la forge!</font> </h2><br>  En termes de performances et de fonctionnalit√©s, ICM peut √™tre consid√©r√© comme ¬´assembleur pour cartes graphiques Intel¬ª, et en termes de circuits et de convivialit√© - ¬´un analogue d'OpenCL pour les cartes graphiques Intel¬ª. <br><br>  Pendant de nombreuses ann√©es, ICM a √©t√© utilis√© en interne par Intel dans le d√©veloppement de produits de traitement multim√©dia sur le GPU Intel.  Mais en 2018, ICM a √©t√© rendu public, et m√™me en open source! <br><br>  Intel C for Metal a obtenu son nom actuel il y a quelques mois, avant qu'il s'appelait Intel C for Media (le m√™me acronyme ICM ou simplement CM ou m√™me Cm), et plus t√¥t encore - Media Development Framework (MDF).  Donc, si quelque part dans le nom du composant, dans la documentation ou dans les commentaires open source, les anciens noms se rencontrent - ne vous inqui√©tez pas, c'est une valeur historique. <br><br>  Ainsi, le code d'application ICM, tout comme dans OpenCL, contient deux parties: celle ¬´administrative¬ª, ex√©cut√©e sur le processeur, et le noyau, ex√©cut√© sur le GPU.  Sans surprise, la premi√®re partie est appel√©e l'h√¥te, et la seconde est le noyau. <br><br>  Les noyaux sont une fonction du traitement d'un bloc de pixels donn√© (ou simplement des donn√©es), sont √©crits dans le langage Intel C for Metal et compil√©s dans le jeu d'instructions GPU Intel (ISA) √† l'aide du compilateur ICM. <br><br>  L'h√¥te est une sorte de ¬´gestionnaire d'√©quipe du noyau¬ª, il g√®re le processus de transfert de donn√©es entre le processeur et le GPU et effectue d'autres ¬´travaux de gestion¬ª via la biblioth√®que d'ex√©cution ICM Runtime et le pilote de m√©dia Intel GPU. <br>  Un flux de travail ICM d√©taill√© ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/a1/q4/ola1q4zotlteitoqxvmttsuulu0.png"></div><br><ul><li>  Le code h√¥te ICM est compil√© par n'importe quel compilateur x86 C / C ++ avec l'application enti√®re; </li><li>  Le code du noyau ICM est compil√© par le compilateur ICM dans un fichier binaire avec un ensemble d'instructions communes (Common ISA); </li><li>  Au moment de l'ex√©cution, cet ensemble g√©n√©ral d'instructions JIT se traduit par un processeur graphique Intel sp√©cifique; </li><li>  L'h√¥te ICM appelle la biblioth√®que d'ex√©cution ICM pour communiquer avec le GPU et le syst√®me d'exploitation. </li></ul><br>  Quelques points plus importants et utiles: <br><br><ul><li>  Les surfaces utilis√©es dans ICM pour repr√©senter / stocker des donn√©es peuvent √™tre partag√©es avec DirectX 11 et 9 (DXVA sur Linux). </li><li>  Le GPU peut prendre et √©crire des donn√©es de la m√©moire vid√©o et de la m√©moire syst√®me partag√©es avec le CPU.  ICM comprend des fonctions sp√©ciales pour les deux cas de transfert de donn√©es dans les deux sens.  Dans le m√™me temps, la m√©moire syst√®me est exactement partag√©e et aucune copie r√©elle n'est requise - pour cela, la copie dite z√©ro est fournie dans ICM. </li></ul><br><h2>  <font color="#0071c5">ICM - dans l'√©vent du volcan!</font> </h2><br>  D√©j√† du nom ¬´C for Iron¬ª lui-m√™me, il s'ensuit que la langue de l'appareil correspond √† l'appareil graphique interne Intel.  Autrement dit, il prend en compte le fait que le code sera ex√©cut√© sur plusieurs dizaines d'unit√©s d'ex√©cution de la carte graphique, dont chacune est un processeur enti√®rement vectoriel capable d'ex√©cuter plusieurs threads simultan√©ment. <br><br>  Le langage ICM lui-m√™me est C ++ avec quelques limitations et extensions.  Par rapport √† C ++, ICM manque ... de pointeurs, d'allocation de m√©moire et de variables statiques.  En vertu de l'interdiction √©galement des fonctions r√©cursives.  Mais il existe une programmation par mod√®le vectoriel explicite (SIMD): types de donn√©es vectorielles - vecteur, matrice et surface;  op√©rations vectorielles sur ces types de donn√©es, conditions vectorielles si / sinon, ex√©cut√©es ind√©pendamment pour chaque √©l√©ment du vecteur;  ainsi que des fonctions int√©gr√©es pour acc√©der aux fonctionnalit√©s fixes du mat√©riel Intel GPU. <br><br>  Le travail avec des vecteurs, des matrices et des surfaces dans des t√¢ches r√©elles est facilit√© par des objets de ¬´sous-ensembles¬ª - parmi les objets de base correspondants, vous ne pouvez choisir que les blocs ¬´de r√©f√©rence¬ª qui vous int√©ressent ou, comme cas sp√©cial, des √©l√©ments individuels par masque. <br><br>  Par exemple, regardons le code ICM qui impl√©mente un filtre lin√©aire - remplacement d'une valeur <br>  Couleurs RVB de chaque pixel par sa valeur moyenne et 8 voisins dans l'image: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/0q/xk/of/0qxkofxlflf0p_pxmtzgvcd7aze.png"></td><td>  <b>I (x, y) = [I (x-1, y-1) + I (x-1, y) + I (x-1, y + 1) + I (x, y-1) +</b> <b><br></b>  <b>+ I (x, y) + I (x, y + 1) + I (x + 1, y-1) + I (x + 1, y) + I (x + 1, y + 1)] / 9</b> <br></td></tr></tbody></table></div><br>  Si les couleurs (donn√©es) dans la matrice sont situ√©es comme <b>R8G8B8</b> , alors le calcul avec la division de l'image d'entr√©e en blocs de 6x8 pixels (√©l√©ments de donn√©es 6x24 octets) sera le suivant: <br><br><pre><code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">GENX_MAIN_ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceIndex inBuf, SurfaceIndex outBuf, uint h_pos, uint v_pos)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    8x32 matrix&lt;uchar, 8, 32&gt; in; //   6x24 matrix&lt;uchar, 6, 24&gt; out; matrix&lt;float, 6, 24&gt; m; //    read(inBuf h_pos*24, v_pos*6, in); //    -  m = in.select&lt;6,1,24,1&gt;(1,3); m += in.select&lt;6,1,24,1&gt;(0,0); m += in.select&lt;6,1,24,1&gt;(0,3); m += in.select&lt;6,1,24,1&gt;(0,6); m += in.select&lt;6,1,24,1&gt;(1,0); m += in.select&lt;6,1,24,1&gt;(1,6); m += in.select&lt;6,1,24,1&gt;(2,0); m += in.select&lt;6,1,24,1&gt;(2,3); m += in.select&lt;6,1,24,1&gt;(2,6); //  -   9   * 0.111f; out = m * 0.111f; //   write(outBuf, h_pos*24, v_pos*6, out); }</span></span></code> </pre> <br><ul><li>  La taille des matrices est d√©finie sous la forme &lt;type de donn√©es, hauteur, largeur&gt;; </li><li>  l' <i>op√©rateur select &lt;v_size, v_stride, h_size, h_stride&gt; (i, j)</i> renvoie la sous-matrice en commen√ßant par l'√©l√©ment <i>(i, j)</i> , <i>v_size</i> affiche le nombre de lignes s√©lectionn√©es, <i>v_stride</i> - la distance entre les lignes s√©lectionn√©es <i>h_size</i> - le nombre de colonnes s√©lectionn√©es, <i>h_stride</i> - la distance entre elles . </li></ul><br>  Veuillez noter que la taille de la matrice d'entr√©e 8x32 est choisie car bien que le bloc 8x30 soit algorithmiquement suffisant pour calculer les valeurs de tous les pixels du bloc 6x24, le bloc de donn√©es est lu en ICM non pas en octets, mais en √©l√©ments dword 32 bits. <br><br>  Le code ci-dessus est en fait un noyau ICM √† part enti√®re.  Comme mentionn√©, il sera compil√© par le compilateur ICM en deux √©tapes (pr√©compilation et traduction JIT ult√©rieure).  Le compilateur ICM est construit sur la base de LLVM et, si vous le souhaitez, peut √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©tudi√© dans les sources et construit par vous-m√™me</a> . <br><br>  Mais que fait l'h√¥te ICM?  Appelle les fonctions de biblioth√®que d'ex√©cution ICM Runtime qui: <br><br><ul><li>  Cr√©er, initialiser et supprimer apr√®s avoir utilis√© le p√©riph√©rique GPU (CmDevice), ainsi que les surfaces contenant des donn√©es utilisateur utilis√©es dans les noyaux (CmSurface); </li><li>  Travailler avec des noyaux - t√©l√©chargez-les √† partir de fichiers <i>.isa</i> pr√©compil√©s, pr√©parez leurs arguments, en indiquant la partie des donn√©es avec laquelle chaque noyau fonctionnera; </li><li>  Cr√©er et g√©rer la file d'attente d'ex√©cution du noyau; </li><li>  Ils contr√¥lent le fonctionnement des threads ex√©cutant chaque noyau sur le GPU; </li><li>  G√©rer les √©v√©nements (CmEvent) - objets de synchronisation du GPU et du CPU; </li><li>  Transf√©rer des donn√©es entre le GPU et le CPU, ou plut√¥t, entre le syst√®me et la m√©moire vid√©o; </li><li>  Signaler les erreurs, mesurer le temps de fonctionnement des noyaux. </li></ul><br>  Le code h√¥te le plus simple ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  CmDevice cm_result_check(::CreateCmDevice(p_cm_device, version)); //  hello_world_genx.isa std::string isa_code = isa::loadFile("hello_world_genx.isa"); //    isa  CmProgram CmProgram *p_program = nullptr; cm_result_check(p_cm_device-&gt;LoadProgram(const_cast&lt;char* &gt;(isa_code.data()),isa_code.size(), p_program)); //  hello_world . CmKernel *p_kernel = nullptr; cm_result_check(p_cm_device-&gt;CreateKernel(p_program, "hello_world", p_kernel)); //       CmKernel CmThreadSpace *p_thread_space = nullptr; cm_result_check(p_cm_device-&gt;CreateThreadSpace(thread_width, thread_height, p_thread_space)); //   . cm_result_check(p_kernel-&gt;SetKernelArg(0, sizeof(thread_width), &amp;thread_width)); //  CmTask ‚Äì      //         //     . CmTask *p_task = nullptr; cm_result_check(p_cm_device-&gt;CreateTask(p_task)); cm_result_check(p_task-&gt;AddKernel(p_kernel)); //   CmQueue *p_queue = nullptr; cm_result_check(p_cm_device-&gt;CreateQueue(p_queue)); //    GPU (    ). CmEvent *p_event = nullptr; cm_result_check(p_queue-&gt;Enqueue(p_task, p_event, p_thread_space)); //   . cm_result_check(p_event-&gt;WaitForTaskFinished());</span></span></code> </pre> <br>  Comme vous pouvez le voir, il n'y a rien de compliqu√© √† cr√©er et √† utiliser des noyaux et un h√¥te.  Tout est simple! <br><br>  La seule difficult√© √† mettre en garde pour retourner dans le monde r√©el: actuellement dans la version publique d'ICM, le seul moyen de d√©boguer les noyaux est les messages printf.  Comment les utiliser correctement peut √™tre vu dans l'exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hello, World</a> . <br><br><h2>  <font color="#0071c5">ICM - pas du heavy metal!</font> </h2><br>  Voyons maintenant comment cela fonctionne dans la pratique.  Le kit de d√©veloppement ICM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est disponible pour Windows et Linux</a> , et pour les deux syst√®mes d'exploitation contient le compilateur ICM, la documentation et les cas d'utilisation du didacticiel.  Une description d√©taill√©e de ces exemples de formation est <a href="">t√©l√©charg√©e s√©par√©ment</a> . <br><br>  Pour Linux, le package comprend √©galement un pilote de m√©dia en mode utilisateur pour VAAPI avec une biblioth√®que d'ex√©cution ICM Runtime int√©gr√©e.  Pour Windows, le pilote graphique Intel habituel pour Windows fonctionnera avec ICM.  La biblioth√®que d'ex√©cution ICM Runtime est incluse dans l'ensemble dll de ce pilote.  Le package ICM inclut uniquement le fichier de lien .lib correspondant.  Si le pilote est absent de votre syst√®me pour une raison quelconque, il est t√©l√©charg√© sur le site Web d'Intel et le bon fonctionnement d'ICM dans les pilotes est garanti, √† partir de la version 15.60 - 2017). <br><br>  Le code source des composants peut √™tre trouv√© ici: <br><br><ul><li>  Pilote Intel Media pour VAAPI et Intel C pour Media Runtime: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/intel/media-driver</a> </li><li>  Intel C pour Media Compiler et exemples: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/intel/cm-compiler</a> </li><li>  Intel Graphics Compiler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/intel/intel-graphics-compiler</a> </li></ul><br>  Le contenu suppl√©mentaire de cette section s'applique exclusivement √† Windows, mais les principes g√©n√©raux de travail avec ICM sont √©galement applicables √† Linux. <br><br>  Pour le travail ¬´normal¬ª avec le package ICM, vous aurez besoin de Visual Studio √† partir de 2015 et de Cmake √† partir de la version 3.2.  Dans le m√™me temps, les fichiers de configuration et de script des exemples de formation sont con√ßus pour VS 2015. Pour utiliser des versions plus r√©centes des fichiers VS, vous devrez √©tudier et modifier vous-m√™me les chemins d'acc√®s aux composants VS. <br><br>  Alors, d√©couvrez ICM pour Windows: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√©l√©chargez l'archive</a> ; </li><li>  D√©ballez-le; </li><li>  Nous d√©marrons (de pr√©f√©rence sur la ligne de commande VS) le script de configuration de l'environnement setupenv.bat avec trois param√®tres - la g√©n√©ration de GPU Intel (correspondant au processeur dans lequel le GPU est int√©gr√©, il peut √™tre laiss√© par d√©faut: gen9), la plateforme de compilation: x86 \ x64 et la version DirectX pour partage avec ICM: dx9 / dx11. </li></ul><br>  Apr√®s cela, vous pouvez simplement cr√©er tous les exemples de formation - dans le dossier des exemples, le script <i>build_all.bat le</i> fera ou g√©n√©rera des projets pour Microsoft Visual Studio - cela <i>cr√©era le</i> script <i>create_vs.bat</i> avec le nom d'un exemple sp√©cifique comme param√®tre. <br><br>  Comme vous pouvez le voir, l'application ICM sera un fichier .exe avec la partie h√¥te et un fichier .isa avec la partie GPU pr√©compil√©e correspondante. <br><br>  Divers exemples sont inclus dans le package ICM - du plus simple Hello, World, qui montre les principes de base du fonctionnement ICM, √† celui assez compliqu√© - la mise en ≈ìuvre de l'algorithme pour trouver le "d√©bit maximal - coupe minimale" du graphique (probl√®me de d√©bit minimal de d√©bit maximal) utilis√© dans la segmentation et l'assemblage d'images . <br><br>  Toutes les √©tudes de cas ICM sont bien document√©es dans le code et dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">description s√©par√©e</a> d√©j√† mentionn√©e.  Il est recommand√© de se plonger dans ICM pr√©cis√©ment dessus - en √©tudiant et en ex√©cutant s√©quentiellement des exemples, puis - en les modifiant pour r√©pondre √† vos besoins. <br><br>  Pour une compr√©hension g√©n√©rale de toutes les fonctionnalit√©s ICM existantes, il est fortement recommand√© d'√©tudier la ¬´sp√©cification¬ª - la description ICM <i>cmlangspec.html</i> dans le <i>dossier</i> <i>\ documents \ compiler \ html \ cmlangspec</i> . <br><br>  En particulier, il d√©crit l'API des fonctions ICM impl√©ment√©es dans le mat√©riel - acc√®s aux soi-disant √©chantillonneurs de texture (Sampler) - un m√©canisme pour filtrer les images de diff√©rents formats, ainsi que pour √©valuer le mouvement (Motion Estimation) entre les images vid√©o et certaines capacit√©s d'analyse vid√©o. <br><br><h2>  <font color="#0071c5">ICM - frappez pendant qu'il fait chaud!</font> </h2><br>  En ce qui concerne les performances des applications ICM, il convient de noter que les √©tudes de cas incluent la mesure du temps de leur travail, de sorte qu'en les ex√©cutant sur le syst√®me cible et en les comparant avec vos t√¢ches, vous pouvez √©valuer la pertinence d'utiliser ICM pour elles. <br><br>  Et les consid√©rations g√©n√©rales concernant les performances ICM sont assez simples: <br><br><ul><li>  Lors du d√©chargement des calculs sur un GPU, rappelez-vous la surcharge de transfert des donn√©es du processeur &lt;-&gt; GPU et de la synchronisation de ces p√©riph√©riques.  Par cons√©quent, un exemple tel que Hello, World n'est pas un bon candidat pour une impl√©mentation ICM.  Mais les algorithmes de la vision par ordinateur, de l'IA et de tout traitement non trivial des tableaux de donn√©es, en particulier avec un changement de l'ordre de ces donn√©es dans le processus ou √† la sortie, sont ce dont ICM a besoin. </li><li>  De plus, lors de la conception d'un code ICM, il est n√©cessaire de prendre en compte le p√©riph√©rique GPU interne, c'est-√†-dire qu'il est conseill√© de cr√©er un nombre suffisant (&gt; 1000) de threads GPU et de les charger tous avec du travail.  Dans ce cas, c'est une bonne id√©e de diviser les images √† traiter en petits blocs.  Mais la mani√®re sp√©cifique de partitionner, ainsi que le choix d'un algorithme de traitement sp√©cifique pour atteindre des performances maximales, n'est pas une t√¢che triviale.  Cependant, cela s'applique √† n'importe quelle fa√ßon de travailler avec n'importe quel GPU (et CPU). </li></ul><br>  Avez-vous du code OpenCL, mais ses performances ne vous plaisent pas?  Ou du code CUDA, mais vous voulez travailler sur un nombre beaucoup plus grand de plateformes?  Ensuite, il vaut la peine de jeter un ≈ìil √† ICM. <br><br>  ICM est un produit vivant et √©volutif.  Vous pouvez participer √† son utilisation et √† son d√©veloppement - les r√©f√©rentiels correspondants sur github attendent vos validations.  Toutes les informations n√©cessaires aux deux processus se trouvent dans cet article et les fichiers Lisez-moi sur github.  Et si quelque chose manque, il appara√Ætra apr√®s vos questions dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466521/">https://habr.com/ru/post/fr466521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466505/index.html">YIMP - Panneau de configuration pour Yii 2 sur Bootstrap 4</a></li>
<li><a href="../fr466509/index.html">Un regard √† l'int√©rieur: le processus de l'appareil au travail et l'adaptation dans Google</a></li>
<li><a href="../fr466515/index.html">Interview √Ä quoi un ing√©nieur doit-il s'attendre de travailler dans une startup europ√©enne, comment se d√©roulent les entretiens et est-il difficile de s'adapter</a></li>
<li><a href="../fr466517/index.html">Formation √† la localisation de l'Universit√© de Washington</a></li>
<li><a href="../fr466519/index.html">Analyse d√©taill√©e d'AWS Lambda</a></li>
<li><a href="../fr466525/index.html">Qu'est-ce qu'une disposition iPhone PSD et comment l'utiliser?</a></li>
<li><a href="../fr466527/index.html">Test de la fonctionnalit√© utilisateur du site Web avec les objets de page Capybara</a></li>
<li><a href="../fr466529/index.html">Types de compilation dans la JVM: exposer la session Black Magic</a></li>
<li><a href="../fr466535/index.html">Repenser deepClone</a></li>
<li><a href="../fr466537/index.html">Utilisation de modules JavaScript en production: situation actuelle. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>