<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗂️ ☯️ 🧚🏽 OutOfLine - modèle en mémoire pour les applications C ++ hautes performances 😻 🖖🏾 👉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En travaillant chez Headlands Technologies, j'ai eu la chance d'écrire plusieurs utilitaires pour simplifier la création de code C ++ hautes performan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OutOfLine - modèle en mémoire pour les applications C ++ hautes performances</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421475/"><p> En travaillant chez Headlands Technologies, j'ai eu la chance d'écrire plusieurs utilitaires pour simplifier la création de code C ++ hautes performances.  Cet article offre un aperçu général de l'un de ces utilitaires, <a href=""><code>OutOfLine</code></a> . </p><a name="habracut"></a><br><p>  Commençons par un exemple illustratif.  Supposons que vous disposiez d'un système qui gère un grand nombre d'objets du système de fichiers.  Il peut s'agir de fichiers ordinaires, appelés sockets ou tuyaux UNIX.  Pour une raison quelconque, vous ouvrez de nombreux descripteurs de fichiers au démarrage, puis travaillez intensivement avec eux, et à la fin, fermez les descripteurs et supprimez les liens vers les fichiers (environ. La voie signifie la fonction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dissociation</a> ). </p><br><p>  La version initiale (simplifiée) peut ressembler à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : path(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD() { close(fd); unlink(path.c_str()); } UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Et c'est une bonne conception, logiquement saine.  Il s'appuie sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RAII</a> pour libérer automatiquement le descripteur et supprimer le lien.  Vous pouvez créer un grand tableau de ces objets, travailler avec eux et lorsque le tableau cesse d'exister, les objets eux-mêmes effaceront tout ce qui était nécessaire dans le processus. </p><br><p>  Mais qu'en est-il de la performance?  Supposons que <code>fd</code> utilisé très souvent et <code>path</code> uniquement lors de la suppression d'un objet.  Maintenant, le tableau se compose d'objets de taille 40 octets, mais souvent, seuls 4 octets sont utilisés.  Cela signifie qu'il y aura plus de ratés dans le cache, car vous devez «ignorer» 90% des données. </p><br><p>  L'une des solutions courantes à ce problème est la transition d'un tableau de structures à une structure de tableau.  Cela fournira les performances souhaitées, mais au prix de l'abandon du RAII.  Existe-t-il une option qui combine les avantages des deux approches? </p><br><p>  Un compromis simple serait de remplacer <code>std::string</code> taille de 32 octets par <code>std::unique_ptr&lt;std::string&gt;</code> , dont la taille n'est que de 8 octets.  Cela réduira la taille de notre objet de 40 octets à 16 octets, ce qui est une grande réussite.  Mais cette solution perd toujours l'utilisation de plusieurs tableaux. </p><br><p>  <code>OutOfLine</code> est un outil qui permet sans abandonner RAII de déplacer complètement les champs (froids) rarement utilisés à l'extérieur de l'objet.  OutOfLine est utilisé comme classe de base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CRTP</a> , donc le premier argument du modèle doit être une classe enfant.  Le deuxième argument est le type de données (froides) rarement utilisées qui est associé à un objet (principal) fréquemment utilisé. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD(); UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Alors, à quoi ressemble cette classe? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColdData</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class"> {</span></span></code> </pre> <br><p>  L'idée de base de l'implémentation est d'utiliser un conteneur associatif global qui mappe les pointeurs sur les objets principaux et les pointeurs sur les objets qui contiennent des données froides. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;ColdData&gt;&gt; global_map_;</code> </pre> <br><p>  <code>OutOfLine</code> peut être utilisé avec tout type de données froides, dont une instance est créée et associée automatiquement à l'objet principal. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); }</code> </pre> <br><p>  La suppression de l'objet principal entraîne la suppression automatique de l'objet froid associé: </p><br><pre> <code class="cpp hljs"> ~OutOfLine() { global_map_.erase(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><p>  Lors du déplacement (constructeur de déplacement / opérateur d'affectation de déplacement) de l'objet principal, l'objet froid correspondant sera automatiquement associé au nouvel objet successeur principal.  Par conséquent, vous ne devez pas accéder aux données froides d'un objet déplacé. </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutOfLine&amp;&amp; other)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = other; } OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine&amp;&amp; other) { global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(global_map_[&amp;other]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Dans l'exemple d'implémentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ci</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dessus</a> , <code>OutOfLine</code> est rendu non copiable pour plus de simplicité.  Si nécessaire, les opérations de copie sont faciles à ajouter; il suffit de créer et de lier une copie d'un objet froid. </p><br><pre> <code class="cpp hljs">OutOfLine(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br><p>  Maintenant, pour que cela soit vraiment utile, ce serait bien d'avoir accès à des données froides.  Lorsqu'elle hérite d' <code>OutOfLine</code> classe reçoit les méthodes constantes et non constantes de <code>cold()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ColdData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; } <span class="hljs-function"><span class="hljs-function">ColdData </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; }</code> </pre> <br><p>  Ils renvoient le type de référence approprié aux données froides. </p><br><p>  C’est presque tout.  Cette option <code>UnlinkingFD</code> aura une taille de 4 octets, fournira un accès compatible avec le cache au champ <code>fd</code> et conservera les avantages de RAII.  Tous les travaux liés au cycle de vie d'un objet sont entièrement automatisés.  Lorsque l'objet principal fréquemment utilisé se déplace, les données froides rarement utilisées se déplacent avec lui.  Lorsque l'objet principal est supprimé, l'objet froid correspondant est également supprimé. </p><br><p>  Parfois, cependant, vos données sont compliquées pour compliquer votre vie - et vous êtes confronté à une situation dans laquelle des données de base doivent être créées en premier.  Par exemple, ils sont nécessaires pour construire des données froides.  Il est nécessaire de créer des objets dans l'ordre inverse par rapport à ce <code>OutOfLine</code> propose <code>OutOfLine</code> .  Dans de tels cas, une «sauvegarde» nous est utile pour contrôler l'ordre d'initialisation et de désinitialisation. </p><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoPhaseInit</span></span></span><span class="hljs-class"> {</span></span>}; OutOfLine(TwoPhaseInit){} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_cold_data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_.find(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;second = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release_cold_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>].reset(); }</code> </pre> <br><p>  Il s'agit d'un autre constructeur <code>OutOfLine</code> qui peut être utilisé dans les classes enfants; il accepte une balise de type <code>TwoPhaseInit</code> .  Si vous créez <code>OutOfLine</code> de cette manière, les données froides ne seront pas initialisées et l'objet restera à moitié construit.  Pour terminer la construction en deux phases, vous devez appeler la méthode <code>init_cold_data</code> (en lui passant les arguments nécessaires pour créer un objet de type <code>ColdData</code> ).  N'oubliez pas que vous ne pouvez pas appeler <code>.cold()</code> sur un objet dont les données froides n'ont pas encore été initialisées.  Par analogie, les données froides peuvent être supprimées avant la date prévue avant d'exécuter le destructeur <code>~OutOfLine</code> en appelant <code>release_cold_data</code> . </p><br><pre> <code class="cpp hljs">}; <span class="hljs-comment"><span class="hljs-comment">// end of class OutOfLine</span></span></code> </pre> <br><p>  Maintenant c'est tout.  Que nous apportent donc ces 29 lignes de code?  Ils constituent un autre compromis possible entre performances et facilité d'utilisation.  Dans les cas où vous avez un objet, dont certains membres sont utilisés beaucoup plus souvent que d'autres, <code>OutOfLine</code> peut servir de moyen facile à utiliser pour optimiser le cache, au prix d'un ralentissement significatif de l'accès aux données rarement utilisées. </p><br><p>  Nous avons pu appliquer cette technique à plusieurs endroits - assez souvent, il est nécessaire de compléter les données de travail intensivement utilisées par des métadonnées supplémentaires nécessaires à la fin du travail, dans des situations rares ou inattendues.  Qu'il s'agisse d'informations sur les utilisateurs qui ont établi la connexion, du terminal de négociation d'où provient l'ordre ou de la poignée de l'accélérateur matériel engagé dans le traitement des données d'échange - <code>OutOfLine</code> gardera le cache propre lorsque vous êtes dans la partie critique des calculs (chemin critique). </p><br><p>  J'ai préparé un <a href="">test</a> pour que vous puissiez voir et évaluer la différence. </p><br><table><thead><tr><th>  Le script </th><th>  Temps (ns) </th></tr></thead><tbody><tr><td>  Données froides dans l'objet principal (version initiale) </td><td>  34684547 </td></tr><tr><td>  Données froides complètement supprimées (meilleur scénario) </td><td>  2938327 </td></tr><tr><td>  Utilisation d'OutOfLine </td><td>  2947645 </td></tr></tbody></table><br><p>  J'ai obtenu une accélération d'environ <code>OutOfLine</code> lors de l'utilisation d' <code>OutOfLine</code> .  De toute évidence, ce test est conçu pour démontrer le potentiel d' <code>OutOfLine</code> , mais il montre également dans quelle mesure l'optimisation du cache peut avoir un impact significatif sur les performances, tout comme <code>OutOfLine</code> permet d'obtenir cette optimisation.  Garder le cache exempt de données rarement utilisées peut apporter des améliorations complexes, mesurables et complètes au reste du code.  Comme toujours avec l'optimisation, faites confiance aux mesures plus qu'aux hypothèses, néanmoins j'espère que <code>OutOfLine</code> se révélera être un outil utile dans votre collection d'utilitaires. </p><br><h2 id="primechanie-ot-perevodchika">  <em>Note du traducteur</em> </h2><br><p>  <em>Le code fourni dans l'article sert à démontrer l'idée et n'est pas représentatif du code de production.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421475/">https://habr.com/ru/post/fr421475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421465/index.html">DevOps mobiles en pratique</a></li>
<li><a href="../fr421467/index.html">Développement d'un robot de collecte de balles de golf</a></li>
<li><a href="../fr421469/index.html">Telegram a accepté de transférer vers les services spéciaux [mais pas le russe] les adresses IP et les numéros de certains utilisateurs</a></li>
<li><a href="../fr421471/index.html">Ad Exchange Server - contrairement à d'autres</a></li>
<li><a href="../fr421473/index.html">Que sont les Coroutines à Kotlin?</a></li>
<li><a href="../fr421477/index.html">Ce qui est écrit dans le fichier .ssh / known_hosts</a></li>
<li><a href="../fr421481/index.html">Microphones, captures d'écran et vidéo locale: comment le Voximplant Web SDK contrôle les médias dans un navigateur</a></li>
<li><a href="../fr421485/index.html">Avis important pour les utilisateurs de Gitlab Pages</a></li>
<li><a href="../fr421487/index.html">Comment renforcer le support technique - 6 façons secrètes</a></li>
<li><a href="../fr421489/index.html">Grogner mais donner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>