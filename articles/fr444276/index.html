<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öôÔ∏è üë©üèæ‚Äçüè≠ üë≤üèª Introduction √† l'architecture React Fibre üîô ‚ùî üëπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! J'attire votre attention sur une traduction de l'article "React Fibre Architecture" d' Andrew Clark . 
 Entr√©e 


 React Fibre est une ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction √† l'architecture React Fibre</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444276/"><p> Bonjour, Habr!  J'attire votre attention sur une traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"React Fibre Architecture"</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrew Clark</a> . </p><br><h2 id="vstuplenie">  Entr√©e </h2><br><p>  React Fibre est une impl√©mentation progressive de l'algorithme cl√© React.  Il s'agit de l'aboutissement d'une √©tude de deux ans men√©e par l'√©quipe de d√©veloppement de React. </p><br><p>  L'objectif de Fibre est d'augmenter la productivit√© lors du d√©veloppement de t√¢ches telles que l'animation, l'organisation d'√©l√©ments sur une page et le d√©placement d'√©l√©ments.  Sa principale caract√©ristique est le rendu incr√©mentiel: la possibilit√© de diviser le travail de rendu en unit√©s et de les r√©partir entre plusieurs images. </p><br><p>  Les autres fonctionnalit√©s cl√©s incluent la possibilit√© de suspendre, d'annuler ou de r√©utiliser les mises √† jour entrantes de l'arborescence DOM, la possibilit√© de hi√©rarchiser diff√©rents types de mises √† jour, ainsi que la coordination des primitives. </p><a name="habracut"></a><br><p>  <em>Avant de lire cet article, nous vous recommandons de vous familiariser avec les principes de base de React:</em> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©action des composants, des √©l√©ments et des instances</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©conciliation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">React - Concepts th√©oriques de base</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Principes de conception</a> </li></ul><br><h2 id="obzor">  Revue </h2><br><h4 id="chto-takoe-sverka-reconciliation">  Qu'est-ce que la r√©conciliation? </h4><br><p>  <strong>La r√©conciliation</strong> est un algorithme React utilis√© pour distinguer un arbre d'√©l√©ments d'un autre pour d√©terminer les pi√®ces qui devront √™tre remplac√©es. </p><br><p>  <strong>Une mise √† jour</strong> est un changement dans les donn√©es utilis√©es pour rendre une application React.  Ceci est g√©n√©ralement le r√©sultat de l'appel de la m√©thode setState;  Le r√©sultat final du rendu du composant. </p><br><p>  L'id√©e cl√© de l'API React est de penser aux mises √† jour comme si elles pouvaient conduire √† un rendu complet de l'application.  Cela permet au d√©veloppeur d'agir de mani√®re d√©clarative, sans se soucier de la rationalit√© de la transition de l'application d'un √©tat √† un autre (de A √† B, B √† C, C √† A, etc.). </p><br><p>  En g√©n√©ral, le rendu de l'application enti√®re pour chaque modification ne fonctionne que dans les applications les plus traditionnelles.  Dans le monde r√©el, cela affecte n√©gativement les performances.  L'acte comprend des optimisations qui cr√©ent une vue de rendu compl√®te sans affecter une √©norme part des performances.  La plupart de ces optimisations impliquent un processus appel√© r√©conciliation. </p><br><p>  La r√©conciliation est un algorithme derri√®re ce que nous avons l'habitude d'appeler ¬´DOM virtuel¬ª.  La d√©finition ressemble √† ceci: lorsque vous effectuez le rendu d'une application React, l'arborescence des √©l√©ments qui d√©crit l'application est g√©n√©r√©e dans la m√©moire r√©serv√©e.  Cet arbre est ensuite inclus dans l'environnement de rendu - en utilisant l'exemple d'une application de navigateur, il est traduit en un ensemble d'op√©rations DOM.  Lorsque l'√©tat de l'application est mis √† jour (g√©n√©ralement en appelant setState), une nouvelle arborescence est g√©n√©r√©e.  La nouvelle arborescence est compar√©e √† la pr√©c√©dente pour calculer et activer exactement les op√©rations n√©cessaires pour redessiner l'application mise √† jour. </p><br><p>  Bien que Fibre soit une impl√©mentation proche du r√©conciliateur, l'algorithme de haut niveau expliqu√© dans la documentation React sera √† peu pr√®s le m√™me. </p><br><h4 id="klyuchevye-ponyatiya">  Concepts cl√©s: </h4><br><ul><li>  Diff√©rents types de composants sugg√®rent la g√©n√©ration d'arbres sensiblement diff√©rents.  React n'essaiera pas de les comparer, mais remplacera simplement l'ancien arbre compl√®tement. </li><li>  Les listes sont distingu√©es √† l'aide de cl√©s.  Les cl√©s doivent √™tre ¬´persistantes, pr√©visibles et uniques¬ª. </li></ul><br><h2 id="sverka-protiv-renderinga">  R√©conciliation vs rendu </h2><br><p>  L'arbre DOM est l'un des environnements que React peut dessiner, le reste peut √™tre attribu√© √† des vues natives iOS et Android √† l'aide de React Native (c'est pourquoi Virtual Dom est un petit nom inappropri√©). </p><br><p>  La raison pour laquelle React prend en charge tant d'objectifs est que React est con√ßu de mani√®re √† ce que la r√©conciliation et le rendu soient des phases distinctes.  Le r√©conciliateur, qui fonctionne, calcule quelles parties de l'arborescence ont chang√©, le moteur de rendu utilise ensuite ces informations pour mettre √† jour l'arborescence pr√©c√©demment rendue. </p><br><p>  Cette s√©paration signifie que React DOM et React Native peuvent utiliser leurs propres m√©canismes de rendu lorsqu'ils utilisent le m√™me outil de mise en cache, qui se trouve dans React Core. </p><br><p>  La fibre est une impl√©mentation repens√©e de l'algorithme de r√©conciliation.  Il a une relation indirecte avec le rendu, tandis que les m√©canismes de rendu (rendus) peuvent √™tre modifi√©s pour prendre en charge tous les avantages de la nouvelle architecture. </p><br><p>  <strong>La planification</strong> est un processus qui d√©termine quand les travaux doivent √™tre termin√©s. </p><br><p>  <strong>Travail</strong> - tous les calculs qui doivent √™tre effectu√©s.  Le travail est g√©n√©ralement le r√©sultat d'une mise √† jour (par exemple, l'appel de setState). </p><br><p>  Les principes de l'architecture React sont si bons qu'ils ne peuvent √™tre d√©crits qu'avec cette citation: </p><br><blockquote>  Dans l'impl√©mentation actuelle de React, il parcourt r√©cursivement l'arborescence et appelle les fonctions de rendu sur la totalit√© de l'arborescence mise √† jour en un seul tick (16 ms).  Cependant, √† l'avenir, il pourra annuler certaines mises √† jour pour √©viter les sauts de trame. <br>  Il s'agit d'un sujet fr√©quemment discut√© concernant React Design.  Certaines biblioth√®ques populaires impl√©mentent une approche ¬´push¬ª, o√π les calculs sont effectu√©s lorsque de nouvelles donn√©es sont disponibles.  Cependant, React adh√®re √† l'approche pull, o√π les calculs peuvent √™tre annul√©s si n√©cessaire. <br>  React n'est pas une biblioth√®que de traitement de donn√©es g√©n√©ralis√©es.  Il s'agit d'une biblioth√®que pour cr√©er des interfaces utilisateur.  Nous pensons qu'il devrait avoir une position unique dans l'application afin de d√©terminer quels calculs sont appropri√©s et lesquels ne le sont pas pour le moment. <br>  Si quelque chose se d√©roule dans les coulisses, nous pouvons annuler toute la logique qui lui est associ√©e.  Si les donn√©es arrivent plus rapidement que le taux de rendu d'image, nous pouvons combiner les mises √† jour.  Nous pouvons augmenter la priorit√© du travail r√©sultant de l'interaction de l'utilisateur (comme l'apparition d'une animation lorsqu'un bouton est enfonc√©) par rapport √† un travail moins important en arri√®re-plan (rendre le nouveau contenu charg√© √† partir du serveur) pour emp√™cher les t√©l√©chargements de trames. </blockquote><br><h4 id="klyuchevye-ponyatiya-1">  Concepts cl√©s: </h4><br><ul><li>  Dans les interfaces utilisateur, il n'est pas important que chaque mise √† jour soit appliqu√©e imm√©diatement;  en fait, ce comportement sera superflu, il contribuera √† la chute des frames et √† la d√©t√©rioration de l'UX. </li><li>  Diff√©rents types de mises √† jour ont des priorit√©s diff√©rentes - les mises √† jour d'animation devraient se terminer plus rapidement que, par exemple, la mise √† jour du stockage de donn√©es. </li><li>  Une approche push n√©cessite que l'application (vous, le d√©veloppeur) d√©cide comment planifier le travail.  Une approche bas√©e sur l'extraction permet au cadre de prendre des d√©cisions pour vous. </li></ul><br><p>  R√©agir pour le moment n'a pas l'avantage de planifier dans une large mesure;  les r√©sultats de mise √† jour de la sous-arborescence enti√®re seront dessin√©s imm√©diatement.  La s√©lection judicieuse des √©l√©ments de l'algorithme du noyau React pour appliquer la planification est l'id√©e cl√© de Fibre. </p><br><h2 id="chto-zhe-takoe-fiber">  Qu'est-ce que la fibre? </h2><br><p>  Nous aborderons le c≈ìur de l'architecture React Fibre.  La fibre est une abstraction de niveau inf√©rieur sur l'application √† laquelle les d√©veloppeurs ont l'habitude de penser.  Si vous consid√©rez vos tentatives pour le comprendre comme d√©sesp√©r√©es, ne vous d√©couragez pas (vous n'√™tes pas seul).  Continuez √† chercher et cela portera enfin ses fruits. </p><br><p>  Et donc! </p><br><p>  Nous avons atteint cet objectif principal de l'architecture Fibre - laisser React profiter de la planification.  Plus pr√©cis√©ment, nous devons √™tre en mesure de: </p><br><ul><li>  arr√™ter le travail et y revenir plus tard. </li><li>  prioriser diff√©rents types de travaux. </li><li>  r√©utiliser le travail effectu√© pr√©c√©demment. </li><li>  annuler le travail s'il n'est plus n√©cessaire. </li></ul><br><p>  Pour faire tout cela, nous devons d'abord diviser le travail en unit√©s.  Dans un sens, c'est de la fibre.  La fibre repr√©sente une unit√© de travail. </p><br><p>  Pour aller plus loin, revenons au concept de base de React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"composants as function data"</a> , souvent exprim√© comme: </p><br><pre><code class="javascript hljs">v = f(d)</code> </pre> <br><p>  Il s'ensuit que le rendu d'une application React revient √† appeler une fonction dont le corps contient des appels √† d'autres fonctions, etc.  Cette analogie est utile lorsque l'on pense aux fibres. </p><br><p>  La fa√ßon dont les ordinateurs v√©rifient essentiellement l'ordre d'ex√©cution d'un programme est appel√©e une pile d'appels.  Une fois la fonction termin√©e, le nouveau conteneur de pile est ajout√© √† la pile.  Ce conteneur de pile repr√©sente le travail effectu√© par une fonction. </p><br><p>  Lorsque vous travaillez avec des interfaces utilisateur, trop de travail est effectu√© imm√©diatement et c'est un probl√®me, cela peut entra√Æner des sauts dans l'animation et semblera intermittent.  De plus, une partie de ce travail peut ne pas √™tre n√©cessaire s'il est remplac√© par la mise √† jour la plus r√©cente.  √Ä ce stade, la comparaison entre l'interface utilisateur et la fonction diverge, car les composants ont une responsabilit√© plus sp√©cifique que les fonctions en g√©n√©ral. <br>  Les derniers navigateurs et React Native impl√©mentent des API qui aident √† r√©soudre ce probl√®me: <br>  requestIdleCallback distribue les t√¢ches de fa√ßon √† ce que les fonctions de faible priorit√© soient appel√©es dans une p√©riode simple, et requestAnimationFrame distribue les t√¢ches de sorte que les fonctions de haute priorit√© soient appel√©es dans la trame suivante.  Le probl√®me est que pour utiliser ces API, vous devez diviser le travail de rendu en unit√©s incr√©mentielles.  Si vous ne comptez que sur la pile d'appels, le travail se poursuivra jusqu'√† ce que la pile soit vide. </p><br><p>  Ne serait-il pas int√©ressant de pouvoir personnaliser le comportement de la pile d'appels pour optimiser l'affichage de certaines parties de l'interface utilisateur?  Serait-ce bien si nous pouvions casser la pile d'appels pour manipuler les conteneurs manuellement? </p><br><p>  C'est la vocation de React Fibre.  La fibre est une nouvelle impl√©mentation de pile adapt√©e aux composants React.  Vous pouvez consid√©rer une fibre unique comme un conteneur de pile virtuelle. </p><br><p>  L'avantage de cette impl√©mentation de la pile est que vous pouvez enregistrer la pile de conteneurs en m√©moire et l'ex√©cuter ensuite (et o√π) vous le souhaitez.  Il s'agit d'une d√©finition cruciale pour atteindre vos objectifs de planification. </p><br><p>  En plus de la planification, des actions manuelles avec la pile r√©v√®lent le potentiel de concepts tels que la coh√©rence (simultan√©it√©) et la gestion des erreurs (limites d'erreur). </p><br><p>  Dans la section suivante, nous examinons la structure des fibres. </p><br><h2 id="struktura-volokna">  Structure en fibre </h2><br><p>  Plus pr√©cis√©ment, une ¬´fibre¬ª est un objet JavaScript qui contient des informations sur un composant, son entr√©e et sa sortie. </p><br><p>  La fibre est coh√©rente avec le conteneur de pile, mais elle est √©galement coh√©rente avec l'essence du composant. </p><br><p>  Voici quelques propri√©t√©s importantes de la ¬´fibre¬ª (Cette liste n'est pas exhaustive): </p><br><p>  <strong>Type et cl√©</strong> </p><br><p>  Le type et la cl√© servent la fibre ainsi que les √©l√©ments React.  En fait, lorsqu'une fibre est cr√©√©e, ces deux champs y sont copi√©s directement. </p><br><p>  Le type de fibre d√©crit le composant auquel elle correspond.  Pour la composition des composants, le type est une fonction ou une classe de composants.  Pour les composants de service (div, span), le type est une cha√Æne. </p><br><p>  Conceptuellement, un type est une fonction dont l'ex√©cution est suivie par un conteneur de pile. </p><br><p>  Avec le type, la cl√© est utilis√©e lors de la comparaison des arbres pour d√©terminer si la fibre peut √™tre r√©utilis√©e. </p><br><p>  <strong>Enfant et fr√®re</strong> <strong><br></strong> <br>  Ces champs pointent vers d'autres fibres, d√©crivant la structure r√©cursive des fibres. </p><br><p>  L'enfant fibre correspond √† la valeur qui a √©t√© renvoy√©e suite √† l'appel de la m√©thode de rendu sur le composant.  Dans l'exemple ci-dessous: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  Parent Fiber Child correspond √† Child. </p><br><p>  Le champ relatif (ou voisin) est utilis√© si le rendu renvoie plusieurs enfants (une nouvelle fonctionnalit√© dans Fibre): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child1</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child2</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">] }</span></span></code> </pre> <br><p>  Les fibres enfants sont une liste li√©e individuellement √† la t√™te de laquelle se trouve le premier enfant.  Ainsi, dans cet exemple, l'enfant Parent est Child1 et les parents de Child1 sont Child2. </p><br><p>  Pour revenir √† notre analogie avec les fonctions, vous pouvez penser √† une fibre enfant comme une fonction appel√©e √† la fin (fonction appel√©e queue). </p><br><p>  Exemple Wikip√©dia: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ a(data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b(data); }</code> </pre> <br><p>  Dans cet exemple, la fonction appel√©e queue est b. </p><br><p>  <strong>Valeur de retour (retour)</strong> </p><br><p>  La fibre de retour est la fibre vers laquelle le programme doit retourner apr√®s avoir trait√© la fibre actuelle.  Cela revient √† renvoyer l'adresse du conteneur de pile. <br>  Elle peut √©galement √™tre consid√©r√©e comme une fibre parente. </p><br><p>  Si une fibre a plusieurs fibres enfants, le retour de chaque fibre enfant renvoie la fibre parent.  Dans l'exemple ci-dessus, la fibre de retour de Child1 et Child2 est Parent. </p><br><p>  <strong>Propri√©t√©s actuelles et mises en cache (en attenteProps et memoredProps)</strong> </p><br><p>  Conceptuellement, les propri√©t√©s sont des arguments de fonction.  Les propri√©t√©s de fibre actuelles sont un ensemble de ces propri√©t√©s au d√©but de l'ex√©cution, celles mises en cache sont un ensemble √† la fin de l'ex√©cution. </p><br><p>  Lorsque les propri√©t√©s d'attente d'entr√©e sont mises en cache, cela signifie que la sortie de fibre pr√©c√©dente peut √™tre r√©utilis√©e sans aucun calcul. </p><br><p>  <strong>Priorit√© des travaux en cours (en attenteWorkPriority)</strong> </p><br><p>  La quantit√© de travail d√©terminant la priorit√© est affich√©e par la fibre.  Le module de niveau de priorit√© dans React <a href="">ReactPrioritylevel</a> comprend diff√©rents niveaux de priorit√© et ce qu'ils repr√©sentent. </p><br><p>  En commen√ßant par une exception de type NoWork qui est 0, un nombre plus √©lev√© d√©finit la priorit√© la plus basse.  Par exemple, vous pouvez utiliser la fonction suivante pour v√©rifier si la priorit√© de fibre est sup√©rieure au niveau sp√©cifi√©: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchesPriority</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fiber, priority</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fiber.pendingWorkPriority !== <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fiber.pendingWorkPriority &lt;= priority }</code> </pre> <br><p>  <em>Cette fonction est uniquement √† des fins d'illustration;</em>  <em>il ne fait pas partie de la base de donn√©es React Fibre.</em> </p><br><p>  L'ordonnanceur utilise le champ prioritaire pour trouver l'unit√© de travail suivante qui peut √™tre effectu√©e.  Nous discuterons de cet algorithme dans la section suivante. </p><br><p>  <strong>Alternative (ou paire)</strong> </p><br><p>  Mise √† jour (flush) de la fibre - cela signifie afficher sa sortie sur l'√©cran. </p><br><p>  Fibre en d√©veloppement (travaux en cours) - fibre qui n'a pas encore √©t√© construite;  en d'autres termes, c'est un conteneur de pile qui n'a pas encore √©t√© retourn√©. </p><br><p>  A tout moment, l'essence du composant n'a pas plus de deux √©tats pour la fibre qui correspond √†: fibre dans son √©tat actuel, fibre mise √† jour ou fibre en d√©veloppement. </p><br><p>  La fibre actuelle est suivie par la fibre en cours de d√©veloppement, puis, √† son tour, la fibre est mise √† jour. </p><br><p>  L'√©tat de fibre suivant est cr√©√© paresseusement √† l'aide de la fonction cloneFiber.  Presque toujours lors de la cr√©ation d'un nouvel objet, cloneFiber tentera de r√©utiliser une alternative (paire) de fibres si elle existe, tout en minimisant le co√ªt des ressources. </p><br><p>  Vous devriez consid√©rer le champ de vapeur (ou son alternative) comme un d√©tail d'impl√©mentation, mais il appara√Æt si souvent dans la documentation qu'il √©tait tout simplement impossible de ne pas le mentionner. </p><br><p>  La conclusion est un √©l√©ment de service (ou un ensemble d'√©l√©ments de service);  n≈ìuds foliaires R√©agissez aux applications.  Ils sont sp√©cifiques √† chaque environnement d'affichage (par exemple, dans un navigateur, il s'agit de 'div', 'span', etc.).  Dans JSX, ils sont d√©sign√©s comme des noms de balises minuscules. </p><br><p>  Conclusion: je recommande d'essayer les fonctionnalit√©s de la nouvelle architecture React v16.0 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444276/">https://habr.com/ru/post/fr444276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444264/index.html">Comment devenir un committer et en avez-vous vraiment besoin?</a></li>
<li><a href="../fr444268/index.html">Semaine de s√©curit√© 12: attaques au clavier</a></li>
<li><a href="../fr444270/index.html">Webinaire du Groupe-IB ¬´L'approche du Groupe-IB en mati√®re de cyber√©ducation: aper√ßu des programmes actuels et des cas pratiques¬ª</a></li>
<li><a href="../fr444272/index.html">PyDERASN: comme j'ai √©crit la biblioth√®que ASN.1 avec des slots et des blobs</a></li>
<li><a href="../fr444274/index.html">Une r√©ponse d√©taill√©e au commentaire, ainsi qu'un peu sur la vie des prestataires en F√©d√©ration de Russie</a></li>
<li><a href="../fr444278/index.html">Comment inciter des dizaines de milliers de personnes √† lire votre article en anglais pour Habr: 3 conseils simples</a></li>
<li><a href="../fr444282/index.html">7 extensions Chrome pour apprendre l'anglais</a></li>
<li><a href="../fr444284/index.html">compositeur et compl√©tion en ligne de commande</a></li>
<li><a href="../fr444286/index.html">Analyse des cam√©ras PTZ: ce qu'il y a √† l'int√©rieur et comment cela fonctionne</a></li>
<li><a href="../fr444288/index.html">Nouvelle application mobile LampTest.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>