<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚙️ 👩🏾‍🏭 👲🏻 Introduction à l'architecture React Fibre 🔙 ❔ 👹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! J'attire votre attention sur une traduction de l'article "React Fibre Architecture" d' Andrew Clark . 
 Entrée 


 React Fibre est une ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à l'architecture React Fibre</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444276/"><p> Bonjour, Habr!  J'attire votre attention sur une traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"React Fibre Architecture"</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrew Clark</a> . </p><br><h2 id="vstuplenie">  Entrée </h2><br><p>  React Fibre est une implémentation progressive de l'algorithme clé React.  Il s'agit de l'aboutissement d'une étude de deux ans menée par l'équipe de développement de React. </p><br><p>  L'objectif de Fibre est d'augmenter la productivité lors du développement de tâches telles que l'animation, l'organisation d'éléments sur une page et le déplacement d'éléments.  Sa principale caractéristique est le rendu incrémentiel: la possibilité de diviser le travail de rendu en unités et de les répartir entre plusieurs images. </p><br><p>  Les autres fonctionnalités clés incluent la possibilité de suspendre, d'annuler ou de réutiliser les mises à jour entrantes de l'arborescence DOM, la possibilité de hiérarchiser différents types de mises à jour, ainsi que la coordination des primitives. </p><a name="habracut"></a><br><p>  <em>Avant de lire cet article, nous vous recommandons de vous familiariser avec les principes de base de React:</em> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Réaction des composants, des éléments et des instances</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Réconciliation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">React - Concepts théoriques de base</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Principes de conception</a> </li></ul><br><h2 id="obzor">  Revue </h2><br><h4 id="chto-takoe-sverka-reconciliation">  Qu'est-ce que la réconciliation? </h4><br><p>  <strong>La réconciliation</strong> est un algorithme React utilisé pour distinguer un arbre d'éléments d'un autre pour déterminer les pièces qui devront être remplacées. </p><br><p>  <strong>Une mise à jour</strong> est un changement dans les données utilisées pour rendre une application React.  Ceci est généralement le résultat de l'appel de la méthode setState;  Le résultat final du rendu du composant. </p><br><p>  L'idée clé de l'API React est de penser aux mises à jour comme si elles pouvaient conduire à un rendu complet de l'application.  Cela permet au développeur d'agir de manière déclarative, sans se soucier de la rationalité de la transition de l'application d'un état à un autre (de A à B, B à C, C à A, etc.). </p><br><p>  En général, le rendu de l'application entière pour chaque modification ne fonctionne que dans les applications les plus traditionnelles.  Dans le monde réel, cela affecte négativement les performances.  L'acte comprend des optimisations qui créent une vue de rendu complète sans affecter une énorme part des performances.  La plupart de ces optimisations impliquent un processus appelé réconciliation. </p><br><p>  La réconciliation est un algorithme derrière ce que nous avons l'habitude d'appeler «DOM virtuel».  La définition ressemble à ceci: lorsque vous effectuez le rendu d'une application React, l'arborescence des éléments qui décrit l'application est générée dans la mémoire réservée.  Cet arbre est ensuite inclus dans l'environnement de rendu - en utilisant l'exemple d'une application de navigateur, il est traduit en un ensemble d'opérations DOM.  Lorsque l'état de l'application est mis à jour (généralement en appelant setState), une nouvelle arborescence est générée.  La nouvelle arborescence est comparée à la précédente pour calculer et activer exactement les opérations nécessaires pour redessiner l'application mise à jour. </p><br><p>  Bien que Fibre soit une implémentation proche du réconciliateur, l'algorithme de haut niveau expliqué dans la documentation React sera à peu près le même. </p><br><h4 id="klyuchevye-ponyatiya">  Concepts clés: </h4><br><ul><li>  Différents types de composants suggèrent la génération d'arbres sensiblement différents.  React n'essaiera pas de les comparer, mais remplacera simplement l'ancien arbre complètement. </li><li>  Les listes sont distinguées à l'aide de clés.  Les clés doivent être «persistantes, prévisibles et uniques». </li></ul><br><h2 id="sverka-protiv-renderinga">  Réconciliation vs rendu </h2><br><p>  L'arbre DOM est l'un des environnements que React peut dessiner, le reste peut être attribué à des vues natives iOS et Android à l'aide de React Native (c'est pourquoi Virtual Dom est un petit nom inapproprié). </p><br><p>  La raison pour laquelle React prend en charge tant d'objectifs est que React est conçu de manière à ce que la réconciliation et le rendu soient des phases distinctes.  Le réconciliateur, qui fonctionne, calcule quelles parties de l'arborescence ont changé, le moteur de rendu utilise ensuite ces informations pour mettre à jour l'arborescence précédemment rendue. </p><br><p>  Cette séparation signifie que React DOM et React Native peuvent utiliser leurs propres mécanismes de rendu lorsqu'ils utilisent le même outil de mise en cache, qui se trouve dans React Core. </p><br><p>  La fibre est une implémentation repensée de l'algorithme de réconciliation.  Il a une relation indirecte avec le rendu, tandis que les mécanismes de rendu (rendus) peuvent être modifiés pour prendre en charge tous les avantages de la nouvelle architecture. </p><br><p>  <strong>La planification</strong> est un processus qui détermine quand les travaux doivent être terminés. </p><br><p>  <strong>Travail</strong> - tous les calculs qui doivent être effectués.  Le travail est généralement le résultat d'une mise à jour (par exemple, l'appel de setState). </p><br><p>  Les principes de l'architecture React sont si bons qu'ils ne peuvent être décrits qu'avec cette citation: </p><br><blockquote>  Dans l'implémentation actuelle de React, il parcourt récursivement l'arborescence et appelle les fonctions de rendu sur la totalité de l'arborescence mise à jour en un seul tick (16 ms).  Cependant, à l'avenir, il pourra annuler certaines mises à jour pour éviter les sauts de trame. <br>  Il s'agit d'un sujet fréquemment discuté concernant React Design.  Certaines bibliothèques populaires implémentent une approche «push», où les calculs sont effectués lorsque de nouvelles données sont disponibles.  Cependant, React adhère à l'approche pull, où les calculs peuvent être annulés si nécessaire. <br>  React n'est pas une bibliothèque de traitement de données généralisées.  Il s'agit d'une bibliothèque pour créer des interfaces utilisateur.  Nous pensons qu'il devrait avoir une position unique dans l'application afin de déterminer quels calculs sont appropriés et lesquels ne le sont pas pour le moment. <br>  Si quelque chose se déroule dans les coulisses, nous pouvons annuler toute la logique qui lui est associée.  Si les données arrivent plus rapidement que le taux de rendu d'image, nous pouvons combiner les mises à jour.  Nous pouvons augmenter la priorité du travail résultant de l'interaction de l'utilisateur (comme l'apparition d'une animation lorsqu'un bouton est enfoncé) par rapport à un travail moins important en arrière-plan (rendre le nouveau contenu chargé à partir du serveur) pour empêcher les téléchargements de trames. </blockquote><br><h4 id="klyuchevye-ponyatiya-1">  Concepts clés: </h4><br><ul><li>  Dans les interfaces utilisateur, il n'est pas important que chaque mise à jour soit appliquée immédiatement;  en fait, ce comportement sera superflu, il contribuera à la chute des frames et à la détérioration de l'UX. </li><li>  Différents types de mises à jour ont des priorités différentes - les mises à jour d'animation devraient se terminer plus rapidement que, par exemple, la mise à jour du stockage de données. </li><li>  Une approche push nécessite que l'application (vous, le développeur) décide comment planifier le travail.  Une approche basée sur l'extraction permet au cadre de prendre des décisions pour vous. </li></ul><br><p>  Réagir pour le moment n'a pas l'avantage de planifier dans une large mesure;  les résultats de mise à jour de la sous-arborescence entière seront dessinés immédiatement.  La sélection judicieuse des éléments de l'algorithme du noyau React pour appliquer la planification est l'idée clé de Fibre. </p><br><h2 id="chto-zhe-takoe-fiber">  Qu'est-ce que la fibre? </h2><br><p>  Nous aborderons le cœur de l'architecture React Fibre.  La fibre est une abstraction de niveau inférieur sur l'application à laquelle les développeurs ont l'habitude de penser.  Si vous considérez vos tentatives pour le comprendre comme désespérées, ne vous découragez pas (vous n'êtes pas seul).  Continuez à chercher et cela portera enfin ses fruits. </p><br><p>  Et donc! </p><br><p>  Nous avons atteint cet objectif principal de l'architecture Fibre - laisser React profiter de la planification.  Plus précisément, nous devons être en mesure de: </p><br><ul><li>  arrêter le travail et y revenir plus tard. </li><li>  prioriser différents types de travaux. </li><li>  réutiliser le travail effectué précédemment. </li><li>  annuler le travail s'il n'est plus nécessaire. </li></ul><br><p>  Pour faire tout cela, nous devons d'abord diviser le travail en unités.  Dans un sens, c'est de la fibre.  La fibre représente une unité de travail. </p><br><p>  Pour aller plus loin, revenons au concept de base de React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"composants as function data"</a> , souvent exprimé comme: </p><br><pre><code class="javascript hljs">v = f(d)</code> </pre> <br><p>  Il s'ensuit que le rendu d'une application React revient à appeler une fonction dont le corps contient des appels à d'autres fonctions, etc.  Cette analogie est utile lorsque l'on pense aux fibres. </p><br><p>  La façon dont les ordinateurs vérifient essentiellement l'ordre d'exécution d'un programme est appelée une pile d'appels.  Une fois la fonction terminée, le nouveau conteneur de pile est ajouté à la pile.  Ce conteneur de pile représente le travail effectué par une fonction. </p><br><p>  Lorsque vous travaillez avec des interfaces utilisateur, trop de travail est effectué immédiatement et c'est un problème, cela peut entraîner des sauts dans l'animation et semblera intermittent.  De plus, une partie de ce travail peut ne pas être nécessaire s'il est remplacé par la mise à jour la plus récente.  À ce stade, la comparaison entre l'interface utilisateur et la fonction diverge, car les composants ont une responsabilité plus spécifique que les fonctions en général. <br>  Les derniers navigateurs et React Native implémentent des API qui aident à résoudre ce problème: <br>  requestIdleCallback distribue les tâches de façon à ce que les fonctions de faible priorité soient appelées dans une période simple, et requestAnimationFrame distribue les tâches de sorte que les fonctions de haute priorité soient appelées dans la trame suivante.  Le problème est que pour utiliser ces API, vous devez diviser le travail de rendu en unités incrémentielles.  Si vous ne comptez que sur la pile d'appels, le travail se poursuivra jusqu'à ce que la pile soit vide. </p><br><p>  Ne serait-il pas intéressant de pouvoir personnaliser le comportement de la pile d'appels pour optimiser l'affichage de certaines parties de l'interface utilisateur?  Serait-ce bien si nous pouvions casser la pile d'appels pour manipuler les conteneurs manuellement? </p><br><p>  C'est la vocation de React Fibre.  La fibre est une nouvelle implémentation de pile adaptée aux composants React.  Vous pouvez considérer une fibre unique comme un conteneur de pile virtuelle. </p><br><p>  L'avantage de cette implémentation de la pile est que vous pouvez enregistrer la pile de conteneurs en mémoire et l'exécuter ensuite (et où) vous le souhaitez.  Il s'agit d'une définition cruciale pour atteindre vos objectifs de planification. </p><br><p>  En plus de la planification, des actions manuelles avec la pile révèlent le potentiel de concepts tels que la cohérence (simultanéité) et la gestion des erreurs (limites d'erreur). </p><br><p>  Dans la section suivante, nous examinons la structure des fibres. </p><br><h2 id="struktura-volokna">  Structure en fibre </h2><br><p>  Plus précisément, une «fibre» est un objet JavaScript qui contient des informations sur un composant, son entrée et sa sortie. </p><br><p>  La fibre est cohérente avec le conteneur de pile, mais elle est également cohérente avec l'essence du composant. </p><br><p>  Voici quelques propriétés importantes de la «fibre» (Cette liste n'est pas exhaustive): </p><br><p>  <strong>Type et clé</strong> </p><br><p>  Le type et la clé servent la fibre ainsi que les éléments React.  En fait, lorsqu'une fibre est créée, ces deux champs y sont copiés directement. </p><br><p>  Le type de fibre décrit le composant auquel elle correspond.  Pour la composition des composants, le type est une fonction ou une classe de composants.  Pour les composants de service (div, span), le type est une chaîne. </p><br><p>  Conceptuellement, un type est une fonction dont l'exécution est suivie par un conteneur de pile. </p><br><p>  Avec le type, la clé est utilisée lors de la comparaison des arbres pour déterminer si la fibre peut être réutilisée. </p><br><p>  <strong>Enfant et frère</strong> <strong><br></strong> <br>  Ces champs pointent vers d'autres fibres, décrivant la structure récursive des fibres. </p><br><p>  L'enfant fibre correspond à la valeur qui a été renvoyée suite à l'appel de la méthode de rendu sur le composant.  Dans l'exemple ci-dessous: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  Parent Fiber Child correspond à Child. </p><br><p>  Le champ relatif (ou voisin) est utilisé si le rendu renvoie plusieurs enfants (une nouvelle fonctionnalité dans Fibre): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child1</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child2</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">] }</span></span></code> </pre> <br><p>  Les fibres enfants sont une liste liée individuellement à la tête de laquelle se trouve le premier enfant.  Ainsi, dans cet exemple, l'enfant Parent est Child1 et les parents de Child1 sont Child2. </p><br><p>  Pour revenir à notre analogie avec les fonctions, vous pouvez penser à une fibre enfant comme une fonction appelée à la fin (fonction appelée queue). </p><br><p>  Exemple Wikipédia: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ a(data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b(data); }</code> </pre> <br><p>  Dans cet exemple, la fonction appelée queue est b. </p><br><p>  <strong>Valeur de retour (retour)</strong> </p><br><p>  La fibre de retour est la fibre vers laquelle le programme doit retourner après avoir traité la fibre actuelle.  Cela revient à renvoyer l'adresse du conteneur de pile. <br>  Elle peut également être considérée comme une fibre parente. </p><br><p>  Si une fibre a plusieurs fibres enfants, le retour de chaque fibre enfant renvoie la fibre parent.  Dans l'exemple ci-dessus, la fibre de retour de Child1 et Child2 est Parent. </p><br><p>  <strong>Propriétés actuelles et mises en cache (en attenteProps et memoredProps)</strong> </p><br><p>  Conceptuellement, les propriétés sont des arguments de fonction.  Les propriétés de fibre actuelles sont un ensemble de ces propriétés au début de l'exécution, celles mises en cache sont un ensemble à la fin de l'exécution. </p><br><p>  Lorsque les propriétés d'attente d'entrée sont mises en cache, cela signifie que la sortie de fibre précédente peut être réutilisée sans aucun calcul. </p><br><p>  <strong>Priorité des travaux en cours (en attenteWorkPriority)</strong> </p><br><p>  La quantité de travail déterminant la priorité est affichée par la fibre.  Le module de niveau de priorité dans React <a href="">ReactPrioritylevel</a> comprend différents niveaux de priorité et ce qu'ils représentent. </p><br><p>  En commençant par une exception de type NoWork qui est 0, un nombre plus élevé définit la priorité la plus basse.  Par exemple, vous pouvez utiliser la fonction suivante pour vérifier si la priorité de fibre est supérieure au niveau spécifié: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchesPriority</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fiber, priority</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fiber.pendingWorkPriority !== <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fiber.pendingWorkPriority &lt;= priority }</code> </pre> <br><p>  <em>Cette fonction est uniquement à des fins d'illustration;</em>  <em>il ne fait pas partie de la base de données React Fibre.</em> </p><br><p>  L'ordonnanceur utilise le champ prioritaire pour trouver l'unité de travail suivante qui peut être effectuée.  Nous discuterons de cet algorithme dans la section suivante. </p><br><p>  <strong>Alternative (ou paire)</strong> </p><br><p>  Mise à jour (flush) de la fibre - cela signifie afficher sa sortie sur l'écran. </p><br><p>  Fibre en développement (travaux en cours) - fibre qui n'a pas encore été construite;  en d'autres termes, c'est un conteneur de pile qui n'a pas encore été retourné. </p><br><p>  A tout moment, l'essence du composant n'a pas plus de deux états pour la fibre qui correspond à: fibre dans son état actuel, fibre mise à jour ou fibre en développement. </p><br><p>  La fibre actuelle est suivie par la fibre en cours de développement, puis, à son tour, la fibre est mise à jour. </p><br><p>  L'état de fibre suivant est créé paresseusement à l'aide de la fonction cloneFiber.  Presque toujours lors de la création d'un nouvel objet, cloneFiber tentera de réutiliser une alternative (paire) de fibres si elle existe, tout en minimisant le coût des ressources. </p><br><p>  Vous devriez considérer le champ de vapeur (ou son alternative) comme un détail d'implémentation, mais il apparaît si souvent dans la documentation qu'il était tout simplement impossible de ne pas le mentionner. </p><br><p>  La conclusion est un élément de service (ou un ensemble d'éléments de service);  nœuds foliaires Réagissez aux applications.  Ils sont spécifiques à chaque environnement d'affichage (par exemple, dans un navigateur, il s'agit de 'div', 'span', etc.).  Dans JSX, ils sont désignés comme des noms de balises minuscules. </p><br><p>  Conclusion: je recommande d'essayer les fonctionnalités de la nouvelle architecture React v16.0 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444276/">https://habr.com/ru/post/fr444276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444264/index.html">Comment devenir un committer et en avez-vous vraiment besoin?</a></li>
<li><a href="../fr444268/index.html">Semaine de sécurité 12: attaques au clavier</a></li>
<li><a href="../fr444270/index.html">Webinaire du Groupe-IB «L'approche du Groupe-IB en matière de cyberéducation: aperçu des programmes actuels et des cas pratiques»</a></li>
<li><a href="../fr444272/index.html">PyDERASN: comme j'ai écrit la bibliothèque ASN.1 avec des slots et des blobs</a></li>
<li><a href="../fr444274/index.html">Une réponse détaillée au commentaire, ainsi qu'un peu sur la vie des prestataires en Fédération de Russie</a></li>
<li><a href="../fr444278/index.html">Comment inciter des dizaines de milliers de personnes à lire votre article en anglais pour Habr: 3 conseils simples</a></li>
<li><a href="../fr444282/index.html">7 extensions Chrome pour apprendre l'anglais</a></li>
<li><a href="../fr444284/index.html">compositeur et complétion en ligne de commande</a></li>
<li><a href="../fr444286/index.html">Analyse des caméras PTZ: ce qu'il y a à l'intérieur et comment cela fonctionne</a></li>
<li><a href="../fr444288/index.html">Nouvelle application mobile LampTest.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>