<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 🎂 😳 Schmerzloser Fallback-Cache auf Scala 🙌 🙅🏻 🍟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In großen oder Microservice-Architekturen ist der wichtigste Service nicht immer der produktivste und manchmal nicht für Hochlast vorgesehen. Wir spre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schmerzloser Fallback-Cache auf Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/466295/"> In großen oder Microservice-Architekturen ist der wichtigste Service nicht immer der produktivste und manchmal nicht für Hochlast vorgesehen.  Wir sprechen über das Backend.  Es arbeitet langsam - es verliert Zeit bei der Datenverarbeitung und wartet auf eine Antwort zwischen ihm und dem DBMS und skaliert nicht.  Selbst wenn sich die Anwendung selbst leicht skalieren lässt, lässt sich dieser Engpass überhaupt nicht skalieren.  Wie kann dieses Problem gelöst und eine hohe Leistung sichergestellt werden?  Wie kann eine Systemantwort bereitgestellt werden, wenn wichtige Informationsquellen stumm sind? <br><br><img src="https://habrastorage.org/webt/tw/3o/ti/tw3otiqpnki3jcwa8ittvdrpzoc.jpeg"><br><br>  Wenn Ihre Architektur vollständig mit dem Reactive-Manifest übereinstimmt, skalieren die Komponenten der Anwendung unbegrenzt mit zunehmender Last unabhängig voneinander und halten dem Fall eines Knotens stand - Sie kennen die Antwort.  Wenn nicht, wird <b>Oleg Nizhnikov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Odomontois</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">erklären</a> , wie das Skalierbarkeitsproblem bei Tinkoff gelöst wurde, indem er seinen schmerzlosen Fallback-Cache auf Scala erstellt, ohne die Anwendung neu zu schreiben. <br><br>  <i>Hinweis</i>  <i>Der Artikel enthält ein Minimum an Scala-Code und ein Maximum an allgemeinen Prinzipien und Ideen.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p9j6_nOP4Kk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Instabiles oder langsames Backend </h2><br>  Bei der Interaktion mit dem Backend ist die durchschnittliche Anwendung schnell.  Das Backend erledigt jedoch den Großteil der Arbeit und mahlt die meisten Daten intern - es dauert länger.  Es wird zusätzliche Zeit verschwendet, auf ein Backend und eine DBMS-Antwort zu warten.  Selbst wenn sich die Anwendung selbst leicht skalieren lässt, lässt sich dieser Engpass überhaupt nicht skalieren.  Wie kann das Backend entlastet und das Problem gelöst werden? <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Ihr Service</b> <br></td><td>  <b>Backend</b> <br></td></tr><tr><td>  Nettoarbeitszeit in jeder Antwort: (De-) Serialisierung, Überprüfungen, Logik, Asynchronitätskosten <br></td><td>  53 ms <br></td><td>  785 ms <br></td></tr><tr><td>  Warten auf Backend und DBMS <br></td><td>  3015 ms <br></td><td>  1932 ms <br></td></tr><tr><td>  Anzahl der Knoten <br></td><td>  32 <br></td><td>  2 <br></td></tr><tr><td>  Zusammenfassende Antwort <br></td><td>  3070 ms <br></td><td>  2702 ms <br></td></tr></tbody></table></div><br><h3>  Eingebetteter Cache </h3><br>  Die erste Idee besteht darin, Daten zum Lesen zu nehmen, Daten anzufordern und den Cache auf der Ebene jedes speicherinternen Knotens zu konfigurieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/e7d/18f/e98e7d18f9f43d97f36941011d82b3b4.jpg"><br><br>  Der Cache bleibt so lange bestehen, bis der Knoten neu gestartet wird und nur die letzten Daten gespeichert werden.  Wenn die Anwendung abstürzt und neue Benutzer hinzukommen, die nicht in der letzten Stunde, am letzten Tag oder in der letzten Woche waren, kann die Anwendung nichts dagegen tun. <br><br><h3>  Proxy </h3><br>  Die zweite Option ist ein Proxy, der einen Teil der Anforderungen übernimmt oder die Anwendung ändert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ff/817/a49/7ff817a49b919c269c55e9995eaca4f0.jpg"><br><br>  Im Proxy können Sie jedoch nicht die gesamte Arbeit für die Anwendung selbst erledigen. <br><br><h3>  Datenbank zwischenspeichern </h3><br>  Die dritte Option ist schwierig, wenn der Teil der Daten, den das Backend zurückgibt, für lange Zeit gespeichert werden kann.  Wenn sie gebraucht werden, zeigen wir dem Kunden, auch wenn sie nicht mehr relevant sind.  Das ist besser als nichts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/024/8a3/72f/0248a372f78828298f116a711321a55f.jpg"><br><br>  Diese Entscheidung wird diskutiert. <br><br><h2>  Fallback-Cache </h2><br>  Dies ist unsere Bibliothek.  Es ist in die Anwendung eingebettet und kommuniziert mit dem Backend.  Mit minimaler Verfeinerung analysiert es die Datenstruktur, generiert Serialisierungsformate und erhöht mit Hilfe des Leistungsschalteralgorithmus die Fehlertoleranz.  Eine effektive Serialisierung kann in jeder Sprache implementiert werden, in der Typen im Voraus analysiert werden können, wenn sie streng genug definiert sind. <br><br><h3>  Komponenten </h3><br>  Unsere Bibliothek sieht ungefähr so ​​aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/57c/ce0/90657cce0e43cbaf09ba1a38b3e8eaff.jpg"><br><br>  Der linke Teil ist der Interaktion mit diesem Repository gewidmet, das zwei wichtige Komponenten enthält: <br><br><ul><li>  die Komponente, die für den Initialisierungsprozess verantwortlich ist - vorbereitende Aktionen mit dem DBMS vor Verwendung des Fallback-Cache; <br></li><li>  Modul zur automatischen Serialisierung. <br></li></ul><br>  Die rechte Seite ist die allgemeine Funktionalität, die sich auf Fallback bezieht. <br><br>  Wie funktioniert das alles?  In der Mitte der Anwendung befinden sich Abfragen und Zwischentypen zum Speichern des Status.  Dieses Formular drückt die Daten aus, die wir vom Backend für eine oder mehrere Anfragen erhalten haben.  Wir senden die Parameter an unsere Methode und erhalten die Daten von dort.  Diese Daten müssen irgendwie serialisiert werden, um gespeichert zu werden, also verpacken wir sie in Code.  Ein separates Modul ist dafür verantwortlich.  Wir haben das Leistungsschaltermuster verwendet. <br><br><h3>  Speicheranforderungen </h3><br>  <b>Lange Haltbarkeit - 30-500 Tage</b> .  Einige Aktionen können lange dauern, und während dieser ganzen Zeit müssen Daten gespeichert werden.  Daher möchten wir einen Speicher, in dem Daten für lange Zeit gespeichert werden können.  In-Memory ist dafür nicht geeignet. <br><br>  <b>Großes Datenvolumen - 100 GB-20 TB</b> .  Wir möchten Dutzende Terabyte Daten im Cache speichern, und noch mehr aufgrund des Wachstums.  All dies im Speicher zu halten ist ineffizient - die meisten Daten werden nicht ständig angefordert.  Sie lügen lange und warten auf ihren Benutzer, der hereinkommt und fragt.  In-Memory fällt nicht unter diese Anforderungen. <br><br>  <b>Hohe Datenverfügbarkeit</b> .  Mit dem Service kann alles passieren, aber wir möchten, dass das DBMS jederzeit verfügbar bleibt. <br><br>  <b>Niedrige Lagerkosten</b> .  Wir senden zusätzliche Daten an den Cache.  Infolgedessen tritt Overhead auf.  Bei der Implementierung unserer Lösung möchten wir diese minimieren. <br><br>  <b>Unterstützung für Abfragen in regelmäßigen Abständen</b> .  Unsere Datenbank sollte in der Lage sein, Daten nicht nur vollständig, sondern in Intervallen abzurufen: eine Liste von Aktionen, den Verlauf eines Benutzers für einen bestimmten Zeitraum.  Daher ist ein reiner Schlüsselwert nicht geeignet. <br><br><h3>  Annahmen </h3><br>  Anforderungen schränken die Liste der Kandidaten ein.  Wir gehen davon aus, dass wir den Rest implementiert haben, und gehen von den folgenden Annahmen aus, wobei wir wissen, warum genau wir den Fallback-Cache benötigen. <br><br>  <b>Datenintegrität zwischen zwei verschiedenen GET-Anforderungen ist nicht erforderlich</b> .  Wenn sie also zwei verschiedene Zustände aufweisen, die nicht miteinander übereinstimmen, werden wir dies ertragen. <br><br>  <b>Die Relevanz und Ungültigmachung von Daten ist nicht erforderlich</b> .  Zum Zeitpunkt der Anfrage wird davon ausgegangen, dass wir die neueste Version haben, die wir anzeigen. <br><br>  Wir senden und empfangen Daten vom Backend.  <b>Die Struktur dieser Daten ist im Voraus bekannt</b> . <br><br><h2>  Speicherauswahl </h2><br>  Als Alternative haben wir drei Hauptoptionen in Betracht gezogen. <br><br>  Der erste ist <b>Cassandra</b> .  Vorteile: hohe Verfügbarkeit, einfache Skalierbarkeit und integrierter Serialisierungsmechanismus mit der UDT-Sammlung. <br><br>  <b>UDT</b> oder <b>benutzerdefinierte Typen</b> bedeutet einen Typ.  Mit ihnen können Sie strukturierte Typen effizient stapeln.  Typfelder sind im Voraus bekannt.  Diese Serialisierungsfelder sind wie in Protokollpuffern mit separaten Tags gekennzeichnet.  Nach dem Lesen dieser Struktur ist es möglich zu verstehen, welche Felder dort auf Tags basieren.  Genug Metadaten, um ihren Namen und Typ herauszufinden. <br><br>  Ein weiteres Plus von Cassandra ist, dass es neben dem Partitionsschlüssel einen zusätzlichen <b>Clustering-Schlüssel gibt</b> .  Dies ist ein spezieller Schlüssel, aufgrund dessen die Daten auf einem Knoten sortiert werden.  Auf diese Weise können Sie eine Option wie Intervallabfragen implementieren. <br><br>  Cassandra gibt es schon relativ lange, es gibt <b>viele Überwachungslösungen dafür</b> , und <b>ein Minus ist die JVM</b> .  Dies ist nicht die produktivste Option für Plattformen, auf denen Sie ein DBMS schreiben können.  Die JVM hat Probleme mit der Speicherbereinigung und dem Overhead. <br><br>  Die zweite Option ist <b>CouchBase</b> .  Vorteile: Datenzugriff, Skalierbarkeit und Schema. <br><br>  Mit CouchBase müssen Sie weniger über Serialisierung nachdenken.  Dies ist sowohl ein Plus als auch ein Minus - wir müssen das Datenschema nicht steuern.  Es gibt globale Indizes, mit denen Sie Intervallabfragen global in einem Cluster ausführen können. <br><br>  CouchBase ist ein Hybrid, bei dem <b>Memcache</b> zu einem üblichen DBMS hinzugefügt wird <b>- schneller Cache</b> .  Sie können damit automatisch alle Daten auf dem Knoten zwischenspeichern - die heißesten mit sehr hoher Verfügbarkeit.  Dank seines Caches kann CouchBase schnell sein, wenn dieselben Daten sehr oft angefordert werden. <br><br>  <b>Schemaless</b> und <b>JSON</b> können auch ein Minus sein.  Daten können so lange gespeichert werden, dass die Anwendung Zeit zum Ändern hat.  In diesem Fall ändert sich auch die Datenstruktur, die CouchBase speichern und lesen wird.  Die vorherige Version ist möglicherweise nicht kompatibel.  Dies erfahren Sie nur beim Lesen und nicht beim Entwickeln von Daten, wenn diese irgendwo in der Produktion liegen.  Wir müssen über eine ordnungsgemäße Migration nachdenken, und genau das wollen wir nicht tun. <br><br>  Die dritte Option ist <b>Tarantool</b> .  Es ist berühmt für seine super Geschwindigkeit.  Es hat eine wunderbare LUA-Engine, mit der Sie eine Reihe von Logik schreiben können, die direkt auf dem Server von LuaJit ausgeführt wird. <br><br>  Andererseits ist dies ein modifizierter Schlüsselwert.  Daten werden in Tupeln gespeichert.  Wir müssen selbst über die richtige Serialisierung nachdenken, dies ist nicht immer eine offensichtliche Aufgabe.  Tarantool hat auch einen spezifischen Ansatz zur <b>Skalierbarkeit</b> .  Was mit ihm los ist, werden wir weiter diskutieren. <br><br><h3>  Sharding / Replikation </h3><br>  Möglicherweise benötigt unsere Anwendung <b>Sharding / Replication</b> .  Drei Repositorys implementieren sie unterschiedlich. <br><br>  Cassandra schlägt eine Struktur vor, die normalerweise als "Ring" bezeichnet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/b22/828/387b228289ece281dd70ecea2ded8890.jpg"><br><br>  Viele Knoten sind verfügbar.  Jeder von ihnen speichert seine Daten und Daten von den nächstgelegenen Knoten als Replikate.  Wenn einer ausfällt, können die Knoten daneben einen Teil seiner Daten bedienen, bis der Ausfall steigt. <br><br>  Sharding \ Replication ist für dieselbe Struktur verantwortlich.  Zum Auspacken in 10 Teile und Replikationsfaktor 3 reichen 10 Knoten aus.  Jeder der Knoten speichert 2 Replikate der benachbarten. <br><br>  In CouchBase ist die Interaktionsstruktur zwischen Knoten ähnlich aufgebaut: <br><br><ul><li>  Es gibt Daten, die als aktiv markiert sind und für die der Knoten selbst verantwortlich ist. <br></li><li>  Es gibt Replikate benachbarter Knoten, die CouchBase speichert. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/296/09a/1c8/29609a1c8391653566cb36ab9434da21.jpg"><br><br>  Wenn ein Knoten ausfällt, übernehmen die benachbarten, gemeinsam genutzten Knoten die Verantwortung für die Wartung dieses Teils der Schlüssel. <br><br>  In Tarantool ähnelt die Architektur MongoDB.  Aber mit einer Nuance: Es gibt Sharding-Gruppen, die miteinander repliziert werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/5f8/5a5/e815f85a59d330b8250071def6cc0d25.jpg"><br><br>  Für die beiden vorherigen Architekturen sind 4 Knoten erforderlich, wenn 4 Shards und Replikationsfaktor 3 erstellt werden sollen.  Für Tarantool - 12!  Der Nachteil wird jedoch durch die von Tarantool garantierte Geschwindigkeit ausgeglichen. <br><br><h2>  Cassandra </h2><br>  Optionale Module für das Sharding in Tarantool wurden erst kürzlich veröffentlicht.  Aus diesem Grund haben wir das Cassandra DBMS als Hauptkandidaten ausgewählt.  Denken Sie daran, dass wir über die spezifische Serialisierung gesprochen haben. <br><br><h3>  Automatische Serialisierung </h3><br><blockquote>  Das SQL-Protokoll setzt voraus, dass Sie ein Datenschema ziemlich frei definieren können. </blockquote><br>  Sie können dies als Vorteil nutzen.  Serialisieren Sie beispielsweise Daten so, dass die langen Feldnamen unserer Blattstrukturen nicht jedes Mal in unseren Werten gespeichert werden.  In diesem Fall verfügen wir über einige Metadaten, die das Datengerät beschreiben.  UDTs selbst geben auch an, welche Felder Beschriftungen und Tags entsprechen. <br><br>  Daher erfolgt die automatisch generierte Serialisierung ungefähr auf die gleiche Weise.  Wenn wir einen der Grundtypen haben, der dem Typ aus der Datenbank eins zu eins entsprechen kann, tun wir das.  Eine Reihe von Typen Int, Long, String, Double befindet sich ebenfalls in Cassandra. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Anwendungsdatentyp</b> <br></td><td>  <b>Datentyp in Cassandra</b> <br></td></tr><tr><td>  Primitiver Typ <br>  (Int, Long, String, Double, BigDecimal) <br></td><td>  Primitiver Typ <br>  (int, biging, text, double, decimal) <br></td></tr></tbody></table></div><br>  Wenn in einer Struktur ein optionales Feld auftritt, tun wir nichts extra.  Wir geben ihm den Typ an, in den sich dieses Feld verwandeln soll.  Die Struktur speichert null.  Wenn wir in der Struktur auf der Deserialisierungsebene Null finden, nehmen wir an, dass dies das Fehlen eines Wertes ist. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Anwendungsdatentyp</b> <br></td><td>  <b>Datentyp in Cassandra</b> <br></td></tr><tr><td>  Option [A] <br></td><td>  a <br></td></tr></tbody></table></div><br>  Alle Sammlungstypen aus der Sammlung in Scala werden in eine Typliste konvertiert.  Hierbei handelt es sich um geordnete Sammlungen mit einem Index-Matching-Element. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Anwendungsdatentyp</b> <br></td><td>  <b>Datentyp in Cassandra</b> <br></td></tr><tr><td>  Seq [A], Liste [A], Stream [A], Vektor [A] <br></td><td>  eingefroren &lt;Liste "a"&gt; <br></td></tr></tbody></table></div><br>  Ungeordnete Set-Sammlungen garantieren, dass jeder Wert genau ein Element enthält.  Cassandra hat auch einen speziellen Set-Typ für sie. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Anwendungsdatentyp</b> <br></td><td>  <b>Datentyp in Cassandra</b> <br></td></tr><tr><td>  Setze [A] <br></td><td>  eingefroren &lt;setze "a"&gt; <br></td></tr></tbody></table></div><br>  Höchstwahrscheinlich werden wir viel Mapping () haben, insbesondere mit String-Schlüsseln.  Cassandra hat einen speziellen Kartentyp für sie.  Es ist auch typisiert und hat zwei Typparameter.  Damit können wir für jeden Schlüssel einen passenden Typ erstellen <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Anwendungsdatentyp</b> <br></td><td>  <b>Datentyp in Cassandra</b> <br></td></tr><tr><td>  Karte [K, V] <br></td><td>  eingefroren &lt;map "k, v"&gt; <br></td></tr></tbody></table></div><br>  Es gibt Datentypen, die wir selbst in unserer Anwendung definieren.  In vielen Sprachen werden sie als <b>algebraische Datentypen bezeichnet</b> .  Sie werden definiert, indem ein benanntes Produkt von Typen definiert wird, dh eine Struktur.  Wir weisen diese Struktur dem benutzerdefinierten Typ zu.  Jedes Feld der Struktur entspricht einem Feld in der UDT. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Anwendungsdatentyp</b> <br></td><td>  <b>Datentyp in Cassandra</b> <br></td></tr><tr><td>  Typ Produkt: Fallklasse <br></td><td>  UDT <br></td></tr></tbody></table></div><br>  Der zweite Typ ist die <b>algebraische Summe der Typen</b> .  In diesem Fall entspricht der Typ mehreren zuvor bekannten Subtypen oder Unterarten.  In gewisser Weise weisen wir ihm auch eine Struktur zu. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Anwendungsdatentyp</b> <br></td><td>  <b>Datentyp in Cassandra</b> <br></td></tr><tr><td>  Typ Summe: versiegeltes Merkmal \ Klasse <br></td><td>  UDT <br></td></tr></tbody></table></div><br><h3>  Abstrakter Datentyp in UDT übersetzen </h3><br>  Wir haben eine Struktur und zeigen sie eins zu eins an - für jedes Feld definieren wir das Feld in der erstellten UDT in Cassandra: <br><br><pre><code class="plaintext hljs">case class Account ( id: Long, tags: List[String], user: User, finData: Option[FinData] ) create type account ( id bigint, tags: frozen&lt;list&lt;text&gt;&gt;, user frozen&lt;user&gt;, fin_data frozen&lt;fin_data&gt; )</code> </pre> <br>  Primitive Typen werden zu primitiven Typen.  Ein Link zu einem vordefinierten Typ, bevor dieser eingefroren wird.  Dies ist ein spezieller Wrapper in Cassandra, was bedeutet, dass Sie nicht Stück für Stück aus diesem Feld lesen können.  Der Wrapper ist in diesem Zustand "eingefroren".  Wir können nur den Benutzer oder die Liste lesen oder speichern, wie im Fall von Tags. <br><br>  Wenn wir auf ein optionales Feld treffen, verwerfen wir dieses Merkmal.  Wir nehmen nur den Datentyp, der dem Feldtyp entspricht, der sein wird.  Wenn wir hier nicht treffen - das Fehlen eines Wertes - schreiben wir null in das entsprechende Feld.  Beim Lesen nehmen wir auch Korrespondenz ungleich Null entgegen. <br><br>  Wenn wir auf einen Typ treffen, der mehrere bekannte Alternativen aufweist, definieren wir in Cassandra auch einen neuen Datentyp.  Für jede Alternative ein Feld in unserem Datentyp in UDT. <br><br>  Infolgedessen ist in dieser Struktur zu einem bestimmten Zeitpunkt nur eines der Felder nicht null.  Wenn Sie einen Benutzertyp kennengelernt haben und sich zur Laufzeit als Instanz eines Moderators herausstellte, enthält das Moderatorfeld einen Wert, der Rest ist null.  Für admin - admin ist der Rest - null. <br><br>  Auf diese Weise können Sie die Struktur wie folgt codieren: Wir haben 4 optionale Felder, wir garantieren, dass nur eines von ihnen geschrieben wird.  Cassandra verwendet nur ein Tag, um das Vorhandensein eines bestimmten Feldes in der Struktur zu identifizieren.  Dank dessen erhalten wir eine Speicherstruktur ohne Overhead. <br><br>  Um den Benutzertyp zu speichern, wird als Moderator dieselbe Anzahl von Bytes benötigt, die zum Speichern des Moderators erforderlich sind.  Plus ein Byte, um zu zeigen, welche bestimmte Alternative hier vorhanden ist. <br><br><h3>  Initialisierung </h3><br><blockquote>  Die Initialisierung ist ein vorläufiges Verfahren, das abgeschlossen sein muss, bevor wir unseren Fallback verwenden können. </blockquote><br>  Wie funktioniert dieser Prozess? <br><br><ul><li>  Auf jedem Knoten generieren wir Definitionen von Tabellen, Typen und Abfragetexten basierend auf den dargestellten Typen. <br></li><li>  Lesen Sie das aktuelle Schema aus dem DBMS.  In Cassandra ist dies einfach, indem Sie einfach eine Verbindung herstellen.  Wenn eine Verbindung besteht, pumpt das "Sitzungs" -Objekt in fast allen Treibern die Metadaten des Schlüsselbereichs aus, mit denen es verbunden ist.  Dann können Sie sehen, was sie haben. <br></li><li>  Wir gehen die Metadaten durch, vergleichen und überprüfen, ob alles, was wir erstellen möchten, zulässig ist und ob eine inkrementelle Migration möglich ist. <br></li><li>  Wenn alles normal ist und eine Initialisierung möglich ist, führen wir die Migration durch. <br></li><li>  Wir bereiten Anfragen vor. <br></li></ul><br><pre> <code class="plaintext hljs">sealed trait User case class Anonymous extends User case class Registered extends User case class Moderator extends User case class Admin extends User create type user ( anonymous frozen&lt;anonymous&gt;, registered frozen&lt;registered&gt;, moderator frozen&lt;moderator&gt;, admin frozen&lt;admin&gt; )</code> </pre> <br>  Es passiert so.  Wir haben <b>Typen</b> , <b>Tabellen</b> und <b>Abfragen</b> .  Typen hängen von anderen Typen ab, die von anderen.  Tabellen hängen von diesen Typen ab.  Abfragen hängen bereits von den Tabellen ab, aus denen sie Daten lesen.  Bei der Initialisierung werden alle diese Abhängigkeiten überprüft und im DBMS alles erstellt, was nach bestimmten Regeln erstellt werden kann. <br><br><h3>  Geben Sie Migration ein </h3><br>  Wie kann festgestellt werden, dass ein Typ schrittweise migriert werden kann? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/eeb/554/105eeb554bcc5eadaf10753f8c150531.jpg"><br><br><ul><li>  Wir lesen, wie dieser Typ im DBMS definiert ist. <br></li><li>  Wenn es keinen solchen Typ gibt, haben wir uns einen neuen ausgedacht - wir erstellen ihn. <br></li><li>  Wenn ein solcher Typ bereits vorhanden ist, versuchen wir, die vorhandene Definition Feld für Feld mit der zu vergleichen, die wir diesem Typ geben möchten. <br></li><li>  Wenn sich herausstellt, dass wir nur einige Felder hinzufügen möchten, die nicht mehr existieren, tun wir dies.  Erstellen Sie eine Liste mutierender ALTER TYPE-Operationen und starten Sie sie. <br></li><li>  Wenn sich herausstellt, dass wir ein Feld eines anderen Typs haben, generieren wir einen Fehler.  Zum Beispiel gab es eine Liste - wurde zu einer Karte oder es gab einen Link zu einem benutzerdefinierten Typ, und wir versuchen, ihn anders zu machen. <br></li></ul><br>  Der Entwickler kann diesen Fehler sehen, noch bevor er die Funktionalität in der Produktion startet.  Ich gehe davon aus, dass sich in seiner Entwicklungsumgebung genau das gleiche Datenschema befindet.  Er sieht, dass er irgendwie ein nicht migrierbares Datenschema erstellt hat, und um diese Fehler zu vermeiden, kann er die automatisch generierte Serialisierung überschreiben, Optionen hinzufügen, Felder umbenennen oder alle Typen und Tabellen als Ganzes. <br><br><h3>  Initialisierung: Typen </h3><br>  Stellen Sie sich vor, es gibt verschiedene Arten von Definitionen: <br><br><pre> <code class="plaintext hljs">case class Product (id: Long, name: ctring, price: BigDecimal) case class UserOffers (valiDate: LocalDate, offers: Seq[Products]) case class UserProducts (user User, products: Map[Date, Product]) case class UserInfo: UserOffers, products: UserProducts)</code> </pre> <br>  <b>Fallklasse</b> - Eine Klasse, die eine Reihe von Feldern enthält.  Dies ist ein Analogon von struct in Rust. <br><br>  Wir werden ungefähr solche Datendefinitionen für jeden der 4 Typen generieren - was wir schließlich ankurbeln wollen: <br><br><pre> <code class="plaintext hljs">CREATE TYPE product (id bigint, name text, price decimal); CREATE TYPE user_offers (valid_date date, offers frozen&lt;list&lt;frozen&lt;offer&gt;&gt;&gt;); CREATE TYPE user_products (user frozen&lt;user&gt;, products frozen&lt;map&lt;date, frozen&lt;product&gt;&gt;); CREATE TYPE user_jnfo (offers: frozen&lt;user_offers&gt;, products: frozen&lt;user_products&gt;);</code> </pre> <br>  Die Art der user_offers hängt von der Art des Angebots ab, user_products hängt von der Art des Produkts ab, user_info vom zweiten und dritten Typ. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5bb/e3b/e9d/5bbe3be9d2694677b42b59613305752b.jpg"><br><br>  Wir haben eine solche Abhängigkeit zwischen Typen und möchten sie korrekt initialisieren.  Das Diagramm zeigt, dass wir user_offers und user_products parallel initialisieren.  Dies bedeutet nicht, dass wir zwei parallele Operationen starten werden.  Nein, wir starten alle Anweisungen, alle Analysen nacheinander, um nicht versehentlich denselben Typ in zwei parallelen Threads zu erstellen. <br><br>  Auf der Ebene der Fehlerkorrektur besteht jedoch eine gewisse Parallelität.  Wenn ein Typfehler auftritt, wird bei allem, was davon abhängt, der ursprüngliche Fehler abgerufen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/122/93f/0ba/12293f0bab8bd0a8b7e12d092380a5c5.jpg"><br><br>  Wenn ein Fehler von einem der parallelen Zweige generiert wird, wird alles, was von normal migrierten Daten abhängt, fehlerfrei generiert.  Wenn es weitere Definitionen von Tabellen und vorbereitete Anweisungen gibt, können wir diesen Teil unseres Fallback-Cache sicher initialisieren.  Die Kommunikation geht nur mit einem Teil der Backends oder mit einigen Funktionen verloren.  Die restlichen werden initialisiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/5ec/3a2/a8d5ec3a2483d899c7db16ac56974fe9.jpg"><br><br>  Es kann vorkommen, dass zwei gleichzeitig initialisierte Typen unterschiedliche Fehler erzeugen.  In diesem Fall führt eine Funktionalität, die von beiden Typen abhängt, zu einem summierenden Fehlertyp.  Der Entwickler, der seinen Fallback in der Entwicklungsumgebung initialisiert, erhält eine vollständige Liste der fehlerhaften Daten.  Natürlich kann er es hier beheben und den Fehler weiter bringen.  Es wird jedoch nicht so sein, dass ein völlig unabhängiger Zweig die Fehler schließt, die wir bekommen könnten, unabhängig von diesem Zweig. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/e94/4ba/d08e944ba9b210d16f6f6c0b57048051.jpg"><br><br><h3>  Initialisierung: Tabellen </h3><br>  Als nächstes erstellen wir die Tabellen. <br><br><pre> <code class="plaintext hljs">def getOffer (user: User, number: Long): Future[OfferData] create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt;PRIMARY KEY, value frozen&lt;friend_data&gt; )</code> </pre> <br>  Eine solche Anforderung kann direkt eine REST- oder SOAP-Anforderung starten, zusätzliche Vorgänge darin erstellen oder sogar mehrere Anforderungen ausführen.  Es hängt alles von Ihrem Code ab - wie Sie den Code organisiert haben.  Fallback analysiert nicht vollständig, was innerhalb der Methode passiert, an der Sie einen solchen Stub aufhängen. <br><br><blockquote>  Die Methode muss asynchron sein, da Fallback identisch ist. </blockquote><br>  In Scala ist dies mit einer besonderen Art von Zukunft gekennzeichnet.  Dies bedeutet, dass das Ergebnis eines Tages zurückkehren wird.  Wann genau - es ist unbekannt: vielleicht sofort oder vielleicht auch nicht. <br><br>  Erstellen Sie für die Methode eine Tabelle.  Der Schlüssel in der Tabelle ist ein Tupel aller Typen, die den Parametern dieser Methode entsprechen.  Der Nichtschlüsselwert ist das Ergebnis, das asynchron zurückgegeben wird.  Für jede solche Tabelle bereiten wir im Voraus zwei parametrische Abfragen vor: Daten einfügen und Daten lesen. <br><br><pre> <code class="plaintext hljs">insert into get_offer(key, value) values (?key, ?value); select value from get_offer where key = ?key;</code> </pre> <br>  Alles ist bereit, mit dem DBMS zu interagieren.  Es bleibt abzuwarten, wie wir Daten aus Fallback lesen werden. <br><br><h3>  Leistungsschalter </h3><br>  Hier geht die Verantwortung in die Zone des berühmten Leistungsschaltermusters über. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c0/de1/91c/5c0de191c5c1699cc8f324f38d62b6ee.jpg"><br><br>  Ein typischer Leistungsschalter enthält drei Zustände. <br><br>  <b>Geschlossen - der standardmäßig geschlossene Zustand</b> , der unser Backend schließt.  Das Prinzip ist, dass wir die Daten zuerst aus dem Backend lesen und nur dann zu Fallback gehen, wenn wir sie nicht erhalten konnten.  Wenn es uns gelungen ist, die Daten abzurufen, suchen wir nicht in Fallback, sondern speichern die Daten darin, und es passiert nichts. <br><br>  Wenn die Probleme nacheinander auftreten, gehen wir davon aus, dass das Backend liegt.  Um es nicht mit einer riesigen Menge neuer Anfragen zu spammen, wechseln wir zu <b>Open - in einem zerrissenen Zustand</b> .  Darin versuchen wir, Daten nur aus Fallback zu lesen.  Wenn es nicht funktioniert, geben wir sofort einen Fehler zurück und berühren nicht einmal das Haupt-Backend. <br><br>  Nach einer Weile entscheiden wir uns herauszufinden, ob das Backend aufgewacht ist, und versuchen, den <b>halboffenen Zustand - einen kurzlebigen Zustand - zurückzusetzen</b> .  Seine Lebensspanne ist eine Bitte. <br><br>  Im kurzlebigen Zustand entscheiden wir uns, wieder zu schließen oder für eine noch längere Zeit zu öffnen.  Wenn wir im halboffenen Zustand erfolgreich Fallback erreichen und die nächste Anfrage erhalten, gehen wir in den geschlossenen Zustand.  Wenn wir nicht durchkommen konnten, kehren wir zu Open zurück, aber für eine lange Zeit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ad/92e/4a4/9ad92e4a417201c8655ed4785ae21dfc.jpg"><br><br>  Wir haben zwei zusätzliche Zustände hinzugefügt, die eindeutig nicht mit der Leistungsschalterschaltung zusammenhängen: <br><br><ul><li>  Erzwungener - gewaltsam geschlossener Zustand; <br></li><li>  Umgekehrt - Priorität für offenen, geschlossenen Zustand invertiert. <br></li></ul><br>  Mal sehen, was sie tun. <br><br><h3>  Das Funktionsprinzip von Staaten </h3><br>  <b>Geschlossen</b>  Das Schema ist groß, aber es reicht aus, um das allgemeine Prinzip daraus zu verstehen.  Wir behalten Fallback parallel dazu bei, wie wir das Ergebnis aus dem Backend zurückgeben, wenn dort alles gut gelaufen ist und lesen aus Fallback.  Wenn es überall schlecht ist, geben wir die Fehlerpriorität zurück. <br><br><blockquote>  Wählen Sie aus den beiden Fehlern den Backend-Fehler aus. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/541/f99/5b7541f99197cc1730c6a934cebe6516.jpg"><br><br>  Wenn keine Fehler vorliegen, erhöhen wir parallel dazu den Zähler und gehen in den geöffneten Zustand, wenn zu viele Anforderungen vorliegen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/182/18f/25d/18218f25de112cf7f6a88291fccbe72f.jpg"><br><br>  <b>Öffnen</b>  Der offene Zustand von Open ist einfacher - wir lesen ständig aus Fallback, egal was passiert, und nach einer Weile versuchen wir, in den halboffenen Zustand zu wechseln. <br><br>  <b>Halb offen</b> .  Der Zustand in der Struktur ähnelt geschlossen.  Der Unterschied besteht darin, dass wir im Falle einer erfolgreichen Antwort in einen geschlossenen Zustand übergehen.  Im Fehlerfall kehren wir mit einem längeren Intervall zum Open zurück. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/a1e/7c8/b82a1e7c89774bbe327613b51f50f5c0.jpg"><br><br>  <b>Forced ist ein zusätzlicher Status zum Aufwärmen des Caches</b> .  Wenn wir es mit Daten füllen, versucht es nie, aus Fallback zu lesen, sondern fügt nur Datensätze hinzu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdc/8e3/b33/bdc8e3b335750b826fdd21db6c0f0ac7.jpg"><br><br>  <b>Umgekehrt ist ein zweiter weit hergeholter Zustand</b> .  Es funktioniert wie ein persistenter Cache.  Wir aktivieren den Status, wenn wir die Last dauerhaft aus dem Backend entfernen möchten, auch wenn die Daten möglicherweise irrelevant sind.  Die ersten Suchvorgänge in Fallback wurden rückgängig gemacht. Wenn die Suche fehlgeschlagen ist, wird das Backend aufgerufen und behandelt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/618/0da/8ed/6180da8edf69398780bd37fae9bc8ba7.jpg"><br><br><h3>  Die Probleme </h3><br>  Bei diesem ganzen Schema hatten wir mehrere Probleme.  Am ernstesten ist es, zu verstehen, wie <b>vorbereitete Aussagen</b> in Cassandra funktionieren.  Dieses Problem wurde in Version 4.0 behoben, die noch nicht veröffentlicht wurde. Ich werde es Ihnen also sagen. <br><br>  Cassandra wurde entwickelt, um Millionen von Kunden gleichzeitig damit zu verbinden, und jeder versucht, seine vorbereiteten Aussagen vorzubereiten.  Natürlich bereitet Cassandra nicht jede vorbereitete Anweisung vor, da sonst der Speicherplatz knapp wird.  Es berechnet den MD5-Parameter basierend auf Text, Schlüsselraum und Abfrageoptionen.  Wenn sie genau dieselbe Anfrage mit genau demselben MD5 erhält, nimmt sie die bereits vorbereitete Anfrage entgegen.  Es enthält bereits Informationen zu Metadaten und deren Handhabung. <br><br>  Es gibt jedoch Versionsprobleme.  Wir veröffentlichen eine neue Version, die erfolgreich Migrationen durchgeführt, Felder in Typen hinzugefügt und vorbereitete Anweisungen ausgeführt hat.  Sie kommen mit der vorherigen Version unseres Status und unserer Metadaten zurück - mit Typen ohne Felder.  Zum Zeitpunkt des Lesens der Daten versuchen wir, ihre neuen erforderlichen Spalten zu schreiben, und sehen uns mit der Tatsache konfrontiert, dass sie einfach nicht existieren!  Cassandra sagt, dass dies im Allgemeinen ein anderer Typ ist, den sie nicht kennt. <br><br>  Wir haben dieses Problem wie folgt behandelt: Wir haben <b>jeder unserer vorbereiteten Anfrage einen eindeutigen Text hinzugefügt</b> . <br><br><pre> <code class="plaintext hljs">create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt; PRIMARY KEY, value frozen&lt;friend_data&gt;, query_tag text ) insert into get_offer (key, value, query_tag) values (?key, ?value, 'tag_123'); select value as tag_123 from get_offer where key = ?key;</code> </pre> <br>  Wir werden nicht Millionen verbundener Clients haben, sondern nur eine Sitzung für jeden Knoten, der mehrere Verbindungen enthält.  Für jede vorbereitende Anweisung einmal.  Wir gehen davon aus, dass es in Ordnung ist, wenn für jede Version der Anwendung oder für jeden Start eines Knotens ein eindeutiger Text generiert wird, der eindeutig im Text unserer Anfrage enthalten ist. <br><br>  Wir haben ein spezielles Feld hinzugefügt, um ihn auszutricksen.  Beim Einfügen schreiben wir eine Konstante in dieses Feld.  Es ist für jeden Start oder jede Anwendungsversion eindeutig - dies wird in der Bibliothek konfiguriert.  Beim Lesen verwenden wir diesen Namen als Alias ​​für den Wert, den wir erhalten.  Die Anfrage ist genau die gleiche, wir machen immer noch einen ausgewählten Wert, aber der Text ist anders.  Cassandra erkennt nicht, dass dies dieselbe Anforderung ist, berechnet eine andere MD5 und bereitet die Anforderung erneut mit neuen Metadaten vor. <br><br>  Das zweite Problem ist das <b>Migrationsrennen</b> .  Zum Beispiel möchten wir mehrere parallele Migrationen durchführen.  Beginnen wir mit einigen Notizen und gleichzeitig starten sie Berechnungen, führen Tabellen erstellen und Typen erstellen aus.  Dies kann dazu führen, dass auf jedem Knoten oder in jedem der parallelen Threads alles erfolgreich ist und zwei Tabellen erfolgreich erstellt wurden.  Aber in Cassandra ist man verwirrt und wir werden eine Auszeit zum Schreiben und Lesen erhalten. <br><br><blockquote>  Sie können Cassandra unterbrechen, wenn Sie versuchen, Prozesse aus mehreren Threads oder aus mehreren Knoten zu parallelisieren. </blockquote><br>  Wenn wir wissen, dass eine Fallback-Migration erforderlich ist, <b>migrieren</b> wir <b>vor der Veröffentlichung von einem speziellen Knoten</b> .  Nur dann werden wir alle unsere Knoten während der Veröffentlichung starten.  Also haben wir dieses Problem gelöst. <br><br>  Das dritte Problem ist der <b>Mangel an Daten im Fallback-Cache</b> .  Es mag sein, dass wir die Methode „voll unterstützt“ haben, sie sollte historische Daten für ein Jahr speichern, aber in Wirklichkeit haben wir sie gestern gestartet. <br><br>  <b>Das Problem wurde durch Aufwärmen gelöst</b> .  Wir haben den Status "Erzwungen" verwendet und spezielle Knoten gestartet, die nicht mit echten Benutzern kommunizieren.  Sie nehmen alle möglichen Schlüssel, die wir annehmen, und erwärmen den Cache in einem Kreis.  Das Aufwärmen geht so schnell, dass das Backend, aus dem wir lesen, nicht zerstört wird. <br><br><blockquote>  Skalierung von Anwendungen, Backend, Big Data und Frontend - Scala ist dafür geeignet.  Am 26. November veranstalten wir eine professionelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konferenz für Scala-Entwickler</a> .  Stile, Ansätze, Dutzende von Lösungen für das gleiche Problem, die Nuancen der Verwendung alter und bewährter Ansätze, die Praxis der funktionalen Programmierung, die Theorie der radikalen funktionalen Kosmonautik - darüber werden wir auf der Konferenz sprechen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beantragen Sie</a> einen Bericht, wenn Sie Ihre Scala-Erfahrung vor dem 26. September teilen möchten, oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">buchen Sie Ihre Tickets</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466295/">https://habr.com/ru/post/de466295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466283/index.html">Opencartforum und Freunde</a></li>
<li><a href="../de466285/index.html">Ein kleines Werbegeschenk: Tombola Combo DVR und Radarwarner</a></li>
<li><a href="../de466287/index.html">2019 National Internet Segments Reliability Research & Report</a></li>
<li><a href="../de466289/index.html">Legislative Initiativen. Seltsam, aber der Staatsduma vorgestellt</a></li>
<li><a href="../de466291/index.html">Nachhaltigkeitsumfrage der nationalen Internet-Segmente für 2019</a></li>
<li><a href="../de466299/index.html">Russische Soziologen führten die weltweit erste Chatbots-Umfrage durch</a></li>
<li><a href="../de466301/index.html">Noch etwas: Haiku-App-Pakete?</a></li>
<li><a href="../de466305/index.html">Takashi Kokubun: Wie man Ruby-Anwendungen schneller laufen lässt</a></li>
<li><a href="../de466307/index.html">Wie gestalte ich SCS?</a></li>
<li><a href="../de466311/index.html">SLS Workshop 6. September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>