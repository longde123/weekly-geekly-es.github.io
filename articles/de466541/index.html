<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐟 🕧 🤟🏿 Verwenden von DbTool zum Seeding von Datenbanken in .NET-Anwendungen (Core) 🧔 💆 👩🏼‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir stellen Ihnen DbTool vor - ein Befehlszeilenprogramm zum Exportieren von Datenbankdaten in verschiedene Formate und die Open-Source-Bibliothek Kor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von DbTool zum Seeding von Datenbanken in .NET-Anwendungen (Core)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466541/"><p>  Wir stellen Ihnen DbTool vor - ein Befehlszeilenprogramm zum Exportieren von Datenbankdaten in verschiedene Formate und die Open-Source-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Korzh.DbUtils</a> , deren Verwendung die anfängliche "Aussaat" der Datenbank in Ihrer .NET (Core) -Anwendung erheblich vereinfachen kann. </p><br><p>  Mit diesem Toolkit können Sie: </p><br><ol><li>  Speichern Sie Daten aus Ihrer lokalen Datenbank in Dateien eines bestimmten Textformats (XML, JSON), die einfach mit dem Projekt verbunden werden können. </li><li>  Verwenden Sie gespeicherte Dateien, um die Datenbank der Anwendung beim ersten Start selbst zu füllen. </li></ol><br><p>  Im Folgenden werde ich Ihnen erklären, warum dies alles notwendig ist, wie diese Tools installiert und konfiguriert werden und ein detailliertes Szenario für ihre Verwendung beschreiben. </p><br><p><img src="https://habrastorage.org/webt/3r/sk/3i/3rsk3iitaroanayip5fskvr3fxc.png" alt="Bild"></p><a name="habracut"></a><br><h2 id="zachem-my-sdelali-dbtool">  Warum haben wir DbTool gemacht? </h2><br><p>  Die anfängliche Aufgabe bestand darin, einen praktischen Mechanismus zum Füllen von Datenbanken in .NET (Core) -Anwendungen zu erstellen.  Aufgrund der Besonderheiten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserer Art von Aktivität</a> (Komponentenentwicklung) müssen wir häufig kleine Beispielanwendungen erstellen, die das eine oder andere Merkmal unseres Produkts demonstrieren.  Solche Demo-Projekte sollten mit einer bestimmten Testdatenbank funktionieren. Daher ist es ratsam, diese Datenbank beim ersten Start der Anwendung automatisch zu erstellen und zu füllen. </p><br><p> Wenn das Projekt das Entity Framework (Core) verwendet (und dies am häufigsten vorkommt), gibt es keine Probleme beim Erstellen der Datenbank.  Sie rufen einfach <code>dbContext.Database.EnsureCreated</code> oder <code>dbContext.Database.Migrate</code> (wenn es wichtig ist, die Migrationen <code>dbContext.Database.Migrate</code> ). </p><br><p>  Aber mit dem Füllen der Datenbank ist alles etwas komplizierter.  Das erste, was Ihnen in den Sinn kommt, ist einfach, ein SQL-Skript mit einer Reihe von INSERTs zu erstellen, es in das Projekt einzufügen und es beim ersten Start auszuführen.  Dies funktioniert (und wir haben es lange getan), aber es gibt einige Probleme mit diesem Ansatz.  Zunächst ein SQL-Syntaxproblem für ein bestimmtes DBMS.  Sehr oft unterscheidet sich das ursprüngliche DBMS von dem, das tatsächlich vom Benutzer verwendet wird, und unser SQL-Skript funktioniert möglicherweise nicht. </p><br><p>  Das zweite mögliche Problem ist die Migration der Datenbank selbst.  Von Zeit zu Zeit muss die Datenbankstruktur geringfügig geändert werden (neues Feld hinzufügen, altes löschen oder umbenennen, neue Beziehung zwischen Tabellen hinzufügen usw.).  Ein SQL-Skript, das unter der alten Struktur erstellt wurde, ist in diesem Fall normalerweise irrelevant und seine Ausführung verursacht einen Fehler.  Das Laden von Daten aus einem Drittanbieterformat verläuft problemlos.  Neue / geänderte Felder werden einfach übersprungen.  Stimmen Sie zu, dass es zu Demonstrationszwecken besser ist, das Programm zu starten, wenn auch ohne Daten in einem neuen Bereich, als dass es überhaupt nicht startet. </p><br><p>  Als Ergebnis kamen wir zu folgender Lösung: </p><br><ol><li>  Die Daten aus der "Masterkopie" unserer Demo-Datenbank werden in einer Datei in einem bestimmten "unabhängigen" Format aufgezeichnet (derzeit ist es XML oder JSON).  Die resultierenden Dateien (oder eine Archivdatei) werden mit dem Projekt geliefert.  Diese Aufgabe befasst sich tatsächlich mit DbTool. </li><li>  In unser Programm wird ein kleiner Code eingefügt, der mithilfe der Klassen und Funktionen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Korzh.DbUtils-</a> Bibliothek die Datenbank mit Daten aus den im ersten Schritt erhaltenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien</a> füllt. <br>  Zusätzlich zum obigen Szenario kann DbTool einfach zum Exportieren von Daten in andere Formate und zum Übertragen von Daten zwischen Datenbanken verwendet werden.  So können Sie beispielsweise Daten aus Ihrer Datenbank auf SQL Server hochladen und dann in eine ähnliche Datenbank in MySQL laden </li></ol><br><h2 id="installyaciya">  Installation </h2><br><p>  DbTool ist als globales .NET Core-Tool implementiert, d.h.  kann problemlos auf jedem System installiert werden, auf dem ein <a href="">.NET SDK Version 2.1</a> oder höher vorhanden ist. </p><br><p>  Um das Dienstprogramm zu installieren, müssen Sie nur die Konsole (Terminal / Eingabeaufforderung) öffnen und den folgenden Befehl ausführen: </p><br><pre> <code class="plaintext hljs">dotnet tool install -g Korzh.DbTool</code> </pre> <br><p>  <code>dbtool</code> Sie zur Überprüfung nach der Installation <code>dbtool</code> in die Konsole ein. Sie erhalten Hilfe zu einer Liste der verfügbaren Befehle. </p><br><p><img src="https://habrastorage.org/webt/tn/x_/zs/tnx_zs0qltekxzf9jkkfiwf4jai.png"></p><br><h2 id="dobavlyaem-soedinenie-s-bazoy">  Verbindung zur Datenbank hinzufügen </h2><br><p>  Um mit DbTool arbeiten zu können, müssen Sie eine Datenbankverbindung hinzufügen: </p><br><pre> <code class="plaintext hljs">dbtool add {YourConnectionId} {DbType} {YourConnectionString}</code> </pre> <br><p>  Hier: </p><br><ul><li>  {YourConnectionId} ist eine Kennung, die Sie dieser Verbindung zuweisen möchten, damit Sie später darauf zugreifen können, wenn Sie andere Befehle ausführen. </li><li>  DbType ist der Typ Ihres DBMS.  Zum Zeitpunkt dieses Schreibens unterstützte DbTool (Version 1.1.7) SQL Server- (mssql) und MySQL- (mysql) Datenbanken. </li><li>  Der letzte Parameter in diesem Befehl ist die Verbindungszeichenfolge.  Das gleiche, das Sie bereits in Ihrem .NET (Core) -Projekt verwenden. </li></ul><br><p>  Ein Beispiel: </p><br><p><img src="https://habrastorage.org/webt/o8/az/ml/o8azmls5cz7im6noyyuuixtsa3w.png"></p><br><p>  Danach können Sie alle Ihre Verbindungen überprüfen, indem Sie Folgendes eingeben: </p><br><pre> <code class="plaintext hljs">dbtool connections list</code> </pre> <br><h2 id="eksport-dannyh">  Datenexport </h2><br><p>  Nachdem wir die Verbindung hinzugefügt haben, können wir unsere Datenbank mit dem Befehl export exportieren: </p><br><pre> <code class="plaintext hljs">dbtool export {ConnectionId} [--format=xml|json] [--output={path-to-folder}] [--zip={file-name}]</code> </pre> <br><p>  Jede oben erwähnte Option kann weggelassen werden.  Wenn Sie kein <code>format</code> angeben <code>format</code> wird JSON verwendet.  Wenn Sie die <code>output</code> weglassen, wird das Ergebnis in entpackter Form in einem Verzeichnis der Form <code>ConnectionId_yyyy-MM-dd</code> abgelegt. </p><br><p>  Zum Beispiel der folgende Befehl: </p><br><pre> <code class="plaintext hljs">dbtool export MyDb01 --zip=MyDbData.zip</code> </pre> <br><p>  erstellt ein ZIP-Archiv mit dem Namen MyDbData.zip im aktuellen Verzeichnis und füllt es mit Datendateien im JSON-Format (eine Datei für jede Datenbanktabelle). </p><br><p><img src="https://habrastorage.org/webt/nc/eb/nz/ncebnz_khmkvpxjuhxwarhzdfva.png"></p><br><h2 id="import-dannyh">  Datenimport </h2><br><p>  Sie können die im vorherigen Schritt erstellten Daten wieder in Ihre Datenbank importieren.  Oder zu einer anderen Basis mit derselben Struktur. </p><br><blockquote>  Wichtig: DbTool erstellt während des Importvorgangs keine Tabellen.  Daher muss die Datenbank, in die die Daten importiert werden, bereits vorhanden sein und dieselbe (oder zumindest eine ähnliche) Struktur wie die ursprüngliche haben. </blockquote><p>  Der Importbefehl selbst lautet wie folgt: </p><br><pre> <code class="plaintext hljs">dbtool import {ConnectionId} [--input=path-to-file-or-folder] [--format=xml|json]</code> </pre> <br><p>  Die Option <code>--input</code> teilt dem Dienstprogramm mit, wo nach importierten Daten <code>--input</code> werden soll.  Wenn ein Ordnerpfad angegeben ist, importiert DbTool XML- oder JSON-Dateien in diesen Ordner.  Wenn es sich um eine ZIP-Datei handelt, entpackt das Dienstprogramm zuerst dieses Archiv und entfernt von dort die erforderlichen Datendateien. </p><br><p>  Wie im vorherigen Fall kann <code>--format</code> weggelassen werden, da DbTool das Format an Dateierweiterungen erkennen kann. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="plaintext hljs">dbtool import MyDb01 --input=MyDbData.zip</code> </pre> <br><h2 id="bibilioteka-korzhdbutils">  Bibliothek Korzh.DbUtils </h2><br><p>  Das DbTool-Dienstprogramm selbst basiert auf der Open-Source-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Korzh.DbUtils</a> , die mehrere Pakete mit der Implementierung einiger grundlegender Datenbankoperationen enthält. </p><br><h3 id="korzhdbutils">  Korzh.DbUtils </h3><br><p>  Definiert grundlegende Abstraktionen und Schnittstellen wie IDatasetExporter, IDatasetImporter, IDataPacker, IDbBridge </p><br><h3 id="korzhdbutilsimport">  Korzh.DbUtils.Import </h3><br><p>  Enthält Implementierungen von IDatasetImporter-Schnittstellen für XML- und JSON-Formate.  Darüber hinaus enthält dieses Paket die DbInitializer-Klasse, mit der Sie Daten in Ihren Projekten auffüllen können (mehr dazu weiter unten). </p><br><h3 id="korzhdbutilsexport">  Korzh.DbUtils.Export </h3><br><p>  Enthält Implementierungen von IDatasetExporter für XML und JSON. </p><br><h3 id="korzhdbutilssqlserver">  Korzh.DbUtils.SqlServer </h3><br><p>  Enthält die Implementierung der Schnittstellen grundlegender Datenbankoperationen (IDbBridge, IDbReader, IDbSeeder) für MS SQL Server. </p><br><h3 id="korzhdbutilsmysql">  Korzh.DbUtils.MySQL </h3><br><p>  Enthält Implementierungen von Datenbankschnittstellen für MySQL. </p><br><p>  Hier finden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollständige Referenz zur Korzh.DbUtils-Bibliotheks-API</a> . </p><br><h2 id="ispolzovanie-korzhdbutils-dlya-zapolnenie-bd-dannymi-pri-starte-prilozheniya">  Verwenden von Korzh.DbUtils zum Auffüllen der Datenbank mit Daten beim Start der Anwendung </h2><br><p>  Nun werden wir uns überlegen, wie wir mit DbTool und Korzh.DbUtils das Basisskript zum Füllen (Seeding) der Datenbank beim ersten Start der Anwendung implementieren können. </p><br><p>  Angenommen, Sie haben eine „Masterkopie“ einer Datenbank, die Sie beim ersten Start der Anwendung auf dem Computer des Benutzers „kopieren“ müssen. </p><br><h3 id="shag-1-eksportiruem-master-kopiyu-v-json">  Schritt 1: Exportieren Sie die Masterkopie nach JSON </h3><br><p>  Installieren Sie einfach DbTool wie oben beschrieben, fügen Sie eine Verbindung zur Datenbank hinzu und führen Sie den Exportbefehl aus, um alle Daten aus dieser Datenbank in einem separaten Ordner zu speichern: </p><br><pre> <code class="plaintext hljs">dotnet tool install -g Korzh.DbTool dbtool connections add MyMasterDb mssql "{ConnectionString}" dbtool export MyMasterDb</code> </pre> <br><h3 id="shag-2-dobavlyaem-fayly-s-dannymi-v-nash-proekt">  Schritt 2: Fügen Sie unserem Projekt Datendateien hinzu </h3><br><p>  Nach dem vorherigen Schritt haben wir einen neuen Ordner in der Form MyMasterDb-yyyy-MM-dd mit einer Reihe von JSON-Dateien (eine für jede Tabelle).  Kopieren Sie einfach den Inhalt dieses Ordners in App_Data \ DbSeed unseres .NET (Core) -Projekts.  Beachten Sie, dass Sie für Projekte unter .NET Framework diese Dateien auch manuell zum Projekt hinzufügen müssen. </p><br><h3 id="shag-3-kod-inicializacii-bd">  Schritt 3: DB-Initialisierungscode </h3><br><p>  Obwohl der Prozess selbst (bis zu einigen Details) für alle Arten von Projekten unter .NET Core oder .NET Framework (Version 4.6.1 oder höher) anwendbar ist, nehmen wir zur Vereinfachung der Beschreibung an, dass es sich um ein ASP.NET Core-Projekt handelt, mit dem gearbeitet wird SQL Server-Datenbank und dass diese Datenbank automatisch mit Entity Framework Core erstellt wird. </p><br><p>  Um das Problem des Füllens der Datenbank mit Daten beim ersten Start zu lösen, benötigen wir: </p><br><h4 id="1-ustanovit-v-proekt-nuget-pakety-biblioteki-korzhdbutils">  1. Installieren Sie die Bibliothekspakete von Korzh.DbUtils im NuGet-Projekt </h4><br><p>  In diesem Fall benötigen wir zwei davon: </p><br><ul><li>  Korzh.DbUtils.Import </li><li>  Korzh.DbUtils.SqlServer </li></ul><br><h4 id="2-dobavit-kod-inicializacii">  2. Fügen Sie den Initialisierungscode hinzu </h4><br><p>  Hier ist ein Beispiel für einen solchen Code, den wir am Ende der Startup.Configure-Methode hinzufügen sollten: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app, IHostingEnvironment env</span></span></span><span class="hljs-function">)</span></span> { . . . . app.UseMvc(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = app.ApplicationServices.GetRequiredService&lt;IServiceScopeFactory&gt;().CreateScope()) <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = scope.ServiceProvider.GetService&lt;AppDbContext&gt;()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Database.EnsureCreated()) { <span class="hljs-comment"><span class="hljs-comment">//run only if database was not created previously Korzh.DbUtils.DbInitializer.Create(options =&gt; { options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")); //set the connection string for our database options.UseFileFolderPacker(System.IO.Path.Combine(env.ContentRootPath, "App_Data", "SeedData")); //set the folder where to get the seeding data }) .Seed(); } } }</span></span></code> </pre><br><p>  Um alles schön zu machen oder wenn Sie beim ersten Start eine zusätzliche Initialisierung durchführen müssen (z. B. mehrere Benutzerkonten und / oder Benutzerrollen hinzufügen), ist es besser, den gesamten Code als separate Erweiterungsmethode (nennen wir ihn <code>EnsureDbInitialized</code> ) für die Schnittstelle <code>EnsureDbInitialized</code> <code>IApplicationBuilder</code> . </p><br><p>  Ein Beispiel für eine solche Implementierung finden Sie auf GitHub im <a href="">Demo-Projekt für die EasyQuery-Bibliothek</a> . </p><br><p>  In diesem Fall müssen Sie am Ende Ihrer Startup.Configure-Methode nur einen Aufruf hinzufügen: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IApplicationBuilder,   IHostingEnvironment</span></span></span><span class="hljs-function">)</span></span> { . . . . app.UseMvc (); <span class="hljs-comment"><span class="hljs-comment">//Init database (only if necessary) app.EnsureDbInitialized(Configuration, env); }</span></span></code> </pre> <br><h2 id="plany-na-buduschee">  Zukunftspläne </h2><br><p>  Obwohl die Bibliothek und das Dienstprogramm in einem ganz bestimmten Szenario geschrieben wurden, haben wir versucht, alles so flexibel und erweiterbar wie möglich zu gestalten, sodass die Aktivierung zusätzlicher Funktionen kein Problem darstellt. </p><br><p>  Von den möglichen Verbesserungen sehen wir Folgendes: </p><br><ul><li><p>  Unterstützung für andere Datenbanken (PostgreSQL, Oracle, SQLite, MariaDB) </p><br></li><li><p>  Neue Formate, in die Sie Daten exportieren können (CSV, Excel, HTML) </p><br></li><li><p>  Der Vorgang des direkten Kopierens von Daten aus der Datenbank in die Datenbank (jetzt kann er durch mehrere aufeinanderfolgende Aufrufe zum Exportieren / Importieren von Befehlen implementiert werden). </p><br></li><li><p>  Vollständige Sicherungs- / Wiederherstellungsvorgänge unter vollständiger Beibehaltung der Datenbankstruktur und ihrer Erstellung von Grund auf während der Wiederherstellung. </p><br></li></ul><br><p>  Wir freuen uns über Anregungen oder Kommentare und sind sehr dankbar für die neuen Stars für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub Library Repository</a> :) </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466541/">https://habr.com/ru/post/de466541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466527/index.html">Testen der Benutzerfunktionalität von Websites mit Capybara-Seitenobjekten</a></li>
<li><a href="../de466529/index.html">Kompilierungstypen in der JVM: Aufdecken der Black Magic-Sitzung</a></li>
<li><a href="../de466535/index.html">DeepClone neu denken</a></li>
<li><a href="../de466537/index.html">Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 1</a></li>
<li><a href="../de466539/index.html">Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 2</a></li>
<li><a href="../de466543/index.html">Habr Weekly # 17 / Sberbank-Darlehen werden von AI genehmigt - beängstigend, Werbung in Open-Source-Produkten - zweifelhaft</a></li>
<li><a href="../de466547/index.html">Glücklicher Programmiertag</a></li>
<li><a href="../de466549/index.html">Allgemeine Funktionsprinzipien von QEMU-KVM</a></li>
<li><a href="../de466551/index.html">Puppenspieler mit ES6 in einem Knoten und Browser oder warum Zora das beste Testframework in seiner Nische ist</a></li>
<li><a href="../de466553/index.html">6 Lektionen aus der Suche nach einer Lösung für ein massives Problem bei gitlab.com. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>