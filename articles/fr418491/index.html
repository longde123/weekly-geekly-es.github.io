<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌂 🔦 🌿 Tester la résistance d'automatisation 🐞 🔫 🆖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malgré le fait que les technologies de test unitaire existent depuis 30 ans (Kent Beck a écrit l'article «Simple Smalltalk Testing: With Patterns» en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tester la résistance d'automatisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418491/"><p>  Malgré le fait que les technologies de test unitaire existent depuis 30 ans (Kent Beck a écrit l'article «Simple Smalltalk Testing: With Patterns» en 1989), tous les programmeurs ne possèdent pas cette technologie et toutes les entreprises n'ont pas intégré le test automatique dans leur culture d'entreprise. .  Malgré les avantages évidents des tests automatiques, la résistance comportementale est encore assez forte.  Quiconque a essayé de mettre en œuvre des tests automatisés sait qu'il y a toujours une raison pour laquelle cela ne pourrait pas être fait. </p><br><p>  À partir de mon expérience personnelle de mise en œuvre de méthodes de programmation fiables dans mon entreprise, dans les entreprises que j'ai consultées, communiquant lors de conférences, et également à partir de sources accessibles au public, j'ai formulé des objections et des résistances typiques qui entravent la mise en œuvre d'une culture de tests automatiques. </p><br><p>  J'ai regroupé toutes les objections dans une pyramide de programmation fiable, qui comprend quatre niveaux: <a name="habracut"></a></p><br><ul><li>  <strong>La culture professionnelle</strong> (le plus haut niveau, la base d'une programmation fiable) est un ensemble de normes, de règles non écrites, de croyances des employés qui le guident dans son travail.  Par exemple: «L'envoi de code découvert par des tests vers le référentiel est mauvais», «Faire taire les erreurs trouvées dans le code est une honte». </li><li>  <strong>La gestion</strong> est les procédures, politiques, règles adoptées par l'organisation, ainsi que la volonté (décision) des dirigeants.  Par exemple: «Chaque fonction d'application développée doit transmettre un code de révision.  Aucune exception! ” </li><li>  <strong>Les méthodes</strong> sont des approches scientifiques, des méthodes pour résoudre un problème particulier.  Par exemple: «Si la fonction de l'application est difficile à tester, vous devez augmenter la testabilité de l'application en appliquant le modèle d'Injection de dépendances.» </li><li>  <strong>Les technologies</strong> (le plus bas niveau) sont les langages de programmation, les bibliothèques, les frameworks, les outils.  Par exemple, JUnit, Selenium, XCTest et ainsi de suite. </li></ul><br><p><img src="https://habrastorage.org/webt/ky/wa/ev/kywaevzql1sl53klb8pzmazzwcm.png"></p><br><p>  Pourquoi une telle division est-elle nécessaire?  Parce que le problème d'un niveau est résolu par des méthodes du même niveau ou par des méthodes d'un niveau supérieur.  Par exemple, s'il n'est pas habituel pour une organisation d'écrire des tests automatiques (le problème de la culture professionnelle), alors ce problème ne peut pas être résolu en décrivant le processus métier de test en détail (niveau «gestion») ou en installant un cadre moderne (niveau «technologie»).  Je donne la garantie que dans une semaine, personne ne passera de tests, malgré le processus opérationnel approuvé. </p><br><h2 id="vozrazheniya-kulturnogo-urovnya">  Objections culturelles </h2><br><h3 id="moi-programmy-ne-lomayutsya-ya-ne-vizhu-nuzhdy-v-testirovanii">  «Mes programmes ne se cassent pas.  Je ne vois pas la nécessité de faire des tests. " </h3><br><p>  J'ai entendu cette déclaration de débutants ou de programmeurs trop confiants. <br>  Bien sûr, une fois qu'une fonction écrite ne peut pas se casser d'elle-même.  Mais ici, il est important de comprendre qu'au fil du temps, le programme peut nécessiter un support, l'introduction de nouvelles fonctions ou des ajouts aux fonctions existantes.  La complexité des programmes - le nombre de classes et les dépendances entre elles - est assez grande, et finalement, après avoir créé une nouvelle fonction ou amélioré une fonction existante, une erreur se produira tôt ou tard.  Un test automatique permettrait de détecter une telle régression. </p><br><p>  En outre, une telle objection peut souvent être entendue par des programmeurs novices qui n'ont aucun concept de test.  Par exemple, seuls les plantages sont considérés comme une panne, pas des erreurs fonctionnelles. </p><br><p>  Lors d'une des entrevues que j'ai menées, le dialogue suivant a eu lieu: </p><br><p>  - Avez-vous les compétences des tests automatiques? <br>  - Non, j'ai écrit des programmes simples, il n'y avait rien à casser. <br>  - Quelle est votre motivation pour changer d'emploi? <br>  - Je veux écrire des applications complexes. </p><br><p>  Je sais très bien comment cela se termine.  Le programmeur est réputé pour développer un programme plus complexe, mais il ne connaît pas les méthodes de test automatique, il ne peut pas tester l'application de manière qualitative et il ne peut pas faire face à l'échelle du projet, ce qui entraînera une interruption du projet, un dépassement de coût du développement et une perte de réputation.  Parce que j'ai personnellement géré des projets, où je ne pouvais pas faire face à l'échelle du projet et je l'ai échoué précisément en raison du manque de tests automatiques. </p><br><h3 id="nezhelanie-brat-otvetstvennost-za-kachestvo-koda-za-testirovanie">  Réticence à prendre la responsabilité de la qualité du code, des tests. </h3><br><p>  Les tests automatisés sont la seule source d'informations opérationnelles et objectives sur la véritable qualité d'un produit logiciel.  En d'autres termes, le programmeur a toujours un superviseur derrière le dos, qui peut rendre compte à tout moment à la direction de la façon dont le programmeur fait son travail.  Les tests automatisés vous permettent de lier la productivité du travail non pas avec des tickets fermés dans la Jira, mais avec la vraie qualité du produit logiciel.  Et ici, vous devez déjà réfléchir à la façon d'écrire de manière fiable afin que chaque prochaine modification du code ne casse pas les fonctions existantes.  Pour que chaque nouvelle fonction fonctionne non seulement dans le script, quand tout va bien, mais traite également correctement les erreurs. </p><br><p>  La responsabilité est l'engagement volontaire d'assurer un résultat positif du travail.  L'employé accepte cette obligation en raison de son caractère et de sa formation.  Malheureusement, en raison de la crise culturelle et professionnelle, tous les programmeurs ne sont pas prêts à assumer de telles obligations. </p><br><h3 id="pishite-srazu-pravilno-bez-oshibok">  "Écrivez maintenant sans erreurs" </h3><br><p>  Les personnes qui ne connaissent pas très bien le fonctionnement du développement logiciel peuvent avoir une attitude négative envers les développeurs qui mentionnent une sorte d'erreurs. </p><br><p>  - Couvrons l'application avec des tests automatiques. <br>  - Pourquoi? <br>  - Pour vous assurer que tout fonctionne correctement et qu'il n'y a pas d'erreurs. <br>  - Ecrivez-vous avec des erreurs?  Avez-vous de faibles qualifications?  Écrivez tout de suite sans erreurs. <br>  "Oui, mais tout le monde fait des erreurs ..." <br>  - Mais la société XYZ a dit à un ami qu'ils ont des programmeurs de haut niveau qui écrivent sans erreur! </p><br><p>  Ainsi, le développement de tests est difficile à «vendre» à des clients qui ne sont pas techniquement avertis.  En conséquence, la direction est obligée de développer un projet sans tests automatiques, ce qui conduit à des problèmes bien connus. </p><br><h2 id="vozrazheniya-na-urovne-menedzhmenta">  Objections de gestion </h2><br><h3 id="c-testami-programmu-pisat-v-dva-raza-dolshe-my-ne-ulozhimsya-v-sroki">  «Avec les tests, écrire un programme est deux fois plus long.  Nous ne respecterons pas les délais. » </h3><br><p>  À première vue, cette thèse semble juste.  Il est vraiment nécessaire de passer du temps à programmer des tests.  Mais les programmeurs et la direction ne tiennent pas compte du fait que le temps total de développement du produit comprend non seulement la programmation, mais le débogage et le support, ainsi que le coût énorme des tests de régression manuelle après avoir effectué des corrections. </p><br><p>  Les tests automatisés ont plusieurs fonctions: </p><br><ol><li>  <strong>Vérification</strong> . <br>  1.1.  Les tests vérifient que l'objet de test fonctionne correctement. <br>  1.2.  Les tests vérifient la qualité du travail du programmeur: si la tâche est résolue, s'il y a des effets secondaires sous forme de régressions. </li><li>  <strong>Diagnostic</strong> .  Les tests de diagnostic peuvent réduire considérablement le temps de recherche d'un défaut.  Les tests vous permettent de déterminer l'emplacement de l'erreur, précis pour la classe et la méthode, et parfois précis pour la ligne de code. </li><li>  <strong>Automatiser</strong> .  Les tests vous permettent d'entrer rapidement et facilement l'objet de test dans l'état souhaité pour le débogage. </li><li>  <strong>Documenter</strong> . <br>  4.1.  Les tests d'acceptation enregistrent les exigences du client pour le produit en cours de développement. <br>  4.2.  Les tests montrent des exemples d'utilisation du composant développé, réduisant ainsi le temps passé à étudier le travail du système par un autre programmeur. </li></ol><br><p>  Dans l'une des organisations que j'ai consultées, le responsable a résisté à l'introduction d'une culture de tests automatiques: </p><br><p>  - Mais après tout, écrire des tests depuis longtemps!  Nous ne respecterons pas les délais! <br>  - Avez-vous des erreurs que vous recherchez et corrigez depuis très longtemps? <br>  - Oui, il y en a. <br>  - Quel est le cas le plus difficile? <br>  - Nous avons recherché une erreur pendant 80 heures. <br>  - 80 heures, c'est deux semaines de travail du programmeur.  Si vous passiez même une semaine entière à tester l'automatisation, cela vous ferait gagner des mois pour diagnostiquer et déboguer votre application! </p><br><p>  Notre organisation a le postulat: «Avec les tests, écrire un programme est deux fois plus rapide!»  et ce postulat n'est pas discuté.  Seul le coefficient 2 est discuté - parfois il y a 3 et 4. Et certains projets ne peuvent tout simplement pas être achevés sans tests automatiques compétents (voir le projet débordé). </p><br><h3 id="u-nas-uzhe-est-otdel-ruchnogo-testirovaniya-pust-oni-i-testiruyut">  "Nous avons déjà un département de tests manuels, laissez-les tester." </h3><br><p>  À première vue, la séparation des spécialisations entre tests et programmation semble logique. </p><br><p>  Mais regardons les inconvénients des tests manuels: </p><br><ul><li>  C'est très cher. </li><li>  Cela prend très longtemps.  Par exemple: le script de test pour le testeur d'application mobile «Cinéma en ligne» fait 40 heures.  Et ce n'est que pour une seule plateforme!  Si vous devez tester l'application sur iPhone, iPad, Apple TV, Android, Fire TV, vous devez passer 40 × 6 = 240 heures de temps de travail, c'est un mois et demi, ce qui est inacceptable pour de courts cycles de développement. </li><li>  Les tests manuels sont sujets à des erreurs humaines courantes - ils ne donnent pas un résultat objectif et vrai. </li></ul><br><p>  De plus, certains types de tests ne peuvent pas être effectués dans un délai raisonnable, car le nombre de combinaisons de formats et de divers scripts de test est très important.  Par exemple: </p><br><ol><li>  Fonction permettant d'importer des fichiers CSV. </li><li>  Analyseurs pour les documents texte. </li><li>  Instruments financiers. </li></ol><br><h2 id="vozrazheniya-na-urovne-metodov">  Objections au niveau de la méthode </h2><br><h3 id="neznanie-metodov-avtomaticheskogo-testirovaniya">  Ignorance des méthodes de test automatique. </h3><br><p>  En raison de la crise de l'éducation, il n'y a pas de disciplines de tests automatiques dans les universités.  Il existe très peu de cours de ce type dans les écoles informatiques commerciales.  Et les cours existants sont superficiels et de mauvaise qualité.  Par conséquent, j'ai souvent rencontré une stupeur chez les programmeurs: ils ne savent pas comment tester des applications non triviales (plus difficile que 2 + 2 = 4). </p><br><p>  En fait, la science des tests est assez vaste.  Par exemple, tous les programmeurs ne répondront pas immédiatement aux questions: a) qu'est-ce que la testabilité?  b) qu'est-ce que la contrôlabilité et l'observabilité?  c) quels modèles de conception améliorent la testabilité de l'application?  Et ainsi de suite. </p><br><h3 id="programmisty-ne-znayut-chto-oni-pishut-kak-ono-vyglyadit-kakie-budut-funkcii-i-interfeysy">  Les programmeurs ne savent pas ce qu'ils écrivent, à quoi cela ressemble, quelles seront les fonctions et les interfaces. </h3><br><p>  Il est très difficile de tester ce qui n'est pas clair à première vue.  En d'autres termes, sans les exigences prédéfinies de l'application, le programmeur ne peut pas comprendre ce qu'on attend de lui. </p><br><p>  La particularité de certains projets est qu'ils sont développés à l'aide de la technologie de produit minimum viable, qui en d'autres termes peut être décrite comme suit: "Faisons au moins quelque chose pour le temps minimum et le budget minimum", et le programmeur est considéré par le client ou la direction comme un analyste, concepteur, architecte, programmeur et testeur dans une bouteille.  Avec cette approche, l'étape formelle de conception d'un système logiciel est exclue: la définition de la logique métier, du domaine, des interfaces des composants, ainsi que leur organisation interne de leur relation entre eux.  Il n'y a pas d'architecture formalisée, pas d'interfaces, pas de processus métier prescrits - on ne sait pas quoi tester, à travers quelles interfaces et quel est le résultat attendu. </p><br><h3 id="netestoprigodnyy-kod">  Code inapproprié. </h3><br><p>  La testabilité est une propriété de projet qui indique avec quelle facilité elle peut être testée.  L'aptitude au test est déterminée par deux autres propriétés: la contrôlabilité et l'observabilité.  Gérabilité - une propriété qui détermine la facilité avec laquelle il est possible d'entrer une application dans l'état souhaité pour les tests (remplir les conditions préalables).  Observabilité - avec quelle facilité il est possible de considérer l'état après le test, de le comparer avec celui attendu. </p><br><p>  Par exemple, l'authentification à deux facteurs à l'aide de SMS est très difficile à tester automatiquement, car la fonction de réception de SMS est en dehors de la portée de l'environnement de test automatisé.  Un tel système ne convient pas. </p><br><p>  Face à un système inadapté, le programmeur abandonne et évite de tester un tel système. </p><br><h3 id="podgotovka-testovyh-dannyh">  Préparation des données de test. </h3><br><p>  L'une des résistances non évidentes est la préparation des données de test et des normes.  Par exemple: l'état initial de la base de données sur laquelle les tests sont effectués.  La préparation des données de test peut prendre beaucoup de temps et de travail de routine, donc ce travail est considéré comme ingrat et sans intérêt parmi les programmeurs. </p><br><p>  Solution: </p><br><ul><li>  développement de valeurs de référence et d'exemples au stade de l'élaboration des tests d'acceptation - ils aideront également à résoudre les conflits avec le client au stade de l'acceptation du travail; </li><li>  élaboration de valeurs de référence au stade de la conception du système.  Par exemple, les requêtes et réponses HTTP standard - faciliteront l'intégration du client et du serveur; </li><li>  développement de procédures spéciales d'assemblage de bases de données, dans lesquelles l'état requis de la base de données est créé automatiquement et non manuellement </li><li>  utilisation du modèle Object Mother [Fowler, Schuh, Peter et Stephanie Punke.  "Faciliter la création d'objets de test sous XP."  XP Universe.  2003], ce qui permet d'allouer et d'initialiser facilement des objets dans l'état requis. </li></ul><br><h3 id="obsluzhivanie-testov">  Service de test. </h3><br><p>  Au cours de l'élaboration d'un projet, les exigences de celui-ci (clarification, changement) peuvent changer.  Ou une refactorisation interne peut se produire, ce qui entraînera un changement dans les interfaces de classe.  Avec le changement des exigences, les critères d'acceptation d'une fonction particulière changeront également, et avec eux les tests.  À un moment donné, le programmeur peut refuser de réparer les tests, c'est-à-dire de les maintenir à jour. </p><br><p>  Solution: </p><br><ul><li>  utiliser le modèle «adaptateur» afin de découpler la logique du test de l'interface qu'il teste; </li><li>  utilisation de tests de haut niveau (cornichons, concombres, donnés à la demande); </li><li>  voir la solution à la résistance «préparation des données de test». </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Il ne fait aucun doute que les logiciels doivent être fiables: dépasser les attentes des clients.  Les tests automatisés ne sont pas le seul, mais un élément important dans le développement de logiciels fiables. </p><br><p>  J'ai formulé des objections et des obstacles typiques à la mise en œuvre des tests automatiques, que j'ai personnellement rencontrés dans mon organisation, ainsi que dans les organisations que j'ai consultées. </p><br><p>  L'article ne décrit que les problèmes et aborde à peine les moyens de les résoudre.  En général, la stratégie pour résoudre ces problèmes me semble être la suivante: </p><br><ol><li>  Formation et promotion d'une nouvelle culture de la conception informatique, qui est la fiabilité, la fierté et la responsabilité personnelle du résultat. </li><li>  Développer de nouvelles normes élevées pour les tests de code. </li><li>  Développement et mise en place de formations. </li><li>  L'introduction de la motivation dans la carrière des programmeurs et managers, liée à la qualité des produits logiciels en cours de développement, ainsi qu'aux compétences des tests automatiques. </li></ol><br><p>  La chose la plus importante que j'ai réussi à comprendre est que les problèmes se situent à différents niveaux: technologique, méthodologique, managérial et culturel.  Et ils doivent être traités aux niveaux appropriés.  Il est très difficile de mettre en œuvre des tests automatisés si le programmeur n'est pas formé aux méthodes de conception adaptées aux tests ou si la direction ne prend pas en charge une culture de programmation fiable dans l'organisation. </p><br><p>  Je serai reconnaissant pour des exemples tirés de votre pratique de la facilité ou de la difficulté à mettre en œuvre des tests automatisés dans votre organisation.  Quels problèmes avez-vous rencontrés?  Comment les avez-vous résolus? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418491/">https://habr.com/ru/post/fr418491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418481/index.html">La vie en Israël - quelques moments liés à l'informatique</a></li>
<li><a href="../fr418483/index.html">Comment compresser le chargeur de démarrage pour STM8 à une taille de 8 octets dans la mémoire FLASH</a></li>
<li><a href="../fr418485/index.html">Breaking Bad 3 - Traversez le sombre forestier</a></li>
<li><a href="../fr418487/index.html">À propos du travail en Allemagne</a></li>
<li><a href="../fr418489/index.html">Chefs-d'œuvre de la construction de colonnes dans le monde: évolution d'un standard à trois voies, culte studio de JBL</a></li>
<li><a href="../fr418493/index.html">Bluetooth Histoire à la première personne</a></li>
<li><a href="../fr418497/index.html">«Je ne te reconnais pas dans le maquillage» (c)</a></li>
<li><a href="../fr418499/index.html">Expérience de mise à niveau classique SAMBA sur Debian 8</a></li>
<li><a href="../fr418501/index.html">Victimes du RGPD: qui ont déjà arrêté de travailler en raison de la nouvelle réglementation des données personnelles</a></li>
<li><a href="../fr418503/index.html">Après 2020, le Royaume-Uni acquerra le premier port spatial - en Écosse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>