<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌏 ⬆️ 🕚 Mencari tempat parkir gratis dengan Python 🏹 ❄️ 💄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya tinggal di kota yang baik. Tetapi, seperti di banyak tempat lainnya, pencarian tempat parkir selalu berubah menjadi ujian. Ruang kosong dengan ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencari tempat parkir gratis dengan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451164/"><img src="https://habrastorage.org/webt/vz/x5/od/vzx5odyqel0ow-z2qolfdo1htd4.gif" alt="gambar"><br><br>  Saya tinggal di kota yang baik.  Tetapi, seperti di banyak tempat lainnya, pencarian tempat parkir selalu berubah menjadi ujian.  Ruang kosong dengan cepat ditempati, dan bahkan jika Anda memiliki sendiri, akan sulit bagi teman untuk memanggil Anda, karena mereka tidak punya tempat parkir. <br><br>  Jadi saya memutuskan untuk mengarahkan kamera ke luar jendela dan menggunakan pembelajaran mendalam sehingga komputer saya memberi tahu saya ketika ruang tersedia: <br><br><img src="https://habrastorage.org/webt/lx/md/gy/lxmdgyxkvnwtwc5nsqccy83mp34.gif" alt="gambar"><br><br>  Ini mungkin terdengar rumit, tetapi sebenarnya menulis prototipe yang berfungsi dengan pembelajaran mendalam adalah cepat dan mudah.  Semua komponen yang diperlukan sudah ada di sana - Anda hanya perlu tahu di mana menemukannya dan bagaimana menyatukannya. <br><br>  Jadi mari bersenang-senang dan menulis sistem pemberitahuan parkir gratis akurat menggunakan Python dan pembelajaran mendalam <a name="habracut"></a><br><br><h3>  Mengurai tugas </h3><br>  Ketika kita memiliki tugas yang sulit yang ingin kita selesaikan menggunakan pembelajaran mesin, langkah pertama adalah memecahnya menjadi urutan tugas sederhana.  Kemudian kita dapat menggunakan berbagai alat untuk menyelesaikannya.  Dengan menggabungkan beberapa solusi sederhana bersama, kami mendapatkan sistem yang mampu melakukan sesuatu yang kompleks. <br><br>  Inilah cara saya melanggar tugas saya: <br><br><img src="https://habrastorage.org/webt/q7/gi/hi/q7gihifth7-k9mad7fhgbj4itcc.jpeg" alt="gambar"><br><br>  Aliran video dari webcam yang diarahkan ke jendela memasuki input konveyor: <br><br><img src="https://habrastorage.org/webt/aa/wk/ig/aawkigsexhbk5s4slqmvksvofcm.gif" alt="gambar"><br><br>  Melalui pipa, kami akan mengirimkan setiap frame video, satu per satu. <br><br>  Langkah pertama adalah mengenali semua ruang parkir yang mungkin ada dalam bingkai.  Jelas, sebelum kita dapat mencari tempat yang tidak dihuni, kita perlu memahami di bagian mana dari gambar yang ada parkir. <br><br>  Kemudian pada setiap bingkai Anda perlu menemukan semua mobil.  Ini akan memungkinkan kami melacak pergerakan setiap mesin dari bingkai ke bingkai. <br><br>  Langkah ketiga adalah menentukan tempat mana yang ditempati oleh mesin dan mana yang tidak.  Untuk melakukan ini, gabungkan hasil dari dua langkah pertama. <br><br>  Akhirnya, program harus mengirimkan peringatan ketika tempat parkir menjadi gratis.  Ini akan ditentukan oleh perubahan lokasi mesin antara bingkai video. <br><br>  Setiap langkah ini dapat diselesaikan dengan cara yang berbeda menggunakan teknologi yang berbeda.  Tidak ada satu cara yang benar atau salah untuk menyusun konveyor ini, pendekatan yang berbeda akan memiliki kelebihan dan kekurangan.  Mari kita bahas setiap langkah lebih terinci. <br><br><h3>  Kami mengenali ruang parkir </h3><br>  Inilah yang dilihat kamera kami: <br><br><img src="https://habrastorage.org/webt/2u/zl/xt/2uzlxtgxbn6jvfkhfy0e523ow88.png" alt="gambar"><br><br>  Kita perlu memindai gambar ini dan mendapatkan daftar tempat parkir: <br><br><img src="https://habrastorage.org/webt/m-/bq/xb/m-bqxb9ybcjc44blvsuzhnw6xyk.png" alt="gambar"><br><br>  Solusi "di dahi" adalah dengan hanya meng-hardcode lokasi semua ruang parkir secara manual alih-alih mengenalinya secara otomatis.  Tetapi dalam kasus ini, jika kita memindahkan kamera atau ingin mencari tempat parkir di jalan lain, kita harus melakukan seluruh prosedur lagi.  Kedengarannya begitu-begitu, jadi mari kita mencari cara otomatis untuk mengenali ruang parkir. <br><br>  Atau, Anda dapat mencari meteran parkir di gambar dan menganggap bahwa ada tempat parkir di sebelah masing-masing: <br><br><img src="https://habrastorage.org/webt/qi/g8/cj/qig8cjwmp7dmduejcddjk6tnoiw.png" alt="gambar"><br><br>  Namun, dengan pendekatan ini, tidak semuanya lancar.  Pertama, tidak setiap tempat parkir memiliki meteran parkir, dan memang, kami lebih tertarik menemukan tempat parkir yang tidak perlu Anda bayar.  Kedua, lokasi meteran parkir tidak memberi tahu kita apa pun tentang di mana tempat parkir, tetapi hanya memungkinkan kita untuk membuat asumsi. <br><br>  Gagasan lain adalah membuat model pengenalan objek yang mencari tanda tempat parkir yang tergambar di jalan: <br><br><img src="https://habrastorage.org/webt/bo/vv/nu/bovvnu6rsl-zimlr1gtpp1a_egm.png" alt="gambar"><br><br>  Tapi pendekatan ini biasa saja.  Pertama, di kota saya semua tanda seperti itu sangat kecil dan sulit dilihat dari jauh, sehingga akan sulit untuk mendeteksi mereka menggunakan komputer.  Kedua, jalanan penuh dengan segala macam garis dan tanda lainnya.  Akan sulit untuk memisahkan tanda parkir dari pembatas jalur dan penyeberangan pejalan kaki. <br><br>  Ketika Anda menghadapi masalah yang pada pandangan pertama tampaknya sulit, luangkan beberapa menit untuk menemukan pendekatan lain untuk memecahkan masalah, yang akan membantu untuk menghindari beberapa masalah teknis.  Apa ada tempat parkir?  Ini hanya tempat di mana mobil diparkir untuk waktu yang lama.  Mungkin kita tidak perlu mengenali ruang parkir sama sekali.  Mengapa kita tidak mengenali saja mobil yang berdiri diam untuk waktu yang lama dan tidak menganggap mereka berdiri di tempat parkir? <br><br>  Dengan kata lain, tempat parkir terletak di mana mobil berdiri untuk waktu yang lama: <br><br><img src="https://habrastorage.org/webt/b8/tb/ua/b8tbuafyf4uci3jy61jnjlwanqa.png" alt="gambar"><br><br>  Jadi, jika kita bisa mengenali mobil-mobil dan mencari tahu mana yang tidak bergerak di antara frame, kita bisa menebak di mana tempat parkir.  Sesederhana itu - buka pengenalan mesin! <br><br><h3>  Kenali mobil </h3><br>  Mengenali mobil pada bingkai video adalah tugas pengenalan objek klasik.  Ada banyak pendekatan pembelajaran mesin yang bisa kita gunakan untuk pengakuan.  Berikut adalah beberapa dari mereka dalam urutan dari "sekolah lama" ke "sekolah baru": <br><br><ul><li>  Anda dapat melatih detektor berdasarkan HOG (Histogram of Oriented Gradients, histogram gradien arah) dan berjalan melalui seluruh gambar untuk menemukan semua mobil.  Pendekatan lama ini, yang tidak menggunakan pembelajaran mendalam, bekerja relatif cepat, tetapi tidak mengatasi dengan baik mesin yang terletak dengan cara yang berbeda. </li><li>  Anda dapat melatih detektor berbasis CNN (Convolutional Neural Network, jaringan saraf convolutional) dan berjalan melalui seluruh gambar sampai Anda menemukan semua mobil.  Pendekatan ini bekerja dengan tepat, tetapi tidak seefisien itu, karena kita perlu memindai gambar beberapa kali menggunakan CNN untuk menemukan semua mesin.  Dan meskipun kami dapat menemukan mesin yang terletak dengan cara yang berbeda, kami membutuhkan lebih banyak data pelatihan daripada detektor HOG. </li><li>  Anda dapat menggunakan pendekatan baru dengan pembelajaran mendalam seperti Mask R-CNN, Faster R-CNN atau YOLO, yang menggabungkan akurasi CNN dan serangkaian trik teknis yang sangat meningkatkan kecepatan pengakuan.  Model seperti itu akan bekerja relatif cepat (pada GPU) jika kita memiliki banyak data untuk melatih model. </li></ul><br>  Dalam kasus umum, kita membutuhkan solusi paling sederhana, yang akan berfungsi sebagaimana mestinya dan membutuhkan paling sedikit data pelatihan.  Ini tidak diperlukan untuk menjadi algoritma terbaru dan tercepat.  Namun, khusus dalam kasus kami, Mask R-CNN adalah pilihan yang masuk akal, meskipun faktanya cukup baru dan cepat. <br><br>  Arsitektur Mask R-CNN dirancang sedemikian rupa sehingga mengenali objek di seluruh gambar, secara efektif menghabiskan sumber daya, dan tidak menggunakan pendekatan jendela geser.  Dengan kata lain, ini bekerja sangat cepat.  Dengan GPU modern, kita akan dapat mengenali objek dalam video dalam resolusi tinggi dengan kecepatan beberapa frame per detik.  Untuk proyek kami ini sudah cukup. <br><br>  Selain itu, Mask R-CNN menyediakan banyak informasi tentang setiap objek yang dikenali.  Sebagian besar algoritma pengenalan hanya mengembalikan kotak pembatas untuk setiap objek.  Namun, Mask R-CNN tidak hanya akan memberi kami lokasi setiap objek, tetapi juga garis besarnya (mask): <br><br><img src="https://habrastorage.org/webt/n2/b0/hp/n2b0hpwgwpkn6ahfhqetvbhq1rg.png" alt="gambar"><br><br>  Untuk melatih Mask R-CNN, kita membutuhkan banyak gambar objek yang ingin kita kenali.  Kita bisa pergi keluar, mengambil gambar mobil dan menandainya dalam foto, yang akan membutuhkan beberapa hari kerja.  Untungnya, mobil adalah salah satu objek yang sering ingin dikenali, sehingga beberapa set data publik dengan gambar mobil sudah ada. <br><br>  Salah satunya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dataset</a> SOCO yang populer (kependekan dari Common Objects In Context), yang memiliki gambar beranotasi dengan topeng objek.  Dataset ini berisi lebih dari 12.000 gambar dengan mesin yang telah dilabeli.  Berikut adalah contoh gambar dari dataset: <br><br><img src="https://habrastorage.org/webt/dv/lz/7l/dvlz7ltgwmudog9-b2f6i7tlmhe.jpeg" alt="gambar"><br><br>  Data tersebut sangat baik untuk melatih model berdasarkan Mask R-CNN. <br><br>  Tapi pegang kudanya, ada berita yang lebih baik lagi!  Kami bukan yang pertama yang ingin melatih model mereka menggunakan dataset COCO - banyak orang telah melakukan ini sebelum kami dan membagikan hasilnya.  Karena itu, alih-alih melatih model kita, kita dapat mengambil yang sudah jadi yang sudah bisa mengenali mobil.  Untuk proyek kami, kami akan menggunakan model <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open-source dari Matterport.</a> <br><br>  Jika kita memberikan gambar dari kamera ke input model ini, inilah yang sudah kita dapatkan “out of the box”: <br><br><img src="https://habrastorage.org/webt/vy/kq/50/vykq50pcxhyt_vkmfzmxk_fgl5g.png" alt="gambar"><br><br>  Model ini tidak hanya mengenali mobil, tetapi juga benda-benda seperti lampu lalu lintas dan manusia.  Lucu dia mengenali pohon itu sebagai tanaman hias. <br><br>  Untuk setiap objek yang dikenali, model Mask R-CNN mengembalikan 4 hal: <br><br><ul><li>  Jenis objek yang terdeteksi (integer).  Model COCO yang sudah dilatih sebelumnya dapat mengenali 80 objek umum yang berbeda seperti mobil dan truk.  Daftar lengkapnya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </li><li>  Tingkat kepercayaan pada hasil pengakuan.  Semakin tinggi angkanya, semakin kuat model percaya diri dalam pengenalan objek. </li><li>  Kotak pembatas untuk objek dalam bentuk koordinat XY piksel dalam gambar. </li><li>  "Mask" yang menunjukkan piksel mana dalam kotak pembatas adalah bagian dari objek.  Menggunakan data mask, Anda dapat menemukan garis besar objek. </li></ul><br>  Di bawah ini adalah kode Python untuk mendeteksi kotak pembatas untuk mesin yang menggunakan model Mask R-CNN dan OpenCV yang sudah dilatih sebelumnya: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mrcnn.config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mrcnn.utils <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mrcnn.model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MaskRCNN <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-comment"><span class="hljs-comment"># ,     Mask-RCNN. class MaskRCNNConfig(mrcnn.config.Config): NAME = "coco_pretrained_model_config" IMAGES_PER_GPU = 1 GPU_COUNT = 1 NUM_CLASSES = 1 + 80 #   COCO  80  + 1  . DETECTION_MIN_CONFIDENCE = 0.6 #    ,    . def get_car_boxes(boxes, class_ids): car_boxes = [] for i, box in enumerate(boxes): #     ,   . if class_ids[i] in [3, 8, 6]: car_boxes.append(box) return np.array(car_boxes) #   . ROOT_DIR = Path(".") #       . MODEL_DIR = ROOT_DIR / "logs" #       . COCO_MODEL_PATH = ROOT_DIR / "mask_rcnn_coco.h5" #   COCO  . if not COCO_MODEL_PATH.exists(): mrcnn.utils.download_trained_weights(COCO_MODEL_PATH) #     . IMAGE_DIR = ROOT_DIR / "images" #      —   0,    ,   . VIDEO_SOURCE = "test_images/parking.mp4" #   Mask-RCNN   . model = MaskRCNN(mode="inference", model_dir=MODEL_DIR, config=MaskRCNNConfig()) #   . model.load_weights(COCO_MODEL_PATH, by_name=True) #   . parked_car_boxes = None #  ,     . video_capture = cv2.VideoCapture(VIDEO_SOURCE) #      . while video_capture.isOpened(): success, frame = video_capture.read() if not success: break #      BGR ( OpenCV)  RGB. rgb_image = frame[:, :, ::-1] #    Mask R-CNN   . results = model.detect([rgb_image], verbose=0) # Mask R-CNN ,       . #     ,     . r = results[0] #  r    : # - r['rois'] —      ; # - r['class_ids'] —  () ; # - r['scores'] —  ; # - r['masks'] —   (    ). #      . car_boxes = get_car_boxes(r['rois'], r['class_ids']) print("Cars found in frame of video:") #     . for box in car_boxes: print("Car:", box) y1, x1, y2, x2 = box #  . cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 1) #    . cv2.imshow('Video', frame) #  'q',  . if cv2.waitKey(1) &amp; 0xFF == ord('q'): break #    . video_capture.release() cv2.destroyAllWindows()</span></span></code> </pre> <br>  Setelah menjalankan skrip ini, gambar dengan bingkai di sekitar setiap mesin yang terdeteksi akan muncul di layar: <br><br><img src="https://habrastorage.org/webt/_p/il/0r/_pil0reoz3gj7dtqboav_rgerl8.jpeg" alt="gambar"><br><br>  Juga, koordinat masing-masing mesin akan ditampilkan di konsol: <br><br><pre> <code class="python hljs">Cars found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> frame of video: Car: [<span class="hljs-number"><span class="hljs-number">492</span></span> <span class="hljs-number"><span class="hljs-number">871</span></span> <span class="hljs-number"><span class="hljs-number">551</span></span> <span class="hljs-number"><span class="hljs-number">961</span></span>] Car: [<span class="hljs-number"><span class="hljs-number">450</span></span> <span class="hljs-number"><span class="hljs-number">819</span></span> <span class="hljs-number"><span class="hljs-number">509</span></span> <span class="hljs-number"><span class="hljs-number">913</span></span>] Car: [<span class="hljs-number"><span class="hljs-number">411</span></span> <span class="hljs-number"><span class="hljs-number">774</span></span> <span class="hljs-number"><span class="hljs-number">470</span></span> <span class="hljs-number"><span class="hljs-number">856</span></span>]</code> </pre><br>  Jadi kami belajar mengenali mobil dalam gambar. <br><br><h3>  Kami mengenali ruang parkir kosong </h3><br>  Kami tahu koordinat piksel dari setiap mesin.  Melihat melalui beberapa frame berturut-turut, kita dapat dengan mudah menentukan mobil mana yang tidak bergerak, dan berasumsi bahwa ada ruang parkir.  Tetapi bagaimana memahami bahwa mobil meninggalkan tempat parkir? <br><br>  Masalahnya adalah bahwa kerangka mesin sebagian tumpang tindih satu sama lain: <br><br><img src="https://habrastorage.org/webt/7t/vi/4q/7tvi4q1rgvkfkaljrsp8sjathr0.jpeg" alt="gambar"><br><br>  Oleh karena itu, jika Anda membayangkan bahwa setiap frame mewakili ruang parkir, mungkin ternyata sebagian ditempati oleh mesin, padahal sebenarnya kosong.  Kita perlu menemukan cara untuk mengukur tingkat persimpangan dua objek untuk mencari hanya frame "paling kosong". <br><br>  Kami akan menggunakan ukuran yang disebut Intersection Over Union (rasio area persimpangan dengan total area) atau IoU.  IoU dapat ditemukan dengan menghitung jumlah piksel di mana dua objek berpotongan, dan dibagi dengan jumlah piksel yang ditempati oleh objek-objek ini: <br><br><img src="https://habrastorage.org/webt/zs/c0/sz/zsc0szsct8xjwkx5eo-6ieynfuc.png" alt="gambar"><br><br>  Jadi kita bisa mengerti bagaimana rangka mobil yang sangat melintang bersilangan dengan bingkai tempat parkir.  Ini akan memudahkan untuk menentukan apakah parkir gratis.  Jika nilai IoU rendah, seperti 0,15, maka mobil menempati sebagian kecil dari tempat parkir.  Dan jika tinggi, seperti 0,6, maka ini berarti mobil mengambil sebagian besar ruang dan Anda tidak dapat parkir di sana. <br><br>  Karena IoU cukup sering digunakan dalam visi komputer, sangat mungkin bahwa perpustakaan yang sesuai menerapkan ukuran ini.  Di pustaka kami Mask R-CNN, ini diimplementasikan sebagai fungsi mrcnn.utils.compute_overlaps (). <br><br>  Jika kami memiliki daftar kotak pembatas untuk tempat parkir, Anda dapat menambahkan tanda centang untuk keberadaan mobil dalam kerangka ini dengan menambahkan satu atau dua baris kode: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#      . car_boxes = get_car_boxes(r['rois'], r['class_ids']) # ,        . overlaps = mrcnn.utils.compute_overlaps(car_boxes, parking_areas) print(overlaps)</span></span></code> </pre><br>  Hasilnya akan terlihat seperti ini: <br><br><pre> <code class="python hljs">[ [<span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-number"><span class="hljs-number">0.07040032</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span>] [<span class="hljs-number"><span class="hljs-number">0.07040032</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-number"><span class="hljs-number">0.07673165</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span>] [<span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-number"><span class="hljs-number">0.02332112</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span>] ]</code> </pre><br>  Dalam array dua dimensi ini, setiap baris mencerminkan satu bingkai ruang parkir.  Dan setiap kolom menunjukkan seberapa kuat masing-masing tempat bersinggungan dengan salah satu mesin yang terdeteksi.  Hasil 1,0 berarti bahwa seluruh tempat benar-benar ditempati oleh mobil, dan nilai rendah seperti 0,02 menunjukkan bahwa mobil telah naik sedikit ke tempat, tetapi Anda masih dapat parkir di atasnya. <br><br>  Untuk menemukan tempat kosong, Anda hanya perlu memeriksa setiap baris dalam larik ini.  Jika semua angka mendekati nol, maka kemungkinan besar tempat itu gratis! <br><br>  Namun, perlu diingat bahwa pengenalan objek tidak selalu bekerja dengan sempurna dengan video waktu-nyata.  Meskipun model berdasarkan Mask R-CNN cukup akurat, dari waktu ke waktu mungkin kehilangan satu atau dua mobil dalam satu frame video.  Oleh karena itu, sebelum menyatakan bahwa tempat itu gratis, Anda harus memastikan bahwa tempat itu tetap demikian untuk 5-10 frame video berikutnya.  Dengan cara ini kita dapat menghindari situasi ketika sistem secara keliru menandai tempat kosong karena kesalahan dalam satu bingkai video.  Segera setelah kami memastikan bahwa tempat itu tetap gratis untuk beberapa bingkai, Anda dapat mengirim pesan! <br><br><h3>  Kirim SMS </h3><br>  Bagian terakhir dari conveyor kami adalah mengirimkan notifikasi SMS ketika tempat parkir gratis muncul. <br><br>  Mengirim pesan dari Python sangat mudah jika Anda menggunakan Twilio.  Twilio adalah API populer yang memungkinkan Anda mengirim SMS dari hampir semua bahasa pemrograman hanya dengan beberapa baris kode.  Tentu saja, jika Anda lebih suka layanan yang berbeda, maka Anda dapat menggunakannya.  Saya tidak ada hubungannya dengan Twilio, itu hanya hal pertama yang terlintas dalam pikiran. <br><br>  Untuk menggunakan Twilio, daftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akun percobaan</a> , buat nomor telepon Twilio, dan dapatkan informasi otentikasi akun Anda.  Kemudian instal pustaka klien: <br><br><pre> <code class="python hljs">$ pip3 install twilio</code> </pre><br>  Setelah itu, gunakan kode berikut untuk mengirim pesan: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> twilio.rest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Client <span class="hljs-comment"><span class="hljs-comment">#   Twilio. twilio_account_sid = ' Twilio SID' twilio_auth_token = '   Twilio' twilio_source_phone_number = '   Twilio' #    Twilio. client = Client(twilio_account_sid, twilio_auth_token) #  SMS. message = client.messages.create( body=" ", from_=twilio_source_phone_number, to=" ,   " )</span></span></code> </pre><br>  Untuk menambahkan kemampuan mengirim pesan ke skrip kami, cukup salin kode ini di sana.  Namun, Anda perlu memastikan bahwa pesan tidak dikirim pada setiap frame, di mana Anda dapat melihat ruang kosong.  Oleh karena itu, kami akan memiliki bendera yang dalam keadaan terpasang tidak akan mengizinkan pengiriman pesan untuk beberapa waktu atau hingga tempat lain dikosongkan. <br><br><h3>  Menyatukan semuanya </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mrcnn.config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mrcnn.utils <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mrcnn.model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MaskRCNN <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> twilio.rest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Client <span class="hljs-comment"><span class="hljs-comment"># ,     Mask-RCNN. class MaskRCNNConfig(mrcnn.config.Config): NAME = "coco_pretrained_model_config" IMAGES_PER_GPU = 1 GPU_COUNT = 1 NUM_CLASSES = 1 + 80 #   COCO  80  + 1  . DETECTION_MIN_CONFIDENCE = 0.6 #    ,    . def get_car_boxes(boxes, class_ids): car_boxes = [] for i, box in enumerate(boxes): #     ,   . if class_ids[i] in [3, 8, 6]: car_boxes.append(box) return np.array(car_boxes) #  Twilio. twilio_account_sid = ' Twilio SID' twilio_auth_token = '   Twilio' twilio_phone_number = '   Twilio' destination_phone_number = ',   ' client = Client(twilio_account_sid, twilio_auth_token) #   . ROOT_DIR = Path(".") #       . MODEL_DIR = ROOT_DIR / "logs" #       . COCO_MODEL_PATH = ROOT_DIR / "mask_rcnn_coco.h5" #   COCO  . if not COCO_MODEL_PATH.exists(): mrcnn.utils.download_trained_weights(COCO_MODEL_PATH) #     . IMAGE_DIR = ROOT_DIR / "images" #      —   0,   ,   . VIDEO_SOURCE = "test_images/parking.mp4" #   Mask-RCNN   . model = MaskRCNN(mode="inference", model_dir=MODEL_DIR, config=MaskRCNNConfig()) #   . model.load_weights(COCO_MODEL_PATH, by_name=True) #   . parked_car_boxes = None #  ,     . video_capture = cv2.VideoCapture(VIDEO_SOURCE) #         . free_space_frames = 0 #    SMS? sms_sent = False #      . while video_capture.isOpened(): success, frame = video_capture.read() if not success: break #      BGR  RGB. rgb_image = frame[:, :, ::-1] #    Mask R-CNN   . results = model.detect([rgb_image], verbose=0) # Mask R-CNN ,       . #     ,     . r = results[0] #  r    : # - r['rois'] —      ; # - r['class_ids'] —  () ; # - r['scores'] —  ; # - r['masks'] —   (    ). if parked_car_boxes is None: #     — ,       . #            . parked_car_boxes = get_car_boxes(r['rois'], r['class_ids']) else: #   ,  . ,   . #     . car_boxes = get_car_boxes(r['rois'], r['class_ids']) # ,         . overlaps = mrcnn.utils.compute_overlaps(parked_car_boxes, car_boxes) # ,    ,      . free_space = False #        . for parking_area, overlap_areas in zip(parked_car_boxes, overlaps): #        #    (, ). max_IoU_overlap = np.max(overlap_areas) #         . y1, x1, y2, x2 = parking_area # ,   ,   IoU. if max_IoU_overlap &lt; 0.15: #  !     . cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 3) # ,        . free_space = True else: #     —   . cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 0, 255), 1) #   IoU  . font = cv2.FONT_HERSHEY_DUPLEX cv2.putText(frame, f"{max_IoU_overlap:0.2}", (x1 + 6, y2 - 6), font, 0.3, (255, 255, 255)) #       ,   . #   ,  ,     #      . if free_space: free_space_frames += 1 else: #   ,  . free_space_frames = 0 #       ,  ,   . if free_space_frames &gt; 10: #   SPACE AVAILABLE!!  . font = cv2.FONT_HERSHEY_DUPLEX cv2.putText(frame, f"SPACE AVAILABLE!", (10, 150), font, 3.0, (0, 255, 0), 2, cv2.FILLED) #  ,     . if not sms_sent: print("SENDING SMS!!!") message = client.messages.create( body="Parking space open - go go go!", from_=twilio_phone_number, to=destination_phone_number ) sms_sent = True #    . cv2.imshow('Video', frame) #  'q',  . if cv2.waitKey(1) &amp; 0xFF == ord('q'): break #  'q',  . video_capture.release() cv2.destroyAllWindows()</span></span></code> </pre><br>  Untuk menjalankan kode itu, Anda harus menginstal Python 3.6+, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Matterport Mask R-CNN,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenCV terlebih dahulu</a> . <br><br>  Saya secara khusus menulis kode sesederhana mungkin.  Misalnya, jika dia melihat mobil di bingkai pertama, dia menyimpulkan bahwa mereka semua diparkir.  Cobalah bereksperimen dengannya dan lihat apakah Anda dapat meningkatkan keandalannya. <br><br>  Hanya dengan mengubah pengidentifikasi objek yang model cari, Anda dapat mengubah kode menjadi sesuatu yang sama sekali berbeda.  Misalnya, bayangkan Anda bekerja di resor ski.  Setelah melakukan beberapa perubahan, Anda dapat mengubah skrip ini menjadi sistem yang secara otomatis mengenali papan luncur salju dari lintasan dan merekam video dengan lompatan keren.  Atau, jika Anda bekerja di cagar alam, Anda dapat membuat sistem yang menghitung zebra.  Anda hanya dibatasi oleh imajinasi Anda. <br><br>  Lebih banyak artikel seperti itu dapat dibaca di saluran telegram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Neuron</a> (@neurondata) <br><br>  Tautan terjemahan alternatif: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tproger.ru/translations/parking-searching/</a> <br><br>  Semua pengetahuan  Eksperimen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451164/">https://habr.com/ru/post/id451164/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451152/index.html">Resistor di sirkuit gerbang atau cara melakukannya dengan benar</a></li>
<li><a href="../id451154/index.html">Sistem Akusisi Data Otonomi Daerah (lanjutan)</a></li>
<li><a href="../id451158/index.html">Sirkuit listrik. Jenis sirkuit</a></li>
<li><a href="../id451160/index.html">Apache Kafka dan Streaming dengan Spark Streaming</a></li>
<li><a href="../id451162/index.html">Koreksi Kesalahan - Konstanta Fisik di Masa Kini dan Versi Baru Sistem Satuan Internasional (SI)</a></li>
<li><a href="../id451166/index.html">Apa yang akan ditawarkan repositori baru untuk sistem AI dan MO?</a></li>
<li><a href="../id451170/index.html">Jeff Bezos mengumumkan rencana untuk menaklukkan bulan</a></li>
<li><a href="../id451172/index.html">Julia: fungsi dan struktur sebagai fungsi</a></li>
<li><a href="../id451174/index.html">Adaptasi program untuk ZX Spectrum ke TR-DOS dengan cara modern. Bagian 1</a></li>
<li><a href="../id451176/index.html">Berita dari dunia OpenStreetMap No. 458 (23/4/2019 - 04/09/2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>