<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵 👩‍💼 ⛰️ Comment Lisp est devenu un langage de programmation pour Dieu 🤽 🥀 🍼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque les programmeurs discutent des avantages de divers langages de programmation, ils en parlent souvent en termes prosaïques, comme des outils da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment Lisp est devenu un langage de programmation pour Dieu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428229/"> Lorsque les programmeurs discutent des avantages de divers langages de programmation, ils en parlent souvent en termes prosaïques, comme des outils dans un ensemble de différents appareils - l'un est plus approprié pour la programmation système, l'autre pour coller d'autres programmes pour résoudre le problème actuel.  Il devrait en être ainsi.  Les langues ont des forces différentes, et affirmer qu'une langue est meilleure que les autres langues sans spécifier d'exemples spécifiques ne signifie que provoquer des débats improductifs et vifs. <br><br>  Cependant, il existe une langue qui suscite étrangement le respect universel: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lisp</a> .  Les croisés des claviers, prêts à attaquer tous ceux qui osent déclarer que n'importe quelle langue est meilleure que les autres, conviennent que Lisp est à un niveau différent.  Cela va au-delà des critères utilitaires jugés par d'autres langages, car le programmeur moyen n'a jamais utilisé Lisp pour créer quoi que ce soit de pratique, et ne le sera probablement jamais, cependant, le respect pour Lisp est si profond qu'il est souvent crédité de propriétés mythiques.  Les bandes dessinées xkcd préférées de tous ont donc dépeint Lisp au moins deux fois: dans une bande dessinée, un personnage atteint l'illumination de Lisp, ce qui l'aide à comprendre la structure fondamentale de l'univers.  Dans un autre, un ancien programmeur en robe de chambre remet une pile de parenthèses à son padawan, expliquant qu'il s'agit «d'une arme élégante pour des temps plus civilisés», faisant allusion aux possibilités occultes de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Force</a> inhérente à Lisp. <br><a name="habracut"></a><br>  Un autre excellent exemple est la parodie de la chanson «God lives on Terra» de Bob Kanefsky.  Sa parodie a été écrite au milieu des années 90 et s'appelle "Eternal Flame".  Elle décrit comment, apparemment, Dieu a créé le monde avec l'aide de Lisp.  Ce qui suit est un extrait, et la version complète peut être trouvée sur le site Web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU Humor Collection</a> : <br><blockquote>  Après tout, Dieu a écrit en Lisp <br>  Quand il a rempli les feuilles de vert. <br>  Fleurs fractales et racines récursives: <br>  Le plus beau hack que j'ai jamais vu. <br>  Et quand j'étudie les flocons de neige <br>  Et je n'en trouve pas deux identiques <br>  Je sais que Dieu aime la langue <br>  Avec son propre nom à quatre lettres. </blockquote><br>  Je ne parle que pour moi, mais il me semble que le mème culturel «Lisp est une magie secrète» est le phénomène le plus étrange et intéressant.  Lisp a été conçu dans une tour d'ivoire comme un outil de recherche sur l'intelligence artificielle, il sera donc toujours un peu inconnu et mystérieux pour les programmeurs ordinaires.  Cependant, maintenant les programmeurs se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poussent</a> mutuellement "essayez Lisp avant de mourir", comme s'il s'agissait d'une sorte de drogue psychédélique qui élargit la conscience.  Ils le font malgré le fait que Lisp est le deuxième plus ancien des langages de programmation qu'ils utilisent encore, juste derrière <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fortran</a> , et ce n'est qu'un an.  Imaginez que la société ou l'équipe qui l'a développé vous demanderait de publier un nouveau langage de programmation.  Ne serait-ce pas cool de pouvoir convaincre tout le monde que votre nouvelle langue a des pouvoirs divins?  Mais comment y parvenir?  Comment le langage de programmation est-il devenu célèbre en tant que source de connaissances secrètes? <br><br>  Comment Lisp en est-il arrivé là? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/303/7b7/7d7/3037b77d74f9f90ecacc06b0d77f8b6e.jpg"><br>  <i>Couverture du magazine Byte, août 1979</i> <br><br><h2>  Théorie A: langage axiomatique </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">John McCarthy</a> , le créateur de Lisp, n'a pas initialement cherché à faire de Lisp l'essence élégante des principes de calcul.  Mais, après une ou deux idées réussies et plusieurs améliorations, Lisp est devenu exactement cela.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Paul Graham</a> - nous en parlerons plus tard - a écrit que, après avoir créé Lisp, McCarthy "a fait la même chose pour la programmation qu'Euclid pour la géométrie".  Peut-être que les gens recherchent un sens plus profond en Lisp, parce que McCarthy l'a créé à partir de parties si fondamentales qu'il est difficile de dire s'il l'a inventé ou découvert. <br><br>  McCarthy a commencé à réfléchir à la création de la langue lors du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet de recherche sur l'intelligence artificielle d'été de Dartmouth en 1956</a> .  Cet atelier était une conférence académique continue de plusieurs semaines, la toute première dans le domaine de l'IA.  Soit dit en passant, c'est McCarthy, alors professeur agrégé de mathématiques à Dartmoor, qui a inventé le terme «intelligence artificielle», proposant de tenir cette réunion.  La conférence a réuni une dizaine de personnes.  Parmi eux, Allen Newel et Herbert Simon, deux chercheurs associés à RAND Corporation et à l'Université Carnegie Mellon, qui venaient de terminer le développement du langage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPL</a> . <br><br>  Newel et Simon ont essayé de créer un système capable de fournir des preuves dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">logique des énoncés</a> .  Ils ont réalisé qu'il serait difficile de le faire, en restant au niveau de leurs propres instructions informatiques, alors ils ont décidé de créer un langage - ou, comme ils l'appelaient, un "pseudo-code" - qui les aiderait à exprimer plus naturellement le travail de leur "machine de logique théorique".  Leur langage, IPL, le "langage de traitement de l'information", ressemblait plus à un dialecte d'assembleur de haut niveau qu'à un langage de programmation au sens moderne.  Newel et Simon, faisant peut-être référence à Fortran, ont noté que les «autres pseudo-codes» alors en développement étaient «occupés» à représenter les équations en notation mathématique standard.  Au lieu de cela, leur langage s'est concentré sur la présentation des déclarations comme des listes d'expressions symboliques.  Les programmes IPL ont utilisé des séquences d'assemblage de macros pour traiter et évaluer des expressions dans une ou plusieurs de ces listes. <br><br>  McCarthy a pensé qu'il serait utile d'avoir des expressions algébriques dans une langue similaire à Fortran.  Par conséquent, il n'aimait pas l'IPL.  Mais il pensait que les listes symboliques sont un bon moyen de modéliser les tâches du domaine de l'IA, en particulier celles qui incluent la déduction.  C'était le germe du désir de McCarthy de créer un langage de traitement de liste algébrique, un langage qui ressemblait à Fortran, mais qui pouvait gérer des listes symboliques comme l'IPL. <br><br>  Bien sûr, aujourd'hui, Lisp ne ressemble pas à Fortran.  Au cours des prochaines années, les idées de McCarthy pour un langage de traitement de liste idéal ont évolué.  Ses idées ont commencé à changer en 1957 quand il a commencé à écrire des procédures pour le programme d'échecs de Fortran.  La longue exposition de Fortran a convaincu McCarthy qu'il y avait plusieurs points négatifs dans sa conception, le principal étant la déclaration maladroite de la FI.  McCarthy a inventé une alternative, l'expression conditionnelle "true", renvoyant la sous-expression A si la vérification donnée a réussi, et la sous-expression B dans un autre cas, et exécutant uniquement la sous-expression qui a été renvoyée.  À l'été 1958, alors que McCarthy travaillait sur un programme capable de différenciation, il s'est rendu compte que son expression conditionnelle «vraie» rendait l'écriture des fonctions récursives plus simple et plus naturelle.  Le problème de différenciation a également incité McCarthy à écrire une fonction maplist qui prend une autre fonction comme argument et l'applique à tous les éléments de la liste.  Il était utile pour différencier les sommes d'un nombre arbitraire de membres. <br><br>  Fortran ne pouvait pas exprimer de telles choses, donc à l'automne 1958 McCarthy a demandé à plusieurs étudiants la tâche d'implémenter Lisp.  Puisque McCarthy était maintenant professeur agrégé au MIT, tous les étudiants ont étudié au MIT.  En traduisant les idées en code de travail, McCarthy et les étudiants ont apporté des modifications qui ont encore simplifié la langue.  Le plus grand d'entre eux était la syntaxe Lisp.  McCarthy voulait d'abord le soi-disant  «M-expressions», une couche de « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sucre syntaxique</a> » qui faisait ressembler la syntaxe Lisp à Fortran.  Bien que les expressions M puissent être traduites en expressions S - une simple liste entre crochets pour laquelle Lisp est célèbre - les expressions S étaient vraiment une représentation de bas niveau pour un ordinateur.  Le seul problème était que McCarthy désignait les expressions M avec des crochets, et il n'y avait pas de crochets sur le poinçon IBM 026 utilisé dans le MIT.  Par conséquent, l'équipe Lisp s'est limitée aux expressions S et les a utilisées pour représenter non seulement des listes de données, mais aussi l'utilisation de fonctions.  McCarthy et les étudiants ont fait plusieurs autres simplifications, y compris le passage à l'enregistrement de préfixe et un modèle de mémoire dans lequel la langue n'avait qu'un seul type de réel. <br><br>  En 1960, McCarthy a publié le célèbre ouvrage sur Lisp "Fonctions récursives des expressions symboliques et leur calcul par la machine].  D'ici là, le langage avait été réduit à un point tel que McCarthy s'est rendu compte qu'il avait créé un «système mathématique élégant», et pas seulement un autre langage de programmation.  Il a écrit plus tard que la plupart des simplifications de Lisp en faisaient une "façon de décrire les fonctions calculées, beaucoup plus précises que les machines de Turing ou les définitions récursives générales utilisées dans la théorie des fonctions récursives".  Dans son travail, il a introduit Lisp comme langage de programmation de travail et comme formalisme pour étudier le comportement des fonctions récursives. <br><br>  McCarthy a expliqué Lisp aux lecteurs, en le construisant à partir d'un petit ensemble de règles.  Plus tard, Paul Graham a suivi les traces de McCarthy en utilisant un langage plus facile à lire dans son essai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Roots of Lisp</a> .  Graham peut expliquer Lisp avec seulement sept opérateurs primitifs, deux entrées différentes pour les fonctions et six fonctions de haut niveau définies via des opérateurs primitifs.  La capacité de définir Lisp avec une si petite séquence de règles simples ajoute certainement à son mystère.  Graham a qualifié le travail de McCarthy de "axiomatiser le calcul".  Je pense que c'est une excellente façon de réfléchir à l'attrait de Lisp.  Dans d'autres langues, il existe clairement des constructions artificielles décrites par des mots réservés tels que while, typedef ou public static void; il semble que la description Lisp soit limitée par la logique même des calculs.  Cette qualité et la connexion originale de Lisp avec un champ ésotérique tel que la «théorie des fonctions récursives» devraient expliquer le prestige actuel de la langue. <br><br><h2>  Théorie B: La machine du futur </h2><br>  Deux décennies après sa création, Lisp est devenu, selon le célèbre " <a href="">dictionnaire des informaticiens</a> ", la "langue maternelle" de la recherche en IA.  Lisp s'est rapidement répandu dans les premiers stades, probablement en raison du fait que sa syntaxe systématique a rendu la tâche de sa mise en œuvre sur de nouvelles machines relativement simple.  Plus tard, les chercheurs ont continué à l'utiliser en raison de sa bonne gestion des expressions symboliques, ce qui était important à une époque où la plupart des IA étaient symboliques.  Lisp a été utilisé dans des projets d'IA prolifiques tels que le programme de langage naturel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SHRDLU</a> , le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système</a> d'algèbre informatique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Macsyma</a> et le système logique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACL2</a> . <br><br>  Au milieu des années 1970, les chercheurs en IA ont commencé à manquer de puissance informatique.  Par exemple, le PDP-10 - la machine IA préférée de tous - avait un espace d'adressage de 18 bits, ce qui manquait de plus en plus pour les programmes d'IA à Lisp.  De nombreux programmes d'IA devaient également être interactifs, et la création d'un grand programme interactif qui fonctionne bien sur un système de partage de temps était une tâche difficile.  La solution que Peter Deutsch du MIT a d'abord proposée était de développer un ordinateur dédié pour Lisp.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ces machines</a> devraient donner à chaque utilisateur un processeur dédié optimisé pour Lisp.  Ils devaient également avoir un environnement de développement écrit en Lisp pour les programmeurs Lisp hardcore.  Les machines Lisp, inventées à un moment inconfortable à la fin de l'ère des mini-ordinateurs, mais avant l'apogée de la révolution des micro-ordinateurs, étaient des ordinateurs personnels hautes performances pour l'élite des programmeurs. <br><br>  Pendant un certain temps, il semblait que les machines Lisp seraient la vague du futur.  Plusieurs entreprises ont commencé à concurrencer pour la commercialisation de cette technologie.  Le plus réussi d'entre eux était Symbolics, créé par des vétérans du MIT AI Lab.  Dans les années 1980, Symbolics a lancé sa série d'ordinateurs 3600, populaire dans l'industrie de l'IA et dans les industries nécessitant un calcul haute puissance.  La gamme 3600 comprenait des ordinateurs avec de grands écrans, des graphiques bitmap, une interface basée sur la souris et des programmes graphiques et d'animation puissants.  Ce sont des machines impressionnantes qui ont permis d'écrire des programmes impressionnants.  Par exemple, Bob Cali, qui a travaillé dans le domaine de la recherche en robotique, m'a écrit via Twitter qu'il était capable d'implémenter et de visualiser l'algorithme de recherche de chemin sur Symbolics 3650 en 1985. Il a dit que les graphiques raster et OOP (disponibles sur les machines Lisp grâce à l'extension Flavors) étaient nouveaux dans les années 1980.  La symbolique était au premier plan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed6/24f/fd8/ed624ffd86464f9be7709ddae35ca3cf.jpg"><br><br>  Mais en conséquence, les ordinateurs Symbolics étaient incroyablement chers.  Symbolics 3600 a coûté 110 000 $ en 1983. La plupart des gens ne pouvaient qu'émerveiller devant la puissance des machines Lisp et la magie des opérateurs écrivant à distance à Lisp.  Mais ils se sont émerveillés.  Le magazine Byte a décrit plusieurs fois les machines Lisp et Lisp entre 1979 et la fin des années 1980.  Dans le numéro d'août 1979 de Lisp, le rédacteur en chef était enthousiasmé par les nouvelles machines développées au MIT, "avec une montagne de mémoire" et un "système d'exploitation avancé".  Il les considérait si prometteurs que les deux années précédentes au cours desquelles l'Apple II, le Commodore PET et le TRS-80 sont apparus ennuyeux.  Cinq ans plus tard, en 1985, l'auteur du magazine Byte a décrit le processus d'écriture des programmes Lisp pour le «Symbolics 3670 complexe et extrêmement puissant», et a encouragé les lecteurs à apprendre le Lisp, déclarant que c'était à la fois «le langage dont la plupart des chercheurs en IA ont besoin». et un candidat pour une future langue d'usage général. <br><br>  J'ai demandé à Paul MacJones, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui avait beaucoup fait</a> pour sauver Lisp au Mountain View Museum of Computer History, quand les gens ont commencé à parler de Lisp comme un cadeau de créatures de dimensions supérieures.  Il a déclaré que les caractéristiques du langage lui-même y contribuaient certainement, mais également le lien étroit entre Lisp et les puissantes applications d'IA dans les années 1960 et 1970.  Quand il est devenu possible d'acheter des machines Lisp dans les années 80, quelques personnes de plus se sont rencontrées en dehors d'endroits comme le MIT ou Stanford, et la légende a continué de grandir.  Aujourd'hui, peu de gens se souviennent des machines Lisp et de la symbolique, mais ils ont contribué à maintenir l'aura du mystère Lisp jusqu'aux années 1980. <br><br><h2>  Théorie B: formation à la programmation </h2><br>  En 1985, des professeurs du MIT, Harold Abelson et Gerald Sasman, ainsi que l'épouse de Sasman, Julia, ont publié le manuel Structure and Interpretation of Computer Programs.  Dans le manuel, les lecteurs apprenaient la programmation en langage Scheme, le dialecte Lisp.  Il a été utilisé au MIT pour une introduction à la programmation pendant deux décennies.  Il me semble que c'est un manuel, SICP, qui a ajouté du mysticisme à Lisp.  SICP a pris Lisp et a montré comment il peut être utilisé pour illustrer les concepts profonds, presque philosophiques de l'art de la programmation.  Ces concepts étaient assez communs pour utiliser n'importe quel PL, mais les auteurs du SICP ont choisi Lisp.  En conséquence, la réputation de Lisp a été complétée par la notoriété de ce livre étrange et brillant qui a intrigué de nombreuses générations de programmeurs (et est devenu un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mème très étrange</a> ).  Lisp a toujours été "l'élégant formalisme de McCarthy";  maintenant il est également devenu un langage "vous apprenant les secrets cachés de la programmation"). <br><br>  Il vaut la peine de parler un peu de l’étrangeté de ce livre - car il me semble que son étrangeté et son étrangeté Lisp ont fusionné aujourd’hui en un seul.  L'étrangeté commence sur la couverture.  Il représente un sorcier ou un alchimiste s'approchant d'une table et prêt à démarrer une sorte de sorcellerie.  Dans une main, il a un pied à coulisse ou une boussole, dans l'autre - un globe avec les inscriptions "eval" et "apply".  La femme en face de lui montre la table;  sur le fond est la lettre grecque lambda rayonnant dans l'air. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/c76/41a/dcdc7641ad77a08295763e07c85e4727.jpg"><br><br>  Que se passe-t-il ici?  Pourquoi y a-t-il une patte d'animal à table?  Pourquoi une femme pointe-t-elle la table?  Quelle est la signification de l'encrier?  Faut-il comprendre que l'assistant a révélé la connaissance secrète de l'univers, et qu'elles consistent en un cycle d'évaluation / application et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">calcul lambda</a> ?  Apparemment, ça l'est.  Seule cette image aurait dû ajouter beaucoup à la perception actuelle de Lisp. <br><br>  Mais le texte du livre lui-même s'avère souvent tout aussi étrange.  Le SICP n'est pas comme la plupart des autres livres sur l'informatique.  Les auteurs de la préface expliquent que le livre ne concerne pas seulement la programmation en Lisp - il parle de «trois astuces ou phénomènes: l'esprit humain, un ensemble de programmes informatiques et un ordinateur».  Plus tard, ils décrivent qu'ils sont convaincus que la programmation ne doit pas être considérée comme une discipline de l'informatique, mais comme un nouveau record «d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">épistémologie</a> procédurale».  Les programmes sont une nouvelle façon de structurer les pensées qui ne sont saisies qu'occasionnellement dans un ordinateur.  Le premier chapitre donne une brève visite de Lisp, mais la plupart du livre concerne des concepts plus abstraits.  Il examine divers paradigmes de programmation, la nature du temps et de l'identité dans les systèmes OO, et en un seul endroit, quels problèmes de synchronisation peuvent survenir en raison des limitations fondamentales du passage des messages, qui jouent le rôle de la vitesse de la lumière dans la théorie de la relativité.  Ce sont des choses assez abstruses. <br><br>  Et pour ne pas dire que le livre est mauvais.  Elle est magnifique.  Il aborde des concepts de programmation importants à un niveau supérieur à celui de tous les autres livres que j'ai lus, des concepts auxquels j'ai pensé pendant longtemps mais que je ne pouvais pas décrire.  Étonnamment, l'introduction au manuel de programmation peut si rapidement continuer à décrire les inconvénients fondamentaux de la POO et les avantages des langages fonctionnels qui minimisent un état mutable.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est incroyable de voir comment cela se transforme en une discussion sur la façon dont le paradigme de streaming, probablement quelque chose comme le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RxJS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d'aujourd'hui </font><font style="vertical-align: inherit;">, peut vous donner le meilleur des deux approches. SICP met en évidence l'essence même du développement de programmes de haut niveau d'une manière qui rappelle le travail original de McCarthy sur Lisp. La première chose que vous voulez faire après avoir lu ce livre est d'amener vos collègues programmeurs à le lire; s'ils le trouvent, voient la couverture et ne lisent pas, alors tout ce qui sera reporté est qu'une chose mystérieuse appelée eval / apply donne aux sorciers un pouvoir spécial sur les tables avec des pattes d'animaux. J'aurais été impressionné par leurs chaussures.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais la contribution la plus importante du SICP a peut-être été de faire passer Lisp d'un niveau de curiosité drôle à une nécessité pédagogique. Bien avant le SICP, les gens se sont conseillés d'apprendre le lisp afin d'améliorer leur niveau de programmeur. Numéro de 1979 de Byte Magazine. Le même éditeur, qui admirait les nouvelles machines Lisp au MIT, a expliqué qu'il valait la peine d'apprendre ce langage car il «présente un point de vue différent sur les tâches». Cependant, au SICP, Lisp n'a pas été présenté uniquement comme un contraste avec d'autres langues. Il a été utilisé comme langage d'introduction, laissant entendre qu'il s'agit du meilleur langage pour l'apprentissage des concepts de programmation de base. Lorsque les programmeurs d'aujourd'hui se conseillent d'essayer Lisp avant de mourir, ils le font probablement à cause de SICP. Après tout, Brainfuck offre également probablement une «perspective différente sur les tâches».Mais les gens étudient plutôt le lisp, sachant que depuis vingt ans le point de vue de lisp a été si utile que les étudiants du MIT ont enseigné le lisp dans toutes les autres langues.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retour Lisp </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'année de la sortie du SICP, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Björn Straustrup a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> publié la première édition du livre " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Programming Language</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", qui a amené la POO à la masse. </font><font style="vertical-align: inherit;">Quelques années plus tard, le marché des machines Lisp s'est effondré et l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hiver de l'IA a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> commencé </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au cours des dix années suivantes, C ++ puis Java sont devenus les langages du futur et Lisp a végété. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturellement, il est impossible d'indiquer quand exactement les gens ont recommencé à admirer Lisp. </font><font style="vertical-align: inherit;">Cela s'est peut-être produit après que Paul Graham, co-fondateur de Y-Combinator et créateur de Hacker News, a publié plusieurs essais influents décrivant Lisp comme le meilleur langage pour les startups. </font><font style="vertical-align: inherit;">Dans l'essai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant le milieu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Graham a affirmé que les macros Lisp rendaient le langage plus fort que les autres langages. Il a déclaré que l'utilisation de Lisp dans sa startup Viaweb l'avait aidé à développer certaines choses plus rapidement que ses concurrents. Certains programmeurs étaient convaincus. Mais la plupart ne sont pas passés à Lisp.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de cela, de plus en plus de fonctionnalités de Lisp ont commencé à tomber dans les langues préférées de tout le monde. Python a ajouté la génération de listes. En C # - Linq. Dans Ruby ... eh bien, Ruby est Lisp. Comme Graham l'a fait remarquer en 2001, «la langue par défaut, intégrée à de nombreuses langues populaires ultérieures, a progressivement évolué vers Lisp.» Et tandis que d'autres langues se rapprochent progressivement de Lisp, Lisp lui-même maintient en quelque sorte sa réputation particulière de langue mystérieuse que peu de gens comprennent, mais tout le monde doit apprendre. En 1980, l'année du 20e anniversaire de Lisp, McCarthy a écrit que Lisp avait survécu aussi longtemps qu'il avait pris «un optimum local approximatif d'une certaine sorte dans l'espace de PL». Mais cela sous-estime la véritable influence de Lisp. Il survit depuis cinquante ans parce que les programmeurs ont reconnu à contrecœur, décennie après décennie, que c'était le meilleur outil pour leur tâche. Il a survécu même sique la plupart des programmeurs ne l'utilisent pas. En raison de son origine et de son utilisation dans la recherche sur l'IA, et peut-être aussi de l'héritage du SICP, Lisp continue de ravir les gens. Et jusqu'à ce que nous puissions imaginer Dieu qui a créé le monde à l'aide d'un langage plus récent, Lisp n'ira nulle part.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428229/">https://habr.com/ru/post/fr428229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428219/index.html">D'où est venue la pratique de la réinstallation massive de personnel qualifié?</a></li>
<li><a href="../fr428221/index.html">Génération AI de visages réalistes</a></li>
<li><a href="../fr428223/index.html">Les villes et leurs Big Data</a></li>
<li><a href="../fr428225/index.html">Comment faire des analyses Web pour SaaS via Google Analytics: introduction et suivi d'un entonnoir</a></li>
<li><a href="../fr428227/index.html">Apprentissage automatique: prédire les cours boursiers en bourse</a></li>
<li><a href="../fr428231/index.html">Beau et propre: des outils qui vous aident à obtenir un code presque parfait</a></li>
<li><a href="../fr428233/index.html">Cinq raisons d'aimer les soirées IT régionales</a></li>
<li><a href="../fr428235/index.html">Pourquoi m'ont-ils appelé de la NSA au milieu de la nuit et demandé la source</a></li>
<li><a href="../fr428237/index.html">Scrum-mitap avec jeu de société: invitez au jeu Scrum Values</a></li>
<li><a href="../fr428239/index.html">Les lecteurs flash à l'aube de 2019 - une relique du passé ou encore une nécessité?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>