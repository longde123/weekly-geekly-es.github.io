<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💔 🏇 👩🏻‍⚕️ Implementieren der Statusvorlage in Unity 👩🏻‍🌾 🧒🏾 🌴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Programmieren von In-Game-Entitäten treten Situationen auf, in denen sie unter unterschiedlichen Bedingungen auf unterschiedliche Weise agieren m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementieren der Statusvorlage in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484176/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png" alt="Bild"></div><br>  Beim Programmieren von In-Game-Entitäten treten Situationen auf, in denen sie unter unterschiedlichen Bedingungen auf unterschiedliche Weise agieren müssen, was auf die Verwendung von <i>Zuständen</i> hindeutet. <br><br>  Wenn Sie sich jedoch für Brute Force entscheiden, verwandelt sich der Code schnell in ein Chaos mit vielen verschachtelten if-else-Anweisungen. <br><br>  Für eine ordnungsgemäße Lösung dieses Problems können Sie das Entwurfsmuster "Status" verwenden.  Wir werden ihm dieses Tutorial widmen! <br><br>  Aus dem Tutorial Sie: <br><br><ul><li>  Lernen Sie die Grundlagen der Statusvorlage in Unity kennen. </li><li>  Sie erfahren, was eine Zustandsmaschine ist und wann sie verwendet werden muss. </li><li>  Erfahren Sie, wie Sie diese Konzepte verwenden, um die Bewegung Ihres Charakters zu steuern. </li></ul><br><blockquote>  <em>Hinweis</em> : Dieses Tutorial richtet sich an fortgeschrittene Benutzer.  Es wird davon ausgegangen, dass Sie bereits mit Unity vertraut sind und über durchschnittliche Kenntnisse in C # verfügen.  Darüber hinaus verwendet dieses Lernprogramm Unity 2019.2 und C # 7. </blockquote><a name="habracut"></a><br><h2>  An die Arbeit gehen </h2><br>  <a href="">Projektmaterialien</a> herunterladen.  Entpacken Sie die <em>Zip-Datei</em> und öffnen Sie das Startprojekt in Unity. <br><br>  Das Projekt enthält mehrere Ordner, die Ihnen den Einstieg erleichtern.  Der Ordner <em>Assets / RW</em> enthält die Ordner <em>Animationen</em> , <em>Materialien</em> , <em>Modelle</em> , <em>Prefabs</em> , <em>Ressourcen</em> , <em>Szenen</em> , <em>Skripte</em> und <em>Sounds</em> , die nach den darin enthaltenen Ressourcen benannt sind. <br><br>  Um das Tutorial zu vervollständigen, arbeiten wir nur mit <em>Szenen</em> und <em>Skripten</em> . <br><br>  Gehen Sie zu <em>RW / Scenes</em> und öffnen Sie <em>Main</em> .  Im Spielmodus sehen Sie eine Figur in einer Kapuze in einer mittelalterlichen Burg. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/f1b/4e1/478f1b4e1ec3a2e8702e365e4082a605.png"></div><br>  Klicken Sie auf " <em>Abspielen"</em> und beobachten Sie, wie sich die <em>Kamera</em> an den <em>Zeichenrahmen</em> anpasst.  Momentan gibt es in unserem kleinen Spiel keine Interaktionen, wir werden sie im Tutorial bearbeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/62c/536/ba362c53682371294f90576b5fd5adc6.gif"></div><br><h2>  Erkunde den Charakter </h2><br>  Wählen Sie in der <em>Hierarchie</em> <em>Zeichen</em> .  Überprüfen Sie den <em>Inspector</em> .  Sie sehen eine <em>Komponente</em> mit demselben Namen, die die Steuerlogik für <em>Zeichen</em> enthält. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/ffd/2ba/957ffd2ba0299d4b509b75bedb094581.png"></div><br>  Öffnen Sie <em>Character.cs</em> in <em>RW / Scripts</em> . <br><br>  Das Skript führt viele Aktionen aus, die meisten sind jedoch für uns nicht wichtig.  Beachten wir zunächst die folgenden Methoden. <br><br><ul><li> <code>Move</code> : Bewegt den Charakter und empfängt Werte vom Typ Gleitgeschwindigkeit als Bewegungsgeschwindigkeit und <code>rotationSpeed</code> als Winkelgeschwindigkeit. </li><li>  <code>ResetMoveParams</code> : Diese Methode setzt die Parameter zurück, mit denen <i>die Bewegung</i> und die Winkelgeschwindigkeit des Zeichens <i>animiert werden</i> .  Es wird nur zur Reinigung verwendet. </li><li>  <code>SetAnimationBool</code> : <code>param</code> Parameter <code>param</code> animation vom Typ Bool auf value. </li><li>  <code>CheckCollisionOverlap</code> : Er empfängt einen <code></code> Typ <code>Vector3</code> und gibt ein <code>Vector3</code> zurück, das bestimmt, ob sich innerhalb des angegebenen Radius vom <code></code> <code>Vector3</code> befinden. </li><li>  <code>TriggerAnimation</code> : <code>TriggerAnimation</code> den Animationsparameter des Eingabeparameters <code>param</code> . </li><li>  <code>ApplyImpulse</code> : <code>ApplyImpulse</code> Impuls auf Character an, der dem Eingabeparameter <code>force</code> Typ <code>Vector3</code> . </li></ul><br>  Nachfolgend sehen Sie diese Methoden.  In unserem Tutorial sind deren Inhalt und interne Arbeit nicht wichtig. <br><br><h2>  Was sind Zustandsautomaten? </h2><br>  Eine Zustandsmaschine ist ein Konzept, bei dem ein Container den Zustand von etwas zu einem bestimmten Zeitpunkt speichert.  Basierend auf den Eingabedaten kann es abhängig vom aktuellen Status eine Schlussfolgerung geben, die in diesem Prozess in einen neuen Status übergeht.  Zustandsautomaten können als <a href="https://www.geeksforgeeks.org/unified-modeling-language-uml-state-diagrams/" rel="noopener">Zustandsdiagramm dargestellt werden</a> .  Wenn Sie ein Zustandsdiagramm erstellen, können Sie alle möglichen Zustände des Systems und die Übergänge zwischen ihnen durchdenken. <br><br><h3>  Zustandsautomaten </h3><br>  <em>Finite State Machines</em> oder <em>FSM (Finite State Machine)</em> ist eine der vier Hauptfamilien von <em>Maschinen</em> .  Automaten sind abstrakte Modelle einfacher Maschinen.  Sie werden im Rahmen der <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/2004-05/automata-theory/basics.html" rel="noopener"><em>Automatentheorie</em></a> - dem theoretischen Zweig der Informatik - untersucht. <br><br>  Kurzgesagt: <br><br><ul><li>  FSM besteht aus einer endlichen Menge von <em>Bedingungen</em> .  Zu jedem Zeitpunkt <em>ist</em> nur einer dieser Zustände <em>aktiv</em> . </li><li>  Jeder Zustand bestimmt, in welchen Zustand er als <em>Ausgabe geht,</em> basierend auf der empfangenen Sequenz <em>eingehender Informationen</em> . </li><li>  Der Ausgangszustand wird zum neuen aktiven Zustand.  Mit anderen Worten, es gibt einen <em>Übergang zwischen Zuständen</em> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/111/f04/c43111f045f3727ab5f3b02c05c6ecc2.png"></div><br>  Um dies besser zu verstehen, betrachten Sie den Charakter eines Plattformspiels, das vor Ort ist.  Der Charakter befindet sich im <i>stehenden</i> Zustand.  Dies ist sein <em>aktiver Zustand,</em> bis der Spieler den Knopf drückt, so dass der Charakter springt. <br><br>  Der Status " <i>Stehend"</i> kennzeichnet einen Tastendruck als signifikanten <em>Eingang</em> und wechselt als <em>Ausgang</em> in den Status " <i>Springen"</i> . <br><br>  Angenommen, es gibt eine bestimmte Anzahl solcher Bewegungszustände, und ein Charakter kann sich jeweils nur in einem der Zustände befinden.  Dies ist ein Beispiel für FSM. <br><br><h3>  Hierarchische Zustandsmaschinen </h3><br>  Stellen Sie sich einen Plattformer mit FSM vor, in dem mehrere Zustände eine gemeinsame Physiklogik aufweisen.  Sie können sich beispielsweise in den Zuständen <em>Hocken</em> und <em>Stehen</em> bewegen und springen.  In diesem Fall führen mehrere eingehende Variablen für zwei verschiedene Zustände zur gleichen Verhaltens- und Informationsausgabe. <br><br>  In einer solchen Situation wäre es logisch, das allgemeine Verhalten an einen anderen Staat zu delegieren.  Glücklicherweise kann dies mit <em>hierarchischen</em> Zustandsautomaten erreicht werden. <br><br>  In einem hierarchischen FSM gibt es <em>Unterzustände, die</em> eingehende <i>Rohdaten</i> an ihre <em>Unterzustände delegieren</em> .  Auf diese Weise können Sie die Größe und Komplexität des FSM unter Beibehaltung seiner Logik elegant reduzieren. <br><br><h2>  Statusvorlage </h2><br>  In ihrem Buch <i>Design Patterns: Elemente wiederverwendbarer objektorientierter Software definierten</i> Erich Gamma, Richard Helm, Ralph Johnson und John Vlissidis ( <em>Die Viererbande</em> ) die <i>Aufgabe</i> der Vorlage State wie folgt: <br><br>  „Er muss dem Objekt erlauben, sein Verhalten zu ändern, wenn sich sein interner Zustand ändert.  In diesem Fall hat das Objekt anscheinend seine Klasse geändert. “ <br><br>  Um dies besser zu verstehen, betrachten Sie das folgende Beispiel: <br><br><ul><li>  Ein Skript, das eingehende Informationen für die Bewegungslogik empfängt, ist an eine Entität im Spiel angehängt. </li><li>  Diese Klasse speichert eine <i>aktuelle</i> Statusvariable, die sich einfach auf eine Instanz der Statusklasse bezieht. </li><li>  Eingehende Informationen werden an diesen aktuellen Status delegiert, der sie verarbeitet und ein in sich selbst definiertes Verhalten erzeugt.  Es behandelt auch die erforderlichen Zustandsübergänge. </li></ul><br>  Aufgrund der Tatsache, dass sich die <i>aktuelle</i> Statusvariable zu unterschiedlichen Zeitpunkten auf unterschiedliche <i>Status</i> bezieht, scheint es, dass sich dieselbe Skriptklasse unterschiedlich verhält.  Dies ist das Wesentliche der Vorlage "Status". <br><br>  In unserem Projekt verhält sich die oben genannte <em>Zeichenklasse</em> je nach Status unterschiedlich.  Aber wir brauchen ihn, um sich zu benehmen! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d8/d20/f59/3d8d20f5921bf342b2ac84b5677e9a3b.png"></div><br>  Im Allgemeinen gibt es drei Schlüsselpunkte für jede Zustandsklasse, die das Verhalten des gesamten Staates ermöglichen: <br><br><ul><li>  <em>Eintrag</em> : Dies ist der Moment, in dem eine Entität in einen Zustand eintritt und Aktionen ausführt, die beim Eintritt in den Zustand nur einmal ausgeführt werden müssen. </li><li>  <em>Beenden</em> : Ähnlich wie bei der Eingabe werden hier alle Rücksetzvorgänge ausgeführt, die nur ausgeführt werden müssen, bevor sich der Status ändert. </li><li>  <em>Update-Schleife</em> : Hier ist die grundlegende <i>Update-Logik</i> , die in jedem Frame ausgeführt wird.  Es kann in mehrere Teile unterteilt werden, z. B. einen Zyklus zum Aktualisieren der Physik und einen Zyklus zum Verarbeiten der Spielereingaben. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a26/847/8e6/a268478e6da2566cc58d1083fefed27f.png"></div><br><h3>  Definieren eines Zustands und einer Zustandsmaschine </h3><br>  Gehen Sie zu <em>RW / Scripts</em> und öffnen Sie <em>StateMachine.cs</em> . <br><br>  <em>Die Zustandsmaschine stellt</em> , wie Sie vielleicht vermuten, eine Abstraktion für die Zustandsmaschine bereit.  Beachten Sie, dass sich <code>CurrentState</code> korrekt in dieser Klasse befindet.  Es wird eine Verknüpfung zum aktuellen Status der aktiven Statusmaschine gespeichert. <br><br>  <em>Um</em> das Konzept des <i>Status</i> zu definieren, <em>rufen Sie</em> <em>RW / Scripts auf</em> und öffnen Sie das Skript <em>State.cs</em> in der IDE. <br><br>  <em>State</em> ist eine abstrakte Klasse, die wir als <i>Modell verwenden,</i> aus dem alle <i>Klassen von</i> Projektstatus abgeleitet werden.  Ein Teil des Codes in den Projektmaterialien ist bereits fertig. <br><br>  <code>DisplayOnUI</code> zeigt nur den Namen des aktuellen Status in der Bildschirmbenutzeroberfläche an.  Sie müssen das interne Gerät nicht kennen. Sie müssen lediglich verstehen, dass es einen Enumerator des Typs <code>UIManager.Alignment</code> als Eingabeparameter empfängt, der <code>Left</code> oder <code>Right</code> .  Die Anzeige des Namens des Status im linken oder rechten unteren Teil des Bildschirms hängt davon ab. <br><br>  Zusätzlich gibt es zwei geschützte Variablen, <code>character</code> und <code>stateMachine</code> .  Die <code>character</code> verweist auf eine Instanz der <em>Character-</em> Klasse, und <code>stateMachine</code> verweist auf eine Instanz <em>der Zustandsmaschine,</em> die dem Zustand zugeordnet ist. <br><br>  Beim Erstellen einer <code>stateMachine</code> bindet der Konstruktor <code>character</code> und <code>stateMachine</code> . <br><br>  Jede der vielen Instanzen von <code>Character</code> in einer Szene kann einen eigenen Satz von Zuständen und Zustandsautomaten haben. <br><br>  <em>Fügen Sie State.cs</em> nun die folgenden Methoden <em>hinzu</em> und speichern Sie die Datei: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DisplayOnUI(UIManager.Alignment.Left); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Diese virtuellen Methoden definieren die oben beschriebenen Hauptstatuspunkte.  Wenn <em>die Zustandsmaschine</em> einen Übergang zwischen Zuständen durchführt, rufen wir <code>Exit</code> für den vorherigen Zustand auf und <code>Enter</code> neuen <i>aktiven Zustand ein</i> . <br><br>  <code>HandleInput</code> , <code>LogicUpdate</code> und <code>PhysicsUpdate</code> definieren zusammen <i>eine Aktualisierungsschleife</i> .  <code>HandleInput</code> verarbeitet die Player-Eingabe.  <code>LogicUpdate</code> verarbeitet grundlegende Logik, während <code>PhyiscsUpdate</code> Logik- und Physikberechnungen verarbeitet. <br><br>  Öffnen <em>Sie</em> nun <em>StateMachine.cs</em> erneut, fügen Sie die folgenden Methoden hinzu und speichern Sie die Datei: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State startingState</span></span></span><span class="hljs-function">)</span></span> { CurrentState = startingState; startingState.Enter(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State newState</span></span></span><span class="hljs-function">)</span></span> { CurrentState.Exit(); CurrentState = newState; newState.Enter(); }</code> </pre> <br>  <code>Initialize</code> konfiguriert den Zustandsautomaten, indem <code>CurrentState</code> auf <code>startingState</code> und die <code>Enter</code> dafür <code>CurrentState</code> .  Dies initialisiert die Zustandsmaschine und setzt zum ersten Mal den aktiven Zustand. <br><br>  <code>ChangeState</code> behandelt <code>ChangeState</code> .  Es ruft <code>Exit</code> für den alten <code>CurrentState</code> bevor die Referenz durch <code>newState</code> .  Am Ende wird <code>Enter</code> für <code>newState</code> . <br><br>  So setzen wir den <em>Zustand</em> und die <em>Zustandsmaschine</em> . <br><br><h3>  Bewegungszustände erstellen </h3><br>  Schauen Sie sich das folgende Zustandsdiagramm an, in dem die verschiedenen <i>Bewegungszustände der</i> In-Game-Essenz <i>des</i> Spielers dargestellt sind.  In diesem Abschnitt implementieren wir die Vorlage "Status" für die in der <i>FSM-</i> Abbildung gezeigte <i>Bewegung</i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png"></div><br>  Achten Sie auf die Bewegungszustände <em>Stehen</em> , <em>Ducken</em> und <em>Springen</em> sowie darauf, wie die eingehenden Daten Übergänge zwischen den Zuständen verursachen.  Dies ist eine hierarchische FSM, in der <em>Grounded</em> ein Unterzustand für die <em>Unterzustände Ducking</em> und <em>Standing</em> <em>ist</em> . <br><br>  Kehren Sie zu Unity zurück und gehen Sie zu <em>RW / Scripts / States</em> .  Dort finden Sie mehrere C # -Dateien mit Namen, die auf <i>State</i> enden. <br><br>  Jede dieser Dateien definiert eine Klasse, von denen jede von <code>State</code> geerbt wird.  Daher definieren diese Klassen die Zustände, die wir im Projekt verwenden werden. <br><br>  Öffnen Sie nun <em>Character.cs</em> aus dem <em>RW / Scripts-</em> Ordner. <br><br>  <code>#region Variables</code> über die Datei <code>#region Variables</code> und fügen Sie den folgenden Code hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StateMachine movementSM; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StandingState standing; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DuckingState ducking; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JumpingState jumping;</code> </pre> <br>  Diese <code>movementSM</code> bezieht sich auf eine Zustandsmaschine, die die Bewegungslogik für die <code>Character</code> Instanz verarbeitet.  Wir haben auch Links zu drei Zuständen hinzugefügt, die wir für jede Art von Bewegung implementieren. <br><br>  Gehen <code>#region MonoBehaviour Callbacks</code> in derselben Datei zu <code>#region MonoBehaviour Callbacks</code> .  Fügen Sie die folgenden <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" rel="noopener">MonoBehaviour-</a> Methoden hinzu und speichern Sie sie <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateMachine(); standing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); ducking = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DuckingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); jumping = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JumpingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); movementSM.Initialize(standing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.HandleInput(); movementSM.CurrentState.LogicUpdate(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.PhysicsUpdate(); }</code> </pre> <br><ul><li>  In <code>Start</code> Code eine Instanz der <em>Zustandsmaschine</em> und weist sie <code>movementSM</code> . Außerdem werden verschiedene Bewegungszustände instanziiert.  Bei der Erstellung der einzelnen Bewegungszustände übergeben wir unter Verwendung des <code>this</code> sowie der <code>movementSM</code> Instanz Verweise auf die <code>Character</code> Instanz.  Am Ende rufen wir <code>Initialize</code> for <code>movementSM</code> und übergeben <code>Standing</code> als Ausgangszustand. </li><li>  In der <code>Update</code> Methode rufen wir <code>HandleInput</code> und <code>LogicUpdate</code> für den <code>CurrentState</code> der <code>movementSM</code> Maschine auf.  Ebenso <code>FixedUpdate</code> wir in <code>FixedUpdate</code> <code>PhysicsUpdate</code> für den <code>CurrentState</code> der <code>movementSM</code> Maschine auf.  Im Wesentlichen delegiert dies Aufgaben an einen aktiven Status.  Dies ist die Bedeutung der Vorlage "Status". </li></ul><br>  Jetzt müssen wir das Verhalten in jedem der Bewegungszustände einstellen.  Machen Sie sich bereit, es wird eine Menge Code geben! <br><br><h3>  Stehend fest </h3><br>  <em>Kehren Sie</em> im Projektfenster zu <em>RW / Scripts / States</em> zurück. <br><br>  Öffnen Sie <em>Grounded.cs,</em> und beachten Sie, dass diese Klasse über einen Konstruktor verfügt, der dem <code>State</code> Konstruktor entspricht.  Das ist logisch, weil diese Klasse davon erbt.  Sie werden dasselbe in allen anderen Staatsklassen sehen. <br><br>  Fügen Sie den folgenden Code hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); horizontalInput = verticalInput = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.ResetMoveParams(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); verticalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); horizontalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); character.Move(verticalInput * speed, horizontalInput * rotationSpeed); }</code> </pre> <br>  Folgendes passiert hier: <br><br><ul><li>  Wir definieren eine der in der Elternklasse definierten virtuellen Methoden neu.  Um die gesamte Funktionalität des übergeordneten Elements beizubehalten, rufen wir die <code>base</code> mit demselben Namen für jede überschriebene Methode auf.  Dies ist eine wichtige Vorlage, die wir weiterhin verwenden werden. </li><li>  Die nächste Zeile, <code>Enter</code> setzt <code>horizontalInput</code> und <code>verticalInput</code> ihre Standardwerte. </li><li>  Innerhalb von <code>Exit</code> rufen wir, wie oben erwähnt, die <code>ResetMoveParams</code> Methode des <code></code> , um sie zurückzusetzen, wenn Sie in einen anderen Status wechseln. </li><li>  In der <code>HandleInput</code> Methode zwischenspeichern die Variablen <code>horizontalInput</code> und <code>verticalInput</code> <code>HandleInput</code> Werte der horizontalen und vertikalen Eingabeachse.  Dank dessen kann der Spieler den Charakter mit den Tasten <em>W</em> , <em>A</em> , <em>S</em> und <em>D</em> steuern <em>.</em> </li><li>  Bei <code>PhysicsUpdate</code> wir <code>Move</code> und übergeben die Variablen <code>horizontalInput</code> und <code>verticalInput</code> multipliziert mit den entsprechenden Geschwindigkeiten.  In der variablen <code>speed</code> die Bewegungsgeschwindigkeit und in <code>rotationSpeed</code> die Winkelgeschwindigkeit gespeichert. </li></ul><br>  Öffnen Sie nun <em>Standing.cs</em> und achten Sie darauf, dass es von <code>Grounded</code> erbt.  Es ist passiert, weil <em>Standing</em> , wie wir oben sagten, ein Substate für <em>Grounded ist</em> .  Es gibt verschiedene Möglichkeiten, diese Beziehung zu implementieren. In diesem Lernprogramm wird jedoch die Vererbung verwendet. <br><br>  Fügen Sie die folgenden <code>override</code> und speichern Sie das Skript: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); speed = character.MovementSpeed; rotationSpeed = character.RotationSpeed; crouch = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; jump = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouch = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); jump = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Jump"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (crouch) { stateMachine.ChangeState(character.ducking); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jump) { stateMachine.ChangeState(character.jumping); } }</code> </pre> <br><ul><li>  In <code>Enter</code> konfigurieren wir die von <code>Grounded</code> geerbten Variablen.  Wenden Sie die <code>MovementSpeed</code> und <code>RotationSpeed</code> Charakters auf <code>speed</code> und <code>rotationSpeed</code> .  Dann beziehen sie sich jeweils auf die <i>normale</i> Bewegungsgeschwindigkeit und die Winkelgeschwindigkeit, die für das Wesen des Charakters bestimmt sind. <br><br>  Darüber hinaus werden Variablen zum Speichern von <code>crouch</code> Eingaben und <code>jump</code> auf false zurückgesetzt. </li><li>  In <code>HandleInput</code> speichern die Variablen <code>HandleInput</code> und <code>jump</code> die Eingaben des Spielers für Kniebeugen und Sprünge.  Wenn der Spieler in der Hauptszene die <em>Umschalttaste</em> drückt <em>, wird die</em> Hocke auf true gesetzt.  Ebenso kann ein Spieler mit der Leertaste <code>jump</code> . </li><li>  In <code>LogicUpdate</code> überprüfen wir die Variablen <code>LogicUpdate</code> und <code>jump</code> vom Typ <code>bool</code> .  Wenn <code>crouch</code> true ist, ändert sich <code>movementSM.CurrentState</code> in <code>character.ducking</code> .  Wenn <code>jump</code> true ist, ändert sich der Status in <code>character.jumping</code> . </li></ul><br>  Speichern und montieren Sie das Projekt und klicken Sie dann auf <em>Wiedergabe</em> .  Mit den Tasten <em>W</em> , <em>A</em> , <em>S</em> und <em>D</em> können Sie sich in der Szene bewegen <em>.</em>  Wenn Sie versuchen, die <em>Umschalt-</em> oder Leertaste zu drücken, tritt ein unerwartetes Verhalten auf, da die entsprechenden Status noch nicht implementiert sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/89a/564/45089a5640a8d492b20ac5948e0fdf69.gif"></div><br>  Versuchen Sie, sich unter den Tischobjekten zu bewegen.  Sie werden sehen, dass dies aufgrund der Höhe des Colliders des Charakters nicht möglich ist.  Damit der Charakter dies tun kann, müssen Sie das Verhalten der Hocke hinzufügen. <br><br><h3>  Wir klettern unter den Tisch </h3><br>  Öffnen Sie das Skript <em>Ducking.cs</em> .  Beachten Sie, dass <code>Ducking</code> aus den gleichen Gründen wie <code>Standing</code> auch von der <code>Grounded</code> Klasse erbt.  Fügen Sie die folgenden <code>override</code> und speichern Sie das Skript: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); speed = character.CrouchSpeed; rotationSpeed = character.CrouchRotationSpeed; character.ColliderSize = character.CrouchColliderHeight; belowCeiling = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); character.ColliderSize = character.NormalColliderHeight; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouchHeld = Input.GetButton(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(crouchHeld || belowCeiling)) { stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); belowCeiling = character.CheckCollisionOverlap(character.transform.position + Vector3.up * character.NormalColliderHeight); }</code> </pre> <br><ul><li>  In der <code>Enter</code> Parameter, der das Umschalten der Kniebeugenanimation bewirkt, auf "geduckt" gesetzt, wodurch die Kniebeugenanimation aktiviert wird.  Den Eigenschaften <code>character.CrouchSpeed</code> und <code>character.CrouchRotationSpeed</code> die Werte für <code>speed</code> und <code>rotation</code> zugewiesen, die die Bewegung und Winkelgeschwindigkeit des Zeichens beim <i>Bewegen in einer Hocke zurückgeben</i> . <br><br>  Nächstes <code>character.CrouchColliderHeight</code> legt die Größe des Colliders des Zeichens fest, der beim Hocken die gewünschte Collider-Höhe zurückgibt.  Am Ende wird <code>belowCeiling</code> auf false zurückgesetzt. </li><li>  Innerhalb von <code>Exit</code> der Parameter für die Squat-Animation auf false festgelegt.  Dadurch wird die Squat-Animation deaktiviert.  Dann wird die normale Collider-Höhe festgelegt, die vom <code>character.NormalColliderHeight</code> zurückgegeben wird. <code>character.NormalColliderHeight</code> . </li><li>  In <code>HandleInput</code> Variable <code>crouchHeld</code> den Eingabewert des Players fest.  <code>crouchHeld</code> in der <code>crouchHeld</code> die <em>Umschalttaste</em> <code>crouchHeld</code> , wird <code>crouchHeld</code> auf true gesetzt. </li><li>  In <code>PhysicsUpdate</code> Variablen <code>belowCeiling</code> ein Wert zugewiesen, indem ein Punkt im <code>Vector3</code> Format mit dem Kopf des <code>Vector3</code> des Charakters an die <code>CheckCollisionOverlap</code> Methode übergeben wird.  Wenn es in der Nähe dieses Punktes zu einer Kollision kommt, bedeutet dies, dass sich der Charakter unter einer bestimmten Decke befindet. </li><li>  Intern prüft <code>LogicUpdate</code> , ob <code>crouchHeld</code> oder <code>belowCeiling</code> wahr ist.  Wenn keines davon wahr ist, ändert sich <code>movementSM.CurrentState</code> in <code>character.standing</code> . </li></ul><br>  Erstellen Sie das Projekt und klicken Sie auf <em>Abspielen</em> .  Jetzt können Sie sich in der Szene bewegen.  Wenn Sie die <em>Umschalttaste</em> drücken, setzt sich der Charakter hin und Sie können sich in der Hocke bewegen. <br><br>  Sie können auch unter der Plattform klettern.  Wenn Sie die <em>Umschalttaste</em> unter den Plattformen loslassen, befindet sich der Charakter immer noch in der Hocke, bis er sein Obdach verlässt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee4/dce/657/ee4dce657ae6be49244106652a168a3a.gif"></div><br><h3>  Steig auf! </h3><br>  Öffnen Sie <em>Jumping.cs</em> .  Sie sehen eine Methode namens <code>Jump</code> .  Mach dir keine Sorgen darüber, wie es funktioniert;  Es reicht zu verstehen, dass es verwendet wird, damit der Charakter unter Berücksichtigung von Physik und Animation springen kann. <br><br>  Fügen Sie nun die üblichen <code>override</code> und speichern Sie das Skript <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); SoundManager.Instance.PlaySound(SoundManager.Instance.jumpSounds); grounded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Jump(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grounded) { character.TriggerAnimation(landParam); SoundManager.Instance.PlaySound(SoundManager.Instance.landing); stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); grounded = character.CheckCollisionOverlap(character.transform.position); }</code> </pre> <br><ul><li>  Innerhalb von <code>Enter</code> Singleton <code>SoundManager</code> den Sound des Sprungs ab.  Dann wird <code>grounded</code> auf den Standardwert zurückgesetzt.  Am Ende heißt <code>Jump</code> . </li><li>  In <code>PhysicsUpdate</code> Punkt neben den Beinen des Charakters an <code>CheckCollisionOverlap</code> gesendet. Wenn sich der Charakter auf dem Boden befindet, wird <code>grounded</code> auf True gesetzt. </li><li>  <code>LogicUpdate</code> in <code>LogicUpdate</code> <code>grounded</code> True ist, rufen wir <code>TriggerAnimation</code> auf, um die <code>TriggerAnimation</code> zu aktivieren, ein Landegeräusch wird abgespielt und <code>movementSM.CurrentState</code> ändert sich in <code>character.standing</code> . </li></ul><br>  Damit haben wir die vollständige Implementierung der FSM-Verschiebung mithilfe <em>der Vorlage „State“ abgeschlossen</em> .  Erstellen Sie das Projekt, und führen Sie es aus.  Drücken Sie die <em>Leertaste</em> , um den Charakter zum Springen zu bringen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/e16/05d/ebde1605dc739588529c51509e19c0a8.gif"></div><br><h2>  Wohin als nächstes? </h2><br>  Die <a href="">Projektmaterialien</a> haben einen Projektentwurf und ein fertiges Projekt. <br><br>  Trotz ihrer Nützlichkeit weisen Zustandsmaschinen Einschränkungen auf.  Concurrent State Machines und Pushdown-Automaten können einige dieser Einschränkungen umgehen.  Sie können darüber im Buch von Robert Nystrom <a href="https://gameprogrammingpatterns.com/state.html" rel="noopener"><em>Game Programming Patterns</em></a> nachlesen. <br><br>  Darüber hinaus kann das Thema vertieft werden, indem die <a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)" rel="noopener"><em>Verhaltensbäume untersucht</em></a> werden, mit denen komplexere Objekte im Spiel erstellt werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484176/">https://habr.com/ru/post/de484176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484166/index.html">VVVVVV ??? VVVVVV !!! :)</a></li>
<li><a href="../de484168/index.html">Wir schreiben unsere Strategie für das virtuelle Scrollen von Angular CDK</a></li>
<li><a href="../de484170/index.html">Aktualisieren Sie Check Point von R77.30 auf 80.20</a></li>
<li><a href="../de484172/index.html">Kontinuierliche Integration in Unity: Verkürzung der Montagezeit und Einsparung von Ressourcen + Gewinnlinie als Geschenk</a></li>
<li><a href="../de484174/index.html">Castle trinkt unter "extremen" Bedingungen oder wie wir an der "DOZOR" Show teilgenommen haben</a></li>
<li><a href="../de484178/index.html">Intelligenter Ethernet-Switch für Planet Earth</a></li>
<li><a href="../de484180/index.html">Virtuelle Telefonanlage von Rostelecom: Was und wie kann über die API geschehen?</a></li>
<li><a href="../de484182/index.html">Xenobots: Lebende Nanoroboter aus Froschzellen</a></li>
<li><a href="../de484186/index.html">LDAP - "Authentifizierung" ist ein Antipattern</a></li>
<li><a href="../de484188/index.html">Standards für das Datenbankdesign</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>