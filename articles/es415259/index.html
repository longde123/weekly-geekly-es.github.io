<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçª üåæ üçπ select / poll / epoll: diferencia pr√°ctica üïô üßöüèæ üë¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al dise√±ar aplicaciones de red de alto rendimiento con sockets sin bloqueo, es importante decidir qu√© m√©todo de monitoreo de eventos de red usaremos. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>select / poll / epoll: diferencia pr√°ctica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/415259/">  Al dise√±ar aplicaciones de red de alto rendimiento con sockets sin bloqueo, es importante decidir qu√© m√©todo de monitoreo de eventos de red usaremos.  Hay varios de ellos, y cada uno es bueno y malo a su manera.  Elegir el m√©todo correcto puede ser cr√≠tico para la arquitectura de su aplicaci√≥n. <br><br>  En este art√≠culo consideraremos: <br><br><ul><li>  seleccione () </li><li>  encuesta () </li><li>  epoll () </li><li>  liberador </li></ul><a name="habracut"></a><br><h3>  Usando select () </h3><br>  El viejo, probado a trav√©s de los a√±os, trabajador duro select () fue creado en aquellos d√≠as cuando los "enchufes" se llamaban " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enchufes Berkeley</a> ".  Este m√©todo no se incluy√≥ en la primera especificaci√≥n de esos z√≥calos Berkeley, ya que en aquellos d√≠as todav√≠a no exist√≠a el concepto de E / S sin bloqueo.  Pero en alg√∫n momento de los a√±os 80 apareci√≥, y con ella seleccion√≥ ().  Desde entonces, nada ha cambiado significativamente en su interfaz. <br><br>  Para usar select (), el desarrollador necesita inicializar y llenar varias estructuras fd_set con descriptores y eventos que necesitan ser monitoreados, y luego llamar a select ().  Un c√≥digo t√≠pico se parece a esto: <br><br><pre><code class="cpp hljs">fd_set fd_in, fd_out; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   FD_ZERO( &amp;fd_in ); FD_ZERO( &amp;fd_out ); //        sock1 FD_SET( sock1, &amp;fd_in ); //        sock2 FD_SET( sock2, &amp;fd_out ); //       (select   ) int largest_sock = sock1 &gt; sock2 ? sock1 : sock2; //    10  tv.tv_sec = 10; tv.tv_usec = 0; //  select int ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { if ( FD_ISSET( sock1, &amp;fd_in ) ) //    sock1 if ( FD_ISSET( sock2, &amp;fd_out ) ) //    sock2 }</span></span></code> </pre> <br>  Cuando se dise√±√≥ select (), nadie esperaba que en el futuro necesit√°ramos escribir aplicaciones de subprocesos m√∫ltiples que sirvan a miles de conexiones.  Select () tiene varios inconvenientes importantes que lo hacen poco adecuado para trabajar en dichos sistemas.  Los principales son: <br><br><ul><li>  select modifica las estructuras fd_sets que se le pasan, de modo que ninguna de ellas pueda reutilizarse.  Incluso si no necesita cambiar nada (por ejemplo, despu√©s de recibir un dato, desea obtener m√°s), las estructuras de fd_sets tendr√°n que reinicializarse.  Bueno, o copie desde una copia de seguridad previamente guardada usando FD_COPY.  Y esto tendr√° que hacerse una y otra vez, antes de cada llamada de selecci√≥n. </li><li>  Para saber exactamente qu√© descriptor gener√≥ el evento, debe sondearlos manualmente con FD_ISSET.  Cuando monitorea 2000 descriptores, y el evento ocurri√≥ solo para uno de ellos (que, de acuerdo con la ley de la mezquindad, ser√° el √∫ltimo en la lista), desperdiciar√° muchos recursos del procesador. </li><li>  ¬øAcabo de mencionar 2000 descriptores?  Me emocion√© al respecto.  select no es tan compatible.  Bueno, al menos en Linux normal, con el n√∫cleo habitual.  El n√∫mero m√°ximo de descriptores observados simult√°neamente est√° limitado por la constante FD_SETSIZE, que es r√≠gidamente igual a 1024 en Linux. Algunos sistemas operativos le permiten implementar un hack al anular el valor FD_SETSIZE antes de incluir el archivo de encabezado sys / select.h, pero este hack no es parte de alg√∫n est√°ndar com√∫n.  El mismo Linux lo ignorar√°. </li><li>  No puede trabajar con descriptores de un conjunto observable de otro hilo.  Imagine un hilo ejecutando el c√≥digo anterior.  Entonces comenz√≥ y espera eventos en su select ().  Ahora imagine que tiene otro subproceso que supervisa la carga general en el sistema, y ‚Äã‚Äãahora decidi√≥ que los datos del z√≥calo sock1 no han llegado durante demasiado tiempo y que era hora de romper la conexi√≥n.  Dado que este socket se puede reutilizar para servir a nuevos clientes, ser√≠a bueno cerrarlo correctamente.  Pero el primer hilo es observar este descriptor en este momento.  ¬øQu√© pasar√° si lo cerramos de todos modos?  Ah, la documentaci√≥n tiene una respuesta a esta pregunta y no le gustar√°: "Si el identificador observado con select () est√° cerrado por otro hilo, obtendr√° un comportamiento indefinido". </li><li>  El mismo problema aparece cuando intenta enviar algunos datos a trav√©s de sock1.  No enviaremos nada hasta que select finalice su trabajo. </li><li>  La elecci√≥n de eventos que podemos monitorear es bastante limitada.  Por ejemplo, para determinar que se ha cerrado un socket remoto, primero debe monitorear los eventos de llegada de datos y, en segundo lugar, intentar leer estos datos (leer devolver√° 0 para el socket cerrado).  Todav√≠a se puede llamar aceptable cuando se leen datos de un socket (leer 0: el socket est√° cerrado), pero ¬øqu√© pasa si nuestra tarea actual en este momento es enviar datos a este socket y no es necesario leer datos de √©l ahora? </li><li>  select le impone una carga innecesaria para calcular el "descriptor m√°s grande" y pasarlo como un par√°metro separado </li></ul><br>  Por supuesto, todo lo anterior no es ninguna noticia.  Los desarrolladores de sistemas operativos han sido conscientes de estos problemas y muchos de ellos se tuvieron en cuenta al dise√±ar el m√©todo de encuesta.  En este punto, usted puede preguntar, ¬øpor qu√© estamos estudiando historia antigua ahora, y hay alguna raz√≥n hoy para usar el antiguo?  S√≠, hay dos de esos motivos.  No es el hecho de que te sean √∫tiles alguna vez, sino por qu√© no descubrirlos. <br><br>  La primera raz√≥n es la portabilidad.  select () ha estado con nosotros durante un mill√≥n de a√±os.  No importa lo que le traiga la jungla de las plataformas de hardware y software, si hay una red all√≠, habr√° una selecci√≥n.  Puede que no haya otros m√©todos, pero select estar√° casi garantizado.  Y no piense que ahora estoy cayendo en la senilidad senil y recuerdo algo como tarjetas perforadas y ENIAC, no.  No hay un m√©todo de encuesta m√°s moderno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, por ejemplo, en Windows XP</a> .  Pero seleccionar es. <br><br>  La segunda raz√≥n es m√°s ex√≥tica y est√° relacionada con el hecho de que select puede (en teor√≠a) trabajar con tiempos de espera del orden de un nanosegundo (si el hardware lo permite), mientras que sondeo y epoll solo admiten una precisi√≥n de milisegundos.  Esto no deber√≠a desempe√±ar un papel especial en los escritorios comunes (o incluso en los servidores), donde todav√≠a no tiene un temporizador de precisi√≥n de nanosegundos de hardware.  Pero a√∫n en el mundo hay sistemas en tiempo real que tienen tales temporizadores.  As√≠ que te ruego, cuando escribas el firmware de un reactor nuclear o cohete, no seas demasiado vago para medir el tiempo en nanosegundos.  Sabes, quiero vivir. <br><br>  El caso descrito anteriormente es probablemente el √∫nico en el que realmente no tiene elecci√≥n qu√© usar (solo seleccionar es adecuado).  Sin embargo, si est√° escribiendo una aplicaci√≥n regular para trabajar en hardware ordinario, y operar√° con un n√∫mero adecuado de sockets (decenas, cientos, y no m√°s), entonces la diferencia en el rendimiento de la encuesta y la selecci√≥n no ser√° notable, por lo que la elecci√≥n se basar√° en otros factores. <br><br><h3>  Encuesta con encuesta () </h3><br>  poll es un m√©todo m√°s nuevo de sondeo de sockets, creado despu√©s de que las personas comenzaron a intentar escribir servicios de red grandes y muy cargados.  Est√° dise√±ado mucho mejor y no sufre la mayor√≠a de los inconvenientes del m√©todo seleccionado.  En la mayor√≠a de los casos, al escribir aplicaciones modernas, elegir√°s entre usar poll y epoll / libevent. <br><br>  Para usar poll, un desarrollador necesita inicializar miembros de la estructura pollfd con descriptores y eventos observables, y luego llamar a poll (). <br>  Un c√≥digo t√≠pico se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   struct pollfd fds[2]; //  sock1      fds[0].fd = sock1; fds[0].events = POLLIN; //   sock2 -  fds[1].fd = sock2; fds[1].events = POLLOUT; //   10  int ret = poll( &amp;fds, 2, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //  ,  revents      if ( pfd[0].revents &amp; POLLIN ) pfd[0].revents = 0; //     sock1 if ( pfd[1].revents &amp; POLLOUT ) pfd[1].revents = 0; //     sock2 }</span></span></code> </pre> <br>  La encuesta se cre√≥ para resolver los problemas del m√©todo select, veamos c√≥mo result√≥: <br><br><ul><li>  No hay l√≠mite para el n√∫mero de descriptores observados; se pueden monitorear m√°s de 1024 </li><li>  La estructura pollfd no se modifica, lo que hace posible reutilizarla entre llamadas a poll (); solo necesita restablecer el campo revents. </li><li>  Los eventos observados est√°n mejor estructurados.  Por ejemplo, puede determinar si un cliente remoto est√° desconectado sin tener que leer los datos del socket. </li></ul><br>  Ya hablamos sobre las deficiencias del m√©todo de encuesta: no est√° disponible en algunas plataformas, como Windows XP.  Desde Vista, existe, pero se llama WSAPoll.  El prototipo es el mismo, por lo que para el c√≥digo independiente de la plataforma puede escribir una anulaci√≥n, como: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (WIN32) static inline int poll( struct pollfd *pfd, int nfds, int timeout) { return WSAPoll ( pfd, nfds, timeout ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Bueno, la precisi√≥n de los tiempos de espera es de 1 ms, lo que rara vez ser√° suficiente.  Sin embargo, la encuesta tiene otras desventajas: <br><br><ul><li>  Al igual que con el uso de select, es imposible determinar qu√© descriptores generaron los eventos sin un pase completo a trav√©s de todas las estructuras observadas y verificar los campos revents en ellos.  Peor a√∫n, tambi√©n se implementa en el n√∫cleo del sistema operativo. </li><li>  Al igual que con select, no hay forma de cambiar din√°micamente el conjunto de eventos observados </li></ul><br>  Sin embargo, todo lo anterior puede considerarse relativamente insignificante para la mayor√≠a de las aplicaciones cliente.  La excepci√≥n es probablemente solo protocolos p2p, donde cada uno de los clientes puede asociarse con miles de otros.  Estos problemas pueden ser ignorados incluso por la mayor√≠a de las aplicaciones de servidor.  Por lo tanto, la encuesta debe ser su preferencia predeterminada sobre la selecci√≥n, a menos que una de las dos razones anteriores lo limite. <br><br>  Mirando hacia el futuro, dir√© que la encuesta es preferible incluso en comparaci√≥n con el epoll m√°s moderno (discutido a continuaci√≥n) en los siguientes casos: <br><br><ul><li>  Desea escribir c√≥digo multiplataforma (epoll solo est√° en Linux) </li><li>  No necesita monitorear m√°s de 1000 sockets (epoll no le dar√° nada significativo en este caso) </li><li>  Debe supervisar m√°s de 1000 sockets, pero el tiempo de conexi√≥n con cada uno de ellos es muy peque√±o (en estos casos, el rendimiento de sondeo y epoll estar√° muy cerca; la ganancia de esperar menos eventos en epoll se tachar√° por la sobrecarga de agregarlos / eliminarlos) </li><li>  Su aplicaci√≥n no est√° dise√±ada para cambiar eventos de un hilo mientras otro los est√° esperando (o no lo necesita) </li></ul><br><h3>  Encuesta con epoll () </h3><br>  epoll es el mejor y m√°s nuevo m√©todo para esperar eventos en Linux (y solo en Linux).  Bueno, no es que el "m√°s nuevo" sea directo: ha estado en el n√∫cleo desde 2002.  Se diferencia de la encuesta y la selecci√≥n en que proporciona una API para agregar / eliminar / modificar la lista de descriptores y eventos observados. <br><br>  Usar epoll requiere preparaciones un poco m√°s exhaustivas.  El desarrollador debe: <br><br><ul><li>  Cree un descriptor de epoll llamando a epoll_create </li><li>  Inicialice la estructura epoll_event con los eventos y punteros necesarios para los contextos de conexi√≥n.  El "contexto" aqu√≠ puede ser cualquier cosa, epoll simplemente pasa ese valor en los eventos devueltos </li><li>  Llame a epoll_ctl (... EPOLL_CTL_ADD) para agregar un identificador a la lista de observables </li><li>  Llame a epoll_wait () para esperar eventos (indicamos exactamente cu√°ntos eventos queremos recibir a la vez, por ejemplo, 20).  A diferencia de los m√©todos anteriores, obtenemos estos eventos por separado y no en las propiedades de las estructuras de entrada.  Si observamos 200 descriptores y 5 de ellos recibieron nuevos datos, epoll_wait devolver√° solo 5 eventos.  Si ocurren 50 eventos, los primeros 20 nos ser√°n devueltos, y los 30 restantes esperar√°n la pr√≥xima llamada, no se perder√°n </li><li>  Proceso de eventos recibidos.  Este ser√° un procesamiento relativamente r√°pido, porque no miramos esos descriptores donde no pas√≥ nada </li></ul><br>  Un c√≥digo t√≠pico se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   epoll.       ,      //    (    ,   ),        int pollingfd = epoll_create( 0xCAFE ); if ( pollingfd &lt; 0 ) //  //   epoll_event struct epoll_event ev = { 0 }; //     .    ,   // epoll     . , ,       ev.data.ptr = pConnection1; //    ,     ev.events = EPOLLIN | EPOLLONESHOT; //     .        //      epoll_wait -    if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 ) // report error //       20    struct epoll_event pevents[ 20 ]; //  10  int ready = epoll_wait( pollingfd, pevents, 20, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //     for ( int i = 0; i &lt; ret; i++ ) { if ( pevents[i].events &amp; EPOLLIN ) { //        ,   Connection * c = (Connection*) pevents[i].data.ptr; c-&gt;handleReadEvent(); } } }</span></span></code> </pre> <br>  Comencemos con los defectos de epoll: son obvios por el c√≥digo.  Este m√©todo es m√°s dif√≠cil de usar, necesita escribir m√°s c√≥digo, hace m√°s llamadas al sistema. <br><br>  Las ventajas tambi√©n son evidentes: <br><br><ul><li>  epoll devuelve una lista de solo aquellos descriptores para los cuales ocurrieron los eventos observados.  No necesita mirar a trav√©s de miles de estructuras en busca de una, posiblemente aquella en la que funcion√≥ el evento esperado. </li><li>  Puede asociar un contexto significativo con cada evento observado.  En el ejemplo anterior, usamos un puntero a un objeto de la clase de conexi√≥n para esto; esto nos ahorr√≥ otra posible b√∫squeda de una matriz de conexiones. </li><li>  Puede agregar o quitar sockets de la lista en cualquier momento.  Incluso puede modificar los eventos observados.  Todo funcionar√° correctamente, esto est√° oficialmente respaldado y documentado. </li><li>  Puede iniciar varios subprocesos esperando eventos de la misma cola usando epoll_wait.  Algo que de ninguna manera se puede hacer con select / poll. </li></ul><br>  Pero tambi√©n debe recordar que epoll no es "una encuesta mejorada".  Tiene desventajas en comparaci√≥n con la encuesta: <br><br><ul><li>  Cambiar los indicadores de evento (por ejemplo, cambiar de LEER a ESCRIBIR) requiere una llamada adicional al sistema epoll_ctl, mientras que para la encuesta simplemente cambia la m√°scara de bits (completamente en modo de usuario).  Cambiar 5,000 sockets de lectura a escritura requerir√° 5,000 llamadas al sistema y cambios de contexto para epoll, mientras que para sondeo ser√° una operaci√≥n trivial en un bucle. </li><li>  Para cada nueva conexi√≥n, debe llamar a accept () y epoll_ctl () son dos llamadas al sistema.  Si usa la encuesta, solo habr√° una llamada.  Con una vida √∫til de conexi√≥n muy corta, esto puede marcar la diferencia. </li><li>  epoll solo est√° disponible en Linux.  Otros sistemas operativos tienen mecanismos similares, pero a√∫n no son completamente id√©nticos.  No podr√° escribir c√≥digo con epoll para que se construya y funcione, por ejemplo, en FreeBSD. </li><li>  Escribir c√≥digo paralelo altamente cargado es dif√≠cil.  Muchas aplicaciones no necesitan un enfoque tan fundamental, ya que su nivel de carga se procesa f√°cilmente utilizando m√©todos m√°s simples. </li></ul><br>  Por lo tanto, epoll solo debe usarse cuando se cumple todo lo siguiente: <br><br><ul><li>  Su aplicaci√≥n utiliza un grupo de subprocesos para manejar las conexiones de red.  La ganancia de epoll en una aplicaci√≥n de un solo subproceso ser√° insignificante, y no debe molestarse con la implementaci√≥n. </li><li>  Espera un n√∫mero relativamente grande de conexiones (de 1000 y superiores).  En un peque√±o n√∫mero de sockets observados, epoll no dar√° un aumento de rendimiento, y si hay literalmente unos pocos sockets, incluso puede disminuir la velocidad. </li><li>  Tus conexiones viven relativamente tiempo.  En una situaci√≥n en la que una nueva conexi√≥n transfiere solo unos pocos bytes de datos y se cierra all√≠ mismo, la encuesta funcionar√° m√°s r√°pido, ya que necesitar√° hacer menos llamadas al sistema para procesarla. </li><li>  Tiene la intenci√≥n de ejecutar su c√≥digo en Linux y solo en Linux. </li></ul><br>  Si uno o m√°s de los √≠tems fallan, considere usar sondeo o liberador. <br><br><h3>  liberador </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libevent</a> es una biblioteca que envuelve los m√©todos de sondeo enumerados en este art√≠culo (as√≠ como algunos otros) en una API unificada.  La ventaja aqu√≠ es que una vez que ha escrito el c√≥digo, puede compilarlo y ejecutarlo en diferentes sistemas operativos.  Sin embargo, es importante comprender que libevent es solo un envoltorio, dentro del cual funcionan todos los m√©todos anteriores, con todas sus ventajas y desventajas.  libevent no forzar√° a select para escuchar m√°s de 1024 sockets, y epoll no modificar√° la lista de eventos sin una llamada adicional al sistema.  Por lo tanto, conocer las tecnolog√≠as subyacentes sigue siendo importante. <br><br>  La necesidad de soportar diferentes m√©todos de sondeo hace que la API de la biblioteca libevent sea m√°s compleja.  Pero a√∫n as√≠, su uso es m√°s f√°cil que escribir manualmente dos motores de selecci√≥n de eventos diferentes para, por ejemplo, Linux y FreeBSD (usando epoll y kqueue). <br><br>  Considere usar libevent cuando combine dos eventos: <br><br><ul><li>  Miraste los m√©todos de selecci√≥n y encuesta y definitivamente no funcionaron para ti. </li><li>  Necesitas soportar m√∫ltiples SO </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415259/">https://habr.com/ru/post/es415259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415249/index.html">Un peque√±o paso para un programador es un gran paso para una ONG</a></li>
<li><a href="../es415251/index.html">Empleados de Amazon, Google y Microsoft protestan por la cooperaci√≥n con militares y polic√≠as</a></li>
<li><a href="../es415253/index.html">Las fotograf√≠as del siglo XIX fueron restauradas utilizando la tecnolog√≠a del siglo XXI.</a></li>
<li><a href="../es415255/index.html">Roskosmos anunci√≥ la terminaci√≥n de los vuelos de misiles Proton</a></li>
<li><a href="../es415257/index.html">8 formas de mejorar la visualizaci√≥n de datos</a></li>
<li><a href="../es415261/index.html">Artista VFX en desarrollo de juegos: caracter√≠sticas, carrera, desarrollo</a></li>
<li><a href="../es415263/index.html">C√≥mo agregamos entradas al mapa y redujimos el tama√±o de las bases en un 10%</a></li>
<li><a href="../es415265/index.html">Buscando un sucesor del KL-7: RACE y AROFLEX</a></li>
<li><a href="../es415269/index.html">C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n</a></li>
<li><a href="../es415271/index.html">C√≥mo los gr√°ficos de Gantt simplifican la gesti√≥n de proyectos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>