<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âš–ï¸ ğŸ•Œ ğŸ” Akurasi kedalaman jelas ğŸ‘¸ğŸ¾ âœŠğŸ¼ ğŸ§‘ğŸ»â€ğŸ¤â€ğŸ§‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Keakuratan kedalaman adalah rasa sakit di pantat bahwa setiap programmer grafis akan cepat atau lambat menghadapi. Banyak artikel dan karya telah ditu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akurasi kedalaman jelas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434322/">  Keakuratan kedalaman adalah rasa sakit di pantat bahwa setiap programmer grafis akan cepat atau lambat menghadapi.  Banyak artikel dan karya telah ditulis tentang hal ini.  Dan di berbagai gim dan mesin, dan pada platform yang berbeda, Anda dapat melihat banyak format dan pengaturan berbeda untuk <b>buffer kedalaman</b> . <br><br>  Konversi kedalaman pada GPU tampaknya tidak jelas karena cara berinteraksi dengan proyeksi perspektif, dan studi tentang persamaan tidak memperjelas situasi.  Untuk memahami cara kerjanya, berguna untuk menggambar beberapa gambar. <br><br><img src="https://developer.nvidia.com/sites/default/files/styles/main_image/public/akamai/gameworks/blog/Depthprecision/graph.jpg?itok=tLMbXLov" alt="gambar"><br><br>  Artikel ini dibagi menjadi 3 bagian: <br><br><ol><li>  Saya akan mencoba menjelaskan motivasi untuk transformasi kedalaman <b>nonlinier</b> . </li><li>  Saya akan menyajikan beberapa grafik yang akan membantu Anda memahami bagaimana konversi kedalaman non-linear bekerja dalam berbagai situasi, secara intuitif dan visual. </li><li>  Sebuah diskusi tentang temuan utama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengetatan Presisi Rendering Perspektif</a> [Paul Upchurch, Mathieu Desbrun (2012)] mengenai pengaruh kesalahan titik apung pada akurasi kedalaman. </li></ol><br><a name="habracut"></a><br><h2>  Kenapa 1 / z? </h2><br>  <b>Buffer kedalaman</b> GPU perangkat keras biasanya tidak menyimpan representasi linear jarak antara objek dan kamera, bertentangan dengan apa yang diharapkan secara naif dari objek tersebut pada pertemuan pertama.  Sebaliknya, buffer kedalaman menyimpan nilai yang berbanding terbalik dengan kedalaman ruang tampilan.  Saya ingin menggambarkan secara singkat motivasi untuk keputusan seperti itu. <br><br>  Dalam artikel ini, saya akan menggunakan <b>d</b> untuk merepresentasikan nilai yang disimpan dalam buffer kedalaman (dalam kisaran [0, 1] untuk DirectX), dan <b>z</b> untuk mewakili ruang tampilan kedalaman, yaitu.  Jarak sebenarnya dari kamera, dalam satuan dunia, misalnya meter.  Secara umum, hubungan di antara mereka memiliki bentuk berikut: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg" alt="gambar"><br><br>  di mana <b>a, b</b> adalah konstanta yang terkait dengan pengaturan dekat dan jauh dari pesawat.  Dengan kata lain, <b>d</b> selalu merupakan transformasi linear dari <b>1 / z</b> . <br><br>  Pada pandangan pertama, sepertinya fungsi <b>z</b> dapat diambil sebagai <b>d</b> .  Jadi mengapa dia terlihat seperti itu?  Ada dua alasan utama untuk ini. <br><br>  Pertama, <b>1 / z</b> secara alami cocok dengan proyeksi perspektif.  Dan ini adalah kelas transformasi yang paling dasar, yang dijamin untuk menjaga garis.  Oleh karena itu, proyeksi perspektif cocok untuk rasterisasi perangkat keras, karena tepi lurus segitiga tetap lurus di layar.  Kita bisa mendapatkan transformasi linear dari <b>1 / z</b> , mengambil keuntungan dari divisi perspektif yang sudah dilakukan GPU: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg" alt="gambar"><br><br>  Tentu saja, kekuatan sebenarnya dari pendekatan ini adalah bahwa matriks proyeksi dapat dikalikan dengan matriks lain, memungkinkan Anda untuk menggabungkan banyak transformasi menjadi satu. <br><br>  Alasan kedua adalah bahwa <b>1 / z</b> linear dalam ruang layar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti yang dicatat Emil Persson</a> .  Ini membuatnya mudah untuk menginterpolasi d dalam segitiga selama rasterisasi, dan hal-hal seperti <b>buffer Z hirarkis</b> , <b>Z-culling awal</b> dan <b>buffer kedalaman kompresi</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Secara singkat dari artikel</b> <div class="spoiler_text">  Sementara nilai <b>w (kedalaman ruang tampilan)</b> adalah linier dalam ruang tampilan, nilai itu non-linear dalam ruang layar.  <b>z (kedalaman)</b> , non-linear dalam ruang tampilan, di sisi lain linear dalam ruang layar.  Ini dapat dengan mudah diperiksa dengan shader DX10 sederhana: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = ddx(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dy = ddy(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000.0</span></span> * float4(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dx), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dy), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Di sini Posisi adalah SV_Posisi.  Hasilnya terlihat seperti ini: <br><br><img src="http://www.humus.name/News/ZGradient.png" alt="gambar"><br><br>  Perhatikan bahwa semua permukaan terlihat monokrom.  Perbedaan <b>z</b> dari pixel ke pixel adalah sama untuk primitif manapun.  Ini sangat penting untuk GPU.  Salah satu alasannya adalah bahwa interpolasi <b>z</b> lebih murah daripada interpolasi <b>w</b> .  Untuk <b>z,</b> tidak perlu melakukan koreksi perspektif.  Dengan unit perangkat keras yang lebih murah, Anda dapat memproses lebih banyak piksel per siklus dengan anggaran yang sama untuk transistor.  Secara alami, ini sangat penting untuk <b>pra-z pass</b> dan <b>shadow map</b> .  Dengan perangkat keras modern, linearitas dalam ruang layar juga merupakan fitur yang sangat berguna untuk optimasi z.  Mengingat bahwa gradien linier untuk seluruh primitif, juga relatif mudah untuk menghitung kisaran kedalaman yang tepat di dalam ubin untuk <b>Hi-z culling</b> .  Ini juga berarti bahwa <b>z-kompresi</b> dimungkinkan.  Dengan constantz konstan dalam <b>x</b> dan <b>y,</b> Anda tidak perlu menyimpan banyak informasi untuk dapat sepenuhnya mengembalikan semua nilai <b>z</b> dalam ubin, asalkan primitif telah menutupi seluruh ubin. <br></div></div><br><h2>  Bagan Kedalaman </h2><br>  Persamaan itu rumit, mari kita lihat beberapa gambar! <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg" alt="gambar"><br><br>  Cara membaca grafik ini dari kiri ke kanan, lalu ke bawah.  Mulai dengan <b>d</b> pada sumbu kiri.  Karena <b>d</b> dapat berupa transformasi linear sewenang-wenang dari <b>1 / z</b> , kita dapat mengatur 0 dan 1 di tempat yang nyaman pada sumbu.  Tanda menunjukkan nilai <b>buffer kedalaman yang</b> berbeda.  Untuk tujuan kejelasan, saya memodelkan <b>penyangga kedalaman</b> dinormalisasi 4-bit integer, jadi ada 16 tanda spasi yang sama. <br><br>  Grafik di atas menunjukkan konversi kedalaman vanila "standar" ke D3D dan API serupa.  Anda dapat segera melihat bagaimana, karena kurva <b>1 / z</b> , nilai-nilai yang dekat dengan bidang yang dekat dikelompokkan, dan nilai-nilai yang dekat dengan bidang yang jauh tersebar. <br><br>  Juga mudah untuk memahami mengapa dekat pesawat sangat mempengaruhi akurasi kedalaman.  Jarak di dekat bidang akan menyebabkan peningkatan cepat dalam nilai-nilai <b>d</b> relatif terhadap nilai-nilai <b>z</b> , yang akan mengarah pada distribusi nilai yang bahkan lebih tidak rata: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg" alt="gambar"><br><br>  Demikian pula, dalam konteks ini, mudah untuk melihat mengapa memindahkan pesawat jauh ke tak terhingga tidak memiliki efek yang begitu besar.  Itu hanya berarti memperluas rentang <b>d</b> ke <b>1 / z = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg" alt="gambar"><br><br>  Tapi bagaimana dengan kedalaman floating-point?  Grafik berikut telah ditambahkan tanda yang sesuai dengan format float dengan 3 bit eksponen dan 3 bit mantissa: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg" alt="gambar"><br><br>  Sekarang dalam kisaran [0,1] ada 40 nilai yang berbeda - sedikit lebih dari 16 nilai sebelumnya, tetapi kebanyakan dari mereka tidak berguna dikelompokkan dekat dengan pesawat dekat (mendekati 0 float memiliki akurasi lebih tinggi), di mana kita benar-benar tidak membutuhkan banyak akurasi. <br><br>  Sekarang trik terkenal adalah membalikkan kedalaman, menampilkan bidang dekat pada <b>d = 1</b> dan bidang jauh pada <b>d = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg" alt="gambar"><br><br>  Jauh lebih baik!  Sekarang distribusi quasi-logaritmik dari float entah bagaimana mengompensasi non-linearitas <b>1 / z</b> , sementara lebih dekat ke pesawat dekat itu memberikan akurasi yang mirip dengan buffer kedalaman bilangan bulat, dan memberikan akurasi yang lebih besar di tempat lain.  Akurasi kedalaman menurun dengan sangat lambat jika Anda bergerak lebih jauh dari kamera. <br><br>  Trik <b>terbalik-Z</b> mungkin telah ditemukan kembali secara independen beberapa kali, tetapi setidaknya yang pertama disebutkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makalah SIGGRAPH '99</a> [Eugene Lapidous dan Guofang Jiao (sayangnya tidak tersedia untuk umum)].  Dan baru-baru ini, ia disebutkan kembali di blog oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Matt Petineo</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brano Kemen</a> , dan dalam pidato oleh Emil Persson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Making</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vast Game Worlds</a> SIGGRAPH 2012. <br><br>  Semua grafik sebelumnya mengasumsikan kisaran kedalaman [0,1] setelah proyeksi, yang merupakan konvensi dalam D3D.  Bagaimana dengan <b>OpenGL</b> ? <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg" alt="gambar"><br><br>  <b>OpenGL</b> secara default mengasumsikan kisaran kedalaman [-1, 1] setelah proyeksi.  Untuk format integer, tidak ada yang berubah, tetapi untuk floating-point semua akurasi terkonsentrasi tidak berguna di tengah.  (Nilai kedalaman dipetakan ke kisaran [0,1] untuk penyimpanan selanjutnya di buffer kedalaman, tetapi ini tidak membantu, karena pemetaan awal ke [-1,1] telah menghancurkan semua akurasi di separuh jauh rentang.) Dan karena simetri, triknya <b>terbalik-Z</b> tidak akan berfungsi di sini. <br><br>  Untungnya, di desktop OpenGL, ini dapat diperbaiki menggunakan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ARB_clip_control yang</a> didukung secara luas (juga dimulai dengan OpenGL 4.5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">glClipControl</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar</a> ).  Sayangnya, GL ES sedang dalam penerbangan. <br><br><h2>  Efek kesalahan pembulatan </h2><br>  Konversi <b>1 / z</b> dan pilihan <b>float vs int depth buffer</b> adalah bagian besar dari kisah akurasi, tetapi tidak semua.  Bahkan jika Anda memiliki akurasi kedalaman yang cukup untuk mewakili adegan yang ingin Anda render, mudah untuk menurunkan akurasi dengan kesalahan aritmatika selama proses konversi vertex. <br><br>  Di awal artikel, disebutkan bahwa Upchurch dan Desbrun mempelajari masalah ini.  Mereka mengusulkan dua rekomendasi utama untuk meminimalkan kesalahan pembulatan: <br><br><ol><li>  Gunakan pesawat jauh tak terbatas. </li><li>  Jauhkan matriks proyeksi terpisah dari matriks lain, dan terapkan itu sebagai operasi terpisah di vertex shader, daripada menggabungkannya dengan view matrix. </li></ol><br>  Upchurch dan Desbrun membuat rekomendasi ini menggunakan metode analitis berdasarkan pemrosesan kesalahan pembulatan sebagai kesalahan acak kecil yang disajikan dalam setiap operasi aritmatika dan melacaknya ke urutan pertama dalam proses konversi.  Saya memutuskan untuk menguji hasilnya dalam praktik. <br><br>  Sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> adalah Python 3.4 dan numpy.  Program ini bekerja sebagai berikut: urutan titik acak dihasilkan, diurutkan berdasarkan kedalaman, terletak secara linear atau logaritmik antara pesawat dekat dan jauh.  Kemudian poin dikalikan dengan matriks tampilan dan proyeksi dan pembagian perspektif dilakukan, menggunakan float 32-bit, dan secara opsional hasil akhir dikonversi ke int 24-bit.  Pada akhirnya, ia melewati urutan dan menghitung berapa kali 2 titik tetangga (yang awalnya memiliki kedalaman berbeda) menjadi identik, karena mereka memiliki kedalaman yang sama atau urutannya berubah sama sekali.  Dengan kata lain, program ini mengukur frekuensi terjadinya kesalahan perbandingan kedalaman - yang terkait dengan masalah seperti <b>pertempuran Z</b> - dalam berbagai skenario. <br><br>  Berikut adalah hasil untuk dekat = 0,1, jauh = 10K, dengan kedalaman linier 10K.  (Saya mencoba interval kedalaman logaritmik dan rasio dekat / jauh lainnya, dan meskipun angka-angka spesifik bervariasi, tren umum dalam hasilnya adalah sama.) <br><br>  Dalam tabel, "eq" - dua titik dengan kedalaman terdekat mendapatkan nilai yang sama di buffer kedalaman, dan "swap" - dua titik dengan kedalaman terdekat ditukar. <br><table><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="2" rowspan="1">  <b>Matriks proyeksi-tampilan komposit</b> </td><td colspan="2" rowspan="1">  <b>Matriks tampilan dan proyeksi terpisah</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>Nilai Z tidak berubah (uji kontrol)</b> </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Proyeksi standar</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Jauh tak terhingga</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Terbalik z</b> </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinite + terbalik-Z</b> </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td><td colspan="1" rowspan="1">  0% persamaan <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Standar + gaya GL</b> </td><td colspan="1" rowspan="1">  56% persamaan <br>  12% swap </td><td colspan="1" rowspan="1">  56% persamaan <br>  12% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinite + GL-style</b> </td><td colspan="1" rowspan="1">  59% persamaan <br>  10% swap </td><td colspan="1" rowspan="1">  59% persamaan <br>  10% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td></tr></tbody></table><br>  Saya minta maaf atas kenyataan bahwa tanpa grafik, ada terlalu banyak dimensi di sini dan tidak dapat membuatnya!  Bagaimanapun, melihat angka-angka, kesimpulan berikut jelas: <br><br><ul><li>  Dalam kebanyakan kasus, tidak ada perbedaan antara <b>buffer kedalaman</b> <b>int</b> dan <b>float</b> .  Kesalahan aritmatika untuk menghitung kedalaman menimpa kesalahan dalam konversi ke int.  Sebagian karena float32 dan int24 memiliki ULP yang hampir sama (satuan akurasi paling rendah adalah jarak ke nomor tetangga terdekat) sebesar [0,5.1] (karena float32 memiliki mantissa 23-bit), sehingga kesalahan konversi tidak ditambahkan ke hampir seluruh rentang kedalaman. di int. </li><li>  Dalam kebanyakan kasus, pemisahan <b>pandangan</b> dan matriks <b>proyeksi</b> (mengikuti rekomendasi Upchurch dan Desbrun) meningkatkan hasilnya.  Terlepas dari kenyataan bahwa tingkat kesalahan keseluruhan tidak menurun, "swap" menjadi nilai yang sama, dan ini merupakan langkah ke arah yang benar. </li><li>  Infinite far plane sedikit mengubah frekuensi kesalahan.  Upchurch dan Desbrun memperkirakan pengurangan 25% dalam frekuensi kesalahan numerik (kesalahan akurasi), tetapi ini tampaknya tidak mengarah pada penurunan frekuensi kesalahan perbandingan. </li></ul><br>  Namun, temuan di atas tidak nyata dibandingkan dengan sihir <b>terbalik-Z</b> .  Periksa: <br><br><ul><li>  Reversed-Z dengan buffer kedalaman mengambang memberikan <i>tingkat kesalahan nol</i> dalam pengujian.  Sekarang, tentu saja, Anda bisa mendapatkan beberapa kesalahan jika Anda terus meningkatkan interval nilai kedalaman input.  Namun, Z terbalik dengan float jauh lebih akurat daripada opsi lainnya. </li><li>  Reversed-Z dengan buffer kedalaman integer sama baiknya dengan opsi integer lainnya. </li><li>  Reversed-Z mengaburkan perbedaan antara komposit dan pandangan terpisah / proyeksi matriks, dan pesawat jauh terbatas dan tak terbatas.  Dengan kata lain, dengan Z terbalik, Anda dapat melipatgandakan proyeksi dengan matriks lain, dan menggunakan pesawat jauh yang Anda inginkan, tanpa mengurangi akurasi. </li></ul><br><h2>  Kesimpulan </h2><br>  Saya pikir kesimpulannya jelas.  Dalam situasi apa pun, ketika berhadapan dengan proyeksi perspektif, cukup gunakan <b>buffer kedalaman mengambang dan terbalik-Z</b> !  Dan jika Anda tidak dapat menggunakan buffer kedalaman float, Anda masih harus menggunakan Z terbalik.  Ini bukan obat mujarab untuk semua penyakit, terutama jika Anda menciptakan lingkungan dunia terbuka dengan rentang kedalaman ekstrem.  Tapi ini awal yang bagus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434322/">https://habr.com/ru/post/id434322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434306/index.html">Bagaimana kami memperbarui intranet dengan pemirsa harian 2K + pengguna. Tanpa anggaran</a></li>
<li><a href="../id434312/index.html">Waktu konferensi! Menjumlahkan 2018</a></li>
<li><a href="../id434314/index.html">Alternatif untuk LastPass. Evaluasi komparatif dari enam manajer kata sandi</a></li>
<li><a href="../id434316/index.html">Secret Santa, quests, quiz dan skating rink - bagaimana kami bertemu ABBYY Tahun Baru</a></li>
<li><a href="../id434320/index.html">Bagaimana kami menguji Sberbank Online di iOS</a></li>
<li><a href="../id434326/index.html">Balet di udara: levitasi partikel yang dikendalikan karena gelombang suara</a></li>
<li><a href="../id434328/index.html">Tanda tangan elektronik untuk partisipasi dalam pengadaan</a></li>
<li><a href="../id434330/index.html">Apa yang Baru di YouTrack 2018.4</a></li>
<li><a href="../id434332/index.html">Dan sekali lagi tentang KIB SearchInform: kami berurusan dengan yang terbaru</a></li>
<li><a href="../id434334/index.html">Bagaimana baghunter mencegat surat pos udara di ZeroNights</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>