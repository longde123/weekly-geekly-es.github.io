<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüè´ üò• üë®üèΩ‚Äçüè≠ Reactor, WebFlux, Kotlin Coroutines oder Asynchrony anhand eines einfachen Beispiels üçª ü§ûüèΩ üõ¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Dienste in der modernen Welt tun gr√∂√ütenteils ‚Äûnichts‚Äú. Ihre Aufgaben beschr√§nken sich darauf, andere Datenbanken / Dienste / Caches anzufordern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reactor, WebFlux, Kotlin Coroutines oder Asynchrony anhand eines einfachen Beispiels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/477052/"><img src="https://habrastorage.org/webt/oc/vm/jy/ocvmjybd42pjwnaqjaxeyz_dxlo.png"><br><br><p>  Viele Dienste in der modernen Welt tun gr√∂√ütenteils ‚Äûnichts‚Äú.  Ihre Aufgaben beschr√§nken sich darauf, andere Datenbanken / Dienste / Caches anzufordern und all diese Daten nach verschiedenen Regeln und verschiedenen Gesch√§ftslogiken zu aggregieren.  Aus diesem Grund ist es nicht verwunderlich, dass Sprachen wie Golang mit einem praktischen integrierten Wettbewerbssystem angezeigt werden, mit dem sich nicht blockierender Code einfach organisieren l√§sst. </p><br><p>  In der JVM-Welt sind die Dinge etwas komplizierter.  Es gibt eine Vielzahl von Frameworks und Bibliotheken, die Threads blockieren, wenn sie verwendet werden.  So kann stdlib selbst manchmal das Gleiche tun.  Und in Java gibt es keinen √§hnlichen Mechanismus wie in Golang. </p><br><p>  Trotzdem entwickelt sich JVM aktiv weiter und es ergeben sich neue interessante M√∂glichkeiten.  Es gibt Kotlin mit Coroutinen, die in ihrer Verwendung den Golang-Goroutinen sehr √§hnlich sind (obwohl sie auf v√∂llig andere Weise implementiert sind).  Es gibt JEP Loom, das der JVM in Zukunft Fasern bringen wird.  Eines der beliebtesten Webframeworks - Spring - hat k√ºrzlich die M√∂glichkeit hinzugef√ºgt, vollst√§ndig blockierungsfreie Dienste auf Webflux zu erstellen.  Und mit der j√ºngsten Version von Spring Boot 2.2 ist die Integration mit Kotlin noch besser. </p><br><p>  Ich schlage vor, am Beispiel eines kleinen Dienstes zum √úbertragen von Geld von einer Karte auf eine andere eine Anwendung f√ºr Spring Boot 2.2 und Kotlin zur Integration mit mehreren externen Diensten zu schreiben. </p><a name="habracut"></a><br><p>  Es ist gut, wenn Sie bereits mit Java, Kotlin, Gradle, Spring, Spring Boot 2, Reactor, Web <s>Flux, Tomcat, Netty, Kotlin Coroutines, Gradle Kotlin DSL vertraut sind oder sogar einen Doktortitel haben.</s>  Wenn nicht, spielt es keine Rolle.  Der Code wird maximal vereinfacht, und selbst wenn Sie nicht aus der JVM-Welt stammen, hoffe ich, dass Ihnen alles klar ist. </p><br><p>  Wenn Sie vorhaben, einen Dienst selbst zu schreiben, stellen Sie sicher, dass alles installiert ist, was Sie ben√∂tigen: </p><br><ul><li>  Java 8+ </li><li>  Docker und Docker Compose; </li><li>  cURL und vorzugsweise <a href="https://stedolan.github.io/jq/download/">jq</a> ; </li><li>  Git </li><li>  vorzugsweise eine IDE f√ºr Kotlin (Intellij Idea, Eclipse, VS, <s>vim</s> usw.).  Aber es ist in einem Notebook m√∂glich. </li></ul><br><p>  Die Beispiele enthalten sowohl Leerzeichen f√ºr die Implementierung im Service als auch eine bereits geschriebene Implementierung.  F√ºhren Sie zuerst die Installation und Assembly aus, und werfen Sie einen genaueren Blick auf die Dienste und ihre APIs. </p><br><blockquote> Das Beispiel f√ºr Services und API selbst dient nur zu Illustrationszwecken, √ºbertragen Sie nicht alle <code>AS IS</code> Daten auf Ihr Produkt! </blockquote><p>  Zuerst klonen wir das Repository mit den Diensten f√ºr uns selbst, die Integration, mit der wir das tun werden, und wechseln in das Verzeichnis: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/spring-demo-services &amp;&amp; cd spring-demo-services</code> </pre> <br><p>  In einem separaten Terminal sammeln wir alle Anwendungen mit <code>gradle</code> , wobei nach einem erfolgreichen Build alle Dienste mit <code>gradle</code> <code>docker-compose</code> gestartet werden. </p><br><pre> <code class="plaintext hljs">./gradlew build &amp;&amp; docker-compose up</code> </pre> <br><p>  Stellen Sie sich ein Projekt mit Diensten vor, w√§hrend alles heruntergeladen und installiert wird. </p><br><img src="https://habrastorage.org/webt/go/mp/mb/gompmbrgtjwsuz9pnpbaxbuksg8.png"><br><p>  Eine Anfrage mit einem Token, Kartennummern f√ºr die √úbertragung und dem Betrag, der zwischen den Karten √ºbertragen werden soll, wird am Eingang des Dienstes eingehen (Demo-Dienst): </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"authToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"auth-token1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardFrom"</span></span>: <span class="hljs-string"><span class="hljs-string">"55593478"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardTo"</span></span>: <span class="hljs-string"><span class="hljs-string">"55592020"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-string"><span class="hljs-string">"10.1"</span></span> }</code> </pre> <br><p>  Entsprechend dem Token <code>authToken</code> m√ºssen <code>authToken</code> zum Dienst <code>userId</code> gehen und die <code>userId</code> , mit der Sie eine Anforderung an <code>USER</code> und alle zus√§tzlichen Informationen zum Benutzer <code>userId</code> k√∂nnen.  <code>AUTH</code> gibt auch Informationen dar√ºber zur√ºck, auf welche der drei Dienste wir zugreifen k√∂nnen.  Beispielantwort von <code>AUTH</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"userId"</span></span>: <span class="hljs-number"><span class="hljs-number">158</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"paymentAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"userAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Um zwischen Karten zu wechseln, gehen Sie zun√§chst mit jeder Kartennummer in der <code>CARD</code> .  Als Antwort auf Anfragen erhalten wir eine <code>cardId</code> , mit der wir eine Anfrage an <code>PAYMENT</code> und eine √úberweisung vornehmen.  Und zum <code>PAYMENT</code> senden wir noch einmal eine Anfrage an <code>PAYMENT</code> mit <code>fromCardId</code> und ermitteln den aktuellen Kontostand. </p><br><p>  Um eine kleine Verz√∂gerung bei Diensten zu emulieren, wird der Wert der Umgebungsvariablen TIMEOUT in allen Containern ausgegeben, in denen die Antwortverz√∂gerung in Millisekunden festgelegt ist.  Und um die Antworten von <code>AUTH</code> zu diversifizieren, ist es m√∂glich, den Wert von <code>SUCCESS_RATE</code> zu variieren, der die Wahrscheinlichkeit einer <code>true</code> Antwort f√ºr den Dienst steuert. </p><br><p>  Docker-compose.yaml-Datei: </p><br><pre> <code class="plaintext hljs">version: '3' services: service-auth: build: service-auth image: service-auth:1.0.0 environment: - SUCCESS_RATE=1.0 - TIMEOUT=100 ports: - "8081:8080" service-card: build: service-card image: service-card:1.0.0 environment: - TIMEOUT=100 ports: - "8082:8080" service-payment: build: service-payment image: service-payment:1.0.0 environment: - TIMEOUT=100 ports: - "8083:8080" service-user: build: service-user image: service-user:1.0.0 environment: - TIMEOUT=100 ports: - "8084:8080"</code> </pre> <br><p>  F√ºr alle Dienste wird eine Portweiterleitung von 8081 nach 8084 durchgef√ºhrt, um sie direkt zu erreichen. </p><br><p>  Fahren wir mit dem Schreiben des <code>Demo service</code> .  Versuchen wir zun√§chst, die Implementierung so umst√§ndlich wie m√∂glich zu schreiben, ohne Asynchronit√§t und Parallelit√§t.  Dazu nehmen Sie Spring Boot 2.2.1, Kotlin und einen Blank f√ºr den Service.  Wir klonen das Repository und gehen zum Zweig <code>spring-mvc-start</code> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/demo-service &amp;&amp; cd demo-service &amp;&amp; git checkout spring-mvc-start</code> </pre> <br><p>  Gehen Sie zur <code>demo.Controller</code> Datei.  Es hat die einzige leere <code>processRequest</code> Methode, f√ºr die eine Implementierung geschrieben werden muss. </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { .. }</code> </pre> <br><p>  Eine Aufforderung zur √úbertragung zwischen Karten erhalten Sie am Eingang der Methode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRequest</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authToken: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFrom: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardTo: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: BigDecimal )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">F√ºr diejenigen, die Spring nicht kennen</b> <div class="spoiler_text"><p>  Spring verf√ºgt √ºber eine integrierte DI, die auf Anmerkungen basiert.  Der DemoController ist mit der speziellen Anmerkung RestController gekennzeichnet: Er registriert nicht nur die Bean in der DI, sondern f√ºgt auch deren Verarbeitung als Controller hinzu.  PostProcessor findet alle mit der <code>PostMapping</code> Annotation markierten Methoden und f√ºgt sie mit der <code>POST</code> Methode als Endpunkt f√ºr den Service hinzu. </p><br><p>  Der Handler erstellt auch eine Proxy-Klasse f√ºr den DemoController, in der alle erforderlichen Argumente an die <code>processRequest</code> Methode √ºbergeben werden.  In unserem Fall ist dies nur ein Argument, das mit der Annotation <code>@RequestBody</code> .  Daher wird diese Methode im Proxy mit dem in der <code>ServiceRequest</code> Klasse deserialisierten JSON-Inhalt <code>ServiceRequest</code> . </p></div></div><br><p>  Um es einfacher zu machen, wurden bereits alle Methoden zur Integration mit anderen Diensten durchgef√ºhrt. Sie m√ºssen sie nur richtig verbinden.  Es gibt nur f√ºnf Methoden, eine f√ºr jede Aktion.  Aufrufe an andere Dienste selbst werden im <strong>Blockierungsaufruf von</strong> Spring <code>RestTemplate</code> implementiert. </p><br><p>  Beispielmethode zum Aufrufen von <code>AUTH</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: AuthInfo { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/{token}"</span></span>, AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">token) .body ?: throw RuntimeException</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"couldn't find user by token='</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">'"</span></span>) }</code> </pre> <br><p>  Fahren wir mit der Implementierung der Methode fort.  Die Kommentare zeigen die Prozedur und welche Antwort am Ausgang erwartet wird: </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-comment"><span class="hljs-comment">//1) get auth info from service by token -&gt; userId //2) find user info by userId from 1. //3) 4) find cards info for each card in serviceRequest // 5) make transaction for known cards by calling sendMoney(id1, id2, amount) // 6) after payment get payment info by fromCardId TODO("return SuccessResponse") // SuccessResponse( // amount = , // userName = , // userSurname = , // userAge = // ) }</span></span></code> </pre> <br><p>  Zun√§chst implementieren wir die Methode so einfach wie m√∂glich, ohne zu ber√ºcksichtigen, dass <code>AUTH</code> uns den Zugriff auf andere Dienste verweigern kann.  Versuchen Sie es selbst zu tun.  Wenn sich herausstellt (oder nachdem Sie in den <code>spring-mvc</code> Zweig <code>spring-mvc</code> ), k√∂nnen Sie die Funktionsweise des Dienstes wie folgt √ºberpr√ºfen: </p><br><div class="spoiler">  <b class="spoiler_title">umsetzung von spring-mvc branch</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = findUser(authInfo.userId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = findCardInfo(serviceRequest.cardFrom) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = findCardInfo(serviceRequest.cardTo) sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = getPaymentInfo(cardFromInfo.cardId) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Starten Sie den Dienst (aus dem Demo-Dienst-Ordner): </p><br><pre> <code class="plaintext hljs">./gradlew bootRun</code> </pre> <br><p>  Wir senden eine Anfrage an den Endpunkt: </p><br><pre> <code class="plaintext hljs">./demo-request.sh</code> </pre> <br><p>  Als Antwort erhalten wir so etwas: </p><br><pre> <code class="plaintext hljs">‚ûú demo-service git:(spring-mvc) ‚úó ./demo-request.sh + curl -XPOST http://localhost:8080/ -d @demo-payment-request.json -H 'Content-Type: application/json; charset=UTF-8' + jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 182 0 85 100 97 20 23 0:00:04 0:00:04 --:--:-- 23 { "amount": 989.9, "userName": "Vasia", "userSurname": "Pupkin", "userAge": 18, "status": true }</code> </pre> <br><p>  Insgesamt m√ºssen Sie 6 Anfragen stellen, um den Service zu implementieren.  Und da jeder von ihnen mit einer Verz√∂gerung von 100 ms antwortet, kann die Gesamtzeit nicht weniger als 600 ms betragen.  In der Realit√§t ergeben sich unter Ber√ºcksichtigung des gesamten Overheads etwa 700 ms.  Bisher ist der Code recht einfach, und wenn wir jetzt eine <code>AUTH</code> Antwortpr√ºfung f√ºr den Zugriff auf andere Dienste hinzuf√ºgen m√∂chten, ist dies nicht schwierig (wie bei jedem anderen Refactoring). </p><br><p>  Aber lassen Sie uns dar√ºber nachdenken, wie Sie die Ausf√ºhrung von Abfragen beschleunigen k√∂nnen.  Wenn Sie die √úberpr√ºfung der Antwort von <code>AUTH</code> nicht ber√ºcksichtigen, haben wir zwei unabh√§ngige Aufgaben: </p><br><ul><li>  <code>userId</code> Benutzer- <code>userId</code> und Anfordern von Daten von <code>USER</code> ; </li><li>  <code>cardId</code> f√ºr jede Karte erhalten, eine Zahlung <code>cardId</code> und den Gesamtbetrag erhalten. </li></ul><br><p>  Diese Aufgaben k√∂nnen unabh√§ngig voneinander durchgef√ºhrt werden.  Die Gesamtausf√ºhrungszeit h√§ngt dann von der l√§ngsten Kette von Aufrufen ab (in diesem Fall von der zweiten) und wird insgesamt f√ºr 300 ms + X ms Overhead ausgef√ºhrt. </p><br><p>  Da die Aufrufe selbst blockiert sind, besteht die einzige M√∂glichkeit, parallele Anforderungen auszuf√ºhren, darin, sie auf separaten Threads auszuf√ºhren.  Sie k√∂nnen f√ºr jeden Aufruf einen eigenen Thread erstellen, dies ist jedoch sehr teuer.  Eine andere M√∂glichkeit besteht darin, Aufgaben in ThreadPool auszuf√ºhren.  Auf den ersten Blick sieht eine solche L√∂sung angemessen aus und die Zeit wird sich verk√ºrzen.  Beispielsweise k√∂nnen wir Abfragen auf CompletableFuture ausf√ºhren.  Sie k√∂nnen Hintergrundaufgaben ausf√ºhren, indem Sie Methoden mit dem <code>async</code> Postfix aufrufen.  Wenn Sie beim Aufrufen von Methoden keinen bestimmten ThreadPool angeben, werden Tasks in <code>ForkJoinPool.commonPool()</code> gestartet.  Versuchen Sie, eine Implementierung selbst zu schreiben, oder gehen Sie zum Zweig <code>spring-mvc-async</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Implementierung aus dem Bereich spring-mvc-async</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfoFuture = CompletableFuture.supplyAsync { getAuthInfo(serviceRequest.authToken) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoFuture = authInfoFuture.thenApplyAsync { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> waitAll = CompletableFuture.allOf(cardFromInfo, cardToInfo) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoFuture = waitAll .thenApplyAsync { sendMoney(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, cardToInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, serviceRequest.amount) } .thenApplyAsync { getPaymentInfo(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Wenn wir jetzt die Anforderungszeit messen, wird sie im Bereich von 360 ms liegen.  Gegen√ºber der Originalversion hat sich die Gesamtzeit um fast das 2-fache verringert.  Der Code selbst ist etwas komplizierter geworden, aber bis jetzt ist es nicht schwierig, ihn zu √§ndern.  Und wenn wir hier eine Antwortpr√ºfung von <code>AUTH</code> hinzuf√ºgen m√∂chten, ist dies nicht schwierig. </p><br><p>  Aber was ist, wenn wir eine gro√üe Anzahl eingehender Anfragen f√ºr den Dienst selbst haben?  Sagen Sie etwa 1000 gleichzeitige Anfragen?  Bei diesem Ansatz stellt sich schnell heraus, dass alle ThreadPool-Threads damit besch√§ftigt sind, Aufrufe zu blockieren.  Und wir kommen zu dem Schluss, dass die aktuelle Version auch nicht passt. </p><br><p>  Es bleibt nur noch etwas mit den Serviceaufrufen selbst zu tun.  Sie k√∂nnen Abfragen √§ndern und sie nicht blockieren.  Dann geben die Methoden zum Aufrufen der Services CompletableFuture, Flux, Observable, Deferred, Promise oder ein √§hnliches Objekt zur√ºck, auf dem eine Kette von Erwartungen aufgebaut werden kann.  Mit diesem Ansatz m√ºssen wir keine Aufrufe f√ºr separate Streams t√§tigen. Es reicht aus, einen (oder zumindest einen kleinen separaten Pool von Streams) zu haben, den wir bereits f√ºr die Verarbeitung von Anforderungen ausgeliehen haben. </p><br><p>  K√∂nnen wir jetzt der hohen Belastung des Dienstes standhalten?  Um diese Frage zu beantworten, werfen Sie einen Blick auf Tomcat, das in Spring Boot 2.2.1 im Starter <code>org.springframework.boot:spring-boot-starter-web</code> .  Es ist so aufgebaut, dass f√ºr jede eingehende Anforderung ein Thread aus ThreadPool f√ºr dessen Verarbeitung zugewiesen wird.  Und wenn kein freier Datenfluss besteht, werden neue Anforderungen zu einer Warteschlange.  Unser Dienst selbst sendet jedoch nur Anfragen an andere Dienste.  Ordnen Sie einen ganzen Stream darunter zu und blockieren Sie ihn, bis Antworten von allen kommen, um es milde auszudr√ºcken, √ºberfl√ºssig. </p><br><p>  Gl√ºcklicherweise hat Spring k√ºrzlich die Verwendung eines nicht blockierenden Webservers auf Basis von Netty oder Undertow erm√∂glicht.  Dazu m√ºssen Sie nur den <code>spring-boot-starter-web</code> <code>spring-boot-starter-webflux</code> in <code>spring-boot-starter-webflux</code> √§ndern und die Methode f√ºr die Verarbeitung von Anforderungen, in denen die Anforderung und die Antwort in Mono "verpackt" werden, geringf√ºgig √§ndern.  Dies liegt an der Tatsache, dass Webflux auf der Basis von Reactor erstellt wurde und daher jetzt in der Methode eine Kette von Mono-Transformationen erstellt werden muss. <br></p><p>  Versuchen Sie, Ihre eigene nicht blockierende Implementierung der Methode zu schreiben.  Gehen Sie dazu in den Zweig <code>spring-webflux-start</code> .  Beachten Sie, dass der Starter f√ºr Spring Boot ge√§ndert wurde, wobei jetzt die Version mit Webflux verwendet wird, und die Implementierung von Anforderungen an andere Dienste, die f√ºr die Verwendung des nicht blockierenden <code>WebClient</code> ebenfalls ge√§ndert wurde. </p><br><p>  Beispielmethode zum Aufrufen von AUTH: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;AuthInfo&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebClient.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() .uri(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">"</span></span>) .retrieve() .bodyToMono(AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  Die Implementierung des ersten Beispiels wird in einem Kommentar in den Inhalt der <code>processRequest</code> Methode eingef√ºgt.  Versuchen Sie, es in Reactor selbst neu zu schreiben.  Machen Sie wie beim letzten Mal zuerst die Version, ohne die Pr√ºfungen von <code>AUTH</code> zu ber√ºcksichtigen, und sehen Sie dann, wie schwierig es ist, sie hinzuzuf√ºgen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-comment"><span class="hljs-comment">// val authInfo = getAuthInfo(serviceRequest.authToken) // // val userInfo = findUser(authInfo.userId) // // val cardFromInfo = findCardInfo(serviceRequest.cardFrom) // val cardToInfo = findCardInfo(serviceRequest.cardTo) // // sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) // // val paymentInfo = getPaymentInfo(cardFromInfo.cardId) // // log.info("result") // // return SuccessResponse( // amount = paymentInfo.currentAmount, // userName = userInfo.name, // userSurname = userInfo.surname, // userAge = userInfo.age // ) TODO() }</span></span></code> </pre> <br><p>  Nachdem Sie sich damit besch√§ftigt haben, k√∂nnen Sie sich mit meiner Implementierung aus dem <code>spring-webflux</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Umsetzung aus der spring-webflux-Branche</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cacheRequest = serviceRequest.cache() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoMono = cacheRequest.flatMap { getAuthInfo(it.authToken) }.flatMap { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoMono = cacheRequest.flatMap { findCardInfo(it.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoMono = cacheRequest.flatMap { findCardInfo(it.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoMono = cardFromInfoMono.zipWith(cardToInfoMono) .flatMap { (cardFromInfo, cardToInfo) -&gt; cacheRequest.flatMap { request -&gt; sendMoney(cardFromInfo.cardId, cardToInfo.cardId, request.amount).map { cardFromInfo } } }.flatMap { getPaymentInfo(it.cardId) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userInfoMono.zipWith(paymentInfoMono) .map { (userInfo, paymentInfo) -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) } }</code> </pre> </div></div><br><p>  Stimmen Sie zu, dass das Schreiben einer Implementierung (im Vergleich zum vorherigen Blockierungsansatz) schwieriger geworden ist.  Und wenn wir "vergessene" Schecks von <code>AUTH</code> hinzuf√ºgen wollen, ist dies nicht so einfach. </p><br><p>  Dies ist der Kern des reaktiven Ansatzes.  Es eignet sich hervorragend zum Aufbau von unverzweigten Verarbeitungsketten.  Wenn jedoch eine Verzweigung auftritt, ist der Code nicht mehr so ‚Äã‚Äãeinfach. </p><br><p>  Kotlin-Coroutinen, die mit jedem asynchronen / reaktiven Code sehr vertraut sind, k√∂nnen hier Abhilfe schaffen.  Dar√ºber hinaus gibt es eine gro√üe Anzahl schriftlicher Wrapper f√ºr <a href="">Reactor</a> , <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">CompletableFuture</a> usw.  Aber auch wenn Sie nicht den richtigen finden, k√∂nnen Sie ihn mit speziellen <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html">Buildern</a> immer selbst schreiben. </p><br><p>  Lassen Sie uns die Implementierung f√ºr Coroutinen selbst umschreiben.  Gehen Sie dazu in den Zweig <code>spring-webflux-coroutines-start</code> .  Die erforderlichen Abh√§ngigkeiten werden in build.gradle.kts hinzugef√ºgt: </p><br><pre> <code class="kotlin hljs">implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactive:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Und die <code>processRequest</code> Methode √§ndert sich ein <code>processRequest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { <span class="hljs-comment"><span class="hljs-comment">//TODO() }</span></span></code> </pre> <br><p>  Es ben√∂tigt kein Mono mehr und wird einfach in eine Suspend-Funktion umgewandelt (dank der Integration von Spring und Kotlin).  In Anbetracht der Tatsache, dass wir zus√§tzliche Coroutinen in der Methode erstellen werden, m√ºssen wir ein untergeordnetes Scout- <code>coroutineScope</code> erstellen (um die Gr√ºnde f√ºr das Erstellen eines zus√§tzlichen Scopes zu verstehen, siehe Roman Elizarovs Beitrag √ºber <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">strukturierte Parallelit√§t</a> ).  Bitte beachten Sie, dass sich andere Serviceabrufe √ºberhaupt nicht ge√§ndert haben.  Sie geben dasselbe Mono zur√ºck, in dem die Methode awaitFirst <code>suspend</code> aufgerufen werden kann, um auf das Ergebnis der Abfrage zu warten. </p><br><p>  Wenn Coroutinen f√ºr Sie immer noch ein neues Konzept sind, gibt es eine wunderbare <a href="">Anleitung</a> mit einer detaillierten Beschreibung.  Versuchen Sie, eine eigene Implementierung der <code>processRequest</code> Methode zu <code>processRequest</code> , oder gehen Sie zum Zweig <code>spring-webflux-coroutines</code> : </p><br><div class="spoiler">  <b class="spoiler_title">umsetzung aus dem bereich spring-webflux-coroutines</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { log.info(<span class="hljs-string"><span class="hljs-string">"start"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken).awaitFirst() findUser(authInfo.userId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoDeferred = async { findCardInfo(serviceRequest.cardFrom).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoDeferred = async { findCardInfo(serviceRequest.cardTo).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = cardFromInfoDeferred.await() sendMoney(cardFromInfo.cardId, cardToInfoDeferred.await().cardId, serviceRequest.amount).awaitFirst() getPaymentInfo(cardFromInfo.cardId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoDeferred.await() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoDeferred.await() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Sie k√∂nnen den Code mit dem reaktiven Ansatz vergleichen.  Bei Coroutinen m√ºssen Sie nicht alle Verzweigungspunkte im Voraus durchdenken.  Wir k√∂nnen einfach <code>await</code> Methoden aufrufen und asynchrone Tasks asynchron an den richtigen Stellen verzweigen.  Der Code bleibt so √§hnlich wie m√∂glich der urspr√ºnglichen, unkomplizierten Version, die √ºberhaupt nicht schwer zu √§ndern ist.  Ein wichtiger Faktor ist, dass Koroutinen einfach in reaktiven Code eingebettet sind. </p><br><p>  Vielleicht gef√§llt Ihnen der reaktive Ansatz f√ºr diese Aufgabe sogar besser, aber viele der Befragten finden es schwieriger.  Im Allgemeinen l√∂sen beide Ans√§tze ihr Problem, und Sie k√∂nnen dasjenige verwenden, das Ihnen gef√§llt.  √úbrigens gibt es in letzter Zeit in Kotlin auch die M√∂glichkeit, mit Flow ‚Äûkalte‚Äú Coroutinen zu erstellen, die dem Reaktor sehr √§hnlich sind.  Sie befinden sich zwar noch im experimentellen Stadium, aber jetzt k√∂nnen Sie sich die aktuelle Implementierung ansehen und sie in Ihrem Code ausprobieren. </p><br><p>  Ich m√∂chte hier enden und endlich n√ºtzliche Links hinterlassen: </p><br><ul><li>  <a href="">Coroutine-F√ºhrer</a> </li><li>  <a href="">Coroutinen-Reaktor</a> </li><li>  <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">Coroutines CompletableFuture</a> </li><li>  <a href="https://www.youtube.com/results%3Fsearch_query%3D%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B2%2B%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%2B%25D0%25BA%25D0%25BE%25D1%2580%25D1%2583%25D1%2582%25D0%25B8%25D0%25BD%25D1%258B">Roman Elizarov √ºber Koroutinen</a> </li><li>  <a href="https://medium.com/%40elizarov/kotlin-flows-and-coroutines-256260fb3bdb">Kotlin Flows und Coroutinen</a> </li><li>  <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">Strukturierte Parallelit√§t</a> </li><li>  <a href="https://blog.karumi.com/spring-boot-loves-kotlin/">Spring Boot liebt Kotlin</a> </li></ul><br><p>  Ich hoffe, Sie waren interessiert und haben es geschafft, eine Implementierung der Methode f√ºr alle Methoden selbst zu schreiben.  Und nat√ºrlich m√∂chte ich glauben, dass Ihnen die Option mit Coroutinen besser gef√§llt =) </p><br><p>  Vielen Dank an alle, die bis zum Ende gelesen haben! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477052/">https://habr.com/ru/post/de477052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477042/index.html">Monte Carlo Blackjack Strategieoptimierung</a></li>
<li><a href="../de477044/index.html">Automatisierung von End-2-End-Tests eines integrierten Informationssystems. Teil 2. Technische</a></li>
<li><a href="../de477046/index.html">.Net Meetup bei der Raiffeisenbank 28/11 + Broadcast</a></li>
<li><a href="../de477048/index.html">Warum hat ein Unternehmen mit einem Kapital von 55 Milliarden US-Dollar daran gedacht, die B√∂rse zu verlassen?</a></li>
<li><a href="../de477050/index.html">Black Friday 2019 f√ºr Video√ºberwachung und Wolken.</a></li>
<li><a href="../de477054/index.html">Webasto k√ºndigt modulares Fahrzeugbatteriesystem an</a></li>
<li><a href="../de477058/index.html">Enterprise Agile Russia bei der Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../de477060/index.html">DataArt wird einen offenen Vortrag von Andrei Terekhov, Leiter der Abteilung f√ºr Systemprogrammierung, Matmekh, St. Petersburg State University, halten</a></li>
<li><a href="../de477062/index.html">Wie der optimierende Compiler funktioniert</a></li>
<li><a href="../de477072/index.html">Kundenentwicklung oder wie man ein Produkt ohne Fehler einf√ºhrt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>