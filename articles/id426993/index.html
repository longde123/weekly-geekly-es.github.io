<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’†ğŸ¿ ğŸ‘©â€ğŸ”¬ ğŸ“¶ Apakah saya perlu belajar C untuk memahami cara kerja komputer? ğŸ‘¨ğŸ½â€âœˆï¸ ğŸ›°ï¸ ğŸˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya sering mendengar orang menyarankan belajar C. untuk memahami kinerja komputer. Apakah itu ide yang bagus? Apakah kamu yakin Saya akan segera meng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah saya perlu belajar C untuk memahami cara kerja komputer?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426993/">  Saya sering mendengar orang menyarankan belajar C. untuk memahami kinerja komputer. Apakah itu ide yang bagus?  Apakah kamu yakin  Saya akan segera menguraikan kesimpulan artikel, hanya untuk kejelasan mutlak: <br><br><ul><li>  C bukan cara komputer bekerja. </li><li>  Saya tidak berpikir kebanyakan orang berbicara secara harfiah, jadi itu tidak masalah. </li><li>  Memahami konteks berarti bahwa belajar C untuk alasan ini mungkin masih masuk akal, tergantung pada tujuan Anda. </li></ul><br>  Saya berencana untuk menulis dua artikel lagi dengan penjelasan yang lebih terperinci dari kesimpulan, tetapi ini sudah cukup.  Tambahkan tautan di sini saat artikel keluar. <br><a name="habracut"></a><br>  Saya sering mendengar dari orang-orang ini: <br><br><blockquote> Dengan mempelajari C, Anda dapat memahami cara kerja komputer. </blockquote><br>  Saya tidak berpikir bahwa idenya awalnya salah, tetapi memiliki beberapa keberatan.  Jika Anda mengingatnya, itu bisa menjadi strategi yang layak untuk mempelajari hal-hal baru dan penting.  Namun, saya jarang melihat orang membahas reservasi ini secara rinci, jadi saya menulis artikel ini untuk memberikan, menurut pendapat saya, konteks yang sangat diperlukan ... Jika Anda berpikir tentang belajar C untuk memahami cara kerja komputer Anda, maka artikel ini adalah untuk Anda.  Saya harap dia membantu Anda mengetahuinya. <br><br><blockquote>  Sebelum kita benar-benar memulai, saya ingin mengatakan satu hal lagi: jika Anda ingin belajar C, maka belajarlah!  Belajar itu bagus.  Belajar C telah menjadi sangat penting bagi pemahaman saya tentang komputasi dan karier saya.  Mempelajari bahasa ini dan tempatnya dalam sejarah bahasa pemrograman akan menjadikan Anda seorang programmer yang lebih baik.  Anda tidak perlu alasan apa pun.  Belajar hal-hal hanya demi belajar.  Artikel ini dimaksudkan sebagai pedoman untuk memahami kebenaran, tidak membahas apakah akan belajar C. </blockquote><br>  Pertama-tama, kepada siapa ide ini umumnya direkomendasikan.  Jika Anda mencoba "mencari tahu cara kerja komputer," maka tidak perlu dikatakan bahwa saat ini Anda tidak memahami ini.  Programmer mana yang tidak mengerti cara kerja komputer?  Saya pada dasarnya melihat bahwa perasaan ini berasal dari orang-orang yang sebagian besar memprogram dalam bahasa "scripting" yang diketik secara dinamis seperti Ruby, Python, atau JavaScript.  Mereka seharusnya "tidak tahu bagaimana komputer bekerja" karena bahasa-bahasa ini bekerja di dalam mesin virtual, di mana hanya semantik masalah mesin virtual.  Pada akhirnya, seluruh ide mesin virtual adalah untuk menyediakan portabilitas.  Tujuannya bukan untuk bergantung pada peralatan yang dijalankan VM. <br><br>  Hanya ada satu masalah: C <i>juga</i> berfungsi di dalam mesin virtual. <br><br><h3>  Mesin Abstrak C </h3><br>  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi C99</a> , bagian 5.1.2.3, â€œEksekusi Programâ€: <br><br><blockquote>  Deskripsi semantik dalam Standar Internasional ini menjelaskan perilaku mesin abstrak yang masalah pengoptimalannya tidak relevan. </blockquote><br>  Menurut pendapat saya, ini adalah hal yang paling penting untuk dipahami ketika belajar C. Bahasa tidak "menggambarkan bagaimana komputer bekerja", tetapi menggambarkan bagaimana "mesin C abstrak" bekerja.  Semua hal penting lainnya mengikuti dari konsep ini. <br><br><blockquote> Satu lagi catatan: di sini saya memilih C99, yang bukan standar C. terbaru Mengapa?  Yah, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSVC memiliki ... dukungan bahasa C yang menarik</a> , dan saya pengguna Windows akhir-akhir ini.  Ya, Anda dapat menjalankan <code>clang</code> dan <code>gcc</code> di Windows.  Tidak ada perbedaan besar antara C89, C99 dan C11 tentang apa yang kita bicarakan.  Pada titik tertentu, Anda harus memilih.  Versi yang saya sebutkan di sini mencakup beberapa perubahan pada spesifikasi aslinya. </blockquote><br>  Anda mungkin pernah mendengar ungkapan lain dalam ceramah C Anda: "C adalah assembler portabel."  Jika Anda berpikir tentang frasa ini, Anda akan memahami bahwa jika ini benar, maka C tidak dapat sesuai dengan operasi komputer: ada banyak komputer berbeda dengan arsitektur yang berbeda.  Jika C seperti assembler yang berjalan pada komputer yang berbeda dengan arsitektur yang berbeda, maka C tidak dapat berfungsi secara bersamaan persis seperti masing-masing komputer ini.  Dia <i>harus</i> menyembunyikan detailnya, kalau tidak dia tidak akan portabel! <br><br>  Namun demikian, saya pikir fakta ini tidak masalah, karena orang hampir tidak secara harfiah mengacu pada "C adalah cara kerja komputer."  Sebelum kembali ke ini, mari kita bicara tentang mesin C abstrak, dan mengapa banyak yang tampaknya tidak memahami aspek C. <br><br><h3>  Digresi: mengapa orang salah? </h3><br>  Saya hanya bisa berbicara tentang pengalaman saya, walaupun pasti itu tidak unik. <br><br>  Saya belajar GW-BASIC, lalu C, lalu C ++, lalu Jawa.  Saya mendengar tentang Jawa sebelum saya mulai menulisnya sekitar tahun 1999, empat tahun setelah itu muncul.  Pemasaran pada waktu itu secara aktif membandingkan Java dan C ++, itu berfokus pada JVM sebagai platform, dan pada kenyataan bahwa model mesin membedakannya dari C ++, dan karenanya C. Sun Microsystems tidak lagi ada, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cermin rilis pers</a> mengingatkan kita: <br><br><blockquote>  Aplikasi Java adalah platform independen;  Anda hanya perlu melakukan porting mesin virtual Java ke setiap platform.  Karena berfungsi sebagai juru bahasa antara komputer pengguna dan aplikasi Java.  Aplikasi yang ditulis dalam lingkungan Java dapat bekerja di mana saja, sehingga tidak perlu lagi mem-port aplikasi ke berbagai platform. </blockquote><br>  Moto utamanya adalah "Menulis sekali, jalankan di mana-mana."  Dua kalimat ini menjadi bagaimana saya (dan banyak lainnya) memahami Java, dan bagaimana ia berbeda dari C ++.  Java memiliki interpreter, mesin virtual Java.  Tidak ada mesin virtual di C ++. <br><br>  Dengan pemasaran yang begitu kuat, "mesin virtual" di benak banyak orang telah menjadi identik dengan "runtime besar dan / atau penerjemah."  Bahasa tanpa fitur ini terlalu terikat pada komputer tertentu dan memerlukan porting karena mereka tidak benar-benar platform independen.  Alasan utama Java ada adalah perubahan dalam cacat C ++ ini. <br><br><blockquote>  "Lingkungan runtime", "mesin virtual" dan "mesin abstrak" adalah kata-kata yang berbeda untuk konsep dasar yang sama.  Tetapi sejak itu mereka menerima konotasi yang berbeda karena ada sedikit perbedaan dalam implementasi ide-ide ini. </blockquote><br>  Saya pribadi percaya bahwa pemasaran tahun 1995 ini adalah alasan mengapa pemrogram masih salah memahami sifat C. <br><br>  Jadi, apakah pernyataan ini salah?  Mengapa Sun Microsystems menghabiskan jutaan dan jutaan dolar untuk mempromosikan kebohongan?  Jika C juga didasarkan pada mesin abstrak yang menawarkan portabilitas lintas-platform, mengapa kita membutuhkan Java?  Saya pikir ini adalah kunci untuk memahami apa yang sebenarnya dimaksud orang ketika mereka mengatakan "C adalah cara kerja komputer." <br><br><h3>  Apa yang sebenarnya orang maksud? </h3><br>  Meskipun C bekerja dalam konteks mesin virtual, C masih berbeda secara signifikan dari bahasa mirip Java.  Sun tidak berbohong.  Untuk memahami, Anda perlu tahu kisah C. <br><br>  Pada tahun 1969, Bell Labs menulis sistem operasi komputer dalam bahasa assembly.  Pada tahun 1970, ia dijuluki UNIX.  Seiring waktu, Bell Labs membeli semakin banyak komputer baru, termasuk PDP-11. <br><br>  Ketika tiba saatnya untuk port Unix ke PDP-11, mereka memutuskan untuk menggunakan bahasa tingkat yang lebih tinggi, yang merupakan ide yang cukup radikal pada saat itu.  Bayangkan hari ini saya akan memberi tahu Anda: "Saya akan menulis OS di Jawa" - Anda mungkin akan tertawa, meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gagasan itu bisa diwujudkan</a> .  Situasi (dalam pemahaman saya, saya tidak hidup saat itu) kira-kira sama.  Kami menganggap bahasa yang disebut B, tetapi tidak mendukung beberapa fungsi yang dimiliki PDP-11, dan oleh karena itu mereka menciptakan penggantinya dengan menyebutnya "C", karena itu adalah huruf berikutnya dalam alfabet. <br><br><blockquote>  Tidak ada bahasa "A";  B berhasil BCPL (Bahasa Pemrograman Gabungan Dasar). </blockquote><br>  Pada tahun 1972, kompiler C pertama ditulis pada PDP-11 dan pada saat yang sama ditulis ulang UNIX menjadi C. Awalnya, mereka tidak memikirkan portabilitas, tetapi C memperoleh ketenaran, sehingga kompiler C porting ke sistem lain. <br><br>  Pada tahun 1978, edisi pertama buku "Bahasa Pemrograman C" diterbitkan.  Disebut â€œK&amp;Râ€, sesuai dengan nama penulisnya, buku itu sama sekali tidak menyerupai spesifikasi, tetapi pada saat yang sama menggambarkan bahasa tersebut dengan cukup rinci, sebagai akibatnya orang lain juga mencoba menulis kompiler C. Kemudian â€œversiâ€ ini akan disebut â€œK&amp;R Câ€. <br><br>  Saat UNIX dan C menyebar, keduanya porting ke banyak komputer.  Di tahun 70-an dan 80-an, basis perangkat keras mereka terus tumbuh.  Dengan cara yang sama bahwa C dibuat karena B tidak mendukung semua fungsi PDP-11, banyak kompiler menggunakan ekstensi bahasa.  Karena hanya ada K&amp;R dan bukan spesifikasi, ini dianggap dapat diterima selama ekstensi cukup dekat.  Pada tahun 1983, kurangnya standarisasi menyebabkan masalah, jadi ANSI membentuk tim untuk menyiapkan spesifikasi.  Pada tahun 1989, standar C89 keluar, kadang-kadang disebut "ANSI C". <br><br>  Spesifikasi C mencoba menyatukan beragam implementasi ini pada berbagai perangkat keras.  Dengan demikian, mesin C abstrak adalah semacam spesifikasi sekecil mungkin yang memungkinkan kode yang sama berfungsi sama di semua platform.  Implementasi C dikompilasi, tidak ditafsirkan, sehingga tidak ada penerjemah, oleh karena itu tidak ada "VM" dalam arti 1995.  Namun, program C ditulis pada komputer abstrak yang tidak ada ini, dan kemudian kode tersebut dikonversi menjadi assembler khusus ke komputer tertentu di mana program tersebut berjalan.  Anda tidak dapat mengandalkan beberapa detail spesifik untuk menulis kode C portabel. Ini membuat penulisan portabel C sangat sulit karena Anda mungkin telah membuat asumsi platform khusus ketika menulis versi awal kode Anda. <br><br>  Ini paling baik digambarkan dengan contoh.  Salah satu tipe data utama dalam C adalah <code>char</code> , dari kata "karakter".  Namun, mesin C abstrak tidak menentukan berapa banyak bit yang harus di <code>char</code> .  Ya, tentukan, tetapi tidak dengan angka;  itu menentukan ukuran <code>CHAR_BIT</code> , yang merupakan konstanta.  Bagian 5.2.4.2.1 dari spesifikasi: <br><br><blockquote>  Nilai-nilai yang diberikan di bawah ini harus diganti dengan ekspresi konstan yang sesuai atau digunakan dalam arahan preprocessing <code>#if</code> ... Nilai-nilai dalam implementasi spesifik harus sama dengan atau lebih besar dalam besarnya (nilai absolut) dari yang diberikan di sini dengan tanda yang sama. <br><br> <code>CHAR_BIT: 8</code> </blockquote> <br>  Dengan kata lain, Anda tahu bahwa <code>char</code> setidaknya 8 bit, tetapi implementasinya mungkin lebih besar.  Untuk menyandikan "mesin C abstrak," <code>CHAR_BIT</code> harus digunakan sebagai ganti ukuran 8 saat memproses <code>char</code> .  Tapi ini bukan semacam fungsi interpreter, seperti yang kita pikirkan tentang mesin virtual;  ini adalah properti dari bagaimana kompiler menerjemahkan kode sumber menjadi kode mesin. <br><br><blockquote>  Ya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada sistem di</a> mana <code>CHAR_BIT</code> bukan <code>8</code> . </blockquote><br>  Dengan demikian, "mesin abstrak" ini, walaupun secara teknis ide yang sama dengan mesin virtual Java, lebih mungkin merupakan konstruksi kompilasi untuk mengelola kompiler ketika membuat kode assembler, daripada semacam pemeriksaan runtime atau properti.  Jenis yang setara di Jawa adalah <code>byte</code> , yang selalu 8 bit, dan implementasi JVM ditugaskan dengan apa yang harus dilakukan pada platform dengan lebih banyak byte.  (Tidak yakin apakah JVM bekerja di salah satu platform ini, tetapi begitulah seharusnya.)  Mesin C abstrak dibuat sebagai pembungkus minimal untuk berbagai "perangkat keras", dan bukan sebagai semacam platform yang terbuat dari bahan padat yang ditulis dalam perangkat lunak untuk kode Anda. <br><br>  Jadi, meskipun Sun secara teknis salah, dalam praktiknya mereka sedikit berarti dari apa yang mereka katakan, dan apa yang mereka <i>maksud</i> adalah benar.  Hal yang sama dengan ungkapan "Belajar C untuk Memahami Cara Kerja Komputer". <br><br><h3>  Pelajari C untuk LEBIH BAIK Memahami Bagaimana Komputer Bekerja </h3><br>  Apa <i>yang sebenarnya</i> orang maksud?  Dalam konteks "seandainya seorang rubist belajar C untuk memahami bagaimana komputer bekerja" - ini adalah saran untuk turun "ke tingkat besi".  Artinya, tidak hanya untuk memahami bagaimana program Anda bekerja di dalam mesin virtual, tetapi juga bagaimana kombinasi dari program dan VM bekerja dalam konteks mesin itu sendiri. <br><br>  Belajar C <i>akan memberi</i> Anda lebih banyak detail ini karena mesin abstrak jauh lebih dekat ke perangkat keras serta abstraksi dari sistem operasi.  Bahasa C sangat berbeda dari bahasa tingkat tinggi, jadi belajar bahasa itu bisa mengajar banyak. <br><br>  Tetapi penting untuk diingat bahwa C pada dasarnya adalah <i>abstraksi</i> perangkat keras, dan abstraksi tidak sempurna.  Berhati-hatilah dengan apa yang dilakukan C atau cara kerjanya dengan mesin itu sendiri.  Jika Anda terlalu dalam, Anda pasti akan menemukan perbedaan ini, yang dapat menyebabkan masalah.  Sebagian besar sumber daya pelatihan untuk C, terutama hari ini, ketika peralatan menjadi lebih homogen, akan mempromosikan gagasan bahwa <i>ini adalah cara</i> komputer bekerja.  Oleh karena itu, mungkin sulit bagi siswa untuk memahami apa yang terjadi di bawah tenda dan apa abstraksi yang diberikan oleh C. <br><br>  Dalam diskusi ini, kami bahkan tidak menyentuh masalah lain.  Misalnya, karena popularitas C yang sangat besar, perangkat keras menjadi lebih seragam karena cenderung bergerak ke arah semantik mesin abstrak C. Jika arsitektur Anda terlalu berbeda dari semantik C, program C dapat berjalan jauh lebih lambat daripada yang lain. dan kecepatan perangkat keras sering diukur dengan tes dalam C. Artikel ini sudah cukup lama ... <br><br>  Untuk alasan ini, saya pikir versi yang lebih akurat dari pernyataan ini adalah "Dengan mempelajari C, Anda <i>akan</i> belajar <i>lebih banyak</i> tentang cara kerja komputer."  Saya benar-benar berpikir bahwa perkenalan dengan C sangat berguna bagi banyak programmer, bahkan jika mereka sendiri tidak menulis C. Memperkenalkan C juga akan memberi Anda gambaran tentang sejarah industri kami. <br><br>  Ada cara lain untuk menjelajahi topik ini;  C <i>secara inheren</i> tidak dirancang untuk mempelajari komputer, tetapi itu adalah pilihan yang baik. <br><br>  Ada begitu banyak yang harus dipelajari dalam pemrograman.  Semoga sukses dalam perjalanan ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426993/">https://habr.com/ru/post/id426993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426981/index.html">10 trik untuk dasbor tingkat lanjut di Splunk. Bagian 1</a></li>
<li><a href="../id426983/index.html">Baru di SObjectizer-5.5.23: keinginan terpenuhi atau kotak Pandora?</a></li>
<li><a href="../id426985/index.html">kubebox dan cangkang konsol lainnya untuk Kubernetes</a></li>
<li><a href="../id426987/index.html">Pelajari OpenGL. Pelajaran 6.3 - Pencahayaan Berbasis Gambar. Iradiasi difus</a></li>
<li><a href="../id426991/index.html">Startup Digest: 10 acara IT mendatang di Moskow</a></li>
<li><a href="../id426995/index.html">Daur ulang membahayakan produk dan karyawan</a></li>
<li><a href="../id426997/index.html">Cara membuat bentuk khusus menggunakan MaterialShapeDrawable</a></li>
<li><a href="../id426999/index.html">Mengikuti tren, atau bergerak menuju RxJava dan LiveData</a></li>
<li><a href="../id427003/index.html">Hexagon maps in Unity: kabut perang, riset peta, pembuatan prosedural</a></li>
<li><a href="../id427005/index.html">Pengembang AI - profesi jutawan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>