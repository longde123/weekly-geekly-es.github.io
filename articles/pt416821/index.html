<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚úàÔ∏è üêù üëçüèª Como o JS funciona: comunica√ß√µes WebRTC e P2P üë®üèº‚Äçüîß üïäÔ∏è üí™üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Leitura recomendada] As outras 19 partes do ciclo  Parte 1: Vis√£o geral do mecanismo, mecanismos de tempo de execu√ß√£o, pilha de chamadas 
 Parte 2: S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o JS funciona: comunica√ß√µes WebRTC e P2P</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416821/"><div class="spoiler">  <b class="spoiler_title">[Leitura recomendada] As outras 19 partes do ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vis√£o geral do mecanismo, mecanismos de tempo de execu√ß√£o, pilha de chamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobre os internos da V8 e otimiza√ß√£o de c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciando a mem√≥ria, quatro tipos de vazamentos de mem√≥ria e lidando com eles</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Loop de eventos, ass√≠ncrono e cinco maneiras de melhorar seu c√≥digo com async / waitit</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebSocket e HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que escolher?</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recursos e escopo do WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhadores da Web e cinco cen√°rios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhadores de Servi√ßo</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Notifica√ß√µes por push da Web</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rastrear altera√ß√µes no DOM com MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mecanismos de renderiza√ß√£o de p√°ginas da Web e dicas para otimizar seu desempenho</a> <br>  Parte 12: O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subsistema de rede dos navegadores, otimizando seu desempenho e seguran√ßa</a> <br>  Parte 12: O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subsistema de rede dos navegadores, otimizando seu desempenho e seguran√ßa</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Anima√ß√£o com CSS e JavaScript</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: √Årvores de sintaxe abstratas, an√°lise e sua otimiza√ß√£o</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: classes e heran√ßa, transpila√ß√£o em Babel e TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: armazenamento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: Tecnologia Shadow DOM e componentes da Web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: mecanismos de comunica√ß√£o WebRTC e P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: elementos personalizados</a> </div></div><br>  Hoje estamos publicando uma tradu√ß√£o da parte 18 de uma s√©rie de materiais dedicados a tudo relacionado ao JavaScript.  Aqui falaremos sobre a tecnologia WebRTC, que visa organizar o interc√¢mbio direto de dados entre aplicativos de navegador em tempo real. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/aff/ed1/fee/affed1fee433a9375eefd24a753a89b8.png" alt="imagem"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revis√£o</font> </h2><br>  O que √© o WebRTC?  Para come√ßar, vale dizer que a abrevia√ß√£o RTC significa Comunica√ß√£o em tempo real (comunica√ß√£o em tempo real).  Isso por si s√≥ fornece muitas informa√ß√µes sobre essa tecnologia. <br><br>  O WebRTC ocupa um nicho muito importante entre os mecanismos da plataforma web.  Anteriormente, as tecnologias P2P (redes ponto a ponto, ponto a ponto, redes ponto a ponto, ponto a ponto) usadas por aplicativos como bate-papos na √°rea de trabalho davam a eles oportunidades que os projetos da Web n√£o tinham.  O WebRTC faz a diferen√ßa para as tecnologias da web. <br><br>  O WebRTC, se observarmos essa tecnologia em termos gerais, permitir√° que aplicativos da Web criem conex√µes P2P, que discutiremos abaixo.  Al√©m disso, abordaremos os seguintes t√≥picos aqui para mostrar a imagem completa da estrutura interna do WebRTC: <br><br><ul><li>  Comunica√ß√µes P2P. </li><li> Firewalls e tecnologia NAT Traversal. </li><li>  Sinaliza√ß√£o, sess√µes e protocolos. </li><li>  API WebRTC </li></ul><br><h2>  <font color="#3AC1EF">Comunica√ß√µes P2P</font> </h2><br>  Suponha que dois usu√°rios tenham lan√ßado, cada um em seu pr√≥prio navegador, um aplicativo que permita organizar um bate-papo por v√≠deo usando o WebRTC.  Eles querem estabelecer uma conex√£o P2P.  Ap√≥s a decis√£o, precisamos de um mecanismo que permita que os navegadores dos usu√°rios se encontrem e estabele√ßam a comunica√ß√£o levando em considera√ß√£o os mecanismos de prote√ß√£o de informa√ß√µes dispon√≠veis nos sistemas.  Ap√≥s estabelecer uma conex√£o, os usu√°rios poder√£o trocar informa√ß√µes multim√≠dia em tempo real. <br><br>  Uma das principais dificuldades associadas √†s conex√µes P2P do navegador √© que os navegadores precisam primeiro descobrir um ao outro e, em seguida, estabelecer uma conex√£o de rede baseada em soquetes para fornecer transfer√™ncia de dados bidirecional.  Sugerimos discutir as dificuldades associadas √† instala√ß√£o dessas conex√µes. <br><br>  Quando um aplicativo da web precisa de alguns dados ou recursos, ele os baixa do servidor e √© isso.  O endere√ßo do servidor √© conhecido pelo aplicativo.  Se estamos falando, por exemplo, sobre a cria√ß√£o de um bate-papo P2P, cuja opera√ß√£o se baseia na conex√£o direta de navegadores, os endere√ßos desses navegadores n√£o s√£o conhecidos antecipadamente.  Como resultado, para estabelecer uma conex√£o P2P, voc√™ ter√° que lidar com alguns problemas. <br><br><h2>  <font color="#3AC1EF">Firewalls e Protocolo NAT Transversal</font> </h2><br>  Computadores comuns, como regra, n√£o t√™m endere√ßos IP externos est√°ticos atribu√≠dos a eles.  A raz√£o para isso √© que esses computadores geralmente est√£o localizados atr√°s de firewalls e dispositivos NAT. <br><br>  O NAT √© um mecanismo que converte endere√ßos IP locais internos localizados atr√°s de um firewall em endere√ßos IP globais externos.  A tecnologia NAT √© usada, primeiramente, por raz√µes de seguran√ßa e, em segundo lugar, devido √†s restri√ß√µes impostas pelo IPv4 ao n√∫mero de endere√ßos IP globais dispon√≠veis.  √â por isso que aplicativos da Web que usam o WebRTC n√£o devem confiar no fato de o dispositivo atual ter um endere√ßo IP est√°tico global. <br><br>  Vamos ver como o NAT funciona.  Se voc√™ estiver em uma rede corporativa e conectado ao Wi-Fi, seu computador receber√° um endere√ßo IP que existe apenas atr√°s do seu dispositivo NAT.  Suponha que este seja o endere√ßo IP 172.0.23.4.  Para o mundo exterior, no entanto, seu endere√ßo IP pode parecer 164.53.27.98.  O mundo externo, como resultado, v√™ suas solicita√ß√µes como vindas do endere√ßo 164.53.27.98, mas gra√ßas ao NAT, as respostas √†s solicita√ß√µes feitas pelo seu computador a servi√ßos externos ser√£o enviadas para o seu endere√ßo interno 172.0.23.4.  Isso acontece usando tabelas de tradu√ß√£o.  Observe que, al√©m do endere√ßo IP, tamb√©m √© necess√°rio um n√∫mero de porta para a rede. <br><br>  Como o NAT est√° envolvido no processo de intera√ß√£o do sistema com o mundo exterior, o navegador, para estabelecer uma conex√£o WebRTC, precisa saber o endere√ßo IP do computador no qual o navegador que voc√™ deseja se comunicar est√° executando. <br><br>  √â aqui que os servidores STUN (Utilit√°rios de transfer√™ncia de sess√£o para NAT) e TURN (Traversal usando rel√©s em torno de NAT) entram em cena.  Para garantir a opera√ß√£o da tecnologia WebRTC, uma solicita√ß√£o √© feita primeiro ao servidor STUN, a fim de descobrir seu endere√ßo IP externo.  Na verdade, estamos falando de uma solicita√ß√£o feita a um servidor remoto para descobrir a partir de qual endere√ßo IP o servidor recebe essa solicita√ß√£o.  Ap√≥s receber uma solicita√ß√£o semelhante, o servidor remoto enviar√° uma resposta contendo o endere√ßo IP vis√≠vel para ele. <br><br>  Com base na suposi√ß√£o de que esse esquema est√° operacional e que voc√™ recebeu informa√ß√µes sobre seu endere√ßo IP e porta externos, poder√° informar outros participantes do sistema (n√≥s os chamaremos de colegas) sobre como entrar em contato diretamente com voc√™.  Esses pares tamb√©m podem fazer o mesmo usando servidores STUN ou TURN e podem informar quais endere√ßos s√£o atribu√≠dos a eles. <br><br><h2>  <font color="#3AC1EF">Sinaliza√ß√£o, sess√µes e protocolos</font> </h2><br>  O processo de descoberta de informa√ß√µes de rede, descrito acima, √© parte de um grande sistema de sinaliza√ß√£o, que, no caso do WebRTC, √© baseado no padr√£o JSEP (JavaScript Session Establishment Protocol).  A sinaliza√ß√£o inclui descoberta de recursos de rede, cria√ß√£o e gerenciamento de sess√µes, seguran√ßa de comunica√ß√£o, coordena√ß√£o de par√¢metros de m√≠dia, tratamento de erros. <br><br>  Para que a conex√£o funcione, os pares devem concordar com os formatos de dados que eles trocar√£o e coletar informa√ß√µes sobre os endere√ßos de rede do computador no qual o aplicativo est√° sendo executado.  O mecanismo de sinaliza√ß√£o para compartilhar essas informa√ß√µes cr√≠ticas n√£o faz parte da API WebRTC. <br><br>  A sinaliza√ß√£o n√£o √© definida pelo padr√£o WebRTC e n√£o √© implementada em sua API para fornecer flexibilidade nas tecnologias e protocolos utilizados.  A sinaliza√ß√£o e os servidores que a suportam s√£o de responsabilidade do desenvolvedor do aplicativo WebRTC. <br><br>  Com base na suposi√ß√£o de que seu aplicativo WebRTC em execu√ß√£o no navegador √© capaz de determinar o endere√ßo IP externo do navegador usando STUN, conforme descrito acima, a pr√≥xima etapa √© discutir os par√¢metros da sess√£o e estabelecer uma conex√£o com outro navegador. <br><br>  A discuss√£o inicial dos par√¢metros da sess√£o e o estabelecimento de uma conex√£o s√£o feitos usando um protocolo de sinaliza√ß√£o / comunica√ß√£o especializado em comunica√ß√µes multim√≠dia.  Esse protocolo, al√©m disso, √© respons√°vel por cumprir as regras sob as quais a sess√£o √© gerenciada e finalizada. <br><br>  Um desses protocolos √© chamado SIP (Session Initiation Protocol).  Observe que, devido √† flexibilidade do subsistema de sinaliza√ß√£o WebRTC, o SIP n√£o √© o √∫nico protocolo de sinaliza√ß√£o que pode ser usado.  O protocolo de sinaliza√ß√£o selecionado, al√©m disso, deve funcionar com um protocolo de camada de aplicativo chamado SDP (Session Description Protocol), usado ao usar o WebRTC.  Todos os metadados relacionados aos dados multim√≠dia s√£o transmitidos usando o protocolo SDP. <br><br>  Qualquer par (isto √©, um aplicativo usando o WebRTC) que tenta entrar em contato com outro par gera um conjunto de rotas candidatas para o protocolo ICE (Interactive Connectivity Establishment).  Os candidatos representam uma combina√ß√£o de endere√ßo IP, porta e protocolo de transporte que podem ser usados.  Observe que um computador pode ter muitas interfaces de rede (com fio, sem fio etc.), para que possam ser atribu√≠dos v√°rios endere√ßos IP, um para cada interface. <br><br>  Aqui est√° um diagrama com o MDN que ilustra o processo acima de troca de dados. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/eb5/3a2/c33eb53a21f48ec8f629ac38fc503d4e.png"></div><br>  <i><font color="#999999">O processo de troca de dados necess√°rio para estabelecer uma conex√£o P2P</font></i> <br><br><h2>  <font color="#3AC1EF">Estabelecer uma conex√£o</font> </h2><br>  Cada par primeiro descobre seu endere√ßo IP externo como descrito acima.  Em seguida, s√£o criados dinamicamente "canais" de dados de sinaliza√ß√£o, que servem para detectar pares e dar suporte √† troca de dados entre eles, para discutir os par√¢metros da sess√£o e sua instala√ß√£o. <br><br>  Esses "canais" s√£o desconhecidos e inacess√≠veis ao mundo exterior; um identificador exclusivo √© necess√°rio para acess√°-los. <br><br>  Observe que, devido √† flexibilidade do WebRTC e ao fato de o processo de sinaliza√ß√£o n√£o ser definido pelo padr√£o, o conceito de "canais" e a ordem de seu uso podem variar um pouco, dependendo das tecnologias utilizadas.  De fato, alguns protocolos n√£o requerem um mecanismo de "canal" para organizar a troca de dados.  Para os fins deste material, assumimos que os "canais" na implementa√ß√£o do sistema s√£o utilizados. <br><br>  Se dois ou mais pares estiverem conectados ao mesmo "canal", eles ter√£o a oportunidade de trocar dados e discutir informa√ß√µes da sess√£o.  Esse processo √© semelhante a um modelo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">editor-assinante</a> .  Em geral, o ponto que inicia a conex√£o envia uma "oferta" usando um protocolo de sinaliza√ß√£o como SIP ou SDP.  O iniciador espera receber uma "resposta" do destinat√°rio da proposta, que est√° conectado ao "canal" considerado. <br><br>  Depois que a resposta √© recebida, ocorre o processo de determinar e discutir os melhores candidatos a ICE coletados por cada festa.  Ap√≥s a sele√ß√£o dos candidatos ideais para ICE, s√£o acordados os par√¢metros de dados que ser√£o trocados entre pares e o mecanismo de roteamento de rede (endere√ßo IP e porta). <br><br>  Em seguida, uma sess√£o de soquete de rede ativa √© estabelecida entre pares.  Al√©m disso, cada par cria fluxos de dados locais e pontos finais de canais de dados, e a transmiss√£o bidirecional de dados multim√≠dia come√ßa a usar a tecnologia aplicada. <br><br>  Se o processo de negocia√ß√£o para escolher o melhor candidato a ICE n√£o for bem-sucedido, o que √†s vezes acontece devido √† falha de firewalls e sistemas NAT, √© usada uma op√ß√£o de backup, que consiste em usar, como retransmiss√£o, um servidor TURN.  Esse processo envolve um servidor que atua como intermedi√°rio que retransmite os dados trocados entre pares.  Observe que esse esquema n√£o √© uma conex√£o P2P real na qual os pares transmitem dados diretamente entre si. <br><br>  Ao usar um fallback usando TURN para troca de dados, cada ponto n√£o precisa mais saber como se comunicar com os outros e como transferir dados para ele.  Em vez disso, os colegas precisam saber qual servidor TURN externo precisa enviar dados multim√≠dia em tempo real e de qual servidor eles precisam receber durante a sess√£o de comunica√ß√£o. <br><br>  √â importante entender que agora era uma maneira alternativa de organizar as comunica√ß√µes.  Os servidores TURN devem ser muito confi√°veis, ter uma grande largura de banda e poder de computa√ß√£o s√©rio, dar suporte ao trabalho com quantidades potencialmente grandes de dados.  Portanto, o uso de um servidor TURN obviamente leva a custos adicionais e a um aumento na complexidade do sistema. <br><br><h2>  <font color="#3AC1EF">API WebRTC</font> </h2><br>  Existem tr√™s categorias principais de APIs que existem no WebRTC: <br><br><ul><li>  A API Media Capture and Streams √© respons√°vel pela captura e streaming de m√≠dia.  Essa API permite conectar-se a dispositivos de entrada, como microfones e webcams, e receber fluxos de m√≠dia deles. </li><li>  API RTCPeerConnection  Usando a API desta categoria, √© poss√≠vel, a partir de um terminal do WebRTC, enviar, em tempo real, o fluxo capturado de dados de √°udio ou v√≠deo via Internet para outro terminal do WebRTC.  Usando esta API, voc√™ pode criar conex√µes entre a m√°quina local e o ponto remoto.  Ele fornece m√©todos para conectar-se a um ponto remoto, gerenciar a conex√£o e monitorar seu status.  Seus mecanismos s√£o usados ‚Äã‚Äãpara fechar conex√µes desnecess√°rias. </li><li>  API RTCDataChannel  Os mecanismos representados por esta API permitem a transfer√™ncia de dados arbitr√°rios.  Cada canal de dados est√° associado a uma interface RTCPeerConnection. </li></ul><br>  Vamos falar sobre essas APIs. <br><br><h2>  <font color="#3AC1EF">Captura de m√≠dia e fluxos de API</font> </h2><br>  A API Media Capture and Streams, geralmente chamada de API Media Stream ou Stream API, √© uma API que suporta o trabalho com fluxos de dados de √°udio e v√≠deo, m√©todos para trabalhar com eles.  Usando esta API, voc√™ pode definir restri√ß√µes relacionadas aos tipos de dados; aqui existem retornos de chamada para a conclus√£o bem-sucedida e malsucedida de opera√ß√µes que s√£o usadas ao usar mecanismos ass√≠ncronos para trabalhar com dados e eventos gerados durante a opera√ß√£o. <br><br>  O m√©todo <code>getUserMedia()</code> da API <code>getUserMedia()</code> solicita ao usu√°rio permiss√£o para trabalhar com dispositivos de entrada que produzem fluxos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MediaStream</a> com faixas de √°udio ou v√≠deo contendo os tipos de m√≠dia solicitados.  Esse fluxo pode incluir, por exemplo, uma faixa de v√≠deo (sua fonte √© uma fonte de hardware ou de v√≠deo virtual, como uma c√¢mera, gravador de v√≠deo, servi√ßo de compartilhamento de tela etc.), uma faixa de √°udio (fontes de √°udio f√≠sicas ou virtuais podem formar a mesma, como um microfone, um conversor de anal√≥gico para digital etc.) e possivelmente outros tipos de faixas. <br><br>  Este m√©todo retorna a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">promessa</a> que resolve para o objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MediaStream</a> .  Se o usu√°rio rejeitar a solicita√ß√£o de permiss√£o ou a m√≠dia correspondente n√£o estiver dispon√≠vel, a promessa ser√° resolvida, respectivamente, com um <code>NotFoundError</code> <code>PermissionDeniedError</code> ou <code>NotFoundError</code> . <br><br>  Voc√™ pode acessar o singleton <code>MediaDevice</code> atrav√©s do objeto <code>navigator</code> : <br><br><pre> <code class="hljs php">navigator.mediaDevices.getUserMedia(constraints) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> });</code> </pre> <br>  Observe que, quando voc√™ chama o m√©todo <code>getUserMedia()</code> , precisa passar para ele um objeto de <code>constraints</code> que informa √† API que tipo de fluxo ele deve retornar.  Aqui voc√™ pode configurar v√°rias coisas, incluindo a c√¢mera que deseja usar (frontal ou traseira), taxa de quadros, resolu√ß√£o e assim por diante. <br><br>  A partir da vers√£o 25, os navegadores baseados no Chromium permitem transferir √°udio de <code>getUserMedia()</code> elementos de √°udio ou v√≠deo (no entanto, observe que os elementos de m√≠dia ser√£o desativados por padr√£o). <br><br>  O m√©todo <code>getUserMedia()</code> tamb√©m pode ser usado como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um n√≥ de entrada para a API de √°udio da Web</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gotStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stream</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitAudioContext;   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> audioContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioContext();   <span class="hljs-comment"><span class="hljs-comment">//  AudioNode     var mediaStreamSource = audioContext.createMediaStreamSource(stream);   //       ,    ,   //       !   mediaStreamSource.connect(audioContext.destination); } navigator.getUserMedia({audio:true}, gotStream);</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Limita√ß√µes relacionadas √† prote√ß√£o de informa√ß√µes pessoais</font> </h2><br>  A captura n√£o autorizada de dados de um microfone ou c√¢mera √© uma s√©ria interfer√™ncia na vida pessoal do usu√°rio.  Portanto, o uso de <code>getUserMedia()</code> prev√™ a implementa√ß√£o de requisitos muito espec√≠ficos para notificar o usu√°rio sobre o que est√° acontecendo e para gerenciar permiss√µes.  O m√©todo <code>getUserMedia()</code> sempre deve obter permiss√£o do usu√°rio antes de abrir qualquer dispositivo de entrada que colete m√≠dia, como uma webcam ou microfone.  Os navegadores podem oferecer a op√ß√£o de uma configura√ß√£o √∫nica de permiss√£o para um dom√≠nio, mas s√£o solicitados a solicitar permiss√£o pelo menos na primeira vez em que acessam dispositivos de m√≠dia, e o usu√°rio deve conceder explicitamente essa permiss√£o. <br><br>  Al√©m disso, as regras relacionadas √† notifica√ß√£o ao usu√°rio sobre o que est√° acontecendo s√£o importantes aqui.  √â necess√°rio que os navegadores exibam um indicador que indique o uso de um microfone ou c√¢mera.  A exibi√ß√£o desse indicador n√£o depende da presen√ßa no sistema de indicadores de hardware indicando a opera√ß√£o de tais dispositivos.  Al√©m disso, os navegadores devem mostrar um indicador de que a permiss√£o para usar o dispositivo de entrada foi concedida, mesmo que o dispositivo n√£o seja usado em algum momento para registrar dados relevantes. <br><br><h2>  <font color="#3AC1EF">Interface RTCPeerConnection</font> </h2><br>  A interface RTCPeerConnection √© uma conex√£o WebRTC entre o computador local e o ponto remoto.  Ele fornece m√©todos para conectar-se a um sistema remoto, para suportar a conex√£o e monitorar seu status e para fechar a conex√£o depois que ela n√£o √© mais necess√°ria. <br><br>  Aqui est√° um diagrama da arquitetura WebRTC demonstrando o papel do RTCPeerConnection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/a16/dfe/4c0a16dfe63b400dc7082cd733ffa863.png"></div><br>  <i><font color="#999999">Fun√ß√£o RTCPeerConnection</font></i> <br><br>  Da perspectiva do JavaScript, o principal conhecimento que pode ser extra√≠do da an√°lise deste diagrama √© que o RTCPeerConnection abstrai o desenvolvedor da Web de mecanismos complexos localizados em n√≠veis mais profundos do sistema.  Os codecs e protocolos usados ‚Äã‚Äãpelo WebRTC fazem um √≥timo trabalho para permitir a troca de dados em tempo real, mesmo ao usar redes n√£o confi√°veis.  Aqui est√£o algumas das tarefas resolvidas por esses mecanismos: <br><br><ul><li>  Perda de pacotes de m√°scara. </li><li>  Cancelamento de eco. </li><li>  Adapta√ß√£o de largura de banda. </li><li>  Buffer din√¢mico para eliminar a instabilidade. </li><li>  Controle de volume autom√°tico. </li><li>  Redu√ß√£o e supress√£o de ru√≠do. </li><li>  "Limpando" a imagem. </li></ul><br><h2>  <font color="#3AC1EF">API RTCDataChannel</font> </h2><br>  Assim como os dados de √°udio e v√≠deo, o WebRTC suporta a transmiss√£o em tempo real de outros tipos de dados.  A API RTCDataChannel permite organizar uma troca P2P de dados arbitr√°rios. <br><br>  Existem muitos cen√°rios para usar esta API.  Aqui est√£o alguns deles: <br><br><ul><li>  Jogos </li><li>  Bate-papo em tempo real. </li><li>  Transfer√™ncia de arquivos. </li><li>  Organiza√ß√£o de redes descentralizadas. </li></ul><br>  Essa API visa o uso mais eficiente dos recursos da API RTCPeerConnection e permite organizar um sistema de troca de dados poderoso e flex√≠vel em um ambiente P2P.  Entre suas caracter√≠sticas est√£o as seguintes: <br><br><ul><li>  Trabalho eficaz com sess√µes usando RTCPeerConnection. </li><li>  Suporte para v√°rios canais de comunica√ß√£o usados ‚Äã‚Äãsimultaneamente com prioriza√ß√£o. </li><li>  Suporte para m√©todos confi√°veis ‚Äã‚Äãe n√£o confi√°veis ‚Äã‚Äãde entrega de mensagens. </li><li>  Gerenciamento de seguran√ßa interno (DTLS) e congestionamento. </li></ul><br>  A sintaxe aqui √© semelhante √† usada ao trabalhar com a tecnologia WebSocket.  O m√©todo <code>send()</code> e o evento da <code>message</code> s√£o aplicados aqui: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peerConnection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webkitRTCPeerConnection(servers,   {<span class="hljs-attr"><span class="hljs-attr">optional</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">RtpDataChannels</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]} ); peerConnection.ondatachannel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   receiveChannel = event.channel;   receiveChannel.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{       <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"#receiver"</span></span>).innerHTML = event.data;   }; }; sendChannel = peerConnection.createDataChannel(<span class="hljs-string"><span class="hljs-string">"sendDataChannel"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">reliable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"button#send"</span></span>).onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"textarea#send"</span></span>).value;   sendChannel.send(data); }</code> </pre> <br><h2>  <font color="#3AC1EF">WebRTC no mundo real</font> </h2><br>  No mundo real, a comunica√ß√£o WebRTC requer servidores.  Os sistemas n√£o s√£o muito complicados; gra√ßas a eles, a seguinte sequ√™ncia de a√ß√µes √© implementada: <br><br><ul><li>  Os usu√°rios descobrem um ao outro e trocam informa√ß√µes um sobre o outro, por exemplo, nomes. </li><li>  Os aplicativos clientes WebRTC (pares) trocam informa√ß√µes de rede. </li><li>  Os colegas trocam informa√ß√µes sobre dados de m√≠dia, como formato e resolu√ß√£o de v√≠deo. </li><li>  Os aplicativos cliente WebRTC estabelecem uma conex√£o ignorando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gateways</a> e firewalls <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NAT</a> . </li></ul><br>  Em outras palavras, o WebRTC precisa de quatro tipos de fun√ß√µes do servidor: <br><br><ul><li>  Meios para descobrir usu√°rios e organizar sua intera√ß√£o. </li><li>  Sinaliza√ß√£o. </li><li>  Ignore o NAT e os firewalls. </li><li>  Servidores de retransmiss√£o usados ‚Äã‚Äãquando uma conex√£o P2P n√£o pode ser estabelecida. </li></ul><br>  O protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STUN</a> e sua extens√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TURN</a> s√£o usados ‚Äã‚Äãpelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ICE</a> para permitir que o RTCPeerConnection trabalhe com mecanismos de desvio NAT e para lidar com outras dificuldades encontradas ao transmitir dados por uma rede. <br><br>  Como j√° mencionado, o ICE √© um protocolo para conectar pares, como dois clientes de bate-papo por v√≠deo.  No in√≠cio da sess√£o de comunica√ß√£o, o ICE tenta conectar os pares diretamente, com o menor atraso poss√≠vel, via UDP.  Durante esse processo, os servidores STUN t√™m uma √∫nica tarefa: permitir que o parceiro atr√°s do NAT aprenda seu endere√ßo e porta p√∫blicos.  D√™ uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta lista de</a> servidores STUN dispon√≠veis (o Google tamb√©m possui esses servidores). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/935/4e9/1a09354e9eb986043dc153ffb8b82500.png"></div><br>  <i><font color="#999999">Servidores STUN</font></i> <br><br><h2>  <font color="#3AC1EF">Detec√ß√£o de Candidatos ICE</font> </h2><br>  Se a conex√£o UDP n√£o puder ser estabelecida, o ICE tentar√° estabelecer uma conex√£o TCP: primeiro por HTTP e depois por HTTPS.  Se uma conex√£o direta n√£o puder ser estabelecida - em particular, devido √† incapacidade de ignorar NATs e firewalls corporativos, o ICE usar√° um intermedi√°rio (rel√©) na forma de um servidor TURN.  Em outras palavras, o ICE primeiro tentar√° usar o STUN com o UDP para conex√£o direta de pares e, se isso n√£o funcionar, ele usar√° uma op√ß√£o de fallback com um locat√°rio na forma de um servidor TURN.  O termo "pesquisa de candidatos" refere-se ao processo de pesquisa de interfaces e portas de rede. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80d/c0a/41b/80dc0a41b9c4f59966b325e95c99e9c3.png"></div><br>  <i><font color="#999999">Localizando interfaces e portas de rede adequadas</font></i> <br><br><h2>  <font color="#3AC1EF">Seguran√ßa</font> </h2><br>  Aplicativos de comunica√ß√£o em tempo real ou plug-ins relacionados podem levar a problemas de seguran√ßa.  Em particular, estamos falando sobre o seguinte: <br><br><ul><li>  Dados de m√≠dia n√£o criptografados ou outros dados podem ser interceptados ao longo do caminho entre navegadores ou entre um navegador e um servidor. </li><li>  Um aplicativo pode, sem o conhecimento do usu√°rio, gravar e transmitir dados de v√≠deo e √°udio para um invasor. </li><li>  Juntamente com um plug-in ou aplicativo com apar√™ncia inofensiva, um v√≠rus ou outro software malicioso pode chegar ao computador do usu√°rio. </li></ul><br>  O WebRTC possui v√°rios mecanismos projetados para lidar com essas amea√ßas: <br><br><ul><li>  As implementa√ß√µes do WebRTC usam protocolos seguros como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DTLS</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SRTP</a> . </li><li>  Para todos os componentes dos sistemas WebRTC, o uso de criptografia √© obrigat√≥rio.  Isso tamb√©m se aplica aos mecanismos de sinaliza√ß√£o. </li><li>  WebRTC n√£o √© um plugin.  Os componentes WebRTC s√£o executados na caixa de prote√ß√£o do navegador e n√£o em um processo separado.  Os componentes s√£o atualizados quando o navegador √© atualizado. </li><li>  O acesso √† c√¢mera e ao microfone deve ser concedido explicitamente.  E, quando uma c√¢mera ou microfone √© usado, esse fato √© exibido claramente na interface do usu√°rio do navegador. </li></ul><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  O WebRTC √© uma tecnologia muito interessante e poderosa para projetos que usam a transfer√™ncia de qualquer dado entre navegadores em tempo real.  O autor do material diz que sua empresa, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SessionStack</a> , utiliza mecanismos tradicionais para troca de dados com usu√°rios, envolvendo o uso de servidores.  No entanto, se eles usassem o WebRTC para resolver os problemas correspondentes, isso permitiria organizar a troca de dados diretamente entre navegadores, o que levaria a uma diminui√ß√£o no atraso na transfer√™ncia de dados e a reduzir a carga na infraestrutura da empresa. <br><br>  <b>Caros leitores!</b>  Voc√™ usa a tecnologia WebRTC em seus projetos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416821/">https://habr.com/ru/post/pt416821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416809/index.html">Modelos de snooker Elo e EloBet</a></li>
<li><a href="../pt416813/index.html">Quando 2 x 3 = 2 ou mais uma vez sobre virtualiza√ß√£o de dados</a></li>
<li><a href="../pt416815/index.html">Como paramos de passar uma semana emitindo um stand-dev</a></li>
<li><a href="../pt416817/index.html">3¬∫ lugar na fase de qualifica√ß√£o do DataScienceGame 2018</a></li>
<li><a href="../pt416819/index.html">Adeus, microsservi√ßos: de cem crian√ßas problem√°ticas a uma estrela</a></li>
<li><a href="../pt416823/index.html">Sangue, suor e pixels: o que √© o livro de Jason Schreier</a></li>
<li><a href="../pt416825/index.html">Como N√ÉO ser um desenvolvedor med√≠ocre</a></li>
<li><a href="../pt416827/index.html">Contentores para adultos (parte 02): um guia pr√°tico de terminologia</a></li>
<li><a href="../pt416829/index.html">Padr√£o de modelo ABI v0.5.6 Beta</a></li>
<li><a href="../pt416831/index.html">O roteamento externo do tr√°fego russo interno ser√° reduzido para 5%</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>