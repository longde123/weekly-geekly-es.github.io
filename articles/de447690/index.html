<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌻 🧑🏿‍🤝‍🧑🏽 👩🏾‍🍳 Kompilierbare Konfiguration eines verteilten Systems 👩🏼‍✈️ 📻 🙅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Beitrag möchten wir Ihnen einen interessanten Umgang mit der Konfiguration eines verteilten Systems vorstellen. 
 Die Konfiguration wird typ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilierbare Konfiguration eines verteilten Systems</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/primetalk/blog/447690/"><p>  In diesem Beitrag möchten wir Ihnen einen interessanten Umgang mit der Konfiguration eines verteilten Systems vorstellen. <br>  Die Konfiguration wird typsicher direkt in der Scala-Sprache dargestellt.  Eine Beispielimplementierung wird ausführlich beschrieben.  Verschiedene Aspekte des Vorschlags werden erörtert, einschließlich des Einflusses auf den gesamten Entwicklungsprozess. </p><br><p><img src="https://habrastorage.org/webt/71/bl/ax/71blaxtldz-ia4yftyebaxbam7c.png" alt="Gesamtkonfigurationsmanagementprozess"></p><br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Russisch</a> ) </p><a name="habracut"></a><br><h3 id="introduction">  Einführung </h3><br><p>  Der Aufbau robuster verteilter Systeme erfordert die Verwendung einer korrekten und kohärenten Konfiguration auf allen Knoten.  Eine typische Lösung besteht darin, eine textuelle Bereitstellungsbeschreibung (Terraform, Ansible oder ähnliches) und automatisch generierte Konfigurationsdateien (häufig - für jeden Knoten / jede Rolle reserviert) zu verwenden.  Wir möchten auch auf jedem Kommunikationsknoten dieselben Protokolle derselben Version verwenden (andernfalls treten Inkompatibilitätsprobleme auf).  In der JVM-Welt bedeutet dies, dass mindestens die Messaging-Bibliothek auf allen kommunizierenden Knoten dieselbe Version haben sollte. </p><br><p>  Was ist mit dem Testen des Systems?  Natürlich sollten wir Unit-Tests für alle Komponenten durchführen, bevor wir zu Integrationstests kommen.  Um Testergebnisse zur Laufzeit extrapolieren zu können, sollten wir sicherstellen, dass die Versionen aller Bibliotheken sowohl in der Laufzeit- als auch in der Testumgebung identisch sind. </p><br><p>  Beim Ausführen von Integrationstests ist es oft viel einfacher, auf allen Knoten denselben Klassenpfad zu haben.  Wir müssen nur sicherstellen, dass bei der Bereitstellung derselbe Klassenpfad verwendet wird.  (Es ist möglich, verschiedene Klassenpfade auf verschiedenen Knoten zu verwenden, aber es ist schwieriger, diese Konfiguration darzustellen und korrekt bereitzustellen.) Um die Dinge einfach zu halten, werden nur identische Klassenpfade auf allen Knoten berücksichtigt. </p><br><p>  Die Konfiguration entwickelt sich tendenziell zusammen mit der Software.  Wir verwenden normalerweise Versionen, um verschiedene zu identifizieren <br>  Stufen der Softwareentwicklung.  Es erscheint sinnvoll, die Konfiguration unter Versionsverwaltung abzudecken und verschiedene Konfigurationen mit einigen Bezeichnungen zu identifizieren.  Wenn es in der Produktion nur eine Konfiguration gibt, können wir eine einzelne Version als Kennung verwenden.  Manchmal haben wir mehrere Produktionsumgebungen.  Und für jede Umgebung benötigen wir möglicherweise einen separaten Konfigurationszweig.  Konfigurationen können daher mit Zweig und Version gekennzeichnet sein, um verschiedene Konfigurationen eindeutig zu identifizieren.  Jede Verzweigungsbezeichnung und -version entspricht einer einzelnen Kombination von verteilten Knoten, Ports, externen Ressourcen und Klassenpfadbibliotheksversionen auf jedem Knoten.  Hier werden wir nur den einzelnen Zweig behandeln und Konfigurationen anhand einer dreikomponentigen Dezimalversion (1.2.3) identifizieren, genau wie andere Artefakte. </p><br><p>  In modernen Umgebungen werden Konfigurationsdateien nicht mehr manuell geändert.  Normalerweise generieren wir <br>  Konfigurationsdateien zur Bereitstellungszeit und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berühren Sie sie</a> danach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nie mehr</a> .  Man könnte sich also fragen, warum wir immer noch das Textformat für Konfigurationsdateien verwenden.  Eine praktikable Option besteht darin, die Konfiguration in einer Kompilierungseinheit zu platzieren und von der Validierungskonfiguration zur Kompilierungszeit zu profitieren. </p><br><p>  In diesem Beitrag werden wir die Idee untersuchen, die Konfiguration im kompilierten Artefakt beizubehalten. </p><br><h3 id="compilable-configuration">  Kompilierbare Konfiguration </h3><br><p>  In diesem Abschnitt werden wir ein Beispiel für eine statische Konfiguration diskutieren.  Zwei einfache Dienste - der Echodienst und der Client des Echodienstes - werden konfiguriert und implementiert.  Dann werden zwei verschiedene verteilte Systeme mit beiden Diensten instanziiert.  Eine ist für eine Konfiguration mit einem Knoten und eine andere für die Konfiguration mit zwei Knoten. </p><br><p>  Ein typisches verteiltes System besteht aus wenigen Knoten.  Die Knoten könnten unter Verwendung eines Typs identifiziert werden: </p><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Backend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Frontend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span></span></code> </pre> <br><p>  oder einfach </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">hostName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  oder sogar </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span></code> </pre> <br><p>  Diese Knoten erfüllen verschiedene Rollen, führen einige Dienste aus und sollten über TCP / HTTP-Verbindungen mit den anderen Knoten kommunizieren können. </p><br><p>  Für die TCP-Verbindung ist mindestens eine Portnummer erforderlich.  Wir möchten auch sicherstellen, dass Client und Server dasselbe Protokoll sprechen.  Um eine Verbindung zwischen Knoten zu modellieren, deklarieren wir die folgende Klasse: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TcpEndPoint</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">node: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">NodeId</span></span></span></span><span class="hljs-class"><span class="hljs-params">, port: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Port</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Protocol</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Dabei ist <code>Port</code> nur ein <code>Int</code> innerhalb des zulässigen Bereichs: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortNumber</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Closed</span></span>[_0, <span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-number"><span class="hljs-number">65535</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Verfeinerte Typen</b> <div class="spoiler_text"><p>  Siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfeinerte</a> Bibliothek.  Kurz gesagt, es ermöglicht das Hinzufügen von Einschränkungen für die Kompilierungszeit zu anderen Typen.  In diesem Fall darf <code>Int</code> nur 16-Bit-Werte haben, die die Portnummer darstellen können.  Es ist nicht erforderlich, diese Bibliothek für diesen Konfigurationsansatz zu verwenden.  Es scheint einfach sehr gut zu passen. </p></div></div><br><p>  Für HTTP (REST) ​​benötigen wir möglicherweise auch einen Pfad des Dienstes: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UrlPathPrefix</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">MatchesRegex</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-string"><span class="hljs-string">"[a-zA-Z_0-9/]*"</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortWithPrefix</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">portNumber: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">PortNumber</span></span></span></span><span class="hljs-class"><span class="hljs-params">, pathPrefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">UrlPathPrefix</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Phantomtyp</b> <div class="spoiler_text"><p>  Um das Protokoll während der Kompilierung zu identifizieren, verwenden wir die Scala-Funktion zum Deklarieren des Typargumentprotokolls, das in der Klasse nicht verwendet wird.  Es ist ein sogenannter <em>Phantomtyp</em> .  Zur Laufzeit benötigen wir selten eine Instanz der Protokollkennung, deshalb speichern wir sie nicht.  Während der Kompilierung bietet dieser Phantomtyp zusätzliche Typensicherheit.  Wir können keinen Port mit falschem Protokoll übergeben. </p></div></div><br><p>  Eines der am häufigsten verwendeten Protokolle ist die REST-API mit Json-Serialisierung: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonHttpRestProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  Dabei ist <code>RequestMessage</code> der Basistyp von Nachrichten, die der Client an den Server senden kann, und <code>ResponseMessage</code> ist die Antwortnachricht vom Server.  Natürlich können wir auch andere Protokollbeschreibungen erstellen, die das Kommunikationsprotokoll mit der gewünschten Genauigkeit angeben. </p><br><p>  Für die Zwecke dieses Beitrags verwenden wir eine einfachere Version des Protokolls: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleHttpGetRest</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  In diesem Protokoll wird die Anforderungsnachricht an die URL angehängt und die Antwortnachricht als einfache Zeichenfolge zurückgegeben. </p><br><p>  Eine Dienstkonfiguration kann durch den Dienstnamen, eine Sammlung von Ports und einige Abhängigkeiten beschrieben werden.  Es gibt einige Möglichkeiten, wie all diese Elemente in Scala dargestellt werden können (z. B. <code>HList</code> , algebraische Datentypen).  Für die Zwecke dieses Beitrags verwenden wir das Kuchenmuster und stellen kombinierbare Teile (Module) als Merkmale dar.  (Kuchenmuster ist keine Voraussetzung für diesen kompilierbaren Konfigurationsansatz. Es ist nur eine mögliche Umsetzung der Idee.) </p><br><p>  Abhängigkeiten können mithilfe des Kuchenmusters als Endpunkte anderer Knoten dargestellt werden: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">SimpleHttpGetRest</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8081</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoPort</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]](portNumber, <span class="hljs-string"><span class="hljs-string">"echo"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoService</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = providedSimpleService(echoPort) }</code> </pre> <br><p>  Für den Echo-Dienst muss nur ein Port konfiguriert werden.  Und wir erklären, dass dieser Port das Echo-Protokoll unterstützt.  Beachten Sie, dass wir derzeit keinen bestimmten Port angeben müssen, da das Merkmal abstrakte Methodendeklarationen zulässt.  Wenn wir abstrakte Methoden verwenden, benötigt der Compiler eine Implementierung in einer Konfigurationsinstanz.  Hier haben wir die Implementierung ( <code>8081</code> ) bereitgestellt und sie wird als Standardwert verwendet, wenn wir sie in einer konkreten Konfiguration überspringen. </p><br><p>  Wir können eine Abhängigkeit in der Konfiguration des Echo-Service-Clients deklarieren: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMessage</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"test"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pollInterval</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FiniteDuration</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoServiceDependency</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[_, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] }</code> </pre> <br><p>  Die Abhängigkeit hat den gleichen Typ wie der <code>echoService</code> .  Insbesondere erfordert es das gleiche Protokoll.  Daher können wir sicher sein, dass diese beiden Abhängigkeiten ordnungsgemäß funktionieren, wenn wir sie verbinden. </p><br><div class="spoiler">  <b class="spoiler_title">Implementierung von Diensten</b> <div class="spoiler_text"><p>  Ein Dienst benötigt eine Funktion zum Starten und ordnungsgemäßen Herunterfahren.  (Die Fähigkeit, einen Dienst herunterzufahren, ist für das Testen von entscheidender Bedeutung.) Auch hier gibt es einige Möglichkeiten, eine solche Funktion für eine bestimmte Konfiguration anzugeben (wir könnten beispielsweise Typklassen verwenden).  Für diesen Beitrag verwenden wir wieder Cake Pattern.  Wir können einen Dienst mit <code>cats.Resource</code> Ressource, die bereits Klammern und Ressourcenfreigabe bereitstellt.  Um eine Ressource zu erhalten, sollten wir eine Konfiguration und einen Laufzeitkontext bereitstellen.  Die Dienststartfunktion könnte also folgendermaßen aussehen: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceReader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Resource</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> implicit resolver: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">AddressResolver</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], timer: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Timer</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], contextShift: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ContextShift</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], ec: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ExecutionContext</span></span></span></span><span class="hljs-class"><span class="hljs-params">, applicative: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Applicative</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">] </span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] }</code> </pre> <br><p>  wo </p><br><ul><li>  <code>Config</code> - Konfigurationstyp, der von diesem Servicestarter benötigt wird </li><li>  <code>AddressResolver</code> - ein Laufzeitobjekt, mit dem reale Adressen anderer Knoten <code>AddressResolver</code> werden können (lesen Sie weiter, um Einzelheiten zu <code>AddressResolver</code> ). </li></ul><br><p>  Die anderen Arten stammen von <code>cats</code> : </p><br><ul><li>  <code>F[_]</code> - <code>cats.IO</code> (Im einfachsten Fall könnte <code>F[A]</code> nur <code>() =&gt; A</code> In diesem Beitrag verwenden wir <code>cats.IO</code> ) </li><li>  <code>Reader[A,B]</code> - ist mehr oder weniger ein Synonym für eine Funktion <code>A =&gt; B</code> </li><li>  <code>cats.Resource</code> - hat Möglichkeiten zu erwerben und freizugeben </li><li>  <code>Timer</code> - Ermöglicht das Schlafen / Messen der Zeit </li><li>  <code>ContextShift</code> - analog zu <code>ExecutionContext</code> </li><li>  <code>Applicative</code> - Wrapper der tatsächlichen Funktionen (fast eine Monade) (wir könnten ihn eventuell durch etwas anderes ersetzen) </li></ul><br><p>  Über diese Schnittstelle können wir einige Dienste implementieren.  Zum Beispiel ein Dienst, der nichts tut: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Any</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resource</span></span></span></span>(...): <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">Reader</span></span>(_ =&gt; <span class="hljs-type"><span class="hljs-type">Resource</span></span>.pure[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>](())) }</code> </pre> </div></div><br><p>  (Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellimplementierungen finden Sie unter Quellcode</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echo-Dienst</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echo-Client</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lifetime-Controller</a> .) </p><br><p>  Ein Knoten ist ein einzelnes Objekt, auf dem einige Dienste ausgeführt werden (das Starten einer Ressourcenkette wird durch das Kuchenmuster ermöglicht): </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Beachten Sie, dass wir im Knoten den genauen Konfigurationstyp angeben, der von diesem Knoten benötigt wird.  Der Compiler lässt nicht zu, dass wir das Objekt (Cake) mit unzureichendem Typ erstellen, da jedes Service-Merkmal eine Einschränkung für den <code>Config</code> Typ deklariert.  Außerdem können wir den Knoten nicht starten, ohne eine vollständige Konfiguration bereitzustellen. </p><br><div class="spoiler">  <b class="spoiler_title">Auflösung der Knotenadresse</b> <div class="spoiler_text"><p>  Um eine Verbindung herzustellen, benötigen wir für jeden Knoten eine echte Hostadresse.  Es ist möglicherweise später als andere Teile der Konfiguration bekannt.  Daher benötigen wir eine Möglichkeit, eine Zuordnung zwischen der Knoten-ID und ihrer tatsächlichen Adresse bereitzustellen.  Diese Zuordnung ist eine Funktion: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeAddress</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeId</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">host: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Uri</span></span></span></span><span class="hljs-class"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Host</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressResolver</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>](nodeId: <span class="hljs-type"><span class="hljs-type">NodeId</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">NodeAddress</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>]] }</code> </pre> <br><p>  Es gibt einige Möglichkeiten, eine solche Funktion zu implementieren. </p><br><ol><li>  Wenn wir die tatsächlichen Adressen vor der Bereitstellung kennen, können wir während der Instanziierung der Knotenhosts Scala-Code mit den tatsächlichen Adressen generieren und anschließend den Build ausführen (der die Kompilierungszeit überprüft und dann die Integrationstestsuite ausführt).  In diesem Fall ist unsere Zuordnungsfunktion statisch bekannt und kann zu einer Art <code>Map[NodeId, NodeAddress]</code> vereinfacht werden. </li><li>  Manchmal erhalten wir tatsächliche Adressen erst zu einem späteren Zeitpunkt, wenn der Knoten tatsächlich gestartet wird, oder wir haben keine Adressen von Knoten, die noch nicht gestartet wurden.  In diesem Fall verfügen wir möglicherweise über einen Erkennungsdienst, der vor allen anderen Knoten gestartet wird, und jeder Knoten gibt möglicherweise seine Adresse in diesem Dienst bekannt und abonniert Abhängigkeiten. </li><li>  Wenn wir <code>/etc/hosts</code> ändern können, können wir vordefinierte Hostnamen (wie <code>my-project-main-node</code> und <code>echo-backend</code> ) verwenden und diesen Namen zur Bereitstellungszeit einfach mit der IP-Adresse verknüpfen. </li></ol><br><p>  In diesem Beitrag werden diese Fälle nicht näher erläutert.  In unserem Spielzeugbeispiel haben alle Knoten dieselbe IP-Adresse - <code>127.0.0.1</code> . </p></div></div><br><p>  In diesem Beitrag werden zwei verteilte Systemlayouts betrachtet: </p><br><ol><li>  Einzelknotenlayout, bei dem alle Dienste auf dem Einzelknoten platziert werden. </li><li>  Zwei-Knoten-Layout, bei dem sich Service und Client auf verschiedenen Knoten befinden. </li></ol><br><p>  Die Konfiguration für ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzelnes</a> Knotenlayout lautet wie folgt: </p><br><div class="spoiler">  <b class="spoiler_title">Einzelknotenkonfiguration</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identifier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">single</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">configuration</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span> <span class="hljs-comment"><span class="hljs-comment">/** Type safe service port specification. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8088</span></span> <span class="hljs-comment"><span class="hljs-comment">// configuration of client /** We'll use the service provided by the same host. */ def echoServiceDependency = echoService override def testMessage: UrlPathElement = "hello" def pollInterval: FiniteDuration = 1.second // lifecycle controller configuration def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 requests, not 9. }</span></span></code> </pre> </div></div><br><p>  Hier erstellen wir eine einzelne Konfiguration, die sowohl die Server- als auch die Client-Konfiguration erweitert.  Außerdem konfigurieren wir einen Lifecycle-Controller, der normalerweise Client und Server nach <code>lifetime</code> beendet. </p><br><p>  Mit denselben Service-Implementierungen und -Konfigurationen kann das Layout eines Systems mit zwei separaten Knoten erstellt werden.  Wir müssen nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei separate Knotenkonfigurationen</a> mit den entsprechenden Diensten erstellen: </p><br><div class="spoiler">  <b class="spoiler_title">Konfiguration mit zwei Knoten</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigTermLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeIdImpl</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeServer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8080</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeClientConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NB! dependency specification def echoServiceDependency = NodeServerConfig.echoService def pollInterval: FiniteDuration = 1.second def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 request, not 9. def testMessage: String = "dolly" }</span></span></code> </pre> </div></div><br><p>  Sehen Sie, wie wir die Abhängigkeit angeben.  Wir erwähnen den bereitgestellten Dienst des anderen Knotens als Abhängigkeit vom aktuellen Knoten.  Die Art der Abhängigkeit wird überprüft, da sie einen Phantomtyp enthält, der das Protokoll beschreibt.  Und zur Laufzeit haben wir die richtige Knoten-ID.  Dies ist einer der wichtigen Aspekte des vorgeschlagenen Konfigurationsansatzes.  Es gibt uns die Möglichkeit, den Port nur einmal festzulegen und sicherzustellen, dass wir auf den richtigen Port verweisen. </p><br><div class="spoiler">  <b class="spoiler_title">Implementierung mit zwei Knoten</b> <div class="spoiler_text"><p>  Für diese Konfiguration verwenden wir genau die gleichen Service-Implementierungen.  Überhaupt keine Änderungen.  Wir erstellen jedoch zwei verschiedene Knotenimplementierungen, die unterschiedliche Dienste enthalten: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeServerImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigIntLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">SigTermLifecycleConfig</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeClientImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Der erste Knoten implementiert den Server und benötigt nur die serverseitige Konfiguration.  Der zweite Knoten implementiert den Client und benötigt einen anderen Teil der Konfiguration.  Beide Knoten erfordern eine Lebensdauerangabe.  Für die Zwecke dieses Post-Service-Knotens hat er eine unendliche Lebensdauer, die mit <code>SIGTERM</code> beendet werden kann, während der Echo-Client nach der konfigurierten endlichen Dauer beendet wird.  Einzelheiten finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Starteranwendung</a> . </p></div></div><br><h4 id="overall-development-process">  Gesamtentwicklungsprozess </h4><br><p>  Mal sehen, wie dieser Ansatz die Art und Weise verändert, wie wir mit der Konfiguration arbeiten. </p><br><p>  Die Konfiguration als Code wird kompiliert und erzeugt ein Artefakt.  Es erscheint sinnvoll, Konfigurationsartefakte von anderen Code-Artefakten zu trennen.  Oft können wir eine Vielzahl von Konfigurationen auf derselben Codebasis haben.  Und natürlich können wir mehrere Versionen verschiedener Konfigurationszweige haben.  In einer Konfiguration können wir bestimmte Versionen von Bibliotheken auswählen. Diese bleiben bei jeder Bereitstellung dieser Konfiguration konstant. </p><br><p>  Eine Konfigurationsänderung wird zu einer Codeänderung.  Es sollte also denselben Qualitätssicherungsprozess durchlaufen: </p><br><p>  Ticket -&gt; PR -&gt; Überprüfung -&gt; Zusammenführen -&gt; kontinuierliche Integration -&gt; kontinuierliche Bereitstellung </p><br><p>  Der Ansatz hat folgende Konsequenzen: </p><br><ol><li><p>  Die Konfiguration ist für die Instanz eines bestimmten Systems kohärent.  Es scheint, dass es keine Möglichkeit gibt, eine falsche Verbindung zwischen Knoten herzustellen. </p><br></li><li><p>  Es ist nicht einfach, die Konfiguration nur in einem Knoten zu ändern.  Es erscheint unvernünftig, sich anzumelden und einige Textdateien zu ändern.  Dadurch wird eine Konfigurationsdrift weniger möglich. </p><br></li><li><p>  Kleine Konfigurationsänderungen sind nicht einfach vorzunehmen. </p><br></li><li><p>  Die meisten Konfigurationsänderungen folgen demselben Entwicklungsprozess und werden überprüft. </p><br></li></ol><br><p>  Benötigen wir ein separates Repository für die Produktionskonfiguration?  Die Produktionskonfiguration enthält möglicherweise vertrauliche Informationen, die wir für viele Menschen unerreichbar halten möchten.  Es kann sich daher lohnen, ein separates Repository mit eingeschränktem Zugriff zu führen, das die Produktionskonfiguration enthält.  Wir können die Konfiguration in zwei Teile aufteilen - einen, der die offensten Produktionsparameter enthält, und einen, der den geheimen Teil der Konfiguration enthält.  Dies würde den Zugriff der meisten Entwickler auf die meisten Parameter ermöglichen und gleichzeitig den Zugriff auf wirklich sensible Dinge einschränken.  Dies lässt sich leicht mit Zwischenmerkmalen mit Standardparameterwerten erreichen. </p><br><h3 id="variations">  Variationen </h3><br><p>  Lassen Sie uns die Vor- und Nachteile des vorgeschlagenen Ansatzes im Vergleich zu den anderen Konfigurationsmanagementtechniken sehen. </p><br><p>  Zunächst werden einige Alternativen zu den verschiedenen Aspekten der vorgeschlagenen Art des Umgangs mit der Konfiguration aufgeführt: </p><br><ol><li>  Textdatei auf dem Zielcomputer. </li><li>  Zentraler Schlüsselwertspeicher (wie <code>etcd</code> / <code>zookeeper</code> ). </li><li>  Unterprozesskomponenten, die ohne Neustart des Prozesses neu konfiguriert / neu gestartet werden können. </li><li>  Konfiguration außerhalb der Artefakt- und Versionskontrolle. </li></ol><br><p>  Die Textdatei bietet eine gewisse Flexibilität in Bezug auf Ad-hoc-Korrekturen.  Der Administrator eines Systems kann sich beim Zielknoten anmelden, Änderungen vornehmen und den Dienst einfach neu starten.  Dies ist möglicherweise nicht so gut für größere Systeme.  Hinter der Änderung bleiben keine Spuren zurück.  Die Änderung wird nicht von einem anderen Augenpaar überprüft.  Es könnte schwierig sein herauszufinden, was die Änderung verursacht hat.  Es wurde nicht getestet.  Aus Sicht des verteilten Systems kann ein Administrator einfach vergessen, die Konfiguration auf einem der anderen Knoten zu aktualisieren. </p><br><p>  (Übrigens, wenn irgendwann die Verwendung von Textkonfigurationsdateien erforderlich sein muss, müssen wir nur Parser + Validator hinzufügen, der denselben <code>Config</code> erzeugen kann und der ausreicht, um Textkonfigurationen zu verwenden. Dies zeigt auch, dass die Die Komplexität der Konfiguration zur Kompilierungszeit ist etwas geringer als die Komplexität textbasierter Konfigurationen, da wir in der textbasierten Version zusätzlichen Code benötigen.) </p><br><p>  Der zentralisierte Schlüsselwertspeicher ist ein guter Mechanismus zum Verteilen von Anwendungsmetaparametern.  Hier müssen wir darüber nachdenken, was wir als Konfigurationswerte betrachten und was nur Daten sind.  Bei einer Funktion <code>C =&gt; A =&gt; B</code> wir normalerweise selten wechselnde Werte <code>C</code> "Konfiguration", während häufig geänderte Daten <code>A</code> - nur Daten eingeben.  Die Funktion sollte früher als die Daten <code>A</code> konfiguriert werden <code>A</code>  Angesichts dieser Idee können wir sagen, dass es die erwartete Häufigkeit von Änderungen ist, die verwendet werden könnten, um Konfigurationsdaten von nur Daten zu unterscheiden.  Außerdem stammen Daten normalerweise aus einer Quelle (Benutzer) und die Konfiguration aus einer anderen Quelle (Administrator).  Der Umgang mit Parametern, die nach der Prozessinitialisierung geändert werden können, führt zu einer Erhöhung der Anwendungskomplexität.  Für solche Parameter müssen wir ihren Übermittlungsmechanismus, das Parsen und die Validierung sowie falsche Werte behandeln.  Um die Programmkomplexität zu verringern, sollten wir daher die Anzahl der Parameter reduzieren, die sich zur Laufzeit ändern können (oder sie sogar ganz eliminieren). </p><br><p>  Aus der Perspektive dieses Beitrags sollten wir zwischen statischen und dynamischen Parametern unterscheiden.  Wenn die Servicelogik zur Laufzeit eine seltene Änderung einiger Parameter erfordert, können wir sie als dynamische Parameter bezeichnen.  Andernfalls sind sie statisch und können mit dem vorgeschlagenen Ansatz konfiguriert werden.  Für die dynamische Rekonfiguration sind möglicherweise andere Ansätze erforderlich.  Beispielsweise können Teile des Systems mit den neuen Konfigurationsparametern ähnlich wie beim Neustart separater Prozesse eines verteilten Systems neu gestartet werden. <br>  (Meine bescheidene Meinung ist, eine Neukonfiguration der Laufzeit zu vermeiden, da dies die Komplexität des Systems erhöht. <br>  Es ist möglicherweise einfacher, sich beim Neustart von Prozessen nur auf die Unterstützung des Betriebssystems zu verlassen.  Dies ist jedoch möglicherweise nicht immer möglich.) </p><br><p>  Ein wichtiger Aspekt bei der Verwendung der statischen Konfiguration, der manchmal dazu führt, dass Benutzer eine dynamische Konfiguration in Betracht ziehen (ohne andere Gründe), ist die Ausfallzeit des Dienstes während der Konfigurationsaktualisierung.  Wenn wir Änderungen an der statischen Konfiguration vornehmen müssen, müssen wir das System neu starten, damit neue Werte wirksam werden.  Die Anforderungen an Ausfallzeiten variieren für verschiedene Systeme, daher ist dies möglicherweise nicht so kritisch.  Wenn es kritisch ist, müssen wir einen Neustart des Systems im Voraus planen.  Zum Beispiel könnten wir das Entleeren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS ELB-Verbindungen</a> implementieren.  In diesem Szenario starten wir bei jedem Neustart des Systems parallel eine neue Instanz des Systems und schalten dann ELB darauf um, während das alte System die Wartung bestehender Verbindungen abschließen kann. </p><br><p>  Was ist mit der Konfiguration innerhalb eines versionierten Artefakts oder außerhalb?  Wenn Sie die Konfiguration in einem Artefakt behalten, bedeutet dies in den meisten Fällen, dass diese Konfiguration denselben Qualitätssicherungsprozess wie andere Artefakte durchlaufen hat.  Man könnte also sicher sein, dass die Konfiguration von guter Qualität und vertrauenswürdig ist.  Im Gegenteil, die Konfiguration in einer separaten Datei bedeutet, dass keine Spuren davon vorhanden sind, wer und warum Änderungen an dieser Datei vorgenommen haben.  Ist das wichtig  Wir glauben, dass es für die meisten Produktionssysteme besser ist, eine stabile und qualitativ hochwertige Konfiguration zu haben. </p><br><p>  Mit der Version des Artefakts können Sie herausfinden, wann es erstellt wurde, welche Werte es enthält, welche Funktionen aktiviert / deaktiviert sind und wer für jede Änderung in der Konfiguration verantwortlich war.  Es kann einige Anstrengungen erfordern, die Konfiguration in einem Artefakt zu halten, und es ist eine Designentscheidung, die getroffen werden muss. </p><br><h3 id="pros--cons">  Vor- und Nachteile </h3><br><p>  Hier möchten wir einige Vorteile hervorheben und einige Nachteile des vorgeschlagenen Ansatzes diskutieren. </p><br><h4 id="advantages">  Vorteile </h4><br><p>  Merkmale der kompilierbaren Konfiguration eines vollständig verteilten Systems: </p><br><ol><li>  Statische Überprüfung der Konfiguration.  Dies gibt ein hohes Maß an Sicherheit, dass die Konfiguration bei Typbeschränkungen korrekt ist. </li><li>  Reichhaltige Konfigurationssprache.  Typischerweise beschränken sich andere Konfigurationsansätze auf höchstens variable Substitution. <br>  Mit Scala kann man eine Vielzahl von Sprachfunktionen verwenden, um die Konfiguration zu verbessern.  Zum Beispiel können wir Merkmale verwenden, um Standardwerte bereitzustellen, Objekte, um unterschiedliche <code>val</code> festzulegen. Wir können auf Werte verweisen, die nur einmal im äußeren Bereich (DRY) definiert sind.  Es ist möglich, Literalsequenzen oder Instanzen bestimmter Klassen ( <code>Seq</code> , <code>Map</code> usw.) zu verwenden. </li><li>  DSL  Scala hat gute Unterstützung für DSL-Autoren.  Mit diesen Funktionen kann eine Konfigurationssprache eingerichtet werden, die bequemer und benutzerfreundlicher ist, sodass die endgültige Konfiguration zumindest für Domänenbenutzer lesbar ist. </li><li>  Integrität und Kohärenz über Knoten hinweg.  Einer der Vorteile einer Konfiguration für das gesamte verteilte System an einem Ort besteht darin, dass alle Werte streng einmal definiert und dann an allen Stellen wiederverwendet werden, an denen wir sie benötigen.  Geben Sie außerdem sichere Portdeklarationen ein, um sicherzustellen, dass die Knoten des Systems in allen möglichen korrekten Konfigurationen dieselbe Sprache sprechen.  Es gibt explizite Abhängigkeiten zwischen Knoten, die es schwierig machen, die Bereitstellung einiger Dienste zu vergessen. </li><li>  Hohe Qualität der Änderungen.  Der Gesamtansatz, Konfigurationsänderungen durch einen normalen PR-Prozess zu übergeben, legt auch in der Konfiguration hohe Qualitätsstandards fest. </li><li>  Gleichzeitige Konfigurationsänderungen.  Wenn wir Änderungen an der Konfiguration vornehmen, stellt die automatische Bereitstellung sicher, dass alle Knoten aktualisiert werden. </li><li>  Vereinfachung der Anwendung.  Die Anwendung muss die Konfiguration nicht analysieren und validieren und falsche Konfigurationswerte verarbeiten.  Dies vereinfacht die Gesamtanwendung.  (Die Konfiguration selbst nimmt etwas an Komplexität zu, ist jedoch ein bewusster Kompromiss zur Sicherheit.) Es ist ziemlich einfach, zur normalen Konfiguration zurückzukehren - fügen Sie einfach die fehlenden Teile hinzu.  Es ist einfacher, mit der kompilierten Konfiguration zu beginnen und die Implementierung zusätzlicher Teile auf einen späteren Zeitpunkt zu verschieben. </li><li>  Versionierte Konfiguration.  Aufgrund der Tatsache, dass Konfigurationsänderungen dem gleichen Entwicklungsprozess folgen, erhalten wir ein Artefakt mit einer eindeutigen Version.  Dadurch können wir die Konfiguration bei Bedarf zurückschalten.  Wir können sogar eine Konfiguration bereitstellen, die vor einem Jahr verwendet wurde, und sie funktioniert genauso.  Eine stabile Konfiguration verbessert die Vorhersagbarkeit und Zuverlässigkeit des verteilten Systems.  Die Konfiguration ist zur Kompilierungszeit festgelegt und kann auf einem Produktionssystem nicht einfach manipuliert werden. </li><li>  Modularität  Das vorgeschlagene Framework ist modular aufgebaut und Module können auf verschiedene Arten kombiniert werden <br>  unterstützen verschiedene Konfigurationen (Setups / Layouts).  Insbesondere ist es möglich, ein kleines Einzelknotenlayout und eine große Mehrknoteneinstellung zu haben.  Es ist vernünftig, mehrere Produktionslayouts zu haben. </li><li>  Testen  Zu Testzwecken kann man einen Mock-Service implementieren und ihn typsicher als Abhängigkeit verwenden.  Einige verschiedene Testlayouts mit verschiedenen Teilen, die durch Mocks ersetzt wurden, konnten gleichzeitig beibehalten werden. </li><li>  Integrationstests.  In verteilten Systemen ist es manchmal schwierig, Integrationstests durchzuführen.  Mit dem beschriebenen Ansatz zur typsicheren Konfiguration des gesamten verteilten Systems können wir alle verteilten Teile auf kontrollierbare Weise auf einem einzigen Server ausführen.  Es ist einfach, die Situation zu emulieren <br>  wenn einer der Dienste nicht mehr verfügbar ist. </li></ol><br><h4 id="disadvantages">  Nachteile </h4><br><p>  Der kompilierte Konfigurationsansatz unterscheidet sich von der "normalen" Konfiguration und entspricht möglicherweise nicht allen Anforderungen.  Hier sind einige der Nachteile der kompilierten Konfiguration: </p><br><ol><li>  Statische Konfiguration.  Es ist möglicherweise nicht für alle Anwendungen geeignet.  In einigen Fällen muss die Konfiguration in der Produktion unter Umgehung aller Sicherheitsmaßnahmen schnell repariert werden.  Dieser Ansatz macht es schwieriger.  Die Kompilierung und erneute Bereitstellung ist erforderlich, nachdem Änderungen an der Konfiguration vorgenommen wurden.  Dies ist sowohl das Merkmal als auch die Belastung. </li><li>  Konfigurationsgenerierung.  Wenn die Konfiguration von einem Automatisierungstool generiert wird, erfordert dieser Ansatz eine nachfolgende Kompilierung (die wiederum fehlschlagen kann).  Die Integration dieses zusätzlichen Schritts in das Build-System erfordert möglicherweise zusätzlichen Aufwand. </li><li>  Instrumente.  Heutzutage werden viele Tools verwendet, die auf textbasierten Konfigurationen basieren.  Einige von ihnen <br>  gilt nicht, wenn die Konfiguration kompiliert wird. </li><li>  Eine Änderung der Denkweise ist erforderlich.  Entwickler und DevOps sind mit Textkonfigurationsdateien vertraut.  Die Idee, die Konfiguration zu kompilieren, mag ihnen seltsam erscheinen. </li><li>  Vor der Einführung einer kompilierbaren Konfiguration ist ein qualitativ hochwertiger Softwareentwicklungsprozess erforderlich. </li></ol><br><p>  Das implementierte Beispiel weist einige Einschränkungen auf: </p><br><ol><li>  Wenn wir eine zusätzliche Konfiguration bereitstellen, die von der Knotenimplementierung nicht verlangt wird, hilft uns der Compiler nicht dabei, die fehlende Implementierung zu erkennen.  Dies könnte durch die Verwendung von <code>HList</code> oder ADTs ( <code>HList</code> ) für die Knotenkonfiguration anstelle von Merkmalen und <code>HList</code> . </li><li>  Wir müssen ein Boilerplate in der Konfigurationsdatei bereitstellen: ( <code>package</code> , <code>import</code> , <code>object</code> ; <br>  <code>override def</code> für Parameter mit Standardwerten <code>override def</code> ).  Dies kann teilweise mit einem DSL behoben werden. </li><li>  In diesem Beitrag behandeln wir nicht die dynamische Rekonfiguration von Clustern ähnlicher Knoten. </li></ol><br><h3 id="conclusion">  Fazit </h3><br><p>  In diesem Beitrag haben wir die Idee diskutiert, die Konfiguration direkt im Quellcode typsicher darzustellen.  Der Ansatz könnte in vielen Anwendungen als Ersatz für XML- und andere textbasierte Konfigurationen verwendet werden.  Obwohl unser Beispiel in Scala implementiert wurde, könnte es auch in andere kompilierbare Sprachen (wie Kotlin, C #, Swift usw.) übersetzt werden.  Man könnte diesen Ansatz in einem neuen Projekt ausprobieren und, falls er nicht gut passt, auf die altmodische Weise wechseln. </p><br><p>  Natürlich erfordert eine kompilierbare Konfiguration einen qualitativ hochwertigen Entwicklungsprozess.  Im Gegenzug verspricht es eine ebenso hochwertige robuste Konfiguration. </p><br><p>  Dieser Ansatz könnte auf verschiedene Arten erweitert werden: </p><br><ol><li>  Man könnte Makros verwenden, um die Konfigurationsvalidierung durchzuführen und zur Kompilierungszeit fehlzuschlagen, falls geschäftslogische Einschränkungen fehlschlagen. </li><li>  Ein DSL könnte implementiert werden, um die Konfiguration domänenbenutzerfreundlich darzustellen. </li><li>  Dynamisches Ressourcenmanagement mit automatischen Konfigurationsanpassungen.  Wenn wir beispielsweise die Anzahl der Clusterknoten anpassen, möchten wir möglicherweise (1), dass die Knoten eine leicht modifizierte Konfiguration erhalten;  (2) Cluster-Manager zum Empfangen neuer Knoteninformationen. </li></ol><br><h3 id="thanks">  Danke </h3><br><p>  Ich möchte mich bei Andrey Saksonov, Pavel Popov und Anton Nehaev für das inspirierende Feedback zum Entwurf dieses Beitrags bedanken, das mir geholfen hat, ihn klarer zu machen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447690/">https://habr.com/ru/post/de447690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447680/index.html">Emulationsübungen: Xbox 360 FMA-Handbuch</a></li>
<li><a href="../de447682/index.html">Space Data Center: 24 Stunden vor dem Start</a></li>
<li><a href="../de447684/index.html">So zeigen Sie Unternehmenswerte in einem Büro (ohne Poster und Slogans)</a></li>
<li><a href="../de447686/index.html">Ein sehr wichtiger Parameter von LED-Lampen, den nur wenige kennen</a></li>
<li><a href="../de447688/index.html">Auf die Frage nach Bitset</a></li>
<li><a href="../de447694/index.html">Kompilierte verteilte Systemkonfiguration</a></li>
<li><a href="../de447696/index.html">Warum Städte gegen Amazon Go sind, die ersten bargeldlosen Geschäfte</a></li>
<li><a href="../de447698/index.html">Red Hogwarts: Akademiker ohne Diplom</a></li>
<li><a href="../de447700/index.html">Emotionale Flexibilität ist der Schlüssel zum persönlichen Wachstum.</a></li>
<li><a href="../de447702/index.html">Der ideale mathematische Kreis existiert nicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>