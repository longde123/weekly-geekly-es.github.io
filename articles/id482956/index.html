<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèº üöµüèø ü•Ä Tinjauan WCS 5.2 - Server WebRTC untuk Pengembang Webcast dan Webcam üë∂üèæ ‚èèÔ∏è üë©üèø‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alice adalah pengembang tumpukan penuh berpengalaman, yang mampu menulis kerangka kerja proyek SAAS pada kerangka favoritnya menggunakan php dalam sem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tinjauan WCS 5.2 - Server WebRTC untuk Pengembang Webcast dan Webcam</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/482956/"><img src="https://habrastorage.org/webt/za/go/wo/zagowolkguxr8_bdsbwjmkvyd0a.jpeg"><br><br><p>  Alice adalah pengembang tumpukan penuh berpengalaman, yang mampu menulis kerangka kerja proyek SAAS pada kerangka favoritnya menggunakan php dalam seminggu.  Adapun frontend, dia lebih suka Vue.js. </p><br><p>  Seorang klien menghubungi Anda melalui Telegram, meminta Anda untuk mengembangkan situs web yang akan menjadi tempat pertemuan bagi majikan dan karyawan untuk melakukan wawancara secara langsung.  Secara langsung berarti tatap muka, kontak video langsung secara real time dengan video dan suara.  "Mengapa tidak menggunakan Skype?" Beberapa orang mungkin bertanya.  Kebetulan proyek-proyek serius - dan setiap startup tidak diragukan lagi menganggap dirinya sebagai proyek serius - sedang mencoba menawarkan layanan komunikasi internal untuk berbagai alasan, termasuk: </p><a name="habracut"></a><br><p>  1) Mereka tidak ingin meminjamkan penggunanya kepada komunikator pihak ketiga (Skype, Hangouts, dll.) Dan ingin mempertahankan mereka dalam layanan. </p><br><p>  2) Keinginan untuk memantau komunikasi mereka, seperti riwayat panggilan dan hasil wawancara. </p><br><p>  3) Rekam panggilan (tentu saja, memberi tahu kedua belah pihak tentang rekaman). </p><br><p>  4) Mereka tidak ingin bergantung pada kebijakan dan pembaruan layanan pihak ketiga.  Semua orang tahu cerita ini: Skype diperbarui, dan semuanya menjadi asap ... </p><br><p>  Sepertinya ini tugas yang mudah.  WebRTC muncul saat googling pada topik, dan sepertinya Anda dapat mengatur koneksi peer-to-peer antara dua browser, tetapi masih ada beberapa pertanyaan: </p><br><p>  1) Di mana mendapatkan server STUN / TURN? </p><br><p>  2) Bisakah kita melakukannya tanpa mereka? </p><br><p>  3) Bagaimana cara merekam panggilan WebRTC peer-to-peer? </p><br><p>  4) Apa yang akan terjadi jika kita perlu menambahkan pihak ketiga ke dalam panggilan, misalnya, manajer SDM atau spesialis lain dari pemberi kerja? </p><br><p>  Ternyata WebRTC dan peer-to-peer saja tidak cukup, dan tidak jelas apa yang harus dilakukan dengan semua ini untuk meluncurkan fungsi video layanan yang diperlukan. </p><br><h2>  Konten artikel </h2><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Server dan API</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Aliran masuk</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rtsp</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Vod</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">SIP / RTP</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Aliran keluar</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rtsp</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">MSE</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Hl</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Masuk dan keluar</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Manipulasi arus masuk</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rekaman aliran masuk</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Mengambil foto</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Menambahkan aliran ke mixer</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Streaming transcoding</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Menambahkan tanda air</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Menambahkan filter FPS</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rotasi gambar sebesar 90, 180, 270 derajat</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Manajemen aliran masuk</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Pengaliran arus</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">SIP / RTP</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Menghubungkan server ke jaringan pemrosesan konten CDN</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Untuk meringkas</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Tautan</a> </li></ul><br></div></div><br><h2><a name="serverapi"></a>  Server dan API </h2><br><p>  Untuk menutup celah ini, solusi server dan arsitektur peer-server-peer digunakan.  Web Call Server 5.2 (selanjutnya - WCS) adalah salah satu solusi server;  ini adalah platform pengembangan yang memungkinkan Anda untuk menambahkan fungsi video ke proyek dan tidak khawatir tentang STUN / MENGHIDUPKAN dan stabilitas koneksi peer-to-peer. </p><br><p>  Pada level tertinggi, WCS adalah bagian JavaScript API + server.  API digunakan untuk pengembangan menggunakan JavaScript biasa di sisi browser, dan server memproses lalu lintas video, bertindak sebagai Proksi Stateful untuk lalu lintas media. </p><br><p><img src="https://habrastorage.org/webt/7a/w0/qv/7aw0qvwyfc9tak6ij9ycdr1sju4.png"></p><br><p>  Selain JavaScript API, ada juga SDK Android dan iOS SDK, yang masing-masing diperlukan untuk mengembangkan aplikasi seluler asli untuk iOS dan Android. </p><br><p>  Misalnya, menerbitkan aliran ke server (streaming dari webcam ke server) terlihat seperti ini: </p><br><p>  Sdk web </p><br><pre><code class="plaintext hljs">session.createStream({name:‚Äùstream123‚Äù}).publish();</code> </pre> <br><p>  Android SDK </p><br><pre> <code class="plaintext hljs">publishStream = session.createStream(streamOptions) publishStream.publish();</code> </pre><br><p>  iOS SDK </p><br><pre> <code class="plaintext hljs">FPWCSApi2Stream *stream = [session createStream:options error:&amp;error]; if(![stream publish:&amp;error]) { //published without errors }</code> </pre><br><p>  Sebagai hasilnya, kami dapat menerapkan tidak hanya aplikasi web, tetapi juga up-up penuh untuk Google Play dan App Store dengan dukungan streaming video.  Jika kita menambahkan SDK seluler ke gambar tingkat atas, kita akan mendapatkan ini: </p><br><p><img src="https://habrastorage.org/webt/tf/z-/ya/tfz-yax_izaf-eyitcvd57y82h0.png"></p><br><p></p><br><h2><a name="Incomingstreams"></a>  Aliran masuk </h2><br><p>  Server streaming, yaitu WCS, dimulai dengan aliran masuk.  Untuk mendistribusikan sesuatu, kita perlu memilikinya.  Untuk mendistribusikan streaming video ke pemirsa, aliran ini perlu masuk ke server, melalui RAM-nya, dan keluar melalui kartu jaringan.  Oleh karena itu, pertanyaan pertama yang perlu kita tanyakan ketika membiasakan diri dengan server media adalah protokol dan format apa yang digunakan terakhir untuk menerima stream.  Dalam hal WCS, ini adalah teknologi berikut: WebRTC, RTMP, RTSP, VOD, SIP / RTP. </p><br><p><img src="https://habrastorage.org/webt/du/2r/pc/du2rpcr6ihdkicklwlyusrodjog.png"></p><br><p>  Setiap protokol dapat digunakan oleh beragam klien.  Misalnya, tidak hanya aliran dari browser yang dapat masuk melalui WebRTC, tetapi juga dari server lain.  Dalam tabel di bawah ini ada kemungkinan sumber lalu lintas masuk. </p><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>WebRTC</strong> </td><td>  <strong>RTMP</strong> </td><td>  <strong>Rtsp</strong> </td><td>  <strong>Vod</strong> </td><td>  <strong>SIP / RTP</strong> </td></tr><tr><td><ul><li>  Sdk web <br><ul><li>  kamera + mic </li><li>  kanvas </li><li>  berbagi layar </li></ul><br></li><li>  Android SDK </li><li>  iOS SDK </li><li>  WCS <br><ul><li>  mendorong </li><li>  tarik </li></ul><br></li><li>  Cdn </li></ul><br></td><td><ul><li>  Encoder RTMP <br><ul><li>  ffmpeg </li><li>  Obs </li><li>  Wirecast </li></ul><br></li><li>  Adobe encoder </li><li>  WCS <br><ul><li>  mendorong </li><li>  tarik </li></ul><br></li><li>  Flash player </li></ul><br></td><td><ul><li>  Kamera IP </li><li>  Server RTSP </li></ul><br></td><td><ul><li>  Sistem File </li><li>  AWS S3 </li></ul><br></td><td><ul><li>  SIP titik akhir </li><li>  Konferensi SIP </li></ul><br></td></tr></tbody></table></div><br><br><p>  Jika kita menelusuri sumber lalu lintas masuk, kita dapat menambahkan yang berikut ini: <br></p><br><h3> <strong><a name="inWebRTC"></a></strong>  <strong>WebRTC yang masuk</strong> </h3><br><p>  Web SDK memungkinkan tidak hanya menangkap kamera dan mikrofon, tetapi juga menggunakan kemampuan API browser untuk mengakses layar dengan cara berbagi layar.  Selain itu, kami dapat menangkap elemen Canvas yang sewenang-wenang, dan semua yang digambar untuk siaran selanjutnya adalah streaming kanvas: </p><br><p>  Karena spesifik seluler, SDK Android dan iOS SDK memiliki kemampuan untuk beralih antara kamera depan dan belakang perangkat saat dalam perjalanan.  Ini memungkinkan kita untuk mengganti sumber selama streaming tanpa harus menghentikan aliran. </p><br><p>  Aliran WebRTC yang masuk juga dapat diperoleh dari server WCS lain menggunakan metode push, pull dan CDN, yang akan dibahas nanti. </p><br><p><img src="https://habrastorage.org/webt/zn/rw/5i/znrw5ikkd8vcjuexwarfzeqkhg4.jpeg"></p><br><p></p><br><h3> <strong><a name="inRTMP"></a></strong>  <strong>Rtmp masuk</strong> </h3><br><p>  Protokol RTMP secara luas digunakan dalam OBS favorit streamer, serta dalam enkoder lain: Wirecast, Adobe Media Encoder, ffmpeg, dll.  Dengan menggunakan salah satu encoders ini, kita dapat menangkap stream dan mengirimkannya ke server. </p><br><p>  Kami juga dapat mengambil aliran RTMP dari server media lain atau server WCS menggunakan metode push dan pull.  Dalam hal push, inisiator adalah server jarak jauh.  Dalam kasus tarikan, kita beralih ke server lokal untuk menarik aliran dari yang jauh. </p><br><p><img src="https://habrastorage.org/webt/3o/8x/f8/3o8xf84v5rx2apw_09n_lm2cjoe.jpeg"></p><br><p></p><br><h3> <strong><a name="inRTSP"></a></strong>  <strong>Rtsp masuk</strong> </h3><br><p>  Sumber lalu lintas RTSP biasanya adalah kamera IP atau server media pihak ketiga yang mendukung protokol RTSP.  Terlepas dari kenyataan bahwa ketika memulai koneksi RTSP, inisiatornya adalah WCS, lalu lintas audio dan video dalam arah dari kamera IP bergerak ke arah server WCS.  Oleh karena itu, kami menganggap aliran dari kamera masuk. </p><br><p><img src="https://habrastorage.org/webt/ch/pj/qi/chpjqiof2ipgoqzmwx0zzkewrgm.jpeg"></p><br><p></p><br><h3> <strong><a name="inVOD"></a></strong>  <strong>Vod masuk</strong> </h3><br><p>  Pada pandangan pertama, sepertinya fungsi VOD (Video On Demand) secara eksklusif terkait dengan stream keluar dan dengan pemutaran file oleh browser.  Tetapi dalam kasus kami, ini tidak sepenuhnya benar.  WCS menyiarkan file mp4 dari sistem file ke localhost;  sebagai hasilnya, aliran masuk dibuat, seolah-olah itu berasal dari sumber pihak ketiga.  Lebih jauh, jika kita membatasi satu viewer menjadi satu file mp4, kita mendapatkan VOD klasik, di mana viewer mendapatkan stream dan memainkannya dari awal.  Jika kami tidak membatasi satu pemirsa ke satu file mp4, kami mendapatkan VOD LIVE - variasi VOD, di mana pemirsa dapat memutar file yang sama sebagai streaming, menghubungkan ke titik pemutaran di mana semua yang lain saat ini berada (pra- mode siaran televisi yang direkam). </p><br><p><img src="https://habrastorage.org/webt/cn/ot/tv/cnottvwwytktaxh9vnbjexlxlaq.jpeg"></p><br><p></p><br><h3> <strong><a name="inSIP-RTP"></a></strong>  <strong>SIP / RTP masuk</strong> </h3><br><p>  Untuk menerima lalu lintas RTP masuk dalam sesi SIP, kita perlu mengatur panggilan dengan gateway SIP pihak ketiga.  Jika koneksi berhasil dibuat, lalu lintas audio dan / video akan pergi dari gateway SIP, yang akan dibungkus dalam aliran masuk di sisi WCS. </p><br><p><img src="https://habrastorage.org/webt/-r/km/io/-rkmio-9lhqlfjioblwkanzuxiq.jpeg"></p><br><p></p><br><h2><a name="Outgoingstreams"></a>  Aliran keluar </h2><br><p>  Setelah menerima aliran ke server, kami dapat mereplikasi aliran yang diterima ke satu atau banyak pemirsa berdasarkan permintaan.  Penampil meminta streaming dari pemain atau perangkat lain.  Streaming semacam itu disebut outgoing atau "viewer stream," karena sesi aliran seperti itu selalu dimulai di sisi penonton / pemain.  Perangkat teknologi pemutaran meliputi protokol / format berikut: WebRTC, RTMP, RTSP, MSE, dan HLS. </p><br><br><div class="scrollable-table"><table><thead><tr><th>  WebRTC </th><th>  RTMP </th><th>  Rtsp </th><th>  MSE </th><th>  Hl </th></tr></thead><tbody><tr><td><ul><li>  Sdk web </li><li>  Android SDK </li><li>  iOS SDK </li><li>  WC <br><ul><li>  tarik </li><li>  Cdn </li></ul><br></li></ul><br></td><td><ul><li>  Flash player </li><li>  Pemain RTMP </li></ul><br></td><td><ul><li>  RTSP Player <br><ul><li>  VLC </li><li>  WCS </li><li>  dll </li></ul><br></li></ul><br></td><td><ul><li>  Sdk web </li></ul><br></td><td><ul><li>  Pemain HLS <br><ul><li>  hls.js </li><li>  safari asli </li></ul><br></li></ul><br></td></tr></tbody></table></div><br><h3> <strong><a name="outWebRTC"></a></strong>  <strong>WebRTC keluar</strong> </h3><br><p>  Dalam hal ini, SDK Web, Android SDK, dan iOS SDK bertindak sebagai API untuk pemain.  Contoh memainkan streaming WebRTC terlihat seperti ini: </p><br><p>  Sdk web </p><br><pre> <code class="plaintext hljs">session.createStream({name:‚Äùstream123‚Äù}).play();</code> </pre><br><p>  Android SDK </p><br><pre> <code class="plaintext hljs">playStream = session.createStream(streamOptions); playStream.play();</code> </pre><br><p>  iOS SDK </p><br><pre> <code class="plaintext hljs">FPWCSApi2Stream *stream = [session createStream:options error:nil]; if(![stream play:&amp;error]) { //published without errors }</code> </pre> <br><p>  Ini sangat mirip dengan API penerbitan, dengan satu-satunya perbedaan adalah bahwa alih-alih stream.publish (), stream.play () dipanggil untuk bermain. </p><br><p>  Server WCS pihak ketiga bisa menjadi pemain, yang akan diperintahkan untuk mengambil aliran melalui WebRTC dari server lain menggunakan metode tarik atau mengambil aliran di dalam CDN. </p><br><p></p><br><h3> <strong><a name="outRTMP"></a></strong>  <strong>Rtmp keluar</strong> </h3><br><p><img src="https://habrastorage.org/webt/in/zq/nb/inzqnbejvsout_d4n5iiej4gozi.png"></p><br><p>  Di sini akan ada terutama pemain RTMP - baik Flash Player dan aplikasi desktop dan mobile yang terkenal yang menggunakan protokol RTMP, menerima dan memainkan aliran RTMP.  Terlepas dari kenyataan bahwa Flash meninggalkan peramban, ia tetap menggunakan protokol RTMP, yang banyak digunakan untuk siaran video, dan kurangnya dukungan asli pada peramban tidak mencegah penggunaan protokol yang cukup sukses ini di aplikasi klien lainnya.  Diketahui bahwa RTMP banyak digunakan pada pemutar VR untuk aplikasi mobile di Android dan iOS. </p><br><p></p><br><h3> <strong><a name="outRTSP"></a></strong>  <strong>Rtsp keluar</strong> </h3><br><p><img src="https://habrastorage.org/webt/ly/xu/r9/lyxur9b3gfzwsubfmrb3afmkfh0.png"></p><br><p>  Server WCS dapat bertindak sebagai server RTSP dan mendistribusikan aliran yang diterima melalui RTSP sebagai kamera IP biasa.  Dalam hal ini, pemain harus membuat koneksi RTSP dengan server dan mengambil aliran untuk pemutaran, seolah-olah itu adalah kamera IP. </p><br><p></p><br><h3> <strong><a name="outMSE"></a></strong>  <strong>Keluar mse</strong> </h3><br><p><img src="https://habrastorage.org/webt/lt/wh/wz/ltwhwz7b8urhlg4m5ay-blpg-d8.jpeg"></p><br><p>  Dalam hal ini, pemain meminta aliran dari server menggunakan protokol Websocket.  Server mendistribusikan data audio dan video melalui soket web.  Data mencapai browser dan dikonversi menjadi potongan-potongan yang dapat dimainkan browser berkat ekstensi MSE asli yang didukung di luar kotak.  Pemain akhirnya bekerja berdasarkan elemen video HTML5. </p><br><p></p><br><h3> <strong><a name="outHLS"></a></strong>  <strong>Hl keluar</strong> </h3><br><p><img src="https://habrastorage.org/webt/if/5l/5f/if5l5fdsrgbgaekle2edci9gyws.jpeg"></p><br><p>  Di sini, WCS bertindak sebagai server HLS atau server Web yang mendukung HLS (HTTP Live Streaming).  Setelah aliran masuk muncul di server, daftar main HLS .m3u8 dibuat, yang diberikan kepada pemain dalam menanggapi permintaan HTTP.  Daftar putar menjelaskan segmen video mana yang harus diunduh dan ditampilkan oleh pemutar.  Pemain mengunduh segmen video dan memutarnya di halaman browser, di perangkat seluler, di desktop, di dekoder Apple TV, dan di mana pun dukungan HLS diklaim. </p><br><p></p><br><h2><a name="IncomingOutgoing"></a>  Masuk dan keluar </h2><br><p>  Secara total, kami memiliki 5 tipe aliran masuk dan keluar.  Mereka tercantum dalam tabel: </p><br><br><div class="scrollable-table"><table><thead><tr><th>  <strong>Kotak masuk</strong> </th><th>  <strong>Keluar</strong> </th></tr></thead><tbody><tr><td>  WebRTC </td><td>  WebRTC </td></tr><tr><td>  RTMP </td><td>  RTMP </td></tr><tr><td>  Rtsp </td><td>  Rtsp </td></tr><tr><td>  Vod </td><td>  MSE </td></tr><tr><td>  SIP / RTP </td><td>  Hl </td></tr></tbody></table></div><br><p>  Artinya, kita dapat mengunggah streaming ke server, menyambungkannya, dan memutarnya dengan pemain yang sesuai.  Untuk memutar aliran WebRTC, gunakan SDK Web.  Untuk memainkan aliran WebRTC sebagai HLS, gunakan pemain HLS, dll.  Satu aliran dapat dimainkan oleh banyak penonton.  Siaran satu-ke-banyak berhasil. </p><br><p>  Sekarang, mari kita gambarkan tindakan apa yang dapat dilakukan dengan stream. </p><br><p></p><br><h2><a name="manipulatingincoming"></a>  Manipulasi arus masuk </h2><br><p>  Aliran keluar dengan penonton tidak mudah dimanipulasi.  Memang, jika pemirsa telah membuat sesi dengan server dan sudah mendapatkan semacam aliran, tidak ada cara untuk melakukan perubahan apa pun tanpa merusak sesi.  Untuk alasan ini, semua manipulasi dan perubahan terjadi pada aliran masuk, pada titik di mana replikasi belum terjadi.  Aliran yang telah mengalami perubahan kemudian didistribusikan ke semua pemirsa yang terhubung. </p><br><p>  Operasi aliran meliputi: </p><br><p>  - merekam </p><br><p>  - mengambil snapshot </p><br><p>  - menambahkan aliran ke mixer </p><br><p>  - stream transcoding </p><br><p>  - menambahkan tanda air </p><br><p>  - menambahkan filter FPS </p><br><p>  - Rotasi gambar sebesar 90, 180, 270 derajat </p><br><p></p><br><h3> <strong><a name="recording"></a></strong>  <strong>Rekaman aliran masuk</strong> </h3><br><p><img src="https://habrastorage.org/webt/m_/je/j8/m_jej8-gdyvh2e2urt4s75ltsse.jpeg"></p><br><p>  Mungkin fungsi yang paling dimengerti dan sering ditemui.  Memang, dalam banyak kasus, stream memerlukan rekaman: webinar, pelajaran bahasa Inggris, konsultasi, dll. <br><img src="https://habrastorage.org/webt/kz/t0/_r/kzt0_rj0y1mvgb4rnob5ix4_bnk.jpeg"><br>  Perekaman dapat dimulai dengan SDK Web atau API REST dengan permintaan khusus: </p><br><pre> <code class="plaintext hljs">/stream/startRecording {}</code> </pre> <br><p>  Hasilnya disimpan dalam sistem file sebagai file mp4. </p><br><p></p><br><h3> <strong><a name="snapshot"></a></strong>  <strong>Mengambil foto</strong> </h3><br><p><img src="https://habrastorage.org/webt/cg/g6/yh/cgg6yhu_d8lj4tl6tecphzvgsce.jpeg"></p><br><p>  Tugas yang sama umum adalah untuk mengambil gambar dari aliran saat ini untuk menampilkan ikon di situs.  Misalnya, kami memiliki 50 aliran dalam sistem pengawasan video, yang masing-masing memiliki satu kamera IP sebagai sumber.  Menampilkan semua 50 utas pada satu halaman tidak hanya bermasalah untuk sumber daya browser, tetapi juga tidak berguna.  Dalam hal 30 FPS, total FPS dari gambar yang berubah adalah 1500, dan mata manusia tidak akan menerima frekuensi tampilan seperti itu.  Sebagai solusi, kami dapat mengonfigurasi pemotongan otomatis atau pengambilan foto sesuai permintaan;  dalam hal ini, gambar dengan frekuensi sewenang-wenang dapat ditampilkan di situs, misalnya, 1 frame dalam 10 detik.  Snapshots dapat dihapus dari SDK melalui REST API, atau diiris secara otomatis. </p><br><p><img src="https://habrastorage.org/webt/b9/c5/hf/b9c5hfkspnmifm7wfw96aatldl8.jpeg"></p><br><p>  Server WCS mendukung metode REST untuk menerima foto: </p><br><pre> <code class="plaintext hljs">/stream/snapshot</code> </pre> <br><p></p><br><p><img src="https://habrastorage.org/webt/5c/8z/v-/5c8zv-0i7uglnd6t5eyldejyzt0.jpeg"></p><br><p></p><br><h3> <strong><a name="mixer"></a></strong>  <strong>Menambahkan aliran ke mixer</strong> </h3><br><p><img src="https://habrastorage.org/webt/o3/mx/bj/o3mxbjmxo3evugpsr5td7wko1pc.jpeg"></p><br><p>  Gambar dari dua sumber atau lebih dapat digabungkan menjadi satu untuk ditampilkan untuk mengakhiri pemirsa.  Prosedur ini disebut pencampuran.  Contoh dasar: 1) Pengawasan video dari beberapa kamera di layar dalam satu gambar.  2) Konferensi video, di mana setiap pengguna menerima satu aliran, di mana sisanya dicampur, untuk menghemat sumber daya.  Mixer dikendalikan melalui REST API dan memiliki mode operasi MCU untuk membuat konferensi video. </p><br><p>  Perintah REST untuk menambahkan aliran ke mixer: </p><br><pre> <code class="plaintext hljs">/mixer/startup</code> </pre> <br><p></p><br><h3> <strong><a name="transcoding"></a></strong>  <strong>Streaming transcoding</strong> </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d19/7de/e1b/d197dee1b288f44501461f2893f19af6.jpg" alt="transcoding_WebRTC_Android_iOS_SDK_API_WCS_browser_RTMP_RTSP_VOD_SIP_RTP" width="924" height="553"></p><br><p>  Streaming kadang-kadang perlu dikompresi untuk beradaptasi dengan kelompok perangkat klien tertentu dengan resolusi dan bit rate.  Untuk ini, transcoding digunakan.  Transcoding dapat diaktifkan di sisi SDK Web, melalui REST API, atau secara otomatis melalui node transcoding khusus di CDN.  Misalnya, video 1280x720 dapat ditranskodekan ke 640x360 untuk distribusi ke pelanggan dari wilayah geografis dengan bandwidth yang biasanya rendah.  Di mana satelit Anda, Elon Musk? </p><br><p><img src="https://habrastorage.org/webt/yn/t2/5g/ynt25g1_9phfzcqtptzb0e0u3gq.jpeg"></p><br><p>  Metode REST yang digunakan: </p><br><pre> <code class="plaintext hljs">/transcoder/startup</code> </pre> <br><p></p><br><h3> <strong><a name="watermark"></a></strong>  <strong>Menambahkan tanda air</strong> </h3><br><p><img src="https://habrastorage.org/webt/l_/7q/-t/l_7q-td_lifwkr5aw3mn-btem1o.png"></p><br><p>  Diketahui bahwa konten apa pun dapat dicuri dan diubah menjadi WebRip, apa pun perlindungan yang dimilikinya.  Jika konten Anda berharga, Anda dapat menyisipkan tanda air atau logo ke dalamnya yang akan sangat mempersulit penggunaan lebih lanjut dan tampilan publik.  Untuk menambahkan tanda air, cukup unggah gambar PNG, dan itu akan dimasukkan ke dalam aliran video dengan transcoding.  Oleh karena itu, Anda harus menyiapkan beberapa inti CPU di sisi server jika Anda masih memutuskan untuk menambahkan tanda air ke aliran.  Agar tidak membuat tanda air pada server dengan transcoding, lebih baik menambahkannya langsung pada encoder / streamer, yang sering kali memberikan peluang seperti itu. </p><br><p></p><br><h3> <strong><a name="fpsfilter"></a></strong>  <strong>Menambahkan filter FPS</strong> </h3><br><p><img src="https://habrastorage.org/webt/27/oi/bk/27oibkbef1jtrjulbcdcpomi_ts.png"></p><br><p>  Dalam beberapa kasus, diperlukan aliran yang memiliki FPS genap (bingkai per detik).  Ini mungkin berguna jika kita melakukan streaming ulang sumber daya pihak ketiga seperti Youtube atau Facebook atau memainkannya dengan pemutar HLS yang sensitif.  Penyaringan juga membutuhkan transcoding, jadi pastikan untuk menilai dengan benar kekuatan server Anda dan menyiapkan 2 core per stream jika operasi seperti itu direncanakan. </p><br><p></p><br><h3> <strong><a name="rotate"></a></strong>  <strong>Rotasi gambar sebesar 90, 180, 270 derajat</strong> </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8fe/997/147/8fe997147f962e8d2f2d3405c5415f6e.png" alt="rotasi_WebRTC_Android_iOS_SDK_API_WCS_browser_RTMP_RTSP_VOD_SIP_RTP" width="628" height="189"></p><br><p>  Perangkat seluler memiliki kemampuan untuk mengubah resolusi aliran yang dipublikasikan tergantung pada sudut rotasi.  Misalnya, Anda mulai melakukan streaming, memegang iPhone secara horizontal, dan kemudian memutarnya.  Menurut spesifikasi WebRTC, peramban streamer perangkat seluler (dalam hal ini iOS Safari) harus memberi sinyal rotasi ke server.  Pada gilirannya, server harus mengirim acara ini ke semua pelanggan.  Jika tidak, akan seperti ini - streamer meletakkan telepon di sampingnya, tetapi masih melihat kameranya secara vertikal, sementara pemirsa melihat gambar yang diputar.  Untuk bekerja dengan rotasi di sisi SDK, ekstensi cvoExtension yang sesuai disertakan. </p><br><p></p><br><h3> <strong><a name="manage"></a></strong>  <strong>Manajemen aliran masuk</strong> </h3><br><p>  Otomatis - konfigurasi biasanya ditetapkan pada sisi server dalam pengaturan. </p><br><div class="scrollable-table"><table><thead><tr><th>  Tindakan mengalir </th><th>  Web, iOS, Android SDK </th><th>  API SISA </th><th>  Otomatis </th><th>  Cdn </th></tr></thead><tbody><tr><td>  Rekam </td><td>  + </td><td>  + </td><td><br></td><td><br></td></tr><tr><td>  Penghapusan Snapshot </td><td>  + </td><td>  + </td><td>  + </td><td><br></td></tr><tr><td>  Menambahkan ke Mixer </td><td>  + </td><td>  + </td><td><br></td><td><br></td></tr><tr><td>  Streaming transcoding </td><td>  + </td><td>  + </td><td><br></td><td>  + </td></tr><tr><td>  Menambahkan air <br>  tanda </td><td><br></td><td><br></td><td>  + </td><td><br></td></tr><tr><td>  Menambahkan Filter FPS </td><td><br></td><td><br></td><td>  + </td><td><br></td></tr><tr><td>  Putar gambar sebanyak 90, <br>  180, 270 derajat </td><td>  + </td><td><br></td><td><br></td><td><br></td></tr></tbody></table></div><br><p></p><br><h2><a name="Streamrelay"></a>  Pengaliran arus </h2><br><p>  Relai juga merupakan opsi untuk memanipulasi aliran memasuki server;  itu terdiri dari memaksa aliran ke server pihak ketiga.  Relaying identik dengan kata-kata seperti menerbitkan kembali, mendorong, menyuntikkan. </p><br><p>  Relai dapat diimplementasikan menggunakan salah satu dari protokol berikut: WebRTC, RTMP, SIP / RTP.  Tabel menunjukkan arah di mana aliran dapat disampaikan. </p><br><br><div class="scrollable-table"><table><thead><tr><th>  WebRTC </th><th>  RTMP </th><th>  SIP / RTP </th></tr></thead><tbody><tr><td>  WCS </td><td>  Server RTMP WCS </td><td>  Server SIP </td></tr></tbody></table></div><br><br><h3> <strong><a name="repubWebRTC"></a></strong>  <strong>Relai WebRTC</strong> </h3><br><p><img src="https://habrastorage.org/webt/d9/yf/cc/d9yfccsjz8zqvx3jo-3gas2nuu8.jpeg"></p><br><p>  Streaming dapat diteruskan ke server WCS lain jika karena alasan tertentu diperlukan untuk membuat aliran tersedia di server lain.  Relai dilakukan melalui REST API via / push method.  Setelah menerima permintaan REST, WCS terhubung ke server yang ditentukan dan menerbitkan aliran server-server untuk itu.  Setelah itu, aliran menjadi tersedia untuk diputar di komputer lain. </p><br><pre> <code class="plaintext hljs">/pull/push</code> </pre> <br><p>  - Menggunakan metode REST </p><br><p></p><br><h3> <strong><a name="rebubRTMP"></a></strong>  <strong>Relai RTMP</strong> </h3><br><p><img src="https://habrastorage.org/webt/y-/hv/tn/y-hvtne9e-vtgry-2or6nhmqzte.jpeg"></p><br><p>  Seperti halnya relai WebRTC, relai RTMP ke server lain juga dimungkinkan.  Perbedaannya hanya ada pada protokol relay.  Relai RTMP juga dilakukan melalui / push dan memungkinkan mentransfer aliran ke server RTMP pihak ketiga dan ke layanan yang mendukung RTMP Ingest: Youtube, Facebook streaming, dll.  Dengan demikian, aliran WebRTC dapat diteruskan ke RTMP.  Kami mungkin juga menyampaikan aliran lain yang memasuki server, misalnya RTSP atau VOD, ke RTMP. </p><br><p>  Aliran video diteruskan ke server RTMP lain menggunakan panggilan REST. </p><br><pre> <code class="plaintext hljs">/push/startup</code> </pre> <br><p>  - Menggunakan panggilan REST </p><br><p></p><br><h3> <strong><a name="repubSIP-RTP"></a></strong>  <strong>Relai SIP / RTP</strong> </h3><br><p><img src="https://habrastorage.org/webt/sl/tt/hj/sltthjlgwbvryka0vgpqel0hcx8.jpeg"><br></p><p>  Ini jarang digunakan fungsinya.  Paling sering, digunakan dalam perusahaan.  Misalnya, ketika kita perlu membuat panggilan SIP dengan server konferensi SIP eksternal dan mengalihkan aliran audio atau video ke panggilan ini sehingga audiensi konferensi melihat beberapa jenis konten video: "Silakan tonton video ini" atau "Kolega , sekarang mari kita tonton aliran kamera IP dari situs konstruksi ‚Äù.  Kita perlu diingat bahwa dalam hal ini, konferensi itu sendiri ada dan dikelola pada server VKS eksternal dengan dukungan SIP (baru-baru ini, kami telah menguji solusi dari Polycom DMA), sedangkan kami hanya menghubungkan dan menyampaikan aliran yang ada ke server ini.  Fungsi REST API disebut / disuntikkan dan berfungsi hanya untuk kasus ini. </p><br><p>  Perintah REST API: </p><br><pre> <code class="plaintext hljs">/call/inject_stream/startup</code> </pre> <br><p></p><br><h2><a name="CDN"></a>  Menghubungkan server ke jaringan pemrosesan konten CDN </h2><br><p>  Biasanya, satu server memiliki sumber daya yang terbatas.  Oleh karena itu, untuk siaran online besar di mana audiens menghitung ribuan dan puluhan ribu, penskalaan diperlukan.  Beberapa server WCS dapat digabungkan menjadi satu jaringan pengiriman konten CDN.  Secara internal, CDN akan bekerja melalui WebRTC untuk menjaga latensi rendah selama streaming. </p><br><p><img src="https://habrastorage.org/webt/99/sx/gd/99sxgd8frahbmd2trrxsfltfmeg.jpeg"></p><br><p>  Server dapat dikonfigurasi di salah satu peran berikut: Asal, Tepi, atau Transcoder.  Server tipe asal menerima lalu lintas dan mendistribusikannya ke server Edge, yang bertanggung jawab untuk mengirimkan aliran ke pemirsa.  Jika diperlukan untuk menyiapkan aliran dalam beberapa resolusi, Transcoder node dimasukkan dalam skema, yang mengambil misi sumber daya yang membutuhkan transcoding stream. </p><br><p></p><br><h2><a name="summarize"></a>  Untuk meringkas </h2><br><p>  WCS 5.2 adalah server untuk mengembangkan aplikasi dengan dukungan audio dan video realtime untuk browser dan perangkat seluler.  Empat API disediakan untuk pengembangan: SDK Web, iOS SDK, Android SDK, REST API.  Kami dapat menerbitkan streaming video (umpan) ke server menggunakan lima protokol: WebRTC, RTMP, RTSP, VOD, SIP / RTP.  Dari server, kita dapat memainkan stream dengan pemain menggunakan lima protokol: WebRTC, RTMP, RTSP, MSE, HLS.  Streaming dapat dikontrol dan menjalani operasi seperti merekam, mengiris snapshot, mencampur, transcoding, menambahkan tanda air, memfilter FPS, dan menyiarkan video menyalakan perangkat seluler.  Streaming dapat diteruskan ke server lain melalui protokol WebRTC dan RTMP, serta dialihkan ke konferensi SIP.  Server dapat digabungkan ke dalam jaringan pengiriman konten dan diskalakan untuk memproses sejumlah stream video secara sewenang-wenang. </p><br><h3>  <strong>Apa yang harus diketahui Alice untuk bekerja dengan server</strong> </h3><br><p>  Pengembang harus dapat menggunakan Linux.  Perintah berikut di baris perintah seharusnya tidak menyebabkan kebingungan: </p><br><pre> <code class="plaintext hljs">tar -xvzf wcs5.2.tar.gz</code> </pre> <br><pre> <code class="plaintext hljs">cd wcs5.2</code> </pre> <br><pre> <code class="plaintext hljs">./install.sh</code> </pre> <br><pre> <code class="plaintext hljs">tail -f flashphoner.log</code> </pre> <br><pre> <code class="plaintext hljs">ps aux | grep WebCallServer</code> </pre> <br><pre> <code class="plaintext hljs">top</code> </pre> <br><p>  Satu juga perlu tahu JavaScript Vanilla ketika datang ke pengembangan Web. </p><br><pre> <code class="plaintext hljs">//publishing the stream session.createStream({name:'mystream'}).publish(); //playing the stream session.createStream({name:'mystream'}).play();</code> </pre><br><p>  Kemampuan untuk bekerja dengan back-end juga berguna. </p><br><p><img src="https://habrastorage.org/webt/3l/0a/9s/3l0a9shqbhfy4yjheu30ocammzg.jpeg"></p><br><p>  WCS tidak hanya dapat menerima perintah kontrol melalui REST API, tetapi juga mengirim kait - yaitu pemberitahuan tentang peristiwa yang terjadi di dalamnya.  Misalnya, ketika mencoba membuat koneksi dari browser atau aplikasi seluler, WCS akan memicu kait / sambungkan, dan ketika mencoba memainkan streaming, itu akan memicu kait playStream.  Oleh karena itu, pengembang harus berjalan sedikit di belakang, yang mampu membuat klien REST sederhana dan server REST kecil untuk memproses kait. </p><br><p>  Contoh REST API </p><br><pre> <code class="plaintext hljs">/rest-api/stream/find_all</code> </pre> <br><p>  - contoh REST API untuk daftar stream di server </p><br><p>  SISA contoh kait </p><br><pre> <code class="plaintext hljs">https://myback-end.com/hook/connect</code> </pre> <br><p>  - Pengolahan hook / koneksi REST di sisi backend. </p><br><p>  Linux, JavaScript, REST Client / Server - tiga elemen yang cukup untuk mengembangkan layanan produksi pada platform WCS bekerja dengan stream video. </p><br><p>  Mengembangkan aplikasi seluler masing-masing membutuhkan pengetahuan tentang Java dan Objective-C untuk Android dan iOS. </p><br><h3>  <strong>Instalasi dan peluncuran</strong> </h3><br><p>  Ada tiga cara untuk meluncurkan WCS dengan cepat hari ini: </p><br><p>  1) Instal Ubuntu 16.x LTS atau Ubuntu 18.x LTS dll.  pada Centos7 Anda.  atau dipandu oleh <a href="https://docs.flashphoner.com/display/WCS52EN/Quick%2Bdeployment%2Band%2Btesting%2Bof%2Bthe%2Bserver">artikel dari dokumentasi</a> . </p><br><p>  atau </p><br><p>  2) Dapatkan <a href="https://flashphoner.com/amazon-ec2-support-in-web-call-server">gambar yang sudah jadi di Amazon EC2</a> . </p><br><p>  atau </p><br><p>  3) Dapatkan gambar <a href="https://flashphoner.com/web-call-server-on-digital-ocean-marketplace">server siap pakai di Digital Ocean</a> . </p><br><p>  Dan mulailah pengembangan proyek yang menarik dengan fitur streaming video. </p><br><p>  Artikel ulasan ternyata cukup besar.  Terima kasih atas kesabaran untuk membacanya. </p><br><p>  Selamat streaming! </p><br><p></p><br><h2><a name="Links"></a>  Tautan </h2><br><p>  <a href="https://flashphoner.com/">WCS 5.2</a> - Server WebRTC </p><br><h3>  Instalasi dan peluncuran </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Quick%2Bdeployment%2Band%2Btesting%2Bof%2Bthe%2Bserver">Instalasi dan luncurkan WCS</a> <br>  <a href="https://flashphoner.com/amazon-ec2-support-in-web-call-server">Luncurkan gambar yang sudah jadi di Amazon EC2</a> <br>  <a href="https://flashphoner.com/web-call-server-on-digital-ocean-marketplace">Luncurkan gambar siap pakai server di DigitalOcean</a> </p><br><h3>  SDK </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Web%2BSDK">SDK Web Dokumentasi</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Android%2BSDK">Dokumentasi Android SDK</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/iOS%2BSDK">Dokumentasi iOS SDK</a> </p><br><h3>  Kasing </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Stream%2Bcapturing%2Band%2Bpublishing%2Bto%2Bthe%2Bserver">Aliran masuk</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Playing%2Ba%2Bvideo%2Bstream%2Bfrom%2Bthe%2Bserver">Aliran keluar</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Captured%2Bstream%2Bmanagement">Pengelolaan aliran</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Republishing%2Ba%2Bvideo%2Bstream">Pengaliran arus</a> <br>  <a href="">CDN untuk streaming WebRTC latensi rendah</a> </p><br><h3>  Dokumentasi </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Web%2BCall%2BServer%2B5.2%2B-%2BEN">Dokumentasi Web Call Server 5.2</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482956/">https://habr.com/ru/post/id482956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482942/index.html">Mitos dan legenda Fediverse kuno</a></li>
<li><a href="../id482944/index.html">Dispenser Konveyor Multi Komponen</a></li>
<li><a href="../id482946/index.html">1–° DSS dan estimasi syarat dan biaya proyek dengan metode COCOMO II</a></li>
<li><a href="../id482948/index.html">"Satu, dua, tiga - bakar pohon Natal!" Atau pandangan pertamaku pada pengontrol mungil CANNY 3</a></li>
<li><a href="../id482950/index.html">Java: hal-hal yang mungkin tampak aneh bagi pengembang yang berpengalaman</a></li>
<li><a href="../id482958/index.html">"Aturan pertumbuhan: dari junior ke CTO", abstrak dari webinar oleh Fedor Borshchev</a></li>
<li><a href="../id482960/index.html">Tinjauan Umum WCS 5.2 - Server WebRTC untuk Pengembang Web Siaran Daring dan Video Chat</a></li>
<li><a href="../id482968/index.html">Quarkus - Pandangan Baru Di Cloud Native Java</a></li>
<li><a href="../id482970/index.html">Hack The Box - Walkthrough Craft. Kami menggali Git, mengeksploitasi kerentanan dalam API, berurusan dengan Vault</a></li>
<li><a href="../id482976/index.html">Analisis transaksi anonim dalam perdagangan saham</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>