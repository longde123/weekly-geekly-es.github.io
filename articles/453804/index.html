<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèΩ üë®‚Äçüî¨ üßñüèΩ El libro "Competitividad y concurrencia en la plataforma .NET. Patrones de dise√±o efectivos " üë®üèΩ‚Äçüîß üë©üèø‚Äçüíª üîì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! El libro de Riccardo Terrell proporciona orientaci√≥n sobre c√≥mo crear programas competitivos y escalables en .NET, destacando los b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "Competitividad y concurrencia en la plataforma .NET. Patrones de dise√±o efectivos "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/453804/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/xh/fk/az/xhfkazyaueuwhx3c7cjwt5ohyea.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  El libro de Riccardo Terrell proporciona orientaci√≥n sobre c√≥mo crear programas competitivos y escalables en .NET, destacando los beneficios de un paradigma funcional y brindando las herramientas y principios apropiados para mantener la competencia de manera competitiva y f√°cil.  Como resultado, armado con nuevas habilidades, recibir√° el conocimiento necesario para convertirse en un experto en brindar soluciones exitosas de alto rendimiento. <br><br>  Si est√° escribiendo c√≥digo multiproceso en .NET, este libro puede ayudarlo.  Si est√° interesado en utilizar un paradigma funcional para simplificar la programaci√≥n competitiva y maximizar el rendimiento de la aplicaci√≥n, este libro ser√° una gu√≠a importante para usted.  Beneficiar√° a cualquier desarrollador .NET que quiera escribir aplicaciones competitivas, reactivas y as√≠ncronas que escalen y se adapten autom√°ticamente a los recursos de hardware existentes donde sea que funcionen dichos programas. <br><a name="habracut"></a><br><h3>  Estructura de publicaci√≥n: hoja de ruta </h3><br>  Los catorce cap√≠tulos de este libro est√°n divididos en tres partes.  La Parte I presenta los conceptos funcionales de la programaci√≥n competitiva y describe las habilidades necesarias para comprender los aspectos funcionales de escribir programas multiproceso. <br><br><ul><li>  El Cap√≠tulo 1 describe los conceptos y objetivos b√°sicos de la programaci√≥n competitiva, as√≠ como las razones para usar la programaci√≥n funcional para escribir aplicaciones de subprocesos m√∫ltiples. </li><li>  El Cap√≠tulo 2 explora una gama de tecnolog√≠as de programaci√≥n funcional para mejorar el rendimiento de las aplicaciones multiproceso.  El prop√≥sito de este cap√≠tulo es proporcionar al lector los conceptos utilizados en el resto del libro e introducir ideas poderosas que surgen de un paradigma funcional. </li><li>  El Cap√≠tulo 3 ofrece una visi√≥n general del concepto funcional de inmutabilidad.  Explica c√≥mo se usa la inmutabilidad para escribir programas competitivos predecibles y correctos y para implementar estructuras de datos funcionales que son de naturaleza segura para subprocesos. </li></ul><br>  En la parte II, se examinan en profundidad varios modelos de programaci√≥n competitiva en un paradigma funcional.  Exploraremos temas como la Biblioteca de tareas paralelas (TPL) e implementaremos patrones paralelos como Bifurcar / Unir, dividir y conquistar, y MapReduce.  Esta secci√≥n tambi√©n trata el dise√±o declarativo, las abstracciones de alto nivel en operaciones asincr√≥nicas, la programaci√≥n de agentes y la sem√°ntica de transferencia de mensajes. <br><br><ul><li>  El Cap√≠tulo 4 describe los conceptos b√°sicos del procesamiento paralelo de grandes cantidades de datos, incluidas plantillas como Fork / Join. </li><li>  El Cap√≠tulo 5 presenta m√©todos m√°s sofisticados para el procesamiento paralelo de grandes cantidades de informaci√≥n, como la agregaci√≥n paralela, la reducci√≥n de datos y la implementaci√≥n de una plantilla MapReduce paralela. </li><li>  El Cap√≠tulo 6 proporciona informaci√≥n detallada sobre los m√©todos funcionales para procesar flujos de eventos (datos) en tiempo real utilizando los operadores funcionales de alto orden en .NET Reactive Extensions para formar combinadores de eventos as√≠ncronos.  Los m√©todos estudiados se utilizar√°n luego para implementar una plantilla reactiva competitiva editor-suscriptor. </li><li> El Cap√≠tulo 7 proporciona una explicaci√≥n del modelo de programaci√≥n basado en tareas aplicado a la programaci√≥n funcional para implementar operaciones competitivas utilizando la plantilla Monadic.  Luego, este m√©todo se utiliza para construir una tuber√≠a competitiva basada en un paradigma de programaci√≥n funcional. </li><li>  El Cap√≠tulo 8 est√° dedicado a la implementaci√≥n de computaci√≥n paralela ilimitada utilizando el modelo de programaci√≥n as√≠ncrono C #.  Este cap√≠tulo tambi√©n trata los m√©todos de manejo de errores y los m√©todos para construir operaciones asincr√≥nicas. </li><li>  El Cap√≠tulo 9 describe el flujo de trabajo as√≠ncrono en F #.  Muestra c√≥mo una evaluaci√≥n diferida y expl√≠cita en este modelo permite una mayor sem√°ntica compositiva.  Luego, aprenderemos c√≥mo implementar expresiones computacionales personalizadas para elevar el nivel de abstracci√≥n a la programaci√≥n declarativa. </li><li>  El Cap√≠tulo 10 muestra c√≥mo, en base al conocimiento adquirido en cap√≠tulos anteriores, los combinadores y las plantillas, como Functor, Monad y Applicative, se pueden implementar para componer y ejecutar varias operaciones asincr√≥nicas y manejar errores sin efectos secundarios. </li><li>  El Cap√≠tulo 11 analiza la programaci√≥n reactiva utilizando un modelo de mensajer√≠a de software.  Revela el concepto de aislamiento natural como una tecnolog√≠a que complementa la inmutabilidad y permite la creaci√≥n de programas competitivos.  Este cap√≠tulo se centra en la clase MailboxProcessor utilizada en F # para distribuir el trabajo paralelo utilizando la programaci√≥n del agente y un enfoque sin recursos. </li><li>  El Cap√≠tulo 12 describe la programaci√≥n del agente utilizando la biblioteca TPL Dataflow de .NET con ejemplos en C #.  Muestra c√≥mo implementar agentes sin estado y con estado en C #, as√≠ como c√≥mo realizar varios c√°lculos en paralelo que intercambian datos entre s√≠, utilizando (enviando) mensajes al estilo de una canalizaci√≥n. </li></ul><br>  La Parte III muestra c√≥mo poner en pr√°ctica todos los m√©todos funcionales de programaci√≥n competitiva estudiados en cap√≠tulos anteriores. <br><br><ul><li>  El Cap√≠tulo 13 presenta un conjunto de recetas √∫tiles para resolver problemas competitivos complejos, tomados de la pr√°ctica real.  Estas recetas usan todos los patrones funcionales descritos en este libro. </li><li>  El Cap√≠tulo 14 describe una aplicaci√≥n completa desarrollada e implementada utilizando plantillas y m√©todos competitivos funcionales estudiados en este libro.  Crear√° una aplicaci√≥n de servidor altamente escalable y receptiva y un programa de cliente receptivo.  El libro contiene dos versiones: una para iOS (iPad), creada con Xamarin Visual Studio, y la segunda, creada con Windows Presentation Foundation (WPF).  Para garantizar la m√°xima escalabilidad en la aplicaci√≥n del servidor, se utiliza una combinaci√≥n de varios modelos de programaci√≥n, como as√≠ncrono, agente y reactivo. </li></ul><br>  El libro tambi√©n contiene tres aplicaciones. <br><br><ul><li>  El Ap√©ndice A describe brevemente los conceptos b√°sicos de la programaci√≥n funcional, as√≠ como presenta la teor√≠a b√°sica de los m√©todos funcionales utilizados en este libro. </li><li>  El Ap√©ndice B revela los conceptos b√°sicos del lenguaje F #.  Esta es una revisi√≥n b√°sica de F #, que le permitir√° familiarizarse con este idioma y sentirse c√≥modo mientras lee un libro. </li><li>  El Ap√©ndice B muestra varios m√©todos que simplifican la interacci√≥n entre un flujo de trabajo as√≠ncrono en F # y una tarea .NET en C #. </li></ul><br><h3>  Extracto  11.6  F # MailboxProcessor: 10,000 agentes para Game of Life </h3><br>  En comparaci√≥n con los subprocesos, MailboxProcessor en combinaci√≥n con flujos de trabajo asincr√≥nicos es una unidad de computaci√≥n simple (primitiva).  Los agentes pueden aparecer y ser destruidos a un costo m√≠nimo.  Puede distribuir el trabajo entre varios objetos de MailboxProcessor de la misma manera que puede usar hilos, sin la sobrecarga adicional asociada con la creaci√≥n de un nuevo hilo.  Gracias a esto, es muy posible crear aplicaciones que consisten en cientos de miles de agentes que trabajan en paralelo con una carga m√≠nima de recursos inform√°ticos. <br><br>  En esta secci√≥n, utilizaremos varias instancias de MailboxProcessor para implementar el juego Game of Life (el juego "Life") ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki-eng</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki-eng</a> ).  Seg√∫n Wikipedia, el Juego de la vida, en palabras simples, es un aut√≥mata celular.  Este es un juego sin jugadores; en otras palabras, cuando un juego comienza con una configuraci√≥n inicial aleatoria, se ejecuta sin ninguna otra entrada.  El juego consiste en un conjunto de celdas que forman una cuadr√≠cula;  en cada celda se cumplen varias reglas matem√°ticas.  Las c√©lulas pueden vivir, morir y multiplicarse.  Cada celda interact√∫a con ocho vecinos (celdas vecinas).  Para mover celdas de acuerdo con estas reglas, es necesario calcular constantemente el nuevo estado de la cuadr√≠cula. <br><br>  Game of Life tiene las siguientes reglas: <br><br><ul><li>  si una celda tiene solo un vecino o ning√∫n vecino, entonces muere "de la soledad"; </li><li>  si cuatro o m√°s vecinos de una c√©lula mueren, entonces muere "debido a la sobrepoblaci√≥n"; </li><li>  si la celda tiene dos o tres vecinos, queda por vivir; </li><li>  Si una celda tiene tres vecinos, entonces se multiplica. </li></ul><br>  Dependiendo de las condiciones iniciales, las c√©lulas forman estructuras caracter√≠sticas a lo largo del juego.  Mediante la aplicaci√≥n repetida de las reglas, se crean las siguientes generaciones de c√©lulas hasta que las c√©lulas alcanzan un estado estable (Fig. 11.12). <br><br>  El listado 11.9 muestra la implementaci√≥n de la celda GameCell AgentCell, basada en los tipos F # de MailboxProcessor.  Cada c√©lula del agente interact√∫a con las c√©lulas vecinas a trav√©s de mensajes as√≠ncronos, creando as√≠ un Juego de la Vida totalmente paralelo.  Por brevedad, omit√≠ algunas partes del c√≥digo, ya que no est√°n relacionadas con el tema principal del ejemplo.  Encontrar√° la implementaci√≥n completa en el c√≥digo fuente de este libro, publicado en el sitio web del editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/qb/jp/siqbjpp_zc4oqi7dgpk032_8xe8.png" alt="imagen"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2d/j9/u2/2dj9u2y7qplsftitwupamkmaji0.png" alt="imagen"></div><br>  AgentCell describe una celda en la cuadr√≠cula Game of Life.  El concepto b√°sico es que cada agente intercambia informaci√≥n con las c√©lulas vecinas sobre su estado actual a trav√©s de mensajes as√≠ncronos.  Esta plantilla crea una cadena de comunicaciones paralelas interconectadas que involucra a todas las celdas que env√≠an su estado actualizado al MailboxProcessor updateAgent.  Despu√©s de recibir estos datos, updateAgent actualiza los gr√°ficos en la interfaz de usuario (Listado 11.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/qy/j2/1aqyj2_ar1ua7a4mjylo8gxdqgg.png" alt="imagen"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wr/jx/l4wrjxuth4-3quliytnseqegjw8.png" alt="imagen"></div><br>  updateAgent, como su nombre lo indica, actualiza el estado de cada p√≠xel de acuerdo con el valor de celda recibido en el mensaje Actualizar.  El agente mantiene el estado de los p√≠xeles y lo usa para crear una nueva imagen cuando todas las celdas pasan a su nuevo estado.  UpdateAgent luego actualiza la GUI de WPF usando esta nueva imagen que coincide con la cuadr√≠cula actual de Game of Life: <br><br><pre><code class="plaintext hljs">do! Async.SwitchToContext ctx image.Source &lt;- createImage pixels do! Async.SwitchToThreadPool()</code> </pre> <br>  Es importante tener en cuenta que updateAgent utiliza el contexto de sincronizaci√≥n actual para actualizar correctamente el controlador WPF.  El hilo actual se cambia al hilo de la interfaz de usuario utilizando la funci√≥n Async.SwitchToContext (descrita en el Cap√≠tulo 9). <br><br>  El √∫ltimo c√≥digo para ejecutar Game of Life genera una cuadr√≠cula que sirve como un patio de recreo para las celdas, y luego el temporizador notifica a las celdas sobre la necesidad de realizar una actualizaci√≥n (Listado 11.11).  En este ejemplo, la cuadr√≠cula es un cuadrado de 100 √ó 100 celdas, un total de 10,000 celdas (objetos MailboxProcessor), que se calculan en paralelo con un temporizador cada 50 ms, como se muestra en la Fig.  11.13.  Diez mil objetos de MailboxProcessor interact√∫an y actualizan la interfaz de usuario 20 veces por segundo (el c√≥digo al que debe prestar atenci√≥n se muestra en negrita). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/px/jw/uepxjwb4re6grfx1wqbmp4rx6pq.png" alt="imagen"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/cg/tx/eqcgtxipd3wr4kipmnbpqj0-rjm.png" alt="imagen"></div><br>  Las notificaciones a todas las c√©lulas (agentes) se env√≠an en paralelo usando PLINQ.  Las celdas son secuencias F # que se consideran .NET IEnumerable, lo que hace que LINQ / PLINQ sea f√°cil de integrar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/9u/wl/rc9uwlhsymr64zmqrffpte7gqcc.png" alt="imagen"></div><br>  Cuando se ejecuta el c√≥digo, el programa genera 10,000 objetos F # de tipo MailboxProcessor en menos de 1 ms, mientras que los agentes ocupan menos de 25 MB de memoria.  Impresionante! <br><br><h3>  Resumen </h3><br><ul><li>  El modelo de programaci√≥n basado en agentes proporciona de forma natural la inmutabilidad y el aislamiento al escribir sistemas competitivos, lo que facilita a√∫n m√°s la discusi√≥n de sistemas complejos, ya que los agentes est√°n encapsulados dentro de objetos activos. </li><li>  Un manifiesto reactivo define las propiedades para implementar un sistema reactivo que sea flexible, poco acoplado y escalable. </li><li>  El aislamiento natural es importante para escribir c√≥digo competitivo sin bloquear.  En un programa de subprocesos m√∫ltiples, el aislamiento resuelve el problema de los estados compartidos al proporcionar a cada subproceso una pieza de datos copiada para realizar c√°lculos locales.  Cuando se usa aislamiento, no hay condici√≥n de carrera. </li><li>  Al ser as√≠ncronos, los agentes son simples porque no bloquean los hilos mientras esperan mensajes.  Como resultado, puede usar cientos de miles de agentes en una aplicaci√≥n sin mucho impacto en el tama√±o de la memoria. </li><li>  Un objeto MailboxProcessor F # proporciona comunicaci√≥n bidireccional: un agente puede usar un canal as√≠ncrono para devolver (responder) al objeto llamante el resultado del c√°lculo. </li><li>  El modelo de programaci√≥n del agente en F # a trav√©s de MailboxProcessor es una herramienta excelente para resolver cuellos de botella en aplicaciones, como el acceso simult√°neo a m√∫ltiples bases de datos.  De hecho, con la ayuda de agentes, puede acelerar significativamente la aplicaci√≥n, manteniendo la capacidad de respuesta del servidor. </li><li>  Otros lenguajes de programaci√≥n .NET le permiten utilizar el MailboxProcessor tipo F #, que proporciona m√©todos que utilizan el conveniente modelo de programaci√≥n TPL basado en tareas. </li></ul><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  Cup√≥n de 20% de descuento para vendedores ambulantes: <b>concurrencia en .NET</b> <br><br>  Tras el pago de la versi√≥n en papel del libro, se env√≠a una versi√≥n electr√≥nica del libro por correo electr√≥nico. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453804/">https://habr.com/ru/post/453804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453788/index.html">Las redes neuronales prefieren las texturas y c√≥mo lidiar con ellas.</a></li>
<li><a href="../453790/index.html">"El cliente se fue, ¬øes para siempre?" C√≥mo contar la p√©rdida de clientes en SaaS y qu√© hay de malo con las m√©tricas b√°sicas</a></li>
<li><a href="../453792/index.html">Sistemas de recomendaci√≥n: ideas, enfoques, tareas.</a></li>
<li><a href="../453796/index.html">¬øLa gente necesita matem√°ticas?</a></li>
<li><a href="../453800/index.html">C√≥mo resolver "Buscaminas" (y hacerlo mejor)</a></li>
<li><a href="../453806/index.html">Manejo de errores en Go</a></li>
<li><a href="../453808/index.html">Desmontamos el modelo de negocio vikingo</a></li>
<li><a href="../453810/index.html">Retroalimentaci√≥n biom√©trica</a></li>
<li><a href="../453812/index.html">Temas, estilos y otros.</a></li>
<li><a href="../453816/index.html">Encefalitis transmitida por garrapatas: un peligro descuidado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>