<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú¥Ô∏è ü§¶üèø üêÆ Wie waren die NES-Grafiken angeordnet? üëÜüèº üòæ üíÜüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die 1983 eingef√ºhrte Heimkonsole des Nintendo Entertainment System (NES) war eine billige, aber leistungsstarke Maschine, die ph√§nomenale Erfolge erzi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie waren die NES-Grafiken angeordnet?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="Bild"></div><br>  Die 1983 eingef√ºhrte Heimkonsole des Nintendo Entertainment System (NES) war eine billige, aber leistungsstarke Maschine, die ph√§nomenale Erfolge erzielte.  Mit der Picture Processing Unit (PPU) konnte das System beeindruckende Grafiken f√ºr diese Zeit erstellen, die auch heute noch im richtigen Kontext recht gut aussehen.  Der wichtigste Aspekt war die Speichereffizienz - beim Erstellen von Grafiken mussten wir mit so wenig Bytes wie m√∂glich arbeiten.  Gleichzeitig stellte NES Entwicklern leistungsstarke und benutzerfreundliche Funktionen zur Verf√ºgung, mit denen es sich von √§lteren Heimkonsolen abheben konnte.  Nachdem Sie die Prinzipien der Erstellung von NES-Grafiken verstanden haben, k√∂nnen Sie die technische Perfektion des Systems sp√ºren und erkennen, wie viel einfacher es f√ºr moderne Spieleentwickler ist, zu arbeiten. <br><br>  Die NES-Hintergrundgrafiken wurden aus vier separaten Komponenten zusammengesetzt, deren Kombination das Bild bildete, das wir auf dem Bildschirm sehen.  Jede Komponente war f√ºr einen eigenen Aspekt verantwortlich;  Farbe, Layout, rohe Pixelgrafiken usw.  Ein solches System mag unn√∂tig kompliziert und umst√§ndlich erscheinen, aber am Ende hat es den Speicher viel effizienter genutzt und es erm√∂glicht, einfache Effekte in einer kleinen Menge Code zu erstellen.  Wenn Sie NES-Grafiken verstehen m√∂chten, sind diese vier Komponenten wichtige Informationen. <br><br>  In diesem Artikel wird davon ausgegangen, dass Sie mit der Computermathematik vertraut sind, insbesondere mit der Tatsache, dass 8 Bit = 1 Byte und 8 Bit 256 Werte darstellen k√∂nnen.  Ein Verst√§ndnis der Funktionsweise der hexadezimalen Notation ist ebenfalls erforderlich.  Aber auch ohne dieses technische Wissen mag der Artikel interessant erscheinen. <br><a name="habracut"></a><br><h1>  Kurzer R√ºckblick </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/6f8/9a7/ca16f89a75e658d68c28f81e9794ff86.png" width="512" height="480"></div><br>  Oben ist ein Bild aus der ersten Szene von Castlevania (1986) zu sehen: das Tor zum Schloss, wo das Spiel stattfinden wird.  Dieses Bild ist 256 √ó 240 Pixel gro√ü und verwendet 10 verschiedene Farben.  Um dieses Bild im Speicher zu beschreiben, m√ºssen wir die begrenzte Farbpalette nutzen und Platz sparen, indem wir nur eine minimale Menge an Informationen speichern.  Einer der naiven Ans√§tze besteht darin, eine indizierte Palette zu verwenden, in der jedes Pixel ein Volumen von 4 Bits hat, dh 2 Pixel werden in einem Byte platziert.  Dies erfordert 256 * 240/2 = 30720 Bytes, aber wie wir bald sehen werden, kann NES diese Aufgabe viel effizienter bew√§ltigen. <br><br>  Die Hauptkonzepte im NES-Grafikthema sind Kacheln und Bl√∂cke [1].  Eine Kachel ist eine Fl√§che von 8 √ó 8 Pixeln, und ein Block ist eine Fl√§che von 16 √ó 16 Pixeln, und jede von ihnen ist an ein Raster mit derselben Zellengr√∂√üe gebunden.  Nach dem Hinzuf√ºgen dieser Gitter k√∂nnen wir die Struktur der Grafiken sehen.  Hier ist der Eingang zum Schloss mit einem Gitter bei doppelter Vergr√∂√üerung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uz/de/sk/uzdeskry1wkruscxe8xsyephbnc.png"></div><br>  In diesem Raster werden Bl√∂cke hellgr√ºn und Kacheln dunkelgr√ºn angezeigt.  Lineale entlang der Achsen haben hexadezimale Werte, die hinzugef√ºgt werden k√∂nnen, um eine Position zu finden.  Das Herz in der Statusleiste befindet sich beispielsweise bei 15 USD + 60 USD = 75 USD, was in Dezimalzahl 117 entspricht. Jeder Bildschirm enth√§lt 16 √ó 15 Bl√∂cke (240) und 32 √ó 30 Kacheln (960).  Lassen Sie uns nun sehen, wie dieses Bild beschrieben wird, und mit den Rohpixelgrafiken beginnen. <br><br><h1>  CHR </h1><br>  Die CHR-Struktur beschreibt ‚Äûrohe‚Äú Pixelgrafiken ohne Farbe und Position und ist in Kacheln angeordnet.  Die gesamte Speicherseite enth√§lt 256 CHR-Kacheln, und jede Kachel hat eine Tiefe von 2 Bit.  Hier sind die Herzgrafiken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/d14/fb3/ad9d14fb3cc4321c5ae65e1e7f61dd52.png" width="128" height="128"></div><br>  Und so wird es in CHR [2] beschrieben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/162/974/e0f/162974e0fe800447c8edecf9157d1763.png" alt="Pixel-Herz-Chr" width="128" height="128"></div><br>  Eine solche Beschreibung ben√∂tigt 2 Bits pro Pixel, dh bei einer Gr√∂√üe von 8 √ó 8 ergibt sich 8 * 8 * 2 = 128 Bits = 16 Bytes.  Dann ben√∂tigt die gesamte Seite 16 * 256 = 4096 Bytes.  Hier sind alle CHRs, die im Bild von Castlevania verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/3ef/83d/5da3ef83d0e339ca2d91d799745157e9.png" width="271" height="101"></div><br>  Denken Sie daran, dass f√ºr das Ausf√ºllen eines Bildes 960 Kacheln erforderlich sind, CHR jedoch nur 256 Kacheln. Dies bedeutet, dass die meisten Kacheln durchschnittlich 3,75 Mal wiederholt werden, aber h√§ufiger nur eine kleine Anzahl von ihnen verwendet wird (z. B. leerer Hintergrund, einfarbige Kacheln) oder sich wiederholende Muster).  Das Bild von Castlevania verwendet viele leere Kacheln sowie ein festes Blau.  Um zu sehen, wie Kacheln zugewiesen werden, verwenden wir Namenstabellen. <br><br><h1>  NAMETABLE </h1><br>  Die Namenstabelle weist jeder Position auf dem Bildschirm eine CHR-Datei zu, und es gibt insgesamt 960. Jede Position wird in einem Byte angegeben, dh die gesamte Namenstabelle ben√∂tigt bis zu 960 Byte.  Die Kacheln werden in der Reihenfolge von links nach rechts, von oben nach unten zugewiesen und entsprechen der berechneten Position, die durch Hinzuf√ºgen der Werte der oben gezeigten Lineale ermittelt wurde.  Das hei√üt, die Position in der oberen linken Ecke betr√§gt 0 USD, rechts davon 1 USD und darunter 20 USD. <br><br>  Die Werte in der Namenstabelle h√§ngen von der Reihenfolge ab, in der die CHR ausgef√ºllt wird.  Hier ist eine der Optionen [3]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h_/vs/qc/h_vsqc5mxdu8ydb1o8cu4mflf9e.png"></div><br>  <i>In diesem Fall hat das Herz (an Position 75 USD) einen Wert von 13 USD.</i> <br><br>  Als n√§chstes m√ºssen wir eine Palette ausw√§hlen, um Farbe hinzuzuf√ºgen. <br><br><h1>  Palette </h1><br>  NES hat eine Systempalette mit 64 Farben [4], und daraus w√§hlen wir die Paletten aus, die beim Rendern verwendet werden sollen.  Jede Palette enth√§lt 3 einzigartige Farben sowie die gesamte Hintergrundfarbe.  Das Bild hat maximal 4 Paletten, die insgesamt 16 Bytes belegen.  Hier sind die Paletten f√ºr das Bild von Castlevania: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f03/59a/259/f0359a259c032b5f6c9048c0231ffb85.png" alt="Castlevania-Kumpel" width="168" height="24"></div><br>  Paletten k√∂nnen nicht willk√ºrlich verwendet werden.  Pro Block wird nur eine Palette angewendet.  Aus diesem Grund muss jeder 16 √ó 16-Bereich gem√§√ü der Farbpalette des Spiels f√ºr NES getrennt werden, um einen solchen "Block" -Look zu erhalten.  Meisterhaft ausgef√ºhrte Grafiken, beispielsweise vom Castlevania-Begr√º√üungsbildschirm, k√∂nnen vermieden werden, indem Farben an den R√§ndern der Bl√∂cke gemischt werden, wodurch das Vorhandensein eines Rasters ausgeblendet wird. <br><br>  Die Auswahl einer Palette f√ºr jeden Block erfolgt anhand der letzten Komponentenattribute. <br><br><h1>  Attribute </h1><br>  Attribute belegen 2 Bits pro Block.  Sie bestimmen, welche der 4 Paletten verwendet werden soll.  Dieses Bild zeigt, welche durch die Attribute definierten Paletten unterschiedliche Bl√∂cke verwenden [5]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/kj/3i/k4kj3imqlxxbwnasjcz3t60abym.png"></div><br>  Wie Sie sehen k√∂nnen, sind die Paletten in Abschnitte unterteilt. Dies ist jedoch schwierig, da in verschiedenen Bereichen dieselben Farben verwendet werden.  Rot in der Mitte des Tores verschmilzt mit den Mauern, die es umgeben, und ein schwarzer Hintergrund verwischt die Linie zwischen der Burg <br>  und Tore. <br><br>  Mit 2 Bits pro Block oder 4 Bl√∂cken pro Byte belegen die Bildattribute nur 240/4 = 60 Bytes, aber aufgrund der Art und Weise, wie sie codiert werden, werden weitere 4 Bytes verschwendet, dh insgesamt werden 64 Bytes erhalten.  Dies bedeutet, dass das gesamte Bild, einschlie√ülich CHR, Namenstabelle, Paletten und Attribute, 4096 + 960 + 16 + 64 = 5136 Byte belegt - viel besser als das oben erw√§hnte 30720. <br><br><h1>  MAKECHR </h1><br>  Das Erstellen dieser vier Komponenten f√ºr NES-Grafiken ist schwieriger als die Verwendung der regul√§ren Bitmap-APIs, aber Tools helfen dabei.  NES-Entwickler hatten wahrscheinlich eine Art Toolchain, aber was auch immer es war, die Geschichte hat es nicht gespeichert.  Heutzutage schreiben Entwickler normalerweise Programme zum Konvertieren von Grafiken in das gew√ºnschte NES-Format. <br><br>  Alle Bilder in diesem Beitrag wurden mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">makechr erstellt</a> , einem neu geschriebenen Tool von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Star Versus</a> .  Dies ist ein Befehlszeilenprogramm, das f√ºr automatisierte Builds entwickelt wurde und auf Geschwindigkeit, Qualit√§tsfehlermeldungen, Portabilit√§t und Verst√§ndlichkeit abzielt.  Er erstellt auch interessante Visualisierungen, wie sie in der Post verwendet werden. <br><br><h1>  Referenzen </h1><br>  Das meiste Wissen √ºber das Programmieren f√ºr NES und insbesondere √ºber das Erstellen von Grafiken habe ich aus folgenden Quellen erhalten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nintendo Age Nerdy Nights</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NesDevs Wiki</a> </li></ul><br><h1>  Anmerkungen </h1><br>  [1] Terminologie - In einigen Dokumenten werden Bl√∂cke als ‚ÄûMeta-Kacheln‚Äú bezeichnet, was mir pers√∂nlich weniger n√ºtzlich erscheint. <br><br>  [2] CHR-Codierung - 2 Bits pro Pixel werden nicht nebeneinander gespeichert.  Das vollst√§ndige Bild wird zuerst nur mit den niedrigen Bits und dann wieder nur mit den hohen Bits gespeichert. <br><br>  Das hei√üt, das Herz wird wie folgt gespeichert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc5/68c/f95/cc568cf959b148d1d11a408876806ae8.png" alt="Pixel-Herz-Besetzt" width="128" height="128"><img src="https://habrastorage.org/getpro/habr/post_images/f87/947/070/f879470703605322e98a2582241b071e.png" alt="Pixel-herz-hoch" width="128" height="128"><br><br>  Jede Zeile besteht aus einem Byte.  Das hei√üt, 01100110 ist $ 66, 01111111 ist $ 7f.  Insgesamt sehen Bytes des Herzens so aus: <br><br>  $ 66 $ 7f $ ff $ ff $ ff $ 7e $ 3c $ 18 $ 66 $ 5f $ bf $ bf $ ff $ 7e $ 3c $ 18 <br><br>  [3] Namenstabelle - In dieser Tabelle im Spiel wird die Namenstabelle anders verwendet.  In der Regel werden die Buchstaben des Alphabets in der Nachbarschaft, einschlie√ülich Castlevania, gespeichert. <br><br>  [4] Systempalette - NES verwendet keine RGB-Palette, und die tats√§chlichen Farben h√§ngen vom jeweiligen Fernsehger√§t ab.  Emulatoren verwenden normalerweise v√∂llig unterschiedliche RGB-Paletten.  Die Farben in diesem Artikel entsprechen der in makechr geschriebenen Palette. <br><br>  [5] Attributcodierung - Attribute werden in einer seltsamen Reihenfolge gespeichert.  Sie gehen nicht von links nach rechts, von oben nach unten - der 2 √ó 2-Blockbereich wird mit einem Byte in Form des Buchstabens Z codiert. Deshalb werden 4 Bytes verschwendet;  Die unterste Zeile ist volle 8 Bytes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/951/0db/71a9510db28128bca1841689ce909c27.png" alt="Kumpel-Block-Gruppe" width="64" height="64"></div><br>  Beispielsweise wird ein Block von 308 US-Dollar mit 30 US-Dollar, 348 US-Dollar und 34 US-Dollar gespeichert.  Ihre Palettenwerte sind 1, 2, 3 und 3 und werden in der Reihenfolge von der niedrigsten zur h√∂chsten Position oder 11 :: 11 :: 10 :: 01 = 11111001 gespeichert. Daher betr√§gt der Bytewert dieser Attribute $ f9. <br><br><h2>  Teil 2 </h2><br>  Im ersten Teil haben wir √ºber die Komponenten der NES-Hintergrundgrafiken gesprochen - CHR, Namenstabelle, Paletten und Attribute.  Dies ist jedoch nur die halbe Wahrheit. <br><br>  Zun√§chst gibt es tats√§chlich zwei Namenstabellen [6].  Jeder von ihnen hat seine eigenen Attribute zum Einstellen der Farbe, aber sie haben die gleiche CHR.  Die Kartuschenausr√ºstung bestimmt ihre Position: entweder nebeneinander oder √ºbereinander.  Das Folgende sind Beispiele f√ºr zwei verschiedene Arten von Orten - Lode Runner (1984) und Bubble Bobble (1988). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/7ef/7c9/7597ef7c97f3e31ed3bb4198727dee37.png" width="512" height="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/035/72a/0e703572ad771478c13bffa254a86579.png" alt="Bubble-Bobble-Scrolling" width="532" height="480"></div><br><h1>  Scrollen </h1><br>  Um das Vorhandensein von zwei Namenstabellen zu nutzen, unterst√ºtzt die PPU die M√∂glichkeit, pixelweise entlang der X- und Y-Achse zu scrollen. Sie wird von einem Register mit Speicheranzeige bei $ 2005 gesteuert: Durch Schreiben von nur zwei Bytes an dieser Adresse wird der gesamte Bildschirm auf die gew√ºnschte Pixelanzahl verschoben [7]. .  Zum Zeitpunkt der Ver√∂ffentlichung von NES war dies der Hauptvorteil gegen√ºber anderen Heimkonsolen, bei denen zum Scrollen h√§ufig der gesamte Videospeicher neu geschrieben werden musste.  Ein solch benutzerfreundliches Schema f√ºhrte zur Entstehung einer gro√üen Anzahl von Plattformspielern und Sch√ºtzen und wurde zum Hauptgrund f√ºr einen so gro√üen Erfolg des Systems. <br><br>  F√ºr ein einfaches Spiel, dessen Feld nur zwei Bildschirme breit ist, z. B. Load Runner, reichte es aus, nur beide Namenstabellen auszuf√ºllen und das Scrollen entsprechend zu √§ndern.  In den meisten Scrolling-Spielen hatten die Levels jedoch eine beliebige Breite.  Um sie zu implementieren, muss das Spiel den Off-Screen-Teil der Namenstabellen aktualisieren, bevor sie auf dem Bildschirm angezeigt werden.  Der Bildlaufwert wird wiederholt, aber da die Namenstabelle st√§ndig aktualisiert wird, entsteht die Illusion einer unendlichen Gr√∂√üe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/936/ab4/829936ab4b2855cd7f824ebd01941bb3.gif" width="512" height="500"></div><br><h1>  Sprites </h1><br>  Neben dem Scrollen durch Namenstabellen hatte NES auch einen v√∂llig anderen Aspekt der Grafik: Sprites.  Im Gegensatz zu Namenstabellen, die in Gittern ausgerichtet werden m√ºssen, k√∂nnen Sprites beliebig positioniert werden, um Spielercharaktere, Hindernisse, Projektile und Objekte mit komplexen Bewegungen anzuzeigen.  Zum Beispiel in der obigen Szene aus Mega Man (1987), um den Charakter eines Spielers anzuzeigen.  Punkte und Energiestreifen werden als Sprites verwendet, die es ihnen erm√∂glichen, beim Scrollen des Bildschirms aus dem Raster der Namenstabellen auszubrechen. <br><br>  Sprites haben eine eigene CHR-Seite [8] und einen Satz von 4 Paletten.  Dar√ºber hinaus belegen sie eine 256-Byte-Speicherseite.  Hier werden die Position und das Erscheinungsbild jedes Sprites aufgelistet (wie sich herausstellt, ist der NES-Videospeicher zweieinhalb Mal gr√∂√üer als im ersten Teil des Artikels erw√§hnt).  Das Format dieser Datens√§tze ist eher ungew√∂hnlich - sie enthalten zuerst eine Position in Y, dann eine Kachelnummer, dann ein Attribut und dann eine Position in X [9].  Da jeder Datensatz 4 Bytes ben√∂tigt, gibt es eine strikte Einschr√§nkung: Auf dem Bildschirm d√ºrfen nicht mehr als 256/4 = 64 Sprites gleichzeitig angezeigt werden. <br><br>  Die Bytes Y und X geben das obere linke Pixel des gezeichneten Sprites an.  Daher kann das Sprite auf der rechten Seite des Bildschirms beschnitten werden, auf der linken Seite l√§sst es jedoch leeren Raum.  Das Byte der Kachel √§hnelt dem Wert in der Namenstabelle, nur f√ºr diese Kacheln verwenden die Sprites ihre eigene CHR.  Ein Attributbyte ist ein Paket von Bits, das drei Aufgaben ausf√ºhrt: Zwei Bits werden der Palette zugewiesen, zwei Bits werden verwendet, um das Sprite horizontal oder vertikal zu spiegeln, und ein Bit bestimmt, ob das Sprite unter den Namenstabellen gerendert werden soll [10]. <br><br><h1>  Einschr√§nkungen </h1><br>  Moderne Systeme erm√∂glichen das Arbeiten mit Sprites beliebiger Gr√∂√üe, aber auf NES musste das Sprite aufgrund von CHR-Einschr√§nkungen eine Gr√∂√üe von 8 √ó 8 haben [11].  Gr√∂√üere Objekte bestehen aus mehreren Sprites, und das Programm sollte sicherstellen, dass alle Einzelteile nebeneinander gerendert werden.  Zum Beispiel kann eine Megaman-Charaktergr√∂√üe 10 Sprites erreichen, wodurch Sie auch mehr Farben verwenden k√∂nnen, insbesondere f√ºr seine wei√üen Augen und seinen Hautton. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/fea/3dc/dd8fea3dc4880761b52885c8ff83acdd.png"></div><br>  Die Hauptbeschr√§nkung bei der Verwendung von Sprites besteht darin, dass nicht mehr als 8 Sprites pro Rasterzeile vorhanden sein d√ºrfen.  Wenn mehr als 8 Sprites in einer horizontalen Linie des Bildschirms angezeigt werden, werden die sp√§ter angezeigten Sprites einfach nicht gerendert.  Dies ist der Grund f√ºr das Flackern in Spielen mit vielen Sprites.  Das Programm tauscht die Adressen von Sprites im Speicher aus, so dass jeder von ihnen zumindest gelegentlich gerendert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/b67/13c/5f0b6713c1be1837d0da2d8213253932.gif" alt="Megaman-Flimmern" width="332" height="128"></div><br>  Schlie√ülich wirkt sich das Scrollen nicht auf Sprites aus: Die Position des Sprites auf dem Bildschirm wird unabh√§ngig von der Position des Scrollens durch seine Y- und X-Werte bestimmt.  Manchmal ist dies ein Plus, zum Beispiel wenn sich das Level relativ zum Spieler bewegt oder die Benutzeroberfl√§che in einer festen Position bleibt.  In anderen F√§llen ist dies jedoch ein Minus - Sie m√ºssen das sich bewegende Objekt verschieben und dann seine Position um den Betrag der √Ñnderung beim Scrollen √§ndern. <br><br><h1>  Anmerkungen </h1><br>  [6] Theoretisch gibt es tats√§chlich vier Namenstabellen, die jedoch so gespiegelt werden, dass nur zwei davon eindeutige Grafiken enthalten.  Wenn sie nebeneinander platziert werden, spricht man von vertikaler Spiegelung, und wenn sich Namenstabellen √ºbereinander befinden, von horizontaler Spiegelung. <br><br>  [7] Es gibt auch ein Register, das ausw√§hlt, mit welcher Namenstabelle das Rendern beginnen soll, dh das Scrollen ist tats√§chlich ein 10-Bit-Wert oder 9-Bit, wenn Sie die Spiegelung in Betracht ziehen. <br><br>  [8] Dies ist nicht immer der Fall.  Die PPU kann so konfiguriert werden, dass f√ºr Namenstabellen dieselbe CHR-Seite wie f√ºr Sprites verwendet wird. <br><br>  [9] M√∂glicherweise wurde diese Reihenfolge verwendet, weil sie den Daten entspricht, die die PPU f√ºr ein effizientes Rendern verarbeiten muss. <br><br>  [10] Dieses Bit wird f√ºr verschiedene Effekte verwendet, z. B. um Mario in Super Mario Bros 3 unter die wei√üen Bl√∂cke zu bewegen oder um Nebel √ºber Sprites in Castlevania 3 zu rendern. <br><br>  [11] PPU bietet auch die Option, 8 √ó 16-Sprites zu aktivieren, die in Spielen wie Contra verwendet werden, in denen es gro√üe Charaktere gibt.  Es gelten jedoch alle anderen Einschr√§nkungen. <br><br><h2>  Teil 3 </h2><br>  In den vorherigen Abschnitten haben wir √ºber CHR-Daten, Hintergr√ºnde basierend auf Namenstabellen, Sprites und Scrollen gesprochen.  Und das ist praktisch alles, was eine einfache NES-Kassette ohne zus√§tzliche Hardware leisten kann.  Um noch weiter zu gehen, m√ºssen wir detailliert erkl√§ren, wie das Rendern funktioniert. <br><br><h1>  Rendern </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/0d4/0ad/12b0d40ad74d27ce6d8ff2499c6df163.gif" width="200" height="200"></div><br>  <i>Raster-Rendering mit einer Pause f√ºr vblank</i> <br><br>  Wie andere alte Computer wurde NES f√ºr die Verwendung mit R√∂hrenfernsehern entwickelt.  Sie zeichnen nacheinander Scanlinien auf dem Bildschirm von links nach rechts, von oben nach unten, wobei sie eine Elektronenkanone verwenden, die sich physisch zu dem Punkt auf dem Bildschirm bewegt, an dem diese Linien gezeichnet werden.  Nach Erreichen der unteren Ecke setzt eine Zeitspanne ein, die als ‚Äûvertikaler Rohling‚Äú (oder vblank) bezeichnet wird: Die Elektronenkanone kehrt in die obere linke Ecke zur√ºck, um das Zeichnen des n√§chsten Rahmens vorzubereiten.  Innerhalb von NES f√ºhrt die PPU (Picture Processing Unit) in jedem Frame automatisch ein Raster-Rendering durch, und der in der CPU arbeitende Code erledigt alle Aufgaben, die das Spiel ausf√ºhren sollte.  Mit Vblank kann das Programm die Daten im PPU-Speicher ersetzen, da diese Daten sonst zum Rendern verwendet werden.  In diesem kleinen Fenster werden meistens √Ñnderungen an der Namenstabelle und den PPU-Paletten vorgenommen. <br><br>  W√§hrend des Bildschirm-Renderings k√∂nnen jedoch einige √Ñnderungen am Status der PPU vorgenommen werden.  Sie werden "Rastereffekte" genannt.  Die h√§ufigste Aktion beim Rendern des Bildschirms ist das Festlegen der Bildlaufposition.  Dank dessen bleibt ein Teil des Bildes statisch (z. B. die Spieloberfl√§che) und alles andere wird weiter gescrollt.  Um diesen Effekt zu erzielen, muss der Zeitpunkt f√ºr die √Ñnderung des Bildlaufwerts genau so ausgew√§hlt werden, dass er in der gew√ºnschten Rasterzeile auftritt.  Es gibt viele Techniken, um diese Art der Synchronisation zwischen Spielcode und PPU zu implementieren. <br><br><h1>  Geteilter Bildschirm </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/4bf/c1e/36e4bfc1e8e92ae1dbfb83225946dc0f.png" width="512" height="480"></div><br>  <i>Die Ebene scrollt und die Oberfl√§che am oberen Bildschirmrand bleibt station√§r</i> <br><br>  Erstens verf√ºgt die PPU √ºber eine integrierte Hardware, die Sprite auf besondere Weise in der Nullspeicherposition verarbeitet.  Wenn beim Rendern dieses Sprites eines seiner Pixel den sichtbaren Teil des Hintergrunds √ºberlappt, wird ein Bit namens "sprite0 flag" gesetzt.  Der Spielcode kann dieses Sprite zuerst dort platzieren, wo die Bildschirmaufteilung erfolgen soll, und dann in einer Schleife warten und den Wert des Sprite0-Flags √ºberpr√ºfen.  Wenn die Schleife beendet wird, wei√ü das Spiel daher genau, welche Rasterlinie gerade gerendert wird.  Diese Technik wird verwendet, um eine einfache Bildschirmfreigabe in vielen NES-Spielen zu implementieren, einschlie√ülich Ninja Gaiden (1989), wie oben gezeigt [12]. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/acd/f19/66bacdf196bab83b91ea70c2657dd497.png" alt="Ninja-hud" width="256" height="240"></div><br>  <i>Sprite0 befindet sich bei Y $ 26, X $ a0.</i>  <i>Wenn die unterste Pixelreihe gerendert wird, wird das Sprite0-Flag gesetzt</i> <br><br>  In einigen Spielen wird das Sprite0-Flag mit einer anderen Technik kombiniert - einer vorhersagbar zeitgesteuerten Schleife (‚Äûein Zyklus mit vorhersagbarem Timing‚Äú): Das Programm wartet, bis einige zus√§tzliche Zeilen gerendert werden, um den Bildschirm in mehrere Teile zu unterteilen.  Diese Technik wird beispielsweise in vielen Ninja Gaiden-Bildschirmschonern verwendet, um dramatische Effekte zu erzielen, z. B. ein windgetriebenes Feld oder ein Bild einer Burg in der Ferne.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel f√ºhrt Aufgaben wie das Abspielen von Musik und das Warten auf den Eintritt des Spielers zu Beginn des Renderns des Frames aus, verwendet dann sprite0, um nach der ersten Division zu suchen, und f√ºr alle anderen verwendet es zeitgesteuerte Schleifen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/19a/bfd/cf919abfdd1c0d786440e0af2c99bb24.gif" alt="Ninjas-in-Field" width="512" height="480"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/fab/d51/f77fabd51c4431db2c98ee1bf64e0eb2.gif" alt="Blick auf die Burg" width="512" height="480"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Spiele k√∂nnen es sich jedoch nicht leisten, in Zyklen zu warten, insbesondere in aktiven Szenen, in denen die CPU-Zeit Gold wert ist. In solchen F√§llen wird eine spezielle Ausr√ºstung verwendet, die in den Kassetten installiert ist (Mapper genannt, da sie eine eigene Zuordnung im Speicher verwendet (Speicherzuordnung)), die eine Benachrichtigung √ºber den Zeitpunkt des Renderns einer bestimmten Rasterzeile erhalten kann [13], wodurch Wartezyklen vollst√§ndig entfallen. Der Spielcode kann jede seiner Aufgaben und zu jedem gew√ºnschten Zeitpunkt ausf√ºhren, sodass der Prozessor optimaler genutzt wird. Die meisten moderneren Spiele f√ºr NES, die viele Bildschirmunterteilungen aufweisen, verwenden Mapper auf diese Weise.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/9c3/f4f/6189c3f4fa79e5c31b80b2c14df75dcb.gif" alt="Zugniveau" width="512" height="480"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel aus Ninja Gaiden 2, das einen Mapper verwendet, um mehrere Partitionen auszuf√ºhren und Parallaxen-Scrollen zu simulieren, was trotz der statischen Natur des Levels ein Gef√ºhl von gro√üer Geschwindigkeit erzeugt. </font><font style="vertical-align: inherit;">Beachten Sie, dass alle einzelnen beweglichen Teile streng horizontale Streifen einnehmen. </font><font style="vertical-align: inherit;">Das hei√üt, keine der Hintergrundebenen kann sich mit einer anderen √ºberlappen. </font><font style="vertical-align: inherit;">Dies liegt daran, dass Trennungen tats√§chlich implementiert werden, indem das Scrollen einzelner Rasterzeilen ge√§ndert wird.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bankwechsel </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapper k√∂nnen viele andere Funktionen ausf√ºhren, aber die h√§ufigste davon ist das Wechseln von Banken. Dies ist eine Operation, bei der der gesamte Block von Adressr√§umen neu zugewiesen wird, um auf einen anderen Teil des Speichers zu verweisen [14]. Das Wechseln der B√§nke kann mit dem Programmcode (mit dem Sie viele Ebenen und Musik in Spielen erstellen k√∂nnen) sowie mit CHR-Daten durchgef√ºhrt werden, sodass Sie die Kacheln, auf die in den Namenstabellen oder Sprites verwiesen wird, sofort ersetzen k√∂nnen. Wenn Sie die Bank zwischen Frames wechseln, k√∂nnen Sie den gesamten Hintergrund gleichzeitig animieren. Bei Verwendung als Rastereffekt k√∂nnen Sie jedoch v√∂llig unterschiedliche Grafiken in verschiedenen Bereichen des Bildschirms zeichnen. In Spielen der Ninja Gaiden-Serie wird dieser Ansatz w√§hrend des Spielprozesses verwendet, um die Benutzeroberfl√§che getrennt vom Level zu rendern, sowie w√§hrend Bildschirmschonern.Damit k√∂nnen Sie Text und visuelle Szenen in verschiedenen Banken CHR speichern.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69f/896/804/69f8968042bded347183e35af32c16ae.gif" alt="goofall-bg" width="512" height="480"></div><br> <i> ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/882/f90/290882f90bb731af9e98f7ee65b4e64f.png" alt="goofall-nt" width="512" height="480"></div><br> <i>  ,        </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/077/b23/cf7077b23ea5242b4f27d308b7514077.png" width="512" height="480"></div><br> <i>      CHR.     ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/335/28e/7a233528e53b01341d21112b3651310e.png" alt="Wer-sind-sie-unten-Bank" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten wird eine andere CHR-Bank verwendet. Beim Bankwechsel wird auch der Bildlaufwert zur√ºckgesetzt. Das</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bankwechsel kann in begrenzter (aber dennoch beeindruckender) Form auch f√ºr das Parallaxen-Bildlauf verwendet werden. Wenn die Szene einen Teil des Hintergrunds hat, der aus einem kurzen sich wiederholenden Muster besteht, kann dasselbe Muster in mehreren B√§nken mit einem Versatz um einen anderen Betrag enthalten sein. Dann kann dieses Muster auf einen bestimmten Wert gescrollt werden, indem zur Bank mit dem entsprechenden Versatz gewechselt wird. Eine solche Technik kann zum Parallaxen-Scrollen verwendet werden, selbst wenn sich der Hintergrund aufgrund des Vorhandenseins von Kacheln √ºberlappt, die nicht von der Speicherumschaltung betroffen sind [15]. Der Nachteil dieser Methode ist, dass insgesamt alle Banken viel CHR-Platz beanspruchen m√ºssen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/6b4/281/5016b4281a88523177dffef3f8de4250.gif" alt="Metallsturm-bg" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal Storm (1991) verwendet Bank Switching f√ºr das Layer-by-Side-Scrollen</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c05/7d4/6cb/c057d46cbf7f4d2cfb3e401d1658692f.png" alt="Metallsturm-nt" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Wiederholen der Namenstabelle k√∂nnen Sie diesen</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CHR- </font><i><font style="vertical-align: inherit;">Effekt</font></i><font style="vertical-align: inherit;"> mit Bankwechsel </font><i><font style="vertical-align: inherit;">erstellen</font></i><font style="vertical-align: inherit;"> - dies ist ein sehr leistungsf√§higes Tool, das jedoch seine Grenzen hat. </font><font style="vertical-align: inherit;">Obwohl es n√ºtzlich ist, den gesamten Bildschirm zu animieren, ist diese Technik nicht sehr gut geeignet, um nur einen kleinen Teil des Bildschirms zu ersetzen. </font><font style="vertical-align: inherit;">Dies erfordert auch √Ñnderungen der Namenstabelle. </font><font style="vertical-align: inherit;">Au√üerdem ist die Menge an CHR in der Kassette begrenzt, und um zu Daten zu wechseln, m√ºssen diese zuerst vorhanden sein. </font><font style="vertical-align: inherit;">Mit Ausnahme von Rastereffekten auf Bildlaufbasis verf√ºgt das Spiel immer √ºber ein striktes Raster von Namenstabellen, wodurch der Dynamikbereich von Grafikeffekten begrenzt wird.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andere Beispiele </font></font></h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="Lasterfeuer" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel Vice: Project Doom (1991) erzeugt diesen Flammeneffekt, indem die Bildlaufposition in jeder Rasterzeile wiederholt festgelegt wird. </font><font style="vertical-align: inherit;">Das Zeichen im Vordergrund wird aus Sprites erstellt, die vom Scrollen nicht betroffen sind.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/25b/9b9/25325b9b935359508dc420aa35ef1748.gif" alt="Schwertmeister" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sword Master (1990) verwendet die Bankumschaltung, um Berge in der Ferne zu scrollen und den Bildschirm f√ºr die Benutzeroberfl√§che und das Gras im Vordergrund zu teilen.</font></font></i> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Danksagung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne die leistungsstarken Debugging-Funktionen des FCEUX-Emulators w√§re es mir nicht m√∂glich, alle diese Grafiken f√ºr einen Artikel zu generieren. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist das NesDev-Site-Wiki zu einer n√ºtzlichen Informationsquelle √ºber sprite0 geworden:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fceux</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NesDev Wiki</font></font></a> </li></ul><br><h1>  Anmerkungen </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] Tats√§chlich ist die Situation mit Ninja Gaiden etwas komplizierter. Das Spiel verwendet 8 √ó 16-Sprites-Sprites - ein spezieller Modus, der von der PPU bereitgestellt wird und Sprites als vertikal √ºberlagerte Paare darstellt. Das hei√üt, sprite0 ist vollst√§ndig transparent und sprite1 hat ganz unten eine Pixelreihe. Er setzt auch die Z-Ebene dieser Sprites so, dass sie hinter der Schw√§rze der Benutzeroberfl√§che gerendert werden, wodurch alles unsichtbar wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] Dies ist ziemlich schwierig zu implementieren. Der Spielcode schreibt die gew√ºnschte Rasterzeile in den Adressraum des Mappers. Der Mapper f√§ngt dann PPU-Speicherzugriffsanforderungen ab und z√§hlt, wann eine neue Rasterzeile gerendert wird. Bei Erreichen der gew√ºnschten Rasterzeile wird ein Programm-Interrupt (IRQ) generiert, w√§hrend dessen der Spielcode ausgef√ºhrt wird und der das tut, was w√§hrend dieser bestimmten Rasterzeile ben√∂tigt wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14] Das Umschalten wird durchgef√ºhrt, indem Ger√§te dem Speicher zugeordnet werden, Speicherzugriffsoperationen abgefangen und der physische Ort neu definiert wird, von dem Daten erhalten werden. </font><font style="vertical-align: inherit;">Das Ergebnis ist augenblicklich, weist jedoch eine gro√üe Fraktionalit√§t auf, wodurch die Intervalle der Adressen um 4 KB oder 8 KB variieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15] Die einzige M√∂glichkeit, CHR-B√§nke zu wechseln, ohne die einzelnen Kacheln zu beeinflussen, besteht darin, entweder die Kacheldaten zwischen den B√§nken zu duplizieren oder einen Mapper mit weniger K√∂rnung zu verwenden. </font><font style="vertical-align: inherit;">Mit diesem Mapper k√∂nnen Sie einen kleineren Teil der Bank wechseln, z. B. jeweils nur 1 KB, und alles andere bleibt unver√§ndert.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470614/">https://habr.com/ru/post/de470614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470600/index.html">√úber sichere noVNC-Konsolen, automatische Skalierung in Kubernetes, Haproxy in Ostrovka und die Arbeit von Administratoren mit Programmierern</a></li>
<li><a href="../de470604/index.html">Geschwindigkeit beim Laden von Websites im E-Commerce: Analyse von 48 Top-Online-Shops in Russland</a></li>
<li><a href="../de470608/index.html">Unity UI-Optimierung</a></li>
<li><a href="../de470610/index.html">Ein Tag im Leben eines Entwicklers</a></li>
<li><a href="../de470612/index.html">Was ein Voltmeter zeigt, oder Mathe-Steckdosen</a></li>
<li><a href="../de470616/index.html">Eine neue L√∂sung f√ºr das Fermi-Paradoxon (warum wir allein im Universum sind)</a></li>
<li><a href="../de470618/index.html">Thematische Modellierung von Nachrichten mittels Faktoranalyse</a></li>
<li><a href="../de470620/index.html">Infrastruktur als Code: So √ºberwinden Sie Probleme mit XP</a></li>
<li><a href="../de470622/index.html">√úbersicht √ºber Methoden zur Merkmalsauswahl</a></li>
<li><a href="../de470628/index.html">Raumschiff Simulator Schiffbau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>