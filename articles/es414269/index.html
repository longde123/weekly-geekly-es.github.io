<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïï üë®üèª‚Äçüöí üèÇüèø "20,000 IOPS por nodo tienen un buen rendimiento con 5 ms de latencia". Para OLTP: no üê≤ ü§¶üèø ‚è≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La raz√≥n para escribir este art√≠culo fue una revisi√≥n muy valiosa de c√≥mo probamos VMware vSAN ... CROC. La revisi√≥n es digna, pero tiene una frase co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"20,000 IOPS por nodo tienen un buen rendimiento con 5 ms de latencia". Para OLTP: no</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414269/"><p><img src="https://habrastorage.org/webt/fq/yy/2k/fqyy2kbw4iqx5ikqy7v-o60jfce.jpeg" alt="KDPV"></p><br><p>  La raz√≥n para escribir este art√≠culo fue una revisi√≥n muy valiosa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo probamos VMware vSAN ...</a> CROC.  La revisi√≥n es digna, pero tiene una frase con la que he estado luchando durante m√°s de una d√©cada.  Los administradores de almacenamiento, virtualizadores e integradores repiten una y otra vez: "Los retrasos de 5 ms son un excelente indicador".  Incluso la cifra de 5 ms durante diez a√±os no cambia.  Escuch√© esto en vivo de administradores altamente respetados no menos de una docena de veces.  De menos respetados - docenas, y cu√°ntas veces leo en Internet ... No, no, no.  Para cargas OLTP de 5 ms, especialmente porque generalmente se miden, estos son fallas √©picas.  Tuve que explicar las razones de esto muchas veces, esta vez decid√≠ reunir mis pensamientos en una forma reutilizable. </p><br><p>  Debo decir de inmediato que no hay tales errores en el art√≠culo mencionado anteriormente, sino que la frase funcion√≥ como un disparador. </p><a name="habracut"></a><br><h2 id="tipichnoe-nachalo">  Inicio t√≠pico </h2><br><p>  Todo lo que se describe en este art√≠culo es cierto para los DBMS comunes utilizados para OLTP empresarial t√≠pico.  Sobre todo, tengo experiencia con MS SQL Server, pero, al menos para PostgeSQL, Oracle y Sybase, muchos puntos y conclusiones tambi√©n seguir√°n siendo ciertos. </p><br><p>  El DBMS de rendimiento generalmente no est√° satisfecho con todos.  Si hay un DBMS en un sistema grande, y de repente casi siempre est√° ah√≠, entonces este DBMS es un cuello de botella.  Bueno, o inmediatamente se convertir√° en un cuello de botella si comienzas a optimizar todo lo dem√°s.  Y as√≠, el cliente llega y dice con voz humana: "¬°Ayuda! ¬°Ahorre! Pagaron $ NNNNNNNN por el servidor y el almacenamiento, ¬°pero la velocidad no aumenta! Ah, y el administrador configur√≥ y el proveedor consult√≥, pero a√∫n no se mueve".  Si los desarrolladores del sistema se ajustan a la definici√≥n de Lavrov (podemos hacerlo sin una cita exacta), y los especialistas de operaci√≥n y mantenimiento "luchan con incidentes al reiniciar el servidor", entonces el problema es a menudo simple y sin pretensiones: no hay √≠ndices, consultas torcidas, errores fatales de configuraci√≥n (sobre los cuales la documentaci√≥n est√° en negrita dice <strong>"¬°no puedes hacer esto!"</strong> ), bloqueos excesivos, puntos muertos y otras tonter√≠as simples y claras.  Hay muchos de estos casos, la mayor√≠a, pero no todos.  Si el sistema, en complejidad o carga, ha cruzado alg√∫n l√≠mite invisible, morir√° de estos problemas o pasar√° al siguiente nivel. </p><br><div class="spoiler">  <b class="spoiler_title">Consejos de diagn√≥stico de SQL Server</b> <div class="spoiler_text"><p> En mi humilde opini√≥n, la mejor herramienta ahora es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer kit de respuesta de SQL Server</a> , promovido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brent Ozar</a> .  Esta herramienta se est√° desarrollando de manera muy activa.  Todav√≠a hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto</a> digno de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Glenn Berry</a> , √©l tampoco abandon√≥ su proyecto.  Ambos conjuntos son hermosos a su manera, leer comentarios y consultas por primera vez abre muchas cosas nuevas.  Yo mismo siempre empiezo a mirar alrededor con <code>sys.dm_os_waitsats</code> , un vistazo r√°pido al registro de errores y <code>sys.dm_os_waitsats</code> si hay al menos alg√∫n sistema de respaldo que funcione. </p></div></div><br><p>  En este nivel, el servidor ya no est√° bajo la mesa del director, los discos ya no est√°n dentro del servidor, pero en el sistema de almacenamiento, los desarrolladores conocen los √≠ndices y los administradores ya conocen PowerShell, y los gerentes de TI comienzan a decir palabras inteligentes como SLA y RPO / RTO.  Una situaci√≥n interesante surge a este nivel: </p><br><ul><li>  DBMS es un cuello de botella. </li><li>  El servidor parece ser suficiente en todos los aspectos. </li><li>  El DBMS puede mejorarse a√∫n m√°s mediante programaci√≥n, pero es dif√≠cil (cambiar a licencias m√°s caras o cambiar a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"zona roja de la curva Shipilev"</a> para la optimizaci√≥n) </li><li>  El sistema de disco se compra caro y, al parecer, incluso est√° configurado de alguna manera. </li></ul><br><p>  Pero no  El cocodrilo no se atrapa, el coco no crece y el rendimiento del sistema es el mismo o inferior que en el servidor anterior.  Miro en <code>sys.dm_os_waitsats</code> y veo <code>WRITELOG</code> , <code>PAGEIOLATCH_SH</code> y <code>PAGEIOLATCH_EX</code> en la parte superior, el tiempo de espera promedio es de 5+ ms.  Bueno, t√≠pico, cho: "Hola, administradores y DBA, aqu√≠ tienes un sistema de disco - cuello de botella" y aqu√≠ comienza una vieja canci√≥n de unos 5 ms: </p><br><ul><li>  Tenemos 5 ms para SLA </li><li>  S√≠, tenemos un regimiento de 20,000 IOPS </li><li>  El vendedor nos dijo que todos los archivos de la base de datos pueden estar en una partici√≥n </li><li>  Tenemos virtualizaci√≥n e hiperconvergencia y no podemos asignar discos separados bajo la base de datos. </li><li>  Seg√∫n nuestros datos, la utilizaci√≥n del servidor 5% </li><li>  Todo est√° configurado seg√∫n las recomendaciones. </li><li>  Sus bases de datos no necesitan mucho rendimiento, no hacen m√°s de 300 IOPS (y tenemos un estante para 20,000 IOPS) </li></ul><br><p>  Por cierto, todo lo anterior, no solo sobre "sus" servidores, sino tambi√©n sobre los servicios en la nube y la virtualizaci√≥n.  Hay un mont√≥n de sus propios detalles, pero el cuadro cl√≠nico t√≠pico es casi el mismo: base de datos moderadamente optimizada, personal inteligente de desarrollo y mantenimiento, hay una reserva para el procesador y la memoria, el "escape" de futuras inversiones es casi cero. </p><br><p>  Entonces aqu√≠.  Toda esta canci√≥n sobre "5 ms" no tiene sentido y tiene sentido.  Si usted mismo dice esto, lea este art√≠culo.  Y si te dicen esto, prepara los argumentos.  Antes, cuando escuch√© estas palabras, estaba enojado, pero ya no estoy enojado.  Yo, como esa olla con una petunia de la Gu√≠a del autoestopista gal√°ctico, solo tengo un pensamiento: "Bueno, otra vez ...". </p><br><h2 id="kto-vinovat">  ¬øQui√©n tiene la culpa? </h2><br><p>  ¬øPor qu√© la base de datos es tan lenta?  Bueno, parece que un servidor t√≠pico con 20-64 n√∫cleos a una frecuencia de 2-3 GHz es capaz de realizar operaciones simples de 50-150 mil millones, y las pruebas de base de datos m√°ximas (sint√©ticas) muestran en tales m√°quinas solo 10,000-50000 transacciones por segundo.  Hey  Bueno, esto es de un mill√≥n a una docena de posibles millones de transacciones por transacci√≥n.  No es solo mucho, es mucho sentir. <br>  Tal costo indirecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ACID-</a> requisitos para transacciones. </p><br><ul><li>  <strong>Una</strong> tomicidad: o se completa la transacci√≥n completa o no se completa la totalidad. </li><li>  <strong>C</strong> onstancia: a la entrada y a la salida de una transacci√≥n, el sistema est√° en un estado consistente </li><li>  <strong>I</strong> solation - las transacciones no ven los estados intermedios del otro </li><li>  Durabilidad: si la transacci√≥n se ha completado con √©xito (comprometido), entonces, independientemente de las circunstancias, los cambios realizados deben permanecer en el sistema. </li></ul><br><p>  Por cierto, letra por letra, estos requisitos no se cumplen en casi ning√∫n lugar y nunca, sino simplemente en sistemas distribuidos (el teorema CAP interfiere).  Para nuestra situaci√≥n, el requisito "D" es m√°s probable que sea m√°s costoso que otros, este requisito lo proporciona el mecanismo clave de todos los DBMS OLTP comunes: WAL, registro de escritura anticipada (PostgeSQL), tambi√©n es un registro de transacciones (SQL Server), tambi√©n conocido como registro REDO (Oracle).  Aqu√≠ est√°: una piedra en el cuello de la productividad, y es la base de las transacciones de Durabilidad. </p><br><h3 id="chto-takoe-wal">  ¬øQu√© es el WAL? </h3><br><p>  Olvidemos por un momento los SSD modernos, los sistemas de almacenamiento geniales.  Supongamos que tenemos un servidor, tiene uno o m√°s discos. <br>  Cualquier transacci√≥n, incluso la inserci√≥n de un registro, es al menos potencialmente, pero de hecho casi siempre y de manera realista una acci√≥n no at√≥mica.  Casi siempre necesitamos cambiar no solo la p√°gina donde se encuentra el registro, sino tambi√©n las p√°ginas de √≠ndice, posiblemente las p√°ginas de servicio.  Adem√°s, en la misma transacci√≥n, la misma p√°gina puede cambiar muchas veces.  Adem√°s, se pueden realizar otras transacciones en paralelo con nosotros.  Adem√°s, las transacciones vecinas en el tiempo constantemente "jalan" las mismas p√°ginas.  Si esperamos que cada p√°gina se escriba en el disco antes de continuar, que es esencialmente lo que Durability requiere, tendremos que escribir muchas veces m√°s y esperar a que se complete cada grabaci√≥n en medios no vol√°tiles.  ¬°Sin cach√©s, sin reorganizaci√≥n de operaciones en la cola, de lo contrario no habr√° integridad!  Adem√°s, de alguna manera tenemos que tener en cuenta qu√© datos ya est√°n en las transacciones fijas y cu√°les no (y qu√© datos estaban antes).  Para entenderlo, un disco duro √∫nico t√≠pico (HDD) en este modo dar√° 50-100 IOPS y esto ha sido una constante durante 20 a√±os.  Una peque√±a transacci√≥n requerir√° 5-10 operaciones de escritura.  Ah, s√≠, para saber qu√© grabar, debes leerlo.  Incluso los sistemas OLTP muy, muy fuertemente escribibles leen 3 veces m√°s de lo que escriben.  Por lo tanto, nuestra transacci√≥n cuesta 20-40 IO, lo que significa 0.2-0.8 segundos por disco. <br>  2 transacciones por segundo.  ¬øNo es suficiente?  ¬øIntentamos dispersar los discos?  Ah, pero todav√≠a tenemos que esperar hasta que se grabe el anterior y no haya paralelismo al final.  Como ser  ¬°Y comencemos un archivo de registro en el que registraremos secuencialmente todas las operaciones de escritura en la base de datos y las marcas de transacci√≥n!  Pros: </p><br><ul><li>  La informaci√≥n sobre la operaci√≥n puede ser mucho m√°s compacta que registrar toda la p√°gina (un tama√±o de p√°gina t√≠pico es de 8 KiB, la informaci√≥n escrita en el registro suele ser de 0,5-1 KiB). </li><li>  En lugar de escribir sobre si la transacci√≥n se registra o no directamente en la p√°gina, hay suficientes etiquetas sobre el comienzo y la fijaci√≥n de la transacci√≥n en el registro. </li><li>  Las p√°ginas no se pueden escribir despu√©s de cada transacci√≥n, varias veces menos.  El proceso de lectura / escritura de datos est√° completamente "desatado" del registro. </li><li>  Lo principal  Si colocamos nuestro diario en un disco separado y escribimos registros secuencialmente, entonces debido al hecho de que no necesita reposicionar constantemente los cabezales del disco, incluso un HDD dom√©stico en este modo comprime hasta 1000 IOPS, dado que las peque√±as transacciones "cuestan" 2-4 entradas de diario, entonces puedes exprimir 200-400 TPS </li><li>  En caso de falla, el estado del archivo de datos puede restaurarse utilizando dicho registro, y si se cancela una transacci√≥n, los cambios pueden revertirse. </li></ul><br><p>  Dicho registro se denomina registro de escritura anticipada / registro de transacciones / registro REDO. </p><br><p>  ¬°Hurra!  Genial  Hubo 2 transacciones por segundo, se convirti√≥ en 300, mejor√≥ 150 veces.  ¬øY a qu√© costo?  Como resultado, el precio es significativo: </p><br><ul><li>  En todos los DBMS comunes, el registro es estrictamente consistente.  Un hilo es responsable de escribir en el registro.  ¬øTienes 100 procesadores?  Genial  Y el registro seguir√° escribiendo un hilo.  La profundidad de la cola es exactamente una. </li><li>  A√∫n as√≠, no hay cach√©s del sistema operativo, no hay permutaciones de operaciones.  Los requisitos de durabilidad se mantuvieron.  Operaciones de escritura: hasta que el disco respondi√≥ "Escrib√≠, lo escrib√≠ directamente a la superficie, no al cach√©, seguro" El DBMS no contin√∫a funcionando. </li><li>  Si coloca el archivo de registro en el disco de datos, se perder√°n casi todos los beneficios de la grabaci√≥n secuencial.  Adem√°s, para bien, si hay varias bases de datos en el servidor, entonces varios discos para revistas. </li><li>  Reversi√≥n de transacciones (al menos en MS SQL Server): lea el registro y restaure el estado a partir de √©l.  Estas son tantas o incluso m√°s operaciones de escritura como operaciones de escritura en la transacci√≥n.  ¬°La reversi√≥n es costosa! </li></ul><br><p>  Esta explicaci√≥n es muy simplificada, "en los dedos".  Esto es suficiente para nuestro tema.  WAL es un mecanismo clave y fundamental para garantizar la transaccionalidad, es necesariamente una escritura, el acceso es de un solo subproceso solo para grabaci√≥n secuencial, desde el punto de vista del almacenamiento, la profundidad de la cola es 1. </p><br><div class="spoiler">  <b class="spoiler_title">Si te interesa este tema</b> <div class="spoiler_text"><ul><li>  Un art√≠culo muy introductorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo se dise√±an las bases de datos</a> </li><li>  Hay una excelente serie de art√≠culos para SQL Server: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo dejar de llamar al registro de transacciones de SQL Server un archivo de registro y dejar de luchar por su tama√±o.</a> </li><li>  Es interesante mirar un poco desde el otro lado, por ejemplo, la transcripci√≥n de un excelente informe sobre el DBMS de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarantool</a> en memoria </li><li>  Cada DBMS tiene secciones extensas que explican c√≥mo funciona WAL. </li></ul></div></div><br><p>  El tema del registro de escritura anticipada en la base de datos debe ser al menos m√≠nimo conocido para cualquiera que de alguna manera administre el DBMS, o la infraestructura del DBMS, o desarrolle bases de datos. </p><br><h3 id="wal-i-shd">  WAL y SHD </h3><br><p>  Los fabricantes de almacenamiento "desde el nacimiento" se enfrentan al DBMS.  Es para las bases de datos que las empresas compran estos complejos incre√≠blemente caros: desde el almacenamiento de precios en la calle de Dell-EMC, HP, Hitachi, NetApp, al dise√±ar un presupuesto, los ojos est√°n llenos de l√°grimas de la mayor√≠a de los altos directivos, a menos que, por supuesto, obtengan un porcentaje de este precio.  Pero hay un conflicto de ingenier√≠a y marketing.  Lo explicar√© usando Dell-EMC como ejemplo, pero solo porque recuerdo d√≥nde tienen la documentaci√≥n. </p><br><p>  Entonces </p><br><ol><li>  Diario de un solo hilo </li><li>  El registro de escritura, es decir, la latencia, es "eterno" en comparaci√≥n con el rendimiento de la CPU </li><li>  Las cargas OLTP son muchas transacciones relativamente peque√±as, </li><li>  La mayor√≠a de las otras cargas de DBMS son paralelas de una forma u otra. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La ley de Amdahl</a> nos dice sin piedad que una carga de bajo rendimiento de un solo subproceso har√° que agregar procesadores sea in√∫til, y el registro determinar√° el rendimiento.  Adem√°s, en este momento no nos importar√° el rendimiento del almacenamiento en IOPS, y solo la latencia ser√° importante. <br>  Pero no descarte otras operaciones de disco: leer y escribir en archivos de datos y <code>tempdb</code> .  La lectura tambi√©n es una operaci√≥n de "espera".  Hasta que una p√°gina de datos se lea del disco a la memoria, el procesador no puede procesarla.  Pero para estas operaciones, son posibles grandes colas y permutaci√≥n de operaciones en esta cola: el DBMS a menudo sabe qu√© p√°ginas cargar en la memoria, qu√© p√°ginas volcar y pone muchas colas para leer a la vez.  Como en este escenario es importante cuando finaliza la √∫ltima operaci√≥n del paquete, en esta carga, por el contrario, IOPS es m√°s importante para nosotros que la latencia de una sola operaci√≥n.  Para comprender el alcance: las operaciones de lectura en un sistema OLTP t√≠pico son 85% -95%.  S√≠, s√≠, s√≠, las operaciones de escritura son un orden de magnitud menor. </p><br><p>  Los ingenieros de almacenamiento de proveedores est√°n trabajando estrechamente con los proveedores de DBMS y conocen todos los matices t√©cnicos de c√≥mo funciona un DBMS con un subsistema de disco.  La planificaci√≥n, partici√≥n y asignaci√≥n adecuadas de los recursos del disco para el DBMS es una competencia compleja e importante del <strong>administrador del sistema de almacenamiento</strong> .  El mismo Dell-EMC incluso tiene el documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">t√©cnico</a> b√°sico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">H14621</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">H12341</a> para las recomendaciones de partici√≥n para SQL Server: m√°s de cien p√°ginas.  Hey  Este no es un muelle detallado, este es el libro blanco m√°s com√∫n.  Todav√≠a hay un mont√≥n de espec√≠ficos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">h15142</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">h16389</a> ... hay oscuridad all√≠).  Los "adyacentes" de VMware: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura de Microsoft SQL Server en VMware vSphere</a> no se quedan atr√°s.  Tenga en cuenta que estos documentos no son solo y no tanto para los DBA como para los administradores de infraestructura y almacenamiento. <br>  Tambi√©n noto que en todos estos documentos, los LUN separados se cortan para datos, registros y <code>tempdb</code> .  S√≠, en alg√∫n lugar de los √∫ltimos documentos dicen claramente que para las soluciones All-Flash no tiene sentido separar los registros en medios f√≠sicamente separados, pero los LUN a√∫n ofrecen cortarlos por separado.  Si volca datos y registros en un LUN, desde el punto de vista del sistema operativo ser√° una cola de E / S.  Y habr√° un problema.  Las operaciones de latencia tendr√°n inmediatamente un orden de magnitud m√°s.  Y debido al hecho de que las operaciones de registro no reubicables aparecer√°n en la cola, IOPS se deslizar√° en los archivos de datos y <code>tempdb</code> .  Este no es un "descubrimiento del siglo", es una verdad elemental de trabajar con la base de datos.  No est√° desactualizado ni cancelado con la llegada de All-Flash.  S√≠, los retrasos en las operaciones con SSD son m√°s r√°pidos en un orden de magnitud que en las operaciones con HDD, pero a√∫n son un par de √≥rdenes de magnitud m√°s lentos que las operaciones con memoria.  IO sigue siendo el cuello de botella del DBMS. <br>  Y los documentos t√©cnicos enfatizan correctamente que en los registros de transacciones el n√∫mero de IOPS no es importante, pero es importante que la latencia sea m√≠nima (en los tiempos modernos se escribe menos de 1 ms). </p><br><p>  Pero los vendedores necesitan vender.  Hiperconvergencia!  Virtualizaci√≥n!  Implementaci√≥n Flexibilidad!  ¬°Deduplicaci√≥n!  F√°cil configuraci√≥n!  ¬°Muchas, muchas IOPS!  Hermosas presentaciones, voz segura, disfraces formales.  Pero, ¬øde qu√© otra manera vender una soluci√≥n con una etiqueta de precio de 6 a 7 d√≠gitos en d√≥lares?  Para esto, de alguna manera se olvida que se puede obtener latencia o rendimiento del sistema de almacenamiento, pero no ambos a la vez, que alg√∫n tipo de licencia para el equilibrador de carga es como otro estante, que si la grabaci√≥n intensiva dura m√°s de una hora, entonces la RAM de los controladores no es suficiente y la productividad se reducir√° a "como si no hubiera cach√©", que capacitar a los empleados del cliente cuesta otros 100.000 rublos durante el primer a√±o, bueno, tales trucos ... </p><br><h3 id="5-ms">  5 ms </h3><br><p>  Habiendo escuchado mucho de haber le√≠do a los vendedores, o de la pereza, o debido a alg√∫n tipo de cucarachas, pero por alguna raz√≥n, a menudo los administradores de almacenamiento hacen algo como esto.  Tomamos un estante grande, lo combinamos todo en algo plano, lo cortamos en LUN aprovisionados delgados y lo distribuimos por LUN al servidor.  O dos, porque "la partici√≥n del sistema est√° bien deduplicada".  Y cuando veo que con el subsistema de disco desde el lado de SQL hell-hell-hell, la misma canci√≥n comienza que "5 ms es un excelente indicador", que "100000 IOPS", "Su carga de almacenamiento es inferior al 5%" </p><br><p>  <strong>NO</strong> </p><br><ul><li>  Para sistemas OLTP en una partici√≥n con WAL / registros de transacciones de 5 ms, este es un indicador no v√°lido.  En el trozo de hierro "casi b√°sico" por un precio de 1000 (en palabras: mil) veces m√°s barato, el indicador normal ahora ser√° 0.1-0.3 ms.  Y ma√±ana - 0.01 ms.  No es necesaria la velocidad, como la del HDD 2008, al precio de una entrada completa de apartamentos en Mosc√∫.  Ninguna "capacidad de servicio" vale la pena. </li><li>  ¬øEscribe el proveedor que los registros de transacciones no son exigentes con IOPS y pueden colocarse en el HDD?  Si lo es  Pero para esto es necesario que ninguno de estos discos <del>  contagio </del>  Adem√°s de escribir registros, el DBMS no toc√≥ la tarea.  Y para que el sistema de almacenamiento responda al servidor que los datos se escriben, inmediatamente cuando los datos ingresaron en la memoria no vol√°til (esto es mucho antes de que se escriban) </li><li>  Los discos delgados para bases de datos OLTP reales son malos. </li><li>  Para WAL, es absolutamente interesante la cantidad de IOPS que se puede exprimir a una profundidad de cola de 10 o 20. No hay profundidad all√≠. </li><li>  Para WAL, no es un indicador de que la cola de E / S en el sistema operativo sea "solo alrededor de 1".  Ella ya no lo estar√°. </li><li>  No, los desarrolladores de DBA y DB no son "p√°jaros carpinteros que no pueden configurar correctamente para escribir en el paralelo WAL" <em>(opini√≥n real del administrador)</em> </li><li>  La l√≥gica de los ventiladores para considerar el reciclaje "dado que su sistema <em>que configuramos torcidamente en una partici√≥n</em> no hace 10,000 IOPS, entonces debe moverse de una matriz de gama alta a un rango medio" - esta es una l√≥gica incorrecta. </li><li>  Si el servidor de 40 n√∫cleos tiene una carga de procesador del 2.5 por ciento, esto no significa que no tiene nada que hacer, pero, lo m√°s probable, significa que hay alg√∫n tipo de tarea que bloquea a todos los dem√°s. </li></ul><br><p>  Cuando la carga de algunos datos en la computadora port√°til del desarrollador toma 5 minutos, y en el servidor nuclear n√∫mero 40 con 1 TiB de RAM y almacenamiento por medio mill√≥n de d√≥lares, se realiza la misma tarea durante una hora, incluso los clientes m√°s pacientes tendr√°n preguntas sobre la factibilidad de los costos. </p><br><table><thead><tr><th>  Latencia media de partici√≥n WAL </th><th>  nunca habr√° m√°s transacciones por segundo que: </th></tr></thead><tbody><tr><td>  5 ms </td><td>  200 </td></tr><tr><td>  1 ms </td><td>  1000 </td></tr><tr><td>  0,5 ms </td><td>  2000 </td></tr><tr><td>  0.1 ms </td><td>  10,000 </td></tr><tr><td>  0,05 ms </td><td>  20000 </td></tr></tbody></table><br><h2 id="chto-delat">  Que hacer </h2><br><h3 id="sovety-administratoram-i-dba">  Consejos de administraci√≥n y DBA </h3><br><p>  Para OLTP, deje de contar "reciclaje" y IOPS.  Separadamente, observo: no mire IOPS con grandes profundidades de cola: incluso en particiones de datos, las colas grandes generalmente tienen una r√°faga corta o algo que no afecta el rendimiento real de OLTP. </p><br><p>  Compartir espacio en disco por LUN no es un capricho de DBA.  La base de datos tiene varios perfiles de carga de subsistema de disco diferentes.  Como m√≠nimo, se puede distinguir lo siguiente: </p><br><ul><li>  Trabajar con archivos de datos.  Por lo general, esto es leer y escribir con bloques aleatorios de 8/64 KiB.  Lecturas 80-95%.  Surgen colas: durante los per√≠odos de servicio, durante los per√≠odos de carga masiva, en solicitudes ineficientes o masivas, y durante el punto de control.  El rendimiento se ve afectado por la capacidad de respuesta a la lectura.  Es importante que la alineaci√≥n de los bloques KiB 8/64 "a trav√©s" pase por todo el sistema de almacenamiento. </li><li>  Trabajar con <code>tempdb</code> es lo mismo que trabajar con archivos de datos, pero las lecturas suelen ser del 40-75% y la capacidad de respuesta de escritura puede ser importante.  En los sistemas modernos de MS SQL, esta base de datos se puede cargar varias veces m√°s fuerte que las bases de datos.  En una configuraci√≥n DBMS no agrupada, esta secci√≥n debe excluirse de cualquier replicaci√≥n de almacenamiento.  Su contenido despu√©s de reiniciar el servicio seguir√° siendo destruido. </li><li>  Trabajar con datos archivados / DWH.  Las lecturas son cercanas al 100%.  El tama√±o de un bloque de lectura suele ser de 64 KiB.  Las solicitudes se leen mucho y seguidas, por lo que la cola puede saltar hasta 1000 o m√°s. </li><li>  Trabajar con registros de transacciones.  La lectura es solo para mantenimiento (copia de seguridad, replicaci√≥n, etc.), el rendimiento de la aplicaci√≥n solo se ve afectado por la escritura.  Grabaci√≥n en bloques de 0.5-64 KiB.  Sin cola, en un hilo.  El retraso es cr√≠tico para las aplicaciones. </li><li>  Copia de seguridad y restauraci√≥n.  Desde el punto de vista de la base de datos est√° leyendo en bloques grandes (a menudo 1 MiB).  Es importante que esta carga pueda descansar en los canales / buses (tanto FC como Ethernet) y el rendimiento de los procesadores de almacenamiento en algunos casos.  Hacer una copia de seguridad de un servidor puede afectar el rendimiento de otros servidores de la misma SAN / SHD. </li><li>  Trabaje con archivos de aplicaci√≥n: estos son registros, rastreo predeterminado, archivos binarios, etc.  Esta carga rara vez es significativa y es importante solo al comienzo del sistema. </li></ul><br><p>  Existen otros tipos de carga, pero son ligeramente ex√≥ticos (por ejemplo, puede haber un repositorio de archivos almacenados en la base de datos en forma del directorio FileStream).  Todos estos tipos de cargas tienen requisitos de disco diferentes, a menudo conflictivos.  Si todos est√°n apilados en una partici√≥n, no solo degrada el rendimiento, sino que es muy importante que pierda la capacidad de comprender por qu√© el sistema se ralentiza, y tambi√©n pierde la oportunidad de mejorar solo esa parte que necesita mejoras sin mejoras / actualizaciones globales de almacenamiento.  Por lo tanto, la recomendaci√≥n principal: </p><br><p> <strong>      ,   "   "        .        .</strong> </p><br><p>     </p><br><ul><li>    ,   .  Dell/EMC  SQL Server     . </li><li>    .      ""  (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> NUC c SSD,  , </a> ).    --,    . </li><li>      <strong></strong>     DBA,    -   ( 200   ). </li><li>        (etrolaster   ), ,     ,  .      +0,5 ,    0,2,     0,7     3 . </li><li>   ,          .      <code>tempdb</code>  , , ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RCSI</a>   12      . </li><li> Latency    throughput.         ,   " ",   .    throughput  latency,    .      . </li></ul><br><h3 id="ms-sql-server"> MS SQL Server </h3><br><p>    MS SQL,            bottleneck  ,  - : </p><br><ol><li>        .  Esto es correcto        . 1000          5-30      1000 <code>INSERT</code> . , , ,       ,      "  ‚Äî  ". </li><li>  <code>tempdb</code>   " ".    . ,     ,       . </li><li>     ,    BULK INSERT      .            ,      "Simple"  "Bulk logged". , ,         Simple/Bulk logged  Full  .         ‚Äî <a href="">The Data Loading Performance Guide</a> ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> .   (  ETL,   OLTP)       <a href="">We Loaded 1TB in 30 Minutes with SSIS, and So Can You</a> </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Delayed Transaction Durability</a> ‚Äî ,       . </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">In-Memory OLTP</a> .    ,        . </li><li> ,     ,   AlwaysOn . </li></ol><br><h2>  *** </h2><br><p>  Eso es todo   . 20000 IOPS  5  latency    4-16         OLTP.  OLTP    ,        . </p><br><div class="spoiler"> <b class="spoiler_title">PS:    SSD.</b> <div class="spoiler_text"><p>              .  Intel Optane.   SSD ""       4,       .            SSD, ,     ,      .    SSD  . ,      ""   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,    </a> .      Intel Optane:      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> )        1     20 .     ,  . SSD        100-300 .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     SSD. <br>  , .         OLTP "",  in-memory     ACID.     latency 20      "" .  low-latency        Optane ( <em>    ?</em> ). <br>          ( ) Optane. </p></div></div><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">eugeneb0</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">apatyukov</a>     . </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414269/">https://habr.com/ru/post/es414269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414255/index.html">Sue√±o patentado del programador - Parte II</a></li>
<li><a href="../es414261/index.html">¬øD√≥nde guardas los datos?</a></li>
<li><a href="../es414263/index.html">¬øHay vida fuera del Roscosmos? Descripci√≥n general de la exploraci√≥n espacial privada rusa</a></li>
<li><a href="../es414265/index.html">Richard Hamming: Cap√≠tulo 7. Inteligencia artificial - II</a></li>
<li><a href="../es414267/index.html">¬øC√≥mo reemplazar un contador con un robot?</a></li>
<li><a href="../es414271/index.html">C√≥mo domar un disco duro en una computadora port√°til y evitar el estacionamiento en 8 segundos de tiempo de inactividad</a></li>
<li><a href="../es414273/index.html">Lo que necesita saber antes de desarrollar un backtester para una estrategia comercial: problemas t√≠picos, tipos de sistemas y sus par√°metros</a></li>
<li><a href="../es414277/index.html">El hombre, su entorno e Internet de las cosas.</a></li>
<li><a href="../es414279/index.html">Votaci√≥n de informes en la octava reuni√≥n de bricolaje en Mail.Ru Group (07.07.2018)</a></li>
<li><a href="../es414281/index.html">Desarrollo de un veloc√≠metro de bicicleta basado en una pantalla de Nokia 3310</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>