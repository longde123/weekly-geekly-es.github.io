<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏾 👨‍🔬 👨🏼‍🤝‍👨🏻 WAL di PostgreSQL: 3. Pos pemeriksaan 🌆 👩🏽‍🤝‍👨🏻 🌭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah membiasakan diri dengan perangkat cache buffer , salah satu objek utama dalam memori bersama, dan menyadari bahwa untuk memulihkan dari keg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL di PostgreSQL: 3. Pos pemeriksaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/460423/">  Kami telah membiasakan diri dengan perangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cache buffer</a> , salah satu objek utama dalam memori bersama, dan menyadari bahwa untuk memulihkan dari kegagalan ketika konten RAM hilang, Anda perlu menyimpan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">log prarekam</a> . <br><br>  Masalah yang belum terselesaikan yang kami hentikan pada waktu terakhir adalah tidak diketahui pada titik mana Anda dapat mulai memutar log selama pemulihan.  Mulai dari awal, seperti yang disarankan Raja dari <em>Alice</em> , tidak akan berfungsi: tidak mungkin untuk menyimpan semua entri jurnal dari permulaan server - ini berpotensi jumlah yang besar, dan waktu pemulihan yang sangat besar yang sama.  Kami membutuhkan titik maju yang bertahap untuk memulai pemulihan (dan, karenanya, kami dapat menghapus semua entri jurnal sebelumnya dengan aman).  Ini adalah <em>titik kontrol</em> yang akan dibahas hari ini. <br><br><h1>  Titik kontrol </h1><br>  Properti apa yang harus dimiliki titik kontrol?  Kita harus yakin bahwa semua entri jurnal, mulai dari pos pemeriksaan, akan diterapkan ke halaman yang ditulis ke disk.  Jika tidak demikian, selama pemulihan kita bisa membaca dari disk versi yang terlalu lama dari halaman dan menerapkan entri jurnal untuk itu, dan dengan demikian secara permanen merusak data. <br><a name="habracut"></a><br>  Bagaimana cara mendapatkan breakpoint?  Opsi termudah adalah menangguhkan sistem secara berkala dan menyiram semua halaman kotor buffer dan cache lainnya ke disk.  (Perhatikan bahwa halaman hanya ditulis, tetapi tidak dikeluarkan dari cache.) Poin-poin seperti itu akan memenuhi syarat, tetapi, tentu saja, tidak ada yang mau bekerja dengan sistem yang terus membeku untuk waktu yang tidak terbatas, tetapi sangat signifikan. <br><br>  Oleh karena itu, dalam praktiknya, semuanya agak lebih rumit: titik kontrol dari titik berubah menjadi segmen.  Pertama kita <em>mulai</em> breakpoint.  Setelah itu, tanpa mengganggu pekerjaan dan, jika mungkin, tanpa membuat beban puncak, kami perlahan-lahan membuang buffer kotor pada disk. <br><br><img src="https://habrastorage.org/webt/n0/ch/6f/n0ch6fdrfxkylmuqjdar7idfxsw.png"><br><br>  Ketika semua buffer yang kotor <em>pada awal</em> pos pemeriksaan ditulis, pos pemeriksaan dianggap <em>lengkap</em> .  Sekarang (tetapi tidak lebih awal) kita dapat menggunakan titik <em>awal</em> sebagai titik dari mana Anda dapat memulai pemulihan.  Dan jurnal yang masuk hingga saat ini tidak lagi kita perlukan. <br><br><img src="https://habrastorage.org/webt/q4/th/83/q4th83seql63dkrgfmg7esu3zh8.png"><br><br>  Pos pemeriksaan ditangani oleh proses pos pemeriksaan latar belakang khusus. <br><br>  Durasi buffer kotor ditentukan oleh nilai parameter <em>checkpoint_completion_target</em> .  Ini menunjukkan berapa banyak waktu antara dua titik kontrol yang berdekatan rekaman akan berlangsung.  Nilai default adalah 0,5 (seperti pada gambar di atas), yaitu, rekaman membutuhkan setengah waktu antara titik kontrol.  Biasanya, nilainya ditingkatkan hingga 1,0 untuk keseragaman yang lebih besar. <br><br>  Mari kita pertimbangkan secara lebih rinci apa yang terjadi ketika titik kontrol dijalankan. <br><br>  Proses pos pemeriksaan pertama flushes buffer status transaksi (XACT) ke disk.  Karena ada beberapa dari mereka (total 128), mereka dicatat segera. <br><br>  Kemudian pekerjaan utama dimulai - menulis halaman kotor dari cache buffer.  Seperti yang sudah kami katakan, tidak mungkin untuk mengatur ulang semua halaman sekaligus, karena ukuran cache buffer bisa signifikan.  Oleh karena itu, pertama, semua halaman yang kotor ditandai dalam cache buffer di header dengan flag khusus. <br><br><img src="https://habrastorage.org/webt/_4/ym/eq/_4ymeqozl8o23kwq6su9ntvjujk.png"><br><br>  Dan kemudian proses pos pemeriksaan secara bertahap melewati semua buffer dan menyiram yang ditandai ke disk.  Ingat bahwa halaman tidak dikeluarkan dari cache, tetapi hanya ditulis ke disk, jadi Anda tidak perlu memperhatikan jumlah panggilan ke buffer atau untuk memperbaikinya. <br><br>  Buffer berlabel juga dapat ditulis oleh proses server - tergantung pada siapa yang mendapatkan buffer terlebih dahulu.  Bagaimanapun, flag yang ditetapkan sebelumnya dihapus saat merekam, jadi (untuk tujuan pos pemeriksaan) buffer akan ditulis hanya sekali. <br><br>  Secara alami, selama pelaksanaan pos pemeriksaan, halaman-halaman terus berubah dalam cache buffer.  Tetapi buffer kotor baru tidak ditandai dan proses pos pemeriksaan tidak boleh menulisnya. <br><br><img src="https://habrastorage.org/webt/fg/uo/vm/fguovmm8yzy0jb4jwisgg10nmm8.png"><br><br>  Di akhir pekerjaannya, proses menciptakan entri jurnal untuk akhir pos pemeriksaan.  Catatan ini berisi LSN dari awal pekerjaan titik kontrol.  Karena titik kontrol tidak menulis apa pun ke log di awal kerjanya, LSN ini dapat berisi catatan log apa pun. <br><br>  Selain itu, file $ PGDATA / global / pg_control memperbarui indikasi pos pemeriksaan terakhir yang <em>dilewati</em> .  Sebelum pos pemeriksaan selesai, pg_control menunjuk ke pos pemeriksaan sebelumnya. <br><br><img src="https://habrastorage.org/webt/w0/cy/gi/w0cygixp3k4k3qscwfa2nlapqna.png"><br><br>  Untuk melihat pekerjaan pos pemeriksaan, buat beberapa tabel - halamannya akan menuju ke cache buffer dan akan menjadi kotor: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre> <pre> <code class="plaintext hljs"> count ------- 78 (1 row)</code> </pre><br>  Ingat posisi saat ini di log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A048 (1 row)</code> </pre><br>  Sekarang kami akan menjalankan pos pemeriksaan secara manual dan memastikan bahwa tidak ada halaman kotor di cache (seperti yang kami katakan, halaman kotor baru dapat muncul, tetapi dalam kasus kami tidak ada perubahan dalam proses pelaksanaan pemeriksaan pos): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Mari kita lihat bagaimana pos pemeriksaan tercermin dalam log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A0E4 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A048 -e 0/3514A0E4</code> </pre><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/3514A048, prev 0/35149CEC, desc: RUNNING_XACTS nextXid 101105 latestCompletedXid 101104 oldestRunningXid 101105</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A07C, prev 0/3514A048, desc: CHECKPOINT_ONLINE redo 0/3514A048; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 101105; online</code> </pre><br>  Di sini kita melihat dua entri.  Yang terakhir adalah catatan melewati titik kontrol (CHECKPOINT_ONLINE).  LSN pada awal pos pemeriksaan ditunjukkan setelah kata redo, dan posisi ini sesuai dengan entri jurnal, yang merupakan yang terakhir pada awal pos pemeriksaan. <br><br>  Kami akan menemukan informasi yang sama di file kontrol: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | egrep 'Latest.*location'</code> </pre><pre> <code class="plaintext hljs">Latest checkpoint location: 0/3514A07C Latest checkpoint's REDO location: 0/3514A048</code> </pre><br><h1>  Pemulihan </h1><br>  Sekarang kami siap untuk mengklarifikasi algoritma pemulihan yang diuraikan dalam artikel sebelumnya. <br><br>  Jika server macet, saat berikutnya dimulai, proses startup mendeteksi ini dengan melihat file pg_control dan melihat status selain "mematikan".  Dalam hal ini, pemulihan otomatis dilakukan. <br><br>  Pertama, proses pemulihan akan membaca dari pg_control yang sama dengan posisi awal dari titik kontrol.  (Untuk kelengkapan, kami perhatikan bahwa jika file backup_label ada, maka catatan titik kontrol dibaca darinya - ini diperlukan untuk memulihkan dari cadangan, tetapi ini adalah topik untuk siklus terpisah.) <br><br>  Kemudian dia akan membaca majalah, mulai dari posisi yang ditemukan, secara berurutan menerapkan entri jurnal ke halaman (jika perlu, seperti yang kita bahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> ). <br><br>  Sebagai kesimpulan, semua tabel non-jurnal ditimpa menggunakan gambar dalam file init. <br><br>  Pada titik ini, proses startup berakhir, dan proses checkpointer segera mengeksekusi checkpoint untuk memperbaiki keadaan yang dipulihkan pada disk. <br><br>  Anda dapat mensimulasikan kegagalan dengan menghentikan server secara paksa dalam mode langsung. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop -m immediate --skip-systemctl-redirect</code> </pre><br>  ( <code>--skip-systemctl-redirect</code> diperlukan di sini karena menggunakan PostgreSQL yang diinstal di Ubuntu dari paket. Ia dikontrol oleh perintah pg_ctlcluster, yang sebenarnya memanggil systemctl, dan ia sudah memanggil pg_ctl. Dengan semua pembungkus ini, nama mode hilang di sepanjang jalan, dan <code>--skip-systemctl-redirect</code> memungkinkan Anda melakukannya tanpa systemctl dan menyimpan informasi penting.) <br><br>  Periksa status cluster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Saat startup, PostgreSQL memahami bahwa telah terjadi kegagalan dan diperlukan pemulihan. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:49.441 MSK [8865] LOG: database system was interrupted; last known up at 2019-07-17 15:27:48 MSK 2019-07-17 15:27:49.801 MSK [8865] LOG: database system was not properly shut down; automatic recovery in progress 2019-07-17 15:27:49.804 MSK [8865] LOG: redo starts at 0/3514A048 2019-07-17 15:27:49.804 MSK [8865] LOG: invalid record length at 0/3514A0E4: wanted 24, got 0 2019-07-17 15:27:49.804 MSK [8865] LOG: redo done at 0/3514A07C 2019-07-17 15:27:49.824 MSK [8864] LOG: database system is ready to accept connections 2019-07-17 15:27:50.409 MSK [8872] [unknown]@[unknown] LOG: incomplete startup packet</code> </pre><br>  Kebutuhan untuk pemulihan dicatat dalam log pesan: <em>sistem basis data tidak dimatikan dengan benar;</em>  <em>pemulihan otomatis sedang berlangsung</em> .  Kemudian, entri jurnal mulai diputar dari posisi yang ditandai "redo dimulai pada" dan lanjutkan hingga entri jurnal berikutnya dapat diambil.  Ini menyelesaikan pemulihan di posisi "redo done at" dan DBMS mulai bekerja dengan klien ( <em>sistem database siap menerima koneksi</em> ). <br><br>  Dan apa yang terjadi selama shutdown server normal?  Untuk membersihkan halaman yang kotor ke disk, PostgreSQL memutus semua klien dan kemudian menjalankan pos pemeriksaan terakhir. <br><br>  Ingat posisi saat ini di log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A14C (1 row)</code> </pre><br>  Sekarang hentikan server dengan lembut: <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br>  Periksa status cluster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: shut down</code> </pre><br>  Dan dalam log kami menemukan satu-satunya catatan tentang titik kontrol akhir (CHECKPOINT_SHUTDOWN): <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A14C</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A14C, prev 0/3514A0E4, desc: CHECKPOINT_SHUTDOWN redo 0/3514A14C; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</code> </pre><pre> <code class="plaintext hljs">pg_waldump: FATAL: error in WAL record at 0/3514A14C: invalid record length at 0/3514A1B4: wanted 24, got 0</code> </pre><br>  (Dalam pesan fatal yang mengerikan, pg_waldump hanya ingin mengatakan bahwa dia membaca sampai akhir majalah.) <br><br>  Jalankan instance lagi. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><h1>  Rekaman latar belakang </h1><br>  Seperti yang kami ketahui, pos pemeriksaan adalah salah satu proses yang menulis halaman kotor dari cache buffer ke disk.  Tapi bukan satu-satunya. <br><br>  Jika backend perlu mendorong halaman keluar dari buffer dan halaman itu kotor, ia harus menulisnya ke disk sendiri.  Ini adalah situasi yang buruk, mengarah ke harapan - itu jauh lebih baik ketika perekaman terjadi secara tidak sinkron di latar belakang. <br><br>  Oleh karena itu, selain <em>proses</em> pos pemeriksaan <em>,</em> ada juga <em>proses perekaman</em> latar belakang (penulis latar belakang, penulis naskah, atau penulis adil).  Proses ini menggunakan algoritma pencarian buffer yang sama dengan mekanisme preemption.  Pada dasarnya ada dua perbedaan. <br><br><ol><li>  Itu tidak menggunakan pointer ke "korban berikutnya", tetapi miliknya sendiri.  Dia bisa berada di depan pointer ke "korban", tetapi tidak pernah tertinggal di belakangnya. </li><li>  Saat melintasi buffer, penghitung hit tidak berkurang. </li></ol><br>  Buffer ditulis yang secara bersamaan: <br><br><ul><li>  mengandung data yang diubah (kotor), </li><li>  tidak diperbaiki (jumlah pin = 0), </li><li>  memiliki nol hit (jumlah penggunaan = 0). </li></ul><br>  Dengan demikian, proses perekaman latar belakang, seolah-olah, berjalan di depan crowding out dan menemukan buffer yang kemungkinan akan segera keluar.  Idealnya, karena ini, proses layanan harus menemukan bahwa buffer yang mereka pilih dapat digunakan tanpa berhenti menulis. <br><br><h1>  Kustomisasi </h1><br>  <em>Proses pos pemeriksaan</em> biasanya dikonfigurasi untuk alasan berikut. <br><br>  Pertama, Anda perlu memutuskan berapa banyak file log yang dapat kami simpan (dan waktu pemulihan apa yang cocok untuk kami).  Semakin besar, semakin baik, tetapi karena alasan yang jelas nilai ini akan terbatas. <br><br>  Selanjutnya, kita dapat menghitung berapa lama volume ini akan dihasilkan di bawah beban normal.  Kami telah mempertimbangkan bagaimana melakukan ini (kita perlu mengingat posisi dalam jurnal dan mengurangi satu dari yang lain). <br><br>  Waktu ini akan menjadi interval kami yang biasa di antara titik kontrol.  Kami menulisnya di parameter <em>checkpoint_timeout</em> .  Nilai default 5 menit jelas terlalu kecil, biasanya waktunya meningkat, katakanlah, setengah jam.  Saya ulangi: semakin jarang Anda mampu membayar tonggak, semakin baik - ini mengurangi biaya overhead. <br><br>  Namun, ada kemungkinan (dan bahkan kemungkinan) bahwa kadang-kadang beban akan lebih tinggi dari biasanya, dan terlalu banyak entri jurnal akan dihasilkan pada waktu yang ditentukan dalam parameter.  Dalam hal ini, saya ingin melakukan titik kontrol lebih sering.  Untuk melakukan ini, dalam parameter <em>max_wal_size</em> kami menentukan jumlah yang valid dalam titik kontrol yang sama.  Jika volume aktual diperoleh lebih banyak, server memulai pos pemeriksaan yang tidak terjadwal. <br><br>  Dengan demikian, sebagian besar titik kontrol terjadi pada jadwal: satu kali per unit waktu <em>checkpoint_timeout</em> .  Tetapi dengan peningkatan beban, titik kontrol dipanggil lebih sering ketika volume <em>max_wal_size tercapai</em> . <br><br>  Penting untuk dipahami bahwa parameter <em>max_wal_size sama</em> sekali tidak menentukan jumlah maksimum yang dapat ditempati file log pada disk. <br><br><ul><li>  Untuk memulihkan dari kegagalan, Anda perlu menyimpan file dari saat pos pemeriksaan terakhir dilewati, ditambah file yang terakumulasi selama pengoperasian pos pemeriksaan saat ini.  Oleh karena itu, total volume dapat diperkirakan secara kasar sebagai <br>  (1 + <em>checkpoint_completion_target</em> ) × <em>max_wal_size</em> . </li><li>  Sebelum versi 11, PostgreSQL juga menyimpan file untuk pos pemeriksaan dua tahun, jadi hingga versi 10 dalam rumus di atas, Anda harus menetapkan 2 bukannya 1. </li><li>  Parameter <em>max_wal_size</em> hanya harapan, tetapi bukan batas keras.  Itu mungkin berubah lebih. </li><li>  Server tidak memiliki hak untuk menghapus file log yang belum ditransfer melalui slot replikasi dan yang belum diarsipkan selama pengarsipan terus menerus.  Jika fungsi ini digunakan, pemantauan konstan diperlukan, karena mudah meluap memori server. </li></ul><br>  Untuk melengkapi gambar, Anda dapat mengatur tidak hanya volume maksimum, tetapi juga minimum: parameter <em>min_wal_size</em> .  Arti pengaturan ini adalah bahwa server tidak menghapus file saat mereka masuk volume ke dalam <em>min_wal_size</em> , tetapi cukup <em>mengubah</em> nama mereka dan menggunakannya lagi.  Ini menghemat sedikit dengan terus-menerus membuat dan menghapus file. <br><br>  <em>Proses perekaman latar belakang</em> masuk akal untuk dikonfigurasikan setelah pos pemeriksaan dikonfigurasi.  Bersama-sama, proses ini harus memiliki waktu untuk menulis buffer kotor sebelum mereka diperlukan oleh proses pemeliharaan. <br><br>  Proses perekaman latar belakang berjalan dalam siklus paling <em>banyak</em> halaman <em>bgwriter_lru_maxpages</em> , tertidur di antara siklus pada <em>bgwriter_delay</em> . <br><br>  Jumlah halaman yang akan dicatat dalam satu siklus kerja ditentukan oleh jumlah rata-rata buffer yang diminta oleh proses servis dari putaran terakhir (menggunakan rata-rata bergerak untuk memuluskan ketidakrataan antar putaran, tetapi tidak tergantung pada sejarah yang panjang).  Jumlah buffer yang dihitung dikalikan dengan koefisien <em>bgwriter_lru_multiplier</em> (tetapi dalam hal apa pun itu tidak akan melebihi <em>bgwriter_lru_maxpages</em> ). <br><br>  Nilai default: <em>bgwriter_delay</em> = 200ms (kemungkinan besar terlalu banyak, <em>kebocoran</em> banyak air dalam 1/5 detik), <em>bgwriter_lru_maxpages</em> = 100, <em>bgwriter_lru_multiplier</em> = 2.0 (kami mencoba menanggapi permintaan lebih cepat dari jadwal). <br><br>  Jika proses tidak mendeteksi buffer kotor sama sekali (yaitu, tidak ada yang terjadi dalam sistem), itu "hibernate" dari mana itu menyimpulkan bahwa proses server mengakses buffer.  Setelah itu, proses bangun dan kembali berfungsi dengan cara biasa. <br><br><h1>  Pemantauan </h1><br>  Pengaturan titik kontrol dan latar belakang dapat dan harus disesuaikan, menerima umpan balik dari pemantauan. <br><br>  Parameter <em>checkpoint_warning</em> menampilkan peringatan jika checkpoint yang disebabkan oleh luberan ukuran file log terlalu sering dijalankan.  Nilai default-nya adalah 30 detik, dan harus sesuai dengan nilai <em>checkpoint_timeout</em> . <br><br>  Parameter <em>log_checkpoints</em> (dinonaktifkan secara default) memungkinkan menerima informasi tentang pos pemeriksaan yang dieksekusi di log pesan server.  Hidupkan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_checkpoints = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Sekarang ubah sesuatu dalam data dan jalankan pos pemeriksaan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> n = n + <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>;</code> </pre><br>  Di log pesan, kita akan melihat sesuatu seperti ini: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 2 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:55.248 MSK [8962] LOG: checkpoint starting: immediate force wait 2019-07-17 15:27:55.274 MSK [8962] LOG: checkpoint complete: wrote 79 buffers (0.5%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.013 s, total=0.025 s; sync files=2, longest=0.011 s, average=0.006 s; distance=1645 kB, estimate=1645 kB</code> </pre><br>  Di sini Anda dapat melihat berapa banyak buffer yang ditulis, bagaimana komposisi file log berubah setelah titik kontrol, berapa lama titik kontrol dan jarak (dalam byte) antara titik kontrol yang berdekatan. <br><br>  Tapi, mungkin, informasi yang paling berguna adalah statistik pekerjaan pos pemeriksaan dan proses perekaman latar belakang dalam tampilan pg_stat_bgwriter.  Tampilan adalah satu untuk dua, karena begitu kedua tugas dilakukan oleh satu proses;  lalu fungsinya dibagi, dan pandangan tetap ada. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_bgwriter \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------+------------------------------ checkpoints_timed | 0 checkpoints_req | 1 checkpoint_write_time | 1 checkpoint_sync_time | 13 buffers_checkpoint | 79 buffers_clean | 0 maxwritten_clean | 0 buffers_backend | 42 buffers_backend_fsync | 0 buffers_alloc | 363 stats_reset | 2019-07-17 15:27:49.826414+03</code> </pre><br>  Di sini, antara lain, kami melihat jumlah titik kontrol selesai: <br><br><ul><li>  checkpoints_timed - sesuai dengan jadwal (setelah mencapai checkpoint_timeout), </li><li>  checkpoints_req - sesuai permintaan (termasuk saat mencapai max_wal_size). </li></ul><br>  Nilai checkpoint_req yang besar (dibandingkan dengan checkpoints_timed) menunjukkan bahwa titik kontrol terjadi lebih sering daripada yang diharapkan. <br><br>  Informasi penting tentang jumlah halaman yang direkam: <br><br><ul><li>  buffers_checkpoint - proses pemeriksaan, </li><li>  buffers_backend - dengan melayani proses, </li><li>  buffers_clean - proses perekaman latar belakang. </li></ul><br>  Pada sistem yang disetel dengan baik, nilai buffers_backend harus secara substansial kurang dari jumlah buffers_checkpoint dan buffers_clean. <br><br>  Juga, maxwritten_clean berguna untuk mengatur perekaman latar belakang - angka ini menunjukkan berapa kali proses perekaman latar belakang berhenti bekerja karena melebihi <em>bgwriter_lru_maxpages</em> . <br><br>  Anda dapat mengatur ulang akumulasi statistik menggunakan panggilan berikut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_stat_reset_shared(<span class="hljs-string"><span class="hljs-string">'bgwriter'</span></span>);</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460423/">https://habr.com/ru/post/id460423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460411/index.html">GIF'ok Konverter Gila ke stiker animasi untuk Telegram</a></li>
<li><a href="../id460413/index.html">7 situs dan aplikasi yang berguna untuk belajar bahasa Inggris</a></li>
<li><a href="../id460415/index.html">Apple Watch 4 (44 mm, 2019) vs Pebble Steel Classic (2014)</a></li>
<li><a href="../id460419/index.html">Pemulihan panas gas buang: ramah lingkungan</a></li>
<li><a href="../id460421/index.html">Saklar Optik TP-Link T2600G-28SQ untuk Penyedia Layanan: Ulasan Lengkap</a></li>
<li><a href="../id460425/index.html">Dingin infernal, pengangkatan dan plasma: masa lalu, sekarang dan masa depan superkonduktivitas</a></li>
<li><a href="../id460431/index.html">Membangun pipa pengujian otomatis di Azure DevOps</a></li>
<li><a href="../id460433/index.html">Risiko dan ancaman di Internet hal</a></li>
<li><a href="../id460435/index.html">Petty little joy # 8: kesenangan kecil untuk bekerja dengan database</a></li>
<li><a href="../id460437/index.html">Bagaimana kami mengeluarkan sepeda dukungan teknis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>