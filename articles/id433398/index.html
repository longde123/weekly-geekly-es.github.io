<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ»â€âœˆï¸ ğŸŒ€ ğŸ‘ Pemikiran fungsional. Bagian 7 ğŸ§šğŸ¾ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami melanjutkan serangkaian artikel tentang pemrograman fungsional dalam F #. Hari ini kami memiliki topik yang sangat menarik: definisi fungsi. Term...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemikiran fungsional. Bagian 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Kami melanjutkan serangkaian artikel tentang pemrograman fungsional dalam F #.  Hari ini kami memiliki topik yang sangat menarik: definisi fungsi.  Termasuk, mari kita bicara tentang fungsi anonim, fungsi tanpa parameter, fungsi rekursif, kombinator, dan banyak lagi.  Lihat di bawah kucing! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketiga</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keempat</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kelima</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keenam</a></strong> <a name="habracut"></a></li></ul><br><h1>  Definisi Fungsi </h1><br><p>  Kami sudah tahu cara membuat fungsi biasa menggunakan sintaks "let": </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Pada artikel ini, kita akan melihat beberapa cara lain untuk membuat fungsi, serta tips untuk mendefinisikannya. </p><br><h2>  Fungsi anonim (lambdas) </h2><br><p>  Jika Anda terbiasa dengan lambdas dalam bahasa lain, paragraf berikut akan tampak familier.  Fungsi anonim (atau "ekspresi lambda") didefinisikan sebagai berikut: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  Dibandingkan dengan lambdas dari C #, ada dua perbedaan: </p><br><ul><li>  lambdas harus dimulai dengan kata kunci yang <code>fun</code> , yang tidak diperlukan dalam C # </li><li>  panah tunggal digunakan <code>-&gt;</code> , bukannya double <code>=&gt;</code> dari C #. </li></ul><br><p>  Definisi fungsi penambahan Lambda: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  Fungsi yang sama dalam bentuk tradisional: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Lambdas sering digunakan dalam bentuk ekspresi kecil atau ketika tidak ada keinginan untuk mendefinisikan fungsi terpisah untuk ekspresi.  Seperti yang telah Anda lihat, ketika bekerja dengan daftar ini tidak jarang. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Perhatikan bahwa tanda kurung harus digunakan di sekitar lambdas. </p><br><p>  Lambdas juga digunakan ketika fungsi yang jelas berbeda diperlukan.  Misalnya, " <code>adderGenerator</code> " yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibahas sebelumnya,</a> yang telah kita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahas sebelumnya,</a> dapat ditulis ulang menggunakan lambdas. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  Versi lambda sedikit lebih lama, tetapi segera menjelaskan bahwa fungsi peralihan akan dikembalikan. </p><br><p>  Lambdas bisa disarangkan.  Contoh lain dari definisi <code>adderGenerator</code> , kali ini hanya pada lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Apakah Anda jelas bahwa ketiga definisi itu setara? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Jika tidak, baca kembali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab tentang kari</a> .  Ini sangat penting untuk dipahami! </p><br><h2>  Pencocokan pola </h2><br><p>  Ketika suatu fungsi didefinisikan, dimungkinkan untuk mengirimkan parameter secara eksplisit, seperti pada contoh di atas, tetapi juga dimungkinkan untuk membandingkan dengan templat secara langsung di bagian parameter.  Dengan kata lain, bagian parameter dapat berisi pola (pola yang cocok), dan bukan hanya pengidentifikasi! </p><br><p>  Contoh berikut menunjukkan penggunaan pola dalam definisi fungsi: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Jenis perbandingan ini hanya dapat terjadi ketika korespondensi selalu dapat ditentukan.  Misalnya, Anda tidak dapat mencocokkan jenis dan daftar serikat dengan cara ini, karena beberapa kasus tidak dapat dicocokkan. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  Kompiler akan memberikan peringatan tentang pencocokan yang tidak lengkap (daftar kosong akan menyebabkan kesalahan dalam runtime di pintu masuk ke fungsi ini). </p><br><h2>  Kesalahan umum: tuple vs.  banyak parameter </h2><br><p>  Jika Anda berasal dari bahasa mirip-C, tupel yang digunakan sebagai satu-satunya argumen fungsi dapat menyerupai fungsi multi-parameter.  Tapi ini bukan hal yang sama!  Seperti yang saya catat sebelumnya, jika Anda melihat koma, kemungkinan besar ini adalah tuple.  Parameter dipisahkan oleh spasi. </p><br><p>  Contoh kebingungan: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  Definisi pertama, " <code>addTwoParams</code> ", mengambil dua parameter, dipisahkan oleh spasi. </li><li>  Definisi kedua, " <code>addTuple</code> ", mengambil satu parameter.  Parameter ini mengikat "x" dan "y" dari tuple dan menjumlahkannya. </li><li>  Definisi ketiga, " <code>addConfusingTuple</code> ", mengambil satu parameter seperti " <code>addTuple</code> ", tetapi triknya adalah bahwa tuple ini dibongkar (dicocokkan dengan pola) dan terikat sebagai bagian dari definisi parameter menggunakan pencocokan pola.  Di belakang layar, semuanya terjadi persis sama seperti di <code>addTuple</code> . </li></ul><br><p>  Mari kita lihat tanda tangan (selalu lihat jika Anda tidak yakin tentang sesuatu). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  Dan sekarang di sini: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Di sini kita melihat kesalahan dalam panggilan kedua. </p><br><p>  Pertama, kompilator memperlakukan <code>(1,2)</code> sebagai tuple umum dari formulir <code>('a * 'b)</code> , yang dicoba untuk diteruskan sebagai parameter pertama yang <code>addTwoParams</code> .  Setelah itu ia mengeluh bahwa parameter <code>addTwoParams</code> diharapkan pertama tidak <code>int</code> , tetapi upaya dilakukan untuk melewatkan sebuah tuple. </p><br><p>  Untuk membuat tuple, gunakan koma! </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  Dan sebaliknya, jika Anda melewati beberapa argumen ke fungsi menunggu tuple, Anda juga mendapatkan kesalahan yang tidak bisa dimengerti. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Kali ini, kompiler memutuskan bahwa setelah dua argumen <code>addConfusingTuple</code> , <code>addConfusingTuple</code> harus <code>addConfusingTuple</code> .  Dan entri " <code>addConfusingTuple 1</code> " adalah aplikasi parsial dan harus mengembalikan fungsi perantara.  Mencoba memanggil fungsi perantara ini dengan parameter "2" akan menimbulkan kesalahan, karena  tidak ada fungsi antara!  Kami melihat kesalahan yang sama seperti pada bab tentang currying, di mana kami membahas masalah dengan terlalu banyak parameter. </p><br><h3>  Mengapa tidak menggunakan tupel sebagai parameter? </h3><br><p>  Diskusi tupel di atas menunjukkan cara lain untuk mendefinisikan fungsi dengan banyak parameter: alih-alih melewatinya secara terpisah, semua parameter dapat dirakit menjadi satu struktur.  Dalam contoh di bawah ini, fungsi tersebut mengambil parameter tunggal - tupel dari tiga elemen. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Perlu dicatat bahwa tanda tangan berbeda dari tanda tangan suatu fungsi dengan tiga parameter.  Hanya ada satu panah, satu parameter dan tanda bintang yang menunjuk ke tuple <code>(int*int*int)</code> . </p><br><p>  Kapan perlu mengirimkan argumen dengan parameter terpisah, dan kapan tuple? </p><br><ul><li>  Ketika tuple signifikan dalam diri mereka sendiri.  Misalnya, untuk operasi dalam ruang tiga dimensi, triple tuple akan lebih nyaman daripada tiga koordinat secara terpisah. </li><li>  Terkadang tupel digunakan untuk menggabungkan data yang harus disimpan bersama menjadi satu struktur.  Misalnya, metode <code>TryParse</code> dari perpustakaan .NET mengembalikan hasil dan variabel Boolean sebagai tupel.  Tetapi untuk menyimpan sejumlah besar data terkait, lebih baik untuk menentukan kelas atau catatan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan</a> . </li></ul><br><h3>  Kasus Khusus: Tuple dan Fungsi .NET Library </h3><br><p>  Saat memanggil perpustakaan .NET, koma sangat umum! </p><br><p>  Mereka semua menerima tupel, dan panggilannya terlihat sama seperti di C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  Alasannya adalah bahwa fungsi .NET klasik tidak kari dan tidak dapat diterapkan sebagian.  <em>Semua</em> parameter harus <em>selalu</em> ditransmisikan segera, dan cara yang paling jelas adalah menggunakan tuple. </p><br><p>  Perhatikan bahwa panggilan ini hanya terlihat seperti mentransfer tupel, tetapi ini sebenarnya adalah kasus khusus.  Anda tidak dapat memasukkan tupel asli ke fungsi-fungsi tersebut: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Jika Anda ingin menerapkan sebagian fungsi .NET, cukup tulis pembungkus di atasnya, seperti yang dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> , atau seperti yang ditunjukkan di bawah ini: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Panduan untuk Memilih Parameter Individual dan Kelompok </h2><br><p>  Diskusi tentang tupel mengarah ke topik yang lebih umum: kapan parameter harus terpisah, dan kapan dikelompokkan? </p><br><p>  Anda harus memperhatikan bagaimana F # berbeda dari C # dalam hal ini.  Di C #, <em>semua</em> parameter <em>selalu</em> dilewati, jadi pertanyaan ini bahkan tidak muncul di sana!  Karena aplikasi parsial dalam F #, hanya beberapa parameter yang dapat diwakili, sehingga perlu untuk membedakan antara kasus ketika parameter harus dikombinasikan dan kasus ketika mereka independen. </p><br><p>  Rekomendasi umum tentang cara menyusun parameter saat merancang fungsi Anda sendiri. </p><br><ul><li>  Dalam kasus umum, selalu lebih baik menggunakan parameter terpisah daripada melewati satu struktur, baik itu tupel atau catatan.  Ini memungkinkan perilaku yang lebih fleksibel, seperti aplikasi parsial. </li><li>  Tetapi, ketika sekelompok parameter <em>perlu</em> dilewati pada suatu waktu, semacam mekanisme pengelompokan harus digunakan. </li></ul><br><p>  Dengan kata lain, ketika mengembangkan suatu fungsi, tanyakan pada diri Anda, "Bisakah saya memberikan parameter ini secara terpisah?"  Jika jawabannya tidak, maka parameter harus dikelompokkan. </p><br><p>  Mari kita lihat beberapa contoh: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Akhirnya, pastikan bahwa urutan parameter membantu aplikasi parsial (lihat manual di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Misalnya, mengapa saya meletakkan <code>myCredentials</code> depan nama di fungsi terakhir? </p><br><h2>  Fungsi tanpa parameter </h2><br><p>  Terkadang Anda mungkin memerlukan fungsi yang tidak menerima parameter apa pun.  Misalnya, Anda memerlukan fungsi "hello world" yang dapat dipanggil beberapa kali.  Seperti yang ditunjukkan pada bagian sebelumnya, definisi naif tidak berfungsi. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Tapi ini bisa diperbaiki dengan menambahkan parameter unit ke fungsi atau menggunakan lambda. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Setelah itu, fungsi harus selalu dipanggil dengan argumen <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  Apa yang terjadi cukup sering ketika berinteraksi dengan .NET libraries: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Ingat, panggil mereka dengan parameter <code>unit</code> ! </p><br><h2>  Menentukan operator baru </h2><br><p>  Anda dapat menetapkan fungsi menggunakan satu atau beberapa karakter operator (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> untuk daftar karakter): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Anda harus menggunakan tanda kurung di sekitar karakter untuk menentukan fungsi. </p><br><p>  Operator mulai dengan <code>*</code> memerlukan ruang antara tanda kurung dan <code>*</code> , karena  di F # <code>(*</code> bertindak sebagai awal komentar (seperti <code>/*...*/</code> dalam C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Setelah ditentukan, fungsi baru dapat digunakan dengan cara biasa jika dibungkus dengan tanda kurung: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Jika fungsi ini digunakan dengan dua parameter, Anda dapat menggunakan catatan operator infiks tanpa tanda kurung. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  Anda juga dapat menentukan operator awalan dimulai dengan <code>!</code>  atau <code>~</code> (dengan beberapa batasan, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  Dalam F #, mendefinisikan pernyataan adalah operasi yang cukup umum, dan banyak perpustakaan akan mengekspor pernyataan dengan nama seperti <code>&gt;=&gt;</code> dan <code>&lt;*&gt;</code> . </p><br><h2>  Gaya bebas poin </h2><br><p>  Kami telah melihat banyak contoh fungsi yang tidak memiliki parameter terbaru untuk mengurangi tingkat kekacauan.  Gaya ini disebut gaya <strong>point-free</strong> atau <strong>pemrograman diam</strong> - <strong>diam</strong> . </p><br><p>  Berikut ini beberapa contohnya: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Gaya ini memiliki pro dan kontra. </p><br><p>  Salah satu kelebihannya adalah bahwa penekanannya adalah pada komposisi fungsi tingkat tinggi alih-alih sibuk dengan objek tingkat rendah.  Misalnya, " <code>(+) 1 &gt;&gt; (*) 2</code> " adalah tambahan eksplisit diikuti oleh perkalian.  Dan " <code>List.reduce (+)</code> " memperjelas bahwa operasi penambahan itu penting, terlepas dari informasi daftar. </p><br><p>  Gaya pointless memungkinkan Anda untuk fokus pada algoritma dasar dan mengidentifikasi fitur-fitur umum dalam kode.  Fungsi " <code>reduce</code> " yang digunakan di atas adalah contoh yang bagus.  Topik ini akan dibahas dalam seri yang direncanakan tentang pemrosesan daftar. </p><br><p>  Di sisi lain, penggunaan berlebihan gaya seperti itu dapat membuat kode tidak jelas.  Parameter eksplisit bertindak sebagai dokumentasi dan namanya (seperti "daftar") membuatnya lebih mudah untuk memahami apa fungsinya. </p><br><p>  Seperti segala sesuatu dalam pemrograman, rekomendasi terbaik adalah memilih pendekatan yang memberikan kejelasan paling. </p><br><h2>  Combinators </h2><br><p>  " <strong>Combinators</strong> " disebut fungsi yang hasilnya hanya bergantung pada parameternya.  Ini berarti bahwa tidak ada ketergantungan pada dunia luar, dan, khususnya, tidak ada fungsi lain atau nilai global yang dapat memengaruhi mereka. </p><br><p>  Dalam praktiknya, ini berarti bahwa fungsi kombinatorial dibatasi oleh kombinasi parameternya dengan berbagai cara. </p><br><p>  Kami telah melihat beberapa combinator: pipa dan operator komposisi.  Jika Anda melihat definisi mereka, maka jelas bahwa semua yang mereka lakukan adalah menyusun ulang parameter dengan berbagai cara. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  Di sisi lain, fungsi-fungsi seperti "printf", meskipun primitif, bukan kombinator karena mereka bergantung pada dunia luar (I / O). </p><br><h3>  Burung kombinasi </h3><br><p>  Combinator adalah dasar dari seluruh bagian logika (secara alami disebut "logika kombinatorial"), yang diciptakan bertahun-tahun sebelum komputer dan bahasa pemrograman.  Logika kombinatorial memiliki pengaruh yang sangat besar pada pemrograman fungsional. </p><br><p>  Untuk mempelajari lebih lanjut tentang kombinator dan logika kombinatorial, saya merekomendasikan buku Raymond Smullyan "To Mock a Mockingbird."  Di dalamnya, ia menjelaskan kombinator lain dan dengan fasih memberi mereka <a href="">nama burung</a> .  Berikut adalah beberapa contoh combinator standar dan nama burung mereka: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Nama hurufnya cukup standar, sehingga Anda bisa merujuk pada K-combinator kepada siapa saja yang akrab dengan terminologi ini. </p><br><p>  Ternyata banyak pola pemrograman umum dapat direpresentasikan melalui kombinator standar ini.  Misalnya, Kestrel adalah pola reguler di antarmuka yang lancar di mana Anda melakukan sesuatu tetapi mengembalikan objek asli.  Thrush adalah pipa, Queer adalah komposisi langsung, dan Y-combinator melakukan pekerjaan yang sangat baik untuk menciptakan fungsi rekursif. </p><br><p>  Bahkan, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teorema terkenal</a> bahwa fungsi yang dapat dihitung dapat dibangun hanya dengan menggunakan dua combinator dasar, Kestrel dan Starling. </p><br><h3>  Perpustakaan Kombinatorial </h3><br><p>  Pustaka kombinatorial adalah pustaka yang mengekspor banyak fungsi kombinatorial yang dirancang untuk dibagikan.  Pengguna perpustakaan seperti itu dapat dengan mudah menggabungkan fungsi bersama untuk mendapatkan fungsi yang lebih besar dan lebih kompleks, seperti kubus dengan mudah. </p><br><p>  Perpustakaan combiner yang dirancang dengan baik memungkinkan Anda untuk fokus pada fungsi tingkat tinggi, dan menyembunyikan "noise" tingkat rendah.  Kami telah melihat kekuatan mereka dalam beberapa contoh dalam seri "mengapa menggunakan F #", dan modul <code>List</code> penuh dengan fungsi-fungsi seperti itu, " <code>fold</code> " dan " <code>map</code> " juga merupakan kombinator jika Anda memikirkannya. </p><br><p>  Keuntungan lain dari combinator adalah mereka adalah jenis fungsi yang paling aman.  Karena  mereka tidak memiliki ketergantungan pada dunia luar, mereka tidak dapat berubah ketika lingkungan global berubah.  Fungsi yang membaca nilai global atau menggunakan fungsi pustaka dapat memecah atau mengubah antara panggilan jika konteksnya berubah.  Ini tidak akan pernah terjadi pada kombinator. </p><br><p>  Di F #, pustaka kombinator tersedia untuk parsing (FParsec), membuat HTML, kerangka kerja pengujian, dll.  Kami akan membahas dan menggunakan kombinator nanti di seri berikutnya. </p><br><h2>  Fungsi rekursif </h2><br><p>  Seringkali suatu fungsi perlu merujuk dirinya sendiri dari tubuhnya.  Contoh klasik adalah fungsi Fibonacci. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Sayangnya, fungsi ini tidak dapat dikompilasi: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Anda harus memberi tahu kompiler bahwa ini adalah fungsi rekursif menggunakan kata kunci <code>rec</code> . </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Fungsi rekursif dan struktur data sangat umum dalam pemrograman fungsional, dan saya berharap untuk mencurahkan seluruh seri untuk topik ini nanti. </p><br><h1>  Sumber Daya Tambahan </h1><br><p>  Ada banyak tutorial untuk F #, termasuk materi untuk mereka yang datang dengan pengalaman C # atau Java.  Tautan berikut mungkin berguna saat Anda masuk lebih dalam ke F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # untuk Kesenangan dan Keuntungan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belajar X dalam Y Menit: F #</a> </li></ul><br><p>  Beberapa cara lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk mulai belajar F #</a> juga dijelaskan. </p><br><p>  Akhirnya, komunitas F # sangat ramah pemula.  Ada obrolan yang sangat aktif di Slack, didukung oleh F # Software Foundation, dengan kamar pemula yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabung dengan bebas</a> .  Kami sangat menyarankan Anda melakukan ini! </p><br><p>  Jangan lupa untuk mengunjungi situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas berbahasa Rusia F #</a> !  Jika Anda memiliki pertanyaan tentang belajar bahasa, dengan senang hati kami akan membahasnya di ruang obrolan: </p><br><ul><li>  kamar <code>#ru_general</code> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol di Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol dalam gitter</a> </li><li>  kamar #en_general di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li></ul><br><h2>  Tentang penulis terjemahan </h2><br><p>  Diterjemahkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Perubahan terjemahan dan editorial dilakukan oleh upaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas pengembang F # berbahasa Rusia</a> .  Kami juga berterima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@schvepsss</em></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@shwars</em></a> karena telah menyiapkan artikel ini untuk dipublikasikan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433398/">https://habr.com/ru/post/id433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433386/index.html">Cara menggunakan visi komputer untuk menilai kondisi mobil. Pengalaman Yandex.Taxi</a></li>
<li><a href="../id433388/index.html">Penggemar formula atau mengapa kami bermain game</a></li>
<li><a href="../id433390/index.html">Yandex bergabung dengan perlindungan Linux dan industri TI dari trolling paten</a></li>
<li><a href="../id433392/index.html">Ulasan Telepon IP Snom D725</a></li>
<li><a href="../id433396/index.html">Frontend 2018: hasil tahun ini</a></li>
<li><a href="../id433400/index.html">React Tutorial Bagian 2: Komponen Fungsional</a></li>
<li><a href="../id433402/index.html">Pemikiran fungsional. Bagian 8</a></li>
<li><a href="../id433404/index.html">Bereaksi Tutorial Bagian 3: File Komponen, Struktur Proyek</a></li>
<li><a href="../id433406/index.html">Pemikiran fungsional. Bagian 9</a></li>
<li><a href="../id433408/index.html">Penanganan memori yang efisien di Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>