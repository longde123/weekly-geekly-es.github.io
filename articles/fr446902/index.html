<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👚 🌳 🐁 Ce que vous devez savoir sur les tableaux JavaScript 👦🏿 👨🏼‍💼 👨🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous vous présentons une traduction d'un article de Thomas Lombart, qui a été publié sur medium.freecodecamp.org. La traduction est publiée avec la pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ce que vous devez savoir sur les tableaux JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/446902/">  Nous vous présentons une traduction d'un article de Thomas Lombart, qui a été publié sur medium.freecodecamp.org.  La traduction est publiée avec la permission de l'auteur. <br><br><img src="https://habrastorage.org/webt/sm/gs/6k/smgs6kbtqkaxsoz79qtt2on6m5c.png"><br>  <i>Un exemple d'utilisation de la méthode de réduction pour réduire un tableau</i> <br><br>  Permettez-moi de faire une déclaration audacieuse: les boucles sont souvent inutiles et rendent le code difficile à lire.  Pour les itérations dans les tableaux, la recherche, le tri des éléments et d'autres actions similaires, vous pouvez utiliser l'une des méthodes ci-dessous. <br><br>  Malgré leur efficacité, la plupart de ces méthodes sont encore peu connues et peu populaires.  Je ferai le travail dur pour vous et parlerai des plus utiles.  Lisez cet article comme guide des méthodes de tableau JavaScript. <a name="habracut"></a><br><br>  <b>Remarque</b> : Avant de commencer, vous devez savoir une chose: je suis partisan de la programmation fonctionnelle.  Pour éviter les effets secondaires, je m'efforce d'appliquer des méthodes qui ne modifient pas directement le tableau d'origine.  Je ne vous dis pas de refuser de changer le tableau du tout, mais il vaut la peine de considérer que certaines méthodes y mènent.  En conséquence, des effets secondaires, des modifications indésirables et, par conséquent, des bogues apparaissent. <br><br>  Cet article a été initialement publié sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thomlom.dev</a> , où vous pouvez trouver plus de matériel de développement Web. <br><br><h3>  Les bases </h3><br>  Il existe quatre méthodes à savoir si vous travaillez avec des tableaux.  Ce sont la <code>map</code> , le <code>filter</code> , la <code>reduce</code> et l'opérateur de <code>spread</code> .  Ils sont efficaces et utiles. <br><br>  <b>carte</b> <br>  Vous utiliserez souvent la méthode de la <code>map</code> .  En général, chaque fois que vous devez modifier les éléments d'un tableau, envisagez cette option. <br><br>  Il prend un paramètre - une fonction qui est appelée sur chaque élément du tableau, puis retourne un <b>nouveau tableau</b> afin qu'il n'y ait pas d'effets secondaires. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersPlusOne = numbers.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersPlusOne) <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4, 5]</span></span></code> </pre> <br>  Vous pouvez également créer un nouveau tableau qui stocke une seule propriété spécifique de l'objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allActivities = [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'My activity'</span></span>, <span class="hljs-attr"><span class="hljs-attr">coordinates</span></span>: [<span class="hljs-number"><span class="hljs-number">50.123</span></span>, <span class="hljs-number"><span class="hljs-number">3.291</span></span>] }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Another activity'</span></span>, <span class="hljs-attr"><span class="hljs-attr">coordinates</span></span>: [<span class="hljs-number"><span class="hljs-number">1.238</span></span>, <span class="hljs-number"><span class="hljs-number">4.292</span></span>] } ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allCoordinates = allActivities.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">activity</span></span></span><span class="hljs-function"> =&gt;</span></span> activity.coordinates) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allCoordinates) <span class="hljs-comment"><span class="hljs-comment">// [[50.123, 3.291], [1.238, 4.292]]</span></span></code> </pre> <br>  Alors, souvenez-vous: lorsque vous devez <b>modifier un</b> tableau, pensez à utiliser la <b>carte</b> . <br><br>  <b>filtrer</b> <br>  Le nom de cette méthode parle de lui-même: utilisez-le lorsque vous souhaitez filtrer un tableau. <br><br>  Comme <code>map</code> , le <code>filter</code> prend comme paramètre unique une fonction qui est appelée sur chaque élément du tableau.  Cette fonction doit renvoyer une valeur booléenne: <br><br><ul><li>  <code>true</code> - si vous souhaitez <b>enregistrer l'</b> élément dans un tableau; </li><li>  <code>false</code> - si vous ne souhaitez pas l'enregistrer. </li></ul><br>  En conséquence, vous aurez le nouveau tableau correct avec les éléments que vous souhaitez laisser. <br><br>  Par exemple, seuls les nombres impairs peuvent être stockés dans un tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oddNumbers = numbers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> !== <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(oddNumbers) <span class="hljs-comment"><span class="hljs-comment">// [1, 3, 5]</span></span></code> </pre><br>  Vous pouvez également utiliser un filtre pour supprimer un élément spécifique du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participants = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a3f47'</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fek28'</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'n3j44'</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'sam'</span></span> }, ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeParticipant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">participants, id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> participants.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">participant</span></span></span><span class="hljs-function"> =&gt;</span></span> participant.id !== id) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(removeParticipant(participants, <span class="hljs-string"><span class="hljs-string">'a3f47'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// [{ id: 'fek28', username: 'mary' }, { id: 'n3j44', username: 'sam' }];</span></span></code> </pre> <br>  <b>réduire</b> <br>  À mon avis, cette méthode est la plus difficile à comprendre.  Mais dès que vous le maîtriserez, vous aurez un tas d'opportunités. <br><br>  En règle générale, la méthode de <code>reduce</code> prend un tableau de valeurs et les concatène en une seule valeur.  Il prend deux paramètres, une fonction de rappel (qui est le <b>réducteur</b> ) et une valeur initiale facultative (qui est le premier élément du tableau par défaut).  La boîte de vitesses elle-même prend quatre paramètres: <br><br><ul><li>  une batterie qui recueille les valeurs renvoyées dans la <b>boîte de vitesses</b> ; </li><li>  valeur actuelle du tableau; </li><li>  indice actuel; </li><li>  le tableau pour lequel la méthode de <code>reduce</code> été appelée. </li></ul><br>  Fondamentalement, vous n'utiliserez que les deux premiers paramètres - la batterie et la valeur actuelle. <br><br>  Mais n'allons pas au fond de la théorie et considérons l'exemple le plus courant de l'application de la <code>reduce</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> total = numbers.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total, n</span></span></span><span class="hljs-function">) =&gt;</span></span> total + n) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(total) <span class="hljs-comment"><span class="hljs-comment">// 90</span></span></code> </pre> <br>  Dans la première itération, l'accumulateur, qui est la somme, prend la valeur initiale 37. La valeur retournée est 37 + n, où n = 12. On obtient 49. <br><br>  Lors de la deuxième itération, l'accumulateur est 49, la valeur retournée est 49 + 28 = 77. Et ainsi de suite. <br><br>  La méthode de <code>reduce</code> est tellement fonctionnelle que vous pouvez l'utiliser pour créer de nombreuses méthodes de tableau comme la <code>map</code> ou le <code>filter</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mappedArr, element</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...mappedArr, fn(element)] }, []) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(map([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], n =&gt; n + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4, 5] const filter = (arr, fn) =&gt; { return arr.reduce((filteredArr, element) =&gt; { return fn(element) ? [...filteredArr] : [...filteredArr, element] }, []) } console.log(filter([1, 2, 3, 4, 5, 6], n =&gt; n % 2 === 0)) // [1, 3, 5]</span></span></code> </pre> <br>  En règle générale, nous attribuons la valeur initiale <code>[]</code> à la méthode de <code>reduce</code> - l'accumulateur.  Pour la <code>map</code> nous exécutons une fonction dont le résultat est ajouté à la fin de la batterie en utilisant <b>l'opérateur de propagation</b> (nous en parlerons ci-dessous, ne vous inquiétez pas).  Pour le <code>filter</code> faisons presque la même chose, nous exécutons uniquement la fonction de filtre sur l'élément.  Si c'est vrai, nous retournons le tableau <b>précédent</b> .  Sinon, ajoutez l'élément à la fin du tableau. <br><br>  Regardons un exemple plus complexe: réduisez considérablement le tableau <code>[1, 2, 3, [4, [[[5, [6, 7]]]], 8]]</code> à <code>[1, 2, 3, 4, 5, 6, 7, 8]</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatDeep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">flattenArray, element</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(element) ? [...flattenArray, ...flatDeep(element)] : [...flattenArray, element] }, []) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(flatDeep([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, [<span class="hljs-number"><span class="hljs-number">4</span></span>, [[[<span class="hljs-number"><span class="hljs-number">5</span></span>, [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]]]], <span class="hljs-number"><span class="hljs-number">8</span></span>]])) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span></code> </pre> <br>  Cet exemple est très similaire à <code>map</code> , sauf que nous utilisons ici la récursivité.  Je ne m'attarderai pas sur la récursivité en détail, car cela dépasse la portée de notre sujet, mais si vous voulez en savoir plus, allez à cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellente ressource</a> . <br><br>  <b>Déclaration de propagation (ES2015)</b> <br>  Je suis d'accord, ce n'est pas une méthode.  Cependant, l'opérateur d'étalement aide à atteindre différents objectifs lors de l'utilisation de tableaux.  Vous pouvez l'appliquer pour développer les valeurs d'un tableau dans un autre, puis faire une copie ou lier plusieurs tableaux ensemble. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersCopy = [...numbers] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersCopy) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] const otherNumbers = [4, 5, 6] const numbersConcatenated = [...numbers, ...otherNumbers] console.log(numbersConcatenated) // [1, 2, 3, 4, 5, 6]</span></span></code> </pre> <br>  <b>Remarque</b> : l'instruction spread crée une <b>copie superficielle du</b> tableau d'origine.  Mais que signifie «superficiel»? <br><br>  Une telle copie dupliquera le moins possible les éléments originaux.  Si vous avez un tableau avec des nombres, des chaînes ou des valeurs booléennes ( <b>types primitifs</b> ), il n'y a aucun problème et les valeurs sont vraiment dupliquées.  Cependant, les choses sont différentes avec les <b>objets</b> et les <b>tableaux</b> : seule une <b>référence</b> à la valeur d'origine est copiée.  Par conséquent, si vous effectuez une copie superficielle du tableau comprenant l'objet et modifiez l'objet dans le tableau copié, il sera également modifié dans l'original, car ils ont la <b>même référence</b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas'</span></span> }] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = [...arr] copy[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr) <span class="hljs-comment"><span class="hljs-comment">// No mutations: ["foo", 42, { name: "Thomas" }] console.log(copy) // ["bar", 42, { name: "Thomas" }] copy[2].name = 'Hello' console.log(arr) // /!\ MUTATION ["foo", 42, { name: "Hello" }] console.log(copy) // ["bar", 42, { name: "Hello" }]</span></span></code> </pre> <br>  Donc, si vous souhaitez créer une copie réelle d'un tableau qui contient un objet ou des tableaux, vous pouvez utiliser une fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lodash</a> comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloneDeep</a> .  Mais ne vous considérez pas obligé de le faire.  Votre objectif est de <b>découvrir comment tout fonctionne sous le capot</b> . <br><br><h3>  Méthodes utiles </h3><br>  Vous trouverez ci-dessous d'autres méthodes qui sont également utiles à connaître et qui peuvent être utiles pour résoudre des problèmes tels que la recherche d'un élément dans un tableau, la suppression d'une partie d'un tableau, et bien plus encore. <br><br>  <b>comprend (ES2015)</b> <br>  Avez-vous déjà utilisé <code>indexOf</code> pour savoir s'il y a un élément dans un tableau ou non?  Une terrible façon de vérifier, non? <br><br>  Heureusement, la méthode <code>includes</code> effectue la validation pour nous.  Définissez le paramètre pour includes, et il recherchera l'élément dans le tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sports = [<span class="hljs-string"><span class="hljs-string">'football'</span></span>, <span class="hljs-string"><span class="hljs-string">'archery'</span></span>, <span class="hljs-string"><span class="hljs-string">'judo'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasFootball = sports.includes(<span class="hljs-string"><span class="hljs-string">'football'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hasFootball) <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  <b>concat</b> <br>  La méthode concat peut être utilisée pour fusionner deux tableaux ou plus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> otherNumbers = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersConcatenated = numbers.concat(otherNumbers) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersConcatenated) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5, 6] // You can merge as many arrays as you want function concatAll(arr, ...arrays) { return arr.concat(...arrays) } console.log(concatAll([1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12])) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span></code> </pre> <br>  <b>forEach</b> <br>  Si vous souhaitez effectuer une action pour chaque élément du tableau, vous pouvez utiliser la méthode <code>forEach</code> .  Il prend une fonction comme paramètre, qui à son tour prend également trois paramètres: valeur actuelle, index et tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] numbers.forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// 1 0 [ 1, 2, 3 ] // 2 1 [ 1, 2, 3 ] // 3 2 [ 1, 2, 3 ]</span></span></code> </pre><br>  <b>indexOf</b> <br>  Cette méthode est utilisée pour renvoyer le premier index auquel l'élément peut être trouvé dans le tableau.  De plus, <code>indexOf</code> vérifie souvent la présence d'un élément dans un tableau.  Honnêtement, maintenant je l'utilise rarement. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sports = [<span class="hljs-string"><span class="hljs-string">'football'</span></span>, <span class="hljs-string"><span class="hljs-string">'archery'</span></span>, <span class="hljs-string"><span class="hljs-string">'judo'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> judoIndex = sports.indexOf(<span class="hljs-string"><span class="hljs-string">'judo'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(judoIndex) <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre> <br>  <b>trouver</b> <br>  La méthode de <code>find</code> est similaire au <code>filter</code> .  Vous devez lui fournir une fonction qui teste chaque élément du tableau.  Cependant, <code>find</code> arrête de tester les éléments dès qu'il en trouve un qui a réussi le test.  Ce n'est <b>pas un</b> <code>filter</code> qui itère sur l'ensemble du tableau quelles que soient les circonstances. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'af35'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'932j'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gary'</span></span> }, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = users.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.id === <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user) <span class="hljs-comment"><span class="hljs-comment">// { id: '6gbe', name: 'mary' }</span></span></code> </pre> <br>  Par conséquent, utilisez la méthode de <code>filter</code> lorsque vous souhaitez filtrer l' <b>intégralité du</b> tableau et la méthode <code>find</code> lorsque vous êtes sûr de rechercher un élément <b>unique</b> dans le tableau. <br>  <b>findIndex</b> <br>  Cette méthode est presque identique à <code>find</code> , mais elle retourne l'index du premier élément trouvé au lieu de l'élément lui-même. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'af35'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'932j'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gary'</span></span> }, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = users.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.id === <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Vous pourriez penser que <code>findIndex</code> et <code>indexOf</code> sont la même chose.  Pas vraiment.  Le premier paramètre d' <code>indexOf</code> est une valeur primitive (une valeur booléenne, un nombre, une chaîne, une valeur non définie ou un caractère), tandis que le premier paramètre, <code>findIndex</code> est une fonction de rappel. <br><br>  Par conséquent, lorsque vous devez rechercher l'index d'un élément dans un tableau de valeurs primitives, vous pouvez travailler avec <code>indexOf</code> .  Si vous avez des éléments plus complexes, tels que des objets, utilisez <code>findIndex</code> . <br><br>  <b>tranche</b> <br>  Lorsque vous devez faire partie d'un tableau ou copier un tableau, vous pouvez vous référer à la méthode <code>slice</code> .  Mais attention: comme l'opérateur spread, <code>slice</code> renvoie une <b>copie superficielle</b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> copy = numbers.slice()</code> </pre> <br>  Au début de l'article, j'ai mentionné que les boucles sont souvent inutiles.  Permettez-moi de vous montrer comment vous en débarrasser. <br><br>  Supposons que vous souhaitiez renvoyer un certain nombre de messages de discussion à partir de l'API et que vous n'en ayez besoin que de cinq.  Voici deux approches: une avec des boucles, l'autre avec une méthode de <code>slice</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// The "traditional way" to do it: // Determine the number of messages to take and use a for loop const nbMessages = messages.length &lt; 5 ? messages.length : 5 let messagesToShow = [] for (let i = 0; i &lt; nbMessages; i++) { messagesToShow.push(posts[i]) } // Even if "arr" has less than 5 elements, // slice will return an entire shallow copy of the original array const messagesToShow = messages.slice(0, 5)</span></span></code> </pre> <br>  <b>certains</b> <br>  Si vous souhaitez vérifier si <b>au moins un élément du</b> tableau réussit le test, vous pouvez en utiliser.  Comme <code>map</code> , <code>filter</code> ou <code>find</code> , la méthode <code>some</code> prend une fonction de rappel comme seul paramètre, puis retourne <code>true</code> si au moins un élément réussit la vérification, et <code>false</code> sinon. <br><br>  <code>some</code> conviennent également pour travailler avec des autorisations. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fe34'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a198'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'18aa'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'delete'</span></span>, <span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], } ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDeletePermission = users.some(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.permissions.includes(<span class="hljs-string"><span class="hljs-string">'delete'</span></span>) ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hasDeletePermission) <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  <b>tous</b> <br>  Cette méthode est similaire à <code>some</code> , sauf qu'elle vérifie que <b>chaque</b> élément (et <b>non un</b> ) correspond à la condition. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fe34'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a198'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'18aa'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'delete'</span></span>, <span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], } ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasAllReadPermission = users.every(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.permissions.includes(<span class="hljs-string"><span class="hljs-string">'read'</span></span>) ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hasAllReadPermission) <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  <b>plat (ES2019)</b> <br>  Ce sont des méthodes complètement nouvelles dans le monde JavaScript.  Habituellement, <code>flat</code> crée un nouveau tableau, connectant tous les éléments d'un tableau imbriqué.  Il prend un paramètre - un nombre qui indique combien vous voulez réduire la dimension du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, [<span class="hljs-number"><span class="hljs-number">5</span></span>, [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]], [[[[<span class="hljs-number"><span class="hljs-number">8</span></span>]]]]]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersflattenOnce = numbers.flat() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersflattenOnce) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, Array[2], Array[1]] const numbersflattenTwice = numbers.flat(2) console.log(numbersflattenTwice) // [1, 2, 3, 4, 5, Array[2], Array[1]] const numbersFlattenInfinity = numbers.flat(Infinity) console.log(numbersFlattenInfinity) // [1, 2, 3, 4, 5, 6, 7, 8]</span></span></code> </pre> <br>  <b>flatMap (ES2019)</b> <br>  Devinez ce que fait cette méthode?  Je parie que vous comprendrez un nom. <br><br>  Tout d'abord, il exécute la fonction de mappage pour chaque élément, puis réduit le tableau à la fois.  C'est aussi simple que ça! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sentences = [ <span class="hljs-string"><span class="hljs-string">'This is a sentence'</span></span>, <span class="hljs-string"><span class="hljs-string">'This is another sentence'</span></span>, <span class="hljs-string"><span class="hljs-string">"I can't find any original phrases"</span></span>, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allWords = sentences.flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sentence</span></span></span><span class="hljs-function"> =&gt;</span></span> sentence.split(<span class="hljs-string"><span class="hljs-string">' '</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allWords) <span class="hljs-comment"><span class="hljs-comment">// ["This", "is", "a", "sentence", "This", "is", "another", "sentence", "I", "can't", "find", "any", "original", "phrases"]</span></span></code> </pre> <br>  Dans cet exemple, vous avez plusieurs phrases dans le tableau et vous souhaitez obtenir tous les mots.  Au lieu d'utiliser la méthode <code>map</code> et de diviser toutes les phrases en mots, puis de raccourcir le tableau, vous pouvez utiliser <code>flatMap</code> tout de <code>flatMap</code> . <br><br>  Ensuite, vous pouvez compter le nombre de mots avec la fonction de <code>reduce</code> (cela ne s'applique pas à <code>flatMap</code> , je veux juste vous montrer un autre exemple d'utilisation de la méthode de <code>reduce</code> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wordsCount = allWords.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count, word</span></span></span><span class="hljs-function">) =&gt;</span></span> { count[word] = count[word] ? count[word] + <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count }, {}) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(wordsCount) <span class="hljs-comment"><span class="hljs-comment">// { This: 2, is: 2, a: 1, sentence: 2, another: 1, I: 1, "can't": 1, find: 1, any: 1, original: 1, phrases: 1, }</span></span></code> </pre><br>  La méthode <code>flatMap</code> également souvent utilisée en programmation réactive.  Vous pouvez voir un exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  <b>rejoindre</b> <br>  Si vous devez créer une chaîne basée sur des éléments de tableau, la méthode de <code>join</code> est ce dont vous avez besoin.  Il vous permet de créer une nouvelle ligne en connectant tous les éléments du tableau, séparés par le séparateur fourni. <br><br>  Par exemple, à l'aide de la <code>join</code> vous pouvez afficher visuellement tous les participants d'une activité. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participants = [<span class="hljs-string"><span class="hljs-string">'john'</span></span>, <span class="hljs-string"><span class="hljs-string">'mary'</span></span>, <span class="hljs-string"><span class="hljs-string">'gary'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participantsFormatted = participants.join(<span class="hljs-string"><span class="hljs-string">', '</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(participantsFormatted) <span class="hljs-comment"><span class="hljs-comment">// john, mary, gary</span></span></code> </pre> <br>  Et ceci est un exemple plus réaliste où vous pouvez d'abord filtrer les participants et obtenir leurs noms. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> potentialParticipants = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'k38i'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'baf3'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">13</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a111'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gary'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fx34'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'emma'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">34</span></span> }, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participantsFormatted = potentialParticipants .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.age &gt; <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.name) .join(<span class="hljs-string"><span class="hljs-string">', '</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(participantsFormatted) <span class="hljs-comment"><span class="hljs-comment">// gary, emma</span></span></code> </pre> <br>  <b>de</b> <br>  Il s'agit d'une méthode <b>statique</b> qui crée un nouveau tableau à partir d'un objet de type tableau ou itérable, tel qu'une chaîne.  Il peut être utile lorsque vous travaillez avec le modèle d'objet de document. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nodes = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.todo-item'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// this is an instance of NodeList const todoItems = Array.from(nodes) // now, you can use map, filter, etc. as you're workin with an array!</span></span></code> </pre> <br>  Avez-vous vu que nous avons utilisé un type de tableau au lieu d'une instance de tableau?  C'est pourquoi cette méthode est appelée statique. <br><br>  Ensuite, vous pouvez vous amuser avec les nœuds, par exemple en enregistrant des écouteurs d'événements pour chacun d'eux en utilisant la méthode <code>forEach</code> . <br><br><pre> <code class="javascript hljs">todoItems.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> { item.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">`You clicked on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.innerHTML}</span></span></span><span class="hljs-string">`</span></span>) }) })</code> </pre><br><h3>  Modification de tableau à connaître </h3><br>  Voici d'autres méthodes standard.  Leur différence est qu'ils modifient le tableau d'origine.  Il n'y a rien de mal à ce changement, mais vous devez en tenir compte lorsque vous travaillez. <br><br>  Si vous ne souhaitez pas modifier le tableau d'origine tout en travaillant avec ces méthodes, faites une surface ou une copie complète à l'avance. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> copy = [...arr] <span class="hljs-comment"><span class="hljs-comment">// or arr.slice()</span></span></code> </pre><br>  <b>trier</b> <br>  Oui, <code>sort</code> modifie le tableau d'origine.  En fait, il trie les éléments du tableau en place.  La méthode de tri par défaut transforme tous les éléments en chaînes et les trie par ordre alphabétique. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names = [<span class="hljs-string"><span class="hljs-string">'john'</span></span>, <span class="hljs-string"><span class="hljs-string">'mary'</span></span>, <span class="hljs-string"><span class="hljs-string">'gary'</span></span>, <span class="hljs-string"><span class="hljs-string">'anna'</span></span>] names.sort() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(names) <span class="hljs-comment"><span class="hljs-comment">// ['anna', 'gary', 'john', 'mary']</span></span></code> </pre> <br>  Soyez prudent: si vous, par exemple, êtes passé du langage Python, la méthode de <code>sort</code> lorsque vous travaillez avec un tableau de nombres ne vous donnera pas le résultat souhaité. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">187</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>] numbers.sort() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbers) <span class="hljs-comment"><span class="hljs-comment">// [12, 17, 187, 23, 3, 90]</span></span></code> </pre> <br>  Comment alors trier un tableau?  La méthode de <code>sort</code> prend une fonction - <b>une fonction de comparaison</b> .  Il prend deux paramètres: le premier élément ( <code></code> ) et le deuxième élément pour la comparaison ( <code>b</code> ).  La comparaison entre ces deux éléments nécessite un retour de chiffres: <br><br><ul><li>  si la valeur est négative - <code>a</code> trié avant <code>b</code> ; </li><li>  si la valeur est positive, <code>b</code> trié avant <code>a</code> ; </li><li>  si la valeur est 0, aucun changement. </li></ul><br>  Ensuite, vous pouvez trier les chiffres. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">187</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>] numbers.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbers) <span class="hljs-comment"><span class="hljs-comment">// [3, 12, 17, 23, 90, 187]</span></span></code> </pre> <br>  Ou vous pouvez trier les dates les plus récentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> posts = [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Create a Discord bot under 15 minutes'</span></span>, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">26</span></span>), }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'How to get better at writing CSS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">06</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>) }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'JavaScript arrays'</span></span>, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }, ] posts.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a.date - b.date) <span class="hljs-comment"><span class="hljs-comment">// Substracting two dates returns the difference in millisecond between them console.log(posts) // [ { title: 'How to get better at writing CSS', // date: 2018-07-17T00:00:00.000Z }, // { title: 'Create a Discord bot under 15 minutes', // date: 2018-12-26T00:00:00.000Z }, // { title: 'Learn Javascript arrays the functional way', // date: 2019-03-16T10:31:00.208Z } ]</span></span></code> </pre><br>  <b>remplir</b> <br>  La méthode <code>fill</code> modifie ou remplit tous les éléments du tableau de l'index de début à la fin avec la valeur spécifiée.  Un exemple de l'excellente utilisation de <code>fill</code> est de remplir un nouveau tableau avec les données initiales. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Normally I would have called a function that generates ids and random names but let's not bother with that here. function fakeUser() { return { id: 'fe38', name: 'thomas', } } const posts = Array(3).fill(fakeUser()) console.log(posts) // [{ id: "fe38", name: "thomas" }, { id: "fe38", name: "thomas" }, { id: "fe38", name: "thomas" }]</span></span></code> </pre> <br>  <b>inverser</b> <br>  Il me semble que le nom de la méthode explique pleinement son essence. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] numbers.reverse() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbers) <span class="hljs-comment"><span class="hljs-comment">// [5, 4, 3, 2, 1]</span></span></code> </pre> <br>  <b>pop</b> <br>  Cette méthode supprime le dernier élément du tableau et le renvoie. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messages = [<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hey'</span></span>, <span class="hljs-string"><span class="hljs-string">'How are you?'</span></span>, <span class="hljs-string"><span class="hljs-string">"I'm fine"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastMessage = messages.pop() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages) <span class="hljs-comment"><span class="hljs-comment">// ['Hello', 'Hey', 'How are you?'] console.log(lastMessage) // I'm fine</span></span></code> </pre> <br><h3>  Méthodes pouvant être remplacées </h3><br>  Dans la dernière section, vous trouverez des méthodes qui modifient le tableau d'origine et qui sont faciles à trouver une alternative.  Je ne dis pas qu'ils doivent être réduits, je veux simplement vous dire que certaines méthodes ont des effets secondaires et peuvent être remplacées. <br><br>  <b>pousser</b> <br>  Cette méthode est fréquemment utilisée.  Il vous permet d'ajouter un ou plusieurs éléments au tableau, ainsi que de créer un nouveau tableau basé sur le précédent. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todoItems = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemsIncremented = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; items.length; i++) { itemsIncremented.push(items[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(itemsIncremented) <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4, 5, 6] const todos = ['Write an article', 'Proofreading'] todos.push('Publish the article') console.log(todos) // ['Write an article', 'Proofreading', 'Publish the article']</span></span></code> </pre> <br>  Si vous devez créer un tableau sur la base d'un autre, comme dans la méthode <code>itemsIncremented</code> , il existe des <code>filter</code> <code>map</code> , de <code>filter</code> ou de <code>reduce</code> appropriés qui nous sont déjà familiers.  Par exemple, nous pouvons prendre la <code>map</code> pour ce faire. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemsIncremented = todoItems.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Et si vous souhaitez utiliser <code>push</code> lorsque vous devez ajouter un nouvel élément, alors l'opérateur d'étalement est utile. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todos = [<span class="hljs-string"><span class="hljs-string">'Write an article'</span></span>, <span class="hljs-string"><span class="hljs-string">'Proofreading'</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([...todos, <span class="hljs-string"><span class="hljs-string">'Publish the article'</span></span>])</code> </pre> <br>  <b>épissure</b> <br>  <code>splice</code> souvent accessible pour nettoyer un élément à un index spécifique.  Vous pouvez faire de même avec la méthode de <code>filter</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [<span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">' May'</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With splice months.splice(2, 1) // remove one element at index 2 console.log(months) // ['January', 'February', 'April', 'May'] // Without splice const monthsFiltered = months.filter((month, i) =&gt; i !== 3) console.log(monthsFiltered) // ['January', 'February', 'April', 'May']</span></span></code> </pre> <br>  Vous pouvez demander: et si je dois supprimer un grand nombre d'éléments?  Ensuite, utilisez une <code>slice</code> . <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [<span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">' May'</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With splice months.splice(1, 3) // remove thirds element starting at index 1 console.log(months) // ['January', 'February', 'April', 'May'] // Without splice const monthsFiltered = [...months.slice(0, 1), ...months.slice(4)] console.log(monthsFiltered) // ['January', 'February', 'April', 'May']</span></span></code> </pre><br>  <b>décaler</b> <br>  La méthode <code>shift</code> supprime le premier élément du tableau et le renvoie.  Pour ce faire, dans le style de la programmation fonctionnelle, vous pouvez utiliser l'instruction spread ou rest. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With shift const firstNumber = numbers.shift() console.log(firstNumber) // 1 console.log(numbers) // [2, 3, 4, 5] // Without shift const [firstNumber, ...numbersWithoutOne] = numbers console.log(firstNumber) // 1 console.log(numbersWithoutOne) // [2, 3, 4, 5]</span></span></code> </pre> <br>  <b>décaler</b> <br>  La méthode unshift vous permet d'ajouter un ou plusieurs éléments au début d'un tableau.  Comme <code>shift</code> , vous pouvez le faire avec l'opérateur spread. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With unshift numbers.unshift(1, 2) console.log(numbers) // [1, 2, 3, 4, 5] // Without unshift const newNumbers = [1, 2, ...numbers] console.log(newNumbers) // [1, 2, 3, 4, 5]</span></span></code> </pre><br><h3>  TL; DR </h3><br><ul><li>  Lorsque vous souhaitez effectuer certaines opérations avec un tableau, n'utilisez pas <b>la boucle for</b> et ne réinventez pas la roue, car il existe très probablement une méthode ci-dessus qui peut faire ce dont vous avez besoin. </li><li>  Le plus souvent, vous utiliserez la <code>map</code> , le <code>filter</code> , <code>reduce</code> méthodes de <code>reduce</code> et l'opérateur de propagation - ce sont des outils importants pour tout développeur. </li><li>  Il existe également de nombreuses méthodes de tableau qu'il serait bon de connaître: <code>slice</code> , <code>some</code> , <code>flatMap</code> , etc. Apprenez à les connaître et appliquez si nécessaire. </li><li>  Les effets secondaires peuvent entraîner des changements indésirables.  N'oubliez pas que certaines méthodes modifient votre tableau d'origine. </li><li>  La méthode de <code>slice</code> et l'opérateur d'étalement font des copies superficielles.  Par conséquent, les objets et les sous-réseaux auront les mêmes liens - cela vaut également la peine d'être gardé à l'esprit. </li><li>  Les anciennes méthodes qui modifient le tableau peuvent être remplacées par de nouvelles.  Vous décidez quoi faire. </li></ul><br>  Vous savez maintenant tout ce que vous devez savoir sur les tableaux JavaScript.  Si vous avez aimé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> , cliquez sur le bouton "Pat" (jusqu'à 50 fois, si vous voulez :-)) et partagez-le.  Et n'hésitez pas à partager vos impressions dans les commentaires! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446902/">https://habr.com/ru/post/fr446902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446882/index.html">Le MIPT a reçu le droit d'accueillir la Coupe du monde de programmation ICPC en 2020 à Moscou</a></li>
<li><a href="../fr446884/index.html">Que lire et regarder de la science-fiction fraîche: Mars, les cyborgs et l'IA rebelle</a></li>
<li><a href="../fr446886/index.html">Les meilleurs experts de l'Expo 3D: Sunny Wong. Plus de 25 millions d'entorses peuvent être évitées</a></li>
<li><a href="../fr446888/index.html">Cryptographie en Java. Classe de certificat</a></li>
<li><a href="../fr446896/index.html">Les chefs de projet ne sont pas nécessaires</a></li>
<li><a href="../fr446904/index.html">Tesla partage son crash au milieu de la plus forte baisse de ses ventes</a></li>
<li><a href="../fr446906/index.html">Musique ambiante et ses effets sur l'écriture de code</a></li>
<li><a href="../fr446908/index.html">Recommandations de sécurité des informations DLP et FSTEC: Parallels intersectants</a></li>
<li><a href="../fr446912/index.html">Combien coûte la sécurité des applications Web (en utilisant Barracuda WAF-as-a-Service comme exemple)</a></li>
<li><a href="../fr446914/index.html">Pourquoi enseignez-vous go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>