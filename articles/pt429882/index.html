<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèΩ üíà üë©üèΩ‚Äçüé§ Controle de LEDs RGB via microcontroladores Cypress UDB PSoC üí≤ ‚èπÔ∏è üèä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 H√° muito tempo, eu queria aprender a t√©cnica de programa√ß√£o de blocos UDB nos controladores Cypress PSoC, mas de alguma forma todas as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Controle de LEDs RGB via microcontroladores Cypress UDB PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429882/"><img src="https://habrastorage.org/webt/is/cg/hl/iscghlsqtbktd8fhkstyrghp9ee.jpeg"><br><br><h2>  1. Introdu√ß√£o </h2><br>  H√° muito tempo, eu queria aprender a t√©cnica de programa√ß√£o de blocos UDB nos controladores Cypress PSoC, mas de alguma forma todas as minhas m√£os n√£o alcan√ßaram.  E assim, surgiu um problema no qual isso poderia ser feito.  Compreendendo os materiais da rede, percebi que as recomenda√ß√µes pr√°ticas para trabalhar com o UDB s√£o limitadas a v√°rias varia√ß√µes de contadores e PWMs.  Por alguma raz√£o, todos os autores fazem suas varia√ß√µes desses dois exemplos can√¥nicos; portanto, a descri√ß√£o de outra coisa pode ser interessante para os leitores. <br><a name="habracut"></a><br>  Ent√£o  Ocorreu um problema ao gerenciar dinamicamente uma longa linha de LEDs RGB WS2812B.  Abordagens cl√°ssicas para esse assunto s√£o conhecidas.  Voc√™ pode usar o Arduino trivial, mas a sa√≠da √© programada; portanto, enquanto os dados est√£o sendo produzidos, todo o resto fica ocioso; caso contr√°rio, os diagramas de temporiza√ß√£o falhar√£o.  Voc√™ pode utilizar o STM32 e enviar dados por meio de DMA para PWM ou de DMA para SPI.  T√©cnicas s√£o conhecidas.  Eu at√© mesmo controlei pessoalmente uma linha de dezesseis diodos atrav√©s da SPI.  Mas a sobrecarga √© √≥tima.  Um bit de dados nos LEDs ocupa 8 bits na mem√≥ria para o caso de PWM e de 3 a 4 bits (dependendo da frieza do PLL no controlador) para SPI.  Embora existam poucos LEDs, isso n√£o √© assustador, mas se houver, digamos, algumas centenas, 200 * 24 = 4800 bits = 600 bytes de dados √∫teis devem ser fisicamente armazenados em um buffer de mais de 4 kilobytes para a op√ß√£o PWM ou mais de 2 kilobytes para SPI- op√ß√µes  Para indica√ß√£o din√¢mica de buffers, deve haver v√°rios, e o STM32F103 tem RAM para tudo, desde 20 kilobytes.  N√£o que tenhamos encontrado uma tarefa irrealiz√°vel, mas um motivo para verificar se isso pode ser implementado no PSoC sem precisar gastar RAM extra, √© bastante significativo. <br><br><h2>  Refer√™ncias te√≥ricas </h2><br>  Primeiro, vamos descobrir que tipo de animal √© esse UDB e como eles trabalham com ele.  Filmes instrutivos maravilhosos do fabricante do controlador ajudar√£o nisso. <br><br>  Voc√™ deve come√ßar a assistir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir daqui</a> e, no final de cada v√≠deo, haver√° um link para a pr√≥xima s√©rie.  Passo a passo, voc√™ obter√° conhecimentos b√°sicos e considerar√° o exemplo can√¥nico "contador".  Bem, e um sistema de controle de sem√°foro. <br><br>  Sobre o mesmo, mas cortado em peda√ßos pequenos, voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ver aqui</a> .  Meu v√≠deo n√£o foi reproduzido, mas pode ser baixado e exibido localmente.  Entre outras coisas, tamb√©m h√° um exemplo can√¥nico da implementa√ß√£o do PWM. <br><br><h2>  Solu√ß√µes finalizadas </h2><br>  Para n√£o reinventar a roda (e vice-versa - para aprender a metodologia da experi√™ncia de outra pessoa), vasculhei a rede em busca de solu√ß√µes prontas para o controle de LEDs RGB.  A solu√ß√£o mais popular √© o StripLightLib.cylib.  Mas, h√° muitos anos, ele planeja adicionar o suporte ao Add DMA.  Mas quero experimentar uma solu√ß√£o que n√£o dependa do processador central.  Quero iniciar o processo e esquec√™-lo, concentrando-me na prepara√ß√£o do pr√≥ximo quadro. <br><br>  A solu√ß√£o que atende aos meus desejos foi encontrada em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/PolyVinalDistillate/PSoC_DMA_NeoPixel</a> . <br><br>  Tudo √© implementado no UDB (mas os LEDs s√£o apenas uma desculpa, o objetivo √© aprender o UDB).  H√° suporte para DMA.  E o projeto l√° √© claramente organizado de maneira bonita. <br><br><h2>  Problemas da solu√ß√£o escolhida como base </h2><br>  Como est√° o "firmware" no projeto PSoC_DMA_NeoPixel, qualquer um pode ver depois de ler o artigo.  Isso ir√° corrigir o material.  Por enquanto, s√≥ direi que simplifiquei a l√≥gica do firmware original sem reduzir os recursos consumidos (mas ficou mais f√°cil entender).  Ent√£o, ele come√ßou a experimentar a substitui√ß√£o da l√≥gica do aut√¥mato, que prometia um ganho de recursos, mas enfrentava um problema s√©rio.  E ent√£o ele decidiu - n√£o √© eliminado!  E vagas d√∫vidas come√ßaram a me atormentar: o autor ingl√™s estava tendo o mesmo problema?  Sua demo pisca muito bem com os LEDs.  Mas e se substituirmos o belo recheio por "todas as unidades" e controlarmos a sa√≠da n√£o com nossos olhos, mas com um oscilosc√≥pio? <br>  Portanto, da forma mais grosseira poss√≠vel (voc√™ pode at√© dizer ‚Äúbrutalmente‚Äù), formamos os dados: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (pPixelArray,<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pPixelArray)); <span class="hljs-comment"><span class="hljs-comment">//Call NeoPixel update function (non blocking) to trigger DMA pixel update NP_Update();</span></span></code> </pre> <br>  E aqui vemos essa imagem em um oscilosc√≥pio: <br><br><img src="https://habrastorage.org/webt/kv/u7/wu/kvu7wuciw7tafpf_cjjbp4m-gzw.png"><br><br>  O primeiro bit tem uma largura diferente do resto.  Pedi para enviar todas as unidades, mas nem todas saem.  Entre eles zerados!  Altere a verifica√ß√£o: <br><br><img src="https://habrastorage.org/webt/2k/ev/mb/2kevmb_fna8e8oce9pkdwhaofcg.png"><br><br>  A largura √© diferente para cada oitavo bit. <br><br>  Em geral, este exemplo como solu√ß√£o independente n√£o √© adequado, mas como fonte de inspira√ß√£o - simplesmente perfeito.  Em primeiro lugar, sua inoperabilidade n√£o √© vis√≠vel com o olho (os LEDs ainda est√£o brilhantes, o olho n√£o v√™ que brilha na metade do m√°ximo), mas o c√≥digo √© bem estruturado, √© bom tom√°-lo como base.  Em segundo lugar, este exemplo fornece espa√ßo para encontrar maneiras de simplificar e, em terceiro lugar, faz voc√™ pensar em como corrigir o defeito.  O essencial √© entender o material!  Ent√£o, mais uma vez, depois de ler o artigo, recomendo tentar analisar o exemplo original, percebendo como ele funciona. <br><br><h2>  Parte pr√°tica </h2><br>  Agora come√ßamos a praticar.  Estamos testando os principais aspectos do desenvolvimento de firmware para UDB.  Considere o relacionamento e as t√©cnicas b√°sicas.  Para fazer isso, abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minha vers√£o do projeto</a> .  O bloco esquerdo armazena informa√ß√µes sobre arquivos de trabalho.  Por padr√£o, a guia <b>Origem</b> est√° aberta.  A principal fonte do projeto √© o arquivo <b>main.c.</b>  Na verdade, n√£o h√° outros arquivos de trabalho no grupo <b>Arquivos de Origem</b> . <br><br><img src="https://habrastorage.org/webt/-n/xu/lm/-nxulmetonhzhf6lwlvr30f-2r8.png"><br><br>  O grupo <b>Origem Gerada</b> cont√©m fun√ß√µes de biblioteca.  √â melhor n√£o edit√°-los.  Ap√≥s cada altera√ß√£o do "firmware" do UDB, esse grupo ser√° regenerado.  Ent√£o, onde est√° a descri√ß√£o do c√≥digo para UDB nesse id√≠lio?  Para v√™-lo, voc√™ precisa mudar para a guia <b>Componentes</b> : <br><br><img src="https://habrastorage.org/webt/qb/yj/ku/qbyjkuvng7ibcdlhiftcf5qld6o.png"><br><br>  O autor do projeto original criou um conjunto de componentes de dois n√≠veis.  No n√≠vel superior, encontra-se o circuito <b>NeoPixel_v1_2.cysch</b> .  Isso pode ser visto no esquema principal: <br><br><img src="https://habrastorage.org/webt/z3/cg/fr/z3cgfrfl4k_rdsuu2dw6kykq_o4.png"><br><br>  O componente √© o seguinte: <br><br><img src="https://habrastorage.org/webt/zp/h3/yw/zph3ywaeojjenc6ailxcmsb3f0m.png"><br><br>  O suporte de software para esse esquema ser√° discutido posteriormente.  Enquanto isso, descubra que ela pr√≥pria √© uma unidade DMA comum e um determinado s√≠mbolo <b>NeoPixDrv_v1</b> .  Esse misterioso bloco √© descrito acima na √°rvore, que segue da seguinte dica de ferramenta: <br><br><img src="https://habrastorage.org/webt/zk/_u/2p/zk_u2pxpdmiokfow6b4iur-_ab0.png"><br><br><h2>  UDB "Firmware" </h2><br>  Abra esse componente (arquivo com a extens√£o <b>.cyudb</b> ).  O desenho aberto √© simplesmente enorme.  Come√ßamos a entender o que √© o qu√™. <br><br><img src="https://habrastorage.org/webt/e6/co/4l/e6co4lsbmphoom6ikhuhutzkzbe.png"><br><br>  Ao contr√°rio do autor do projeto original, considero a transmiss√£o de cada bit de dados na forma de tr√™s partes iguais (no tempo): <br><br><ol><li>  Parte inicial (sempre 1) </li><li>  Data Part </li><li>  Parar parte (sempre 0) </li></ol><br>  Com essa abordagem, n√£o √© necess√°rio um grande n√∫mero de contadores (no original havia at√© tr√™s pe√ßas, que consumiam uma grande quantidade de recursos).  A dura√ß√£o de todas as partes √© a mesma e pode ser definida usando um registro.  Assim, o gr√°fico de transi√ß√£o do firmware cont√©m os seguintes estados: <br><br>  Estado <b>ocioso</b> .  A m√°quina permanece nela at√© que novos dados cheguem ao FIFO. <br><br><img src="https://habrastorage.org/webt/s_/r5/zn/s_r5zn54lff9nd9thvqxphyxjqq.png"><br><br>  Nos v√≠deos de treinamento, n√£o estava totalmente claro para mim como o estado da m√°quina est√° relacionado √† ALU.  Os autores usam a comunica√ß√£o naturalmente, mas eu, como iniciante, n√£o pude v√™-la imediatamente.  Vamos dar uma olhada r√°pida em detalhes.  A figura acima mostra que o estado <b>ocioso</b> √© codificado com o valor 1'b0.  3'b000 estar√° mais correto, mas o editor ir√° refazer tudo da mesma forma.  As entradas do bloco <b>Datapath s√£o</b> descritas assim: <br><br><img src="https://habrastorage.org/webt/dq/qc/zp/dqqczpv87oulrwzvu-cbcmucsee.png"><br><br>  Se voc√™ clicar duas vezes neles, uma vers√£o mais detalhada ser√° exibida: <br><br><img src="https://habrastorage.org/webt/pu/xm/ts/puxmtsmg3jf3hjnwstnpbeu-exe.png"><br><br>  Isso significa que o bit zero do endere√ßo da instru√ß√£o ALU corresponde ao bit zero da vari√°vel que define o estado da m√°quina.  O primeiro √© o primeiro, o segundo √© o segundo.  Se desejado, quaisquer vari√°veis ‚Äã‚Äãe express√µes pares podem ser correspondidas com os bits de endere√ßo da instru√ß√£o ALU (na vers√£o original, o segundo bit do endere√ßo da instru√ß√£o ALU foi correspondido por uma express√£o e, na vers√£o atual, ela n√£o √© usada explicitamente, mas como exemplo de execu√ß√£o do c√©rebro √© muito claro, voc√™ pode dar uma olhada). <br><br>  Ent√£o  Com as configura√ß√µes atuais das entradas, que √© o c√≥digo de status bin√°rio da m√°quina, uma instru√ß√£o ALU √© usada.  Quando estamos no estado <b>ocioso,</b> com o c√≥digo 000, √© usada instru√ß√£o nula.  Aqui est√°: <br><br><img src="https://habrastorage.org/webt/4p/oz/gt/4pozgtr4-p66hypvlz2rqdjta2a.png"><br><br>  Eu j√° sei a partir desta entrada que este √© um NOP banal.  Mas voc√™ pode clicar duas vezes nele e ler a vers√£o completa: <br><br><img src="https://habrastorage.org/webt/-a/vl/ii/-avliivwnptl2ra9ipfxseurxqk.png"><br><br>  Os NOPs est√£o inscritos em todos os lugares.  Os registros n√£o s√£o preenchidos com nada. <br><br>  Agora vamos descobrir que tipo de bandeira misteriosa <b>! NoData</b> , for√ßando a m√°quina a deixar o estado <b>ocioso</b> .  Esta √© a sa√≠da do bloco <b>Datapath</b> .  No total, podem ser descritas at√© seis sa√≠das.  S√≥ que o <b>Datapath</b> pode produzir muito mais sinalizadores, mas n√£o h√° recursos de rastreamento suficientes para todos; portanto, precisamos escolher quais seis (ou menos) realmente precisamos.  Aqui est√° a lista na figura: <br><br><img src="https://habrastorage.org/webt/qf/a7/yd/qfa7ydqxuql3khszkw1mqbdb63m.png"><br><br>  Se voc√™ clicar duas vezes, os detalhes ser√£o revelados: <br><br><img src="https://habrastorage.org/webt/vu/zo/2z/vuzo2zxg56zpyaavdunmw60eapg.png"><br><br>  Aqui est√° a lista completa de sinalizadores que podem ser exibidos: <br><br><img src="https://habrastorage.org/webt/gi/la/jf/gilajfhzmatw2hjtfjk9xl1gs7m.png"><br><br>  Ap√≥s selecionar o sinalizador necess√°rio, voc√™ deve dar um nome a ele.  A partir de agora, o sistema tem uma bandeira.  Como voc√™ pode ver, o sinalizador <b>NoData</b> √© o nome do <b>status do bloco F0</b> da cadeia <b>(vazio)</b> .  Ou seja, um sinal de que n√£o h√° dados no buffer de entrada.  Ah <b>! NoData</b> , respectivamente, sua invers√£o.  Sinal de disponibilidade de dados.  Assim que os dados entrarem no FIFO (programaticamente ou usando DMA), o sinalizador ser√° limpo (e sua invers√£o armada) e, no pr√≥ximo ciclo do rel√≥gio, o aut√¥mato sair√° do estado ocioso e entrar√° no estado <b>GetData</b> . <br><br><img src="https://habrastorage.org/webt/lw/o3/av/lwo3avzjvfqynfpw-3t075oat-0.png"><br><br>  Como voc√™ pode ver, o aut√¥mato sair√° desse estado incondicionalmente depois de ter estado nele exatamente um ciclo de rel√≥gio.  Nenhuma a√ß√£o √© indicada no gr√°fico de transi√ß√£o para esse estado.  Mas voc√™ deve sempre observar o que a ALU far√°.  O c√≥digo de status √© 1'b1, ou seja, 3'b001.  Observamos o endere√ßo correspondente na ALU: <br><br><img src="https://habrastorage.org/webt/ic/zk/y8/iczky8asdanru7kzgfzznebiynm.png"><br><br>  Tem alguma coisa  N√£o tendo experi√™ncia em ler o que est√° escrito aqui, abra-o clicando duas vezes na c√©lula correspondente: <br><br><img src="https://habrastorage.org/webt/vu/yf/gf/vuyfgfecoxpfd1brc6v_lzu4a3w.png"><br><br>  Daqui resulta que a pr√≥pria ULA ainda n√£o executa nenhuma a√ß√£o.  Mas o conte√∫do do FIFO0, ou seja, os dados provenientes do programa ou do bloco DMA, ser√° colocado no registro A0.  Olhando para o futuro, direi que A0 √© usado como um registrador de deslocamento, do qual o byte sair√° em forma serial.  O registro A1 colocar√° o valor do registro D1.  Em geral, todos os registros D geralmente s√£o preenchidos com software antes que o hardware inicie.  Ent√£o, ao examinar a API, veremos que o n√∫mero de tiques do rel√≥gio √© colocado nesse registro, que define a dura√ß√£o do terceiro bit.  Ent√£o  Em A0, o valor alterado caiu e, em A1, a dura√ß√£o da parte inicial do bit.  E na pr√≥xima batida, a m√°quina certamente entrar√° no estado <b>Constant1</b> . <br><br><img src="https://habrastorage.org/webt/ue/jx/fh/uejxfhlbmgbh0wgkuy2k4fe-qva.png"><br><br>  Como o nome do estado implica, a constante 1. √© gerada aqui.Vejamos a documenta√ß√£o do LED.  √â assim que a unidade deve ser transferida: <br><br><img src="https://habrastorage.org/webt/cn/2t/i3/cn2ti3ppzpacxrbyi2uy8mq5wte.png"><br><br>  E aqui est√° - zero: <br><br><img src="https://habrastorage.org/webt/z6/yg/vp/z6ygvphpsb700_acfvwiek9mbeo.png"><br><br>  Eu adicionei linhas vermelhas.  Se assumirmos que as dura√ß√µes dos ter√ßos s√£o iguais, os requisitos para a dura√ß√£o dos pulsos (fornecidos na mesma documenta√ß√£o) s√£o atendidos.  Ou seja, qualquer impulso consiste em uma unidade inicial, um bit de dados e um zero zero.  Na verdade, a unidade inicial √© transmitida quando a m√°quina est√° no estado <b>Constant1</b> . <br><br>  Nesse estado, a m√°quina trava a unidade em seu gatilho interno.  O nome do gatilho √© <b>CurrentBit</b> .  No projeto original, geralmente era um gatilho que define o estado do aut√¥mato auxiliar.  Decidi que aquela m√°quina s√≥ confundiria todo mundo, ent√£o iniciei um gatilho.  N√£o est√° descrito em nenhum lugar.  Mas se voc√™ inserir as propriedades do estado, o seguinte registro ser√° vis√≠vel na tabela: <br><br><img src="https://habrastorage.org/webt/tz/2e/m4/tz2em4pv4kxwsg5fvzkhx7-ve_w.png"><br><br>  E sob o estado no gr√°fico, existe esse texto: <br><br><img src="https://habrastorage.org/webt/bx/az/0c/bxaz0clixua21k_umbqpch3vrca.png"><br><br>  N√£o se assuste com o s√≠mbolo de igual.  Esses s√£o os recursos do editor.  No c√≥digo Verilog resultante (gerado automaticamente pelo mesmo sistema), haver√° uma seta: <br><br><pre> <code class="plaintext hljs">Constant1 : begin CurrentBit &lt;= (1); if (( CycleTimeout ) == 1'b1) begin MainState &lt;= Setup1 ; end end</code> </pre> <br>  O valor travado nesse gatilho √© a sa√≠da de todo o nosso bloco: <br><br><img src="https://habrastorage.org/webt/bv/jq/qd/bvjqqdmqg-2framc6_trktlfix4.png"><br><br>  Ou seja, quando a m√°quina entrou no estado de <b>Constant1</b> , a sa√≠da do bloco que estamos desenvolvendo receber√° um.  Agora vamos ver como a ALU est√° programada para o endere√ßo 3'b010: <br><br><img src="https://habrastorage.org/webt/5e/4v/hi/5e4vhiqa5gl7wo6xk0zzea_8_dm.png"><br><br>  N√≥s revelamos este elemento: <br><br><img src="https://habrastorage.org/webt/ij/wx/fc/ijwxfcl3zzmuhlef2qq-j6hhkme.png"><br><br>  A unidade 1 √© subtra√≠da do registro A1.  O valor de sa√≠da da ALU cai no registro A1.  Acima, consideramos que A1 √© um contador de rel√≥gio usado para definir a dura√ß√£o do pulso de sa√≠da.  Deixe-me lembr√°-lo de que foi inicializado a partir do D1 na √∫ltima etapa. <br>  Qual √© a condi√ß√£o para sair de um estado?  <b>CycleTimeOut</b> .  √â descrito entre as sa√≠das da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/7m/1c/pn/7m1cpnxbqkt6fv4x5fv73idlp3g.png"><br><br>  Ent√£o, reunimos a l√≥gica.  No estado anterior, o conte√∫do do registro D1 previamente preenchido pelo programa caiu no registro A1.  Nesta etapa, a m√°quina converte o gatilho <b>CurrentBit</b> em um e, na ALU, o registro A1 diminui a cada ciclo do rel√≥gio.  Quando A1 se torna zero, o sinalizador ser√° automaticamente levantado, ao qual o autor deu o nome <b>CycleTimeout</b> , como resultado do qual a m√°quina passar√° para o estado <b>Setup1</b> . <br><br>  O estado <b>Setup1</b> prepara dados para transmitir o pulso √∫til. <br><br><img src="https://habrastorage.org/webt/on/3g/j-/on3gj-j0zujays_x6uxn_grjnq8.png"><br><br>  Observamos a instru√ß√£o ALU em 3'b011.  Vou abri-lo imediatamente: <br><br><img src="https://habrastorage.org/webt/2u/uu/tl/2uuutl1vwixsvirqgsuwfvxhsb4.png"><br><br>  Parece que a ALU n√£o tem a√ß√µes.  Opera√ß√£o NOP.  E a sa√≠da da ALU n√£o chega a lugar algum.  Mas isso n√£o √© verdade.  Uma a√ß√£o extremamente importante √© a mudan√ßa de dados na ALU.  O fato √© que o bit de transporte entre as sa√≠das est√° conectado √† nossa cadeia <b>ShiftOut</b> : <br><br><img src="https://habrastorage.org/webt/ov/8g/-e/ov8g-emfyzhu3vhj65unf0ukirw.png"><br><br>  E como resultado dessa opera√ß√£o de mudan√ßa, o pr√≥prio valor alterado n√£o chegar√° a lugar algum, mas a cadeia <b>ShiftOut</b> assumir√° o valor do bit mais significativo do registrador A0.  Ou seja, os dados que devem ser transmitidos.  Sob o estado do gr√°fico, pode-se ver que esse valor, que deixou a ALU na cadeia <b>ShiftOut</b> , ser√° travado no gatilho <b>CurrentBit</b> .  Deixe-me mostrar o desenho novamente para n√£o rebobinar o artigo: <br><br><img src="https://habrastorage.org/webt/3t/kq/ef/3tkqefuwb4cbt1mdx7uiqlwazjo.png"><br><br>  A transmiss√£o da segunda parte do bit come√ßa - o valor imediato √© 0 ou 1. <br><br>  Retornamos √†s instru√ß√µes para ALU.  Al√©m do que j√° foi dito, √© claro que o conte√∫do do registrador D1 ser√° novamente colocado no registrador A1 para medir novamente a dura√ß√£o do segundo ter√ßo do pulso. <br><br>  O estado <b>DataStage</b> √© muito semelhante ao estado <b>Constant1</b> .  O aut√¥mato simplesmente subtrai um de A1 e entra no pr√≥ximo estado quando atingir zero.  Deixe-me mostrar assim: <br><br><img src="https://habrastorage.org/webt/ya/ir/hs/yairhsxxk0q9jvmctsthu0lswjk.png"><br><br>  e assim: <br><br><img src="https://habrastorage.org/webt/_-/cj/k9/_-cjk95cwake-lvvpgv5p4gc33i.png"><br><br>  Depois, vem o estado do <b>Setup2</b> , cuja ess√™ncia j√° sabemos. <br><br><img src="https://habrastorage.org/webt/x6/bw/qa/x6bwqa1zi6_s0zdcazzcgcp_emw.png"><br><br>  Nesse estado, o gatilho <b>CurrentBit √©</b> zerado (uma vez que o terceiro ter√ßo do pulso ser√° transmitido, a parte de parada e sempre ser√° zero).  A ALU carrega o conte√∫do de D1 na A1.  Voc√™ pode v√™-lo em uma breve nota com seu olho treinado: <br><br><img src="https://habrastorage.org/webt/dv/pm/1q/dvpm1qqxtwut-1egggnj5mgintu.png"><br><br>  O estado de <b>Constant0 √©</b> completamente id√™ntico aos estados de <b>Constant1</b> e <b>DataStage</b> .  Subtraia a unidade de A1.  Quando o valor chegar a zero, saia para o estado <b>ShiftData</b> : <br><br><img src="https://habrastorage.org/webt/d2/bs/bx/d2bsbxn-pd5opvpeh3g8us5aqkg.png"><br><br><img src="https://habrastorage.org/webt/4i/g2/my/4ig2mytms6p5mt2_msq8cwl33hi.png"><br><br>  O estado de <b>ShiftData √©</b> mais complexo.  Nas instru√ß√µes correspondentes para ALU, as seguintes a√ß√µes s√£o executadas: <br><br><img src="https://habrastorage.org/webt/r7/hn/bx/r7hnbxsnr0ynuxfexzrlisurybi.png"><br><br>  O registro A0 √© deslocado em 1 bit e os resultados s√£o colocados novamente em A0.  Em A1, o conte√∫do de D1 √© novamente colocado para come√ßar a medir o in√≠cio da terceira para o pr√≥ximo bit de dados. <br><br>  √â melhor considerar as setas de sa√≠da levando em considera√ß√£o as prioridades, para as quais clicamos duas vezes no estado <b>ShiftData</b> . <br><br><img src="https://habrastorage.org/webt/sp/dx/f1/spdxf1xnw2j_7ytbypqrbhql6da.png"><br><br>  Se n√£o for transmitido o √∫ltimo bit (sobre como esse sinalizador √© formado, um pouco mais baixo), transferimos um para o pr√≥ximo bit do byte atual. <br><br>  Se o √∫ltimo bit for transmitido e n√£o houver dados no FIFO, iremos para o estado ocioso. <br><br>  Finalmente, se o √∫ltimo bit for transmitido, mas houver dados no FIFO, vamos para a sele√ß√£o e transmiss√£o do pr√≥ximo byte. <br><br>  Agora, sobre o contador de bits.  Existem apenas duas baterias na ALU: A0 e A1.  Eles j√° est√£o ocupados pelo registro de turno e contador de atraso, respectivamente.  Portanto, um contador de bits √© usado externamente. <br><br><img src="https://habrastorage.org/webt/dx/p2/wv/dxp2wv0kt0othgs12nwnq7anuqs.png"><br><br>  Clique duas vezes nele: <br><br><img src="https://habrastorage.org/webt/dz/tj/kz/dztjkza856xdotpsckoje-fnmzo.png"><br><br>  O valor na inicializa√ß√£o √© seis.  √â carregado usando o sinalizador <b>LoadCounter</b> descrito na se√ß√£o vari√°vel: <br><br><img src="https://habrastorage.org/webt/e3/-a/tf/e3-atfbenscj9nudppvxrab9ylg.png"><br><br>  Ou seja, quando o pr√≥ximo byte de dados √© obtido, essa constante √© carregada ao longo do caminho. <br><br>  Quando a m√°quina entra no estado <b>ShiftData</b> , o contador diminui o valor.  Quando chega a zero, o <b>TerminalCount de</b> sa√≠da √© conectado, conectado ao circuito de nossa <b>semente FinalBit</b> .  √â esse circuito que define se a m√°quina ir√° transferir o pr√≥ximo bit do byte atual ou um novo byte (bem, ou aguardar um novo pacote de dados). <br><br>  Na verdade, tudo √© da l√≥gica.  Como o sinal <b>SpaceForData</b> √© <b>gerado</b> , que define o estado da sa√≠da <b>Hungry</b> (informando √† unidade DMA que √© poss√≠vel transmitir os pr√≥ximos dados), os leitores s√£o convidados a rastrear de forma independente. <br><br><h2>  Suporte de software </h2><br>  O autor do projeto original optou por oferecer suporte de software para todo o sistema no bloco que descreve a solu√ß√£o integrada.  Deixe-me lembr√°-lo, estamos falando sobre este bloco: <br><br><img src="https://habrastorage.org/webt/pi/uz/vz/piuzvzjzbcuaqyqqlwnvrmwgh8m.png"><br><br>  Nesse n√≠vel, h√° controle sobre a unidade da biblioteca DMA e todas as partes inclu√≠das na parte UDB.  Para implementar a API, o autor do original adicionou o cabe√ßalho e os arquivos de programa: <br><br><img src="https://habrastorage.org/webt/af/2y/aw/af2yaw0qcmxmjzsevxq30sjwfc4.png"><br><br>  O formato do corpo desses arquivos deixa voc√™ triste.  Toda a culpa √© do amor dos desenvolvedores do PSoC Designer pelos "puros".  Da√≠ as terr√≠veis macros e nomes de quil√¥metros.  A organiza√ß√£o da classe em C ++ seria √∫til aqui.  Pelo menos, verificamos isso ao implementar nosso RTOS MAX: ficou bonito e conveniente.  Mas aqui voc√™ pode discutir muito, mas ter√° que usar o que deixamos de baixo.  Mostrarei apenas brevemente como √© a fun√ß√£o da API que cont√©m essas macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* `$INSTANCE_NAME`_Start(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNumberOfNeopixels, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pBuffer, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fSpeedMHz) { <span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... `$INSTANCE_NAME`_g_pFrameBuffer = NULL; if((0.3/(1.0/(fSpeedMHz))) &gt; 255) return NULL; unsigned char fCyclesOn = (unsigned char)(0.35/(1.0/(fSpeedMHz))); `$INSTANCE_NAME`_g_nFrameBufferSize = nNumberOfNeopixels*3; //Configure for 19.2 MHz operation `$INSTANCE_NAME`_Neo_BITCNT_Start(); //Counts bits in a byte //Sets bitrate frequency in number of clocks. Must be larger than largest of above two counter periods CY_SET_REG8(`$INSTANCE_NAME`_Neo_DPTH_D1_PTR, fCyclesOn+1); //Setup a DMA channel `$INSTANCE_NAME`_g_nDMA_Chan = `$INSTANCE_NAME`_DMA_DmaInitialize(`$INSTANCE_NAME`_DMA_BYTES_PER_BURST, `$INSTANCE_NAME`_DMA_REQUEST_PER_BURST, HI16(`$INSTANCE_NAME`_DMA_SRC_BASE), HI16(`$INSTANCE_NAME`_DMA_DST_BASE)); if(pBuffer == NULL) ...</span></span></code> </pre> <br>  Essas regras do jogo devem ser aceitas.  Agora voc√™ sabe de onde se inspirar ao desenvolver suas fun√ß√µes (√© melhor fazer isso no projeto original).  E prefiro falar sobre os detalhes, tomando a op√ß√£o j√° processada pelo gerador. <br><br>  Ap√≥s gerar o c√≥digo (descrito abaixo), este arquivo ser√° armazenado aqui: <br><br><img src="https://habrastorage.org/webt/b2/c_/j_/b2c_j_llpmg3yjjwirq4b3bjkag.png"><br><br>  E a vista j√° estar√° perfeitamente leg√≠vel.  At√© agora, existem duas fun√ß√µes.  O primeiro inicializa o sistema, o segundo inicia a transfer√™ncia de dados do buffer para a linha do LED. <br><br>  A inicializa√ß√£o afeta todas as partes do sistema.  H√° inicializa√ß√£o do contador de sete bits, que faz parte do sistema UDB: <br><br><pre> <code class="cpp hljs"> NP_Neo_BITCNT_Start(); <span class="hljs-comment"><span class="hljs-comment">//Counts bits in a byte</span></span></code> </pre> <br>  H√° um c√°lculo constante que deve ser carregado no registro D1 (lembro que ele define a dura√ß√£o de cada um dos terceiros bits): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fCyclesOn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(<span class="hljs-number"><span class="hljs-number">0.35</span></span>/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/(fSpeedMHz))); CY_SET_REG8(NP_Neo_DPTH_D1_PTR, fCyclesOn+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  A configura√ß√£o de um bloco DMA ocupa a maior parte dessa fun√ß√£o.  O buffer √© usado como fonte e o FIFO0 do bloco UDB √© usado como receptor (NP_Neo_DPTH_F0_PTR no registro do quil√¥metro).  O autor fez parte dessa configura√ß√£o na fun√ß√£o de transfer√™ncia de dados.  Mas, na minha opini√£o, fazer todos os c√°lculos para cada transmiss√£o √© um desperd√≠cio demais.  Especialmente quando voc√™ considera que uma das a√ß√µes dentro da fun√ß√£o parece muito, muito volumosa. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... NP_g_pFrameBuffer = NULL; NP_g_nFrameBufferSize = nNumberOfNeopixels*3; //Setup a DMA channel NP_g_nDMA_Chan = NP_DMA_DmaInitialize(NP_DMA_BYTES_PER_BURST, NP_DMA_REQUEST_PER_BURST, HI16(NP_DMA_SRC_BASE), HI16(NP_DMA_DST_BASE)); ... NP_g_nDMA_TD = CyDmaTdAllocate(); CyDmaTdSetConfiguration(NP_g_nDMA_TD, NP_g_nFrameBufferSize, CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(NP_g_nDMA_TD, LO16((uint32)NP_g_pFrameBuffer), LO16((uint32)NP_Neo_DPTH_F0_PTR)); CyDmaChSetInitialTd(NP_g_nDMA_Chan, NP_g_nDMA_TD);</span></span></code> </pre><br>  A segunda fun√ß√£o no contexto da primeira √© o topo do laconicismo.  S√≥ que o primeiro √© chamado no est√°gio de inicializa√ß√£o, quando os requisitos de desempenho s√£o bastante gratuitos.  Durante a opera√ß√£o, √© melhor n√£o desperdi√ßar ciclos do processador em algo sup√©rfluo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NP_Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NP_g_pFrameBuffer) { CyDmaChEnable(NP_g_nDMA_Chan, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Claramente, n√£o h√° funcionalidade suficiente para trabalhar com v√°rios buffers (para fornecer buffer duplo), mas, em geral, uma discuss√£o sobre a funcionalidade da API est√° al√©m do escopo do artigo.  Agora, o principal √© mostrar como adicionar suporte de software ao firmware desenvolvido.  Agora sabemos como faz√™-lo. <br><br><h2>  Gera√ß√£o de projeto </h2><br>  Ent√£o, toda a parte do firmware est√° pronta, a API √© adicionada, o que fazer a seguir?  Selecione o item de menu <b>Build-&gt; Generate Application</b> . <br><br><img src="https://habrastorage.org/webt/b-/5d/yv/b-5dyvvwubusbcm5f4xzy7bhie4.png"><br><br>  Se tudo der certo, voc√™ pode abrir a guia <b>Resultados</b> e ver o arquivo com a extens√£o <b>rpt</b> . <br><br><img src="https://habrastorage.org/webt/d2/5e/4d/d25e4d3xlv845numi21z2wzxzba.png"><br><br>  Ele mostra quantos recursos do sistema foram usados ‚Äã‚Äãna implementa√ß√£o do firmware. <br><br><img src="https://habrastorage.org/webt/bv/mm/yn/bvmmynvgxcssd33wk-aetjwwbd4.png"><br><br><img src="https://habrastorage.org/webt/wr/_u/mo/wr_umoub3comqr_3v4qxcqbhpwi.png"><br><br>  Quando comparo os resultados com os do projeto original, minha alma fica mais quente. <br><br>  Agora v√° para a guia <b>Origem</b> e comece a trabalhar com a parte do software.  Mas isso j√° √© trivial e n√£o requer explica√ß√µes especiais. <br><br><img src="https://habrastorage.org/webt/w4/d6/d5/w4d6d5fhjcllllxyqtjva7j-upo.png"><br><br><h2>  Conclus√£o </h2><br>  Espero que, a partir deste exemplo, os leitores tenham aprendido algo novo e interessante sobre o trabalho pr√°tico com blocos UDB.  Tentei me concentrar em uma tarefa espec√≠fica (controle de LED), bem como na metodologia de design, pois precisava compreender alguns aspectos que eram √≥bvios para os especialistas.  Eu tentei marc√°-los enquanto as mem√≥rias da miss√£o s√£o frescas.  Quanto ao problema resolvido, os diagramas de tempo para mim n√£o eram t√£o ideais quanto os do autor do desenvolvimento original, mas se encaixavam perfeitamente nas toler√¢ncias definidas na documenta√ß√£o para os LEDs, e os recursos do sistema eram significativamente menores. <br><br>  De fato, isso √© apenas parte das informa√ß√µes n√£o padr√£o encontradas.  Em particular, na maioria dos materiais, pode parecer que o UDB funcione bem apenas com dados seriais, mas n√£o √© assim.  Nota de aplica√ß√£o encontrada, que mostra brevemente como voc√™ pode conduzir e dados paralelos.  Poder√≠amos considerar exemplos espec√≠ficos com base nessas informa√ß√µes (no entanto, n√£o ser√° poss√≠vel ofuscar o FX2LP, outro controlador do Cypress: o PSoC tem uma velocidade de barramento USB mais baixa). <br><br>  Minha cabe√ßa est√° girando id√©ias sobre como resolver o problema de "piscar" uma impressora 3D, que h√° muito me atormenta.  L√°, interrup√ß√µes no uso de motores de passo consomem apenas uma porcentagem insana do tempo da CPU.  Em geral, falei muito sobre interrup√ß√µes e tempo do processador em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre o RTOS MAX</a> .  Existem estimativas de que, para a manuten√ß√£o de motores de passo, √© poss√≠vel levar todas as cabanas tempor√°rias completamente para o UDB, deixando ao processador uma tarefa puramente computacional, sem medo de que ele n√£o tenha tempo para fazer isso em um intervalo de tempo dedicado. <br><br>  Mas essas coisas s√≥ podem ser fundamentadas se o t√≥pico for interessante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429882/">https://habr.com/ru/post/pt429882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429866/index.html">Como: Termos de TI em ingl√™s</a></li>
<li><a href="../pt429872/index.html">Gera√ß√£o de ambiente baseado em som e m√∫sica no Unity3D</a></li>
<li><a href="../pt429876/index.html">Pesquisadores superaram os bloqueadores de an√∫ncios mais poderosos, a guerra de formatos est√° chegando</a></li>
<li><a href="../pt429878/index.html">Por que com o crescimento da empresa, os desenvolvedores que estavam na vanguarda est√£o "exagerados"</a></li>
<li><a href="../pt429880/index.html">Pix4D - de fotos a medi√ß√µes</a></li>
<li><a href="../pt429884/index.html">Confer√™ncia PROSTOR 2018: perguntas e respostas sobre o futuro do armazenamento</a></li>
<li><a href="../pt429888/index.html">Calculadora baseada em pilha na placa FPGA do Cyclone IV</a></li>
<li><a href="../pt429890/index.html">Semin√°rio on-line aberto "Redes advers√°rias generativas"</a></li>
<li><a href="../pt429892/index.html">xonsh - python como uma substitui√ß√£o de shell</a></li>
<li><a href="../pt429894/index.html">Usando um olho de peixe em um Raspberry Pi 3 com ROS - Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>