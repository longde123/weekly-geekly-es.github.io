<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏠 👆🏻 🍡 Comment rendre les fonctions Python encore meilleures ⛪️ 🙏🏽 📌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En fait, le titre de ce merveilleux article de Jeff Knapp, auteur de " Writing Idiomatic Python " reflète pleinement son essence. Lisez attentivement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rendre les fonctions Python encore meilleures</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426381/">  En fait, le titre de ce merveilleux article de Jeff Knapp, auteur de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Writing Idiomatic Python</a> " reflète pleinement son essence.  Lisez attentivement et n'hésitez pas à commenter. <br><br>  Comme nous ne voulions vraiment pas laisser le terme important en lettres latines dans le texte, nous nous sommes permis de traduire le mot "docstring" par "docstring", après avoir découvert ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">terme</a> dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plusieurs</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sources en</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langue russe</a> . <br><a name="habracut"></a><br>  En Python, comme dans la plupart des langages de programmation modernes, une fonction est la principale méthode d'abstraction et d'encapsulation.  En tant que développeur, vous avez probablement déjà écrit des centaines de fonctions.  Mais fonctions à fonctions - discorde.  De plus, si vous écrivez de "mauvaises" fonctions, cela affectera immédiatement la lisibilité et la prise en charge de votre code.  Alors, qu'est-ce qu'une «mauvaise» fonction et, surtout, comment en faire une «bonne»? <br><br><h3>  Actualiser le sujet </h3><br>  Les mathématiques regorgent de fonctions, mais il est difficile de les rappeler.  Revenons donc à notre discipline préférée: l'analyse.  Vous avez probablement vu des formules comme <code>f(x) = 2x + 3</code> .  Il s'agit d'une fonction appelée <code>f</code> qui prend un argument <code>x</code> puis «retourne» deux fois <code>x + 3</code> .  Bien qu'il ne soit pas trop similaire aux fonctions auxquelles nous sommes habitués en Python, il est complètement similaire au code suivant: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>*x + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Les fonctions existent depuis longtemps en mathématiques, mais en informatique elles sont complètement transformées.  Cependant, ce pouvoir n'est pas donné en vain: vous devez passer divers pièges.  Voyons ce que devrait être une «bonne» fonction et quelles sont les «cloches et sifflets» typiques des fonctions qui peuvent nécessiter une refactorisation. <br><br><h3>  Secrets de bonne fonction </h3><br>  Qu'est-ce qui distingue une «bonne» fonction Python d'une fonction médiocre?  Vous serez surpris du nombre d'interprétations autorisées par le mot «bon».  Dans le cadre de cet article, je considérerai la fonction Python «bonne» si elle satisfait la <i>plupart des</i> éléments de la liste suivante (parfois, il n'est pas possible de compléter tous les éléments pour une fonction particulière): <br><br><ul><li>  Il est clairement nommé </li><li>  Conforme au principe du devoir unique </li><li>  Contient Dock </li><li>  Renvoie une valeur </li><li>  Ne comprend pas plus de 50 lignes </li><li>  Elle est idempotente et, si possible, pure </li></ul><br>  Pour beaucoup d'entre vous, ces exigences peuvent sembler excessivement sévères.  Cependant, je vous le promets: si vos fonctions respectent ces règles, elles se révéleront si belles qu'elles transperceront même une licorne avec une larme.  Ci-dessous, je vais consacrer une section à chacun des éléments de la liste ci-dessus, puis je terminerai l'histoire en racontant comment ils s'harmonisent les uns avec les autres et aident à créer de bonnes fonctions. <br><br>  <b>Nommer</b> <br><br>  Voici ma citation préférée à ce sujet, souvent attribuée à tort à Donald, mais appartenant en fait à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phil Carleton</a> : <br><blockquote>  L'informatique présente deux défis: l'invalidation du cache et la dénomination. </blockquote>  Aussi stupide que cela puisse paraître, la dénomination est vraiment une chose délicate.  Voici un exemple d'un "mauvais" nom de fonction: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_knn_from_df</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Maintenant, de mauvais noms me viennent presque partout, mais cet exemple est tiré du domaine de la science des données (plus précisément, de l'apprentissage automatique), où les praticiens écrivent généralement du code dans un cahier Jupyter, puis essaient d'assembler un programme digestible à partir de ces cellules. <br><br>  Le premier problème avec le nom de cette fonction est qu'elle utilise des abréviations.  <b>Il est préférable d'utiliser des mots anglais complets plutôt que des abréviations et des abréviations peu connues</b> .  La seule raison pour laquelle je veux raccourcir les mots est de ne pas perdre de temps à taper trop de texte, mais <i>tout éditeur moderne a une fonction de saisie semi-automatique</i> , vous devez donc taper le nom complet de la fonction une seule fois.  L'abréviation est un problème, car elle est souvent spécifique à un domaine.  Dans le code ci-dessus, <code>knn</code> signifie «K-voisins les plus proches» et <code>df</code> signifie «DataFrame», une structure de données couramment utilisée dans la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pandas</a> .  Si un programmeur qui ne connaît pas ces abréviations lit le code, il ne comprendra presque rien dans le nom de la fonction. <br><br>  Il existe deux autres défauts mineurs dans le nom de cette fonction.  Premièrement, le mot <code>"get"</code> redondant.  Dans la plupart des fonctions nommées avec compétence, il est immédiatement clair que cette fonction renvoie quelque chose, qui se reflète spécifiquement dans le nom.  L'élément <code>from_d</code> f n'est pas non plus nécessaire.  Soit dans le dock des fonctions, soit (s'il est à la périphérie) dans l'annotation de type, le type du paramètre sera décrit si ces informations <i>ne sont pas déjà évidentes d'après le nom du paramètre</i> . <br><br>  Alors, comment renommer cette fonctionnalité?  Juste: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k_nearest_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataframe)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Maintenant, même un profane comprend ce qui est calculé dans cette fonction, et le nom du paramètre <code>(dataframe)</code> ne laisse aucun doute quant à l'argument qui doit lui être transmis. <br><br><h3>  Responsabilité exclusive </h3><br>  En développant l'idée de Bob Martin, je dirai que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de la responsabilité exclusive</a> s'applique non moins aux fonctions que les classes et les modules (à propos desquels M. Martin a écrit à l'origine).  Selon ce principe (dans notre cas), une fonction devrait avoir une seule responsabilité.  Autrement dit, elle doit faire une et une seule chose.  L'une des raisons les plus convaincantes pour cela: si une fonction ne fait qu'une chose, alors elle devra être réécrite dans le seul cas: si cette chose doit être faite d'une nouvelle manière.  Il devient également clair quand une fonction peut être supprimée;  si, en apportant des modifications ailleurs, nous comprenons que le seul devoir d'une fonction n'est plus pertinent, alors nous nous en débarrasserons simplement. <br><br>  Il vaut mieux donner un exemple.  Voici une fonction qui fait plus d'une «chose»: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_stats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list_of_numbers)</span></span></span><span class="hljs-function">:</span></span> sum = sum(list_of_numbers) mean = statistics.mean(list_of_numbers) median = statistics.median(list_of_numbers) mode = statistics.mode(list_of_numbers) print(<span class="hljs-string"><span class="hljs-string">'-----------------Stats-----------------'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'SUM: {}'</span></span>.format(sum) print(<span class="hljs-string"><span class="hljs-string">'MEAN: {}'</span></span>.format(mean) print(<span class="hljs-string"><span class="hljs-string">'MEDIAN: {}'</span></span>.format(median) print(<span class="hljs-string"><span class="hljs-string">'MODE: {}'</span></span>.format(mode)</code> </pre> <br>  A savoir, deux: calcule un ensemble de statistiques sur une liste de nombres et les affiche dans <code>STDOUT</code> .  Une fonction viole une règle: il doit y avoir une seule raison spécifique pour laquelle elle doit être modifiée.  Dans ce cas, il y a deux raisons évidentes pour lesquelles cela est nécessaire: soit vous devez calculer des statistiques nouvelles ou différentes, soit vous devez changer le format de sortie.  Par conséquent, il est préférable de réécrire cette fonction sous la forme de deux fonctions distinctes: l'une effectuera les calculs et renverra leurs résultats, et l'autre recevra ces résultats et les affichera dans la console.  <i>Une fonction (ou plutôt, elle a deux responsabilités) avec des abats donne le mot <b>et</b> son nom</i> . <br><br>  Cette séparation simplifie également considérablement le test de la fonction et vous permet également non seulement de la diviser en deux fonctions au sein du même module, mais même de séparer ces deux fonctions en modules complètement différents, le cas échéant.  Cela contribue en outre à des tests plus propres et simplifie la prise en charge du code. <br><br>  En fait, les fonctions qui effectuent exactement deux choses sont rares.  Plus souvent, vous rencontrez des fonctions qui font beaucoup, beaucoup plus d'opérations.  Encore une fois, pour des raisons de lisibilité et de testabilité, ces fonctions "multipostes" devraient être divisées en tâches simples, chacune contenant un seul aspect du travail. <br><br><h3>  Docstrings </h3><br>  Il semblerait que tout le monde soit conscient qu'il existe un document <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP-8</a> qui donne des recommandations sur le style du code Python, mais il y a beaucoup moins de personnes parmi nous qui connaissent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP-257</a> , dans lesquelles les mêmes recommandations sont données concernant les cordes d'ancrage.  Afin de ne pas relire le contenu du PEP-257, je vous envoie vous-même ce document - à lire pendant votre temps libre.  Cependant, ses principales idées sont les suivantes: <br><br><ul><li>  Chaque fonction a besoin d'une chaîne doc. </li><li>  Il doit respecter la grammaire et la ponctuation;  écrire des phrases complètes </li><li>  La docstring commence par une brève description (en une phrase) de ce que fait la fonction. </li><li>  La docstring est formulée dans un style prescriptif plutôt que descriptif </li></ul><br>  Tous ces points sont faciles à suivre lors de l'écriture de fonctionnalités.  L'écriture de docstrings devrait devenir une habitude, et essayez de les écrire avant de continuer avec le code de la fonction elle-même.  Si vous ne pouvez pas écrire une chaîne de document claire décrivant la fonction, c'est une bonne raison de réfléchir à la raison pour laquelle vous écrivez cette fonction. <br><br><h3>  Valeurs de retour </h3><br>  Les fonctions peuvent (et <i>doivent</i> ) <i>être</i> interprétées comme de petits programmes autonomes.  Ils prennent des informations sous forme de paramètres et renvoient le résultat.  Bien entendu, les paramètres sont facultatifs.  <i>Mais les valeurs de retour sont requises du point de vue de la structure interne de Python</i> .  Si vous essayez même d'écrire une fonction qui ne renvoie pas de valeur, vous ne pouvez pas.  Si la fonction ne retourne même pas de valeurs, alors l'interpréteur Python la "forcera" à retourner <code>None</code> .  Ne croyez pas?  Essayez-le vous-même: <br><br><pre> <code class="python hljs">❯ python3 Python <span class="hljs-number"><span class="hljs-number">3.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (default, Jul <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">55</span></span>) [Clang <span class="hljs-number"><span class="hljs-number">9.1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (clang<span class="hljs-number"><span class="hljs-number">-902.0</span></span><span class="hljs-number"><span class="hljs-number">.39</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>)] on darwin Type <span class="hljs-string"><span class="hljs-string">"help"</span></span>, <span class="hljs-string"><span class="hljs-string">"copyright"</span></span>, <span class="hljs-string"><span class="hljs-string">"credits"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"license"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> ... print(a + b) ... &gt;&gt;&gt; b = add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; b &gt;&gt;&gt; b <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Comme vous pouvez le voir, la valeur de <code>b</code> est essentiellement <code>None</code> .  Ainsi, même si vous écrivez une fonction sans instruction de retour, elle renverra toujours quelque chose.  Et ça devrait.  Après tout, c'est un petit programme, non?  Quelle est l'utilité des programmes dont il n'y a pas de conclusion - et donc il est impossible de juger si ce programme a été exécuté correctement?  Mais surtout, comment allez-vous <i>tester</i> un tel programme? <br><br>  Je n'ai même pas peur de dire ce qui suit: chaque fonction doit renvoyer une valeur utile, au moins pour des raisons de testabilité.  Le code que j'écris doit être testé (ce n'est pas discuté).  Imaginez à quel point les tests maladroits de la fonction d' <code>add</code> ci-dessus peuvent se révéler (indice: vous devrez rediriger les entrées / sorties, après quoi tout ira mal).  De plus, en renvoyant une valeur, nous pouvons enchaîner des méthodes et donc écrire du code comme ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'foo.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.strip().lower().endswith(<span class="hljs-string"><span class="hljs-string">'cat'</span></span>): <span class="hljs-comment"><span class="hljs-comment"># ...     - </span></span></code> </pre> <br>  Chaîne <code>if line.strip().lower().endswith('cat'):</code> fonctionne car chacune des méthodes de chaîne ( <code>strip()</code> , <code>lower()</code> , <code>endswith()</code> ) renvoie une chaîne suite à l'appel de la fonction. <br><br>  Voici quelques raisons courantes qu'un programmeur peut vous donner pour expliquer pourquoi une fonction qu'il écrit ne renvoie pas de valeur: <br><blockquote>  «C'est juste [une sorte d'opération liée à l'entrée / sortie, par exemple, le stockage d'une valeur dans une base de données].  Ici, je ne peux rien rendre utile. » </blockquote>  Je ne suis pas d'accord.  La fonction peut renvoyer True si l'opération s'est terminée avec succès. <br><blockquote>  "Ici, nous modifions l'un des paramètres disponibles, nous l'utilisons comme paramètre de référence." "" </blockquote>  Voici deux points.  Tout d'abord, faites de votre mieux pour ne pas le faire.  Deuxièmement, fournir une fonction avec une sorte d'argument pour découvrir qu'elle a changé est surprenant au mieux, et tout simplement dangereux au pire.  Au lieu de cela, comme avec les méthodes de chaîne, essayez de renvoyer une nouvelle instance du paramètre qui reflète déjà les modifications qui lui sont appliquées.  Même si cela ne fonctionne pas, étant donné que la création d'une copie de certains paramètres est lourde de coûts excessifs, vous pouvez toujours revenir à l'option «Retourner <code>True</code> si l'opération s'est terminée avec succès» proposée ci-dessus. <br><blockquote>  «Je dois renvoyer plusieurs valeurs.  Il n'y a pas de valeur unique qu'il serait souhaitable dans ce cas de restituer. » </blockquote>  Cet argument est un peu tiré par les cheveux, mais je l'ai entendu.  La réponse, bien sûr, est précisément ce que l'auteur voulait faire - mais ne savait pas comment: <i>utiliser un tuple pour renvoyer plusieurs valeurs</i> . <br><br>  Enfin, l'argument le plus fort selon lequel il vaut mieux renvoyer une valeur utile dans tous les cas est que l'appelant peut toujours à juste titre ignorer ces valeurs.  En bref, renvoyer une valeur à partir d'une fonction est presque certainement une bonne idée, et il est très peu probable que nous endommagions quoi que ce soit de cette manière, même dans les bases de code existantes. <br><br><h3>  Longueur de fonction </h3><br>  J'ai admis plus d'une fois que je suis assez stupide.  Je peux garder environ trois choses en tête en même temps.  Si vous me laissez lire la fonction 200 lignes et demandez ce qu'elle fait, je vais probablement la regarder pendant au moins 10 secondes.  <b>La longueur d'une fonction affecte directement sa lisibilité et donc son support</b> .  Par conséquent, essayez de garder vos fonctions courtes.  50 lignes - une valeur prise complètement au plafond, mais cela me semble raisonnable.  (J'espère) que la plupart des fonctions que vous écrivez seront beaucoup plus courtes. <br><br>  Si une fonction est conforme au principe de responsabilité unique, elle sera probablement suffisamment brève.  S'il est en train de lire ou idempotent (nous en parlerons) ci-dessous - alors, probablement, cela se révélera également court.  Toutes ces idées sont harmonieusement combinées les unes aux autres et aident à écrire du code propre et bon. <br><br>  Que faire si votre fonction est trop longue?  <b>REFACTOR!</b>  Vous devrez probablement refaire tout le temps, même si vous ne connaissez pas le terme.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le refactoring</a> consiste simplement à changer la structure d'un programme, sans changer son comportement.  Par conséquent, extraire plusieurs lignes de code d'une fonction longue et les transformer en fonction indépendante est l'un des types de refactoring.  Il s'avère que c'est également le moyen le plus courant et le plus rapide de raccourcir de manière productive les fonctions longues.  Comme vous donnez à ces nouvelles fonctions des noms appropriés, le code résultant est beaucoup plus facile à lire.  J'ai écrit un livre entier sur le refactoring (en fait, je le fais tout le temps), donc je ne vais pas entrer dans les détails ici.  Sachez simplement que si vous avez une fonction trop longue, vous devez la refactoriser. <br><br><h3>  Idempotence et propreté fonctionnelle </h3><br>  Le titre de cette section peut sembler un peu intimidant, mais conceptuellement, la section est simple.  Une fonction idempotente avec le même ensemble d'arguments renvoie toujours la même valeur, quel que soit le nombre de fois où elle est appelée.  Le résultat ne dépend pas de variables non locales, de la variabilité des arguments ou des données provenant des flux d'entrée / sortie.  La fonction <code>add_three(number)</code> suivante est idempotente: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Quel que soit le nombre de fois que nous appelons <code>add_three(7)</code> , la réponse sera toujours 10. Mais un autre cas est une fonction qui n'est pas idempotente: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" 3 + ,  ."""</span></span> number = int(input(<span class="hljs-string"><span class="hljs-string">'Enter a number: '</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Cette fonction franchement artificielle n'est pas idempotente, car la valeur de retour de la fonction dépend de l'entrée / sortie, à savoir du nombre entré par l'utilisateur.  Bien sûr, avec différents appels à <code>add_three()</code> valeurs de retour seront différentes.  Si nous appelons cette fonction deux fois, l'utilisateur dans le premier cas peut entrer 3 et dans le second - 7, puis deux appels à <code>add_three()</code> respectivement 6 et 10. <br><br>  En dehors de la programmation, il existe également des exemples d'idempotence - par exemple, le bouton haut de l'ascenseur est conçu selon ce principe.  En appuyant dessus pour la première fois, nous «informons» l'ascenseur que nous voulons monter.  Étant donné que le bouton est idempotent, peu importe combien vous appuyez dessus plus tard, rien de mauvais ne se produira.  Le résultat sera toujours le même. <br><br><h3>  Pourquoi l'idempotence est si importante </h3><br>  Prise en charge de la testabilité et de l'utilisabilité.  Les fonctions idempotentes sont faciles à tester, car elles sont garanties de retourner le même résultat dans tous les cas si vous les appelez avec les mêmes arguments.  Le test revient à vérifier qu'avec une variété d'appels, la fonction renvoie toujours la valeur attendue.  De plus, ces tests seront rapides: la vitesse des tests est un problème important qui est souvent négligé dans les tests unitaires.  Et la refactorisation lorsque vous travaillez avec des fonctions idempotentes est généralement une marche facile.  Peu importe la façon dont vous changez le code en dehors de la fonction - le résultat de l'appel avec les mêmes arguments sera toujours le même. <br><br><h3>  Qu'est-ce qu'une fonction «pure»? </h3><br>  En programmation fonctionnelle, une fonction est considérée comme pure si, d'une <i>part</i> , elle est idempotente, et d' <i>autre part</i> , elle ne provoque pas les <b>effets secondaires observés</b> .  N'oubliez pas: une fonction est idempotente si elle retourne toujours le même résultat avec un ensemble d'arguments spécifique.  Cependant, cela ne signifie pas que la fonction ne peut pas affecter d'autres composants - par exemple, des variables non locales ou des flux d'entrée / sortie.  Par exemple, si la version idempotente de la fonction <code>add_three(number)</code> ci-dessus <code>add_three(number)</code> le résultat à la console, puis le renvoie uniquement, il sera toujours considéré comme idempotent, car lorsqu'il accède au flux d'entrée / sortie, cette opération d'accès n'affecte pas la valeur renvoyée de la fonction.  L'appel <code>print()</code> n'est qu'un <i>effet secondaire</i> : interaction avec le reste du programme ou du système en tant que tel, se produisant avec la valeur de retour. <br><br>  Développons un peu notre exemple avec <code>add_three(number)</code> .  Vous pouvez écrire le code suivant pour déterminer combien de fois <code>add_three(number)</code> a été appelé: <br><br><pre> <code class="python hljs">add_three_calls = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> add_three_calls print(<span class="hljs-string"><span class="hljs-string">f'Returning </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{number + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">'</span></span>) add_three_calls += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""",     *add_three*."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add_three_calls</code> </pre> <br>  Maintenant, nous exécutons la sortie vers la console (c'est un effet secondaire) et modifions la variable non locale (un autre effet secondaire), mais comme aucune de ces valeurs n'affecte la valeur retournée par la fonction, elle est de toute façon idempotente. <br><br>  La fonction pure n'a pas d'effets secondaires.  Non seulement il n'utilise pas de "données externes" lors du calcul de la valeur, mais n'interagit pas avec le reste du programme / système, calcule et renvoie uniquement la valeur spécifiée.  Par conséquent, bien que notre nouvelle définition de <code>add_three(number)</code> reste idempotente, cette fonction n'est plus pure. <br><br>  Dans les fonctions pures, il n'y a aucune instruction de journalisation ni appel <code>print()</code> .  Lorsqu'ils travaillent, ils n'accèdent pas à la base de données et n'utilisent pas de connexions Internet.  N'accédez pas et ne modifiez pas les variables non locales.  <b>Et n'appelez pas d'autres fonctions non pures</b> . <br><br>  En bref, ils n'ont pas "une action terrible à long terme", comme le disent les mots d'Einstein (mais dans le contexte de l'informatique, pas de la physique).  Ils n'altèrent en rien le reste du programme ou du système.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programmation impérative</a> (ce que vous faites lorsque vous écrivez du code en Python), ces fonctions sont les plus sûres.  Ils sont connus pour leur testabilité et leur facilité de support;  de plus, comme elles sont idempotentes, le test de telles fonctions est garanti aussi rapide que leur exécution.  Les tests eux-mêmes sont également simples: vous n'avez pas besoin de vous connecter à la base de données ou de simuler des ressources externes, de préparer la configuration initiale du code et, à la fin du travail, vous n'avez rien à nettoyer. <br><br>  Honnêtement, l'idempotence et la propreté sont très souhaitables, mais pas obligatoires.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, nous aimerions écrire uniquement des fonctions pures ou idempotentes, en tenant compte de tous les avantages ci-dessus, mais ce n'est pas toujours possible. </font><font style="vertical-align: inherit;">Le but, cependant, est d'apprendre à écrire du code, en évitant naturellement les effets secondaires et les dépendances externes. </font><font style="vertical-align: inherit;">Ainsi, chaque ligne de code que nous écrivons deviendra plus facile à tester, même si nous ne pouvons pas gérer avec uniquement des fonctions propres ou idempotentes.</font></font><br><br><h3>  Conclusion </h3><br>  C’est tout. ,     –   .          . ,   .    –    !          . ,  ,   ,       « ».     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426381/">https://habr.com/ru/post/fr426381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426371/index.html">Résumé audio: 17 documents et guides pratiques sur le thème de l'acoustique professionnelle</a></li>
<li><a href="../fr426373/index.html">Création de fonctions dans la console. Partie 1</a></li>
<li><a href="../fr426375/index.html">Analyse technologique: où commencer à travailler sur le paysage des brevets</a></li>
<li><a href="../fr426377/index.html">Jeu utilisant des graphiques mathématiques au lieu de graphiques</a></li>
<li><a href="../fr426379/index.html">Débarrassé des illusions</a></li>
<li><a href="../fr426385/index.html">Pourquoi vous ne devriez pas apprendre l'anglais académique</a></li>
<li><a href="../fr426387/index.html">Graphisme dans Julia. Motifs étranges, réflexion d'un triangle à partir d'une ligne droite et construction des normales d'un chat sphérique dans le vide</a></li>
<li><a href="../fr426389/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 334 (7-14 octobre 2018)</a></li>
<li><a href="../fr426391/index.html">PHP Digest n ° 141 (du 1er au 15 octobre 2018)</a></li>
<li><a href="../fr426395/index.html">Des frais pour les marchandises des magasins en ligne étrangers seront facturés au moment de l'achat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>