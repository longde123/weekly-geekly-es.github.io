<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûñ ‚úçüèæ üïì El hilo de Ariadne: c√≥mo enamorarse de JSR-133. Informe Yandex üôç üéÇ üõ∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los procesadores multin√∫cleo son comunes. Tarde o temprano, cualquier programador pr√°ctico tendr√° que entrar en el laberinto de la programaci√≥n multip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El hilo de Ariadne: c√≥mo enamorarse de JSR-133. Informe Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/477074/">  Los procesadores multin√∫cleo son comunes.  Tarde o temprano, cualquier programador pr√°ctico tendr√° que entrar en el laberinto de la programaci√≥n multiproceso y encontrarse con los "monstruos" que lo habitan.  Hablemos sobre d√≥nde comenzar de esta manera y qu√© herramientas y enfoques ayudar√°n a salir victoriosos.  Hice este informe a futuros participantes en la <a href="https://ya.cc/7w_Dq">pasant√≠a de</a> Yandex durante todo el <a href="https://ya.cc/7w_Dq">a√±o</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/veYXsOlYb2A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Me llamo Seva Minkov.  Trabajo en el departamento de infraestructura en la nube del departamento de b√∫squeda.  Principalmente trato con el backend.  Escribo en diferentes idiomas, pero la mayor√≠a de las veces es Java y los idiomas que se ejecutan en la m√°quina virtual Java (JVM). <br><a name="habracut"></a><br>  Nuestro equipo est√° desarrollando una nube interna en la que se lanzan casi todos los servicios de Yandex, tanto conocidos p√∫blicamente como Search, Mail y Alice, as√≠ como varios servicios internos, m√°quinas virtuales, as√≠ como tareas MapReduce de corta duraci√≥n y tareas de aprendizaje autom√°tico. <br><br>  Nuestra nube no es est√°tica: la empresa est√° creciendo, la cantidad de servicios y los recursos que consumen est√°n aumentando.  Y nuestro equipo a menudo enfrenta los desaf√≠os de escalar y mejorar el rendimiento.  Logramos esto mediante el uso de todas las herramientas disponibles, incluida la escala vertical, es decir, acelerando los componentes individuales del sistema hasta reescribir algunos algoritmos de un solo subproceso para que funcionen m√°s r√°pido.  Hacemos escalado horizontal: trituramos el sistema en partes peque√±as para lograr un mejor rendimiento al agregar servidores, procesadores, n√∫cleos, etc. <br><br>  Y la programaci√≥n multiproceso nos ayuda mucho en esto.  Hablaremos de √©l hoy: de d√≥nde vino, por qu√© es relevante;  qu√© es un modelo de memoria y c√≥mo se representa generalmente en Java.  Hablaremos de algunos aspectos pr√°cticos sobre c√≥mo probar sus aplicaciones y verificar su correcci√≥n. <br><br><img src="https://habrastorage.org/webt/me/f6/9z/mef69z0p-acv-chewvn7tuhphpk.jpeg"><br><br>  Para comenzar, veamos este interesante cuadro, que muestra las tendencias en las caracter√≠sticas de los microprocesadores en los √∫ltimos 40 a√±os.  Hace unos 10-15 a√±os, cuando el c√©sped era m√°s verde y los procesadores ten√≠an un solo subproceso, un programador ordinario pod√≠a escribir un programa correcto de un solo subproceso y luego confiar en la ley emp√≠rica de Moore.  √âl dice que los procesadores son dos veces m√°s r√°pidos cada dos a√±os.  Como puede ver, en alg√∫n lugar alrededor de 2005, por varias razones, los fabricantes de microprocesadores cambiaron a una arquitectura de m√∫ltiples n√∫cleos y comenzaron a aumentar el n√∫mero de n√∫cleos l√≥gicos.  Y la ganancia de rendimiento de un solo n√∫cleo dej√≥ de obedecer la ley de Moore, y el poder de procesamiento de un n√∫cleo comenz√≥ a crecer m√°s lentamente.  Esto hizo una revoluci√≥n, y los programadores comunes tuvieron que usar programaci√≥n paralela para usar esta ganancia de rendimiento. <br><br>  Como estamos practicando, trataremos de escribir un programa simple de subprocesos m√∫ltiples y veremos por ti mismo c√≥mo funciona. <br><br><img src="https://habrastorage.org/webt/rl/tv/gz/rltvgzwhsnhczo7tlpu5otwekuw.jpeg"><br><br>  Como ejemplo, tomemos una tarea bastante simple de lectura cruzada de registros.  Tengamos dos variables compartidas X e Y, primero inicializadas con el valor predeterminado (cero) y dos flujos.  Cada hilo escribe en una variable y lee otra.  En este caso, Thread1 escribe una unidad en X y lee Y. El segundo thread hace lo mismo, solo al rev√©s. <br><br>  Una implementaci√≥n simple de Java podr√≠a verse m√°s o menos as√≠. <br><br><img src="https://habrastorage.org/webt/xz/dw/8g/xzdw8gsz8vr8f2p-0dvtdr1y6qw.jpeg"><br><br>  Escribiremos la clase ReadWriteTest, tendr√° dos variables est√°ticas X e Y. Directamente en el m√©todo principal, construimos dos hilos Thread1 y Thread2, le damos a cada uno de ellos una entrada de funci√≥n lambda que se ejecutar√° en el momento en que se ejecute el hilo.  Ponga el c√≥digo de la diapositiva anterior all√≠ y comience dos hilos. <br><br>  El orden en que comienzan los hilos es, en cierto sentido, impredecible.  Depende de c√≥mo el sistema operativo subprocesos subprocesos.  En consecuencia, podemos tener diferentes versiones.  Parece entender c√≥mo funciona todo esto, tendremos que ejecutar este programa muchas veces, luego agregar el resultado y ver con qu√© frecuencia se encontrar√° esta o aquella respuesta en el programa. <br><br><img src="https://habrastorage.org/webt/ij/os/e3/ijose3q1hdbyts7brwd31pujhou.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Enlace desde la diapositiva</a></sub></sup> </h5><br>  Para no reinventar la rueda, podemos usar una herramienta preparada.  Esto se llama jcstress, la utilidad de pruebas de estr√©s de concurrencia de Java que forma parte del proyecto OpenJDK. <br><br>  Esta utilidad proporciona un marco para escribir pruebas de estr√©s.  En este caso, el c√≥digo de la diapositiva anterior se reescribe con bastante facilidad.  En primer lugar, colgaremos la anotaci√≥n jcstress Test en la clase, lo que simplemente hace que nuestros scripts de prueba sean visibles para la utilidad.  Tambi√©n lo marcamos con la clase State, que dice que la clase contiene datos que pueden cambiar: tanto modificados como le√≠dos desde diferentes flujos.  Declaramos dos m√©todos, thread1 y thread2, y los marcamos con la anotaci√≥n Actor.  La anotaci√≥n de actor significa que el m√©todo debe ejecutarse en un hilo separado.  jcstress garantiza que cada uno de estos m√©todos se ejecutar√° en un hilo separado en exactamente una instancia de la clase State.  El orden en que se lanzar√°n no se especifica espec√≠ficamente.  Y el resultado se escribir√° en alg√∫n objeto II_Result que se muestra en la diapositiva.  Podemos suponer que se trata de una tupla de dos valores num√©ricos, que se presentan solo mediante el m√©todo de inyecci√≥n de dependencia, del que Cyril habl√≥ en un informe anterior. <br><br>  Antes de comenzar esta prueba, pensemos qu√© conclusiones pueden dar los comandos y qu√© valores podemos agregar en r1 y en r2. <br><br><img src="https://habrastorage.org/webt/na/ik/dn/naikdng1aeysfm7tc0fe7drjbfs.jpeg"><br><br>  Para hacer esto, usamos el llamado modelo de alternancia.  De una forma u otra, cada una de las operaciones: lectura o escritura, se realiza en alg√∫n orden.  Basta con analizar todas estas opciones y ver qu√© resultados obtendremos. <br><br><img src="https://habrastorage.org/webt/i5/4y/fk/i54yfklqj0mjn1jjhkwhqs8vna0.jpeg"><br><br>  Supongamos que una de las posibles variantes de eventos es que el subproceso uno se ejecuta completamente antes que el segundo.  Primero, agregamos uno a X, leemos cero desde Y, ya que no hab√≠a entradas.  Luego escribieron uno en Y y leyeron uno en X, ya que la primera transmisi√≥n ya hab√≠a logrado hacer esto. <br><br>  La primera respuesta es cero uno. <br><br><img src="https://habrastorage.org/webt/ot/7p/ax/ot7paxx6szikzgwp9xjiusgnfny.jpeg"><br><br>  La segunda variante del desarrollo de eventos es exactamente lo contrario: la secuencia dos se ejecut√≥ antes que la secuencia uno. <br><br><img src="https://habrastorage.org/webt/_r/b5/sg/_rb5sgbawfh8cczgwyz9yzomji8.jpeg"><br><br>  En consecuencia, obtenemos un resultado espejo de un cero. <br><br><img src="https://habrastorage.org/webt/ja/ft/fi/jaftfi3gbc6cwnliw1nufl66x50.jpeg"><br><br>  Hay alrededor de cuatro opciones m√°s que dan el mismo resultado cuando tenemos la ejecuci√≥n de hilos completamente confundida.  Por ejemplo, registramos una unidad en un flujo en X, en el segundo logramos tener una unidad en Y, y calculamos uno a uno.  Luego puede ver qu√© otras opciones hay como ejercicio en el hogar. <br><br><img src="https://habrastorage.org/webt/w2/bf/tr/w2bftrexoxplrdq_v81fuxeoxic.jpeg"><br><br>  Parece que revisamos todas las opciones posibles, no hay nada m√°s.  Ejecutemos la utilidad y veamos qu√© conclusi√≥n da. <br><br><img src="https://habrastorage.org/webt/8-/2k/p7/8-2kp79h_iv-0il5eo9ftko91ye.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Enlace desde la diapositiva</a></sub></sup> </h5><br>  La salida se parece a una tabla.  La primera columna enumera los resultados que agregamos en II_Result (la utilidad ejecuta este c√≥digo millones de veces) y la cantidad de casos en los que se encontr√≥ un resultado en particular.  Pero probablemente este informe no hubiera sido si todo hubiera sido tan simple. <br><br>  De hecho, en esta conclusi√≥n tambi√©n podemos ver el resultado cero-cero, que es dif√≠cil de explicar con el modelo de alternancia.  Parece que una de las opciones posibles es que alguien directamente en el c√≥digo de transmisi√≥n tom√≥ y reorganiz√≥ las l√≠neas. <br><br>  Pensemos por qu√© sucedi√≥ y c√≥mo podemos vivir con eso.  Tambi√©n le pido que preste atenci√≥n al hecho de que la opci√≥n uno a uno se encontr√≥ espec√≠ficamente en mi m√°quina muy raramente.  De 130 millones de actuaciones, solo 154 actuaciones resultaron en uno a uno.  Y por el contrario, cero-cero ocurre muy a menudo, en casi el 30% de los casos. <br><br><img src="https://habrastorage.org/webt/kw/sb/24/kwsb24gow4nmkjkdtmhzxnnvreo.jpeg"><br><br>  Entonces, para resumir algunos resultados intermedios que todos vimos con usted.  En primer lugar, podr√≠amos entender que la interacci√≥n de los flujos a trav√©s de la memoria no es trivial.  El modelo de rotaci√≥n que utilizamos no funciona.  Vimos algunos cambios.  Podr√≠a suceder por muchas razones. <br><br>  Por ejemplo, podr√≠amos ver algunos "efectos relativistas" del hierro.  Esto puede pensarse de la siguiente manera: en un ciclo de reloj de un procesador de 3 GHz, la luz viaja unos 10 cm en el vac√≠o. El protocolo para leer y escribir en la memoria del procesador es complicado y a veces se necesitan cientos de ciclos de reloj para transferir el valor de un n√∫cleo a otro.  En consecuencia, un n√∫cleo puede parecer ver el pasado.  El resultado despu√©s del registro ocurri√≥, pero vemos el valor anterior.  Adem√°s, los procesadores tampoco se detienen y pueden cambiar las instrucciones en algunos lugares. <br><br>  Los compiladores de optimizaci√≥n modernos pueden conducir a la misma permutaci√≥n.  Para lograr el m√°ximo rendimiento de un solo subproceso, tambi√©n pueden intercambiar instrucciones para que esto no rompa la exactitud de un programa de un solo subproceso.  Pero en los programas de subprocesos m√∫ltiples puede dar lugar a efectos interesantes que hemos visto. <br><br>  Y la segunda, probablemente la conclusi√≥n principal: vimos que los programas multiproceso no est√°n determinados fundamentalmente.  Los programas de subproceso √∫nico dependen principalmente de algunos invariantes en la entrada y la salida, y son deterministas;  dado que el generador de n√∫meros aleatorios y la entrada del usuario son par√°metros de entrada. <br><br>  Esto hace las cosas muy complicadas: es dif√≠cil entender lo que hace el programa y es dif√≠cil probarlo. <br><br>  Sobre la complejidad de las pruebas, podemos agregar que el mismo resultado se encontr√≥ solo 154 veces de 130 millones de llamadas.  La probabilidad de ocurrencia de este resultado es una millon√©sima.  En producci√≥n, esto significa que dicho error puede reproducirse despu√©s de semanas.  Y ciertamente suceder√° en alg√∫n lugar el domingo por la noche, cuando no esperabas esto en absoluto. <br><br><img src="https://habrastorage.org/webt/sd/u8/hg/sdu8hgj5xiqhrnnganz3ltxzyp0.jpeg"><br><br>  Pensemos c√≥mo deber√≠amos ser y qu√© queremos generalmente de nuestra lengua para dormir tranquilo el domingo por la noche.  Primero, necesitamos una herramienta que nos permita predecir el comportamiento del programa y emitir juicios sobre su ejecuci√≥n.  En segundo lugar, necesitamos herramientas de lenguaje que nos permitan influir en las permutaciones y los efectos; pueden ser del hardware, el compilador, etc. Me gustar√≠a saber menos sobre c√≥mo funciona un procesador en particular, qu√© optimizaciones puede hacer el compilador y usar la abreviatura que vino del mundo de Java.  Escribir una vez, ejecutar en cualquier lugar: escriba una vez el c√≥digo multiproceso correcto para que funcione en todas las plataformas. <br><br><img src="https://habrastorage.org/webt/tx/lr/du/txlrdugf3x6nxzxnraij4qn9yzq.jpeg"><br><br>  Estas preguntas y requisitos que hemos enumerado surgieron en las mentes de los desarrolladores durante mucho tiempo y de los te√≥ricos y profesionales.  Como cualquier tarea compleja con un alto nivel de complejidad, se resolvi√≥ introduciendo el concepto de alguna m√°quina abstracta.  Todos nosotros, desarrolladores en lenguajes de programaci√≥n de alto nivel, no escribimos para ning√∫n hardware en particular, no para ese modelo de procesador, sino que escribimos alguna m√°quina abstracta.  Y la especificaci√≥n del lenguaje est√° dise√±ada para describir su comportamiento de tal manera que concilie estos tres mundos.  Por un lado, dejemos que los desarrolladores de compiladores y procesadores hagan sus optimizaciones y nos exploten ligeramente, programadores que ya escriben en un lenguaje en particular. <br><br>  El modelo de memoria ocupa una posici√≥n central en esta m√°quina abstracta.  Deber√≠a responder una pregunta: si leo una variable X en alguna secuencia, ¬øcu√°l de las √∫ltimas entradas puedo ver all√≠?  Se intent√≥ por primera vez formalizar el modelo de memoria en el lenguaje Java, todos los dem√°s modelos de memoria aparecieron m√°s tarde.  Digamos que C ++ 11 es casi una copia del modelo de memoria Java con algunos cambios. <br><br>  Hab√≠a varios modelos de memoria en Java.  Inicialmente, el llamado modelo de memoria "en forma de campana", fue reconocido como infructuoso, ya que obstaculiz√≥ el trabajo de los programadores que escriben en Java y prohibi√≥ algunas optimizaciones para el compilador, que son bastante apropiadas para ellos.  En consecuencia, como parte del proceso comunitario JSR-133, se escribi√≥ un modelo de memoria moderno. <br><br>  Como tenemos la escritura en forma de especificaci√≥n, intentemos analizarla y comprender lo que realmente est√° sucediendo dentro. <br><br><img src="https://habrastorage.org/webt/3f/w6/qi/3fw6qiwjhoeqgtrdn3jngdqntfs.jpeg"><br><br>  Hay algun problema  Levanta las manos, quien abri√≥ la especificaci√≥n del idioma y ley√≥ lo que estaba sucediendo all√≠.  ¬øY cu√°ntos de ustedes han le√≠do el modelo de memoria del p√°rrafo 17.4?  Una peque√±a sorpresa te espera.  La especificaci√≥n del lenguaje se describe b√°sicamente en un lenguaje bastante comprensible.  Pero el modelo de memoria est√° lleno de, digamos, algo de matem√°tica hardcore.  Hay inclusiones en griego, muchos t√©rminos matem√°ticos del cierre transitivo de la serie, la uni√≥n de dos √≥rdenes, etc. <br><br>  Lamentablemente, no hay otra manera.  La √∫nica cosa en la que puede confiar al escribir programas multiproceso es la especificaci√≥n.  Ella tendr√° que leer y entender.  Te recomiendo mucho  Adem√°s, cuando le√≠ la especificaci√≥n por primera vez, tuve esas impresiones. <br><br>  ¬øPor qu√© es tan dif√≠cil?  Fui por el camino equivocado y te advierto mucho que act√∫es como yo. <br><br>  Lo tom√©, busqu√© en Internet qu√© es un modelo de memoria.  Encontr√© un libro llamado JSR-133 Cookbook for Compiler Writers.  Ella describe c√≥mo un desarrollador de compiladores puede implementar este modelo de memoria de una manera simple.  El problema es que esta es una implementaci√≥n espec√≠fica, y no se puede usar para juzgar todo el modelo de memoria en general. <br><br>  De todos modos, intentemos hacer un peque√±o intento en las principales conclusiones que se pueden entender del modelo de memoria Java. <br><br><img src="https://habrastorage.org/webt/ii/tn/by/iitnbypnfohtdb0y3gyxuhv1fea.jpeg"><br><br>  Puede haber muchas ejecuciones de su programa multiproceso.  Nosotros mismos vimos esto en el ejemplo de nuestro programa antes.  En el ejemplo m√°s simple, ya tuvimos cuatro resultados de su implementaci√≥n.  Y la tarea del modelo de memoria Java es decir cu√°les de estas ejecuciones son correctas y cu√°les deber√≠an prohibirse.  Y postula tres cosas.  La primera es que, dentro del marco de un hilo, su tarea se ejecuta de forma pseudo-secuencial.  Esto implica que el compilador puede intercambiar operaciones, el procesador tambi√©n puede ejecutar instrucciones en paralelo, intercambiarlas.  Pero deben hacer esto para que los efectos visibles de la ejecuci√≥n de su programa sean los mismos que si se ejecutaran directamente secuencialmente. <br><br>  En segundo lugar, en el lenguaje est√°n prohibidos los llamados significados de la nada tomados de la nada.  Desafortunadamente, no tenemos tiempo para mostrarlo, pero hay casos en que el compilador realmente puede realizar una conversi√≥n tal que todo ser√° correcto en un programa de subproceso √∫nico, y es posible que tenga un registro en un programa de subproceso m√∫ltiple que no hizo. <br><br>  En consecuencia, el modelo de memoria dice que leer cualquier variable devolver√° el valor predeterminado o algunos de los resultados de la grabaci√≥n que alguna vez realiz√≥ otro comando.  Y las acciones restantes se pueden interpretar como secuenciales, si est√°n conectadas por una relaci√≥n de orden parcial que ocurre antes.  Y este es ahora el √∫nico lugar donde necesitamos matem√°ticas.  Relaci√≥n parcial, esto se debe a que no todas las operaciones de lectura, escritura de variables, est√°n conectadas por relaci√≥n.  Tiene las propiedades de reflexividad, transitividad y antisimetr√≠a. <br><br><img src="https://habrastorage.org/webt/vq/vp/11/vqvp11dmptcgzyedx4hazndvmeo.jpeg"><br><br>  Hablemos con m√°s detalle sobre lo que sucede antes que en s√≠ mismo.  La primera regla es que vincula todas las operaciones dentro de un solo hilo.  Si ha escrito dentro de un hilo que X es igual a uno, Y es igual a uno;  se afirma que las operaciones de escritura en X est√°n relacionadas con lo que sucede antes de Y. Es decir, X sucede antes de Y. Y tambi√©n vincula algunas acciones especiales, las llamadas acciones de sincronizaci√≥n.  Lea m√°s en la especificaci√≥n.  Por ejemplo, esto es escribir y leer desde una variable vol√°til, bloquear / desbloquear en un monitor, ingresar al bloque sincronizado y salir del bloque sincronizado.  Un punto muy importante es que todas las acciones de sincronizaci√≥n en su programa ven subprocesos en exactamente el mismo orden, como si se estuvieran ejecutando uno por uno. <br><br>  Y sucede antes de vincular algunos pares de estas acciones.  No importa en qu√© acciones de sincronizaci√≥n de subprocesos tengan lugar.  Es importante que pasen, por ejemplo, sobre una variable vol√°til.  La especificaci√≥n dice, digamos, que escribir en la variable vol√°til ocurre antes de cualquier otra acci√≥n posterior.  Esto se refiere precisamente a la manera en que tuvimos acciones de sincronizaci√≥n. <br><br>  Y lo m√°s importante de todo esto es que la regla sucede antes de la coherencia, que solo responde a la pregunta m√°s importante sobre el modelo de memoria.  Se puede interpretar de la siguiente manera.  Si hay una cadena de operaciones de lectura / escritura en una variable y est√°n conectadas por una cadena de relaciones anteriores, entonces la lectura definitivamente deber√≠a ver el √∫ltimo registro en esta cadena.  Si no est√° all√≠, puede ver cualquier otro valor, cualquier otro registro o valor predeterminado.  Ahora puedes exhalar, con las definiciones b√°sicas que hemos terminado. <br><br><img src="https://habrastorage.org/webt/q6/jv/qq/q6jvqqzesul_tjyflrgcuy8s__4.jpeg"><br><br>  ¬øIntentamos probar la teor√≠a en la pr√°ctica?  Tomemos un ejemplo con una lectura cruzada de registros y simplemente agreguemos el modificador vol√°til a las variables X e Y. Intentemos probar la hip√≥tesis de que ya no veremos el valor cero-cero.  Para hacer esto, solo use las reglas que expres√© anteriormente. <br><br>  Arreglaremos suceder√° antes en un hilo.  Escribir en X sucede antes de leer desde Y y en el segundo hilo.  Escribir en Y sucede antes de leer en X. <br><br>  Y luego tenemos cuatro acciones de sincronizaci√≥n: escribir en X, escribir en Y, leer desde X, leer desde Y. Pueden aparecer en alg√∫n orden, y un par puede ocurrir en dos casos. <br><br><img src="https://habrastorage.org/webt/yz/mu/vr/yzmuvrfkneks1-usipllgsgxanc.jpeg"><br><br>  Por ejemplo, escribir en X en la secuencia uno ocurri√≥ antes que leer desde X en la secuencia dos (ocurre antes de que ocurra).  Como puede ver aqu√≠, la relaci√≥n no est√° relacionada con Y. El resultado de la lectura de Y puede devolvernos el valor predeterminado o el valor que registr√≥ la segunda transmisi√≥n.  Una lectura de X siempre debe ver una unidad.  En consecuencia, nuestras opciones pueden ser cero uno, uno. <br><br><img src="https://habrastorage.org/webt/yc/zi/rm/yczirmhlmh3r0c2whc-g8dpxtvu.jpeg"><br><br>  El segundo caso es cuando surge una conexi√≥n.  Esto es lo mismo: escribir en Y sucede antes de leer desde Y. Adem√°s, no hay conexi√≥n entre X. En consecuencia, el resultado es el mismo, solo que all√≠ obtienes uno-cero, cero-uno.  Te√≥ricamente, podemos probar el comportamiento de nuestro nuevo programa. <br><br><img src="https://habrastorage.org/webt/ui/zs/7o/uizs7ojlz4smbqktuvisojvjxte.jpeg"><br><br>  Puedes comprobarlo en la pr√°ctica.  Tome y agregue la palabra clave vol√°til en nuestra prueba.  Corre y observa que, de hecho, en nuestro pa√≠s este valor nunca se reproducir√°.   happens-before ‚Äî        .         . <br><br><img src="https://habrastorage.org/webt/p8/xp/ao/p8xpaoj1prrfkwto0t3w7unlsli.jpeg"><br><br> ,        .  volatile     Z  volatile,  .   ,        Z;   ,  ,     ,     Z.        happens-before       .  ,     Z   ,        .           . <br><br>  , ,        ‚Äî       put value.    ‚Äî   get value    .   happens-before   ,       ,  put value happens-before get value.           ,        happens-before   ,   volatile,     .      ,    ,  ‚Äî put  happens-before get. <br><br><img src="https://habrastorage.org/webt/m6/br/hd/m6brhdf3iyak436nje-p-fyrq2a.jpeg"><br><br> ,    . -,  .  ,    ,    .         ,     .  ,     ,     .  ,         .    ,      ,      ,     ,       . <br><br> -,     ,  jcstress.       :     ,   JVM   .      ,        . <br><br>    ,   .  ‚Äî ¬´The Art of Multiprocessor Programming¬ª  .        ,   happens-before,  ,   . .     ‚Äî ¬´Java Concurrency in Practice¬ª  .     ,       .     ,   ,    . .    .       <a href="https://shipilev.net/"> </a> ,   performance-  Oracle,     Red Hat.      ,  Java-  ,   .        JMM. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puedes leer el blog de </font></font><a href="https://elizarov.livejournal.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ense√±√≥, en mi opini√≥n, la programaci√≥n multiproceso ITMO. </font><font style="vertical-align: inherit;">Tiene un blog ligeramente abandonado, pero puedes leerlo, buscar sus conferencias y discursos en YouTube. </font><font style="vertical-align: inherit;">En general, muy adecuado, aconsejo. </font><font style="vertical-align: inherit;">Gracias a todos.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477074/">https://habr.com/ru/post/477074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477054/index.html">Webasto anuncia sistema modular de bater√≠as automotrices</a></li>
<li><a href="../477058/index.html">Enterprise Agile Russia en Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../477060/index.html">DataArt organizar√° una conferencia abierta de Andrei Terekhov, Jefe del Departamento de Programaci√≥n del Sistema, Matmekh, Universidad Estatal de San Petersburgo</a></li>
<li><a href="../477062/index.html">C√≥mo funciona el compilador de optimizaci√≥n</a></li>
<li><a href="../477072/index.html">¬øDesarrollo de clientes o c√≥mo lanzar un producto sin fallas?</a></li>
<li><a href="../477078/index.html">WebStorm 2019.3: lanzamiento m√°s r√°pido, soporte mejorado para Vue.js y otras mejoras</a></li>
<li><a href="../477082/index.html">Congreso de EE. UU. Vs Zuckerberg: qu√© reclamos hacen los reguladores contra la libra estable de Facebook</a></li>
<li><a href="../477084/index.html">El cerebro de la empresa. Parte 2</a></li>
<li><a href="../477092/index.html">Descripci√≥n general de las herramientas de seguridad del repositorio de GitHub</a></li>
<li><a href="../477096/index.html">¬ø5G da√±ar√° nuestra salud?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>