<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¶ âŒ ğŸŒ  Pylint dari dalam ke luar. Bagaimana dia melakukannya? ğŸ•• ğŸ“ ğŸ†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berbagai pembantu dalam menulis kode keren hanya mengelilingi kita, linter, typekchera, utilitas untuk menemukan kerentanan, semua bersama kita. Kami ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pylint dari dalam ke luar. Bagaimana dia melakukannya?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433474/">  Berbagai pembantu dalam menulis kode keren hanya mengelilingi kita, linter, typekchera, utilitas untuk menemukan kerentanan, semua bersama kita.  Kami sudah terbiasa dan menggunakannya tanpa masuk ke detail seperti "kotak hitam".  Misalnya, beberapa orang memahami prinsip-prinsip Pylint, salah satu alat yang sangat diperlukan untuk mengoptimalkan dan meningkatkan kode Python. <br><br>  Tapi <strong>Maxim Mazaev</strong> tahu betapa pentingnya memahami alat-alatnya, dan dia memberi tahu kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++</a> .  Dengan menggunakan contoh nyata, ia menunjukkan bagaimana pengetahuan tentang perangkat internal Pylint dan plug-in-nya membantu mengurangi waktu peninjauan kode, meningkatkan kualitas kode, dan umumnya meningkatkan efisiensi pengembangan.  Di bawah ini adalah instruksi dekripsi. <br><br><img src="https://habrastorage.org/webt/4d/mv/i7/4dmvi7slkt32taha4ec14e8kdfg.jpeg"><br><a name="habracut"></a><br><h2>  Mengapa kita membutuhkan Pylint? <br></h2><br>  Jika Anda sudah menggunakannya, pertanyaan mungkin timbul: "Mengapa tahu apa yang ada di dalam Pylint, bagaimana pengetahuan ini bisa membantu?" <br><br>  Biasanya, pengembang menulis kode, meluncurkan linter, menerima pesan tentang apa yang harus ditingkatkan, bagaimana membuat kode lebih indah, dan membuat perubahan yang diajukan.  Sekarang kode lebih mudah dibaca dan tidak malu untuk menunjukkan kepada rekan kerja. <br><br>  Untuk waktu yang lama, mereka bekerja dengan cara yang persis sama dengan Pylint di Cyan Institute, dengan tambahan kecil: mereka mengubah konfigurasi, menghapus aturan yang tidak perlu, dan meningkatkan panjang string maksimum. <br><br>  Tetapi pada suatu saat mereka mengalami masalah, di mana saya harus menggali jauh ke dalam Pylint dan mencari tahu cara kerjanya.  Apa masalah ini dan bagaimana mengatasinya, baca terus. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZKoBZkdYLiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Maxim Mazaev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">backslash</a> ), 5 tahun dalam pengembangan, bekerja di CIAN.  Sangat mempelajari pemrograman Python, asynchrony dan fungsional. <br><br><h2>  Tentang cyan <br></h2><br>  Sebagian besar percaya bahwa CIAN adalah agen real estat dengan agen penjual dan sangat terkejut ketika mereka mengetahui bahwa alih-alih agen penjual kami memiliki programmer. <br><br>  Kami adalah perusahaan teknis di mana tidak ada agen penjual, tetapi ada banyak programmer. <br><br><ul><li>  1 juta pengguna unik per hari. </li><li>  Papan buletin terbesar untuk penjualan dan penyewaan real estat di Moskow dan St. Petersburg.  Pada 2018, mereka memasuki tingkat federal dan bekerja di seluruh Rusia. </li><li>  Hampir 100 orang di tim pengembangan, 30 di antaranya menulis kode Python setiap hari. </li></ul><br>  Setiap hari, ratusan dan ribuan baris kode baru mulai diproduksi.  Persyaratan untuk kode ini cukup sederhana: <br><br><ul><li>  Kode kualitas yang layak. </li><li>  Homogenitas gaya.  Semua pengembang harus menulis kira-kira kode yang sama, tanpa "vinaigrette" di repositori. </li></ul><br>  Untuk mencapai ini, tentu saja, Anda memerlukan peninjauan kode. <br><br><h2>  Ulasan kode <br></h2><br>  Ulasan kode dalam CIAN berlangsung dalam dua tahap: <br><br><ol><li>  Tahap pertama adalah <strong>otomatis</strong> .  Robot Jenkins menjalankan tes, menjalankan Pylint, dan memeriksa konsistensi API antara layanan microser, karena kami menggunakan layanan microser.  Jika pada tahap ini tes gagal atau linter menunjukkan sesuatu yang aneh, maka ini adalah kesempatan untuk menolak permintaan tarikan dan mengirim kode untuk revisi. <br></li><li>  Jika tahap pertama berhasil, maka yang kedua datang - persetujuan dari <strong>dua</strong> <strong>pengembang</strong> .  Mereka dapat mengevaluasi seberapa baik kode dalam hal logika bisnis, menyetujui permintaan tarik atau mengembalikan kode untuk revisi. <br></li></ol><br><h3><br>  Masalah tinjauan kode <br></h3><br>  Permintaan tarik mungkin tidak lulus ulasan kode karena: <br><br><ul><li>  kesalahan dalam logika bisnis saat pengembang memecahkan masalah secara tidak efektif atau salah; </li><li>  masalah gaya kode. </li></ul><br>  Apa yang bisa menjadi masalah gaya jika linter memeriksa kode? <br><br>  Setiap orang yang menulis dengan Python tahu bahwa ada panduan untuk menulis kode <strong>PEP-8</strong> .  Seperti standar apa pun, PEP-8 cukup umum dan bagi kami, sebagai pengembang, ini tidak cukup.  Saya ingin menentukan standar di beberapa tempat, dan memperluas di tempat lain. <br><br>  Oleh karena itu, kami membuat pengaturan internal tentang bagaimana kode seharusnya terlihat dan berfungsi, dan menyebutnya <strong>"Tolak Proposal Cian"</strong> . <br><br><img src="https://habrastorage.org/webt/u8/rk/tw/u8rktwmht5bmkqktwuoof_kbohs.png"><br><br>  â€œDecline Cian Proposalsâ€ - seperangkat aturan, sekarang ada sekitar 15. Masing-masing aturan ini adalah dasar untuk permintaan penarikan ditolak dan dikirim untuk direvisi. <br><br><h3>  Apa yang menghalangi tinjauan kode produktif? <br></h3><br><blockquote>  Ada satu masalah dengan aturan internal kita - si lemah tidak tahu tentang mereka, dan akan aneh jika dia tahu - itu adalah internal. <br></blockquote>  Pengembang yang melakukan tugas harus selalu mengingat dan mengingat aturan.  Jika dia lupa salah satu aturan, maka dalam proses peninjauan kode, pengulas akan menunjukkan masalahnya, tugasnya akan direvisi dan waktu rilis tugas akan bertambah.  Setelah selesai dan koreksi kesalahan, penguji perlu mengingat apa yang ada di tugas, untuk mengganti konteks. <br><br>  Ini menciptakan masalah bagi pengembang dan pengulas.  Akibatnya, kecepatan tinjauan kode berkurang secara kritis.  Alih-alih menganalisis logika kode, para penguji mulai menganalisis gaya visual, yaitu, mereka melakukan pekerjaan linter: mereka memindai baris kode demi baris dan mencari inkonsistensi dalam lekukan dalam format impor. <br><br>  Kami ingin menyingkirkan masalah ini. <br><br><h2>  Tapi jangan tulis kami daftar Anda? <br></h2><br>  Tampaknya masalah akan diselesaikan oleh alat yang akan tahu tentang semua perjanjian internal dan akan dapat memeriksa kode untuk implementasinya.  Jadi kita membutuhkan linter kita sendiri? <br><br>  Tidak juga.  Idenya bodoh, karena kita sudah menggunakan Pylint.  Ini adalah linter nyaman, disukai oleh pengembang dan dibangun ke dalam semua proses: ini berjalan di Jenkins, menghasilkan laporan indah yang benar-benar puas dan datang dalam bentuk komentar dalam permintaan tarik.  Semuanya baik-baik saja, <strong>linter kedua tidak diperlukan</strong> . <br><br>  Jadi bagaimana mengatasi masalah jika kita tidak ingin menulis linter kita sendiri? <br><br><h2>  Tulis Plugin Pylint <br></h2><br>  Anda dapat menulis plugin untuk Pylint, mereka disebut checker.  Di bawah setiap aturan internal, Anda dapat menulis pemeriksa Anda sendiri, yang akan memeriksanya. <br><br>  Perhatikan dua contoh biji seperti itu. <br><br><h3>  Contoh No. 1 <br></h3><br>  Pada titik tertentu, ternyata kode tersebut berisi banyak komentar dari bentuk "TODO" - berjanji untuk melakukan refactor, menghapus kode yang tidak perlu atau menulis ulang dengan indah, tetapi tidak sekarang, tetapi nanti.  Ada masalah dengan komentar seperti itu - mereka sama sekali tidak mengharuskan Anda untuk apa pun. <br><br><h4>  Masalah <br></h4><br>  Pengembang menulis janji, menghembuskan napas dan pergi dengan tenang untuk melakukan tugas selanjutnya. <br><img src="https://habrastorage.org/webt/ji/fk/js/jifkjskaly04vj5ljo74qrb0ys8.png"><br><br>  Singkatnya: <br><br><ul><li>  komentar dengan janji menggantung selama bertahun-tahun dan tidak diikuti; </li><li>  kode dikotori; </li><li>  hutang teknis telah menumpuk selama bertahun-tahun. </li></ul><br>  Misalnya, pengembang 3 tahun lalu berjanji untuk menghapus sesuatu setelah rilis berhasil, tetapi apakah rilis itu terjadi dalam 3 tahun?  Mungkin ya.  Haruskah saya menghapus kode dalam hal ini?  Ini adalah pertanyaan besar, tetapi kemungkinan besar tidak. <br><br><h4>  Solusi: tulis checker Anda untuk Pylint <br></h4><br>  Anda tidak bisa melarang pengembang untuk menulis komentar seperti itu, tetapi Anda bisa membuatnya bekerja ekstra: buat tugas di pelacak untuk menyelesaikan janji.  Maka kita pasti tidak akan melupakannya. <br><br>  Kami perlu menemukan semua komentar dari formulir TODO dan memastikan bahwa masing-masing dari mereka memiliki tautan ke tugas di Jira.  Ayo kita tulis. <br><br>  Apa itu pemeriksa dalam hal Pylint?  Ini adalah kelas yang mewarisi dari kelas dasar pemeriksa dan mengimplementasikan antarmuka tertentu. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoIssueChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> _ _implements_ _ = IRawChecker</code> </pre> <br>  Dalam kasus kami, ini adalah <strong>IRawChecker</strong> - pemeriksa "mentah". <br><br>  Pemeriksa mentah beralih pada baris file dan dapat melakukan tindakan tertentu pada sebuah baris.  Dalam kasus kami, pada setiap baris, pemeriksa akan mencari sesuatu yang mirip dengan komentar dan tautan ke tugas. <br><br>  Untuk pemeriksa, Anda perlu menentukan daftar pesan yang akan dikeluarkannya: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9999'</span></span>: (<span class="hljs-string"><span class="hljs-string">'  TODO    '</span></span>, issue-code-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-todo<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  Pesannya memiliki: <br><br><ul><li>  deskripsinya pendek dan panjang; </li><li>  kode checker dan nama mnemonic pendek yang menentukan jenis pesan apa itu. </li></ul><br>  Kode pesan memiliki bentuk "C1234", di mana: <br><br><ul><li>  Huruf pertama jelas terstandarisasi untuk berbagai jenis pesan: <strong>[C]</strong> pencegahan;  <strong>[W] mulai</strong> ;  <strong>[E]</strong> yog;  <strong>[F]</strong> atal;  <strong>[R]</strong> efactoring.  Berkat surat itu, laporan segera menunjukkan apa yang terjadi: pengingat perjanjian atau masalah fatal yang perlu segera diatasi. </li><li>  4 angka acak unik untuk Pylint. </li></ul><br>  Kode diperlukan untuk menonaktifkan pemeriksaan jika menjadi tidak perlu.  Anda dapat menulis Pylint: disable dan kode alfanumerik pendek atau nama mnemonik: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Pylint: disable=C9999 # Pylint: disable=issue-code-in-todo</span></span></code> </pre><br>  Para penulis Pylint merekomendasikan untuk meninggalkan kode alfanumerik dan menggunakan mnemonik, itu lebih visual. <br><br>  Langkah selanjutnya adalah mendefinisikan metode yang disebut <strong>process_module</strong> . <br><br><img src="https://habrastorage.org/webt/25/cg/lc/25cglcdvsxu5qwgwv6fwhmhuvyu.jpeg"><br><br>  Nama itu sangat penting.  Metode ini harus dipanggil seperti itu, karena Pylint kemudian akan memanggilnya. <br><br>  Parameter <strong>simpul</strong> diteruskan ke modul.  Dalam hal ini, tidak masalah apa itu atau tipe apa itu, penting untuk diingat bahwa node memiliki metode <strong>stream</strong> yang mengembalikan file baris demi baris. <br><br>  Anda dapat melihat file dan untuk setiap baris memeriksa komentar dan tautan ke tugas.  Jika ada komentar, tetapi tidak ada tautan, maka berikan peringatan berupa <strong>'issue-code-in-todo'</strong> dengan kode checker dan nomor baris.  Algoritma ini cukup sederhana. <br><br>  Daftarkan checker sehingga Pylint mengetahuinya.  Ini dilakukan oleh fungsi <strong>register</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter. register_checker ( TodoIssueChecker(linter) )</code> </pre><br><ul><li>  Contoh Pylint masuk ke fungsi. </li><li>  Itu memanggil metode register_checker. </li><li>  Kami melewati pemeriksa ke metode. </li></ul><br>  <strong>Poin penting:</strong> modul checker harus dalam PYTHONPATH sehingga Pylint dapat mengimpornya nanti. <br><br>  Pemeriksa terdaftar diperiksa oleh file uji dengan komentar tanpa tautan ke tugas. <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work. --load-plugins todo_checker â€¦</span></span></code> </pre><br>  Untuk pengujian, jalankan Pylint, berikan modul ke modul tersebut, gunakan parameter <strong>load-plugins</strong> untuk melewati pemeriksa, dan di dalam linter, jalankan dua fase. <br><br><h4>  Fase 1. Inisialisasi Plugin <br></h4><br><ul><li>  Semua modul dengan plugin diimpor.  Pylint memiliki checker internal dan eksternal.  Mereka semua datang bersama dan diimpor. </li><li>  Kami mendaftar - <strong>module.register (mandiri)</strong> .  Untuk setiap pemeriksa, fungsi register dipanggil, tempat instance Pylint dilewatkan. </li><li>  Pemeriksaan dilakukan: untuk validitas parameter, untuk keberadaan pesan, opsi, dan laporan dalam format yang benar. </li></ul><br><h4>  Fase 2. Mengurai kumpulan biji <br></h4><br>  Setelah fase 1, seluruh daftar berbagai jenis biji tetap: <br><br><ul><li>  Pemeriksa AST; </li><li>  Pemeriksa mentah; </li><li>  Pemeriksa token. </li></ul><br><img src="https://habrastorage.org/webt/iy/o-/e9/iyo-e93tezy3y4iczp5d8regoog.jpeg"><br><br>  Dari daftar kami memilih yang berhubungan dengan antarmuka pemeriksa mentah: kami melihat di mana checker mengimplementasikan antarmuka IRawChecker dan membawanya sendiri. <br><br>  Untuk setiap pemeriksa terpilih, panggil metode <strong>checker.process_module (modul)</strong> , dan jalankan pemeriksaan. <br><br><h4>  Hasil <br></h4><br>  Jalankan pemeriksa pada file tes lagi: <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work,  --load-plugins todo_checker : 0,0:   T0D0     (issue-code-in-todo)</span></span></code> </pre><br>  Sebuah pesan akan muncul yang menyatakan bahwa ada komentar dengan TODO dan tidak ada tautan ke tugas tersebut. <br><br>  Masalahnya terpecahkan dan sekarang dalam proses peninjauan kode, pengembang tidak perlu memindai kode dengan mata mereka, menemukan komentar, menulis pengingat kepada pembuat kode bahwa ada perjanjian dan disarankan untuk meninggalkan tautan.  Semuanya terjadi secara otomatis dan tinjauan kode sedikit lebih cepat. <br><br><h3>  Contoh No. 2. argumen-kata kunci <br></h3><br>  Ada fungsi yang mengambil argumen posisi.  Jika ada banyak argumen, maka ketika mereka memanggil fungsi, tidak begitu jelas di mana argumen itu dan mengapa itu diperlukan. <br><br><h4>  Masalah <br></h4><br>  Misalnya, kami memiliki fungsi: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, rue, <span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  Kode telah <strong>dijual</strong> dan <strong>Benar,</strong> dan tidak jelas apa artinya.  Ini jauh lebih nyaman ketika fungsi di mana ada banyak argumen akan dipanggil hanya dengan argumen bernama: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, truncate=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, cian_id=<span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  Ini adalah kode yang baik, di mana langsung jelas di mana parameternya dan kami tidak akan mengacaukan urutannya.  Mari kita coba menulis pemeriksa yang memeriksa kasus-kasus seperti itu. <br><br>  Pemeriksa "mentah" yang digunakan dalam contoh sebelumnya sangat sulit untuk ditulis untuk kasus seperti itu.  Anda dapat menambahkan ekspresi reguler super-kompleks, tetapi kode seperti itu sulit dibaca.  Adalah baik bahwa Pylint memungkinkan untuk menulis jenis pemeriksa lain berdasarkan pohon sintaksis <strong>AST</strong> abstrak, dan kita akan menggunakannya. <br><br><h4>  Lirik tentang AST <br></h4><br>  AST atau pohon sintaksis abstrak adalah representasi pohon dari kode, di mana verteks adalah operan dan daun adalah operator. <br><br>  Misalnya, panggilan fungsi, di mana ada satu argumen posisi dan dua argumen bernama, diubah menjadi pohon abstrak: <br><img src="https://habrastorage.org/webt/k3/zi/hu/k3zihuknbk9txzbwffdwcwr5gf4.jpeg"><br><br>  Ada simpul dengan tipe <strong>Panggilan</strong> dan memiliki: <br><br><ul><li>  atribut fungsi yang disebut func; </li><li>  daftar argumen posisi, di mana ada simpul dengan tipe Const dan nilai 112; </li><li>  daftar argumen bernama Kata kunci. </li></ul><br>  Tugas dalam hal ini: <br><br><ul><li>  Temukan di modul semua node dengan tipe Call (panggilan fungsi). </li><li>  Hitung jumlah total argumen yang digunakan fungsi. </li><li>  Jika ada lebih dari 2 argumen, maka pastikan tidak ada argumen posisional dalam simpul tersebut. </li><li>  Jika ada argumen posisi, maka perlihatkan peringatan. </li></ul><br><br><pre> <code class="python hljs">ll( func=Name(name=<span class="hljs-string"><span class="hljs-string">'get_offer'</span></span>), args=[Const(value=<span class="hljs-number"><span class="hljs-number">1298880</span></span>)], keywords=[ â€¦ ]))]</code> </pre><br>  Dari sudut pandang Pylint, pemeriksa berbasis AST adalah kelas yang mewarisi dari kelas pemeriksa basis dan mengimplementasikan antarmuka <strong>IAstroidChecker</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonKeywordArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> -_ _implements_ _ = IAstroidChecker</code> </pre><br>  Seperti pada contoh pertama, deskripsi checker, kode pesan, nama mnemonik pendek ditunjukkan dalam daftar pesan: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9191'</span></span>: (<span class="hljs-string"><span class="hljs-string">' '</span></span>, keyword-only-args<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  Langkah selanjutnya adalah menentukan metode kunjungan_panggilan: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node: Call)</span></span></span><span class="hljs-function"> â€¦</span></span></code> </pre><br>  Metodenya tidak harus disebut itu.  Yang paling penting di dalamnya adalah awalan visit_, dan kemudian muncul nama titik yang menarik bagi kita, dengan huruf kecil. <br><br><ul><li>  Parser AST berjalan melalui pohon dan untuk setiap vertex terlihat untuk melihat apakah kunjungan checkr antarmuka_ &lt;Nama&gt; didefinisikan. </li><li>  Jika demikian, sebut saja. </li><li>  Secara rekursif melewati semua anak-anaknya. </li><li>  Saat meninggalkan simpul, ia memanggil metode leave_ &lt;Name&gt;. </li></ul><br>  Dalam contoh ini, metode visit_call akan menerima node tipe-panggilan sebagai input dan melihat apakah ada lebih dari dua argumen dan apakah ada argumen posisi untuk melemparkan peringatan dan meneruskan kode ke node itu sendiri. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.args <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.args + node.keywords) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.add_message( <span class="hljs-string"><span class="hljs-string">'keyword-only-args'</span></span>, node=node )</code> </pre><br>  Kami mendaftarkan pemeriksa, seperti pada contoh sebelumnya: kami mentransfer instance Pylint, memanggil register_checker, melewati pemeriksa itu sendiri dan memulainya. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter.register_checker( TodoIssueChecker(linter) )</code> </pre><br>  Ini adalah contoh panggilan fungsi tes di mana ada 3 argumen dan hanya satu yang bernama: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker â€¦</code> </pre><br>  Ini adalah fungsi yang berpotensi disebut salah dari sudut pandang kami.  Luncurkan Pylint. <br><br>  Inisialisasi plugin tahap 1 benar-benar diulang, seperti pada contoh sebelumnya. <br><br><h4>  Fase 2. Modul parsing di AST <br></h4><br>  Kode diuraikan menjadi pohon AST.  Analisis dilakukan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan Astroid</a> . <br><br><h4>  Mengapa Astroid, bukan AST (stdlib) <br></h4><br>  Astroid secara internal tidak menggunakan modul AST Python standar, tetapi <strong>parser AST yang diketik typed_ast</strong> , dicirikan dengan mendukung <strong>petunjuk jenis</strong> PEP <strong>484. Typed_ast</strong> adalah cabang AST, garpu yang berkembang secara paralel.  Menariknya, ada bug yang sama yang ada di AST, dan diperbaiki secara paralel. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Entity <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (Entity) -&gt; None return</span></span></code> </pre><br>  Sebelumnya, Astroid menggunakan modul AST standar, di mana orang bisa menghadapi masalah menggunakan taiphints yang didefinisikan dalam komentar yang digunakan dalam Python kedua.  Jika Anda memeriksa kode ini melalui Pylint, maka pada titik tertentu kode ini akan bersumpah pada impor yang tidak digunakan, karena kelas Entitas yang diimpor hanya ada di komentar. <br><br><blockquote>  Pada suatu titik, Guido Van Rossum datang ke Astroid di GitHub dan berkata: "Guys, Anda punya Pylint, yang bersumpah pada kasus-kasus seperti itu, dan kami memiliki pengurai AST yang diketik yang mendukung semua ini.  Mari berteman! " <br></blockquote><br>  Pekerjaan sudah mulai mendidih!  2 tahun berlalu, Pylint musim semi ini beralih ke pengurai AST yang diketik dan berhenti bersumpah pada hal-hal seperti itu.  Impor untuk taiphint tidak lagi ditandai sebagai tidak digunakan. <br><br>  Astroid menggunakan parser AST untuk mengurai kode menjadi pohon, dan kemudian melakukan beberapa hal menarik ketika membangunnya.  Misalnya, jika Anda menggunakan <strong>impor *</strong> , maka impor semuanya dengan tanda bintang dan tambahkan ke penduduk lokal untuk mencegah kesalahan dengan impor yang tidak digunakan. <br><br>  <strong>Plugin transformasi</strong> digunakan dalam kasus di mana ada beberapa model kompleks berdasarkan kelas meta, ketika semua atribut dihasilkan secara dinamis.  Dalam hal ini, Astroid sangat sulit untuk memahami apa yang dimaksud.  Saat memeriksa, Pylint akan bersumpah bahwa model tidak memiliki atribut seperti itu ketika diakses, dan menggunakan plugin Transform Anda dapat menyelesaikan masalah: <br><br><ul><li>  Bantu Astroid memodifikasi pohon abstrak dan memahami sifat dinamis Python. </li><li>  Tambahan AST dengan informasi yang berguna. </li></ul><br>  Contoh tipikal adalah <strong>pylint-django</strong> .  Ketika bekerja dengan model Django kompleks, linter sering bersumpah pada atribut yang tidak diketahui.  Pylint-Django baru saja menyelesaikan masalah ini. <br><br><h4>  Fase 3. Mengurai kumpulan biji <br></h4><br>  Kami kembali ke pemeriksa.  Kami lagi memiliki daftar checker, dari mana kami menemukan orang-orang yang mengimplementasikan antarmuka AST checker. <br><br><h4>  Fase 4. Parse checker berdasarkan jenis node <br></h4><br>  Selanjutnya, kami menemukan metode untuk setiap pemeriksa, mereka bisa dari dua jenis: <br><br><ul><li>  visit_ &lt;Nama Node&gt; </li><li>  lev_ &lt;Node name&gt;. </li></ul><br>  Akan menyenangkan untuk mengetahui node apa yang perlu Anda panggil untuk node saat berjalan di pohon.  Oleh karena itu, mereka memahami kamus, di mana kuncinya adalah nama node, nilainya adalah daftar checker yang tertarik pada fakta akses ke node ini. <br><br><pre> <code class="python hljs">_visit_methods = dict( &lt; &gt; : [checker1, checker2 ... checkerN] )</code> </pre><br>  Sama dengan metode meninggalkan: kunci dalam bentuk nama node, daftar checker yang tertarik pada fakta keluar dari node ini. <br><br><pre> <code class="python hljs">_leave_methods = dict( &lt; &gt;: [checker1, checker2 ... checkerN] )</code> </pre><br>  Luncurkan Pylint.  Itu menunjukkan peringatan bahwa kita memiliki fungsi di mana ada lebih dari dua argumen dan ada argumen posisional di dalamnya: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker C: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:  c &gt;<span class="hljs-number"><span class="hljs-number">2</span></span>      (keyword-only-args)</code> </pre><br>  Masalahnya teratasi.  Sekarang, programmer pengkaji kode tidak perlu membaca argumen dari fungsi, linter akan melakukannya untuk mereka.  <strong>Kami menghemat waktu</strong> , waktu untuk meninjau kode, dan tugas kami berjalan lebih cepat dalam produksi. <br><br><h2>  Dan untuk menulis tes? <br></h2><br>  Pylint memungkinkan Anda untuk melakukan pengujian unit catur dan sangat sederhana.  Dari sudut pandang linter, pemeriksa tes terlihat seperti kelas yang mewarisi dari <strong>CheckerTestCase</strong> abstrak.  Diperlukan untuk menunjukkan pemeriksa yang sedang diperiksa di dalamnya. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonKwArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CheckerTestCase)</span></span></span><span class="hljs-class">:</span></span> CHECKER_CLASS = NonKeywordArgsChecker</code> </pre><br>  Langkah 1. Kami membuat tes AST-node dari bagian kode yang kami periksa. <br><br><pre> <code class="python hljs">node = astroid.extract_node( <span class="hljs-string"><span class="hljs-string">"get_offers(3, 'magic', 'args')"</span></span> )</code> </pre><br>  Langkah 2. Verifikasi bahwa pemeriksa, memasuki simpul, apakah melempar atau tidak melempar pesan yang sesuai: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.assertAddsMessages(message): self.checker.visit_call(node)</code> </pre><br><h2>  Tokenchecker <br></h2><br>  Ada jenis pemeriksa lain yang disebut <strong>TokenChecker</strong> .  Ia bekerja berdasarkan prinsip penganalisa leksikal.  Python memiliki modul <strong>tokenize</strong> yang berfungsi sebagai pemindai leksikal dan memecah kode menjadi daftar token.  Mungkin terlihat seperti ini: <br><img src="https://habrastorage.org/webt/ul/vj/bl/ulvjblhatvsted81sc1drmjn2io.png"><br><br>  Nama variabel, nama fungsi, dan kata kunci menjadi token bertipe NAME, dan pembatas, tanda kurung, titik dua menjadi token bertipe OP.  Selain itu, ada token terpisah untuk lekukan, umpan baris, dan terjemahan terbalik. <br><br>  Bagaimana Pylint bekerja dengan TokenChecker: <br><br><ul><li>  Modul yang sedang diuji tokenized. </li><li>  Daftar besar token diteruskan ke semua checker yang mengimplementasikan ITokenChecker dan metode <strong>process_tokens</strong> (token) <strong>dipanggil</strong> . </li></ul><br>  Kami belum menemukan penggunaan TokenChecker, tetapi ada beberapa contoh yang digunakan Pylint: <br><br><ul><li>  <strong>Periksa ejaan</strong> .  Misalnya, Anda dapat mengambil semua token dengan jenis teks dan melihat literasi leksikal, memeriksa kata-kata dari daftar stop-word, dll. </li><li>  <strong>Periksa indentasi</strong> , spasi. </li><li>  <strong>Bekerja dengan string</strong> .  Misalnya, Anda dapat memverifikasi bahwa Python 3 tidak menggunakan literal Unicode, atau memverifikasi bahwa hanya karakter ASCI yang ada dalam string byte. </li></ul><br><h2>  Kesimpulan <br></h2><br>  Kami punya masalah dengan ulasan kode.  Para pengembang melakukan pekerjaan linter, menghabiskan waktu mereka pada pemindaian kode tanpa tujuan dan memberi tahu penulis tentang kesalahan.  Dengan Pylint kami: <br><br><ul><li>  Ditransfer cek rutin ke linter, mengimplementasikan perjanjian internal di dalamnya. </li><li>  Peningkatan tinjauan kecepatan dan kualitas kode. </li><li>  Mengurangi jumlah permintaan tarik yang ditolak, dan waktu untuk melewati tugas dalam produksi menjadi lebih sedikit. </li></ul><br>  Pemeriksa sederhana ditulis dalam setengah jam, dan pemeriksa rumit dalam beberapa jam.  Pemeriksa menghemat lebih banyak waktu daripada yang diperlukan untuk menulis dan berjuang untuk beberapa permintaan tarik yang tidak ditolak. <br><br>  Anda dapat mempelajari lebih lanjut tentang Pylint dan cara menulis biji catur di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> , tetapi dalam hal menulis biji catur agak buruk.  Sebagai contoh, tentang TokenChecker hanya ada menyebutkan bahwa itu ada, tetapi bukan tentang bagaimana menulis checker itu sendiri.  Informasi lebih lanjut tersedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sumber Pylint di GitHub</a> .  Anda dapat melihat catur apa yang ada dalam paket standar dan mendapatkan inspirasi untuk menulis sendiri. <br><br>  <em>Pengetahuan tentang desain internal Pylint menghemat waktu, disederhanakan</em> <em><br></em>  <em>kinerja dan meningkatkan kode.</em>  <em>Hemat waktu Anda, tulis kode yang baik dan</em> <em><br></em>  <em>gunakan linter.</em> <br><blockquote>  Konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++ berikutnya</a> akan diadakan <b>pada tanggal 5 April 2019</b> dan Anda sudah dapat memesan tiket birf awal sekarang.  Bahkan lebih baik untuk mengumpulkan pikiran Anda dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melamar</a> laporan, maka kunjungan akan gratis, dan roti manis akan menjadi bonus, termasuk pelatihan tentang persiapan laporan. <br><br>  Konferensi kami adalah platform untuk bertemu dengan orang-orang yang berpikiran sama, mesin industri, untuk berkomunikasi dan mendiskusikan hal-hal yang disukai pengembang Python: backend dan web, pengumpulan dan pemrosesan data, AI / ML, pengujian, IoT.  Bagaimana kelanjutannya di musim gugur, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat laporan video</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran Python</a> kami dan berlangganan saluran - segera kami akan memposting laporan terbaik dari konferensi untuk akses gratis. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433474/">https://habr.com/ru/post/id433474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433450/index.html">Tumbuhkan dan ajarkan. Bagaimana kami berteman dengan PEGA</a></li>
<li><a href="../id433456/index.html">Bagaimana meyakinkan pelanggan atau perusahaan untuk menggunakan Flutter</a></li>
<li><a href="../id433462/index.html">Pemeriksaan kesehatan dan degradasi bertahap sistem terdistribusi</a></li>
<li><a href="../id433468/index.html">Fault Injection: Sistem Anda tidak dapat diandalkan jika Anda belum mencoba untuk memecahkannya</a></li>
<li><a href="../id433472/index.html">Unity 2018.3 dirilis</a></li>
<li><a href="../id433478/index.html">Mengapa Django dipilih di Tinkoff Magazine</a></li>
<li><a href="../id433480/index.html">Kisah Holivarny tentang linter</a></li>
<li><a href="../id433482/index.html">Django di bawah mikroskop</a></li>
<li><a href="../id433486/index.html">Apa lagi? Kebangkitan kartu debit non-bank</a></li>
<li><a href="../id433488/index.html">Christmas Scrum Meetup UPD Broadcast mitap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>