<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎊 ✌🏾 👩🏻‍🏭 关于linux epoll的全部真相 🈷️ 🤶🏻 🤾🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="好吧，或者几乎所有... 





 我相信现代互联网上的问题是过多的不同质量的信息。 在感兴趣的主题上查找材料不是问题；问题是，如果您在该领域经验不足，则可以将好材料与坏材料区分开。 当“概述”（几乎在一个简单列表的级别）上有很多概述信息，很少有深入的文章并且没有从简单到复杂的过渡性文章时，我会...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于linux epoll的全部真相</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416669/"><p> 好吧，或者几乎所有... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/776/71c/91f77671c2186bc1f2393c47e0696ee9.png"></p><br><p> 我相信现代互联网上的问题是过多的不同质量的信息。 在感兴趣的主题上查找材料不是问题；问题是，如果您在该领域经验不足，则可以将好材料与坏材料区分开。 当“概述”（几乎在一个简单列表的级别）上有很多概述信息，很少有深入的文章并且没有从简单到复杂的过渡性文章时，我会看到一张图片。 尽管如此，正是对特定机制的特征的了解使我们能够在开发过程中做出明智的选择。 </p><br><p> 在本文中，我将尝试揭示<strong>epoll</strong>与其他机制之间的根本区别是什么，什么使<strong>epoll</strong>与众不同，并列举了仅需阅读才能进一步了解<strong>epoll</strong>的可能性和问题的文章。 </p><br><blockquote>任何人都可以挥动斧头，但是要让它唱出近战旋律需要一个真正的战士。 </blockquote><p> 我假设读者熟悉<strong>epoll</strong> ，至少阅读了手册页。 关于<strong>epoll</strong> ， <strong>poll</strong> ， <strong>select的文章</strong>已经足够写了，所以在Linux下开发的每个人都至少听说过一次。 </p><a name="habracut"></a><br><h1 id="mnoga--fd"> 很多fd </h1><br><p> 当人们基本上谈论<strong>epoll时，</strong>我听到一个论点，即“在有许多文件描述符的情况下其性能会更好”。 </p><br><p> 只想问一个问题-多少是多少？ 需要多少个连接，最重要的是， <strong>epoll</strong>将在什么条件下开始产生明显的性能提升？ </p><br><p> 对于那些研究过<strong>epoll的人来说</strong> （答案很多，包括科学论文在内），答案是显而易见的-仅当“等待事件”化合物的数量大大超过“准备处理”的数量时，答案才会更好。 数量的标记，当增益变得如此重要以至于没有尿液可以忽略这一事实时，可以考虑使用10k化合物[4]。 </p><br><p> 大多数连接即将挂起的假设来自合理的逻辑和对正在使用的服务器的负载监视。 </p><br><p> 如果活性化合物的数量争取总数， <del> 没有收获 </del> 不会有明显的收益，这是由于并且仅因为<strong>epoll</strong>仅返回需要注意的描述符，而<strong>poll</strong>返回所有为观察而添加的描述符，才有了明显的收益。 </p><br><p> 显然，在后一种情况下，我们花时间遍历所有描述符并从内核复制事件数组的开销。 </p><br><p> 的确，在附加到补丁[9]的初始性能测量中，没有强调这一点，并且只能通过本文中提到的deadcon实用程序的存在来猜测（不幸的是，pipetest.c实用程序代码丢失了）。 另一方面，在其他来源[6，8]中，很难注意到这一点，因为实际上这一点很明显。 </p><br><p> 问题立刻出现了，但是如果不打算像过去那样并且不需要这样的<strong>epoll</strong>文件描述符，那么现在该怎么办呢？ </p><br><p> 尽管<strong>epoll</strong>最初是专门为这种情况而创建的[ <strong>5，8，9</strong> ]，但这远不是<strong>epoll</strong>之间的唯一区别。 </p><br><h1 id="epollet">  EPOLLET </h1><br><p> 首先，我们将探讨边缘触发和电平触发的区别。在文章《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">边缘触发与电平触发的中断-Venkatesh Yadav》中</a>有一个很好的陈述： </p><br><blockquote> 在水平上打断，就像一个孩子。 如果婴儿在哭，您必须放弃所做的一切，跑去给婴儿喂奶。 然后，您将婴儿放回婴儿床。 如果他再次哭泣，您将不会把他留在任何地方，但是您将尝试使他平静下来。 而且，在孩子哭泣的同时，您不会离开他一会儿，只有在他冷静下来之后才能恢复工作。 但是，可以说当孩子开始哭泣时，我们进入花园（中断中断），然后当您回家（中断中断）时，您要做的第一件事就是去检查孩子。 但是你永远不会知道你在花园里的时候他在哭。 <br><br> 前面的中断就像是聋人父母的电子保姆。 当孩子开始在设备上哭泣时，红灯会亮起并点亮，直到您按下按钮为止。 即使孩子开始哭泣，但很快停下来入睡，您仍然会知道孩子在哭泣。 但是，如果他开始哭泣，并且您按了按钮（确认中断），即使他继续哭泣，指示灯也不会点亮。 房间内的声音水平应先下降然后再上升，以使灯亮起。 </blockquote><p> 如果描述符在指定状态下以级别触发的行为解锁了<strong>epoll</strong> （以及<strong>poll</strong> / <strong>select</strong> ），并且在清除该状态之前将其视为活动状态，则仅通过更改当前给定的有序状态来解锁沿触发的状态。 </p><br><p> 这使您可以稍后处理事件，而不必在收到消息后立即处理（几乎直接与中断处理程序的上半部分和下半部分类似）。 </p><br><p>  epoll的具体示例： </p><br><p> 触发水平 </p><br><ul><li> 使用标志<strong>EPOLLIN</strong>添加到<strong>epoll的</strong> <strong>句柄</strong> </li><li>  <strong>epoll_wait（）</strong>在等待事件时阻塞 </li><li> 写入文件描述符19个字节 </li><li>  <strong>epoll_wait（）</strong>通过<strong>EPOLLIN</strong>事件解锁 </li><li> 我们不会处理收到的数据 </li><li>  <strong>epoll_wait（）</strong>通过<strong>EPOLLIN</strong>事件再次解锁 </li></ul><br><p> 这将继续，直到我们完全计算或重置描述符中的数据为止。 </p><br><p> 边缘触发 </p><br><ul><li>  <strong>EPOLLIN</strong>标志将句柄添加到<strong>epoll中</strong> <strong>|</strong>  <strong>EPOLLET</strong> </li><li>  <strong>epoll_wait（）</strong>在等待事件时阻塞 </li><li> 写入文件描述符19个字节 </li><li>  <strong>epoll_wait（）</strong>通过<strong>EPOLLIN</strong>事件解锁 </li><li> 我们不会处理收到的数据 </li><li>  <strong>epoll_wait（）被</strong>阻止等待新事件 </li><li> 向文件描述符再写入19个字节 </li><li>  <strong>epoll_wait（）</strong>通过新的<strong>EPOLLIN</strong>事件解锁 </li><li>  <strong>epoll_wait（）被</strong>阻止等待新事件 </li></ul><br><p> 简单示例： <a href="">epollet_socket.c</a> </p><br><p> 该机制<strong>旨在</strong>防止由于已经处理过的事件而返回<strong>epoll_wait（）</strong> 。 </p><br><p> 如果在级别的情况下，当调用<strong>epoll_wait（）时，</strong>内核检查以查看fd是否处于此状态，则edge跳过此检查，并立即将调用进程置于睡眠状态。 </p><br><p>  <strong>EPOLLET本身</strong>就是使<strong>epoll</strong> O（1）成为事件多路复用器的原因。 </p><br><p> 有必要对<strong>EAGAIN</strong>和<strong>EPOLLET</strong>进行解释<strong>-EAGAIN</strong>的建议不要处理字节流，只有在您没有读完描述符并且没有新数据的情况下，后一种情况下的危险才会出现。 然后尾巴将挂在描述符中，但是您将不会收到新的通知。 使用<strong>accept（），</strong>情况就不同了，您必须继续执行直到<strong>accept（）</strong>返回<strong>EAGAIN</strong> ，只有在这种情况下，才能保证正确的操作。 </p><br><pre><code class="hljs lua">// TCP socket (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> stream) //  fd    EPOLLIN      int <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(fd, buffer, BUFFER_LEN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &lt; BUFFER_LEN) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         //  -       epoll_wait, //      }</code> </pre> <br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ accept /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  listenfd    EPOLLIN      event.events = EPOLLIN | EPOLLERR; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event); sleep(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       &gt;1  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { newfd = accept(listenfd, ...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  epoll_wait    listenfd    } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { while((newfd = accept(...)) &gt; 0) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -  } if(newfd == -1 &amp;&amp; errno = EAGAIN) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       } }</span></span></code> </pre> <br><p> 有了这个属性，仅仅饥饿就足够了： </p><br><ul><li> 数据包到达描述符 </li><li> 将数据包读取到缓冲区 </li><li> 另一个小包来了 </li><li> 将数据包读取到缓冲区 </li><li> 一小部分 </li><li>  ... </li></ul><br><p> 因此<strong>，</strong>我们不会很快收到<strong>EAGAIN</strong> ，但可能根本不会收到。 </p><br><p> 因此，其他文件描述符没有时间来处理，我们正忙于读取不断到达的一小部分数据。 </p><br><h1 id="thundering-nerd-herd"> 雷声 <del> 书呆子 </del> 牛群 </h1><br><p> 为了到达最后一个标记，您需要了解为什么它实际上是创建的，以及随着技术和软件的发展对开发人员造成的问题之一。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://en.wikipedia.org/wiki/">雷电群问题</a> </p><br><blockquote> 雷群问题 <br><br> 想象大量等待事件的进程。 如果发生事件，则将它们唤醒，并且将开始争夺资源，尽管仅需要一个过程来处理事件的进一步处理。 其余过程将再次休眠。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IT术语-Vasily Alekseenko</a> </blockquote><p> 在这种情况下，我们对与<strong>epoll</strong>一起分布在流上的<strong>accept（）</strong>和<strong>read（）</strong>问题感兴趣。 </p><br><h1 id="accept"> 接受 </h1><br><p> 实际上，通过阻塞调用<strong>accept（），</strong>很长时间以来就没有问题。 内核将确保只有一个进程为此事件被解锁，并且所有传入的连接都将被序列化。 </p><br><p> 但是使用<strong>epoll，</strong>这种技巧将行不通。 如果我们在非阻塞套接字上创建了<strong>listen（）</strong> ，则在建立连接时，所有<strong>epoll_wait（）</strong>都会<strong>等待</strong>此描述符中的事件。 </p><br><p> 当然， <strong>accept（）</strong>将只能执行一个线程，其余的将接收<strong>EAGAIN</strong> ，但这是浪费资源。 </p><br><p> 而且， <strong>EPOLLET</strong>也无济于事，因为我们<strong>不确切</strong>知道连接队列中有多少个连接（ <strong>积压</strong> ）。 我们记得，当使用<strong>EPOLLET时</strong> ，套接字处理应该继续进行，直到返回带有<strong>EAGAIN</strong>错误<strong>代码的消息</strong>为止，因此所有的<strong>accept（）</strong>都有可能被一个线程处理，而其余的则无法工作。 </p><br><p> 这又将我们引向了白白唤醒附近小溪的情况。 </p><br><p> 我们还可以得到另一种类型的饥饿-我们将仅加载一个线程，其余线程将不接收用于处理的连接。 </p><br><h1 id="epolloneshot">  EPOLLONESHOT </h1><br><p> 在版本4.5之前的版本中，使用下一个<strong>accept（）</strong>调用将分布式<strong>epoll处理</strong>为非阻塞<strong>listen（）</strong>描述符的唯一正确方法是设置<strong>EPOLLONESHOT</strong>标志，这再次导致我们一次只在一个线程中处理<strong>accept（）</strong> 。 </p><br><p> 总之-使用<strong>epoll_ctl</strong>与特定的描述符相关<strong>EPOLLONESHOT</strong>事件的情况下，只能使用一次，那么你就需要重新公鸡标志<strong>（）。</strong> </p><br><h1 id="epollexclusive"> 弹性 </h1><br><p> 在这里， <strong>EPOLLEXCLUSIVE</strong>和级别触发可为我们提供帮助。 </p><br><p>  <strong>EPOLLEXCLUSIVE</strong>一次为一个事件解锁一个未决的<strong>epoll_wait（）</strong> 。 </p><br><p> 该方案非常简单（实际上不是）： </p><br><ul><li> 我们有N个线程在等待连接事件 </li><li> 第一位客户与我们联系 </li><li> 线程0将被分散并开始处理，其他线​​程将保持阻塞 </li><li> 第二个客户端连接到我们，如果线程0仍在忙于处理，则线程1被解锁 </li><li> 我们继续进行下去，直到线程池耗尽为止（没人期待<strong>epoll_wait（）</strong>上的事件） </li><li> 另一个客户正在与我们联系 </li><li> 并且其处理将收到第一个线程，它将调用<strong>epoll_wait（）</strong> </li><li> 第二个线程将收到第二个客户端，它将调用<strong>epoll_wait（）</strong> </li></ul><br><p> 因此，所有维护均匀地分布在流中。 </p><br><pre> <code class="bash hljs">$ ./epollexclusive --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> -i, --ip=ADDR specify ip address -p, --port=PORT specify port -n, --threads=NUM specify number of threads to use <span class="hljs-comment"><span class="hljs-comment">#    -  n*8 -t, --thunder not adding EPOLLEXCLUSIVE #     thunder herd -h, --help prints this message $ sudo taskset -c 0-7 ./epollexclusive -i 10.56.75.201 -p 40000 -n 8 2&gt;&amp;1</span></span></code> </pre> <br><p> 示例代码： <a href="">epollexclusive.c</a> （仅适用于4.5或更高版本的内核） </p><br><p> 我们在epoll上获得了一个前叉模型。 此方案非常适用于<strong>短时</strong> TCP连接。 </p><br><h1 id="read"> 已读 </h1><br><p> 但是对于字节流而言，使用<strong>read（）</strong>时，像<strong>EPOLLET</strong>一样， <strong>EPOLLEXCLUSIVE</strong>不会帮助我们。 </p><br><p> 出于明显的原因，没有<strong>EPOLLEXCLUSIVE，</strong>我们根本无法使用电平触发。 与所有<strong>EPOLLEXCLUSIVE</strong>不是更好，因为我们可以得到的包，分布在溪流中，除了一个未知的秩序便字节。 </p><br><p> 使用<strong>EPOLLET，</strong>情况是一样的。 </p><br><p> 在这里， <strong>EPOLLONESHOT</strong>会在工作完成后重新初始化。 因此，只要有一个线程将与此文件描述符和缓冲区一起使用： </p><br><ul><li>  <strong>EPOLLONESHOT</strong>标志将句柄添加到<strong>epoll中</strong> <strong>|</strong>  <strong>EPOLLET</strong> </li><li> 等待<strong>epoll_wait（）</strong> </li><li> 从套接字读取到缓冲区，直到<strong>read（）</strong>返回<strong>EAGAIN</strong> </li><li> 用<strong>EPOLLONESHOT</strong>标志重新初始化<strong>|</strong>  <strong>EPOLLET</strong> </li></ul><br><h1 id="struct--epoll_event">  struct epoll_event </h1><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> epoll_data { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> u32; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> u64; } <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/* Epoll events */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* User data variable */</span></span> };</code> </pre> <br><p> 此项可能是我个人恕我直言在我的文章中唯一的一项。 使用指针或数字的功能很有帮助。 例如，在使用epoll时使用指针可以使您完成以下操作： </p><br><pre> <code class="hljs go">#define container_of(ptr, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, member) ({ \ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeof( ((<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;member ) *__mptr = (ptr); \ (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)( (char *)__mptr - offsetof(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>,member) );}) <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client { <span class="hljs-comment"><span class="hljs-comment">/** some usefull associated data...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event event; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* to_epoll_client(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event* event) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container_of(event, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client, event); } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client ec; ... epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;ec.e); ... epoll_wait (efd, events, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* ec_ = to_epoll_client(events[<span class="hljs-number"><span class="hljs-number">0</span></span>].data.ptr);</code> </pre> <br><p> 我想每个人都知道这项技术的来历。 </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p> 我希望我们能够打开<strong>epoll</strong>的话题。 那些有意识地使用此机制的人，只需阅读参考文献列表中的文章[1、2、3、5]。 </p><br><p> 基于此材料（或者甚至更好地从参考文献中仔细地阅读材料），您可以制作多线程的前叉（进程的高级生成）无锁（无阻塞）服务器，或者根据<strong>epoll（）</strong>的特殊属性修改现有策略。 </p><br><p>  <strong>epoll是</strong>选择Linux编程路径的人们需要知道的独特机制之一，因为它们比其他操作系统具有更大的优势），并且也许会针对这种特殊情况放弃跨平台（让它起作用）仅在Linux上使用，但效果会很好）。 </p><br><h2 id="rassuzhdeniya-ob-specifichnosti-zadachi"> 关于问题的“特殊性”的推理 </h2><br><p> 在有人谈论这些标志和使用模式的特殊性之前，我想问一个问题： </p><br><p>  “但是，我们没有试图讨论最初为特定任务创建的机制的特殊性[9，11]？还是我们甚至不愿意为程序员提供1k连接服务？” </p><br><p> 我不理解“任务特殊性”的概念；它使我想起对所教授的各个学科的有用性和无用性的种种呼声。 为了让自己以这种方式进行推理，我们谨请自己决定为他人决定哪些信息对他们有用而哪些信息无用的权利，同时请注意，您没有参与整个教育过程。 </p><br><p> 对于怀疑者，有两个链接： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在NGINX 1.9.1中使用SO_REUSEPORT提高性能-VBart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向独角兽学习：雷电追捕非问题-克里斯·西本曼（Chris Siebenmann）</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">序列化accept（），又名雷电群，又称Zeeg问题-Roberto De Ioris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">epoll的EPOLLEXCLUSIVE模式如何与电平触发相互作用？</a> </p><br><h1 id="spisok-literatury"> 参考文献 </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择从根本上被打破-Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Epoll从根本上打破了1/2-Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Epoll从根本上打破了2/2-Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C10K问题-Dan Kegel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">投票与Epoll，再一次-雅克·马修</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">epoll-I / O事件通知工具-The Mann</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">epoll疯狂的方法-Cindy Sridharan</a> </li></ol><br><h2 id="benchmarks"> 基准测试 </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://lse.sourceforge.net/epoll/index.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://mvitolin.wordpress.com/2015/12/05/endurox-testing-epollexclusive-flag/</a> </li></ol><br><h2 id="evolyuciya-epoll">  epoll的演变 </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://lwn.net/Articles/13918/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://lwn.net/Articles/520012/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://lwn.net/Articles/520198/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://lwn.net/Articles/542629/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://lwn.net/Articles/633422/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://lwn.net/Articles/637435/</a> </li></ol><br><h1 id="postskriptum"> 后记 </h1><br><p> 非常感谢谢尔盖（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">dlinyj</a> ）和Peter Ovchenkovu有价值铁饼，意见和支持！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416669/">https://habr.com/ru/post/zh-CN416669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416657/index.html">三分之二的已用存储卡包含以前所有者的个人数据</a></li>
<li><a href="../zh-CN416659/index.html">由于零工经济的数字支付量将达到1.2万亿美元</a></li>
<li><a href="../zh-CN416661/index.html">移动银行的用户和提供商应考虑哪些趋势</a></li>
<li><a href="../zh-CN416665/index.html">通过Sonatype Nexus Repository OSS重用私有Android库</a></li>
<li><a href="../zh-CN416667/index.html">旧系统单元的预算防尘和隔音</a></li>
<li><a href="../zh-CN416673/index.html">经理人的分析解决方案</a></li>
<li><a href="../zh-CN416677/index.html">赛博朋克和镜子眼镜：时尚和文化的思考</a></li>
<li><a href="../zh-CN416679/index.html">外围计算：“雾”与“云”的友好匹配</a></li>
<li><a href="../zh-CN416681/index.html">如何在numpy中快速，快速地从PostgreSQL和Python中的ClickHouse</a></li>
<li><a href="../zh-CN416683/index.html">接下来是什么？ 或如何选择功能进行开发</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>