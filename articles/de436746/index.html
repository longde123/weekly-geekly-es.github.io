<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤º ğŸ‚ ğŸ—ï¸ So verschlechtern Sie die Leistung, indem Sie sie verbessern ğŸ‘©â€ğŸ³ ğŸ¤›ğŸ½ ğŸ’•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir wollten das Beste, aber es stellte sich wie immer heraus. 
 Victor Chernomyrdin, 
 Russischer Staatsmann 


 Es gibt Zeiten im Leben, in denen Sie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So verschlechtern Sie die Leistung, indem Sie sie verbessern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436746/"><p> <em>Wir wollten das Beste, aber es stellte sich wie immer heraus.</em> <br>  Victor Chernomyrdin, <br>  Russischer Staatsmann </p><br><p>  Es gibt Zeiten im Leben, in denen Sie scheinbar alles richtig machen, aber etwas schief geht. <br>  Diese Geschichte handelt von einem solchen Fall. </p><a name="habracut"></a><br><p>  Einmal habe ich mir diesen Code angesehen und darÃ¼ber nachgedacht, ihn zu beschleunigen: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(data.str, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p>  Zuerst wollte ich die GesamtlÃ¤nge der Zeichenfolge mithilfe der Variablen <code>beginIndex</code> und <code>endIndex</code> (sowie die Tatsache, dass zusÃ¤tzlich zur abgeschnittenen Zeichenfolge 2 weitere Zeichen zu <code>StringBuilder</code> hinzugefÃ¼gt werden) und diesen Wert an den <code>StringBuilder</code> Konstruktor Ã¼bergeben, um sofort das Array mit der erforderlichen GrÃ¶ÃŸe auszuwÃ¤hlen .  Dieser Gedanke schien mir zu offensichtlich, also beschloss ich, etwas anderes auszuprobieren.  Die Tatsache, dass dieser Code nicht durch die "Idee" hervorgehoben wurde, veranlasste mich zum richtigen Gedanken, obwohl dieses kluge MÃ¤dchen normalerweise vorschlÃ¤gt, die kurze Zeichenfolge aus <code>StringBuilder::append</code> durch die HinzufÃ¼gung von Zeichenfolgen zu ersetzen, die kÃ¼rzer und leichter zu lesen sind. </p><br><p>  Ein Hindernis fÃ¼r diese Vereinfachung ist die Verwendung der Methode <code>StringBuilder.append(CharSequence, int, int)</code> .  Da das Feld <code>data.str</code> eine Zeichenfolge ist, kÃ¶nnen Sie mit <code>String.substring(beginIndex, endIndex)</code> eine <code>String.substring(beginIndex, endIndex)</code> auswÃ¤hlen und an <code>StringBuilder.append(String)</code> . </p><br><p>  Code nach der Konvertierung: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String subString = data.str.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(subString) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p>  Und jetzt bietet die Idee eine Vereinfachung: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'L'</span></span> + data.str.substring(beginIndex, endIndex) + <span class="hljs-string"><span class="hljs-string">';'</span></span>; }</code> </pre> <br><p>  Unser Ziel in diesem Fall ist jedoch weniger die Lesbarkeit als vielmehr die ProduktivitÃ¤t.  Vergleichen Sie beide Methoden: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-Xms2g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx2g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilderAppendBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendSubString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String substring = data.nonLatin ? nonLatinStr.substring(beginIndex, endIndex) : latinStr.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(substring) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String appended = data.nonLatin ? nonLatinStr : latinStr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(appended, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ String latinStr; String nonLatinStr; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"false"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> nonLatin; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"50"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"500"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThreadLocalRandom random = ThreadLocalRandom.current(); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ latinStr = randomString(<span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>); nonLatinStr = randomString(<span class="hljs-string"><span class="hljs-string">""</span></span>); beginIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; endIndex = length + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String alphabet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] chars = alphabet.toCharArray(); StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(length + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length + <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = chars[random.nextInt(chars.length)]; sb.append(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.toString(); } } }</code> </pre> <br><p>  Der Benchmark ist so einfach wie zwei Cent: Dem <code>StringBuilder</code> wird eine zufÃ¤llige Zeichenfolge hinzugefÃ¼gt, deren GrÃ¶ÃŸe durch das <code>length</code> bestimmt wird. Da der Yard 2019 ist, mÃ¼ssen Sie ihn als Zeichenfolge Ã¼berprÃ¼fen, die nur die Zeichen des lateinischen Hauptalphabets enthÃ¤lt (die sogenannte komprimierte Zeile, in der jedes Zeichen enthalten ist) entspricht 1 Byte) und einer Zeichenfolge mit nicht lateinischen Zeichen (jedes Zeichen wird durch 2 Byte dargestellt). </p><br><p>  Bei einer flÃ¼chtigen PrÃ¼fung <code>appendSubString</code> uns die <code>appendSubString</code> Methode langsamer zu sein, da die zu klebende Datenmenge mit der der <code>appendBounds</code> Methode Ã¼bereinstimmt. Bei der <code>appendBounds</code> Methode wird jedoch auch explizit eine Teilzeichenfolge erstellt, d. H. Speicher fÃ¼r ein neues Objekt <code>data.latinStr</code> und der Inhalt aus <code>data.latinStr</code> kopiert / <code>data.nonLatinStr</code> . </p><br><p>  Die Ã¼berraschenderen (aber nur auf den ersten Blick) Ergebnisse der Messung, die ich mit JDK11 auf einem Heimcomputer (Intel Core i5-4690, 3,50 GHz) durchgefÃ¼hrt habe, scheinen zu sein: </p><br><pre> <code class="plaintext hljs">Benchmark nonLatin length Score Error Units appendBounds true 5 44,6 Â± 0,4 ns/op appendBounds true 10 45,7 Â± 0,7 ns/op appendBounds true 50 129,0 Â± 0,5 ns/op appendBounds true 100 218,7 Â± 0,8 ns/op appendBounds true 500 907,1 Â± 5,5 ns/op appendBounds true 1000 1626,4 Â± 13,0 ns/op appendSubString true 5 28,6 Â± 0,2 ns/op appendSubString true 10 30,8 Â± 0,2 ns/op appendSubString true 50 65,6 Â± 0,4 ns/op appendSubString true 100 106,6 Â± 0,6 ns/op appendSubString true 500 430,1 Â± 2,4 ns/op appendSubString true 1000 839,1 Â± 8,6 ns/op appendBounds:Â·gc.alloc.rate.norm true 5 184,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 10 200,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 50 688,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 100 1192,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 500 5192,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm true 1000 10200,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 5 136,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 10 160,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 50 360,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 100 608,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 500 2608,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm true 1000 5104,0 Â± 0,0 B/op appendBounds false 5 20,8 Â± 0,1 ns/op appendBounds false 10 24,0 Â± 0,2 ns/op appendBounds false 50 66,4 Â± 0,4 ns/op appendBounds false 100 111,0 Â± 0,8 ns/op appendBounds false 500 419,2 Â± 2,7 ns/op appendBounds false 1000 840,4 Â± 7,8 ns/op appendSubString false 5 25,3 Â± 0,3 ns/op appendSubString false 10 25,7 Â± 0,2 ns/op appendSubString false 50 36,0 Â± 0,1 ns/op appendSubString false 100 52,8 Â± 0,4 ns/op appendSubString false 500 206,1 Â± 6,1 ns/op appendSubString false 1000 388,1 Â± 1,6 ns/op appendBounds:Â·gc.alloc.rate.norm false 5 80,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 10 88,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 50 320,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 100 544,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 500 2144,0 Â± 0,0 B/op appendBounds:Â·gc.alloc.rate.norm false 1000 4152,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 5 96,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 10 112,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 50 192,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 100 288,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 500 1088,0 Â± 0,0 B/op appendSubString:Â·gc.alloc.rate.norm false 1000 2088,0 Â± 0,0 B/op</code> </pre> <br><p>  Unsere Annahme zu widerlegen, <code>appendSubString</code> die <code>appendSubString</code> Methode in den allermeisten FÃ¤llen (auch immer fÃ¼r nicht-lateinische Zeichenfolgen) als schneller und weniger gefrÃ¤ÃŸig (obwohl <code>String::substring</code> ein neues Objekt zurÃ¼ckgibt).  Wie ist es passiert? </p><br><h2 id="smotryu-v-knigu-vizhu-figu">  Ich schaue in das Buch, ich sehe eine Feige </h2><br><p>  Das Studium des <code>StringBuilder</code> Quellcodes hilft dabei <code>StringBuilder</code> Schleier der Geheimhaltung zu lÃ¼ften.  Beide verwendeten Methoden Ã¼bergeben den Aufruf an dieselben Methoden von <code>AbstractStringBuilder</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractStringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharSequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Gehen Sie zu <code>AbstractStringBuilder.append(String)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> appendNull(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putStringAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getCoder() != str.coder()) { inflate(); } str.getBytes(value, index, coder); }</code> </pre> <br><p>  Was ist hier interessant?  Die <code>AbstractStringBuilder::inflate</code> , wie der Name schon sagt, das <code>AbstractStringBuilder.value</code> Array, wenn unterschiedliche Zeichenfolgen kombiniert werden.  Die Daten werden in der <code>String::getBytes</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstBegin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coder() == coder) { System.arraycopy(value, <span class="hljs-number"><span class="hljs-number">0</span></span>, dst, dstBegin &lt;&lt; coder, value.length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// this.coder == LATIN &amp;&amp; coder == UTF16 StringLatin1.inflate(value, 0, dst, dstBegin, value.length); } }</span></span></code> </pre> <br><p>  Was ist wichtig?  Wenn die Zeichenfolgen homogen sind, werden die Daten mit der intrinsischen <code>System::arraycopy</code> verschoben, andernfalls mit <code>StringLatin1::inflate</code> , was uns durch Delegierung zur <code>StringUTF16::inflate</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inflatedCopy byte[] -&gt; byte[] @HotSpotIntrinsicCandidate public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) { // We need a range check here because 'putChar' has no checks checkBoundsOffCount(dstOff, len, dst); for (int i = 0; i &lt; len; i++) { putChar(dst, dstOff++, src[srcOff++] &amp; 0xff); } } @HotSpotIntrinsicCandidate static void putChar(byte[] val, int index, int c) { assert index &gt;= 0 &amp;&amp; index &lt; length(val) : "Trusted caller missed bounds check"; index &lt;&lt;= 1; val[index++] = (byte)(c &gt;&gt; HI_BYTE_SHIFT); val[index] = (byte)(c &gt;&gt; LO_BYTE_SHIFT); }</span></span></code> </pre> <br><p>  Wenn die Zeilen homogen sind, wird die Plattform mit der plattformabhÃ¤ngigen Methode <code>System::arraycopy</code> verschoben, andernfalls wird eine Schleife (auch intrinsisch) verwendet.  Dies bedeutet, dass beim Kleben von zwei Linien, bei denen alle Zeichen im Satz des lateinischen Hauptalphabets enthalten sind (dh in 1 Byte passen), die Leistung viel besser sein sollte als beim Kleben heterogener Linien.  Der Benchmark bestÃ¤tigt dies (siehe Ausgabe fÃ¼r <code>nonLatin = false</code> ). </p><br><p>  Nun die <code>AbstractStringBuilder.append(CharSequence, int, int)</code> Methode <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { s = <span class="hljs-string"><span class="hljs-string">"null"</span></span>; } checkRange(start, end, s.length()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendChars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLatin1()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] val = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off, j = count; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = s.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringLatin1.canEncode(c)) { val[j++] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)c; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { count = j; inflate(); StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, j, s, i, end); count += end - i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, count, s, off, end); } count += end - off; }</code> </pre> <br><p>  Hier Ã¤hnelt der Ansatz dem im vorherigen Beispiel: FÃ¼r homogene Zeichenfolgen wird ein einfacherer Mechanismus verwendet (hier das Kopieren von Zeichen in einer Schleife). FÃ¼r heterogene Zeichenfolgen verwenden wir <code>StringUTF16</code> . Beachten <code>StringUTF16</code> jedoch, dass die aufgerufene <code>StringUTF16::putCharsSB</code> nicht <code>StringUTF16::putCharsSB</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putCharsSB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ checkBoundsBeginEnd(index, index + end - off, val); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off; i &lt; end; i++) { putChar(val, index++, s.charAt(i)); } }</code> </pre> <br><p>  Die interne Struktur beider Methoden und der Grund fÃ¼r ihre unterschiedliche Leistung sind uns also mehr oder weniger klar.  Es stellt sich natÃ¼rlich die Frage, was mit dem als nÃ¤chstes gewonnenen Wissen zu tun ist.  Es gibt mehrere Optionen gleichzeitig: </p><br><p>  1) Denken Sie daran und wenn es einen verdÃ¤chtigen Code entdeckt, Ã¤ndern Sie ihn mit Ihren HÃ¤nden <br>  2) Gehen Sie zu Tagir und bitten Sie ihn, einen Scheck einzureichen, der die Arbeit anstelle von uns erledigt <br>  3) Nehmen Sie Ã„nderungen am JDK vor, damit sich der Code Ã¼berhaupt nicht Ã¤ndert. </p><br><p>  NatÃ¼rlich beginnen wir mit dem dritten.  Bereit, ein Risiko einzugehen? </p><br><h2 id="pogruzhenie-v-puchinu">  Abgrund </h2><br><p>  Wir werden trainieren <del>  auf Katzen </del>  Den Quellcode des elften Java kÃ¶nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunterladen. </p><br><p>  Die einfachste und naheliegendste MÃ¶glichkeit zur Verbesserung besteht darin, einen Teilstring auszuwÃ¤hlen, der sich bereits in der <code>AbstractStringBuilder.append(CharSequence, int, int)</code> Methode <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); int len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); return this; } //  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return append(s.subSequence(start, end).toString()); }</span></span></code> </pre> <br><p>  Jetzt mÃ¼ssen Sie das JDK erstellen, die Tests ausfÃ¼hren und den <code>StringBuilderAppendBenchmark::appendBounds</code> Benchmark darauf <code>StringBuilderAppendBenchmark::appendBounds</code> , dessen Ergebnisse mit den Ergebnissen desselben Benchmarks im ursprÃ¼nglichen JDK verglichen werden mÃ¼ssen: </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 64,4 ns/op avgt true 10 45,7 66,3 ns/op avgt true 50 129,0 168,9 ns/op avgt true 100 218,7 281,9 ns/op avgt true 500 907,1 1116,2 ns/op avgt true 1000 1626,4 2002,5 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 38,0 ns/op avgt false 10 24,0 37,8 ns/op avgt false 50 66,4 82,9 ns/op avgt false 100 111,0 138,8 ns/op avgt false 500 419,2 531,9 ns/op avgt false 1000 840,4 1002,7 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5192,0 B/op</code> </pre> <br><p>  Was heiÃŸt plÃ¶tzlich!  Verbesserungen traten nicht nur nicht auf, sondern es trat auch eine Verschlechterung auf.  Verdammt, aber wie? </p><br><p>  Tatsache ist, dass ich ganz am Anfang in der Beschreibung der <code>StringBuilder::append</code> Methode eine kleine, aber kritisch wichtige Auslassung gemacht habe.  Die Methode wurde folgendermaÃŸen beschrieben: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Und hier ist die vollstÃ¤ndige Ansicht: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Der oben untersuchte Java-Code, der auf C2-Ebene erwÃ¤rmt und kompiliert wird, spielt keine Rolle, da er nicht ausgefÃ¼hrt wird, sondern der eigentliche Code.  Dies lÃ¤sst sich leicht beweisen, indem Sie das Profil mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async-Profiler</a> entfernen.  Im Folgenden wird das Profil fÃ¼r <code>length = 1000</code> und nicht <code>nonLatin = true</code> : </p><br><pre> <code class="plaintext hljs">#   `appendSubString`, JDK    ns percent samples top ---------- ------- ------- --- 19096340914 43.57% 1897673 jbyte_disjoint_arraycopy &lt;--------- 13500185356 30.80% 1343343 jshort_disjoint_arraycopy &lt;--------- 4124818581 9.41% 409533 java.lang.String.&lt;init&gt; #   2177311938 4.97% 216375 java.lang.StringUTF16.compress #   1557269661 3.55% 154253 java.util.Arrays.copyOfRange #   349344451 0.80% 34823 appendSubString_avgt_jmhStub 279803769 0.64% 27862 java.lang.StringUTF16.newString 274388920 0.63% 27312 org.openjdk.jmh.infra.Blackhole.consume 160962540 0.37% 15946 SpinPause 122418222 0.28% 11795 __memset_avx2</code> </pre> <br><p>  Der Code von <code>StringBuilder</code> (und <code>AbstractStringBuilder</code> ) riecht hier nicht einmal, fast 3/4 des Profils ist intrinsisch.  Ich mÃ¶chte ungefÃ¤hr das gleiche Bild im Profil unseres "verbesserten" <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p>  In der Tat haben wir dies: </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19071221451 43.78% 1897827 jbyte_disjoint_arraycopy 6409223440 14.71% 638348 jlong_disjoint_arraycopy 3933622128 9.03% 387403 java.lang.StringUTF16.newBytesFor 2067248311 4.75% 204193 java.lang.AbstractStringBuilder.ensureCapacityInternal 1929218737 4.43% 194751 java.lang.StringUTF16.compress 1678321343 3.85% 166458 java.util.Arrays.copyOfRange 1621470408 3.72% 160849 java.lang.String.checkIndex 969180099 2.22% 96018 java.util.Arrays.copyOf 581600786 1.34% 57818 java.lang.AbstractStringBuilder.&lt;init&gt; 417818533 0.96% 41611 appendBounds_jmhTest 406565329 0.93% 40479 java.lang.String.&lt;init&gt; 340972882 0.78% 33727 java.lang.AbstractStringBuilder.append 299895915 0.69% 29982 java.lang.StringBuilder.toString 183885595 0.42% 18136 SpinPause 168666033 0.39% 16755 org.openjdk.jmh.infra.Blackhole.consume</code> </pre> <br><p>  Sie werden sagen: "Hier sind sie ganz oben!"  In der Tat sind nur diese nicht die gleichen Eigenheiten (inkl. Vergleiche den Namen der zweiten von oben).  RÃ¼ckruf: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Hier ersetzt der Intrinsic den Aufruf von <code>StringBuilder.append(String)</code> , aber in unserem Patch ist dieser Aufruf nicht!  Wird als <code>AbstractStringBuilder.append(String)</code> .  Der <code>jbyte_disjoint_arraycopy</code> Aufruf von <code>jbyte_disjoint_arraycopy</code> ist der intrinsische Aufruf von <code>StringLatin1::inflate</code> , der von <code>AbstractStringBuider::putStringAt</code> Ã¼ber <code>String::getBytes</code> .  Das heiÃŸt, im Gegensatz zu <code>StringBuilder::append</code> verarbeitet es nicht nur plattformspezifischen, sondern auch Java-Code. </p><br><p>  Verstehen Sie die Fehlerursache und versuchen Sie, anderweitig erfolgreich zu sein.  Es ist leicht zu erraten, dass wir uns irgendwie auf <code>StringBuilder::append</code> beziehen mÃ¼ssen.  Sie kÃ¶nnen dies tun, indem Sie den vorherigen Patch abreiÃŸen und Ã„nderungen an <code>StringBuilder</code> selbst vornehmen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  @Override public StringBuilder append(CharSequence s, int start, int end) { super.append(s, start, end); return this; } //  @Override public StringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return this.append(s.subSequence(start, end).toString()); } }</span></span></code> </pre> <br><p>  Jetzt ist alles mit Bedacht erledigt: Der intrinsisierte StringBuilder :: append wird aufgerufen. <br>  Neu erstellen, ausfÃ¼hren, vergleichen: </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 60,2 ns/op avgt true 10 45,7 59,1 ns/op avgt true 50 129,0 164,6 ns/op avgt true 100 218,7 276,2 ns/op avgt true 500 907,1 1088,8 ns/op avgt true 1000 1626,4 1959,4 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 37,9 ns/op avgt false 10 24,0 37,9 ns/op avgt false 50 66,4 80,9 ns/op avgt false 100 111,0 125,6 ns/op avgt false 500 419,2 483,6 ns/op avgt false 1000 840,4 893,8 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5187,2 B/op</code> </pre><br><p>  Ich bin wirklich sehr traurig, aber es wurde nicht besser.  Jetzt ein neues Profil: </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19614374885 44.12% 1953620 jbyte_disjoint_arraycopy 6645299702 14.95% 662146 jlong_disjoint_arraycopy 4065789919 9.15% 400167 java.lang.StringUTF16.newBytesFor 2374627822 5.34% 234746 java.lang.AbstractStringBuilder.ensureCapacityInternal 1837858014 4.13% 183822 java.lang.StringUTF16.compress 1472039604 3.31% 145956 java.util.Arrays.copyOfRange 1316397864 2.96% 130747 appendBounds_jmhTest 956823151 2.15% 94959 java.util.Arrays.copyOf 573091712 1.29% 56933 java.lang.AbstractStringBuilder.&lt;init&gt; 434454076 0.98% 43202 java.lang.String.&lt;init&gt; 368480388 0.83% 36439 java.lang.AbstractStringBuilder.append 304409057 0.68% 30442 java.lang.StringBuilder.toString 272437989 0.61% 26833 SpinPause 201051696 0.45% 19985 java.lang.StringBuilder.&lt;init&gt; 198934052 0.45% 19810 appendBounds_avgt_jmhStub</code> </pre> <br><p>  Es hat sich wenig geÃ¤ndert.  FÃ¼r mich bleibt unklar, warum das Intrinsic beim Zugriff auf <code>StringBuilder.append(String)</code> aus <code>StringBuilder</code> nicht funktioniert hat.  Es besteht der Verdacht, dass das EinfÃ¼gen (Inlining) des Hauptteils der <code>StringBuilder.append(String)</code> -Methode in den Hauptteil von <code>StringBuilder.append(CharSequence, int, int)</code> etwas bei der Verarbeitung von VM-Methodenaufrufen Ã¤ndert. </p><br><p>  Wie auch immer, das ist ein Fiasko, Bruder.  Es war nicht mÃ¶glich, das JDK zu patchen, aber wir kÃ¶nnen den Austausch trotzdem manuell durchfÃ¼hren, wo es sinnvoll ist. </p><br><div class="spoiler">  <b class="spoiler_title">Failure Literary Retreat</b> <div class="spoiler_text"><blockquote>  Die AntwortverschlÃ¼sselung erfolgte in zwei Tagen.  Der Navigator mÃ¶chte sich nicht von Oto Velara trennen, einer Firma, die Ã¼berraschend schnelle und mÃ¤chtige Kriegsschiffe baut.  Der Navigator mÃ¶chte mir die VerschlÃ¼sselung nicht vorlesen.  Er wiederholt einfach die Antwort vom Kommandoposten: "Nein."  Die VerschlÃ¼sselung erklÃ¤rt nicht, warum "nein".  "Nein" bedeutet auf jeden Fall, dass er eine Person ist, die einem groÃŸen Computer bekannt ist.  Wenn nichts Ã¼ber ihn bekannt wÃ¤re, wÃ¤re die Antwort ja: probieren Sie es aus.  Schade.  Es ist schade, eine so interessante Person zu verlieren.  Und der Kommandant muss mir leid tun.  Vielleicht ist das erste Mal schade.  Er sieht mich in die Wikinger reiÃŸen.  Und er will mich nicht wieder in die Windhunde schieben. <br>  Er schweigt.  Aber ich weiÃŸ, dass bei einem wilden Mangel an ArbeitskrÃ¤ften: <br>  - Ich, Generalgenosse, arbeite morgen an der Versorgung.  Lass mich gehen? <br>  - Weiter.  - Und plÃ¶tzlich lÃ¤chelt sie.  "WeiÃŸt du, jede Wolke hat einen Silberstreifen." <br>  "Ich, Genosse General, bin immer krank ohne Gutes." <br>  "Und hier ist es."  Es war dir verboten, ihn zu treffen, das ist schlecht.  <strong>Aber zu den SchÃ¤tzen unserer Erfahrung haben wir ein weiteres Korn hinzugefÃ¼gt.</strong> </blockquote></div></div><br><p>  Schlussfolgerungen: </p><br><ul><li>  Der Code von JDK-Methoden hÃ¤ngt in einigen FÃ¤llen nicht mit der tatsÃ¤chlichen AusfÃ¼hrung zusammen, da anstelle des MethodenkÃ¶rpers ein intrinsischer Code ausgefÃ¼hrt werden kann, der im Darm der VM verborgen ist. </li><li>  Solche Methoden kÃ¶nnen erkannt werden, insbesondere die Bezeichnung <code>@HotSpotIntrinsicCandidate</code> zeigt auf sie, obwohl einige Methoden ohne Hinweis <code>@HotSpotIntrinsicCandidate</code> sind, z. B. <code>String::equals</code> (und <a href="">viele, viele andere</a> ). </li><li>  Die Schlussfolgerung aus den ersten beiden ist, dass unsere Diskussion darÃ¼ber, wie der JDK-Code funktioniert, mÃ¶glicherweise der RealitÃ¤t widerspricht.  C'est la vie </li></ul><br><p>  PS <br>  Ein weiterer mÃ¶glicher Ersatz: </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex); <span class="hljs-comment"><span class="hljs-comment">// --&gt; StringBuilder sb = new StringBuilder(str.substring(o, endIndex));</span></span></code> </pre> <br><p>  PPS <br>  Oracle-Entwickler weisen zu Recht darauf hin </p><br><blockquote>  Es erscheint mir ziemlich seltsam und Ã¼berraschend, einen Codepfad einzufÃ¼hren <br>  sb.append (cs, int, int), das Speicher zuweist, um zu einem intrinsischen Wert zu gelangen <br>  nur manchmal laufen die Dinge schneller.  Wie Sie beobachtet haben, ist die Leistung <br>  Kompromisse sind nicht offensichtlich. <br><br>  Wenn wir stattdessen sb.append (cs, int, int) optimieren mÃ¶chten, sollten wir vielleicht einfach gehen <br>  voraus und tun Sie dies, mÃ¶glicherweise durch HinzufÃ¼gen oder Neuanordnen der Eigenheiten. </blockquote><p>  Die vorgeschlagene LÃ¶sung ist die Intrinsifikation von <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabe</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion</a> </p><br><p>  <strong>PPS</strong> <br>  Interessanterweise im Moment, wenn man so etwas schreibt </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex));</code> </pre> <br><p>  "Idee" schlÃ¤gt vor, den Code zu vereinfachen </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(s, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex);</code> </pre> <br><p>  Wenn die Leistung an diesem Ort fÃ¼r Sie nicht sehr wichtig ist, ist es wahrscheinlich korrekter, die zweite, vereinfachte Version zu verwenden.  Der grÃ¶ÃŸte Teil des Codes, den wir schreiben, ist jedoch fÃ¼r unsere Kameraden bestimmt, nicht fÃ¼r Maschinen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436746/">https://habr.com/ru/post/de436746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436722/index.html">Diagnostisches medizinisches Expertensystem zu Prolog</a></li>
<li><a href="../de436730/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten GerÃ¤te der letzten 50 Jahre, Teil 5</a></li>
<li><a href="../de436740/index.html">Eigene Forschung, was kÃ¶nnen uns Open Source sagen?</a></li>
<li><a href="../de436742/index.html">Android Robotics bis 2019: Die wahre Geschichte; in 5 Teilen; Teil 1</a></li>
<li><a href="../de436744/index.html">Starten Sie Ihren Detektor fÃ¼r neuronale Netze mit dem Neural Compute Stick und OpenVINO auf dem Raspberry Pi</a></li>
<li><a href="../de436748/index.html">Hexapod von Grund auf neu entwickeln (Teil 3) - Kinematik</a></li>
<li><a href="../de436750/index.html">Trendanalyse des russischen YouTube fÃ¼r 2018</a></li>
<li><a href="../de436752/index.html">Der Kuchen ist eine LÃ¼ge</a></li>
<li><a href="../de436754/index.html">Q2VKPT: Quake II mit realistischer Beleuchtung komplett neu geschrieben</a></li>
<li><a href="../de436756/index.html">Isomorphismus eilt zur Rettung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>