<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏾 👵🏽 🕺🏾 Schnelles Compiler-Gerät. Teil 3 🎙️ 🕺🏻 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir studieren weiterhin den Swift-Compiler. Dieser Teil ist der Swift Intermediate Language gewidmet. 


 Wenn Sie die vorherigen nicht gesehen haben,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelles Compiler-Gerät. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/438696/"><img src="https://habrastorage.org/webt/w6/d3/5f/w6d35fpnglkxq8suebz-fhsl2de.png"><br><p>  Wir studieren weiterhin den Swift-Compiler.  Dieser Teil ist der Swift Intermediate Language gewidmet. </p><br><p>  Wenn Sie die vorherigen nicht gesehen haben, empfehle ich Ihnen, dem Link zu folgen und zu lesen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeiner Überblick über die Komponenten</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analysieren der Quelldatei</a> . <a name="habracut"></a></li></ul><br><h1 id="silgen">  Silgen </h1><br><p>  Der nächste Schritt besteht darin, den typisierten AST in rohen SIL zu konvertieren.  Swift Intermediate Language (SIL) ist eine speziell für Swift erstellte Zwischendarstellung.  Eine Beschreibung aller Anweisungen finden Sie in der <a href="">Dokumentation</a> . </p><br><p>  SIL hat ein SSA-Formular.  Static Single Assignment (SSA) - Eine Codedarstellung, bei der jeder Variablen nur einmal ein Wert zugewiesen wird.  Es wird aus regulärem Code durch Hinzufügen zusätzlicher Variablen erstellt.  Verwenden Sie beispielsweise ein numerisches Suffix, das die Version einer Variablen nach jeder Zuweisung angibt. </p><br><p>  Dank dieses Formulars ist es für den Compiler einfacher, den Code zu optimieren.  Unten finden Sie ein Beispiel für Pseudocode.  Offensichtlich ist die erste Zeile unnötig: </p><br><pre><code class="plaintext hljs">a = 1 a = 2 b = a</code> </pre> <br><p>  Das ist aber nur für uns.  Um dem Compiler beizubringen, dies zu bestimmen, müsste man nicht triviale Algorithmen schreiben.  Mit SSA ist dies jedoch viel einfacher.  Selbst für einen einfachen Compiler ist es offensichtlich, dass der Wert der Variablen <strong>a1</strong> nicht verwendet wird, und diese Zeile kann gelöscht werden: </p><br><pre> <code class="plaintext hljs">a1 = 1 a2 = 2 b1 = a2</code> </pre> <br><p>  Mit SIL können Sie bestimmte Optimierungen und Überprüfungen auf Swift-Code anwenden, die in der AST-Phase nur schwer oder gar nicht abgeschlossen werden können. </p><br><h3 id="ispolzovanie-generatora-sil">  Verwenden des SIL-Generators </h3><br><p>  Verwenden <strong>Sie</strong> zum Generieren von SIL das <strong>Flag -emit-silgen</strong> : </p><br><pre> <code class="plaintext hljs">swiftc -emit-silgen main.swift</code> </pre> <br><p>  Das Ergebnis des Befehls: </p><br><pre> <code class="plaintext hljs">sil_stage raw import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %8 %4 = metatype $@thin Int.Type // user: %7 %5 = integer_literal $Builtin.Int2048, 16 // user: %7 // function_ref Int.init(_builtinIntegerLiteral:) %6 = function_ref @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %7 %7 = apply %6(%5, %4) : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %8 store %7 to [trivial] %3 : $*Int // id: %8 %9 = integer_literal $Builtin.Int32, 0 // user: %10 %10 = struct $Int32 (%9 : $Builtin.Int32) // user: %11 return %10 : $Int32 // id: %11 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  SIL kann wie LLVM IR als Quellcode ausgegeben werden.  Sie können darin feststellen, dass zu diesem Zeitpunkt der Import der Swift-Module Builtin, Swift und SwiftShims hinzugefügt wurde. </p><br><p>  Trotz der Tatsache, dass Sie in Swift Code direkt im globalen Bereich schreiben können, generiert SILGen die Hauptfunktion, den Einstiegspunkt in das Programm.  Der gesamte Code befand sich darin, mit Ausnahme der Deklaration einer Konstante, da er global ist und überall zugänglich sein sollte. </p><br><p>  Die meisten Linien haben eine ähnliche Struktur.  Links befindet sich ein Pseudoregister, in dem das Ergebnis der Anweisung gespeichert ist.  Als nächstes - die Anweisung selbst und ihre Parameter und am Ende - ein Kommentar, der das Register angibt, für das dieses Register verwendet wird. </p><br><p>  In dieser Zeile wird beispielsweise ein ganzzahliges Literal vom Typ Int2048 und ein Wert von 16 erstellt. Dieses Literal wird im fünften Register gespeichert und zur Berechnung des Werts des siebten Registers verwendet: </p><br><pre> <code class="plaintext hljs">%5 = integer_literal $Builtin.Int2048, 16 // user: %7</code> </pre> <br><p>  Eine Funktionsdeklaration beginnt mit dem Schlüsselwort sil.  Das Folgende ist der Name mit dem Präfix @, der Aufrufkonvention, den Parametern, dem Rückgabetyp und dem Funktionscode.  Für den <strong>Int.init-</strong> Initialisierer <strong>(_builtinIntegerLiteral :) ist</strong> er natürlich nicht angegeben, da diese Funktion von einem anderen Modul stammt und nur deklariert, aber nicht definiert werden muss.  Ein Dollarzeichen zeigt den Beginn einer Typangabe an: </p><br><pre> <code class="plaintext hljs">// Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Aufrufkonvention</a> gibt an, wie eine Funktion ordnungsgemäß aufgerufen wird.  Dies ist erforderlich, um Maschinencode zu generieren.  Eine detaillierte Beschreibung dieser Prinzipien würde den Rahmen dieses Artikels sprengen. </p><br><p>  Der Name der Initialisierer sowie die Namen der Strukturen, Klassen, Methoden und Protokolle sind verzerrt (Name Mangling).  Dies löst mehrere Probleme gleichzeitig. </p><br><p>  Erstens können dieselben Namen in verschiedenen Modulen und verschachtelten Entitäten verwendet werden.  Beispielsweise wird für die erste Methode <strong>fff</strong> der Name <strong>S4main3AAAV3fffSiyF verwendet</strong> , und für die zweite <strong>Methode</strong> wird <strong>S4main3BBBVVffffSiyF verwendet</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff() -&gt; Int { return 8 } } struct BBB { func fff() -&gt; Int { return 8 } }</code> </pre> <br><p>  <strong>S</strong> bedeutet Swift, 4 ist die Anzahl der Zeichen im Modulnamen und 3 ist im Klassennamen.  Im Literalinitialisierer bezeichnet <strong>Si</strong> den Standardtyp Swift.Int. </p><br><p>  Zweitens werden dem Namen Namen und Arten von Funktionsargumenten hinzugefügt.  Dies ermöglicht die Verwendung von Überlast.  Für die erste Methode wird beispielsweise <strong>S4main3AAAV3fff3iiiS2i_tF</strong> generiert, und für die zweite Methode - <strong>S4main3AAAV3fff3dddSiSd_tF</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff(iii internalName: Int) -&gt; Int { return 8 } func fff(ddd internalName: Double) -&gt; Int { return 8 } }</code> </pre> <br><p>  Nach den Parameternamen wird der Typ des Rückgabewerts angegeben, gefolgt von den Parametertypen.  Ihre internen Namen werden jedoch nicht angegeben.  Leider gibt es in Swift keine Dokumentation zum Mangeln von Namen, und die Implementierung kann sich jederzeit ändern. </p><br><p>  Dem Namen der Funktion folgt ihre Definition.  Es besteht aus einem oder mehreren Grundblöcken.  Ein Basisblock ist eine Folge von Anweisungen mit einem Eintrittspunkt und einem Austrittspunkt, die keine Verzweigungsbefehle oder Bedingungen für einen vorzeitigen Austritt enthalten. </p><br><p>  Die Hauptfunktion hat eine Basiseinheit, die alle an die Funktion übergebenen Parameter als Eingabe verwendet und ihren gesamten Code enthält, da keine Verzweigungen darin sind: </p><br><pre> <code class="plaintext hljs">bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):</code> </pre> <br><p>  Wir können davon ausgehen, dass jeder durch geschweifte Klammern begrenzte Bereich eine separate Basiseinheit ist.  Angenommen, der Code enthält einen Zweig: </p><br><pre> <code class="plaintext hljs">// before if 2 &gt; 5 { // true } else { // false } // after</code> </pre> <br><p>  In diesem Fall werden mindestens 4 Basisblöcke generiert für: </p><br><ul><li>  Code vor der Verzweigung, </li><li>  Fälle, in denen der Ausdruck wahr ist </li><li>  Fälle, in denen der Ausdruck falsch ist </li><li>  Code nach der Verzweigung. </li></ul><br><p>  <strong>cond_br</strong> - Anweisung für den bedingten Sprung.  Wenn der Pseudoregister% 14-Wert wahr ist, wird der Übergang zum Block <strong>bb1 durchgeführt</strong> .  Wenn nicht, dann in <strong>bb2</strong> .  br - bedingungsloser Sprung, der die Ausführung des angegebenen Basisblocks startet: </p><br><pre> <code class="plaintext hljs">// before cond_br %14, bb1, bb2 // id: %15 bb1: // true br bb3 // id: %21 bb2: // Preds: bb0 // false br bb3 // id: %27 bb3: // Preds: bb2 bb1 // after</code> </pre> <br><p>  Quellcode: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SILGen-Implementierungsdateien</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIL-Header-Dateien</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIL-Implementierungsdateien</a> , </li><li>  <a href="">SIL-Dokumentation</a> . </li></ul><br><h1 id="sil-guaranteed-transformations">  SIL garantierte Transformationen </h1><br><p>  Die rohe Zwischendarstellung, die in der letzten Stufe erhalten wurde, wird auf Richtigkeit analysiert und in kanonisch umgewandelt: Die als transparent gekennzeichneten Funktionen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inline</a> (der Funktionsaufruf wird durch seinen Körper ersetzt), die Werte konstanter Ausdrücke werden berechnet, die Funktion wird überprüft, ob die Funktionen die Werte zurückgeben Tun Sie dies in allen Code-Zweigen und so weiter. </p><br><p>  Diese Konvertierungen sind obligatorisch und werden auch dann durchgeführt, wenn die Codeoptimierung deaktiviert ist. </p><br><h3 id="generaciya-kanonichnogo-sil">  Canon SIL Generation </h3><br><p>  Um kanonisches SIL zu generieren, wird das <strong>Flag -emit-sil</strong> verwendet: </p><br><pre> <code class="plaintext hljs">swiftc -emit-sil main.swift</code> </pre> <br><p>  Das Ergebnis des Befehls: </p><br><pre> <code class="plaintext hljs">sil_stage canonical import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %6 %4 = integer_literal $Builtin.Int64, 16 // user: %5 %5 = struct $Int (%4 : $Builtin.Int64) // user: %6 store %5 to %3 : $*Int // id: %6 %7 = integer_literal $Builtin.Int32, 0 // user: %8 %8 = struct $Int32 (%7 : $Builtin.Int32) // user: %9 return %8 : $Int32 // id: %9 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil public_external [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int { // %0 // user: %2 bb0(%0 : $Builtin.Int2048, %1 : $@thin Int.Type): %2 = builtin "s_to_s_checked_trunc_Int2048_Int64"(%0 : $Builtin.Int2048) : $(Builtin.Int64, Builtin.Int1) // user: %3 %3 = tuple_extract %2 : $(Builtin.Int64, Builtin.Int1), 0 // user: %4 %4 = struct $Int (%3 : $Builtin.Int64) // user: %5 return %4 : $Int // id: %5 } // end sil function '$SSi22_builtinIntegerLiteralSiBi2048__tcfC'</code> </pre> <br><p>  In einem so einfachen Beispiel gibt es nur wenige Änderungen.  Um die eigentliche Arbeit des Optimierers zu sehen, müssen Sie den Code etwas komplizieren.  Fügen Sie beispielsweise einen Zusatz hinzu: </p><br><pre> <code class="plaintext hljs">let x = 16 + 8</code> </pre> <br><p>  In seinem rohen SIL finden Sie die Hinzufügung dieser Literale: </p><br><pre> <code class="plaintext hljs">%13 = function_ref @$SSi1poiyS2i_SitFZ : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %14 %14 = apply %13(%8, %12, %4) : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %15</code> </pre> <br><p>  Aber im Kanonischen ist es nicht mehr da.  Stattdessen wird ein konstanter Wert von 24 verwendet: </p><br><pre> <code class="plaintext hljs">%4 = integer_literal $Builtin.Int64, 24 // user: %5</code> </pre> <br><p>  Quellcode: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIL Optimizer Obligatorisch</a> </li></ul><br><h1 id="sil-optimization">  Sil Optimierung </h1><br><p>  Zusätzliche Swift-spezifische Transformationen werden angewendet, wenn die Optimierung aktiviert ist.  Dazu gehören die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezialisierung von Generika</a> (Optimierung des generischen Codes für einen bestimmten Parametertyp), die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Devirtualisierung</a> (Ersetzen dynamischer Aufrufe durch statische), Inlining, <a href="">ARC-Optimierung</a> und vieles mehr.  Eine Erklärung dieser Techniken passt nicht in einen bereits überwucherten Artikel. </p><br><p>  Quellcode: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIL Optimizer-Header</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIL Optimizer-Implementierungsdateien</a> </li></ul><br><p>  Da SIL eine Swift-Funktion ist, habe ich diesmal keine Implementierungsbeispiele gezeigt.  Wir werden im nächsten Teil zum Klammer-Compiler zurückkehren, wenn wir uns mit der LLVM-IR-Generierung beschäftigen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438696/">https://habr.com/ru/post/de438696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438682/index.html">Jubiläumsstart der iranischen Astronautik</a></li>
<li><a href="../de438688/index.html">PCIe 5.0-Bus zur Inbetriebnahme bereit</a></li>
<li><a href="../de438690/index.html">Wenn Pascals CRT-Modul in JavaScript war</a></li>
<li><a href="../de438692/index.html">Trägheit fliegende Untertasse. Alles abschieben</a></li>
<li><a href="../de438694/index.html">Wie sich der Site-Support-Prozess in den letzten zwanzig Jahren verändert hat</a></li>
<li><a href="../de438698/index.html">Tragödiensystemd</a></li>
<li><a href="../de438700/index.html">Unfallkarte</a></li>
<li><a href="../de438708/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 350 (28. Januar - 3. Februar 2019)</a></li>
<li><a href="../de438710/index.html">Frontend Weekly Digest (28. Januar - 3. Februar 2019)</a></li>
<li><a href="../de438714/index.html">Übersicht über Veeam Backup & Replication 9.5 Update 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>