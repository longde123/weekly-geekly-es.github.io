<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎽 💽 👊🏼 Buku “Pure Python. Seluk-beluk pemrograman untuk pro » 🐴 💪🏽 🚼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Mempelajari semua kemungkinan Python adalah tugas yang sulit, dan dengan buku ini Anda dapat fokus pada keterampilan praktis yang s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku “Pure Python. Seluk-beluk pemrograman untuk pro »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418761/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/oz/1p/h5/oz1ph5r8f1tudkyhxgbg-tdwhtc.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Mempelajari semua kemungkinan Python adalah tugas yang sulit, dan dengan buku ini Anda dapat fokus pada keterampilan praktis yang sangat penting.  Gali emas tersembunyi di pustaka standar Python dan mulailah menulis kode bersih hari ini. <br><br>  Jika Anda memiliki pengalaman dengan versi Python yang lebih lama, Anda bisa mempercepat pekerjaan dengan templat dan fungsi modern yang diperkenalkan di Python 3. <br><br>  Jika Anda telah bekerja dengan bahasa pemrograman lain dan ingin beralih ke Python, Anda akan menemukan tips praktis yang diperlukan untuk menjadi pythonist yang efektif. <br>  Jika Anda ingin belajar cara menulis kode bersih, Anda akan menemukan contoh paling menarik di sini dan trik yang kurang dikenal. <br><br><h3>  Kutipan "Ekspresi Kamus Paling Gila di Barat" </h3><br>  Kadang-kadang Anda menemukan contoh kecil kode yang memiliki kedalaman yang benar-benar tak terduga - satu baris kode yang dapat banyak mengajarkan Anda jika Anda memikirkannya dengan cermat.  Sepotong kode seperti koan dalam Buddhisme Zen: pertanyaan atau pernyataan yang digunakan dalam praktik Zen untuk menimbulkan keraguan dan menguji prestasi siswa. <br><a name="habracut"></a><br>  Sepotong kecil kode yang kita bahas di bagian ini adalah salah satu contohnya.  Pada pandangan pertama, ini mungkin terlihat seperti ekspresi kosakata langsung, tetapi setelah pemeriksaan lebih dekat mengirimkan Anda pada pelayaran psychedelic yang memperluas pikiran dengan penerjemah Python. <br><br>  Saya mendapatkan buzz dari one-liner ini yang bahkan pernah saya cetak di lencana peserta konferensi Python saya sebagai alasan untuk percakapan.  Ini menyebabkan beberapa dialog konstruktif dengan anggota buletin email Python saya. <br>  Jadi, tanpa basa-basi lagi, inilah potongan kode ini.  Beristirahat sejenak untuk merenungkan ekspresi kosakata di bawah ini dan apa yang harus diakibatkan oleh perhitungannya: <br><br><pre><code class="hljs css">&gt;&gt;&gt; {<span class="hljs-attribute"><span class="hljs-attribute">True</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>}</code> </pre> <br>  Saya akan menunggu di sini ... <br><br>  Oke siap <br><br>  Berikut ini adalah hasil yang kami dapatkan ketika mengevaluasi ekspresi kamus di atas dalam sesi juru bahasa Python: <br><br><pre> <code class="hljs css">&gt;&gt;&gt; {<span class="hljs-attribute"><span class="hljs-attribute">True</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>} {<span class="hljs-attribute"><span class="hljs-attribute">True</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>}</code> </pre> <br>  Saya akui, ketika saya melihat hasil ini untuk pertama kalinya, saya sangat tercengang.  Tapi semuanya akan jatuh ke tempatnya ketika Anda melakukan studi langkah demi langkah santai tentang apa yang terjadi di sini.  Mari kita renungkan mengapa kita mendapatkan ini, harus saya katakan, bukan hasil yang sangat intuitif. <br><br>  Saat Python memproses ekspresi kamus kami, pertama-tama ia membangun objek kamus kosong yang baru, dan kemudian memberikan kunci dan nilai-nilai padanya dalam urutan yang dilewatkan ke ekspresi kamus. <br><br>  Kemudian, ketika kami menguraikannya menjadi beberapa bagian, ekspresi kamus kami akan setara dengan urutan instruksi berikut yang dijalankan secara berurutan: <br><br><pre> <code class="hljs powershell">&gt;&gt;&gt; xs = dict() &gt;&gt;&gt; xs[<span class="hljs-type"><span class="hljs-type">True</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span> &gt;&gt;&gt; xs[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span> &gt;&gt;&gt; xs[<span class="hljs-number"><span class="hljs-number">1.0</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br>  Anehnya, Python menganggap semua kunci yang digunakan dalam kamus ini setara dengan: <br><br><pre> <code class="hljs python"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">True</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Oke, tapi tunggu sebentar.  Saya yakin Anda secara intuitif dapat mengakui bahwa 1,0 == 1, tetapi mengapa True dianggap juga setara dengan 1?  Pertama kali saya melihat ungkapan kamus ini, itu benar-benar membingungkan saya. <br><br>  Mengaduk-aduk sedikit dalam dokumentasi Python, saya menemukan bahwa Python memperlakukan tipe bool sebagai subkelas dari tipe int.  Ini adalah kasus dalam Python 2 dan Python 3: <br><br><blockquote>  Tipe boolean adalah subtipe dari tipe integer, dan nilai boolean berperilaku, masing-masing, sebagai nilai 0 dan 1 di hampir semua konteks, dengan pengecualian bahwa ketika dikonversi ke tipe string, nilai string 'False' atau 'True dikembalikan, masing-masing ' </blockquote><br>  Dan tentu saja, ini berarti bahwa dalam Python, nilai Boolean secara teknis dapat digunakan sebagai daftar atau indeks tuple: <br><br><pre> <code class="hljs markdown">&gt;&gt;&gt; [<span class="hljs-string"><span class="hljs-string">'', ''</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">True</span></span>] ''</code> </pre> <br>  Tetapi Anda mungkin tidak boleh menggunakan variabel logis semacam ini atas nama kejelasan (dan kesehatan mental kolega Anda). <br><br>  Dengan satu atau lain cara, kembali ke ekspresi kamus kami. <br><br>  Adapun bahasa Python, semua nilai ini - Benar, 1, dan 1.0 - mewakili kunci kamus yang sama.  Ketika penerjemah mengevaluasi ekspresi kamus, itu berulang kali menimpa nilai kunci Sejati.  Ini menjelaskan mengapa di bagian paling akhir kamus yang dihasilkan hanya berisi satu kunci. <br><br>  Sebelum kita melangkah lebih jauh, lihat kembali ekspresi kamus asli: <br><br><pre> <code class="hljs css">&gt;&gt;&gt; {<span class="hljs-attribute"><span class="hljs-attribute">True</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>} {<span class="hljs-attribute"><span class="hljs-attribute">True</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>}</code> </pre> <br>  Mengapa kita masih mendapatkan True sebagai kuncinya di sini?  Bukankah kuncinya juga berubah menjadi 1.0 karena penugasan berulang di akhir? <br><br>  Setelah sedikit riset dalam kode sumber interpreter Python, saya menemukan bahwa ketika nilai baru dikaitkan dengan objek kunci, kamus Python sendiri tidak memperbarui objek kunci ini: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; ys = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>} &gt;&gt;&gt; ys[True] = <span class="hljs-string"><span class="hljs-string">''</span></span> &gt;&gt;&gt; ys {<span class="hljs-number"><span class="hljs-number">1.0</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>}</code> </pre> <br>  Tentu saja, ini masuk akal sebagai optimasi kinerja: jika kunci dianggap identik, lalu mengapa membuang waktu memperbarui yang asli? <br>  Dalam contoh terakhir, Anda melihat bahwa objek True asli sebagai kunci tidak pernah diganti.  Untuk alasan ini, representasi string dari kamus masih mencetak kunci sebagai True (bukan 1 atau 1.0). <br><br>  Dengan apa yang sekarang kita ketahui, tampaknya, nilai-nilai dalam kamus yang dihasilkan ditulis ulang hanya karena perbandingan akan selalu menunjukkannya sebagai setara satu sama lain.  Namun, ternyata efek ini juga bukan konsekuensi dari pengujian untuk kesetaraan dengan metode __eq__. <br><br>  Kamus python bergantung pada struktur data tabel hash.  Ketika saya pertama kali melihat ungkapan kamus yang luar biasa ini, pikiran pertama saya adalah bahwa perilaku semacam itu entah bagaimana terkait dengan konflik hash. <br><br>  Faktanya adalah bahwa tabel hash dalam representasi internal menyimpan kunci yang tersedia di dalamnya dalam berbagai "keranjang" sesuai dengan nilai hash dari setiap kunci.  Nilai hash diturunkan dari kunci sebagai nilai numerik panjang tetap yang secara unik mengidentifikasi kunci. <br><br>  Fakta ini memungkinkan Anda untuk melakukan operasi pencarian cepat.  Menemukan nilai hash kunci dalam tabel pencarian jauh lebih cepat daripada membandingkan objek kunci lengkap dengan semua kunci lainnya dan melakukan pemeriksaan kesetaraan. <br><br>  Namun, metode untuk menghitung nilai hash umumnya tidak ideal.  Dan pada akhirnya, dua atau lebih kunci yang sebenarnya berbeda akan memiliki nilai hash turunan yang sama, dan mereka akan berakhir di keranjang tabel pencarian yang sama. <br>  Ketika dua kunci memiliki nilai hash yang sama, situasi ini disebut konflik hash dan merupakan kasus khusus dimana algoritma untuk memasukkan dan menemukan elemen dalam tabel hash harus ditangani. <br><br>  Berdasarkan penilaian ini, sangat mungkin bahwa hashing entah bagaimana terkait dengan hasil yang tidak terduga yang kami peroleh dari ekspresi kamus kami.  Oleh karena itu, mari kita cari tahu apakah nilai hash kunci juga memainkan peran tertentu di sini. <br>  Saya mendefinisikan kelas di bawah ini sebagai alat detektif kecil: <br><br><pre> <code class="hljs python"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlwaysEquals</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__eq__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, other)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__hash__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id(self)</code> </pre> <br>  Kelas ini ditandai oleh dua aspek. <br><br>  Pertama, karena metode Dunder __eq__ selalu mengembalikan True, semua instance dari kelas ini berpura-pura sama dengan objek apa pun: <br><br><pre> <code class="hljs python"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>AlwaysEquals() == AlwaysEquals() <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; AlwaysEquals() == <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; AlwaysEquals() == <span class="hljs-string"><span class="hljs-string">'?'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Dan kedua, setiap instance dari AlwaysEquals juga akan mengembalikan nilai hash unik yang dihasilkan oleh fungsi bawaan id (): <br><br><pre> <code class="hljs powershell">&gt;&gt;&gt; objects = [<span class="hljs-type"><span class="hljs-type">AlwaysEquals</span></span>(), <span class="hljs-type"><span class="hljs-type">AlwaysEquals</span></span>(), <span class="hljs-type"><span class="hljs-type">AlwaysEquals</span></span>()] &gt;&gt;&gt; [<span class="hljs-type"><span class="hljs-type">hash</span></span>(<span class="hljs-type"><span class="hljs-type">obj</span></span>) <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">obj</span></span> <span class="hljs-type"><span class="hljs-type">in</span></span> <span class="hljs-type"><span class="hljs-type">objects</span></span>] [<span class="hljs-number"><span class="hljs-number">4574298968</span></span>, <span class="hljs-number"><span class="hljs-number">4574287912</span></span>, <span class="hljs-number"><span class="hljs-number">4574287072</span></span>]</code> </pre> <br>  Dalam Python, fungsi id () mengembalikan alamat suatu objek dalam RAM, yang dijamin unik. <br><br>  Menggunakan kelas ini, Anda sekarang dapat membuat objek yang berpura-pura setara dengan objek lain, tetapi pada saat yang sama memiliki nilai hash unik yang terkait dengannya.  Ini akan memungkinkan Anda untuk memeriksa apakah kunci kamus ditulis ulang, hanya mengandalkan hasil perbandingan mereka pada kesetaraan. <br><br>  Dan, seperti yang Anda lihat, kunci-kunci dalam contoh berikut ini tidak sesuai, meskipun perbandingan akan selalu menunjukkan mereka setara satu sama lain: <br><br><pre> <code class="hljs cs">&gt;&gt;&gt; {AlwaysEquals(): <span class="hljs-string"><span class="hljs-string">''</span></span>, AlwaysEquals(): <span class="hljs-string"><span class="hljs-string">''</span></span>} { &lt;AlwaysEquals <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> at <span class="hljs-number"><span class="hljs-number">0x110a3c588</span></span>&gt;: <span class="hljs-string"><span class="hljs-string">''</span></span>, &lt;AlwaysEquals <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> at <span class="hljs-number"><span class="hljs-number">0x110a3cf98</span></span>&gt;: <span class="hljs-string"><span class="hljs-string">''</span></span> }</code> </pre> <br>  Kami juga dapat melihat ide ini dari sisi lain dan memeriksa apakah mengembalikan nilai hash yang sama adalah alasan yang cukup untuk memaksa kunci untuk ditulis ulang: <br><br><pre> <code class="hljs python"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SameHash</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__hash__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Membandingkan instance dari kelas SameHash akan menunjukkan mereka tidak setara satu sama lain, tetapi mereka semua akan memiliki nilai hash yang sama yaitu 1: <br><br><pre> <code class="hljs bash">&gt;&gt;&gt; a = SameHash() &gt;&gt;&gt; b = SameHash() &gt;&gt;&gt; a == b False &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(a), <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(b) (1, 1)</code> </pre> <br>  Mari kita lihat bagaimana kamus Python merespons ketika kita mencoba menggunakan instance kelas SameHash sebagai kunci kamus: <br><br><pre> <code class="hljs mel">&gt;&gt;&gt; {a: <span class="hljs-string"><span class="hljs-string">'a'</span></span>, b: <span class="hljs-string"><span class="hljs-string">'b'</span></span>} { &lt;SameHash <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> at <span class="hljs-number"><span class="hljs-number">0x7f7159020cb0</span></span>&gt;: <span class="hljs-string"><span class="hljs-string">'a'</span></span>, &lt;SameHash <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> at <span class="hljs-number"><span class="hljs-number">0x7f7159020cf8</span></span>&gt;: <span class="hljs-string"><span class="hljs-string">'b'</span></span> }</code> </pre> <br>  Seperti contoh ini menunjukkan, efek "kunci ditimpa" disebabkan tidak hanya oleh konflik nilai hash. <br><br>  Kamus melakukan pemeriksaan ekivalensi dan membandingkan nilai hash untuk menentukan apakah kedua kunci itu sama.  Mari kita coba merangkum hasil penelitian kami. <br><br>  Ekspresi kamus {Benar: 'ya', 1: 'tidak', 1.0: 'mungkin'} dihitung sebagai {Benar: 'mungkin'}, karena membandingkan semua kunci dari contoh ini, Benar, 1, dan 1.0, akan menunjukkan kepada mereka sebagai setara satu sama lain, dan mereka semua memiliki nilai hash yang sama: <br><br><pre> <code class="hljs lisp">&gt;&gt;&gt; True == <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">1.0</span></span> True &gt;&gt;&gt; (<span class="hljs-name"><span class="hljs-name">hash</span></span>(<span class="hljs-name"><span class="hljs-name">True</span></span>), hash(<span class="hljs-number"><span class="hljs-number">1</span></span>), hash(<span class="hljs-number"><span class="hljs-number">1.0</span></span>)) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Mungkin sekarang ini tidak begitu mengejutkan bahwa kita mendapatkan hasil seperti keadaan akhir dari kamus: <br><br><pre> <code class="hljs css">&gt;&gt;&gt; {<span class="hljs-attribute"><span class="hljs-attribute">True</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>} {<span class="hljs-attribute"><span class="hljs-attribute">True</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>}</code> </pre> <br>  Di sini kami membahas banyak topik, dan trik Python khusus ini mungkin tidak cocok di kepala pada awalnya - itu sebabnya pada awal bagian saya membandingkannya dengan koan Zen. <br><br>  Jika Anda kesulitan memahami apa yang terjadi di bagian ini, cobalah bereksperimen dengan semua contoh kode dalam sesi juru bahasa Python secara bergantian.  Anda akan dihargai dengan memperluas pengetahuan Anda tentang mekanisme internal bahasa Python. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 20% untuk penjaja - <b>Python</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418761/">https://habr.com/ru/post/id418761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418751/index.html">Dex mata-mata Cina kurang ajar</a></li>
<li><a href="../id418753/index.html">vSAN di VMware Cloud</a></li>
<li><a href="../id418755/index.html">Bagaimana e-commerce bertahan dalam promosi skala besar. Bersiap-siap untuk beban puncak di web [Bagian 1]</a></li>
<li><a href="../id418757/index.html">Kerangka waktu yang menipis (cryptocurrency, forex, exchange)</a></li>
<li><a href="../id418759/index.html">Berapa biaya bagi siswa untuk mengeluarkan chip?</a></li>
<li><a href="../id418763/index.html">Menengah / senior: bagaimana cara keluar dari rawa?</a></li>
<li><a href="../id418765/index.html">Tips Dadata membantu mengisi formulir input apa pun. Sekarang sembuh</a></li>
<li><a href="../id418767/index.html">Warisan game yang sangat besar dari Adobe Flash dan upaya saya untuk menyimpannya</a></li>
<li><a href="../id418769/index.html">Contoh penghitungan "faktor ketersediaan" untuk sistem TI</a></li>
<li><a href="../id418775/index.html">Cara menghapus dan "menempelkan" panorama bulat di DJI Mavic Air</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>