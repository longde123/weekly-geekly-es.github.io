<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143967986-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-143967986-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèº üí∑ üë©üèΩ‚Äçüé§ Ways to find the goal. The role of chance üç° üë®üèº‚Äçüîß ‚≠êÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 
 The search can be either complex or simple. When not known (or only partially known) both the goal itself and the way to achieve it,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ways to find the goal. The role of chance</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479414/"><h4>  1. Introduction </h4><br>  The search can be either complex or simple.  When not known (or only partially known) both the goal itself and the way to achieve it, chance is important <br><br>  The aim of the research article is to compare the methods of finding the target as moving (yellow object), and motionless. <br><br>  These methods: <br><br><ul><li>  Random search (red object) </li><li>  Random search with memory (blue object) </li><li>  Random search with memory and hierarchy (green object) </li><li>  Search for the first route (purple object) </li><li>  Search for a short route (brown object) </li></ul><br>  In Fig. 1, these objects are shown.  Fully program code posted on <a href="https://github.com/bulygina07/rp/blob/master/random_path.py">github</a> <br><br><img src="https://habrastorage.org/webt/qm/73/tj/qm73tjbhq60wc-ohyw8uuoxmli0.jpeg"><br><a name="habracut"></a><br><h4>  2. The main part </h4><br>  2.1.  Class P - Random Search <br><br>  The constructor initializes class attributes and variables: main window, color, y and x coordinate, counter, visited dictionary, target, hierarchy dictionary, neighbors dictionary.  The init_3_dict method populates three dictionaries.  The show method paints the cell in the desired color.  The update method updates the object.  The top_show method creates a top-level window and shows how many steps are taken to the target. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, root, color, node, target, maps, ban)</span></span></span><span class="hljs-function">:</span></span> self.root = root self.color = color self.y = node[<span class="hljs-number"><span class="hljs-number">0</span></span>] self.x = node[<span class="hljs-number"><span class="hljs-number">1</span></span>] P.target = target self.count = <span class="hljs-number"><span class="hljs-number">0</span></span> self.visit = {} P.hierarchy = {} P.neighbor = {} self.init_3_dict(maps, ban)</code> </pre> <br>  The is_en function is declared in the init_3_dict method, which checks that the coordinate is not banned and does not go beyond the map. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_3_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, maps, ban)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_en</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(yx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> yx[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; len(maps)<span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> yx[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; len(maps[<span class="hljs-number"><span class="hljs-number">0</span></span>])<span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ban: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br>  In a cycle, in the dictionary visited with the coordinate key, write the initial value zero.  In the hierarchy dictionary with the same key, write the hierarchical name of this coordinate.  Then we fill in the dictionary of neighbors by calling the is_en function. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(maps)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(maps[<span class="hljs-number"><span class="hljs-number">0</span></span>])): self.visit[(y,x)] = <span class="hljs-number"><span class="hljs-number">0</span></span> P.hierarchy[(y,x)] = maps[y][x] n = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y<span class="hljs-number"><span class="hljs-number">-1</span></span>,x)): n.append((y<span class="hljs-number"><span class="hljs-number">-1</span></span>,x)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y+<span class="hljs-number"><span class="hljs-number">1</span></span>,x)): n.append((y+<span class="hljs-number"><span class="hljs-number">1</span></span>,x)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y,x<span class="hljs-number"><span class="hljs-number">-1</span></span>)): n.append((y,x<span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y,x+<span class="hljs-number"><span class="hljs-number">1</span></span>)): n.append((y,x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) P.neighbor[(y,x)] = n</code> </pre><br>  The show method paints a cell with y, x coordinates in the desired color. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, y, x, color)</span></span></span><span class="hljs-function">:</span></span> lb = Label(text=<span class="hljs-string"><span class="hljs-string">" "</span></span>, background = color) lb.configure(text=P.hierarchy[(y,x)] ) lb.grid(row=self.y, column=self.x, ipadx=<span class="hljs-number"><span class="hljs-number">10</span></span>, ipady=<span class="hljs-number"><span class="hljs-number">5</span></span>, padx=<span class="hljs-number"><span class="hljs-number">1</span></span>, pady=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  The move method moves the object.  In the variables y, x we ‚Äã‚Äãwrite the coordinate of the neighbor, which is randomly selected from the list of neighbors.  Then we redraw with the new coordinates. <br><br>  We increase the counter.  Check if the goal is achieved.  If the goal is achieved, then in the variable of the class J.disable we write correctly.  We call the top_show () method. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[(self.y, self.x)]: v.append(i) y,x = random.choice(v) self.show(self.y, self.x, <span class="hljs-string"><span class="hljs-string">'white'</span></span>) self.y = y self.x = x self.show(y, x, self.color) self.count +=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> P.target == P.hierarchy[(self.y, self.x)]: J.disable = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.top_show()</code> </pre><br>  The update method calls move and updates every half second. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.move() self.root.after(<span class="hljs-number"><span class="hljs-number">500</span></span>, self.update)</code> </pre><br>  The top_show method displays the results. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> top = Toplevel() lbt = Label(top, text=self.color + <span class="hljs-string"><span class="hljs-string">" = "</span></span> + str(self.count)) lbt.pack() top.mainloop()</code> </pre><br>  2.2.  Class M - Random Memory Search <br><br>  The constructor calls the constructor of the parent class and increases the value of the cell of the field where we are going.  The move method moves the object.  The choice method returns the coordinate that the random search algorithm with memory has selected. <br><br>  In the move method, call the choice method.  Otherwise, his work is similar to the parent's method. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> yx = self.choice((self.y, self.x))</code> </pre><br>  The choice method iterates over the coordinates of neighbors and adds tuples to the list v.  The first element of the tuple will be the coordinate of the neighbor, the second - how many times it has been visited.  Then we sort from small to large.  We sort through all the tuples and in the list v we leave only those that occurred as many times as recorded in the first tuple.  Randomly select any of them. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, yx)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[yx]: v.append((i, self.visit[i])) v.sort(key = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) v = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] == i[<span class="hljs-number"><span class="hljs-number">1</span></span>]] v = random.choice(v) self.visit[v[<span class="hljs-number"><span class="hljs-number">0</span></span>]] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  2.3.  Class N - random search with memory and hierarchy. <br><br>  The choice method selects those tuples that most closely match the hierarchical name of the target.  If this match is the same, then the coordinates that were least visited are selected. <br><br>  The constructor calls the constructor of the parent and initializes the coincidence attribute the number of character matches of the hierarchical name with the target. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, root, color, node, target, maps, ban)</span></span></span><span class="hljs-function">:</span></span> super().__init__(root, color, node, target, maps, ban) self.coincidence = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  The choice method in the loop writes the hierarchical name of the current coordinate of the neighbor.  The variable r stores the number of matches of this variable with the target.  If the number of matches r is greater, then coincidence is overwritten.  In this case, the tuple (coordinates, number of visits) from the list v is written to the list d.  If r is equal to coincidence, then in d we add a tuple from v. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, yx)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[yx]: v.append((i, self.visit[i])) d = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v: c = P.hierarchy[l[<span class="hljs-number"><span class="hljs-number">0</span></span>]] r = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(P.target)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c[i] == P.target[i]: r +=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r &gt; self.coincidence: self.coincidence = r d = [l] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r == self.coincidence: d.append(l) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d: v = d v.sort(key = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) v = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] == i[<span class="hljs-number"><span class="hljs-number">1</span></span>]] v = random.choice(v) self.visit[v[<span class="hljs-number"><span class="hljs-number">0</span></span>]] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  2.4.  Class K - search for a route and search for the shortest route. <br><br>  The constructor writes end coordinates to the end variable.  If the short parameter is False, then we call the route search.  Otherwise, we find the shortest route. <br><br>  The find_path method adds the current coordinate to the route.  If the goal is reached, then returns the route.  We sort through all the neighbors.  If there is no neighbor in path, then call ourselves recursively.  And the fact that the method returns is written to newpath.  The first route found will be newpath.  The difference between the find_short_path method is that if the length of newpath is greater than or equal to the length of shortest, then shortest is overwritten. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node, end, path=[])</span></span></span><span class="hljs-function">:</span></span> path = path + [node] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[node]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> path: newpath = self.find_path(v, end, path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newpath: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newpath</code> </pre><br>  2.5.  Class J is a moving target. <br><br>  An object of class J moves like class P. If the variable of class J.disable is true, then the object stops. <br><br>  2.6.  Function main. <br><br>  Create the main window.  In the target variable, write the hierarchical name of the target.  The ban list contains the coordinates of the forbidden cells.  In the list of maps, the map itself.  In the loop we draw a map.  Create class objects.  Then we call the update function, which updates the objects. <br><br><h4>  3. Conclusions </h4><br>  Five experiments were carried out both for a moving target and for a motionless one. <br><br>  Table 1 shows that the best algorithm is the shortest route.  The second most effective is a random search with memory and hierarchy.  The worst is random search. <br><br>  Table 1. Fixed target <br><br><img src="https://habrastorage.org/webt/lv/w3/_7/lvw3_7ehvk3w0oeffgo8nyrq5zk.jpeg" alt="image"><br><br>  In the case of a moving target, the results are different.  The worst algorithms were those that initially calculated the route to the goal.  In table 2, a dash indicates that the goal has not been achieved.  Brown turned out to be worse than Violet.  Worse, because Violet has a longer trajectory (the chance to meet a moving target is greater).  The best algorithm when searching for a moving target is a random search with memory and hierarchy.  In second place is a random search with memory. <br><br>  Table 2. Moving Target <br><br><img src="https://habrastorage.org/webt/3r/_d/58/3r_d58csbdvlpe0abgm49s8pp44.jpeg" alt="image"><br><br>  If it is not known whether the target is moving or not, then it is better to use the random search algorithm with memory and hierarchy or just random search with memory. <br><br><h4>  4. Conclusion </h4><br>  Randomness is important if the search for a target occurs in the face of uncertainty.  Search is reduced if data is presented hierarchically.  Memory, of course, is also valuable. </div></div><p>Source: <a href="https://habr.com/ru/post/479414/">https://habr.com/ru/post/479414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479398/index.html">We bring the linear regression equation into matrix form</a></li>
<li><a href="../479400/index.html">How to make a journalist out of a neural network, or "Secrets of reducing the text on Habr√© without a word"</a></li>
<li><a href="../479402/index.html">How to officially pay for freelancer services abroad, pay 0% taxes and not feed payment systems</a></li>
<li><a href="../479404/index.html">Staff for Santa Claus</a></li>
<li><a href="../479406/index.html">16 development tips for Android in Kotlin. Part 1</a></li>
<li><a href="../479416/index.html">See where you are going (peripheral vision vs cognitive load)</a></li>
<li><a href="../479420/index.html">Open microphone: backend. Guest Registration</a></li>
<li><a href="../479422/index.html">[Video animation] Wired world: how in 35 years a network of submarine cables enveloped the globe</a></li>
<li><a href="../479426/index.html">Security Week 50: Man-in-the-middle attacks in Confluence and Linux</a></li>
<li><a href="../479428/index.html">Digital events in Moscow from December 9 to 15</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter54458986 = new Ya.Metrika({
                  id:54458986,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/54458986" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-143967986-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=IU0EG0jaqnehka2lu5TyzAcchrZXI4Yb1QXKQvJxpqE&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>