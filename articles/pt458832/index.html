<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📐 👋🏿 🔧 Cinco alunos e três lojas de valores-chave distribuídos 🕯️ 🤳🏿 🐄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ou, como escrevemos a biblioteca C ++ do cliente para o ZooKeeper, etcd e Consul KV 
 No mundo dos sistemas distribuídos, existem várias tarefas típic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cinco alunos e três lojas de valores-chave distribuídos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458832/"><h2>  Ou, como escrevemos a biblioteca C ++ do cliente para o ZooKeeper, etcd e Consul KV </h2><br>  No mundo dos sistemas distribuídos, existem várias tarefas típicas: armazenar informações sobre a composição do cluster, gerenciar a configuração de nós, detectar nós com falha, escolher um líder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">e outros</a> .  Para resolver esses problemas, foram criados sistemas distribuídos especiais - serviços de coordenação.  Agora estaremos interessados ​​em três deles: ZooKeeper, etcd e Consul.  De toda a rica funcionalidade do Consul, vamos nos concentrar no Consul KV. <br><br><img src="https://habrastorage.org/webt/j2/ut/gh/j2utghbsb8egpxnz1ct4k3dqtbk.jpeg"><br><br>  De fato, todos esses sistemas são armazenamentos de valores-chave linearizados e tolerantes a falhas.  Embora seus modelos de dados tenham diferenças significativas, que discutiremos mais adiante, eles nos permitem resolver os mesmos problemas práticos.  Obviamente, cada aplicativo que usa o serviço de coordenação está vinculado a um deles, o que pode levar à necessidade de oferecer suporte a vários sistemas que resolvem as mesmas tarefas em um datacenter para aplicativos diferentes. <br><br>  A idéia, projetada para resolver esse problema, teve origem em uma agência de consultoria australiana e nós, uma pequena equipe de estudantes, tivemos que implementá-la, sobre a qual vou falar. <br><a name="habracut"></a><br>  Conseguimos criar uma biblioteca que fornece uma interface comum para trabalhar com o ZooKeeper, etcd e o Consul KV.  A biblioteca é escrita em C ++, mas há planos para portar para outros idiomas. <br><br><h3>  Modelos de dados </h3><br>  Para desenvolver uma interface comum para três sistemas diferentes, você precisa entender o que eles têm em comum e como eles diferem.  Vamos acertar. <br><br>  <b>Zookeeper</b> <br><br><img src="https://habrastorage.org/webt/dv/7g/bu/dv7gbu5u-rvvg91d7qukhgfs1xg.png"><br><br>  As chaves são organizadas em uma árvore e são chamadas de nós (znodes).  Assim, para o site você pode obter uma lista de seus filhos.  As operações de criação do znode (create) e alteração do valor (setData) são separadas: somente as chaves existentes podem ler e alterar valores.  Os relógios podem ser anexados às operações de verificar a existência de um nó, ler um valor e obter filhos.  O Watch é um acionador único que é acionado quando a versão dos dados correspondentes no servidor é alterada.  Nós efêmeros são usados ​​para detectar falhas.  Eles são anexados à sessão do cliente que os criou.  Quando um cliente fecha uma sessão ou para de notificar o ZooKeeper sobre sua existência, esses nós são excluídos automaticamente.  Transações simples são suportadas - um conjunto de operações com êxito ou com falha, se pelo menos uma delas for impossível. <br><br>  <b>etcd</b> <br><br><img src="https://habrastorage.org/webt/at/hg/me/athgmezjwbafkvetueuq7ytewdc.png"><br><br>  Os desenvolvedores deste sistema foram claramente inspirados pelo ZooKeeper e, portanto, fizeram tudo de maneira diferente.  A hierarquia de chaves não está aqui, mas elas formam um conjunto lexicograficamente ordenado.  Você pode obter ou excluir todas as chaves que pertencem a um determinado intervalo.  Essa estrutura pode parecer estranha, mas na verdade é muito expressiva, e a visão hierárquica através dela é facilmente imitada. <br><br>  Não há operação padrão de comparação e configuração no etcd, mas há algo melhor - transações.  Obviamente, eles estão nos três sistemas, mas nas transações etcd são especialmente boas.  Eles consistem em três blocos: verificação, sucesso, falha.  O primeiro bloco contém um conjunto de condições, a segunda e a terceira - operações.  Uma transação é realizada atomicamente.  Se todas as condições forem verdadeiras, o bloco de sucesso será executado, caso contrário - falha.  Na API versão 3.3, os blocos de sucesso e falha podem conter transações aninhadas.  Ou seja, é possível executar atomicamente construções condicionais de um nível quase arbitrário de aninhamento.  Você pode aprender mais sobre quais verificações e operações existem na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> . <br><br>  Os relógios também existem aqui, embora sejam um pouco mais complexos e reutilizáveis.  Ou seja, depois de instalar o relógio em um intervalo de teclas, você receberá todas as atualizações nesse intervalo até cancelar o relógio, e não apenas o primeiro.  No etcd, as concessões são equivalentes às sessões do cliente ZooKeeper. <br><br>  <b>Consul KV</b> <br><br>  Também não existe uma estrutura hierárquica rigorosa, mas o Consul pode criar a aparência que existe: você pode receber e excluir todas as chaves com o prefixo especificado, ou seja, trabalhar com a "subárvore" da chave.  Tais consultas são chamadas recursivas.  Além disso, o Consul pode selecionar apenas chaves que não contenham o caractere especificado após o prefixo, o que corresponde ao recebimento de “filhos” imediatos.  Mas vale lembrar que essa é precisamente a aparência de uma estrutura hierárquica: é bem possível criar uma chave se seu pai não existir ou excluir uma chave que tenha filhos, enquanto os filhos continuarão sendo armazenados no sistema. <br><br><img src="https://habrastorage.org/webt/qq/mb/8t/qqmb8tupgbnod_6jm6andrhelrs.png"><br>  Em vez de relógios, existem solicitações HTTP de bloqueio no Consul.  Em essência, são chamadas comuns ao método de leitura de dados, para as quais, juntamente com outros parâmetros, é indicada a última versão conhecida dos dados.  Se a versão atual dos dados correspondentes no servidor for maior que a especificada, a resposta será retornada imediatamente, caso contrário, quando o valor for alterado.  Também há sessões aqui que podem ser anexadas às chaves a qualquer momento.  Vale ressaltar que, diferentemente do etcd e do ZooKeeper, onde a exclusão de sessões leva à remoção de chaves relacionadas, existe um modo em que a sessão é simplesmente desanexada delas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As transações</a> estão disponíveis, sem ramificação, mas com todos os tipos de cheques. <br><br><h3>  Junte tudo </h3><br>  O modelo de dados mais rigoroso tem o ZooKeeper.  Solicitações de intervalo expressivas disponíveis no etcd não podem ser emuladas de maneira eficiente no ZooKeeper ou no Consul.  Tentando tirar o melhor de todos os serviços, obtivemos uma interface quase equivalente à interface do ZooKeeper, com as seguintes exceções significativas: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sequência, contêiner e nós TTL</a> não <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">são</a> suportados </li><li>  ACLs não são suportadas </li><li>  O método set cria uma chave se não existir (no ZK setData retorna um erro neste caso) </li><li>  Os métodos set e cas são separados (em ZK, eles são essencialmente a mesma coisa) </li><li>  O método apagar apaga o vértice junto com a subárvore (em ZK delete retorna um erro se o vértice tiver filhos) </li><li>  para cada chave, existe apenas uma versão - a versão do valor (em ZK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">existem três</a> ) </li></ul><br>  A rejeição de nós seqüenciais se deve ao fato de que no etcd e Consul não há suporte interno para eles e, além da interface da biblioteca resultante, eles podem ser facilmente implementados pelo usuário. <br><br>  A implementação do mesmo comportamento ao remover o ZooKeeper superior exigiria a manutenção de um contador filho separado no etcd e no Consul para cada chave.  Como tentamos evitar o armazenamento de meta-informações, foi decidido excluir a subárvore inteira. <br><br><h3>  Sutilezas de implementação </h3><br>  Vamos considerar com mais detalhes alguns aspectos da implementação da interface da biblioteca em diferentes sistemas. <br><br>  <b>Hierarquia no etcd</b> <br><br>  Manter uma visão hierárquica no etcd foi uma das tarefas mais interessantes.  As solicitações de intervalo facilitam a obtenção de uma lista de chaves com um prefixo especificado.  Por exemplo, se você deseja tudo o que começa com <code>"/foo"</code> , solicita o intervalo <code>["/foo", "/fop")</code> .  Mas isso retornaria toda a subárvore inteira da chave, o que pode não ser aceitável se a subárvore for grande.  Inicialmente, planejamos usar o mecanismo de conversão de chaves <a href="">implementado no zetcd</a> .  Envolve adicionar um byte no início da chave, igual à profundidade do nó na árvore.  Eu darei um exemplo <br><br><pre> <code class="plaintext hljs">"/foo" -&gt; "\u01/foo" "/foo/bar" -&gt; "\u02/foo/bar"</code> </pre> <br>  Então você pode obter todos os filhos imediatos da chave <code>"/foo"</code> solicitando o intervalo <code>["\u02/foo/", "\u02/foo0")</code> .  Sim, em ASCII, <code>"0"</code> segue imediatamente <code>"/"</code> . <br><br>  Mas como, então, excluir um vértice?  Acontece que você precisa excluir todos os intervalos do formulário <code>["\uXX/foo/", "\uXX/foo0")</code> para XX de 01 a FF.  E, então, chegamos a um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">limite no número de operações</a> em uma única transação. <br><br>  Como resultado, um sistema simples de conversão de chaves foi inventado, o que nos permitiu implementar efetivamente a remoção da chave e o recebimento de uma lista de filhos.  Basta adicionar um símbolo especial antes do último token.  Por exemplo: <br><br><pre> <code class="plaintext hljs">"/very" -&gt; "/\u00very" "/very/long" -&gt; "/very/\u00long" "/very/long/path" -&gt; "/very/long/\u00path"</code> </pre> <br>  A exclusão da chave <code>"/very"</code> torna-se a exclusão de <code>"/\u00very"</code> e o intervalo <code>["/very/", "/very0")</code> e <code>["/very/", "/very0")</code> todos os filhos a uma solicitação de chaves do intervalo <code>["/very/\u00", "/very/\u01")</code> . <br><br>  <b>Removendo uma chave no ZooKeeper</b> <br><br>  Como já mencionei, no ZooKeeper você não pode excluir um nó se ele tiver filhos.  Queremos excluir a chave junto com a subárvore.  Como ser  Estamos fazendo isso de maneira otimista.  Primeiro, percorremos recursivamente a subárvore, obtendo os filhos de cada vértice em uma consulta separada.  Em seguida, criamos uma transação que tenta excluir todos os nós da subárvore na ordem correta.  Obviamente, podem ocorrer alterações entre a leitura de uma subárvore e a exclusão.  Nesse caso, a transação falhará.  Além disso, a subárvore pode mudar durante o processo de leitura.  Uma consulta para os filhos do próximo nó pode retornar um erro se, por exemplo, esse vértice já tiver sido excluído.  Nos dois casos, repetimos todo o processo novamente. <br><br>  Essa abordagem torna a exclusão de uma chave muito ineficaz se ela tiver filhos, e ainda mais se o aplicativo continuar trabalhando com a subárvore, excluindo e criando chaves.  No entanto, isso nos permitiu não complicar a implementação de outros métodos no etcd e Consul. <br><br>  <b>definido no ZooKeeper</b> <br><br>  No ZooKeeper, existem métodos separados que trabalham com a estrutura em árvore (criar, excluir, getChildren) e que trabalham com dados em nós (setData, getData) Além disso, todos os métodos têm pré-condições estritas: create retornará um erro se o nó já estiver criado, excluído ou setData - se ainda não existir.  Precisávamos do método set, que pode ser chamado sem pensar na chave. <br><br>  Uma opção é aplicar uma abordagem otimista, como ao excluir.  Verifique se o nó existe.  Se existir, chame setData; caso contrário, crie.  Se o último método retornou um erro, repita novamente.  A primeira coisa a observar é a inutilidade de verificar a existência.  Você pode ligar imediatamente para criar.  A conclusão bem-sucedida significa que o nó não existia e foi criado.  Caso contrário, create retornará o erro correspondente, após o qual setData deverá ser chamado.  Obviamente, entre as chamadas, o vértice pode ser removido por uma chamada concorrente e setData também retornará um erro.  Nesse caso, você pode repetir tudo novamente, mas vale a pena? <br><br>  Se os dois métodos retornaram um erro, sabemos com certeza que houve uma exclusão concorrente.  Imagine que essa exclusão ocorreu após chamar o conjunto.  Então, não importa qual valor tentemos estabelecer, ele já será apagado.  Portanto, você pode assumir que o conjunto foi bem-sucedido, mesmo que nada tenha sido escrito. <br><br><h3>  Mais detalhes técnicos </h3><br>  Nesta seção, discordamos de sistemas distribuídos e falamos sobre codificação. <br>  Um dos principais requisitos do cliente era entre plataformas: no Linux, MacOS e Windows, pelo menos um dos serviços deve ser suportado.  Inicialmente, realizamos o desenvolvimento apenas no Linux e, em outros sistemas, começamos a testar mais tarde.  Isso causou muitos problemas, o que, por algum tempo, não ficou totalmente claro como abordar.  Como resultado, todos os três serviços de coordenação agora são suportados no Linux e MacOS e apenas o Consul KV no Windows. <br><br>  Desde o início, tentamos usar bibliotecas prontas para acessar serviços.  No caso do ZooKeeper, a escolha caiu no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ZooKeeper C ++</a> , que no final não pôde ser compilado no Windows.  Isso, no entanto, não é surpreendente: a biblioteca está posicionada como somente linux.  Para a Consul, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ppconsul</a> era a única opção.  Eu tive que adicionar suporte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sessões</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transações a ele</a> .  Para o etcd, uma biblioteca completa que suporta a versão mais recente do protocolo nunca foi encontrada; portanto, apenas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">geramos um cliente grpc</a> . <br><br>  Inspirados na interface assíncrona da biblioteca ZooKeeper C ++, decidimos implementar a interface assíncrona também.  No ZooKeeper C ++, primitivas futuras / promessas são usadas para isso.  No STL, infelizmente, eles são implementados de maneira muito modesta.  Por exemplo, não existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">método</a> que aplique a função passada ao resultado futuro quando ela estiver disponível.  No nosso caso, esse método é necessário para converter o resultado no formato da nossa biblioteca.  Para contornar esse problema, tivemos que implementar nosso pool de encadeamentos simples, porque, a pedido do cliente, não podíamos usar bibliotecas pesadas de terceiros, como o Boost. <br><br>  Nossa implementação então funciona da seguinte maneira.  Quando chamado, um par adicional de promessa / futuro é criado.  O novo futuro é retornado e o transferido é colocado junto com a função correspondente e uma promessa adicional na fila.  Um encadeamento do pool seleciona vários futuros da fila e os pesquisa usando wait_for.  Quando o resultado fica disponível, a função correspondente é chamada e seu valor de retorno é passado para a promessa. <br><br>  Usamos o mesmo pool de threads para executar solicitações ao etcd e Consul.  Isso significa que vários segmentos diferentes podem trabalhar com as bibliotecas subjacentes.  O ppconsul não é seguro para threads, portanto, as chamadas para ele são protegidas por bloqueios. <br>  Você pode trabalhar com o grpc a partir de vários threads, mas existem sutilezas.  Os relógios Etcd são implementados por meio de fluxos grpc.  Estes são canais bidirecionais para certos tipos de mensagens.  A biblioteca cria um único fluxo para todos os relógios e um único fluxo que processa as mensagens recebidas.  Então o grpc proíbe gravações paralelas para transmitir.  Isso significa que, ao inicializar ou excluir o relógio, é necessário aguardar até que o envio da solicitação anterior seja concluído antes de enviar a próxima.  Usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">variáveis ​​condicionais</a> para sincronização. <br><br><h3>  Sumário </h3><br>  Veja você mesmo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">liboffkv</a> . <br><br>  Nossa equipe: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Raed Romanov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ivan Glushenkov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dmitry Kamaldinov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Victor Krapivensky</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vitaly Ivanin</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458832/">https://habr.com/ru/post/pt458832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458818/index.html">Contemporâneos proeminentes</a></li>
<li><a href="../pt458820/index.html">Sobre a implementação do famoso gênero na plataforma Minecraft</a></li>
<li><a href="../pt458826/index.html">Como eliminar artigos antigos para que eles cresçam muito no orgânico: + 104% do tráfego por seis meses</a></li>
<li><a href="../pt458828/index.html">Por que, por que e quando usar o ValueTask</a></li>
<li><a href="../pt458830/index.html">Webinars da Dell Technologies: todos os detalhes do nosso tutorial</a></li>
<li><a href="../pt458834/index.html">Lado da personalidade de Paul Allen, sobre o qual poucas pessoas sabiam como eu gostaria</a></li>
<li><a href="../pt458836/index.html">Índice Borsch. Uma abordagem sistemática para avaliar, comparar, determinar a relação preço / qualidade</a></li>
<li><a href="../pt458840/index.html">Como perfuramos o grande firewall chinês (parte 2)</a></li>
<li><a href="../pt458842/index.html">Paciência e trabalho extrairão o texto inteiro</a></li>
<li><a href="../pt458844/index.html">Destruição de silo através da abordagem de adaptação VeriSM ™</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>