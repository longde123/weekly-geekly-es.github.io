<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ß üë©‚Äçüé§ üòΩ Wenn E-Mails zugestellt werden: Bek√§mpfung des Verlusts von Push-Benachrichtigungen in iOS üßòüèø üìò üï∫üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der E-Mail-Client ist f√ºr den Benutzer eine einfache Anwendung. Yandex.Mail-Entwickler scherzen sogar, dass die Anwendung nur drei Bildschirme enth√§lt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenn E-Mails zugestellt werden: Bek√§mpfung des Verlusts von Push-Benachrichtigungen in iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462507/">  Der E-Mail-Client ist f√ºr den Benutzer eine einfache Anwendung.  Yandex.Mail-Entwickler scherzen sogar, dass die Anwendung nur drei Bildschirme enth√§lt: eine Liste von Buchstaben;  einen Brief senden;  √ºber Bildschirm. <br><br>  Aber viele interessante Dinge passieren unter der Haube.  Wie viele mobile Apps verwendet Mail Push-Benachrichtigungen, um mit Benutzern zu interagieren.  Wie bei vielen iOS-Anwendungen verliert Mail aufgrund der Art des Apple Push Notification Service einige Benachrichtigungen. <br><br>  <strong>Asya Sviridenko</strong> , Leiterin der Yandex.Mail iOS-Gruppe, wird beweisen, dass es trotz der Einschr√§nkungen des Systems m√∂glich und notwendig ist, mit dem Verlust von Push-Benachrichtigungen umzugehen, wenn diese f√ºr Ihre Anwendung kritisch sind.  Dies gilt f√ºr Mail, da der Benutzer die Anwendung √ºber Push-Benachrichtigungen √ºber neue Briefe installiert.  Wenn f√ºr Ihre Anwendung die Zustellung von Push-Benachrichtigungen nicht so wichtig ist, ist es immer noch interessant herauszufinden, welche Fahrr√§der das Handy Yandex.Mail angeh√§uft hat. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SVCMbPIuy8w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Es geht um Remote-Benachrichtigungen, dh Benachrichtigungen, die vom Server √ºber APNs (Apple Push Notification Service) eingehen.  Wir werden nicht auf lokale Benachrichtigungen eingehen und √ºber Folgendes sprechen: <br><br><ul><li>  Wie sieht die API f√ºr die Arbeit mit Push-Benachrichtigungen aus?  Betrachten Sie ein Push-Benachrichtigungs-Zustellungsschema und wo Verluste in diesem Schema auftreten k√∂nnen. </li><li>  Wie haben Sie sich entschieden, mit Verlusten in Yandex.Mail umzugehen - der Warteschlange f√ºr Push-Benachrichtigungen? </li><li>  Wie man sich anmeldet und welche anderen Schwierigkeiten auftreten k√∂nnen. </li></ul><a name="habracut"></a><br><h2>  Was wir haben und wo wir verlieren </h2><br>  Jetzt ist die API f√ºr die Arbeit mit Push-Benachrichtigungen leistungsf√§hig genug, um viele interessante Dinge zu tun.  Das war aber nicht immer der Fall. <br><br><img src="https://habrastorage.org/webt/p6/ln/n1/p6lnn1nbbopnz4xr9k2xiuf1dre.jpeg"><br><br>  Bisher sahen Push-Benachrichtigungen genau so aus - es war ein ungl√ºckliches blaues Dashboard, das auf dem Bildschirm auftauchte, die Arbeit mit der aktuellen Anwendung blockierte, nichts zulie√ü und dann f√ºr immer verschwand, und es gab keine weiteren Erinnerungen daran. <br><br>  Seitdem ist genug Zeit vergangen. <br><br><img src="https://habrastorage.org/webt/nq/kr/9j/nqkr9jbh2v4nwacrbhksoa1tpy0.jpeg"><br><br>  F√ºr uns als Entwickler begann <strong>alles in iOS 3,</strong> als Push-Benachrichtigungen f√ºr Bibliotheken von Drittanbietern verf√ºgbar wurden. <br><br>  <strong>Das Benachrichtigungscenter wurde in iOS 5</strong> angezeigt, und Push-Benachrichtigungen wurden nicht mehr ausgef√ºhrt. Jetzt verbleiben sie im Benachrichtigungscenter, wo sie erneut angezeigt werden k√∂nnen. <br><br>  <strong>IOS 6 f√ºhrte Do Not Disturb ein</strong> .  Der Benutzer hat die M√∂glichkeit, den Zeitraum festzulegen, in dem er keine Benachrichtigungen erhalten m√∂chte. <br><br>  Diese √Ñnderungen betrafen haupts√§chlich, wie der Benutzer mit Push-Benachrichtigungen arbeiten kann, wie sie sein Leben komfortabler gestalten k√∂nnen und nicht, wie Entwickler Benachrichtigungen beeinflussen k√∂nnen. <br><br>  F√ºr Entwickler war <strong>iOS 8 und das Aufkommen der Benachrichtigungsaktion</strong> ein wichtiger Meilenstein, mit dem Aktionen, die f√ºr eine bestimmte Anwendung spezifisch sind, durch Push-Benachrichtigungen ausgef√ºhrt werden konnten. <br><br>  <strong>IOS 10 f√ºhrt die Notification Service Extension und die Notification Content Extension ein</strong> .  Mit der ersten Option k√∂nnen Sie die Push-Benachrichtigung √§ndern, bevor sie dem Benutzer angezeigt wird.  Die zweite M√∂glichkeit besteht darin, eine Benutzeroberfl√§che per Push-Benachrichtigung unter Push-Benachrichtigung anzuzeigen, in der Sie beispielsweise detailliertere Informationen anzeigen k√∂nnen.  In iOS 10 war diese Benutzeroberfl√§che nicht anklickbar. Sie k√∂nnen sie ansehen und nicht ber√ºhren. <br><br>  <strong>IOS 11 f√ºhrte die Datenschutzeinstellungen f√ºr Benachrichtigungen ein</strong> .  Jetzt kann der Benutzer in die Einstellungen gehen und angeben, ob der Inhalt der eingehenden Benachrichtigungen angezeigt werden soll.  Dies ist ein gro√üer Schritt in Richtung Sicherheit.  Es waren nur 8 Versionen von iOS erforderlich, um zu verstehen, dass nicht alle Benutzer m√∂chten, dass pers√∂nliche Informationen pl√∂tzlich auf dem auf dem Tisch liegenden iPhone angezeigt werden. <br><br>  <strong>In iOS 12 wurde es m√∂glich, Push-Benachrichtigungen</strong> nach Thread-ID <strong>zu gruppieren</strong> , und die Benutzeroberfl√§che, die wir in iOS 10 mithilfe der Benachrichtigungsinhaltserweiterung erhalten haben, ist anklickbar.  Jetzt k√∂nnen Sie dort Schaltfl√§chen und Gestensteuerelemente hinzuf√ºgen - alles, was dem Benutzer bei der Interaktion mit der Benutzeroberfl√§che hilft. <br><br><h2>  Push-Benachrichtigungen heute </h2><br>  Wie Sie sehen k√∂nnen, haben Push-Benachrichtigungen einen langen Weg zur√ºckgelegt, und heute k√∂nnen Sie mit ihrer Hilfe wirklich viele Dinge tun. <br><br><h3>  SMS und Lokalisierung </h3><br>  Nach wie vor k√∂nnen wir Textnachrichten in einer Push-Benachrichtigung senden. Jetzt k√∂nnen Sie zus√§tzlich Schl√ºssel f√ºr die Lokalisierung angeben. <br><br><pre><code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"New Mail"</span></span>, <span class="hljs-string"><span class="hljs-string">"subtitle-loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_subtitle_localization_key"</span></span>, <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_body_localization_key"</span></span>, } }</code> </pre> <br>  Wenn Sie in der Nutzlastbenachrichtigung <code>subtitle-loc-key</code> und <code>loc-key</code> angeben, werden die erforderlichen Werte beim Eintreffen der Push-Benachrichtigung auf dem Ger√§t in der Datei Localizable.string der Anwendung gefunden, und dem Benutzer wird eine lokalisierte Nachricht angezeigt. <br><br><h3>  Ton und kritischer Alarm </h3><br>  Nach wie vor k√∂nnen Sie Nutzlastbenachrichtigungen Sounds hinzuf√ºgen. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"sound"</span></span> : { <span class="hljs-string"><span class="hljs-string">"critical"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"bingbong.aiff"</span></span>, <span class="hljs-string"><span class="hljs-string">"volume"</span></span> : <span class="hljs-number"><span class="hljs-number">1.0</span></span>, } }</code> </pre> <br>  IOS 12 hat eine kritische Warnung.  Dies sind Sounds, die auch dann abgespielt werden, wenn sich der Benutzer im Modus ‚ÄûNicht st√∂ren‚Äú befindet. <br><br>  In der Regel ben√∂tigt der Benutzer beispielsweise nachts keine Anwendung mit einem Zeitschriftenabonnement, um zu melden, dass eine neue Nummer ver√∂ffentlicht wurde.  Daher beschr√§nkt Apple Anwendungen, die kritische Warnungen verwenden k√∂nnen.  Wenn Ihre Anwendung mit Gesundheit, Sicherheit funktioniert oder Sie der Meinung sind, dass eine kritische Warnung den Benutzern bei der Interaktion mit Ihrer Anwendung wirklich helfen kann, schreiben Sie an Apple.  Vielleicht k√∂nnen Sie diese Funktionalit√§t nutzen. <br><br><h3>  Stille Benachrichtigungen </h3><br>  Der Benutzer sieht keine stillen Benachrichtigungen.  Sie kommen direkt zur Anwendung, aktivieren sie und erm√∂glichen es Ihnen, einige Aktionen auszuf√ºhren, um die Anwendung auf den neuesten Stand zu bringen: Senden Sie eine Anforderung an den Server, fordern Sie Daten im Hintergrund an, aktualisieren Sie Daten aus der Datenbank, aktualisieren Sie die Benutzeroberfl√§che, damit der Benutzer sie sieht, wenn er die Anwendung betritt aktualisierte Daten. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"content-available"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">//   alert, sound  badge   payload }</span></span></code> </pre> <br>  Damit die Push-Benachrichtigung stumm geschaltet wird, m√ºssen Sie in der Nutzlast Folgendes angeben: <code>"content-available" : 1</code> .  Geben Sie keine Warn-, Ton- und Ausweisschl√ºssel in der Nutzlast an - sie sind f√ºr Push-Benachrichtigungen, die dem Benutzer nicht angezeigt werden, v√∂llig unbrauchbar. <br><br><h3>  Benachrichtigungsgruppierung </h3><br>  Um Nachrichten zu gruppieren, m√ºssen Sie "Thread-ID" in der Nutzlast angeben.  Es kann mehrere Werte in derselben Anwendung haben, wenn Sie auf unterschiedliche Weise gruppieren m√∂chten: nach Konten, nach Empf√§ngern, nach Themen. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"thread-id"</span></span> : <span class="hljs-string"><span class="hljs-string">"any_thread_identifier"</span></span> }</code> </pre> <br>  Dies ist sehr praktisch, da Push-Benachrichtigungen jetzt nicht den gesamten Speicherplatz auf dem gesperrten Bildschirm einnehmen, sondern in Gruppen zusammengefasst sind.  Wenn Sie diese Funktion noch nicht verwenden, k√∂nnen Sie beginnen. <br><br><h3>  √Ñndern Sie die Benachrichtigung, bevor Sie sie anzeigen </h3><br>  Push-Benachrichtigungen k√∂nnen ge√§ndert werden, bevor sie angezeigt werden.  Dazu m√ºssen Sie der Anwendung die Benachrichtigungsinhaltserweiterung hinzuf√ºgen und die <code>didReceive</code> Methode √ºberschreiben.  Bei dieser Methode k√∂nnen Sie den Benachrichtigungsinhalt abrufen und √§ndern. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"mutable-content"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutableContent = request.content.mutableCopy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UNMutableNotificationContent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } mutableContent.subtitle = <span class="hljs-string"><span class="hljs-string">"Got it!"</span></span> contentHandler(mutableContent) }</code> </pre> <br>  Sie k√∂nnen beispielsweise einen Link zu Medieninhalten in der Benachrichtigung senden, den Inhalt in der Erweiterung herunterladen und den heruntergeladenen an die Benachrichtigung anh√§ngen.  Rufen Sie danach die Fertigstellung mit einem neuen Kontext auf und zeigen Sie dem Benutzer eine erweiterte Push-Benachrichtigung.  Sie k√∂nnen den Titel, den Untertitel usw. √§ndern. <br><br>  Ein weiterer interessanter Fall ist, dass Sie eine Push-Benachrichtigung mit einem verschl√ºsselten Kontext senden k√∂nnen, wenn die Daten zus√§tzlich gesch√ºtzt werden sollen und Apple sie nicht gesehen hat.  In der Benachrichtigungsinhaltserweiterung k√∂nnen Sie sie entschl√ºsseln und dem Benutzer bereits entschl√ºsselte Daten anzeigen. <br><br><h3>  Versteckter Benachrichtigungsinhalt </h3><br>  In iOS 11 wurde es m√∂glich, den Inhalt von Push-Benachrichtigungen auszublenden, und wir als Entwickler k√∂nnen dies in keiner Weise beeinflussen.  Wenn der Benutzer den "Benachrichtigungsinhalt ausblenden" angekreuzt hat, wird er auf die eine oder andere Weise ausgeblendet.  Alles, was wir tun k√∂nnen, ist √ºber die UNNotificationCategory, einen Platzhalter anzugeben, der anstelle des Inhalts angezeigt wird (standardm√§√üig ist es eine Benachrichtigung), und festzulegen, ob Titel oder Untertitel angezeigt werden sollen. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commentCategory = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"comment-category"</span></span>, actions: [], intentIdentifiers: [], hiddenPreviewsBodyPlaceholder: <span class="hljs-type"><span class="hljs-type">NSString</span></span>.localizedUserNotificationString(forKey:<span class="hljs-string"><span class="hljs-string">"COMMENT_KEY"</span></span>,arguments: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), options: [.hiddenPreviewsShowTitle])</code> </pre> <br><h3>  Benachrichtigungsschritte ohne Starten der Anwendung </h3><br>  Um Push-Benachrichtigungsaktionen auszuf√ºhren, ohne die Anwendung selbst zu starten, m√ºssen Sie eine Kategorie erstellen und eine Aktion hinzuf√ºgen.  Die Kategoriekennung wird an das Kategoriefeld der Nutzlastbenachrichtigung √ºbergeben.  Sie k√∂nnen verschiedene Aktionen mit verschiedenen Arten von Benachrichtigungen verbinden. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"category"</span></span> : <span class="hljs-string"><span class="hljs-string">"message"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> action = <span class="hljs-type"><span class="hljs-type">UNNotificationAction</span></span>(identifier:<span class="hljs-string"><span class="hljs-string">"reply"</span></span>, title:<span class="hljs-string"><span class="hljs-string">"Reply"</span></span>, options:[]) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> category = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"message"</span></span>, actions: [action], minimalActions: [action], intentIdentifiers: [], options: []) <span class="hljs-type"><span class="hljs-type">UNUserNotificationCenter</span></span>.current().setNotificationCategories([category])</code> </pre> <br><h3>  Reichhaltige Benachrichtigungen </h3><br>  In dieser Erweiterung k√∂nnen Sie zus√§tzliche Aktionen verarbeiten, die Sie der Push-Benachrichtigung hinzugef√ºgt haben, und die benutzerdefinierte Benutzeroberfl√§che anzeigen. <br><br>  Dazu m√ºssen Sie der Anwendung die Benachrichtigungsinhaltserweiterung hinzuf√ºgen, eine Klasse definieren, die von UNNotificationContentExtension erbt, und dann wie mit einem normalen UIViewController damit arbeiten. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UNNotificationContentExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userLabel: <span class="hljs-type"><span class="hljs-type">UILabel?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> notification: UNNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content = notification.request.content <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = content.title <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userInfo = content.userInfo <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.userLabel?.text = userInfo[<span class="hljs-string"><span class="hljs-string">"video-user"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">String</span></span> } }</code> </pre> <br>  Wenn Sie benutzerdefinierte Aktionen verarbeiten, ist es wichtig zu beachten, dass diese Aktionen es wert sind, die Benutzeroberfl√§che zu aktualisieren, die Sie dem Benutzer anzeigen.  Sie m√ºssen nicht versuchen, Gesch√§ftslogik in dieser Erweiterung zu implementieren.  Senden Sie eine Anforderung per Aktion mit einer Push-Benachrichtigung in der Hauptanwendung an den Server, und nicht hier.  Dieser Ort ist nur f√ºr die Benutzeroberfl√§che. <br><br><h2>  Push-Benachrichtigungs-Zustellungsschema </h2><br>  Sehen Sie, wie viel Sie mit Push-Benachrichtigungen in iOS tun k√∂nnen.  Von Version zu Version haben wir immer mehr neue Funktionen, aber das Push-Benachrichtigungs-Zustellungsschema ist jetzt genau das gleiche wie in iOS 3. <br><br><img src="https://habrastorage.org/webt/gt/pb/dd/gtpbdd_4eu403euuueyxscvk8bw.jpeg"><br><br>  Man w√ºrde denken, dass das Push-Benachrichtigungs-Zustellungsschema von Anfang an in Ordnung war, aber es ist nicht so. <br><br>  Das Push-Benachrichtigungs-Zustellungsschema enth√§lt drei Hauptknoten: <br><br><ul><li>  Anbieter, der Push-Benachrichtigungen f√ºr Nutzdaten generiert; </li><li>  APNs - Apple Push Notification Service, der eine Benachrichtigung liefert; </li><li>  iOS-Ger√§t und Ihre Anwendung. </li></ul><br>  Ich werde den Teil √ºberspringen, wie man sich registriert, einen Token erh√§lt und wohin man ihn sendet.  Angenommen, wir haben das alles.  Was passiert als n√§chstes? <br><br><ul><li>  Der Anbieter generiert eine Nutzlast und sendet sie an APNs. </li><li>  APNs senden es an das Ger√§t. </li><li>  Der Benutzer sieht eine Push-Nachricht auf seinem Ger√§t. </li></ul><br>  Mail und viele andere Anwendungen verwenden ein erweitertes Push-Benachrichtigungs-Zustellungsschema.  Die Benachrichtigungsdiensterweiterung wurde hinzugef√ºgt, die Push-Benachrichtigungen mit <code>"mutable-content" : 1</code> empf√§ngt <code>"mutable-content" : 1</code> .  Der Anbieter ist in einen Server unterteilt, der sich mit der Backend-Logik der Anwendung befasst, und der Anbieter selbst, der Nutzdaten generiert und Abonnements verarbeitet. <br><br>  In Yandex hei√üt der Anbieter, der Nutzdaten bildet, XIVA.  XIVA ist eine Abonnementdatenbank.  Mail verwendet XIVA, um mit Push-Benachrichtigungen als Bibliothek eines Drittanbieters zu arbeiten. <br><br>  In Mail ist die Arbeit mit Abonnements nicht trivial organisiert.  Wir unterschreiben nicht nur den Antrag f√ºr Benachrichtigungen, wir haben mehrere Konten.  Wir k√∂nnen verschiedene Konten signieren oder innerhalb eines Kontos ausw√§hlen, f√ºr welche Ordner der Benutzer Benachrichtigungen erhalten m√∂chte und f√ºr welche nicht.  XIVA befasst sich mit all dem.  Einige andere Yandex-Dienste funktionieren auch √ºber XIVA: Alle Informationen zu Anwendungen, Benachrichtigungen, Abonnements und Token werden in XIVA gespeichert. <br><br><h3>  Wo sind die Verluste? </h3><br>  Das Push-Benachrichtigungs-Zustellungsschema enth√§lt vier Pfeile. Bei drei dieser √úberg√§nge k√∂nnen Verluste auftreten. <br><br>  <strong>Zwischen dem Server und XIVA</strong> k√∂nnen im folgenden Fall Verluste auftreten.  Der Benutzer hat einen Brief erhalten, der Server wei√ü davon, generiert eine Benachrichtigung und sendet sie an XIVA.  XIVA kann diese Informationen jedoch verlieren, wenn ein Benutzer in der Anwendung einen bestimmten Ordner abonniert hat, w√§hrend er offline war.  Dann erh√§lt XIVA keine Informationen √ºber das Abonnement des Ordners. Wenn die Nutzdaten eintreffen, wird es einfach gel√∂scht und der Benutzer sieht die Benachrichtigung nicht. <br><br>  <strong>Zwischen XIVA und APNs</strong> kann ein Netzwerkverlust auftreten.  Wir k√∂nnen das Netzwerk kaum beeinflussen, daher werden wir uns nicht mit diesem Punkt befassen. <br><br>  <strong>Zwischen APNs und Erweiterung oder zwischen APNS und iOS,</strong> wenn Sie keine Erweiterung verwenden.  Dies ist die h√§ufigste Art von Verlust.  Solche Verluste treten auf, weil APNs nicht mehr als einen Push pro Anwendung auf dem Ger√§t speichern.  Wenn der Benutzer, w√§hrend er offline ist, mehrere Benachrichtigungen erh√§lt, wird beim Online-Gehen nur die letzte Nachricht angezeigt. <br><br>  Dies sind die gleichen Verluste, die es uns nicht erm√∂glichen, die Lieferung zu garantieren und uns auf Push-Benachrichtigungen zu verlassen.  Apple schreibt eindeutig, dass die Lieferung nicht garantiert ist. <br><br>  <strong>Zwischen der Erweiterungsanwendung und iOS k√∂nnen</strong> <strong><em>keine</em></strong> <strong>Verluste</strong> <strong><em>auftreten</em></strong> <strong>, und Apple garantiert dies.</strong>  Wenn Sie die Erweiterung verwenden und die Methode didReceiveContent mit Abschluss √ºberschreiben, wird die Benachrichtigung trotzdem angezeigt, auch wenn Sie diesen Abschluss nicht aufrufen.  Dies ist wichtig zu beachten.  Sie k√∂nnen es nicht anrufen oder haben keine Zeit, es anzurufen, aber dann wird die Benachrichtigung ohne √Ñnderungen in der Form angezeigt, in der sie von APNs stammt. <br><br>  Wir werden untersuchen, wie wir mit Verlusten zwischen APNs und Extension umgehen.  Wenn Sie jedoch die Zustellbarkeit von Push-Benachrichtigungen verbessern m√ºssen, sehen Sie sich das gesamte Schema an.  √úberpr√ºfen Sie, ob auf der Serviceseite Verluste auftreten, ob Ihr Anbieter normal mit APNs interagiert und so weiter.  √úberpr√ºfen und messen Sie die gesamte Kette und ziehen Sie dann Schlussfolgerungen, wo die Verluste am meisten auftreten und welcher Teil dieser Schaltung ge√§ndert werden sollte. <br><br><h2>  Push-Benachrichtigungswarteschlange </h2><br>  Um mit Verlusten im B√ºndel von APNs und Erweiterungen umzugehen, haben wir die Push-Benachrichtigungswarteschlange aufgerufen. <br><br>  Wenn Sie die ganze Geschichte auf einen Satz komprimieren, ist dies: <br><blockquote>  Wenn Sie die Push-Benachrichtigung verpasst haben, k√∂nnen Sie sie erneut anfordern. </blockquote><br><img src="https://habrastorage.org/webt/mi/dl/c8/midlc81bedgy18xv4gzgmkyb7zo.jpeg"><br><br>  In unserem Benachrichtigungsschema sind alle Teilnehmer: XIVA, APNs, Erweiterung.  Das vereinfachte Schema funktioniert folgenderma√üen: <br><br><ul><li>  XIVA nummeriert die Push-Benachrichtigungen, die an APNs gesendet werden sollen, und sendet erst dann Informationen. </li><li>  Die Nebenstelle erh√§lt eine Push-Benachrichtigung Nummer 1 und nach einiger Zeit die Nummer 3. Sie versteht, dass einige Daten fehlen. </li><li>  Sendet eine Anfrage an XIVA mit der zuletzt empfangenen Position, diff und fordert Sie auf, die fehlenden Daten erneut zu senden. </li><li>  XIVA sendet die Push-Benachrichtigung erneut, da die Nutzdatenbank und die Abonnementdatenbank gespeichert werden.  Alle Abonnements werden f√ºr einige Zeit gespeichert und k√∂nnen erneut angefordert werden. </li><li>  Wir fragen erneut, wir erhalten eine Push-Benachrichtigung und wir haben alle Nachrichten auf dem Client, die der Client h√§tte erhalten sollen. </li></ul><br>  Das erste erwartete Problem sind doppelte Benachrichtigungen.  Wenn wir eine Nachricht von XIVA erneut anfordern, wissen wir nicht, was sich in der Warteschlange zum Senden befindet, da wir nicht direkt, sondern √ºber APNs mit ihr kommunizieren.  Angenommen, wir haben festgestellt, dass einige Benachrichtigungen fehlten, und eine Anfrage an XIVA gesendet.  XIVA wird √ºber Payload-APNs mit einer vers√§umten Benachrichtigung gesendet.  Aber bevor wir es erhielten, erhielten wir eine weitere Nutzlast und auch mit einem Pass.  Sie fragten erneut - XIVA schickte erneut. <br><br>  Damit Benachrichtigungen nicht dupliziert werden, verwenden wir <strong>apns -apse-id</strong> .  Mit dieser Einstellung kann die iOS-Seite Push-Benachrichtigungen mit derselben ID reduzieren.  Wenn mehrere Push-Benachrichtigungen mit derselben Apns-Collapse-ID auf dem Ger√§t eingegangen sind, werden sie von iOS reduziert und der Benutzer sieht nur eine Benachrichtigung. <br><br><h3>  XIVA </h3><br>  Ich werde Ihnen sagen, wie alles unter XIVA funktioniert, da es immer neugierig ist, was im Backend passiert. <br><br>  XIVA existierte vor der Push-Benachrichtigungswarteschlange und war eine Abonnementdatenbank.  Es ist wichtig, dass in der Datenbank alles von Benutzern gespeichert wurde: <br><br><ul><li>  Der Schl√ºssel war <code>&lt;service, user&gt;</code> . </li><li>  Die Nutzlast wurde als Wert gespeichert (Daten zu Briefen bei Mail). </li></ul><br>  XIVA hat Daten aus der Datenbank entnommen und an APNs oder einen anderen Dienst gesendet, da dies nicht nur mit iOS funktioniert.  Wir haben beschlossen, es wiederzuverwenden. <br><br>  Wir sind zum XIVA-Entwicklungsteam gekommen und haben wirklich nach einer Push-Benachrichtigungswarteschlange gefragt.  Grunds√§tzlich hatte XIVA bereits alles daf√ºr: Die Datenbank TTL f√ºr Nutzdaten, dh sie werden nicht sofort gel√∂scht, sie k√∂nnen weitergeleitet werden.  Es fehlte lediglich die M√∂glichkeit, die Push-Benachrichtigungswarteschlange als Teil der aktuellen XIVA-Implementierung zu konfigurieren - die End-to-End-Nummerierung. <br><br>  F√ºr die Pass-Through-Nummerierung sollten Push-Benachrichtigungen nach Ger√§t und Anwendungsname nummeriert werden.  Das hei√üt, eine End-to-End-Nummerierung ist f√ºr ein bestimmtes Ger√§t und f√ºr eine bestimmte Anwendung erforderlich, um sich auf der Clientseite darauf verlassen zu k√∂nnen.  Wir haben dies wie folgt gemacht: Die XIVA-Datenbank wurde wiederverwendet, aber es wurden Nutzdaten mit einem anderen Schl√ºssel darauf geschrieben.  Jetzt fungiert apns_queue als Dienst, <code>device_id + app_name</code> als Benutzer - <code>device_id + app_name</code> die Daten, die auf dem Client nummeriert werden <code>key: &lt;apns_queue, device_id + app_name&gt;</code> . <br><br>  Jetzt nimmt XIVA Daten aus der Hauptdatenbank und stellt sie in die Warteschlange, wenn sie gesendet werden m√ºssen.  Zu diesem Zeitpunkt erhalten Nutzdaten eine neue Nummerierung, da sie sich jetzt in derselben Datenbank befinden, jedoch mit einem anderen Schl√ºssel.  Bereits von dort nimmt XIVA sie heraus und sendet sie √ºber APNs.  Insgesamt erh√§lt der Client die erforderliche Nutzlastnummerierung. <br><br>  Der Client verwendet die Notification Service Extension. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// . . . }</span></span></code> </pre> <br>  Wir definieren die <code>didReceive</code> Methode <code>didReceive</code> und sehen, was vom Server kam.  Wir f√ºgen allen Push-Benachrichtigungen <code>"mutable-content" : 1</code> , damit sie in die Erweiterung fallen, da wir sie sonst bei Berechnungen nicht ber√ºcksichtigen k√∂nnen. <br><br>  Weiter im Code innerhalb der Methode gibt es kontinuierliche √úberpr√ºfungen: ob die erforderliche Nutzlast kam, ob sie sie analysieren konnten.  Wenn nicht analysiert, stammt diese Nachricht nicht von XIVA.  Wenn die Nachricht nicht von XIVA stammt, k√∂nnen wir nicht weiter damit arbeiten und rufen einfach die Fertigstellung mit der Benachrichtigung auf, die von APNs kam. Wir f√ºhren keine Berechnungen durch. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payloadParser.parsePayload(from: request.content.userInfo) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     xiva contentHandler(request.content); return }</span></span></code> </pre> <br>  Wir protokollieren, pr√ºfen, ob sich die Ger√§te-ID ge√§ndert hat, da wir wissen, dass dies unter iOS m√∂glich ist.  Ehrlich gesagt haben wir keine √Ñnderung in der Ger√§te-ID festgestellt, aber nur f√ºr den Fall, dass wir sie verarbeiten, denn wenn sie sich √§ndert, k√∂nnen wir den Zahlen von XIVA nicht vertrauen. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationReceived(with: payload) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastPositionDeviceId != deviceId { <span class="hljs-comment"><span class="hljs-comment">// deviceId ,    lastNotificationPosition = nil lastPositionDeviceId = deviceId }</span></span></code> </pre> <br>  Weiter pr√ºfen wir, ob wir die XIVA-Daten in dieser Nutzlast empfangen k√∂nnen, ob sie es sind oder nicht.  Wenn nicht, rufen Sie contentHandler erneut auf. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xivaInfo = payload.xivaInfo <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  Wenn Daten vorhanden sind, √ºberpr√ºfen Sie, ob die Ger√§te-ID Daten empfangen hat.  XIVA sendet einen Hash des Ger√§ts an die Nutzdaten. Wenn dieser √ºberpr√ºft wird und √ºbereinstimmt, fahren wir fort. Nein, wir rufen contentHandler auf. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> isHashCompatible(deviceId: deviceId, deviceIdHash: xivaInfo.deviceIdHash) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// payload device_id   device_id  contentHandler(request.content); return }</span></span></code> </pre> <br>  Im n√§chsten Block wird gepr√ºft, ob eine Position gespeichert ist: <br><br><ul><li>  Wenn wir nicht √ºber die zuletzt gespeicherte Position verf√ºgen, haben wir entweder noch keine Benachrichtigungen erhalten und die Erweiterung nicht eingegeben oder sind aus irgendeinem Grund abgebrochen.  Dann gibt es nichts mehr zu verschieben, um das verpasste Diff zu finden, und wir rufen erneut die Fertigstellung auf. </li><li>  Wenn ja, fahren Sie fort. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastPos = lastNotificationPosition <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      lastNotificationPosition = xivaInfo.notificationPosition contentHandler(request.content); return }</span></span></code> </pre> <br>  Wir z√§hlen die Anzahl der vers√§umten Benachrichtigungen.  Wenn das Fehlen einer Null in Ordnung ist, haben wir nichts verpasst. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> missedMessages = xivaInfo.notificationPosition - lastPos - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   push‚Äì     contentHandler(request.content); return }</span></span></code> </pre> <br>  Ansonsten nehmen wir von XIVA die Positionsdaten - aus derselben fortlaufenden Nummerierung.  Weiter pr√ºfen wir, ob die Menge der vers√§umten einen bestimmten Sollwert nicht √ºberschreitet. <br><br><pre> <code class="swift hljs">lastNotificationPosition = xivaInfo.notificationPosition <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &lt;= repeatMaxCount <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,   contentHandler(buildNewNotification()); return }</span></span></code> </pre> <br>  Warum wird das ben√∂tigt?  Angenommen, der Benutzer war lange Zeit offline und w√§hrend dieser Zeit wurden hundert Nachrichten gesammelt.  Wir werden die ganzen hundert anfordern (es ist einfach f√ºr uns), XIVA wird die ganzen hundert senden und der Benutzer wird alle Benachrichtigungen erhalten.  Selbst wenn wir sie nach Thread-ID gruppieren (und sie gruppieren), wird diese Erweiterung f√ºr jede Benachrichtigung aufgerufen, alle Pr√ºfungen werden bestanden.  Es ist unwahrscheinlich, dass der Benutzer alle hundert Benachrichtigungen ben√∂tigt.  Daher generieren wir eine Benachrichtigung, in der wir schreiben, dass Sie 100 Nachrichten verpasst haben, zur Anwendung gehen und nachsehen.  Und wir zeigen dem Benutzer genau diese Nachricht, da wir Push-Benachrichtigungen ersetzen k√∂nnen. <br><br>  Wenn alle Pr√ºfungen bestanden sind, senden wir eine Anfrage an XIVA: die letzte Position, die zu uns gekommen ist, und die Anzahl der verpassten Nachrichten.  Und schau: <br><br><ul><li>  Wenn die XIVA erfolgreich antwortet: "Alles ist in Ordnung, ich werde die Daten senden", zeigen wir dem Benutzer die aktuelle Benachrichtigung und warten, bis die XIVA alles andere sendet und der Benutzer alle Nachrichten sieht, die verpasst wurden. </li><li>  Wenn XIVA mit einem Fehler antwortet, zeigen wir dem Benutzer eine benutzerdefinierte Benachrichtigung an, dass er Nachrichten verpasst hat, die in der Anwendung angezeigt werden k√∂nnen. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestMissedNotifications(lastPosition: xivaInfo.notificationPosition, gap: missedMessages) { result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> result.onValue { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .success) contentHandler(request.content) }.onError { error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .failure(error)) contentHandler(buildNewNotification()) } }</code> </pre> <br>  Die Implementierung auf dem Client besteht daher aus einer Vielzahl von √úberpr√ºfungen, bei denen wir herausfinden, ob wir mit den empfangenen Daten arbeiten k√∂nnen. <br><br><h2>  Protokollierung und andere Schwierigkeiten </h2><br>  Wie Sie wissen, m√ºssen Sie sich anmelden, um sicherzustellen, dass der Ansatz gut funktioniert.  Wir haben begonnen, Statistiken √ºber eine neue Methode zur Zustellung von Benachrichtigungen zu sammeln und zu vergleichen, wie sich die Zustellbarkeit ge√§ndert hat. <br><br><h3>  Einschr√§nkungen der Push-Extension </h3><br>  Das erste, was uns begegnet ist, sind die Einschr√§nkungen f√ºr Push-Erweiterungen. <br><br>  <strong>Nicht immer angerufen</strong> .  Wenn Sie die Benachrichtigungszeichnung in den Anwendungseinstellungen deaktivieren (die M√∂glichkeit, eine Benachrichtigung zu erhalten, bleibt aktiviert, aber alle m√∂glichen Renderings sind deaktiviert), wird die Erweiterung nicht aufgerufen - die gesamte Logik mit Nachz√§hlungen und vor allem die Protokollierung werden nicht aufgerufen.  Wir k√∂nnen nicht herausfinden, was f√ºr uns am wichtigsten ist - ob der Benutzer eine Benachrichtigung erhalten hat. <br><br>  <strong>Die Push-Erweiterung ist zeitlich begrenzt</strong> .  In der Apple-Dokumentation hei√üt es, dass Sie innerhalb von 30 Sekunden den Abschluss mit einer ge√§nderten Benachrichtigung anrufen m√ºssen, andernfalls wird die erste Benachrichtigung angezeigt. <br><br>  Ich frage mich, wie wir es herausgefunden haben.  Wir haben eine Funktion implementiert, die wir "sch√∂ne" Push-Benachrichtigungen nannten, Medienelemente an Benachrichtigungen anh√§ngten, den Titel und den Untertitel √§nderten.  W√§hrend des Tests stellte sich heraus, dass einige Push-Benachrichtigungen sch√∂n wurden, w√§hrend der Rest als h√§ssliche Entenk√ºken zur√ºckblieb. <br><br>  Wir begannen, den Unterschied zwischen diesen Push-Benachrichtigungen zu untersuchen und stellten fest, dass es keinen Unterschied gab, nur f√ºr einige, die wir als Abschluss bezeichneten, f√ºr andere jedoch nicht. ,   , push-     ,     APNs. <br><br> <strong>  ‚Äî  </strong> . Apple ,  ,   push-extension, ,        ,     .   ,    12 . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple Developer Forum</a>   ,   ,        .     ,     ‚Äî 10 . <br><br>     ,   .      AppMetrica.   , AppMetrica     ,   Extension   .      ,  -   . <br><br>     :    Extension   . <br><br><h3>   </h3><br>    push-extension    UserDefaults. ,    ,     AppMetrica. <br><br>     .      .   ,          ,      .          ,          .         ,   XIVA (  ),  ,   . <br><br>  ,  Notification Extension   iOS 10  ,       Extension,       ,     . <br><br> <strong> </strong> <strong>AppMetrica</strong> :      , push-extension      .  AppMetrica   push-,   ,             .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppMetrica Push SDK</a> . <br><br> ,   .    ‚Äî   ,   .   ,   . <br><br><img src="https://habrastorage.org/webt/tg/k_/nk/tgk_nkvmus8kud-brgg6v9jvmhm.jpeg"><br><br>   ‚Äî   ,      ,     . <br><br>  ,     push-,   ,        ‚Äî   . <br><br>  ,  ,     .      , ‚Ä¶ <br><br><h2>  </h2><br>   :  , ,  .   ,  ?   -  ,     push-?  ,        ?    user experience   ? <br><br><blockquote>       ,       2‚Äì3‚Äì20  ? <br></blockquote><br> , ,  ,  ,  ,   ,  ,  .           ,      push-. ,     . <br><br><h2>  Zusammenfassung </h2><br> <strong>Push-  iOS   .</strong>             ,    .. ,    . <br><br> <strong> push-  ( ) .</strong>       .  XIVA. ,     ,     . ,  ,      . ! <br><br> <strong>   push-extension.</strong>     ,    . ,   . <br><br> <strong>,     .</strong> ,     , ,    ,    -  . ,   push-           . , ,      ,      App Store,     ,   ! <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,     21  22      ,        ..        50 ,     .  1   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a>      ,       ‚Äî . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462507/">https://habr.com/ru/post/de462507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462493/index.html">Multimodell-DBMS - die Basis moderner Informationssysteme?</a></li>
<li><a href="../de462495/index.html">Digitale Veranstaltungen in Moskau vom 05. bis 11. August</a></li>
<li><a href="../de462501/index.html">Warum brauche ich meine eigene Zertifizierungsstelle?</a></li>
<li><a href="../de462503/index.html">Wof√ºr sind die ‚Äûgoldenen Signale‚Äú von √úberwachung und SRE?</a></li>
<li><a href="../de462505/index.html">Mach mir nichts vor mit deiner funktionalen Programmierung</a></li>
<li><a href="../de462509/index.html">Product Fest - IT-Produktmanagementkonferenz, an der Sie teilnehmen m√∂chten</a></li>
<li><a href="../de462511/index.html">Google Play Instant. Lebenslanges Refactoring</a></li>
<li><a href="../de462513/index.html">Umzug: Vorbereitung, Auswahl, Entwicklung des Territoriums</a></li>
<li><a href="../de462515/index.html">Fehler bei der Arbeit mit der Systemtastatur</a></li>
<li><a href="../de462519/index.html">Das Buch "Microservices. Entwicklungs- und Refactoring-Muster ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>