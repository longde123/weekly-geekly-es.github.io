<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçè üõ£Ô∏è üõÄüèø Analyse der CPU-Auslastung einzelner JavaScript-Komponenten üé§ üèÑ üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns ein wenig dar√ºber sprechen, wie viel CPU-Ressourcen der JavaScript-Code der Anwendung verbraucht. Gleichzeitig schlage ich vor, unser G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse der CPU-Auslastung einzelner JavaScript-Komponenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479266/">  Lassen Sie uns ein wenig dar√ºber sprechen, wie viel CPU-Ressourcen der JavaScript-Code der Anwendung verbraucht.  Gleichzeitig schlage ich vor, unser Gespr√§ch auf Komponenten aufzubauen - die Grundbausteine ‚Äã‚Äãder Anwendung.  Mit diesem Ansatz k√∂nnen alle Bem√ºhungen zur Verbesserung der Produktivit√§t (oder zur Ermittlung der Ursachen f√ºr Programmverlangsamungen) auf (hoffentlich) kleine, autarke Teile des Projekts konzentriert werden.  Gleichzeitig gehe ich davon aus, dass Ihre Front-End-Anwendung, wie viele andere moderne Projekte, durch Zusammenf√ºgen kleiner Fragmente der Schnittstelle erstellt wurde, die f√ºr die wiederholte Verwendung geeignet sind.  Wenn dies nicht der Fall ist, k√∂nnen wir unsere √úberlegungen auf eine andere Anwendung √ºbertragen. Sie m√ºssen jedoch Ihren eigenen Weg finden, um Ihren umfangreichen Code in Fragmente zu unterteilen, und Sie m√ºssen dar√ºber nachdenken, wie Sie diese Fragmente analysieren k√∂nnen. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479266/"><img src="https://habrastorage.org/webt/cx/wv/2y/cxwv2ylp34aq6hzys-fss3azza0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Warum ist das n√∂tig?</font> </h2><br>  Warum den CPU-Verbrauch mit JavaScript messen?  Tatsache ist, dass die Anwendungsleistung heutzutage meistens an die F√§higkeiten des Prozessors gebunden ist.  Lassen Sie mich die Worte von Steve Soders und Pat Minan aus einem Interview f√ºr <a href="https://podcast.perfplanet.com/">Planet Performance Podcast</a> zitieren.  Beide gaben an, dass die Anwendungsleistung nicht mehr auf Netzwerkf√§higkeiten oder Netzwerklatenzen beschr√§nkt ist.  Netzwerke werden immer schneller.  Dar√ºber hinaus lernten die Entwickler, Server-Textantworten mit GZIP (oder besser mit brotli) zu komprimieren, und fanden heraus, wie Bilder optimiert werden k√∂nnen.  Es ist alles sehr einfach. <br><br>  Der Leistungsengpass moderner Anwendungen sind Prozessoren.  Dies gilt insbesondere f√ºr die mobile Umgebung.  Gleichzeitig sind unsere Erwartungen an die interaktiven Funktionen moderner Webanwendungen gestiegen.  Wir erwarten, dass die Schnittstellen solcher Anwendungen sehr schnell und reibungslos funktionieren.  Und das alles erfordert immer mehr JavaScript-Code.  Dar√ºber hinaus m√ºssen wir uns daran erinnern, dass 1 MB Bild nicht mit 1 MB JavaScript identisch ist.  Die Bilder werden nach und nach heruntergeladen und die Anwendung l√∂st zu diesem Zeitpunkt andere Probleme.  JavaScript-Code ist jedoch h√§ufig eine solche Ressource, ohne die sich die Anwendung als nicht funktionsf√§hig herausstellt.  Um das Funktionieren einer modernen Anwendung zu gew√§hrleisten, sind gro√üe Mengen an JS-Code erforderlich, die analysiert und ausgef√ºhrt werden m√ºssen, bevor sie wirklich funktionieren.  Und dies sind Aufgaben, die stark von den F√§higkeiten des Prozessors abh√§ngen. <br><br><h2>  <font color="#3AC1EF">Leistungsindikator</font> </h2><br>  Wir werden einen solchen Indikator f√ºr die Geschwindigkeit von Codefragmenten als die Anzahl der Prozessoranweisungen verwenden, die erforderlich sind, um sie zu verarbeiten.  Dies erm√∂glicht es uns, die Messungen von den Eigenschaften eines bestimmten Computers und von dem Zustand, in dem er sich zum Zeitpunkt der Messung befindet, zu trennen.  Zeitbasierte Metriken (wie TTI) haben zu viel "Rauschen".  Sie h√§ngen vom Status der Netzwerkverbindung sowie von allen anderen Ereignissen ab, die zum Zeitpunkt der Messung auf dem Computer auftreten.  Beispielsweise k√∂nnen einige Skripte, die w√§hrend des Ladens der untersuchten Seite ausgef√ºhrt werden, oder Viren, die mit etwas in den Hintergrundprozessen besch√§ftigt sind, die zeitlichen Leistungsindikatoren beeinflussen.  Das Gleiche gilt f√ºr Browsererweiterungen, die viel Systemressourcen verbrauchen und die Seite verlangsamen k√∂nnen.  Bei der Berechnung der Anzahl der Prozessorbefehle spielt die Zeit dagegen keine Rolle.  Solche Indikatoren k√∂nnen, wie Sie gleich sehen werden, wirklich stabil sein. <br><br><h2>  <font color="#3AC1EF">Idee</font> </h2><br>  Hier ist die Idee, die unserer Arbeit zugrunde liegt: Wir m√ºssen ein ‚ÄûLabor‚Äú schaffen, in dem der Code gestartet und √ºberpr√ºft wird, wenn √Ñnderungen daran vorgenommen werden.  Mit "Labor" meine ich einen normalen Computer, vielleicht den, den Sie st√§ndig benutzen.  Versionskontrollsysteme stellen uns Haken zur Verf√ºgung, mit denen Sie bestimmte Ereignisse abfangen und bestimmte Pr√ºfungen durchf√ºhren k√∂nnen.  Selbstverst√§ndlich k√∂nnen Messungen im ‚ÄûLabor‚Äú nach dem Festschreiben durchgef√ºhrt werden.  Aber Sie wissen wahrscheinlich, dass √Ñnderungen an Code, der die Festschreibungsphase erreicht hat, langsamer durchgef√ºhrt werden als an Code, der geschrieben wird (wenn √ºberhaupt).  Gleiches gilt f√ºr die Korrektur des Beta-Codes des Produkts und des Codes, der in die Produktion gelangt ist. <br><br>  Wir m√ºssen jedes Mal, wenn der Code ge√§ndert wird, seine Leistung vergleichen, bevor und nachdem √Ñnderungen vorgenommen werden.  Dabei sind wir bestrebt, Komponenten isoliert zu untersuchen.  Auf diese Weise k√∂nnen wir die Probleme klar erkennen und genau wissen, wo sie auftreten. <br><br>  Das Gute ist, dass solche Studien in einem echten Browser durchgef√ºhrt werden k√∂nnen, zum Beispiel mit Puppeteer.  Mit diesem Tool k√∂nnen Sie den Browser ohne Benutzeroberfl√§che √ºber Node.js steuern. <br><br><h2>  <font color="#3AC1EF">Suchcode f√ºr Recherchen</font> </h2><br>  Um den Code f√ºr die Studie zu finden, k√∂nnen wir auf jeden Styleguide oder auf jedes Design-System verweisen.  Im Allgemeinen sind wir mit allem zufrieden, was kurze, isolierte Beispiele f√ºr die Verwendung von Komponenten liefert. <br><br>  Was ist ein ‚ÄûStyleguide‚Äú?  Dies ist normalerweise eine Webanwendung, die alle Komponenten oder ‚ÄûBausteine‚Äú von Benutzeroberfl√§chenelementen demonstriert, die dem Entwickler zur Verf√ºgung stehen.  Es kann sich entweder um eine bestimmte Bibliothek mit Komponenten von Drittanbietern oder um eine von Ihnen erstellte Bibliothek handeln. <br><br>  Bei der Suche nach solchen Projekten im Internet bin ich k√ºrzlich auf einen Diskussionsthread auf Twitter gesto√üen, in dem es um relativ neue Bibliotheken von React-Komponenten ging.  Ich habe mir einige der dort erw√§hnten Bibliotheken angesehen. <br><br>  Es √ºberrascht nicht, dass moderne, qualitativ hochwertige Bibliotheken √ºber eine Dokumentation verf√ºgen, die Arbeitscodebeispiele enth√§lt.  Hier sind einige Bibliotheken und <code>Button</code> Komponenten aufgef√ºhrt, die mit ihren Mitteln implementiert wurden.  Die Dokumentation zu diesen Bibliotheken enth√§lt Beispiele f√ºr die Verwendung dieser Komponenten.  Wir sprechen √ºber die Chakra-Bibliothek und die Semantic UI React-Bibliothek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/95d/a0c/64c95da0c7b84620135e33e377c47bd2.png"></div><br>  <i><font color="#999999">Button Component Chakra Dokumentation</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d3/b45/093/7d3b45093ae1f8c6d99e174ca389a9e0.png"></div><br>  <i><font color="#999999">Button Semantic UI React Documentation</font></i> <br><br>  Genau das brauchen wir.  Dies sind Beispiele, deren Code wir auf den Verbrauch von Prozessorressourcen untersuchen k√∂nnen.  √Ñhnliche Beispiele finden Sie in der Dokumentation oder in Codekommentaren im JSDoc-Stil.  Wenn Sie Gl√ºck haben, finden Sie solche Beispiele m√∂glicherweise als separate Dateien, beispielsweise in Form von Unit-Test-Dateien.  Sicher wird es so sein.  Schlie√ülich schreiben wir alle Unit-Tests.  Richtig? <br><br><h2>  <font color="#3AC1EF">Dateien</font> </h2><br>  Stellen Sie sich zur Veranschaulichung der beschriebenen Methode der Leistungsanalyse vor, dass sich in der Bibliothek, die wir untersuchen, eine <code>Button</code> Komponente befindet, deren Code in der Datei <code>Button.js</code> enthalten ist. <code>Button-example.js</code> .  Wir m√ºssen eine Art Testseite erstellen, in deren Umgebung Testcode ausgef√ºhrt werden kann.  Sowas wie <code>test.html</code> . <br><br><h2>  <font color="#3AC1EF">Komponente</font> </h2><br>  Hier ist eine einfache <code>Button</code> Komponente.  Ich verwende React hier, aber Ihre Komponenten k√∂nnen mit jeder f√ºr Sie geeigneten Technologie geschrieben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span>  props.href    ? &lt;a {...props} className="Button"/&gt;    : &lt;button {...props} className="Button"/&gt; export default Button;</code> </pre> <br><h2>  <font color="#3AC1EF">Beispiel</font> </h2><br>  Und hier ist ein Beispiel f√ºr die Verwendung der <code>Button</code> Komponente.  Wie Sie sehen, gibt es in diesem Fall zwei Komponentenoptionen, die unterschiedliche Eigenschaften verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> alert('ouch')}&gt;    Click me  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>,  &lt;Button href=<span class="hljs-string"><span class="hljs-string">"https://reactjs.com"</span></span>&gt;    Follow me  &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Button&gt;, ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Test</font> </h2><br>  Hier ist die Seite <code>test.html</code> , auf der alle Komponenten geladen werden k√∂nnen.  Beachten Sie, dass die Methode das <code>performance</code> aufruft.  Mit ihrer Hilfe schreiben wir auf Anfrage in die Chrome-Leistungsprotokolldatei.  Sehr bald werden wir diese Aufzeichnungen verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> examples =  <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(location.hash + <span class="hljs-string"><span class="hljs-string">'-example.js'</span></span>); examples.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">example</span></span></span><span class="hljs-function"> =&gt;</span></span>  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>);  ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{example}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, where);  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>);  performance.measure(    <span class="hljs-string"><span class="hljs-string">'my mark'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>); );</code> </pre> <br><h2>  <font color="#3AC1EF">Testl√§ufer</font> </h2><br>  Um eine Testseite in Chrome zu laden, k√∂nnen wir die <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> Node.js-Bibliothek verwenden, die uns den Zugriff auf die API zur Verwaltung des Browsers erm√∂glicht.  Sie k√∂nnen diese Bibliothek auf jedem Betriebssystem verwenden.  Es hat eine eigene Kopie von Chrome, kann aber auch verwendet werden, um mit einer Instanz von Chrome oder Chromium verschiedener Versionen zu arbeiten, die bereits auf dem Computer des Entwicklers vorhanden sind.  Chrome kann so gestartet werden, dass sein Fenster nicht sichtbar ist.  Tests werden automatisch durchgef√ºhrt, w√§hrend der Entwickler das Browserfenster nicht sehen muss.  Chrome kann im normalen Modus gestartet werden.  Dies ist n√ºtzlich f√ºr Debugging-Zwecke. <br><br>  Hier ist ein Beispiel f√ºr ein Node.js-Skript, das √ºber die Befehlszeile ausgef√ºhrt wird, auf der eine Testseite geladen und Daten in eine Leistungsprotokolldatei geschrieben werden.  Alles, was im Browser zwischen den <code>tracing.start()</code> und <code>end()</code> passiert, wird in die Datei <code>trace.json</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pup.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.start({<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'trace.json'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'test.html#Button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.stop(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.close();</code> </pre> <br>  Der Entwickler kann die "Details" der Leistungsdaten verwalten, indem er die "Kategorien" der Ablaufverfolgung angibt.  Die Liste der verf√ºgbaren Kategorien wird angezeigt, wenn Sie unter <code>chrome://tracing</code> zu Chrome <code>chrome://tracing</code> , auf <code>Record</code> klicken und im angezeigten Fenster den Abschnitt <code>Edit categories</code> √∂ffnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/047/a3e/51e047a3e5a8b6980192bc6eb6c3047a.png"></div><br>  <i><font color="#999999">Konfigurieren der Zusammensetzung von Daten, die in das Leistungsprotokoll geschrieben werden</font></i> <br><br><h2>  <font color="#3AC1EF">Ergebnisse</font> </h2><br>  Nachdem die Testseite mit Puppeteer untersucht wurde, k√∂nnen Sie die Ergebnisse der Leistungsmessungen analysieren, indem Sie zum Browser unter <code>trace.json</code> <code>chrome://tracing</code> <code>trace.json</code> und die gerade aufgezeichnete <code>trace.json</code> Datei herunterladen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/13b/47c/63c13b47c6bf063822716d5cf13d2830.png"></div><br>  <i><font color="#999999">Trace.json Visualisierung</font></i> <br><br>  Hier sehen Sie die Ergebnisse des Aufrufs der Methode <code>performance.measure('my mark')</code> .  Der Aufruf von <code>measure()</code> dient nur zu Debugging-Zwecken, falls der Entwickler die Datei <code>trace.json</code> √∂ffnen und <code>trace.json</code> m√∂chte.  Alles, was mit der Seite passiert ist, ist im Block <code>my mark</code> . <br><br>  Hier ist ein <code>trace.json</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/9ac/4a4/b769ac4a4abd96771a74255a12a4522c.png"></div><br>  <i><font color="#999999">Fragment der trace.json-Datei</font></i> <br><br>  Um herauszufinden, was wir brauchen, ist es ausreichend, den Indikator der Anzahl der Prozessoranweisungen ( <code>ticount</code> ) des <code>Start</code> Markers vom selben Indikator des <code>End</code> Markers zu subtrahieren.  Auf diese Weise k√∂nnen Sie herausfinden, wie viele Prozessoranweisungen erforderlich sind, um die Komponente im Browser anzuzeigen.  Dies ist dieselbe Zahl, mit der Sie feststellen k√∂nnen, ob eine Komponente schneller oder langsamer geworden ist. <br><br><h2>  <font color="#3AC1EF">Der Teufel steckt im Detail</font> </h2><br>  Jetzt haben wir nur Indikatoren gemessen, die die erste Ausgabe auf der Seite einer einzelnen Komponente kennzeichnen.  Und nichts mehr.  Es ist unbedingt erforderlich, Indikatoren zu messen, die sich auf die kleinste auszuf√ºhrende Codemenge beziehen.  Auf diese Weise k√∂nnen Sie den Ger√§uschpegel verringern.  Der Teufel steckt im Detail.  Je kleiner die gemessene Leistung ist, desto besser.  Nach den Messungen muss aus den erhaltenen Ergebnissen entfernt werden, was au√üerhalb des Einflusses des Entwicklers liegt.  Zum Beispiel Daten, die sich auf Speicherbereinigungsvorg√§nge beziehen.  Die Komponente steuert solche Vorg√§nge nicht.  Wenn sie ausgef√ºhrt werden, bedeutet dies, dass der Browser beim Rendern der Komponente beschlossen hat, sie selbst zu starten.  Infolgedessen sollten die Prozessorressourcen, die f√ºr die Speicherbereinigung verwendet wurden, aus den endg√ºltigen Ergebnissen entfernt werden. <br><br>  Der Datenblock f√ºr die Garbage Collection (dieser ‚ÄûDatenblock‚Äú wird genauer gesagt als ‚ÄûEreignis‚Äú bezeichnet) hei√üt <code>V8.GCScavenger</code> .  Sein <code>tidelta</code> sollte von der Anzahl der Prozessoranweisungen abgezogen werden, die zum Rendern der Komponente verwendet werden.  <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">Hier ist die</a> Dokumentation f√ºr Trace-Ereignisse.  Es stimmt, es ist veraltet und enth√§lt keine Informationen zu den erforderlichen Indikatoren: <br><br><ul><li>  <code>tidelta</code> - Die Anzahl der Prozessoranweisungen, die zum Verarbeiten eines Ereignisses erforderlich sind. </li><li>  <code>ticount</code> - Die Anzahl der Anweisungen zum Starten des Ereignisses. </li></ul><br>  Sie m√ºssen sehr vorsichtig sein, was wir messen.  Browser sind hochintelligente Einheiten.  Sie optimieren Code, der mehrmals ausgef√ºhrt wird.  In der n√§chsten Grafik sehen Sie die Anzahl der Prozessoranweisungen, die f√ºr die Ausgabe einer bestimmten Komponente erforderlich sind.  Der erste Rendervorgang erfordert die meisten Ressourcen.  Nachfolgende Operationen verursachen eine viel geringere Belastung des Prozessors.  Dies sollte bei der Analyse der Codeleistung ber√ºcksichtigt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/329/857/880329857fe02edf503db2e4bff07380.png"></div><br>  <i><font color="#999999">10 Renderoperationen derselben Komponente</font></i> <br><br>  Hier ist ein weiteres Detail: Wenn die Komponente einige asynchrone Vorg√§nge ausf√ºhrt (z. B. <code>setTimeout()</code> oder <code>fetch()</code> ), wird die durch den asynchronen Code verursachte Systemlast nicht ber√ºcksichtigt.  Vielleicht ist es gut.  Vielleicht ist es schlecht.  Wenn Sie die Leistung solcher Komponenten untersuchen, ziehen Sie eine separate Untersuchung des asynchronen Codes in Betracht. <br><br><h2>  <font color="#3AC1EF">Starkes Signal</font> </h2><br>  Wenn Sie verantwortungsbewusst vorgehen, um das Problem zu l√∂sen, was genau gemessen wird, erhalten Sie ein wirklich stabiles Signal, das die Auswirkung von √Ñnderungen auf die Leistung widerspiegelt.  Ich mag die Gl√§tte der Linien in der n√§chsten Grafik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/905/b1b/58b/905b1b58bd6e5fdbb34f4e0b0dedaebd.png"></div><br>  <i><font color="#999999">Stabile Messergebnisse</font></i> <br><br>  Das untere Diagramm zeigt die Messergebnisse von 10 Renderoperationen eines einfachen <code>&lt;span&gt;</code> -Elements in React.  In diesen Ergebnissen ist nichts anderes enthalten.  Es stellt sich heraus, dass f√ºr diesen Vorgang 2,15 bis 2,2 Millionen Prozessorbefehle erforderlich sind.  Wenn Sie das <code>&lt;span&gt;</code> in das <code>&lt;p&gt;</code> , ben√∂tigen Sie f√ºr die Ausgabe eines solchen Designs etwa 2,3 Millionen Anweisungen.  Diese Genauigkeit f√§llt mir auf.  Wenn ein Entwickler den Leistungsunterschied sieht, der auftritt, wenn ein einzelnes <code>&lt;p&gt;</code> -Element zu einer Seite hinzugef√ºgt wird, bedeutet dies, dass der Entwickler √ºber ein wirklich leistungsf√§higes Tool verf√ºgt. <br><br>  Wie genau solche Messungen dargestellt werden, ist Sache des Entwicklers.  Wenn er keine solche Genauigkeit ben√∂tigt, kann er immer die Renderleistung gr√∂√üerer Fragmente messen. <br><br><h2>  <font color="#3AC1EF">Zus√§tzliche Leistungsinformationen</font> </h2><br>  Jetzt, da dem Entwickler ein System zum Auffinden numerischer Indikatoren zur Verf√ºgung steht, die die Leistung kleinster Codefragmente sehr genau charakterisieren, kann der Entwickler mit diesem System verschiedene Probleme l√∂sen.  Mit <code>performance.mark()</code> Sie also zus√§tzliche n√ºtzliche Informationen in <code>trace.json</code> schreiben.  Sie k√∂nnen den Mitgliedern des Entwicklungsteams mitteilen, was gerade passiert und was die Anzahl der Prozessoranweisungen erh√∂ht, die zum Ausf√ºhren von Code erforderlich sind.  Sie k√∂nnen in die Leistungsberichte Informationen zur Anzahl der DOM-Knoten oder zur Anzahl der von React ausgef√ºhrten Schreibvorg√§nge im DOM aufnehmen.  In der Tat k√∂nnen Sie hier Informationen √ºber eine Menge anzeigen.  Sie k√∂nnen die Anzahl der Seitenlayout-Neuberechnungen z√§hlen.  Mit Puppeteer k√∂nnen Sie Screenshots von Seiten machen und vergleichen, wie die Benutzeroberfl√§che vor und nach √Ñnderungen aussieht.  Manchmal ist die Erh√∂hung der Anzahl der zum Anzeigen einer Seite erforderlichen Prozessoranweisungen v√∂llig √ºberraschend.  Zum Beispiel, wenn der neuen Version der Seite 10 Schaltfl√§chen und 12 Felder zum Bearbeiten und Formatieren von Text hinzugef√ºgt werden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ist es m√∂glich, dass jeder, der hier diskutiert wurde, es heute benutzt?  Ja du kannst  Dazu ben√∂tigen Sie Chrome Version 78 oder h√∂her.  Wenn <code>trace.json</code> √ºber <code>ticount</code> und <code>tidelta</code> , steht Ihnen das oben <code>tidelta</code> zur Verf√ºgung.  Fr√ºhere Versionen von Chrome tun dies nicht. <br><br>  Leider k√∂nnen auf der Mac-Plattform keine Informationen √ºber die Anzahl der Prozessoranweisungen abgerufen werden.  Ich habe Windows noch nicht ausprobiert, daher kann ich zu diesem Betriebssystem nichts Genaues sagen.  Im Allgemeinen - unsere Freunde sind Unix und Linux. <br><br>  Es ist zu beachten, dass der Browser nur dann Informationen zu Prozessoranweisungen bereitstellen kann, wenn Sie ein paar Flags verwenden. <code>--enable-thread-instruction-count</code> handelt es sich um <code>--no-sandbox</code> <code>--enable-thread-instruction-count</code> und <code>--enable-thread-instruction-count</code> .  So √ºbergeben Sie sie an einen von Puppeteer gestarteten Browser: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({  <span class="hljs-attr"><span class="hljs-attr">args</span></span>: [    <span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>,    <span class="hljs-string"><span class="hljs-string">'--enable-thread-instruction-count'</span></span>,  ]});</code> </pre> <br>  Hoffentlich k√∂nnen Sie jetzt die Leistungsanalyse Ihrer Webanwendung auf die n√§chste Stufe heben. <br><br>  <b>Sehr geehrte Leser!</b>  Planen Sie, die hier vorgestellte Methodik zur Analyse der Leistung von Webprojekten zu verwenden? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479266/">https://habr.com/ru/post/de479266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479252/index.html">Listenverst√§ndnis vs Karte</a></li>
<li><a href="../de479256/index.html">Nach dem Astrotracker an zwei Abenden - Meine Erfahrung</a></li>
<li><a href="../de479258/index.html">IGF 2019. F√§llt das Internet auseinander?</a></li>
<li><a href="../de479262/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 392 (2. - 8. Dezember 2019)</a></li>
<li><a href="../de479264/index.html">Die Farbe des Mondes und der Sonne aus dem All in Bezug auf RGB und Farbtemperatur</a></li>
<li><a href="../de479268/index.html">Event Listener und Web Worker</a></li>
<li><a href="../de479270/index.html">Was k√∂nnen Sie 2020 von Node.js erwarten?</a></li>
<li><a href="../de479272/index.html">[Lesezeichen] 9 Tools zur Steigerung der Produktivit√§t von Webentwicklern</a></li>
<li><a href="../de479274/index.html">10 wichtige Python-Tricks</a></li>
<li><a href="../de479276/index.html">Drei Pandas-Methoden, die Sie vielleicht nicht kennen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>