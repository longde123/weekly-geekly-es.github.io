<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍏 🛣️ 🛀🏿 Analyse der CPU-Auslastung einzelner JavaScript-Komponenten 🎤 🏄 🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns ein wenig darüber sprechen, wie viel CPU-Ressourcen der JavaScript-Code der Anwendung verbraucht. Gleichzeitig schlage ich vor, unser G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse der CPU-Auslastung einzelner JavaScript-Komponenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479266/">  Lassen Sie uns ein wenig darüber sprechen, wie viel CPU-Ressourcen der JavaScript-Code der Anwendung verbraucht.  Gleichzeitig schlage ich vor, unser Gespräch auf Komponenten aufzubauen - die Grundbausteine ​​der Anwendung.  Mit diesem Ansatz können alle Bemühungen zur Verbesserung der Produktivität (oder zur Ermittlung der Ursachen für Programmverlangsamungen) auf (hoffentlich) kleine, autarke Teile des Projekts konzentriert werden.  Gleichzeitig gehe ich davon aus, dass Ihre Front-End-Anwendung, wie viele andere moderne Projekte, durch Zusammenfügen kleiner Fragmente der Schnittstelle erstellt wurde, die für die wiederholte Verwendung geeignet sind.  Wenn dies nicht der Fall ist, können wir unsere Überlegungen auf eine andere Anwendung übertragen. Sie müssen jedoch Ihren eigenen Weg finden, um Ihren umfangreichen Code in Fragmente zu unterteilen, und Sie müssen darüber nachdenken, wie Sie diese Fragmente analysieren können. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479266/"><img src="https://habrastorage.org/webt/cx/wv/2y/cxwv2ylp34aq6hzys-fss3azza0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Warum ist das nötig?</font> </h2><br>  Warum den CPU-Verbrauch mit JavaScript messen?  Tatsache ist, dass die Anwendungsleistung heutzutage meistens an die Fähigkeiten des Prozessors gebunden ist.  Lassen Sie mich die Worte von Steve Soders und Pat Minan aus einem Interview für <a href="https://podcast.perfplanet.com/">Planet Performance Podcast</a> zitieren.  Beide gaben an, dass die Anwendungsleistung nicht mehr auf Netzwerkfähigkeiten oder Netzwerklatenzen beschränkt ist.  Netzwerke werden immer schneller.  Darüber hinaus lernten die Entwickler, Server-Textantworten mit GZIP (oder besser mit brotli) zu komprimieren, und fanden heraus, wie Bilder optimiert werden können.  Es ist alles sehr einfach. <br><br>  Der Leistungsengpass moderner Anwendungen sind Prozessoren.  Dies gilt insbesondere für die mobile Umgebung.  Gleichzeitig sind unsere Erwartungen an die interaktiven Funktionen moderner Webanwendungen gestiegen.  Wir erwarten, dass die Schnittstellen solcher Anwendungen sehr schnell und reibungslos funktionieren.  Und das alles erfordert immer mehr JavaScript-Code.  Darüber hinaus müssen wir uns daran erinnern, dass 1 MB Bild nicht mit 1 MB JavaScript identisch ist.  Die Bilder werden nach und nach heruntergeladen und die Anwendung löst zu diesem Zeitpunkt andere Probleme.  JavaScript-Code ist jedoch häufig eine solche Ressource, ohne die sich die Anwendung als nicht funktionsfähig herausstellt.  Um das Funktionieren einer modernen Anwendung zu gewährleisten, sind große Mengen an JS-Code erforderlich, die analysiert und ausgeführt werden müssen, bevor sie wirklich funktionieren.  Und dies sind Aufgaben, die stark von den Fähigkeiten des Prozessors abhängen. <br><br><h2>  <font color="#3AC1EF">Leistungsindikator</font> </h2><br>  Wir werden einen solchen Indikator für die Geschwindigkeit von Codefragmenten als die Anzahl der Prozessoranweisungen verwenden, die erforderlich sind, um sie zu verarbeiten.  Dies ermöglicht es uns, die Messungen von den Eigenschaften eines bestimmten Computers und von dem Zustand, in dem er sich zum Zeitpunkt der Messung befindet, zu trennen.  Zeitbasierte Metriken (wie TTI) haben zu viel "Rauschen".  Sie hängen vom Status der Netzwerkverbindung sowie von allen anderen Ereignissen ab, die zum Zeitpunkt der Messung auf dem Computer auftreten.  Beispielsweise können einige Skripte, die während des Ladens der untersuchten Seite ausgeführt werden, oder Viren, die mit etwas in den Hintergrundprozessen beschäftigt sind, die zeitlichen Leistungsindikatoren beeinflussen.  Das Gleiche gilt für Browsererweiterungen, die viel Systemressourcen verbrauchen und die Seite verlangsamen können.  Bei der Berechnung der Anzahl der Prozessorbefehle spielt die Zeit dagegen keine Rolle.  Solche Indikatoren können, wie Sie gleich sehen werden, wirklich stabil sein. <br><br><h2>  <font color="#3AC1EF">Idee</font> </h2><br>  Hier ist die Idee, die unserer Arbeit zugrunde liegt: Wir müssen ein „Labor“ schaffen, in dem der Code gestartet und überprüft wird, wenn Änderungen daran vorgenommen werden.  Mit "Labor" meine ich einen normalen Computer, vielleicht den, den Sie ständig benutzen.  Versionskontrollsysteme stellen uns Haken zur Verfügung, mit denen Sie bestimmte Ereignisse abfangen und bestimmte Prüfungen durchführen können.  Selbstverständlich können Messungen im „Labor“ nach dem Festschreiben durchgeführt werden.  Aber Sie wissen wahrscheinlich, dass Änderungen an Code, der die Festschreibungsphase erreicht hat, langsamer durchgeführt werden als an Code, der geschrieben wird (wenn überhaupt).  Gleiches gilt für die Korrektur des Beta-Codes des Produkts und des Codes, der in die Produktion gelangt ist. <br><br>  Wir müssen jedes Mal, wenn der Code geändert wird, seine Leistung vergleichen, bevor und nachdem Änderungen vorgenommen werden.  Dabei sind wir bestrebt, Komponenten isoliert zu untersuchen.  Auf diese Weise können wir die Probleme klar erkennen und genau wissen, wo sie auftreten. <br><br>  Das Gute ist, dass solche Studien in einem echten Browser durchgeführt werden können, zum Beispiel mit Puppeteer.  Mit diesem Tool können Sie den Browser ohne Benutzeroberfläche über Node.js steuern. <br><br><h2>  <font color="#3AC1EF">Suchcode für Recherchen</font> </h2><br>  Um den Code für die Studie zu finden, können wir auf jeden Styleguide oder auf jedes Design-System verweisen.  Im Allgemeinen sind wir mit allem zufrieden, was kurze, isolierte Beispiele für die Verwendung von Komponenten liefert. <br><br>  Was ist ein „Styleguide“?  Dies ist normalerweise eine Webanwendung, die alle Komponenten oder „Bausteine“ von Benutzeroberflächenelementen demonstriert, die dem Entwickler zur Verfügung stehen.  Es kann sich entweder um eine bestimmte Bibliothek mit Komponenten von Drittanbietern oder um eine von Ihnen erstellte Bibliothek handeln. <br><br>  Bei der Suche nach solchen Projekten im Internet bin ich kürzlich auf einen Diskussionsthread auf Twitter gestoßen, in dem es um relativ neue Bibliotheken von React-Komponenten ging.  Ich habe mir einige der dort erwähnten Bibliotheken angesehen. <br><br>  Es überrascht nicht, dass moderne, qualitativ hochwertige Bibliotheken über eine Dokumentation verfügen, die Arbeitscodebeispiele enthält.  Hier sind einige Bibliotheken und <code>Button</code> Komponenten aufgeführt, die mit ihren Mitteln implementiert wurden.  Die Dokumentation zu diesen Bibliotheken enthält Beispiele für die Verwendung dieser Komponenten.  Wir sprechen über die Chakra-Bibliothek und die Semantic UI React-Bibliothek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/95d/a0c/64c95da0c7b84620135e33e377c47bd2.png"></div><br>  <i><font color="#999999">Button Component Chakra Dokumentation</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d3/b45/093/7d3b45093ae1f8c6d99e174ca389a9e0.png"></div><br>  <i><font color="#999999">Button Semantic UI React Documentation</font></i> <br><br>  Genau das brauchen wir.  Dies sind Beispiele, deren Code wir auf den Verbrauch von Prozessorressourcen untersuchen können.  Ähnliche Beispiele finden Sie in der Dokumentation oder in Codekommentaren im JSDoc-Stil.  Wenn Sie Glück haben, finden Sie solche Beispiele möglicherweise als separate Dateien, beispielsweise in Form von Unit-Test-Dateien.  Sicher wird es so sein.  Schließlich schreiben wir alle Unit-Tests.  Richtig? <br><br><h2>  <font color="#3AC1EF">Dateien</font> </h2><br>  Stellen Sie sich zur Veranschaulichung der beschriebenen Methode der Leistungsanalyse vor, dass sich in der Bibliothek, die wir untersuchen, eine <code>Button</code> Komponente befindet, deren Code in der Datei <code>Button.js</code> enthalten ist. <code>Button-example.js</code> .  Wir müssen eine Art Testseite erstellen, in deren Umgebung Testcode ausgeführt werden kann.  Sowas wie <code>test.html</code> . <br><br><h2>  <font color="#3AC1EF">Komponente</font> </h2><br>  Hier ist eine einfache <code>Button</code> Komponente.  Ich verwende React hier, aber Ihre Komponenten können mit jeder für Sie geeigneten Technologie geschrieben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span>  props.href    ? &lt;a {...props} className="Button"/&gt;    : &lt;button {...props} className="Button"/&gt; export default Button;</code> </pre> <br><h2>  <font color="#3AC1EF">Beispiel</font> </h2><br>  Und hier ist ein Beispiel für die Verwendung der <code>Button</code> Komponente.  Wie Sie sehen, gibt es in diesem Fall zwei Komponentenoptionen, die unterschiedliche Eigenschaften verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> alert('ouch')}&gt;    Click me  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>,  &lt;Button href=<span class="hljs-string"><span class="hljs-string">"https://reactjs.com"</span></span>&gt;    Follow me  &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Button&gt;, ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Test</font> </h2><br>  Hier ist die Seite <code>test.html</code> , auf der alle Komponenten geladen werden können.  Beachten Sie, dass die Methode das <code>performance</code> aufruft.  Mit ihrer Hilfe schreiben wir auf Anfrage in die Chrome-Leistungsprotokolldatei.  Sehr bald werden wir diese Aufzeichnungen verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> examples =  <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(location.hash + <span class="hljs-string"><span class="hljs-string">'-example.js'</span></span>); examples.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">example</span></span></span><span class="hljs-function"> =&gt;</span></span>  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>);  ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{example}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, where);  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>);  performance.measure(    <span class="hljs-string"><span class="hljs-string">'my mark'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>); );</code> </pre> <br><h2>  <font color="#3AC1EF">Testläufer</font> </h2><br>  Um eine Testseite in Chrome zu laden, können wir die <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> Node.js-Bibliothek verwenden, die uns den Zugriff auf die API zur Verwaltung des Browsers ermöglicht.  Sie können diese Bibliothek auf jedem Betriebssystem verwenden.  Es hat eine eigene Kopie von Chrome, kann aber auch verwendet werden, um mit einer Instanz von Chrome oder Chromium verschiedener Versionen zu arbeiten, die bereits auf dem Computer des Entwicklers vorhanden sind.  Chrome kann so gestartet werden, dass sein Fenster nicht sichtbar ist.  Tests werden automatisch durchgeführt, während der Entwickler das Browserfenster nicht sehen muss.  Chrome kann im normalen Modus gestartet werden.  Dies ist nützlich für Debugging-Zwecke. <br><br>  Hier ist ein Beispiel für ein Node.js-Skript, das über die Befehlszeile ausgeführt wird, auf der eine Testseite geladen und Daten in eine Leistungsprotokolldatei geschrieben werden.  Alles, was im Browser zwischen den <code>tracing.start()</code> und <code>end()</code> passiert, wird in die Datei <code>trace.json</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pup.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.start({<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'trace.json'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'test.html#Button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.stop(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.close();</code> </pre> <br>  Der Entwickler kann die "Details" der Leistungsdaten verwalten, indem er die "Kategorien" der Ablaufverfolgung angibt.  Die Liste der verfügbaren Kategorien wird angezeigt, wenn Sie unter <code>chrome://tracing</code> zu Chrome <code>chrome://tracing</code> , auf <code>Record</code> klicken und im angezeigten Fenster den Abschnitt <code>Edit categories</code> öffnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/047/a3e/51e047a3e5a8b6980192bc6eb6c3047a.png"></div><br>  <i><font color="#999999">Konfigurieren der Zusammensetzung von Daten, die in das Leistungsprotokoll geschrieben werden</font></i> <br><br><h2>  <font color="#3AC1EF">Ergebnisse</font> </h2><br>  Nachdem die Testseite mit Puppeteer untersucht wurde, können Sie die Ergebnisse der Leistungsmessungen analysieren, indem Sie zum Browser unter <code>trace.json</code> <code>chrome://tracing</code> <code>trace.json</code> und die gerade aufgezeichnete <code>trace.json</code> Datei herunterladen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/13b/47c/63c13b47c6bf063822716d5cf13d2830.png"></div><br>  <i><font color="#999999">Trace.json Visualisierung</font></i> <br><br>  Hier sehen Sie die Ergebnisse des Aufrufs der Methode <code>performance.measure('my mark')</code> .  Der Aufruf von <code>measure()</code> dient nur zu Debugging-Zwecken, falls der Entwickler die Datei <code>trace.json</code> öffnen und <code>trace.json</code> möchte.  Alles, was mit der Seite passiert ist, ist im Block <code>my mark</code> . <br><br>  Hier ist ein <code>trace.json</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/9ac/4a4/b769ac4a4abd96771a74255a12a4522c.png"></div><br>  <i><font color="#999999">Fragment der trace.json-Datei</font></i> <br><br>  Um herauszufinden, was wir brauchen, ist es ausreichend, den Indikator der Anzahl der Prozessoranweisungen ( <code>ticount</code> ) des <code>Start</code> Markers vom selben Indikator des <code>End</code> Markers zu subtrahieren.  Auf diese Weise können Sie herausfinden, wie viele Prozessoranweisungen erforderlich sind, um die Komponente im Browser anzuzeigen.  Dies ist dieselbe Zahl, mit der Sie feststellen können, ob eine Komponente schneller oder langsamer geworden ist. <br><br><h2>  <font color="#3AC1EF">Der Teufel steckt im Detail</font> </h2><br>  Jetzt haben wir nur Indikatoren gemessen, die die erste Ausgabe auf der Seite einer einzelnen Komponente kennzeichnen.  Und nichts mehr.  Es ist unbedingt erforderlich, Indikatoren zu messen, die sich auf die kleinste auszuführende Codemenge beziehen.  Auf diese Weise können Sie den Geräuschpegel verringern.  Der Teufel steckt im Detail.  Je kleiner die gemessene Leistung ist, desto besser.  Nach den Messungen muss aus den erhaltenen Ergebnissen entfernt werden, was außerhalb des Einflusses des Entwicklers liegt.  Zum Beispiel Daten, die sich auf Speicherbereinigungsvorgänge beziehen.  Die Komponente steuert solche Vorgänge nicht.  Wenn sie ausgeführt werden, bedeutet dies, dass der Browser beim Rendern der Komponente beschlossen hat, sie selbst zu starten.  Infolgedessen sollten die Prozessorressourcen, die für die Speicherbereinigung verwendet wurden, aus den endgültigen Ergebnissen entfernt werden. <br><br>  Der Datenblock für die Garbage Collection (dieser „Datenblock“ wird genauer gesagt als „Ereignis“ bezeichnet) heißt <code>V8.GCScavenger</code> .  Sein <code>tidelta</code> sollte von der Anzahl der Prozessoranweisungen abgezogen werden, die zum Rendern der Komponente verwendet werden.  <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">Hier ist die</a> Dokumentation für Trace-Ereignisse.  Es stimmt, es ist veraltet und enthält keine Informationen zu den erforderlichen Indikatoren: <br><br><ul><li>  <code>tidelta</code> - Die Anzahl der Prozessoranweisungen, die zum Verarbeiten eines Ereignisses erforderlich sind. </li><li>  <code>ticount</code> - Die Anzahl der Anweisungen zum Starten des Ereignisses. </li></ul><br>  Sie müssen sehr vorsichtig sein, was wir messen.  Browser sind hochintelligente Einheiten.  Sie optimieren Code, der mehrmals ausgeführt wird.  In der nächsten Grafik sehen Sie die Anzahl der Prozessoranweisungen, die für die Ausgabe einer bestimmten Komponente erforderlich sind.  Der erste Rendervorgang erfordert die meisten Ressourcen.  Nachfolgende Operationen verursachen eine viel geringere Belastung des Prozessors.  Dies sollte bei der Analyse der Codeleistung berücksichtigt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/329/857/880329857fe02edf503db2e4bff07380.png"></div><br>  <i><font color="#999999">10 Renderoperationen derselben Komponente</font></i> <br><br>  Hier ist ein weiteres Detail: Wenn die Komponente einige asynchrone Vorgänge ausführt (z. B. <code>setTimeout()</code> oder <code>fetch()</code> ), wird die durch den asynchronen Code verursachte Systemlast nicht berücksichtigt.  Vielleicht ist es gut.  Vielleicht ist es schlecht.  Wenn Sie die Leistung solcher Komponenten untersuchen, ziehen Sie eine separate Untersuchung des asynchronen Codes in Betracht. <br><br><h2>  <font color="#3AC1EF">Starkes Signal</font> </h2><br>  Wenn Sie verantwortungsbewusst vorgehen, um das Problem zu lösen, was genau gemessen wird, erhalten Sie ein wirklich stabiles Signal, das die Auswirkung von Änderungen auf die Leistung widerspiegelt.  Ich mag die Glätte der Linien in der nächsten Grafik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/905/b1b/58b/905b1b58bd6e5fdbb34f4e0b0dedaebd.png"></div><br>  <i><font color="#999999">Stabile Messergebnisse</font></i> <br><br>  Das untere Diagramm zeigt die Messergebnisse von 10 Renderoperationen eines einfachen <code>&lt;span&gt;</code> -Elements in React.  In diesen Ergebnissen ist nichts anderes enthalten.  Es stellt sich heraus, dass für diesen Vorgang 2,15 bis 2,2 Millionen Prozessorbefehle erforderlich sind.  Wenn Sie das <code>&lt;span&gt;</code> in das <code>&lt;p&gt;</code> , benötigen Sie für die Ausgabe eines solchen Designs etwa 2,3 Millionen Anweisungen.  Diese Genauigkeit fällt mir auf.  Wenn ein Entwickler den Leistungsunterschied sieht, der auftritt, wenn ein einzelnes <code>&lt;p&gt;</code> -Element zu einer Seite hinzugefügt wird, bedeutet dies, dass der Entwickler über ein wirklich leistungsfähiges Tool verfügt. <br><br>  Wie genau solche Messungen dargestellt werden, ist Sache des Entwicklers.  Wenn er keine solche Genauigkeit benötigt, kann er immer die Renderleistung größerer Fragmente messen. <br><br><h2>  <font color="#3AC1EF">Zusätzliche Leistungsinformationen</font> </h2><br>  Jetzt, da dem Entwickler ein System zum Auffinden numerischer Indikatoren zur Verfügung steht, die die Leistung kleinster Codefragmente sehr genau charakterisieren, kann der Entwickler mit diesem System verschiedene Probleme lösen.  Mit <code>performance.mark()</code> Sie also zusätzliche nützliche Informationen in <code>trace.json</code> schreiben.  Sie können den Mitgliedern des Entwicklungsteams mitteilen, was gerade passiert und was die Anzahl der Prozessoranweisungen erhöht, die zum Ausführen von Code erforderlich sind.  Sie können in die Leistungsberichte Informationen zur Anzahl der DOM-Knoten oder zur Anzahl der von React ausgeführten Schreibvorgänge im DOM aufnehmen.  In der Tat können Sie hier Informationen über eine Menge anzeigen.  Sie können die Anzahl der Seitenlayout-Neuberechnungen zählen.  Mit Puppeteer können Sie Screenshots von Seiten machen und vergleichen, wie die Benutzeroberfläche vor und nach Änderungen aussieht.  Manchmal ist die Erhöhung der Anzahl der zum Anzeigen einer Seite erforderlichen Prozessoranweisungen völlig überraschend.  Zum Beispiel, wenn der neuen Version der Seite 10 Schaltflächen und 12 Felder zum Bearbeiten und Formatieren von Text hinzugefügt werden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ist es möglich, dass jeder, der hier diskutiert wurde, es heute benutzt?  Ja du kannst  Dazu benötigen Sie Chrome Version 78 oder höher.  Wenn <code>trace.json</code> über <code>ticount</code> und <code>tidelta</code> , steht Ihnen das oben <code>tidelta</code> zur Verfügung.  Frühere Versionen von Chrome tun dies nicht. <br><br>  Leider können auf der Mac-Plattform keine Informationen über die Anzahl der Prozessoranweisungen abgerufen werden.  Ich habe Windows noch nicht ausprobiert, daher kann ich zu diesem Betriebssystem nichts Genaues sagen.  Im Allgemeinen - unsere Freunde sind Unix und Linux. <br><br>  Es ist zu beachten, dass der Browser nur dann Informationen zu Prozessoranweisungen bereitstellen kann, wenn Sie ein paar Flags verwenden. <code>--enable-thread-instruction-count</code> handelt es sich um <code>--no-sandbox</code> <code>--enable-thread-instruction-count</code> und <code>--enable-thread-instruction-count</code> .  So übergeben Sie sie an einen von Puppeteer gestarteten Browser: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({  <span class="hljs-attr"><span class="hljs-attr">args</span></span>: [    <span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>,    <span class="hljs-string"><span class="hljs-string">'--enable-thread-instruction-count'</span></span>,  ]});</code> </pre> <br>  Hoffentlich können Sie jetzt die Leistungsanalyse Ihrer Webanwendung auf die nächste Stufe heben. <br><br>  <b>Sehr geehrte Leser!</b>  Planen Sie, die hier vorgestellte Methodik zur Analyse der Leistung von Webprojekten zu verwenden? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479266/">https://habr.com/ru/post/de479266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479252/index.html">Listenverständnis vs Karte</a></li>
<li><a href="../de479256/index.html">Nach dem Astrotracker an zwei Abenden - Meine Erfahrung</a></li>
<li><a href="../de479258/index.html">IGF 2019. Fällt das Internet auseinander?</a></li>
<li><a href="../de479262/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 392 (2. - 8. Dezember 2019)</a></li>
<li><a href="../de479264/index.html">Die Farbe des Mondes und der Sonne aus dem All in Bezug auf RGB und Farbtemperatur</a></li>
<li><a href="../de479268/index.html">Event Listener und Web Worker</a></li>
<li><a href="../de479270/index.html">Was können Sie 2020 von Node.js erwarten?</a></li>
<li><a href="../de479272/index.html">[Lesezeichen] 9 Tools zur Steigerung der Produktivität von Webentwicklern</a></li>
<li><a href="../de479274/index.html">10 wichtige Python-Tricks</a></li>
<li><a href="../de479276/index.html">Drei Pandas-Methoden, die Sie vielleicht nicht kennen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>