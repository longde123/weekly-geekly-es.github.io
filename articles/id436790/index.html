<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➖ 🐞 🌚 256 baris telanjang C ++: menulis pelacak sinar dari awal dalam beberapa jam 🕣 🚘 👨🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya menerbitkan bab selanjutnya dari kuliah saya tentang grafik komputer (di sini Anda dapat membaca yang asli dalam bahasa Rusia, meskipun versi bah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256 baris telanjang C ++: menulis pelacak sinar dari awal dalam beberapa jam</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436790/">  Saya menerbitkan bab selanjutnya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuliah</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang grafik komputer</a> (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini Anda dapat membaca yang</a> asli dalam bahasa Rusia, meskipun versi bahasa Inggrisnya lebih baru).  Kali ini, topik pembicaraan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambar adegan menggunakan ray tracing</a> .  Seperti biasa, saya mencoba menghindari perpustakaan pihak ketiga, karena ini membuat siswa melihat di bawah tenda. <br><br>  Sudah ada banyak proyek serupa di Internet, tetapi hampir semuanya menunjukkan program yang sudah selesai yang sangat sulit untuk dipahami.  Di sini, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program rendering yang</a> sangat terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang cocok dengan kartu nama</a> .  Hasil yang sangat mengesankan, tetapi memahami kode ini sangat sulit.  Tujuan saya bukan untuk menunjukkan bagaimana saya bisa, tetapi untuk memberi tahu secara detail bagaimana mereproduksi ini.  Terlebih lagi, bagi saya kelihatannya kuliah ini bermanfaat bahkan tidak sebanyak materi pelatihan tentang grafik komputer, tetapi lebih sebagai manual pemrograman.  Saya akan secara konsisten menunjukkan bagaimana mencapai hasil akhir, mulai dari awal: bagaimana menguraikan masalah yang rumit menjadi tahap-tahap dasar yang dapat dipecahkan. <br><br>  <i>Perhatian: hanya melihat kode saya, serta hanya membaca artikel ini dengan secangkir teh di tangan, tidak masuk akal.</i>  <i>Artikel ini dirancang bagi Anda untuk mengambil keyboard dan menulis mesin Anda sendiri.</i>  <i>Dia pasti akan lebih baik daripada milikku.</i>  <i>Ya, atau ubah saja bahasa pemrograman!</i> <br><br>  Jadi, hari ini saya akan menunjukkan cara menggambar gambar seperti itu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1>  Tahap satu: menyimpan gambar ke disk </h1><br>  Saya tidak ingin repot dengan manajer jendela, pemrosesan mouse / keyboard, dan sejenisnya.  Hasil dari program kami adalah gambar sederhana yang disimpan ke disk.  Jadi, hal pertama yang perlu kita lakukan adalah menyimpan gambar ke disk.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sinilah</a> letak kode yang memungkinkan Anda melakukan ini.  Biarkan saya memberi Anda file utamanya: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br>  Di fungsi utama, hanya fungsi render () yang dipanggil, bukan yang lain.  Apa yang ada di dalam fungsi render ()?  Pertama-tama, saya mendefinisikan gambar sebagai array satu dimensi dari nilai-nilai framebuffer dari tipe Vec3f, ini adalah vektor tiga dimensi sederhana yang memberi kita warna (r, g, b) untuk setiap piksel. <br><br>  Kelas vektor tinggal di file geometry.h, saya tidak akan menjelaskannya di sini: pertama, semuanya sepele di sana, manipulasi sederhana vektor dua dan tiga dimensi (penambahan, pengurangan, penugasan, perkalian dengan skalar, produk skalar), dan kedua, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">gbg</a> sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambarkannya</a> secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rinci</a> sebagai bagian dari kursus kuliah tentang grafik komputer. <br><br>  Saya menyimpan gambar dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format ppm</a> ;  Ini adalah cara termudah untuk menyimpan gambar, meskipun tidak selalu paling nyaman untuk dilihat lebih lanjut.  Jika Anda ingin menyimpan dalam format lain, saya masih merekomendasikan menghubungkan perpustakaan pihak ketiga, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stb</a> .  Ini adalah pustaka yang luar biasa: cukup untuk memasukkan satu file header stb_image_write.h dalam proyek, dan ini akan memungkinkan Anda untuk menyimpannya bahkan di png, bahkan di jpg. <br><br>  Secara total, tujuan dari tahap ini adalah untuk memastikan bahwa kita dapat a) membuat gambar dalam memori dan menulis nilai warna yang berbeda di sana b) menyimpan hasilnya ke disk sehingga dapat dilihat dalam program pihak ketiga.  Inilah hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1>  Tahap dua, yang paling sulit: penelusuran sinar langsung </h1><br>  Ini adalah tahap paling penting dan sulit dari keseluruhan rantai.  Saya ingin mendefinisikan satu bola dalam kode saya dan menunjukkannya di layar tanpa mengganggu bahan atau pencahayaan.  Beginilah seharusnya hasil kami: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br>  Untuk kenyamanan, di repositori saya, ada satu komit untuk setiap tahap;  Github membuatnya sangat nyaman untuk melihat perubahan Anda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini, misalnya</a> , apa yang telah berubah di komit kedua dibandingkan dengan komit pertama. <br><br>  Untuk mulai dengan: apa yang kita butuhkan untuk mewakili sebuah bola dalam memori komputer?  Empat angka cukup bagi kita: vektor tiga dimensi dengan pusat bola dan skalar yang menggambarkan jari-jari: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  Satu-satunya hal nontrivial dalam kode ini adalah fungsi yang memungkinkan Anda untuk memeriksa apakah sinar yang diberikan (yang berasal dari asal dalam arah dir) berpotongan dengan bola kami.  Penjelasan terperinci dari algoritma untuk memeriksa persimpangan balok dan bola dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibaca di sini</a> , saya sangat merekomendasikan melakukan ini dan memeriksa kode saya. <br><br>  Bagaimana cara kerja ray tracing?  Sangat sederhana.  Pada tahap pertama, kita cukup menutupi gambar dengan gradien: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  Sekarang, untuk setiap piksel, kita akan membentuk sinar yang datang dari pusat koordinat dan melewati piksel kita, dan memeriksa apakah sinar ini memotong bola kita. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br>  Jika tidak ada persimpangan dengan bola, maka kita akan meletakkan color1, jika tidak color2: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre><br>  Pada titik ini, saya sarankan mengambil pensil dan memeriksa di atas kertas semua perhitungan, baik persimpangan sinar dengan bola, dan menyapu gambar dengan sinar.  Untuk jaga-jaga, kamera kami ditentukan oleh hal-hal berikut: <br><br><ul><li>  lebar gambar </li><li>  tinggi gambar </li><li>  sudut pandang, fov </li><li>  lokasi kamera, Vec3f (0,0,0) </li><li>  arah pandangan, sepanjang sumbu z, ke arah minus tanpa batas </li></ul><br><h1>  Tahap Tiga: Tambahkan Spheres Lainnya </h1><br>  Semua yang paling sulit ada di belakang kita, sekarang jalan kita tidak berawan.  Jika kita bisa menggambar satu bola.  maka jelas menambah beberapa pekerjaan tidak sulit.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini Anda dapat</a> melihat perubahan dalam kode, dan inilah hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1>  Tahap Empat: Pencahayaan </h1><br>  Semua orang pandai foto kita, tapi itu tidak cukup pencahayaan.  Sepanjang sisa artikel, kami hanya akan membicarakan hal ini.  Tambahkan beberapa sumber cahaya titik: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br>  Mempertimbangkan pencahayaan yang sebenarnya adalah tugas yang sangat, sangat sulit, oleh karena itu, seperti orang lain, kami akan menipu mata dengan menggambar sepenuhnya hasil yang tidak masuk akal, tetapi paling mungkin, masuk akal.  Komentar pertama: mengapa dingin di musim dingin dan panas di musim panas?  Karena memanaskan permukaan bumi tergantung dari sudut datangnya sinar matahari.  Semakin tinggi matahari di atas cakrawala, semakin cerah permukaannya.  Dan sebaliknya, semakin rendah cakrawala, semakin lemah.  Nah, setelah matahari terbenam di cakrawala, foton tidak mencapai kita sama sekali.  Berkenaan dengan bola kami: di sini adalah sinar kami dipancarkan dari kamera (tidak ada hubungannya dengan foton, perhatikan!) Berpotongan dengan bola.  Bagaimana kita memahami bagaimana titik persimpangan menyala?  Anda cukup melihat sudut antara vektor normal pada titik ini dan vektor yang menggambarkan arah cahaya.  Semakin kecil sudutnya, semakin baik permukaannya menyala.  Untuk membuatnya lebih nyaman, Anda cukup mengambil produk skalar antara vektor normal dan vektor pencahayaan.  Saya ingat bahwa produk skalar antara dua vektor a dan b sama dengan produk norma-norma vektor oleh cosinus sudut antara vektor: a * b = | a |  | b |  cos (alpha (a, b)).  Jika kita mengambil vektor satuan panjang, maka produk skalar yang paling sederhana akan memberi kita intensitas pencahayaan permukaan. <br><br>  Jadi, dalam fungsi cast_ray, alih-alih warna konstan, kami akan mengembalikan warna dengan mempertimbangkan sumber cahaya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihat</a> perubahan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi hasil dari program: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1>  Tahap Lima: Permukaan Mengkilap </h1><br>  Trik dengan produk skalar antara vektor normal dan vektor cahaya mendekati pencahayaan dengan baik pada permukaan matte, dalam literatur disebut pencahayaan difus.  Apa yang harus dilakukan jika kita ingin halus dan berkilau?  Saya ingin mendapatkan gambar ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br>  Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">betapa sedikit</a> perubahan yang perlu dilakukan.  Singkatnya, pantulan pada permukaan mengkilap lebih terang, semakin kecil sudut antara arah pandang dan arah cahaya yang <i>dipantulkan</i> .  Nah, sudut-sudutnya, tentu saja, kita akan menghitung melalui produk skalar, persis seperti sebelumnya. <br><br>  Senam dengan permukaan matte dan mengkilap ini dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model Phong</a> .  Wiki ini memiliki deskripsi yang cukup terperinci tentang model pencahayaan ini, ia dapat dibaca dengan baik jika dibandingkan secara paralel dengan kode saya.  Berikut ini adalah gambar utama untuk dipahami: <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1>  Tahap Enam: Bayangan </h1><br>  Mengapa kita memiliki cahaya, tetapi tidak ada bayangan?  Kekacauan!  Saya ingin gambar ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hanya enam baris kode yang</a> memungkinkan kita mencapai hal ini: ketika menggambar setiap titik, kita hanya memastikan bahwa sumber titik cahaya tidak memotong objek pemandangan kita, dan jika ya, maka sumber cahaya saat ini melompati.  Hanya ada sedikit kehalusan: Saya menggeser titik sedikit ke arah yang normal: <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br>  Mengapa  Ya, hanya saja titik kami terletak di permukaan objek, dan (tidak termasuk masalah kesalahan numerik), sinar apa pun dari titik ini akan melewati tempat kami. <br><br><h1>  Langkah Tujuh: Refleksi </h1><br>  Ini sulit dipercaya, tetapi untuk menambahkan refleksi ke adegan kami, kami hanya perlu menambahkan tiga baris kode: <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihat sendiri:</a> di persimpangan dengan objek, kita cukup menghitung sinar yang dipantulkan (fungsi dari perhitungan benjolan sangat berguna!) Dan secara rekursif memanggil fungsi cast_ray ke arah sinar yang dipantulkan.  Pastikan untuk bermain dengan <a href="">kedalaman rekursi</a> , saya mengaturnya menjadi empat, mulai dari awal, apa yang akan berubah pada gambar?  Inilah hasil saya dengan refleksi yang bekerja dan kedalaman empat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1>  Tahap Delapan: Refraksi </h1><br>  Dengan belajar menghitung refleksi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">refraksi dihitung sama persis</a> .  Satu fungsi yang memungkinkan Anda menghitung arah sinar yang dibiaskan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sesuai dengan hukum Snell</a> ), dan tiga baris kode di cast_ray fungsi rekursif kami.  Inilah hasilnya, di mana bola terdekat menjadi "kaca", itu membias dan sedikit mencerminkan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1>  Tahap sembilan: tambahkan lebih banyak objek </h1><br>  Mengapa kita semua tanpa susu, tetapi tanpa susu.  Hingga saat ini, kami hanya membuat bidang, karena ini adalah salah satu objek matematika non-sepele yang paling sederhana.  Dan mari kita tambahkan sepotong pesawat.  Klasik genre adalah papan catur.  Untuk ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selusin garis</a> dalam fungsi yang menganggap persimpangan balok dengan pemandangan cukup bagi kita. <br><br>  Nah, inilah hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br>  Seperti yang saya janjikan, persis 256 baris kode, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hitung sendiri</a> ! <br><br><h1>  Tahap Sepuluh: Pekerjaan Rumah </h1><br>  Kami menempuh jalan yang agak jauh: kami belajar cara menambahkan objek ke pemandangan, untuk mempertimbangkan pencahayaan yang agak rumit.  Biarkan saya meninggalkan dua tugas sebagai pekerjaan rumah.  Tentu saja semua pekerjaan persiapan telah dilakukan di cabang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">homework_assignment</a> .  Setiap pekerjaan akan membutuhkan maksimal sepuluh baris kode. <br><br><h3>  Tugas satu: Peta lingkungan </h3><br>  Saat ini, jika sinar tidak melewati tempat kejadian, maka kita cukup mengaturnya ke warna konstan.  Dan mengapa, pada kenyataannya, permanen?  Mari kita mengambil foto bulat (file <a href="">envmap.jpg</a> ) dan menggunakannya sebagai latar belakang!  Untuk membuat hidup lebih mudah, saya menautkan proyek kami dengan perpustakaan stb untuk kenyamanan bekerja dengan jpegs.  Ini harus menjadi render seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3>  Tugas kedua: dukun! </h3><br>  Kita dapat membuat bidang dan pesawat (lihat papan catur).  Jadi mari kita tambahkan gambar model triangulasi!  Saya menulis kode untuk membaca kisi-kisi segitiga, dan menambahkan fungsi persimpangan ray-triangle di sana.  Sekarang menambahkan bebek ke adegan kita harus benar-benar sepele! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1>  Kesimpulan </h1><br>  Tugas utama saya adalah menunjukkan proyek yang menarik (dan mudah!) Untuk diprogram, saya sangat berharap bisa melakukannya.  Ini sangat penting, karena saya yakin bahwa seorang programmer harus menulis banyak dan dengan selera.  Saya tidak tahu tentang Anda, tetapi akuntansi pribadi dan pencari ranjau, dengan kompleksitas kode yang cukup sebanding, tidak menarik saya sama sekali. <br><br>  Dua ratus lima puluh baris raytracing sebenarnya dapat ditulis dalam beberapa jam.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lima ratus baris</a> rasterizer perangkat lunak dapat dikuasai dalam beberapa hari.  Lain kali kita akan memilah-milah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rakecasting</a> , dan pada saat yang sama saya akan menunjukkan permainan paling sederhana yang ditulis siswa tahun pertama saya sebagai bagian dari pengajaran pemrograman C ++.  Tetap disini! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436790/">https://habr.com/ru/post/id436790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436776/index.html">Dari zona nyaman hingga pengembang teratas</a></li>
<li><a href="../id436778/index.html">defi.js adalah pustaka reaktif berdasarkan Object.defineProperty</a></li>
<li><a href="../id436780/index.html">Jebakan Pengembangan Instan Google Play</a></li>
<li><a href="../id436786/index.html">Bagaimana kami memantau Black Hat Europe 2018</a></li>
<li><a href="../id436788/index.html">Menyebarkan Office 2019 di lingkungan perusahaan (untuk profesional TI)</a></li>
<li><a href="../id436794/index.html">Konferensi DEFCON 19. Anonim dan kami. Bagian 2</a></li>
<li><a href="../id436798/index.html">Deformasi admin profesional</a></li>
<li><a href="../id436800/index.html">Teknik proyek DIY. Bagian dua</a></li>
<li><a href="../id436822/index.html">Android Robotics hingga 2019: Kisah nyata; dalam 5 bagian; bagian 3</a></li>
<li><a href="../id436828/index.html">Transisi ke Boost-1.65.1 dan bug yang muncul</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>