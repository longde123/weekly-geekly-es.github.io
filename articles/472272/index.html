<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∫ üéë üôÜüèæ Un nuevo juego con un ambiente antiguo en Three.js. Parte 2 üë©üèø‚ÄçüöÄ üöó üì°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte, habl√© sobre los problemas que encontr√© en el proceso de creaci√≥n de un juego 3D para el navegador usando Three.js. Ahora me gusta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un nuevo juego con un ambiente antiguo en Three.js. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472272/"> En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera</a> parte, habl√© sobre los problemas que encontr√© en el proceso de creaci√≥n de un juego 3D para el navegador usando Three.js.  Ahora me gustar√≠a detenerme en detalles para resolver algunos problemas importantes al escribir un juego, como construir niveles, detectar colisiones y adaptar la imagen a cualquier proporci√≥n de la ventana del navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/jr/45/dsjr45-khpwum64yaoqvndmfynw.jpeg"></div><br><h3>  Diagramas de nivel </h3><br>  En realidad, los niveles mismos se crean en el editor 3D, es decir, su geometr√≠a, mapeo de texturas, horneado de sombras, etc.  Describ√≠ todo esto en la primera parte.  ¬øPor qu√© hay otros esquemas?  El hecho es que Three.js no ofrece ning√∫n tipo de motor f√≠sico, y uso esquemas de nivel para identificar obst√°culos. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/7u/j6/pk7uj6hvp3cyrkehdo_ohagtfnc.jpeg"></div><br>  Three.js para resolver el problema de colisi√≥n solo ofrece trazado de rayos, la forma m√°s sencilla de determinar la intersecci√≥n de la geometr√≠a de los objetos.  En principio, se puede usar, e incluso lo hice en uno de mis otros proyectos.  Era una ciudad virtual justo en el sitio, en el navegador.  Puedes moverte por la ciudad y no atravesar las paredes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/8y/4s/ud8y4smxvagibioopva3vc1ajoc.jpeg"></div><br>  En el caso de que la intersecci√≥n de la geometr√≠a del jugador y el edificio ocurra durante el movimiento, implement√© la repulsi√≥n del jugador por una cierta distancia en la direcci√≥n opuesta a la pared.  Pero para esto, los objetos deben ser paralelep√≠pedos.  Alrededor de algunos objetos complejos, cre√© colisionadores (llamaremos a los objetos invisibles que juegan el papel de obst√°culos y evitan que el jugador pase a trav√©s de ellos), a trav√©s del cual se resolvieron las intersecciones.  Y las partes inferiores de algunos edificios, que son simplemente "cajas", a veces se usaban como colisionadores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/on/3e/fzon3eg8bjup0zvzs_cgg81lrmo.jpeg"></div><br>  En objetos geom√©tricamente complejos, el trazado de rayos puede no funcionar o comportarse de manera inapropiada.  Y, como soluci√≥n, puede incrustar en el objeto no uno, sino varios peque√±os colisionadores invisibles en forma de paralelep√≠pedos con 100% de transparencia, dibujados uno al lado del otro y uno encima del otro, repitiendo aproximadamente la forma del objeto. <br><br>  En el juego sobre mazmorras, el nivel es un solo objeto largo con movimientos de corte para mover al jugador.  En realidad, para resolver el problema de colisi√≥n, uno podr√≠a pegar colisionadores invisibles donde sea necesario y usar trazado de rayos.  Sin embargo, decid√≠ ir por el otro lado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ul/ln/rzullnsn4a_befsw71uctfqjyzg.jpeg"></div><br><ul><li>  En primer lugar, quer√≠a automatizar el proceso de creaci√≥n de una serie de colisionadores. </li><li>  En segundo lugar, puede usar solo informaci√≥n sobre los colisionadores, es decir, sus coordenadas en el espacio, y no cargar la escena 3D con algunos objetos vac√≠os adicionales. </li><li>  En tercer lugar, dado que el juego usa solo una vista lateral y una de las coordenadas nunca cambia cuando se mueve, puede usar el c√°lculo de intersecciones en solo dos coordenadas. </li><li>  Y cuarto, despu√©s de todo, de hecho, habr√° un esquema de nivel.  Adem√°s, crear nuevos niveles es conveniente comenzar con un esquema de este tipo.  Simplemente puede arrastrar bloques alrededor de la pantalla en cualquier editor de gr√°ficos, construir nuevos corredores y obst√°culos, y luego ejecutar el script y obtener informaci√≥n sobre los colisionadores.  Es decir, el problema del editor de niveles est√° parcialmente resuelto. </li></ul><br>  Escrib√≠ un script que toma par√°metros de entrada como el nombre del archivo de esquema de nivel (png) y el color, cuyo relleno se interpreta como un obst√°culo.  El color predeterminado del espacio libre es el negro.  Para el procesamiento por el script, el esquema de cada nivel debe guardarse en un archivo png separado.  Por ejemplo, para el nivel m√°s bajo, se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/rg/kw/bargkw-qc8xqbvpszjia3zvnllq.jpeg"></div><br>  Estuve de acuerdo en que un bloque debe tener 80 p√≠xeles de ancho y 48 p√≠xeles de alto.  Esto corresponde a 4 x 2.4 metros en el mundo 3D.  Ser√≠a posible hacer 40 x 24 p√≠xeles, es decir, diez veces, pero en la imagen parece peque√±o. <br><br>  El resultado del script en el primer nivel (la imagen se recorta a la derecha): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xx/zu/9f/xxzu9fsntacg-giuqubbj75iq5k.jpeg"></div><br>  El script se ejecuta en el navegador.  Creo que no tiene sentido el marcado html, es elemental: campos de entrada de datos y un bot√≥n de inicio.  A continuaci√≥n, la imagen le√≠da se muestra en el lienzo.  Y como resultado del script, se muestra una matriz debajo de la imagen en la escala mundial 3D, que contiene las coordenadas inferior izquierda y superior derecha de cada bloque, y con el desplazamiento especificado en el script para cada nivel.  Este conjunto se puede copiar y pegar en la lista de colisionadores para usar en el juego (m√°s sobre eso a continuaci√≥n), se almacenar√° en alg√∫n tipo de constante.  Las coordenadas tambi√©n aparecen en la imagen en s√≠, pero en el marco de referencia de la imagen 2D.  Estos n√∫meros se muestran en el centro de cada bloque y le permiten verificar si todos los bloques est√°n incluidos en el c√°lculo.  Por s√≠ mismos, estos n√∫meros no son necesarios para nada excepto para la inspecci√≥n visual.  Algunos bloques, como las columnas entre las que pasa el jugador, no deben contarse.  Acerca de qu√© objetos se excluyen del c√°lculo, a continuaci√≥n. <br><br>  Adem√°s, por ejemplo, en el segundo nivel hay delgadas placas horizontales sobre las que camina el jugador.  Deben ser considerados.  En consecuencia, debe asegurarse de que los n√∫meros tambi√©n aparezcan en ellos.  En el diagrama, haga que tengan 2 p√≠xeles de altura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/vm/w1/pqvmw1tghz4brz--t0qh6y-bzek.jpeg"></div><br><br>  Ahora, sobre c√≥mo el script toma en cuenta los bloques: <br><br><ul><li>  El esquema se procesa mediante bloques de 80x48, en cada uno de los cuales se toma un √°rea desde el segundo al 79¬∫ p√≠xeles horizontalmente y desde el segundo al 47¬∫ p√≠xeles verticalmente.  El primer y el √∫ltimo p√≠xel no se utilizan para que alrededor de los bloques pueda crear un marco negro con un ancho de 1 p√≠xel, esto mejora la percepci√≥n visual del circuito y facilita su creaci√≥n. </li><li>  Se ven todos los p√≠xeles de la fila superior del bloque.  Si hay colores entre ellos, entonces las coordenadas del bloque van del primer al √∫ltimo p√≠xel coloreado horizontalmente y a la altura total del bloque verticalmente en la matriz final.  Este ser√° un bloque en blanco de ancho total o parcial. </li><li>  Se ven todos los p√≠xeles de la l√≠nea inferior del bloque.  Si hay colores entre ellos, pero no hay ninguno en la fila superior, entonces las coordenadas del bloque van del primer al √∫ltimo p√≠xel coloreado horizontalmente y 3 p√≠xeles verticalmente desde la parte inferior a la matriz final.  Esta ser√° una plataforma sobre la cual caminar.  Dentro de un bloque puede haber varias plataformas horizontales.  Las plataformas se reconocen solo en la parte inferior del bloque.  Las coordenadas de la plataforma est√°n "hundidas" en un bloque, que se encuentra debajo, de modo que la superficie de la plataforma est√° al mismo nivel que los bloques vecinos, no las plataformas. </li><li>  Las columnas y otras decoraciones dentro de un bloque vac√≠o no se procesan, ya que solo se consideran las filas superior e inferior de p√≠xeles.  Por lo tanto, dentro del bloque, puede colocar decoraci√≥n, explicaciones para el diagrama, punteros, columnas, etc., sin temor a que esto afecte de alguna manera el resultado del gui√≥n. </li></ul><br>  Luego, todas las coordenadas recibidas de la matriz se traducen a la escala del mundo 3D, multiplicadas por el coeficiente de su escala (que se seleccion√≥ en el editor 3D cuando se cre√≥).  La matriz est√° lista para usar en el juego.  El c√≥digo del script se escribi√≥ a toda prisa, por lo que no pretende ser elegante, pero realiza su tarea. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre><code class="javascript hljs">ap = { <span class="hljs-comment"><span class="hljs-comment">//      (  ),   3D   lvd: { 'lv01.png': { invw: false, invh: true, level_dw: -8.5, level_dh: -1.5 }, 'lv02.png': { invw: true, invh: true, level_dw: -19.5, level_dh: -5.5 } }, blockw: 80, //   2D blockh: 48, //   2D sc3d: 0.05, //,   3D  ex: 100, //  3D (-   ) v: { data: [] }, i: 0, par: {}, datai: [], resi: [], ars: [], fStopEncode: false, blockColor: function(cl) { document.getElementById('input_cl').value = cl; }, startEncode: function() { //      for (var key in ap.lvd) { ap.lvd[key].dw = ap.lvd[key].level_dw * ap.blockw; ap.lvd[key].dh = ap.lvd[key].level_dh * ap.blockh; }; document.getElementById('startbtn').style.display = 'none'; document.getElementById('startmsg').style.display = 'block'; var cl = document.getElementById('input_cl').value; var fld = document.getElementById('input_fld').value; var nm = document.getElementById('input_nm').value; ap.nm = nm; ap.par = { path: [fld + '/', nm], key: [nm], cl: aplib.hexToRgb(cl.substring(1, 7)) }; setTimeout(function() { ap.datai[ap.par.key] = new Image(); ap.datai[ap.par.key].onload = function() { ap.parseData(); }; ap.datai[ap.par.key].src = ap.par.path[0] + ap.par.path[1]; }, 500); }, stopEnode: function(e) { if (typeof ap !== "undefined") { if (e.keyCode == 27) { console.log('stop'); ap.fStopEncode = true; }; }; }, parseData: function() { ap.w = ap.datai[ap.par.key[0]].width, ap.h = ap.datai[ap.par.key[0]].height; aplib.initCanv(ap.w, ap.h); ctx.drawImage(ap.datai[ap.par.key[0]], 0, 0, ap.w, ap.h, 0, 0, ap.w, ap.h); ap.ars = []; ap.i = 0; setTimeout(function() { ap.parseData1(); }, 1000); }, parseData1: function() { if (ap.i &lt; ap.par.key.length) { document.getElementById('info').innerHTML = '' + ap.nm; ap.blocksw = Math.floor(ap.w / ap.blockw); ap.blocksh = Math.floor(ap.h / ap.blockh); ap.ar = []; ap.arv = {}; ap.hi = 0; ctx.fillStyle = '#CCCCCC'; ap.parseData2(); } else { document.getElementById('startbtn').style.display = 'block'; document.getElementById('startmsg').style.display = 'none'; }; }, parseData2: function() { if (ap.hi &lt; ap.blocksh) { ap.ar.push([]); ap.wi = 0; ap.parseData3(); } else { ap.parseData4(); }; }, parseData3: function() { var k = ''; if (ap.wi &lt; ap.blocksw) { var fground = true, fvari = false, fempty = true; var upx1 = 0, upx2 = 0, dnx1 = 0, dnx2 = 0; var upxf = false, dnxf = false; for (var wii = 1; wii &lt; ap.blockw - 2 + 2; wii++) { pixelDatai = ctx.getImageData(ap.wi * ap.blockw + wii, ap.hi * ap.blockh + 1, 1, 1).data; //  pixelDatai2 = ctx.getImageData(ap.wi * ap.blockw + wii, (ap.hi + 1) * ap.blockh - 3, 1, 1).data; //  if ((pixelDatai[0] == ap.par.cl.r) &amp; (pixelDatai[1] == ap.par.cl.g) &amp; (pixelDatai[2] == ap.par.cl.b)) { //   ground    if (upxf == false) { upxf = true; upx1 = wii; }; } else { //    if (upxf == true) { upx2 = wii + 1; upx1--; //   dy = -1; // 3D       1 ap.v.data.push([ap.wi * ap.blockw + upx1, ap.hi * ap.blockh + dy, ap.wi * ap.blockw + upx2, ap.hi * (ap.blockh) + ap.blockh - 1]); upxf = false; upx1 = 0; upx2 = 0; }; }; if ((pixelDatai2[0] == ap.par.cl.r) &amp; (pixelDatai2[1] == ap.par.cl.g) &amp; (pixelDatai2[2] == ap.par.cl.b)) { //   ground     if (upxf == false) { if (dnxf == false) { dnxf = true dnx1 = wii; }; }; } else { if (upxf == false) { if (dnxf == true) { dnx2 = wii + 1; dnx1--; //   dy = 2; // 3D    2 ap.v.data.push([ap.wi * ap.blockw + dnx1, (ap.hi + 1) * ap.blockh - 3 + dy, ap.wi * ap.blockw + dnx2, (ap.hi + 1) * ap.blockh - 3 + 2 + dy]); dnxf = false; dnx1 = 0; dnx2 = 0; }; }; }; }; if (ap.fStopEncode == true) { ap.hi = ap.h, ap.wi = ap.w, i = ap.par.key.length; }; setTimeout(function() { ap.wi++; ap.parseData3(); }, 10); } else { ap.hi++; ap.parseData2(); }; }, parseData4: function() { setTimeout(function() { var t, tw, tx, ty, ar = []; //  for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; t = ar[0] + ';' + (ar[1]+1) + '&lt;br/&gt;' + ar[2] + ';' + (ar[3]+1); tw = ar[2] - ar[0]; tx = ar[0]; ty = ar[1] + Math.floor((ar[3] - ar[1]) / 2) - 0; aplib.Tex2Canvas(ctx, t, 'normal 10px Arial', 10, '#CCCCCC', tx, ty, tw, 0, 'center', 'top'); }; ap.parseData5(); }, 10); }, parseData5: function() { var t, tw, tx, ty, ar = [], n; //   3D var lv = ap.lvd[ap.nm]; for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; ar[0] += lv.dw; ar[1] += lv.dh; ar[2] += lv.dw; ar[3] += lv.dh; if (lv.invh == true) { n = -ar[1]; ar[1] = -ar[3]; ar[3] = n; }; if (lv.invw == true) { n = -ar[0] ar[0] = -ar[2]; ar[2] = n; }; ar[0] = Math.round(ap.sc3d * ar[0] * ap.ex) / ap.ex; ar[1] = Math.round(ap.sc3d * ar[1] * ap.ex) / ap.ex; ar[2] = Math.round(ap.sc3d * ar[2] * ap.ex) / ap.ex; ar[3] = Math.round(ap.sc3d * ar[3] * ap.ex) / ap.ex; }; //    ap.v.data.sort(aplib.sortBy0); console.log(ap.v.data); document.getElementById('divresult').innerHTML = JSON.stringify(ap.v.data); } }; aplib = { hexToRgb: function(hex) { var arrBuff = new ArrayBuffer(4); var vw = new DataView(arrBuff); vw.setUint32(0, parseInt(hex, 16), false); var arrByte = new Uint8Array(arrBuff); return { r: arrByte[1], g: arrByte[2], b: arrByte[3], s: arrByte[1] + "," + arrByte[2] + "," + arrByte[3] }; }, //   canvas Tex2Canvas: function(ctx, t, font, lin, fcolor, x, y, w, h, haln, valn) { //left, right, center, center-lim- ctx.font = font; ctx.fillStyle = fcolor; var l = 0; var tx = x; var ftw = false; var tw = 1; var arr = t.split('&lt;br/&gt;'); for (var i = 0; i &lt; arr.length; i++) { arr[i] = arr[i].split(' '); }; for (var i = 0; i &lt; arr.length; i++) { var s = '', slen = 0, s1 = '', j = 0; while (j &lt; arr[i].length) { var wordcount = 0; while ((slen &lt; w) &amp; (j &lt; arr[i].length)) { s = s1; s1 = s + arr[i][j] + ' '; slen = ctx.measureText(s1).width; if (slen &lt; w) { j++; wordcount++; } else { if (wordcount &gt; 0) { s1 = s; } else { j++; }; }; }; ftw = false; tw = ctx.measureText(s1).width; if (haln == 'center') { tx = x + Math.round((w - tw) / 2); }; if (haln == 'right') { tx = x + Math.round((w - tw)); }; if (haln == 'center-lim') { if (tw &gt; w) { tw = w; }; if (tw &lt; 1) { tw = 1; }; tx = x + Math.round((w - tw) / 2); ftw = true; }; if (ftw == false) { ctx.fillText(s1, tx, l * lin + y); } else { ctx.fillText(s1, tx, l * lin + y, tw); }; if (s1 == '') { j = arr[i].length + 1; }; l++; s1 = ''; slen = 0; }; }; return Math.round(tw); }, // canvas initCanv: function(w, h) { function canvErr() { document.getElementById('divcanv').innerHTML = '&lt;div style="height:130px"&gt;&lt;/div&gt;&lt;div style="width:440px; border:#FFFFFF 1px solid; margin:10px; padding:4px; background-color:#000000"&gt;&lt;p class="txterr"&gt;---&gt; Error&lt;br/&gt;HTML5 Canvas is not supported!&lt;br/&gt;Please, update your browser!&lt;/p&gt;&lt;/div&gt;'; }; if (w == 0) { w = 740; h = 680; }; elcanv = document.getElementById('divcanv'); elcanv.innerHTML = '&lt;canvas id="canv" style="width:' + w + 'px; height:' + h + 'px; display:block;" width="' + w + '" height="' + h + '"&gt;&lt;/canvas&gt;'; canvas1 = document.getElementById('canv'); if (!canvas1) { canvErr(); return 0; } else { if (canvas1.getContext) { ctx = canvas1.getContext('2d'); ctx.clearRect(0, 0, w, h); return 1; } else { canvErr(); }; }; }, sortBy0: function(i, ii) { if (i[0] &gt; ii[0]) return 1; else if (i[0] &lt; ii[0]) return -1; else return 0; } };</span></span></code> </pre> <br></div></div><br>  Ahora, sobre c√≥mo funciona el juego con una variedad de bloques.  El juego utiliza pasillos (niveles) que se cruzan.  Cuando un jugador se convierte en un corredor, se conecta una nueva matriz de bloques: y para cada corredor, en consecuencia, se obtiene su propia matriz, obtenida de su esquema de nivel.  Durante el movimiento del jugador, se verifica que sus coordenadas est√©n dentro de cada bloque.  Y si √©l est√° dentro de cualquier bloque, entonces tenemos una colisi√≥n.  Pero con cada movimiento del jugador no necesitamos buscar intersecciones con todos los bloques del nivel, porque puede haber muchos de ellos.  Crea una matriz de solo los bloques m√°s cercanos al jugador. <br><br><pre> <code class="javascript hljs">collisionsUpdate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, dw, dh</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coll = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ap.v.lv.d.length; i++) { o = ap.v.lv.d[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= x - ap.v.dw) &amp; (o[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= x + ap.v.dw)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;= y - ap.v.dh) &amp; (o[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= y + ap.v.dh)) { coll.push(o); }; }; }; ap.v.coll = coll; },</code> </pre> <br>  Aqu√≠, en la entrada x, y son las coordenadas actuales del jugador, dw, dh es la distancia a la que desea buscar bloques horizontal y verticalmente, por ejemplo, 12 y 8 metros.  En otras palabras, toma todos los bloques alrededor del jugador en un cuadrado de 24x16 metros.  Participar√°n en la b√∫squeda de enfrentamientos.  ap.v.lv.d [i] es un elemento de una matriz de bloques del nivel actual, de hecho, √©l mismo tambi√©n es una matriz de 4 n√∫meros que definen los l√≠mites de un bloque - [x1, y1, x2, y2], por lo tanto, para verificar el cuadrado horizontalmente tomamos elementos con √≠ndices 0 y 2, y verticalmente - 1 y 3. Si hay una coincidencia, agregue este bloque a la lista para colisiones ap.v.coll. <br><br>  Cuando el jugador se mueve, actualizaremos esta lista de colisiones, pero, para ahorrar rendimiento, no lo haremos en cada paso (o m√°s bien, renderizando el marco), sino cuando el jugador deja un cierto cuadrado, un poco m√°s peque√±o, especificado en ap.v.collwStep y ap.v.collhStep, por ejemplo, 8 y 4 metros.  Es decir, volveremos a montar la matriz de colisi√≥n nuevamente cuando el jugador pase un cierto camino horizontal o verticalmente desde su posici√≥n original.  Al mismo tiempo, recordemos su posici√≥n en la que volvimos a ensamblar la matriz para usarla en la pr√≥xima iteraci√≥n.  pers [ax] - aqu√≠ por ax nos referimos al eje de coordenadas (ax), puede ser x o z, dependiendo de la direcci√≥n del corredor a lo largo del cual camina el jugador. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if ((Math.abs(pers[ax] - ap.v.collw) &gt; ap.v.collwStep) || (Math.abs(pers.y - ap.v.collh) &gt; ap.v.collhStep)) { ap.v.collw = pers[ax]; ap.v.collh = pers.y; ap.collisionsUpdate(pers[ax], pers.y, 12, 8); };</span></span></code> </pre> <br>  ¬øPor qu√© tantas dificultades?  ¬øPor qu√© no utilizar todo el conjunto de colisiones a nivel y no tomar un ba√±o de vapor?  El hecho es que la detecci√≥n de colisi√≥n se lleva a cabo de acuerdo con un algoritmo mucho m√°s complejo, y no es rentable verificar la colisi√≥n con absolutamente todos los bloques de nivel, y no los m√°s cercanos, en cada renderizado de cuadros.  (Aunque esto no es exacto). <br><br>  La definici√≥n de colisiones en cada representaci√≥n de un cuadro utilizando la matriz de colisi√≥n preparada anteriormente: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs">collisionsDetect: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, xOld, yOld, up</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//up=-1 -  var res = false, o; var collw = false, collh = false, collwi = false, collhi = false, collhsup = false, support = [], supportf = false, fw = false, upb = -1; var bub = -1, bubw = 0; var pw2 = ap.v.player.pw2, ph2 = ap.v.player.ph2, supportd = ap.v.supportd; for (var i = 0; i &lt; ap.v.coll.length; i++) { o = ap.v.coll[i]; collwi = false; collhi = false; collhsup = false; fw = false; if ((x + pw2 &gt;= o[0]) &amp; (x - pw2 &lt;= o[2])) { if ((y + ph2 &gt; o[1]) &amp; (y - ph2 &lt; o[3])) { collwi = true; }; }; //     if ((xOld + pw2 &gt;= o[0]) &amp; (xOld - pw2 &lt;= o[2])) { if ((yOld + ph2 &gt; o[1]) &amp; (yOld - ph2 &lt; o[3])) { bub = i; if (Math.abs(xOld - o[0]) &lt; Math.abs(xOld - o[2])) { bubw = -1; } else { bubw = 1; }; }; }; if ((x &gt;= o[0]) &amp; (x &lt;= o[2])) { fw = true; //  i   }; if ((y + ph2 &gt;= o[1]) &amp; (y - ph2 &lt;= o[3])) { if ((x &gt; o[0]) &amp; (x &lt; o[2])) { collhi = true; //  if (y + ph2 &gt; o[3]) { collhsup = true; supportf = true; support = o; upb = 1; }; //  if (y - ph2 &lt; o[1]) { upb = -1; }; }; }; if ((y - ph2 &gt;= o[3] + supportd - 0.11) &amp; (y - ph2 &lt;= o[3] + supportd + 0.001)) { if (fw == true) { collhi = true; collh = true; res = true; collhsup = true; supportf = true; support = o; }; }; if (collwi &amp; collhi) { res = true; }; if (collwi) { collw = true; }; if (collhi) { collh = true; }; }; return { f: res, w: collw, h: collh, support: support, supportf: supportf, upb: upb, bub: bub, bubw: bubw }; },</span></span></code> </pre> <br></div></div><br>  Aqu√≠ x, y, xOld, yOld son las coordenadas nuevas y actuales del jugador.  Los nuevos se calculan con solo tocar un bot√≥n, en funci√≥n de una velocidad de movimiento dada, es decir, estas son coordenadas posibles.  Se verifican para ver si caen dentro de cualquier bloque de la lista de colisiones.  Si se caen, vuelven a los viejos y el jugador no pasa el obst√°culo.  Y si no caen, se vuelven actuales.  pw2 y ph2 son la mitad del ancho y la altura del colisionador imaginario del jugador (ancho del jugador / 2, altura del jugador / 2).  La salida se emite si hay una colisi√≥n horizontal y vertical (collw, collh), si hay un bloque de soporte debajo del jugador (supportf); esto deja en claro si comenzar m√°s la animaci√≥n de ca√≠da o si el jugador simplemente cambi√≥ a un bloque vecino, y as√≠ sucesivamente.  Simplemente no pregunte por qu√© agregu√© 0.001 all√≠ y rest√© 0.11.  Esta es una muleta terrible que evita la ca√≠da a trav√©s de los bloques y el efecto de la fluctuaci√≥n cuando choca con un obst√°culo horizontal ... Esta funci√≥n funciona, pero debe reescribirse de la manera normal.  La optimizaci√≥n de esta funci√≥n tambi√©n falta todav√≠a. <br><br>  Creo que con las colisiones vale la pena terminar aqu√≠. <br><br>  Es dif√≠cil decir qu√© tan r√°pido es mi m√©todo o quiz√°s m√°s lento que el trazado de rayos, pero en el caso de este √∫ltimo, Three.js tambi√©n almacena una variedad de objetos que participan en el sistema de colisi√≥n.  Es solo que las colisiones est√°n determinadas por el m√©todo de emisi√≥n del haz y su intersecci√≥n con los planos de los lados de los objetos, y conmigo, determinando si las coordenadas de un objeto est√°n dentro del otro a lo largo de cada uno de los dos ejes. <br><br>  El juego tambi√©n tiene objetos en movimiento (tibur√≥n) y objetos marcadores que desencadenan alg√∫n tipo de animaci√≥n (por ejemplo, el contacto con el agua desencadena el movimiento de un tibur√≥n).  Todos estos objetos tambi√©n participan en colisiones, y algunos con coordenadas que var√≠an en el tiempo.  All√≠, por extra√±o que parezca, todo es m√°s simple: durante el movimiento del objeto, sus coordenadas se comparan con las coordenadas del jugador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/cx/rz/mjcxrz4m_3fwkm7kep-yrtbp-qa.jpeg"></div><br><h3>  Gamepad </h3><br>  En general, mantener un gamepad javascript en un navegador no es una tarea trivial.  No hay eventos de presionar y soltar botones.  Solo hay eventos que conectan y desconectan el dispositivo y el estado que puede obtenerse mediante un sondeo peri√≥dico y luego compararlo con el anterior. <br><br>  Un video que muestra el funcionamiento del gamepad en un navegador en una tableta en Windows 8.1 y una PC en Windows 10. Sin embargo, la tableta es antigua, lanzada en 2014, por lo que la iluminaci√≥n din√°mica est√° apagada en el juego. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/knkMKB5uizk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Para sondear el gamepad, se usa una funci√≥n llamada una vez cada 100 milisegundos.  Se configura con la funci√≥n de mi biblioteca m3d.lib.globalTimer.addEvent. <br><br><pre> <code class="javascript hljs">m3d.lib.globalTimer.addEvent({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gamepad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ti</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> st = m3d.gamepad.state(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (st == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.gpDownFlag == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { m3d.gamepad.resetH(); }; }; } });</code> </pre> <br>  Aqu√≠ globalTimer es el sistema de administraci√≥n de eventos de temporizador javascript setInterval que escrib√≠.  All√≠, simplemente se agrega una serie de eventos a una determinada matriz que debe llamarse a diferentes intervalos.  Luego, se establece un temporizador setInterval con la frecuencia correspondiente al evento con la frecuencia m√°s alta de todas.  El temporizador sondea la funci√≥n m3d.lib.globalTimer.update (), que recorre la lista de todos los eventos y ejecuta las funciones de aquellos que han llegado a ejecutarse.  Al agregar o eliminar eventos, la frecuencia del intervalo tambi√©n puede cambiar (por ejemplo, si elimina el evento m√°s r√°pido). <br><br>  El juego tambi√©n establece controladores para cada tecla del gamepad: 'a' es para el eje (ax), 'b' para el bot√≥n (bot√≥n), y 11 es la desviaci√≥n izquierda a lo largo del eje horizontal de la cruz (como si fuera el bot√≥n 1), 12 - la desviaci√≥n derecha a lo largo del eje horizontal de la cruz (como si fuera su bot√≥n 2), 21 y 22 - para el eje vertical.  Por ejemplo: <br><br>  ['a', 11], <br>  ['b', 3] <br><br>  significa que la siguiente funci√≥n se establecer√° al mismo tiempo para la desviaci√≥n a lo largo del eje horizontal hacia la izquierda y para el bot√≥n 3 (izquierda).  Bueno, entonces se establece una funci√≥n que se ejecutar√° cuando se presione el bot√≥n, y luego cuando se suelte. <br><br><pre> <code class="javascript hljs"> m3d.gamepad.setHandler( [ [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>], [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.btState.lt == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { contr.keyDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.gpDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; apcontrolsRenderStart(); }; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m3d.contr.controlsCheckBt(); apcontrolsRenderStart(); } );</code> </pre> <br>  Aqu√≠ apcontrolsRenderStart () es una funci√≥n que inicia un render si a√∫n no se est√° ejecutando.  En general, el soporte para el gamepad est√° estrechamente vinculado a mi biblioteca m3d, por lo que si contin√∫o describiendo todas sus caracter√≠sticas, se extender√° durante mucho tiempo ... <br><br>  Solo te dar√© una parte: gamepad, en el que implement√© la inicializaci√≥n del gamepad, la instalaci√≥n de controladores y el sondeo de estado de la manera m√°s simple. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs">gamepad: { <span class="hljs-attr"><span class="hljs-attr">connected</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">gamepad</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">gamepadKey</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">axesCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttonsCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: [], <span class="hljs-comment"><span class="hljs-comment">//  fup: [], //  fval: [], //      fupCall: [], //   buttons: [], //link to f [0.. ] axes: [], //link to f [0.. ] initCb: function() {}, resetH: function() {}, init: function(gp) { var f = false; for (var key in gp) { if (f == false) { if (gp[key] != null) { if (typeof gp[key].id !== "undefined") { f = true; this.connected = true; this.gamepad = gp[key]; this.gamepadKey = key; }; }; }; }; if (typeof this.gamepad.axes !== "undefined") { this.axesCount = this.gamepad.axes.length; }; if (typeof this.gamepad.buttons !== "undefined") { this.buttonsCount = this.gamepad.buttons.length; }; this.f = []; this.fup = []; this.fval = []; this.fupCall = []; this.axes = []; for (var i = 0; i &lt; this.axesCount * 2; i++) { this.axes.push(-1); }; this.buttons = []; for (var i = 0; i &lt; this.buttonsCount; i++) { this.buttons.push(-1); }; this.initCb(); }, setHandlerReset: function(f) { this.resetH = f; }, setHandler: function(ar, f, fup) { //ar['b',3] ['a',11] var fi, bt, ax, finext, finexta; finexta = false; for (var i = 0; i &lt; ar.length; i++) { if (ar[i][0] == 'a') { ax = Math.floor(ar[i][1] / 10); bt = ar[i][1] - (ax * 10); bt = ax * 2 + bt - 3; fi = this.axes[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.axes[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.axes[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; } else if (ar[i][0] == 'b') { bt = ar[i][1] - 1; fi = this.buttons[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.buttons[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.buttons[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; }; }; }, state: function() { var pressed = false; var fi, fval, axesval; for (var i = 0; i &lt; this.fval.length; i++) { this.fval[i] = 0; }; //   var gp = navigator.getGamepads()[this.gamepadKey]; for (var i = 0; i &lt; this.axesCount; i++) { axesval = Math.round(gp.axes[i]); if (axesval &lt; 0) { pressed = true; fi = this.axes[i * 2]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; } else if (axesval &gt; 0) { pressed = true; fi = this.axes[i * 2 + 1]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.buttonsCount; i++) { if (gp.buttons[i].pressed == true) { pressed = true; fi = this.buttons[i]; if (fi != -1) { this.fval[fi] = 1; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.fval.length; i++) { fval = this.fval[i]; if (fval != 0) { this.f[i](this.fval[i]); } else { if (this.fupCall[i] == true) { this.fupCall[i] = false; this.fup[i](this.fval[i]); }; }; }; return pressed; } }, //gamepad</span></span></code> </pre> <br></div></div><br>  En general, el soporte del gamepad en el juego todav√≠a est√° incompleto: solo se implementa el soporte para el gamepad m√°s simple, pero no el que, por ejemplo, se usa en XBox, porque no lo tengo.  Si lo consigo, lo programar√© y trabajar√© con √©l.  All√≠ ser√° posible ajustar la velocidad del personaje, es decir, ser√° posible moverse a cualquier velocidad en el rango de un paso a otro.  Esto se logra tomando par√°metros fraccionarios de los ejes.  Mi gamepad solo devuelve los enteros -1 y 1. Adem√°s, mi gamepad tiene una cruz repugnante, y cuando se presiona hacia la izquierda o hacia la derecha, se presiona simult√°neamente hacia arriba o hacia abajo.  Por lo tanto, no utilic√© la parte superior e inferior de la cruz y la dupliqu√© con los botones a la derecha del gamepad ... Al lanzar el juego, planeo crear varios perfiles de gamepads.  Adem√°s, en el caso de conectar varios gamepads, solo se utilizar√° este √∫ltimo hasta ahora. <br><br><h3>  Pantalla sensible </h3><br>  El juego est√° dise√±ado para una relaci√≥n de aspecto de 16: 9.  Pero agregu√© un ajuste horizontal autom√°tico de ¬± 10% para que en la ventana expandida del navegador no hubiera tales barras negras a los lados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/bn/a5/eybna55ofeptyziaakgix67heea.jpeg"></div><br>  Y ser√≠a as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vm/0n/aa/vm0naaertcqacqufxjadz-sdfyu.jpeg"></div><br>  En modo de pantalla completa, habr√° 16: 9 reales.  Ser√≠a posible adaptar la imagen en general a cualquier relaci√≥n de aspecto de la ventana del navegador, pero no lo hice, ya que una ventana ancha y baja dar√≠a lugar a un √°ngulo de visi√≥n demasiado grande, lo que no es bueno desde el punto de vista del juego: callejones sin salida distantes, objetos, enemigos ser√°n inmediatamente visibles y todo lo dem√°s que el jugador no necesita ver todav√≠a.  Por lo tanto, me limit√© a ajustar dentro de ¬± 10% de 16: 9.  Sin embargo, para monitores estrechos (4: 3), sin embargo, me di cuenta de la capacidad de cambiar de 16: 9 al modo de adaptaci√≥n de 4: 3 a 16: 9 presionando la tecla Y.  Pero no m√°s amplio, as√≠ que, de nuevo, para no romper el juego.  Es decir, puede jugar en la cl√°sica relaci√≥n de 16: 9, o puede ampliar la imagen a la altura de la ventana recort√°ndola horizontalmente.  Aunque, esto tampoco es muy bueno, por ejemplo, en situaciones de arcade, cuando algo vuela hacia el jugador desde un lado.  Queda poco tiempo para la reacci√≥n.  Pero siempre puede volver r√°pidamente al modo cl√°sico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/bp/ci/rebpciy7i7vmap1bwt_ijmub2fk.jpeg"></div><br>  La adaptaci√≥n de la pantalla, as√≠ como todas las teclas de acceso r√°pido utilizadas en el juego se muestran en el siguiente video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FamXdunFFHY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  En realidad, la relaci√≥n de aspecto se establece en la configuraci√≥n del juego. <br><br><pre> <code class="javascript hljs">aspect1:{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-attr"><span class="hljs-attr">h</span></span>:<span class="hljs-number"><span class="hljs-number">720</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-comment"><span class="hljs-comment">//16x9 +- 10% aspect2:{w:960, h:720, p:34}, //4x3 +- 34%</span></span></code> </pre> <br>  Y en el juego cuando presionas Y, cambia: <br><br><pre> <code class="javascript hljs">contr.btCodesDn[<span class="hljs-number"><span class="hljs-number">89</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//'y' if (m3dcache.setup.aspect.swch == 1) { m3dcache.setup.aspect = m3dcache.setup.aspect2; m3dcache.setup.aspect.swch = 2; } else { m3dcache.setup.aspect = m3dcache.setup.aspect1; m3dcache.setup.aspect.swch = 1; }; m3d.core.onWindowResize(0); m3d.contr.renderAll(); };</span></span></code> </pre> <br>  Mi biblioteca tiene un evento que se cuelga en la ventana de cambio de tama√±o.  Aqu√≠ hay un fragmento de ella: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m3dcache.v.vw = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; m3dcache.v.vh = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; m3dcache.v.vclipw = <span class="hljs-number"><span class="hljs-number">0</span></span>; m3dcache.v.vcliph = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m3dcache.setup.aspect.w == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (m3dcache.setup.aspect.h == <span class="hljs-number"><span class="hljs-number">0</span></span>)) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.setup.aspect.w, m3dcache.setup.aspect.h, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect.p !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o.clipx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ow = ow * (m3dcache.setup.aspect.p / <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ow &gt; m3dcache.v.vw) { ow = m3dcache.v.vw; }; o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ow, oh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); }; }; m3dcache.v.vclipw = o.clipx; m3dcache.v.vcliph = o.clipy; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> margx = o.clipx + <span class="hljs-string"><span class="hljs-string">'px'</span></span>, margy = o.clipy + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginTop = margy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginTop = margy; }; m3dcache.v.vw = ow; m3dcache.v.vh = oh; }; };</code> </pre> <br></div></div><br>  m3d.lib.inBlock tambi√©n es una funci√≥n de mi biblioteca, que inscribe un rect√°ngulo en otro rect√°ngulo con par√°metros tales como centrar, escalar o recortar, y muestra las nuevas dimensiones del rect√°ngulo inscrito, as√≠ como los tama√±os de los campos que se forman en este proceso.  Seg√∫n esta informaci√≥n, se coloca el contenedor div de la ventana.  'renderizador' es un elemento de contexto de bloque de una escena 3D.  Luego, el lienzo se escala all√≠ de acuerdo con los par√°metros obtenidos. <br><br>  La IU se muestra en el contenedor en un elemento de lienzo separado.  En general, el √°rbol de documentos consta de tres bloques DIV transparentes con posicionamiento absoluto (m√°s o menos posible, seg√∫n las necesidades del juego): en la parte inferior est√° el lienzo de la escena 3D, arriba est√° el lienzo para IU y la parte superior se usa para animar elementos de interfaz y otros efectos visuales .  Es decir, la interfaz de usuario no se representa en 3D, sino en su knavass o capa.  La tarea de combinar capas en una sola imagen se deja al navegador.  Para trabajar con la interfaz de usuario, tengo un objeto especial en la biblioteca.  Brevemente, la esencia es la siguiente.  Se cargan las listas de sprites con elementos de IU en formato png con transparencia.  A partir de ah√≠, se toman los elementos necesarios: fondos, botones.  Y se dibujan en el lienzo del medio utilizando la funci√≥n js drawImage (img, ix, iy, iw, ih, x, y, w, h).  Es decir, los fragmentos necesarios de la imagen se muestran en las posiciones necesarias en la pantalla.  Los botones se muestran en la parte superior de los fondos adjuntos: todas sus posiciones y tama√±os se configuran en la configuraci√≥n de la interfaz de usuario.  Al cambiar el tama√±o de una ventana, las posiciones de los elementos en el lienzo de destino (en el que se muestran) se recalculan, dependiendo de si este o ese elemento est√° centrado horizontal y verticalmente o se ajusta a alguna esquina o cara de la pantalla.  Esto crea una interfaz de usuario adaptativa que no depende de la relaci√≥n de aspecto de la pantalla.  Solo es necesario establecer la resoluci√≥n m√≠nima posible horizontal y verticalmente y no caer debajo de ella para que los elementos no se superpongan entre s√≠.  Hablar√© sobre la interfaz de usuario otra vez, porque el art√≠culo result√≥ ser voluminoso, y todav√≠a estoy trabajando en la interfaz de usuario, porque todav√≠a faltan muchas funciones que necesito.  Por ejemplo, en monitores de alta resoluci√≥n, la interfaz se ver√° peque√±a.  Puede multiplicar el tama√±o de los elementos por un cierto coeficiente, dependiendo de la resoluci√≥n de la pantalla.  Por otro lado, ¬øquiz√°s los enormes botones en la pantalla no son necesarios?  Si la resoluci√≥n de la pantalla es enorme, entonces la pantalla en s√≠ es bastante grande. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/id/am/kgidamgcsszbyxejvyyar7bgave.jpeg"></div><br>  Y puede darle una opci√≥n al programador, ya sea escalar la UI din√°micamente con el tama√±o de la ventana o distribuir los elementos en las esquinas.  En el caso del tama√±o din√°mico, tambi√©n hay preguntas propias, por ejemplo, el "jab√≥n" de una interfaz cuando se muestra en una escala demasiado grande.  Si crea sprites de elementos de interfaz en una resoluci√≥n deliberadamente enorme, ocupar√°n mucho espacio y, probablemente, no ser√°n √∫tiles para dispositivos peque√±os; todav√≠a no necesitan sprites grandes, pero consumir√°n memoria. <br><br>  Creo que es suficiente por hoy.  Todav√≠a hay algo en qu√© pensar, c√≥mo implementar esto o aquello.  Mientras tanto, me alejo un poco de la programaci√≥n y hago promociones.  Planeo participar en un par de exhibiciones independientes y participo activamente en la promoci√≥n del juego en las redes sociales, ya que en noviembre planeo ir a la plataforma de crowdfunding: necesitar√© especialistas en el campo de los gr√°ficos 3D y la animaci√≥n esquel√©tica para completar el juego. <br><br>  En los siguientes art√≠culos, hablar√© sobre el control t√°ctil en los navegadores para dispositivos m√≥viles: no todos conectan un gamepad o un teclado a la tableta, sobre la optimizaci√≥n de gr√°ficos 3D para dispositivos de baja potencia y mucho m√°s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472272/">https://habr.com/ru/post/472272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472258/index.html">C√≥mo "aprender a aprender" - mejorar la atenci√≥n plena</a></li>
<li><a href="../472262/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 318 (del 14 al 20 de octubre)</a></li>
<li><a href="../472264/index.html">Arqueolog√≠a digital y realidad virtual o c√≥mo intent√© hacerme amigo de BIM y VR</a></li>
<li><a href="../472268/index.html">Mejora de los controles de Microsoft Edge en Chromium</a></li>
<li><a href="../472270/index.html">"No tienes acceso a la oraci√≥n actual": cuentas de alta tecnolog√≠a del Vaticano fueron pirateadas en 15 minutos</a></li>
<li><a href="../472274/index.html">SSH remoto: consejos y hacks</a></li>
<li><a href="../472278/index.html">Mi git commit favorito</a></li>
<li><a href="../472280/index.html">La tarea de determinar la presencia de una palma en un esc√°ner de venas</a></li>
<li><a href="../472288/index.html">9 extensiones de navegador √∫tiles para desarrolladores (lista para 2020)</a></li>
<li><a href="../472290/index.html">Estructuras vs. Clases</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>