<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèø üë®‚Äçüë©‚Äçüë¶ üßõüèø Le tour du monde en 4 secondes au Columnstore (partie 1) ‚úãüèø üïö üëà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais envisager d'augmenter la vitesse des rapports. Par rapport, j'entends toute requ√™te vers une base de donn√©es qui utilise des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le tour du monde en 4 secondes au Columnstore (partie 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472396/">  Dans cet article, je vais envisager d'augmenter la vitesse des rapports.  Par rapport, j'entends toute requ√™te vers une base de donn√©es qui utilise des fonctions d'agr√©gation.  Je vais √©galement aborder les questions li√©es aux ressources consacr√©es √† la production et au support des rapports, humains et machines. <br><br>  Dans les exemples, j'utiliserai un ensemble de donn√©es contenant 52 608 000 enregistrements. <br><br>  En utilisant l'exemple de r√©serves analytiques pas difficiles, je d√©montrerai que m√™me un ordinateur faible peut √™tre transform√© en un bon outil pour analyser une quantit√© ¬´d√©cente¬ª de donn√©es sans trop d'effort. <br><br>  Apr√®s avoir mis en place des exp√©riences pas compliqu√©es, nous verrons qu'un tableau r√©gulier n'est pas une source appropri√©e pour les requ√™tes analytiques. <br><br>  Si le lecteur peut facilement d√©chiffrer les abr√©viations OLTP et OLAP, il peut √™tre judicieux d'aller directement √† la section <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Columnstore</a> <br><br><h4>  Deux approches pour travailler avec des donn√©es </h4> <br>  Ici, je serai bref, car  Il y a plus qu'assez d'informations sur ce sujet sur Internet. <br><br>  Ainsi, au plus haut niveau, il n'y a que deux approches pour travailler avec des donn√©es: OLTP et OLAP. <br><br>  OLTP - peut √™tre traduit par un traitement de transaction instantan√©.  En fait, nous parlons de traitement en ligne de transactions courtes qui fonctionnent avec une petite quantit√© de donn√©es.  Par exemple, enregistrer, mettre √† jour ou supprimer une commande.  Dans la grande majorit√© des cas, une commande est une quantit√© de donn√©es extr√™mement faible, pendant le traitement de laquelle vous ne pouvez pas avoir peur des longs verrous impos√©s par les SGBDR modernes. <br><br>  OLAP - peut √™tre traduit par le traitement analytique d'un grand nombre de transactions √† la fois.  Tout rapport utilise cette approche particuli√®re, car dans la grande majorit√© des cas, le rapport produit des chiffres r√©sum√©s et agr√©g√©s pour certaines sections. <br><a name="habracut"></a><br>  Chaque approche poss√®de sa propre technologie.  Par exemple, pour OLTP, il s'agit de PostgreSQL et pour OLAP, il s'agit de Microsoft SQL Server Analysis Services.  Alors que PostgresSQL utilise un format bien connu pour stocker des donn√©es dans des tableaux, plusieurs formats diff√©rents ont √©t√© invent√©s pour OLAP.  Ce sont des tables multidimensionnelles, un compartiment rempli de paires cl√©-valeur et mon magasin de colonnes pr√©f√©r√©.  √Ä propos de ce dernier plus en d√©tail ci-dessous. <br><br><h4>  Pourquoi deux approches sont-elles n√©cessaires? </h4><br>  Il a √©t√© not√© que tout entrep√¥t de donn√©es devait t√¥t ou tard faire face √† deux types de charges: la lecture fr√©quente (√©criture et mise √† jour, bien s√ªr aussi) de tr√®s petites quantit√©s de donn√©es et une lecture rare, mais de tr√®s grandes quantit√©s de donn√©es.  En fait, c'est une activit√©, par exemple, du box-office et du chef.  La caisse, qui fonctionne toute la journ√©e, remplit le stockage de petits morceaux de donn√©es, tandis qu'√† la fin de la journ√©e, le volume accumul√©, si l'entreprise se porte bien, atteint une taille impressionnante.  √Ä son tour, le gestionnaire √† la fin de la journ√©e veut savoir combien d'argent le box-office a gagn√© par jour. <br><br>  Donc, dans OLTP, nous avons des tables et des index.  Ces deux outils sont parfaits pour enregistrer l'activit√© au box-office avec tous les d√©tails.  Les index permettent une recherche rapide d'une commande pr√©c√©demment enregistr√©e, il est donc facile de modifier une commande.  Mais afin de satisfaire les besoins du leader, nous devons prendre en compte la quantit√© totale de donn√©es accumul√©es par jour.  De plus, en r√®gle g√©n√©rale, le gestionnaire n'a pas besoin de tous les d√©tails de toutes les commandes.  Ce qu'il a vraiment besoin de savoir, c'est combien d'argent le box-office rapportait en g√©n√©ral.  Peu importe o√π se trouvait la billetterie, quand il y avait une pause d√©jeuner, qui y travaillait, etc.  OLAP existe alors, de sorte que dans un court laps de temps, le syst√®me peut r√©pondre √† la question - combien l'entreprise a gagn√© dans son ensemble sans lecture s√©quentielle de chaque commande et de tous ses d√©tails.  OLAP peut-il utiliser les m√™mes tables et index que OLTP?  La r√©ponse est non, du moins elle ne devrait pas.  Tout d'abord, car OLAP n'a tout simplement pas besoin de tous les d√©tails enregistr√©s dans les tableaux.  Ce probl√®me est r√©solu en stockant des donn√©es dans d'autres formats autres que des tableaux bidimensionnels.  Deuxi√®mement, les informations analys√©es sont souvent dispers√©es sur diff√©rentes tables, ce qui implique leurs multiples associations, y compris les associations de type auto-jointure.  Pour r√©soudre ce probl√®me, ils d√©veloppent en r√®gle g√©n√©rale un sch√©ma de base de donn√©es sp√©cial.  Ce sch√©ma est optimis√© pour la charge OLAP, ainsi que le sch√©ma normalis√© normal pour la charge OLTP. <br><br><h4>  Que se passe-t-il lorsque OLAP utilise un sch√©ma OLTP </h4><br>  En fait, j'ai introduit cette section afin que cet article r√©ponde clairement √† mes propres exigences pour le format de ce mat√©riel, c'est-√†-dire  probl√®me, solution, conclusion. <br><br>  Nous √©num√©rons un certain nombre d'inconv√©nients de l'utilisation de sch√©mas OLTP pour l'analyse des donn√©es. <br><br><ul><li>  Trop d'index. <br><br>  <i>Souvent, vous devez cr√©er des index sp√©ciaux pour prendre en charge les rapports.</i>  <i>Ces index impl√©mentent un sch√©ma de stockage de donn√©es OLAP.</i>  <i>Ils ne sont pas utilis√©s par la partie OLTP de l'application, tout en exer√ßant une charge sur celle-ci, n√©cessitant un support constant et occupant de l'espace disque.</i> </li><li>  La quantit√© de donn√©es lues d√©passe la quantit√© requise. </li><li>  Absence d'un sch√©ma de donn√©es clair. <br><br>  <i>Le fait est que souvent les informations soumises par les rapports sous une forme unique sont r√©parties dans diff√©rents tableaux.</i>  <i>Ces informations n√©cessitent une transformation constante √† la vol√©e.</i>  <i>L'exemple le plus simple est le montant des revenus, qui consiste en esp√®ces et en esp√®ces.</i>  <i>Un autre exemple frappant est la hi√©rarchie des donn√©es.</i>  <i>Parce que</i>  <i>le d√©veloppement d'applications est progressif et on ne sait pas toujours ce qui sera n√©cessaire √† l'avenir, la m√™me hi√©rarchie de sens peut √™tre stock√©e dans diff√©rentes tables.</i>  <i>Et tandis que l'acquisition √† la vol√©e est activement utilis√©e dans OLAP, ce sont des choses l√©g√®rement diff√©rentes.</i> </li><li>  Complexit√© excessive des requ√™tes. <br><br>  <i>Parce que</i>  <i>Un sch√©ma OLTP diff√®re d'un sch√©ma OLAP. Une couche logicielle fortement li√©e est n√©cessaire pour amener le sch√©ma de donn√©es OLTP √† la bonne forme.</i> </li><li>  Complexit√© du support, du d√©bogage et du d√©veloppement. <br><br>  <i>En g√©n√©ral, nous pouvons dire que plus la base de code est complexe, plus il est difficile de la maintenir dans un √©tat sain.</i>  <i>Ceci est un axiome.</i> </li><li>  La complexit√© de la couverture du test. <br><br>  <i>De nombreuses copies sont cass√©es en raison des discussions sur la fa√ßon d'obtenir une base de donn√©es pleine de tous les scripts de test, mais il vaut mieux dire que le fait d'avoir un sch√©ma de donn√©es plus simple que la t√¢che de couvrir avec des tests est simplifi√© plusieurs fois.</i> </li><li>  D√©bogage des performances sans fin. <br><br>  <i>Il y a une forte probabilit√© que l'utilisateur commande un rapport ¬´lourd¬ª pour le serveur de base de donn√©es.</i>  <i>Cette probabilit√© augmente avec le temps.</i>  <i>Il convient de noter que OLAP est √©galement sujet √† ce probl√®me, mais contrairement √† OLTP, la ressource OLAP dans ce domaine est beaucoup plus √©lev√©e.</i> </li></ul><br> <b><a name="cs"></a></b>  <b>Columnstore</b> <br><br>  Cet article se concentrera sur le format de stockage columnstore, mais sans d√©tails de bas niveau.  Les autres formats mentionn√©s ci-dessus m√©ritent √©galement l'attention, mais c'est un sujet pour un autre article. <br><br>  En fait, le format columnstore est connu depuis 30 ans, mais il n'a √©t√© impl√©ment√© dans le SGBDR que r√©cemment.  L'essence de columnstore est que les donn√©es ne sont pas stock√©es dans des lignes, mais dans des colonnes.  C'est-√†-dire  sur une page (tous connus 8 Ko), le serveur enregistre les donn√©es d'un seul champ.  Et donc avec chaque champ de la table √† son tour.  Ceci est n√©cessaire pour que vous n'ayez pas √† lire d'informations suppl√©mentaires.  Imaginons une table avec 10 champs et une requ√™te qui n'a qu'un seul champ sp√©cifi√© dans l'instruction SELECT.  S'il s'agissait d'une table r√©guli√®re enregistr√©e dans un format bas√© sur des lignes, le serveur serait oblig√© de lire les 10 champs, mais n'en retournerait qu'un.  Il s'est av√©r√© que le serveur lisait 9 fois plus d'informations que n√©cessaire.  Columnstore r√©sout compl√®tement ce probl√®me, car  le format de stockage vous permet de lire un seul champ ordonn√©.  Tout cela se produit parce que l'unit√© de stockage dans un SGBDR est une page.  C'est-√†-dire  le serveur √©crit et lit toujours au moins une page.  La seule question est de savoir combien de champs y sont pr√©sents. <br><br><h4>  Comment Columnstore peut vraiment aider </h4><br>  Pour r√©pondre √† cela, il faut avoir des chiffres exacts.  Attrapons-les.  Mais quels chiffres peuvent donner une image pr√©cise? <br><br><ol><li>  La quantit√© d'espace disque. </li><li>  Performances des requ√™tes. </li><li>  Tol√©rance aux pannes. </li><li>  Facilit√© de mise en ≈ìuvre. </li><li>  Quelles nouvelles comp√©tences un d√©veloppeur doit-il avoir pour travailler avec de nouvelles structures. </li></ol><br><h4>  Espace disque </h4><br>  Cr√©ons un tableau simple, remplissons-le de donn√©es et v√©rifions combien d'espace cela prend. <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cstore_table ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> cstore_server <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>(compression <span class="hljs-string"><span class="hljs-string">'pglz'</span></span>);</code> </pre> <br>  Comme vous l'avez remarqu√©, j'ai cr√©√© une table externe.  Le fait est que PostgreSQL n'a pas de support de colonne int√©gr√©.  Mais PostgreSQL dispose d'un puissant syst√®me d'extensions.  L'un d'eux permet de cr√©er des tables columnstore.  Liens √† la fin de l'article. <br><br><ul><li>  pglz - indique √† l'extension que les donn√©es doivent √™tre compress√©es √† l'aide de l'algorithme int√©gr√© dans PostgreSQL; </li><li>  trd - temps de transaction; </li><li>  op, it, wh - coupes ou mesures analytiques; </li><li>  m1, m2, m3, m4, m5 - indicateurs ou mesures num√©riques; </li></ul><br>  Ins√©rons une quantit√© ¬´d√©cente¬ª de donn√©es et voyons combien d'espace il faut sur le disque.  Dans le m√™me temps, nous v√©rifions les performances de l'insert.  Parce que  Je mets mes exp√©riences sur un ordinateur portable, je suis un peu organique dans la quantit√© de donn√©es.  De plus, ce qui est encore bon, j'utiliserai le disque dur ex√©cutant le syst√®me d'exploitation invit√© Fedora 30. H√¥te OS - Windows 10 Home Edition.  Processeur Intel Core 7. Le SE invit√© a re√ßu 4 Go de RAM.  Version PostgreSQL - PostgreSQL 10.10 sur x86_64-pc-linux-gnu, compil√© par gcc (GCC) 9.1.1 20190503 (Red Hat 9.1.1-1), 64 bits.  J'exp√©rimenterai un ensemble de donn√©es avec le nombre d'enregistrements 52 608 000. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1095</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d;</code> </pre> <br>  Le plan de mise en ≈ìuvre sera le suivant <br><blockquote>  Ins√©rer sur cstore_table (co√ªt = 0,01..24902714242540.01 lignes = 1000000000000000 largeur = 150) (temps r√©el = 119560.456..119560.456 lignes = 0 boucles = 1) <br>  ----&gt; Boucle imbriqu√©e (co√ªt = 0,01..24902714242540,01 lignes = 1000000000000000 largeur = 150) (temps r√©el = 1,823..22339,976 lignes = 52608000 boucles = 1) <br>  ----------&gt; Fonction Scan sur generate_series d (co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (temps r√©el = 0,151..2,198 lignes = 1096 boucles = 1) <br>  ----------&gt; Materialise (co√ªt = 0,01..27284555030.01 lignes = 1000000000000 largeur = 16) (temps r√©el = 0,002..3,196 lignes = 48000 boucles = 1096) <br>  ----------------&gt; Boucle imbriqu√©e (co√ªt = 0,01..17401742530,01 lignes = 1000000000000 largeur = 16) (temps r√©el = 1,461..15,072 lignes = 48000 boucles = 1) <br>  ----------------------&gt; Scan de fonction sur generate_series it (co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (temps r√©el = 1,159..2,007 lignes = 4000 boucles = 1) <br>  ----------------------&gt; Mat√©rialiser (co√ªt = 0,01..26312333,01 lignes = 10000000000 largeur = 12) (temps r√©el = 0,000..0,001 lignes = 12 boucles = 4000) <br>  ----------------------------&gt; Boucle imbriqu√©e (co√ªt = 0,01 √† 16429520,01 lignes = 1 000 000 000 de largeur = 12) (temps r√©el = 0,257 .0.485 lignes = 12 boucles = 1) <br>  ----------------------------------&gt; Analyse des fonctions sur generate_series wh (co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (temps r√©el = 0,046 √† 0,049 lignes = 3 boucles = 1) <br>  ----------------------------------&gt; Mat√©rialiser (co√ªt = 0,01..28917,01 lignes = 1000000 largeur = 8) (temps r√©el = 0,070..0,139 lignes = 4 boucles = 3) <br>  ---------------------------------------&gt; Boucle imbriqu√©e (co√ªt = 0,01..20010.01 lignes = 1000000 largeur = 8) (temps r√©el = 0,173 √† 0,366 rang√©es = 4 boucles = 1) <br>  -------------------------------------------&gt; Scan de fonction sur l'op√©rande generate_series ( co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (temps r√©el = 0,076..0,079 lignes = 2 boucles = 1) <br>  ---------------------------------------------&gt; Scan de fonction sur generate_series org (co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (temps r√©el = 0,043..0,047 lignes = 2 boucles = 2) <br>  Temps de planification: 0,439 ms <br>  Temps d'ex√©cution: 119692,051 ms </blockquote>  D√©lai total - 1,994867517 minutes <br><br>  Temps de cr√©ation de l'ensemble de donn√©es - 22,339976 secondes <br><br>  Temps d'insertion - 1,620341333 minutes <br><br>  Je n'ai pas r√©ussi √† √©valuer l'espace disque occup√© √† l'aide des fonctions PostgreSQL.  Je ne sais pas pourquoi, mais en affichant 0. C'est peut-√™tre le comportement standard pour les tables externes.  Utilis√© pour ce gestionnaire de fichiers.  Ainsi, le volume d'espace disque occup√© est de 226,2 Mo.  Pour √©valuer beaucoup ou un peu, comparons-le avec un tableau r√©gulier. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1095</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d;</code> </pre> <br>  Le plan de mise en ≈ìuvre sera le suivant <br><blockquote>  Boucle imbriqu√©e (co√ªt = 0,01..22402714242540,01 lignes = 1000000000000000 largeur = 44) (temps r√©el = 0,585..23781.942 lignes = 52608000 boucles = 1) <br>  ---&gt; Analyse des fonctions sur generate_series d (co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (temps r√©el = 0,091..2,130 lignes = 1096 boucles = 1) <br>  ---&gt; Mat√©rialiser (co√ªt = 0,01..27284555030,01 lignes = 1000000000000 largeur = 16) (temps r√©el = 0,001..3,574 lignes = 48000 boucles = 1096) <br>  ----------&gt; Boucle imbriqu√©e (co√ªt = 0,01..17401742530,01 lignes = 1000000000000 largeur = 16) (temps r√©el = 0,489..14,044 lignes = 48000 boucles = 1) <br>  ----------------&gt; Scan de fonction sur generate_series it (co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (temps r√©el = 0,477..1,352 lignes = 4000 boucles = 1 ) <br>  ----------------&gt; Mat√©rialiser (co√ªt = 0,01..26312333,01 lignes = 1000000000 largeur = 12) (temps r√©el = 0,000..0,001 lignes = 12 boucles = 4000) <br>  ----------------------&gt; Boucle imbriqu√©e (co√ªt = 0,01 √† 16429520,01 lignes = 1 000 000 000 de largeur = 12) (temps r√©el = 0,010 √† 0,019 lignes = 12 boucles = 1) <br>  ----------------------------&gt; Fonction Scan sur generate_series wh (co√ªt = 0,00..10,00 lignes = 1000 largeur = 4) (r√©el temps = 0,003..0,003 lignes = 3 boucles = 1) <br>  ----------------------------&gt; Mat√©rialiser (co√ªt = 0,01..28917,01 lignes = 1000000 largeur = 8) (temps r√©el = 0,002. .0.004 lignes = 4 boucles = 3) <br>  ----------------------------------&gt; Boucle imbriqu√©e (co√ªt = 0,01..20010,01 lignes = 1000000 largeur = 8 ) (temps r√©el = 0,006..0,009 lignes = 4 boucles = 1) <br>  ----------------------------------------&gt; Scan de fonction sur l'oper generate_series (co√ªt = 0,00 ..10.00 lignes = 1000 largeur = 4) (temps r√©el = 0,002..0,002 lignes = 2 boucles = 1) <br>  ----------------------------------------&gt; Scan de fonction sur org generate_series (co√ªt = 0,00 ..10.00 lignes = 1000 largeur = 4) (temps r√©el = 0,001..0,001 lignes = 2 boucles = 2) <br>  Temps de planification: 0,569 ms <br>  Temps d'ex√©cution: 378883,989 ms </blockquote>  Le temps consacr√© √† la mise en ≈ìuvre de ce plan ne nous int√©resse pas, car  dans la vraie vie, de tels inserts ne sont pas suppos√©s.  Nous voulons savoir combien d'espace disque cette table occupe.  Ayant r√©pondu √† la demande de fonctions syst√®me, j'ai re√ßu 3,75 Go. <br><br>  Donc, cstore_table - 226 Mo, rbstore_table - 3,75 Go.  La diff√©rence de 16,99 fois est frappante, mais il est peu probable que la m√™me diff√©rence puisse √™tre obtenue en production, principalement en raison de la distribution des donn√©es.  En r√®gle g√©n√©rale, cette diff√©rence sera moindre et sera environ 5 fois. <br><br>  Mais attendez, personne n'utilise de donn√©es brutes dans un format bas√© sur des lignes √† des fins d'analyse.  Par exemple, ils essaient d'utiliser des donn√©es index√©es pour les rapports.  Et parce que  Les donn√©es "brutes" seront toujours, vous devez comparer les tailles avec les tailles des indices.  Cr√©ons au moins un index.  Soit un index sur le champ date et le type d'op√©ration - trd + op. <br><br>  Donc, je n'ai index√© que deux champs, et l'index a pris 1583 Mo, ce qui est beaucoup plus que le cstore_table.  Mais, en r√®gle g√©n√©rale, plusieurs index sont requis pour la charge OLAP.  Il conviendra de noter ici que le cstore_table n'a pas besoin d'indexation suppl√©mentaire.  Cette table agit comme un index couvrant toutes les requ√™tes. <br><br>  De tout ce qui pr√©c√®de, une conclusion simple peut √™tre tir√©e - en utilisant des tables columnstore, vous pouvez r√©duire la quantit√© d'espace disque utilis√©. <br><br><h4>  Performances des requ√™tes </h4><br>  Pour √©valuer les performances, ex√©cutons une requ√™te qui renvoie des donn√©es r√©capitulatives pour un mois sp√©cifique pour un type d'op√©ration sp√©cifique. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Le plan de mise en ≈ìuvre sera le suivant <br><blockquote>  Agr√©gat (co√ªt = 793602,69..793602,70 lignes = 1 largeur = 32) (temps r√©el = 79,708..79,708 lignes = 1 boucles = 1) <br>  --Buffers: hit partag√© = 44226 <br>  ---&gt; Analyse √©trang√®re sur cstore_table (co√ªt = 0,00..793544,70 lignes = 23197 largeur = 5) (temps r√©el = 23,209..76,628 lignes = 24000 boucles = 1) <br>  -------- Filtre: ((trd = '2011-01-01' :: date) AND (op = 1)) <br>  -------- Lignes supprim√©es par le filtre: 26000 <br>  -------- Fichier CStore: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16417 <br>  -------- Taille du fichier CStore: 120818897 <br>  -------- Tampons: hit partag√© = 44226 <br>  Temps de planification: 0,165 ms <br>  Temps d'ex√©cution: 79,887 ms </blockquote>  Et <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Le plan de mise en ≈ìuvre sera le suivant <br><blockquote>  Agr√©gat (co√ªt = 40053.80..40053.81 lignes = 1 largeur = 8) (temps r√©el = 389.183..389.183 lignes = 1 boucles = 1) <br>  --Buffers: lecture partag√©e = 545 <br>  ---&gt; Index Scan utilisant trd_op_ix sur rbstore_table (co√ªt = 0,56..39996,70 lignes = 22841 largeur = 4) (temps r√©el = 55,955..385,283 lignes = 24000 boucles = 1) <br>  -------- Index Cond: ((trd = '2011-01-01 00:00:00' :: horodatage sans fuseau horaire) ET (op = 1)) <br>  -------- Tampons: lecture partag√©e = 545 <br>  Temps de planification: 112,175 ms <br>  Temps d'ex√©cution: 389,219 ms </blockquote>  389,219 ms contre 79,887 ms.  Ici, nous voyons que m√™me sur une quantit√© relativement petite de donn√©es columnstore, une table est beaucoup plus rapide qu'un index sur une table bas√©e sur des lignes. <br><br>  Modifions la demande et essayons d'obtenir l'unit√© pour toute l'ann√©e 2011. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2011-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Le plan de mise en ≈ìuvre sera le suivant <br><blockquote>  Agr√©gat (co√ªt = 946625.58..946625.59 lignes = 1 largeur = 32) (temps r√©el = 3123.604..3123.604 lignes = 1 boucles = 1) <br>  --Buffers: hit partag√© = 44226 <br>  ---&gt; Analyse √©trang√®re sur cstore_table (co√ªt = 0,00..925064,70 lignes = 8624349 largeur = 5) (temps r√©el = 21,728..2100,665 lignes = 8760000 boucles = 1) <br>  -------- Filtre: ((trd&gt; = '2011-01-01' :: date) AND (trd &lt;= '2011-12-31' :: date) AND (op = 1)) <br>  -------- Lignes supprim√©es par le filtre: 8760000 <br>  -------- Fichier CStore: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16411 <br>  -------- Taille du fichier CStore: 120818897 <br>  -------- Tampons: hit partag√© = 44226 <br>  Temps de planification: 0,212 ms <br>  Temps d'ex√©cution: 3123,960 ms </blockquote>  Et <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2011-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Le plan de mise en ≈ìuvre sera le suivant <br><blockquote>  Finaliser l'agr√©gat (co√ªt = 885214.33..885214.34 lignes = 1 largeur = 8) (temps r√©el = 98512.560..98512.560 lignes = 1 boucles = 1) <br>  --Buffers: hit partag√© = 2565 lu = 489099 <br>  ---&gt; Rassembler (co√ªt = 885214.12..885214.33 lignes = 2 largeur = 8) (temps r√©el = 98427.034..98523.194 lignes = 3 boucles = 1) <br>  -------- Travailleurs pr√©vus: 2 <br>  -------- Lancement des travailleurs: 2 <br>  -------- Tampons: hit partag√© = 2565 lu = 489099 <br>  ---------&gt; Agr√©gat partiel (co√ªt = 884214.12..884214.13 lignes = 1 largeur = 8) (temps r√©el = 97907.608..97907.608 lignes = 1 boucles = 3) <br>  -------------- Tampons: hit partag√© = 2565 lu = 489099 <br>  ---------------&gt; Scan Seq parall√®le sur rbstore_table (co√ªt = 0,00..875264,00 lignes = 3580047 largeur = 4) (temps r√©el = 40820,004..97405,250 lignes = 2920000 boucles = 3) <br>  --------------------- Filtre: ((trd&gt; = '2011-01-01 00:00:00' :: horodatage sans fuseau horaire) ET (trd &lt;= '2011-12-31 00:00:00' :: horodatage sans fuseau horaire) ET (op = 1)) <br>  -------------------- Lignes supprim√©es par le filtre: 14616000 <br>  -------------------- Tampons: hit partag√© = 2565 lu = 489099 <br>  Temps de planification: 7,899 ms <br>  Temps d'ex√©cution: 98523,278 ms </blockquote>  98523,278 ms contre 3123,960 ms.  Un index partiel pourrait peut-√™tre nous aider, mais il vaut mieux ne pas le risquer et cr√©er une structure bas√©e sur les lignes appropri√©e dans laquelle les valeurs pr√©d√©finies seront stock√©es. <br><br><h4>  Agr√©gats manuels </h4><br>  Une structure appropri√©e pour les agr√©gats manuels pourrait √™tre une table r√©guli√®re bas√©e sur des lignes contenant des valeurs pr√©calcul√©es.  Par exemple, il peut contenir un enregistrement relatif √† 2011 avec le type d'op√©ration √©gal √† 1, tandis que dans les champs m1, m2, m3, m4 et m5 la valeur agr√©g√©e sera stock√©e pr√©cis√©ment pour ces sections analytiques.  Ainsi, disposant d'un ensemble suffisant d'agr√©gats et d'indices, les requ√™tes analytiques acqui√®rent des performances sans pr√©c√©dent.  Fait int√©ressant, Microsoft SQL Server Analysis Services dispose d'un assistant sp√©cial qui vous permet de configurer le nombre et la profondeur des valeurs pr√©calcul√©es. <br><br>  Cette solution pr√©sente les avantages suivants: <br><br><ul><li>  Analyses en temps r√©el. <br><br>  <i>Veuillez ne pas confondre le terme ¬´analytique en temps r√©el¬ª.</i>  <i>Ici, nous parlons du fait que l'augmentation de l'unit√© se produit sur une p√©riode de temps acceptable dans la grande majorit√© des cas.</i> <i><br><br></i>  <i>En fait, ce plus est controvers√©, mais n'en parlons pas.</i>  <i>Le fait demeure.</i>  <i>L'architecture de la solution est telle que les unit√©s restent ¬´fra√Æches¬ª presque toujours.</i> </li><li>  Ind√©pendance totale vis-√†-vis du volume de donn√©es. <br><br>  <i>C'est un plus tr√®s s√©rieux.</i>  <i>Quelle que soit la quantit√© de donn√©es trait√©es, t√¥t ou tard, elles seront trait√©es et les agr√©gats re√ßus.</i> </li><li>  Complexit√© relative. <br><br>  <i>Pour obtenir des analyses en temps r√©el et une ind√©pendance du volume de donn√©es, la solution doit utiliser des technologies avanc√©es telles que le multithreading et la gestion manuelle des verrous au niveau du SGBD.</i> </li><li>  Test de difficult√©. <br><br>  <i>Ici, nous parlons √† la fois de tests unitaires et de tests manuels.</i>  <i>Je pense que le lecteur ne devrait pas expliquer que l'identification des erreurs de multithreading n'est pas une t√¢che facile.</i> </li><li>  Augmentation de l'espace disque requis. <br><br></li></ul><br><h4>  L'utilisation r√©elle de columnstore </h4><br>  Ici, nous devons √† nouveau plonger dans la th√©orie et analyser plus en d√©tail la question de savoir ce que sont les donn√©es analytiques. <br><br>  Prenez le chef d'entreprise moyen.  En r√®gle g√©n√©rale, il / elle s'inqui√®te de deux questions globales: "Comment √ßa se passe en ce moment?"  et "Qu'est-ce qui a chang√© r√©cemment?". <br><br>  Pour r√©pondre √† la question ¬´Comment vont les choses en ce moment¬ª, nous n'avons absolument pas besoin de donn√©es historiques.  C'est-√†-dire  peu importe comment les choses se sont pass√©es il y a un mois. <br><br>  Afin de se tenir au courant du pouls, la question est souvent pos√©e.  Ce type d'analyse de donn√©es est dit op√©rationnel. <br><br>  Pour r√©pondre √† la question ¬´Ce qui a chang√© r√©cemment¬ª, nous avons besoin de donn√©es historiques pr√©cises.  De plus, en r√®gle g√©n√©rale, l'analyse est effectu√©e aux m√™mes intervalles de temps.  Par exemple, un mois est compar√© √† un mois, d'une ann√©e √† l'autre, etc.  Bien s√ªr, le syst√®me ne doit pas limiter l'utilisateur √† la possibilit√© de comparer des p√©riodes arbitraires, mais un tel cas doit √™tre reconnu comme rare, car  comparer une ann√©e ferm√©e avec une moiti√© non cl√¥tur√©e n'a pas de sens.  Une caract√©ristique distinctive de l'analyse comparative est qu'elle n'est pas requise aussi souvent qu'elle est op√©rationnelle.  Nous appellerons ce type d'analyse historique. <br><br>  De toute √©vidence, l'analyse op√©rationnelle devrait se produire rapidement.  En cons√©quence, il impose des exigences √©lev√©es en mati√®re de performances.  Alors que pour l'analyse historique, de telles exigences ne peuvent pas √™tre avanc√©es.  Bien que la performance de l'analyse historique devrait rester √† un niveau tr√®s √©lev√©.  Au moins pour que le syst√®me d'analyse lui-m√™me reste comp√©titif. <br><br>  Ainsi, selon deux types d'analyses, on peut distinguer deux types de donn√©es analytiques: les donn√©es op√©rationnelles et historiques.  Du c√¥t√© de l'utilisateur, il ne devrait pas √™tre visible avec quelles donn√©es particuli√®res il travaille en ce moment. <br><br>  C'est √† partir de ces consid√©rations que dans les serveurs de bases de donn√©es, la possibilit√© est apparue de diviser les tables en sections distinctes. <br><br>  En ce qui concerne le magasin de colonnes, il est possible de m√©langer des sections dans des formats bas√©s sur des lignes et des magasins de colonnes.  Il est connu que les donn√©es d'analyse op√©rationnelle sont sujettes √† de fr√©quentes modifications, ce qui emp√™che leur stockage au format columnstore.  Et √©tant donn√© que les donn√©es op√©rationnelles ne se produisent pas trop, elles peuvent √™tre stock√©es sous forme de lignes. <br><br>  Les donn√©es historiques ne changent pas.  Il y a beaucoup de ces donn√©es, et donc le format columnstore leur convient mieux.  Rappelez-vous que les performances des requ√™tes en gras sur une source columnstore sont sup√©rieures √† celles d'une source bas√©e sur des lignes. <br><br>  Regardons un exemple de tout ce qui pr√©c√®de. <br><br>  Ci-dessous, je cr√©e la table principale de l'entrep√¥t et y attache les sections d'analyse op√©rationnelle et historique. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">partition by range</span></span>(trd); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> historycal_data ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> cstore_server <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>(compression <span class="hljs-string"><span class="hljs-string">'pglz'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> historycal_data <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-number"><span class="hljs-number">1095</span></span> - <span class="hljs-number"><span class="hljs-number">31</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> historycal_data; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> operational_data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d))::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> trd_op_ix <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> operational_data (trd, op); <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> operational_data; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">attach partition</span></span> operational_data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (<span class="hljs-string"><span class="hljs-string">'2112-01-01'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">attach partition</span></span> historycal_data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>);</code> </pre> <br>  Tout est pr√™t.  Essayons de commander quelques rapports.  Commen√ßons par commander les donn√©es pour un jour du mois en cours. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><blockquote>  Agr√©gat (co√ªt = 15203,37..15203,38 lignes = 1 largeur = 32) (temps r√©el = 17,320..17,320 lignes = 1 boucles = 1) <br>  --Buffers: hit partag√© = 3 lecture = 515 <br>  ---&gt; Ajouter (co√ªt = 532,59..15140,89 lignes = 24991 largeur = 5) (temps r√©el = 1,924..13,838 lignes = 24000 boucles = 1) <br>  ------- Tampons: hit partag√© = 3 lecture = 515 <br>  ---------&gt; Bitmap Heap Scan sur operation_data (co√ªt = 532,59..15140,89 lignes = 24991 largeur = 5) (temps r√©el = 1,924..11,992 lignes = 24000 boucles = 1) <br>  --------------- V√©rifiez √† nouveau Cond: ((trd = '2012-12-01' :: date) AND (op = 1)) <br>  --------------- Blocs de tas: exact = 449 <br>  --------------- Tampons: hit partag√© = 3 lecture = 515 <br>  ----------------&gt; Scan d'index bitmap sur trd_op_ix (co√ªt = 0,00..526,34 lignes = 24991 largeur = 0) (temps r√©el = 1,877..1,877 lignes = 24000 boucles = 1 ) <br>  --------------------- Index Cond: ((trd = '2012-12-01' :: date) AND (op = 1)) <br>  --------------------- Tampons: hit partag√© = 2 lecture = 67 <br>  Temps de planification: 0,388 ms <br>  Temps d'ex√©cution: 100,941 ms </blockquote>  Nous allons maintenant commander des donn√©es pour l'ensemble de 2012, dans lesquelles le nombre de transactions est de 8 784 000. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2012-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2012-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><blockquote>  Agr√©gat (co√ªt = 960685.82..960685.83 lignes = 1 largeur = 32) (temps r√©el = 4124.681..4124.681 lignes = 1 boucles = 1) <br>  --Buffers: hit partag√© = 45591 lu = 11282 <br>  ---&gt; Ajouter (co√ªt = 0,00..938846,60 lignes = 8735687 largeur = 5) (temps r√©el = 66,581..3036,394 lignes = 8784000 boucles = 1) <br>  --------- Tampons: hit partag√© = 45591 lu = 11282 <br>  ----------&gt; Analyse √©trang√®re sur historycal_data (co√ªt = 0,00..898899,60 lignes = 7994117 largeur = 5) (temps r√©el = 66,579..2193.801 lignes = 8040000 boucles = 1) <br>  --------------- Filtre: ((trd&gt; = '2012-01-01' :: date) AND (trd &lt;= '2012-12-31' :: date) AND (op = 1)) <br>  --------------- Lignes supprim√©es par le filtre: 8040000 <br>  --------------- Fichier CStore: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16448 <br>  --------------- Taille du fichier CStore: 117401470 <br>  --------------- Tampons: hit partag√© = 42966 <br>  ----------&gt; Seq Scan sur donn√©es_op√©rationnelles (co√ªt = 0,00..39947,00 lignes = 741570 largeur = 5) (temps r√©el = 0,019..284,824 lignes = 744000 boucles = 1) <br>  --------------- Filtre: ((trd&gt; = '2012-01-01' :: date) AND (trd &lt;= '2012-12-31' :: date) AND (op = 1)) <br>  --------------- Lignes supprim√©es par le filtre: 744000 <br>  --------------- Tampons: hit partag√© = 2625 lu = 11282 <br>  Temps de planification: 0,256 ms <br>  Temps d'ex√©cution: 4125,239 ms </blockquote>  Au final, voyons ce qui se passe si l'utilisateur veut, par exemple, sans intention malveillante, ordonner un rapport sur toutes les transactions du syst√®me, dont il y a 52 608 000. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse</code> </pre> <br><blockquote>  Agr√©gat (co√ªt = 672940.20..672940.21 lignes = 1 largeur = 32) (temps r√©el = 15907.886..15907.886 lignes = 1 boucles = 1) <br>  --Buffers: hit partag√© = 17075 lu = 11154 <br>  ---&gt; Ajouter (co√ªt = 0,00 √† 541420,20 lignes = 52608000 largeur = 5) (temps r√©el = 0,192 √† 9115,144 lignes = 52608000 boucles = 1) <br>  --------- Tampons: hit partag√© = 17075 lu = 11154 <br>  ----------&gt; Analyse √©trang√®re sur historycal_data (co√ªt = 0,00..512633,20 lignes = 51120000 largeur = 5) (temps r√©el = 0,191..5376,449 lignes = 51120000 boucles = 1) <br>  --------------- Fichier CStore: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16448 <br>  --------------- Taille du fichier CStore: 117401470 <br>  --------------- Tampons: hit partag√© = 14322 <br>  ----------&gt; Seq Scan sur donn√©es_op√©rationnelles (co√ªt = 0,00..28787,00 lignes = 1488000 largeur = 5) (temps r√©el = 0,032..246,978 lignes = 1488000 boucles = 1) <br>  --------------- Tampons: hit partag√© = 2753 lu = 11154 <br>  Temps de planification: 0,157 ms <br>  Temps d'ex√©cution: 15908,096 ms </blockquote>  Veuillez noter que j'√©cris toujours mon article, comme si de rien n'√©tait.  Je n'ai m√™me pas eu √† red√©marrer mon ordinateur portable pas si puissant avec disque dur et 4 Go de RAM.  Bien que la question de la consommation des ressources n√©cessite une √©tude plus approfondie. <br><br><h4>  Tol√©rance aux pannes </h4><br>  En partie, la tol√©rance aux pannes a √©t√© test√©e au moment d'√©crire ces lignes.  Mon ordinateur portable est vivant, et, en g√©n√©ral, je n'ai remarqu√© aucun ralentissement dans son travail, √† part les habituels. <br><br>  Que le lecteur me pardonne le fait que je n'ai pas eu le temps de r√©gler en d√©tail la question de la tol√©rance aux pannes, mais je peux dire que l'extension en question a une tol√©rance aux pannes - une sauvegarde est possible. <br><br><h4>  Facilit√© de mise en ≈ìuvre </h4><br>  Il s'est av√©r√© que lors de la cr√©ation d'une table qui stocke des donn√©es dans un format columnstore, il n'y a pas d'options autres qu'un algorithme de compression.  La compression elle-m√™me est absolument n√©cessaire. <br><br>  Le format lui-m√™me a une certaine structure.  En d√©finissant les param√®tres appropri√©s, vous pouvez obtenir une certaine acc√©l√©ration des requ√™tes analytiques ou ajuster le degr√© de compression des informations. <br><br>  Comme d√©montr√© ci-dessus, la cr√©ation d'une table columnstore n'est pas un probl√®me du tout.  L'extension peut fonctionner avec 40 types de donn√©es PostgreSQL.  Les webinaires ont parl√© de tous les types pris en charge par PostgreSQL. <br><br><h4>  Quelles nouvelles comp√©tences un d√©veloppeur doit-il avoir pour travailler avec de nouvelles structures </h4><br>  Le d√©veloppeur SQL n'a pas besoin de comp√©tences particuli√®res pour √©crire des requ√™tes dans des tables columnstore.  Une telle table est visible dans toutes les requ√™tes, comme une table r√©guli√®re bas√©e sur des lignes.  Bien que cela n'exclut pas la n√©cessit√© d'optimiser les requ√™tes. <br><br><h4>  Conclusion </h4><br>  Dans cet article, j'ai montr√© comment une table avec un format de stockage columnstore peut √™tre utile.  Cela √©conomise de l'espace disque et des requ√™tes analytiques hautes performances.  La facilit√© de travail avec la table r√©duit automatiquement le co√ªt de cr√©ation d'un entrep√¥t de donn√©es analytiques √† part enti√®re, car  son utilisation ne n√©cessite pas le d√©veloppement d'algorithmes complexes et difficiles √† d√©boguer.  Les tests sont simplifi√©s. <br><br>  Malgr√© le fait que les exp√©riences pr√©sent√©es ci-dessus inspirent l'optimisme, de nombreux probl√®mes n'ont pas √©t√© r√©solus.  Par exemple, quel plan de requ√™te sera g√©n√©r√© lorsque la table columnstore rejoint d'autres tables.  J'esp√®re continuer ce travail dans la prochaine partie.  Le nombre de pi√®ces d√©pendra du comportement de cstore_fdw sur des donn√©es plus ou moins r√©elles. <br><br><h4>  Liens vers des documents suppl√©mentaires </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Br√®ve revue cstore_fdw</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cstore_fdw sur github</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Feuille de route cstore_fdw</a> <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472396/">https://habr.com/ru/post/fr472396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472384/index.html">Un aper√ßu des mises √† jour Android du point de vue d'un d√©veloppeur</a></li>
<li><a href="../fr472386/index.html">ZIO & Cats Effect: une alliance r√©ussie</a></li>
<li><a href="../fr472388/index.html">Walmart d√©clare la guerre des prix sur Amazon</a></li>
<li><a href="../fr472392/index.html">La mont√©e, la chute et le retour possible des cassettes audio - nous traitons des mythes et donnons un aper√ßu de la situation</a></li>
<li><a href="../fr472394/index.html">√âvaluer l'impact de l'intelligence artificielle sur le p√©trole et le gaz offshore</a></li>
<li><a href="../fr472402/index.html">Streaming d'appels vid√©o RTMP</a></li>
<li><a href="../fr472404/index.html">Calcul de collision 2D: algorithme de Gilbert-Johnson-Kirti</a></li>
<li><a href="../fr472406/index.html">Agrandir le centre de donn√©es pendant la livraison de pizza</a></li>
<li><a href="../fr472410/index.html">Conception de syst√®mes de couleurs disponibles</a></li>
<li><a href="../fr472412/index.html">Analyste syst√®me et m√©triques de produit - secouer mais pas m√©langer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>