<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ℹ️ 🦖 🍥 在Unity3D中使用外部资源 🤲🏼 ⌨️ 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 尊敬的读者您好，今天我们将讨论在Unity 3d环境中使用外部资源的问题。 

 首先，根据传统，我们将确定它是什么以及为什么需要它。 那么，这些外部资源到底是什么。 作为游戏开发的一部分，此类资源可以是应用程序正常运行所需的所有资源，不应存储在项目的最终版本中。 外部资源既可以位于用户计...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity3D中使用外部资源</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433366/"><h2> 引言 </h2><br> 尊敬的读者您好，今天我们将讨论在Unity 3d环境中使用外部资源的问题。 <br><br> 首先，根据传统，我们将确定它是什么以及为什么需要它。 那么，这些外部资源到底是什么。 作为游戏开发的一部分，此类资源可以是应用程序正常运行所需的所有资源，不应存储在项目的最终版本中。 外部资源既可以位于用户计算机的硬盘上，也可以位于外部Web服务器上。 通常，此类资源是我们加载到已经运行的应用程序中的任何文件或数据集。 在Unity 3d框架中，它们可以是： <br><br><ul><li> 文字档 </li><li> 纹理文件 </li><li> 音频文件 </li><li> 字节数组 </li><li>  AssetBundle（与Unity 3d项目的资产一起归档） </li></ul><br> 下面，我们将更详细地研究Unity 3d中存在的用于处理这些资源的内置机制，以及编写用于与Web服务器交互并将资源加载到应用程序中的简单管理器。 <br><br>  <b>注意</b> ： <i>本文</i>的<i>其余部分使用使用C＃7+的代码，并且是为2018.3+版本中Unity3d中使用的Roslyn编译器设计的。</i> <br><a name="habracut"></a><br><h2>  Unity 3d的功能 </h2><br> 在Unity 2017之前，引擎中包含了一种机制（不包括自我描述的机制）来处理服务器数据和外部资源-这是WWW类。 此类允许以同步或异步形式（通过Coroutine）使用各种http命令（get，post，put等）。 使用此类的工作非常简单明了。 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> www = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WWW(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> www; Debug.Log(www.text); }</code> </pre> <br> 同样，您不仅可以获取文本数据，还可以获取其他数据： <br><br><ul><li> 字节数组<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-www.bytes</a> </li><li> 纹理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-www.texture</a> </li><li> 音频<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-www.GetAudioClip</a> （） </li><li> 资产<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-www.assetBundle</a> </li></ul><br> 但是，从2017版开始，Unity具有<b>UnityWebRequest</b>类引入的新服务器系统，该系统位于Networking名称空间中。 在Unity 2018之前，它与<b>WWW</b>一起存在，但是在<b>WWW</b>引擎的最新版本中，不推荐使用它，并且在将来它将被完全删除。 因此，进一步，我们将仅关注<b>UnityWebRequest</b> （以下简称UWR）。 <br><br> 从整体上来说，使用UWR与WWW的核心相似，但是存在差异，这将在后面讨论。 下面是加载文本的类似示例。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityWebRequest(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); Debug.Log(request.downloadHandler.text); request.Dispose(); }</code> </pre><br> 新的UWR系统引入的主要更改（除了更改内部工作原理之外）是分配处理程序以从服务器本身上载和下载数据的能力，更多详细信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读。 默认情况下，这些是类<b>UploadHandler</b>和<b>DownloadHandler</b> 。  Unity本身提供了这些类的扩展集，用于处理各种数据，例如音频，纹理，资产等。 让我们考虑更详细地与他们合作。 <br><br><h2> 处理资源 </h2><br><h3> 文字内容 </h3><br> 使用文本是最简单的选择之一。 上面已经描述了用于下载它的方法。 我们使用创建直接的http Get请求来重写它。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTextFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Get(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(uwr.downloadHandler.text); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br> 从代码中可以看到，此处使用默认的<b>DownloadHandler</b> 。  text属性是一个将字符串数组转换为UTF8编码文本的getter。 从服务器加载文本的主要用途是接收json文件（文本形式的数据序列化表示）。 您可以使用Unity <b>JsonUtility</b>类获取此数据。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = JsonUtility.FromJson&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-comment"><span class="hljs-comment">// T  ,    .</span></span></code> </pre><br><h3> 音讯 </h3><br> 要使用音频，必须使用创建<b>UnityWebRequestMultimedia.GetAudioClip</b>请求的特殊方法，并且要以在Unity中使用所需的形式获取数据表示，必须使用<b>DownloadHandlerAudioClip</b> 。 另外，在创建请求时，您必须指定由<b>AudioType</b>枚举表示的音频数据的类型，该类型设置格式（wav，aiff，oggvorbis等）。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadAudioFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, AudioType audioType, Action&lt;AudioClip&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestMultimedia.GetAudioClip(url, audioType); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerAudioClip.GetContent(request)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br><h3> 质感 </h3><br> 下载纹理类似于音频文件。 该请求是使用<b>UnityWebRequestTexture.GetTexture</b>创建的。 为了获得Unity所需格式的数据，使用<b>DownloadHandlerTexture</b> 。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTextureFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;Texture2D&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestTexture.GetTexture(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerTexture.GetContent(request)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br><h3> 资产捆绑 </h3><br> 如前所述，该捆绑包实际上是具有Unity资源的存档，可以在已经运行的游戏中使用。 这些资源可以是任何项目资产，包括场景。  C＃脚本是一个例外；它们无法传递。 要加载<b>AssetBundle</b> ，将使用使用<b>UnityWebRequestAssetBundle.GetAssetBundle</b>创建的查询<b>。</b>  <b>DownloadHandlerAssetBundle</b>用于获取Unity所需格式的数据。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadBundleFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;AssetBundle&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestAssetBundle.GetAssetBundle(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerAssetBundle.GetContent(request)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } request.Dispose(); }</code> </pre><br><h2> 使用Web服务器和外部数据时的主要问题和解决方案 </h2><br> 上面已经描述了在加载各种资源方面在应用程序和服务器之间进行交互的简单方法。 但是，实际上，事情要复杂得多。 考虑开发人员伴随的主要问题，并详细说明解决问题的方法。 <br><br><h3> 可用空间不足 </h3><br> 从服务器下载数据时的第一个问题是设备上可能缺少可用空间。 用户经常使用旧设备进行游戏（尤其是在Android上），并且下载文件本身的大小可能非常大（Hello PC）。 在任何情况下，都必须正确处理此情况，并且必须提前告知播放器没有足够的空间以及多少空间。 怎么做？ 您需要知道的第一件事是下载文件的大小，这是通过<b>UnityWebRequest.Head（）</b>请求完成的。 下面是获取大小的代码。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConntentLength</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Head(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!request.isHttpError &amp;&amp; !request.isNetworkError) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentLength = request.GetResponseHeader(<span class="hljs-string"><span class="hljs-string">"Content-Length"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(contentLength, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> returnValue)) { response(returnValue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response(<span class="hljs-number"><span class="hljs-number">-1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogErrorFormat(<span class="hljs-string"><span class="hljs-string">"error request [{0}, {1}]"</span></span>, url, request.error); response(<span class="hljs-number"><span class="hljs-number">-1</span></span>); } }</code> </pre><br> 在此处注意一件事很重要，为了使请求正常工作，服务器必须能够返回内容的大小，否则（实际上，为了显示进度）将返回错误的值。 <br><br> 获得下载数据的大小后，可以将其与可用磁盘空间的大小进行比较。 为了获得后者，我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了Asset Store中</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">免费插件</a> 。 <br><br>  <b>注意</b> ： <i>您可以在Unity3d中使用<b>Cache</b>类，它可以显示可用和已用的缓存空间。</i>  <i>但是，值得考虑这些数据是相对的。</i>  <i>它们是根据缓存本身的大小计算的，默认情况下为4GB。</i>  <i>如果用户的可用空间大于缓存的大小，那么就不会有问题，但是如果不是这样，则这些值可能采用相对于实际事务状态而言不正确的值。</i> <br><br><h3> 上网检查 </h3><br> 通常，在从服务器下载任何内容之前，有必要处理无法访问Internet的情况。 有几种方法可以执行此操作：从ping地址到google.ru的GET请求。 但是，我认为，最正确，最快速，最稳定的结果是从您自己的服务器（文件下载位置相同）下载一个小文件。 上面有关文本的部分中介绍了如何执行此操作。 <br> 除了检查是否可以访问Internet之外，还必须确定其类型（移动设备或WiFi），因为播放器不太可能希望下载数百兆的移动流量。 这可以通过<b>Application.internetReachability</b>属性完成。 <br><br><h3> 快取 </h3><br> 下一个也是最重要的问题之一是缓存下载的文件。 此缓存用于什么？ <br><br><ol><li> 节省流量（不要下载已经下载的数据） </li><li> 确保在没有Internet的情况下工作（您可以显示缓存中的数据）。 </li></ol><br> 需要缓存什么？ 这个问题的答案就是一切，您下载的所有文件都必须缓存。 如何执行此操作，请在下面考虑，并从简单的文本文件开始。 <br> 不幸的是，Unity没有内置的机制来缓存文本，纹理和音频文件。 因此，对于这些资源，有必要根据项目的需要编写系统或不编写系统。 在最简单的情况下，我们只是将文件写入高速缓存，并且在没有Internet的情况下，我们从文件中获取文件。 在稍微复杂一些的版本中（我在项目中使用了它），我们向服务器发送了一个请求，该请求返回json，指示存储在服务器上的文件的版本。 您可以使用<b>File</b>类的C＃类或您的团队方便接受的任何其他方式从缓存中写入和读取文件。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(<span class="hljs-string"><span class="hljs-string">"CachePath"</span></span>, <span class="hljs-string"><span class="hljs-string">"{0}.text"</span></span>.Fmt(fileName)); File.WriteAllText(cacheFilePath, data); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(<span class="hljs-string"><span class="hljs-string">"CachePath"</span></span>, <span class="hljs-string"><span class="hljs-string">"{0}.texture"</span></span>.Fmt(fileName)); File.WriteAllBytes(cacheFilePath, data); }</code> </pre><br> 同样，从缓存中获取数据。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTextFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(Utils.Path.Cache, <span class="hljs-string"><span class="hljs-string">"{0}.text"</span></span>.Fmt(fileName)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(cacheFilePath)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> File.ReadAllText(cacheFilePath); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Texture2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTextureFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheFilePath = Path.Combine(Utils.Path.Cache, <span class="hljs-string"><span class="hljs-string">"{0}.texture"</span></span>.Fmt(fileName)); Texture2D texture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(cacheFilePath)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = File.ReadAllBytes(cacheFilePath); texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); texture.LoadImage(data, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texture; }</code> </pre><br>  <b>注意</b> ： <i>为什么不使用带有表单文件url的同一UWR // //不加载纹理。</i>  <i>目前，存在问题，该文件根本无法加载，因此我不得不找到一种解决方法。</i> <br><br>  <b>注意</b> ： <i>我没有在项目中直接使用AudioClip，而是将所有此类数据存储在AssetBundle中。</i>  <i>但是，如有必要，可以使用AudioClip类GetData和SetData的功能轻松完成此操作。</i> <i><br></i> <br>  Unity的<b>AssetBundle</b>的简单资源，Unity具有内置的缓存机制。 让我们更详细地考虑它。 <br><br> 基本上，此机制可以使用两种方法： <br><br><ol><li> 使用CRC和版本号 </li><li> 使用哈希值 </li></ol><br> 原则上，您可以使用它们中的任何一个，但我自己决定哈希是最可接受的，因为我有自己的版本系统，并且它不仅考虑了<b>AssetBundle</b>版本，还考虑了应用程序的版本，因为捆绑通常可能与该版本不兼容，在商店中展示。 <br><br> 因此，如何完成缓存： <br><br><ol><li> 我们从清单服务器请求一个捆绑文件（此文件在创建时会自动创建，并包含对其包含的资产的描述以及哈希，CRC，大小等）。 该文件与捆绑包加上.manifest扩展名相同。 </li><li> 从清单中获取hash128值 </li><li> 我们向服务器创建一个请求以获取AssetBundle，其中除了url外，还指定接收到的hash128值 </li></ol><br><div class="spoiler">  <b class="spoiler_title">上述算法的代码：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadAssetBundleFromServerWithCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;AssetBundle&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,    while (!Caching.ready) { yield return null; } //     var request = UnityWebRequest.Get(url + ".manifest"); yield return request.SendWebRequest(); if (!request.isHttpError &amp;&amp; !request.isNetworkError) { Hash128 hash = default; // hash var hashRow = request.downloadHandler.text.ToString().Split("\n".ToCharArray())[5]; hash = Hash128.Parse(hashRow.Split(':')[1].Trim()); if (hash.isValid == true) { request.Dispose(); request = UnityWebRequestAssetBundle.GetAssetBundle(url, hash, 0); yield return request.SendWebRequest(); if (!request.isHttpError &amp;&amp; !request.isNetworkError) { response(DownloadHandlerAssetBundle.GetContent(request)); } else { response(null); } } else { response(null); } } else { response(null); } request.Dispose(); }</span></span></code> </pre><br></div></div><br> 在上面的示例中，Unity在查询服务器时，首先查看缓存中是否存在具有指定的hash128值的文件，如果是，则将其返回；否则，将下载更新的文件。 要在Unity中管理所有缓存文件，有一个<b>缓存</b>类，通过该类我们可以找出<b>缓存中</b>是否有文件，获取所有缓存的版本以及删除不必要的版本或完全清除它。 <br><br>  <b>注意</b> ： <i>为什么使用这种奇怪的方式获取哈希值？</i>  <i>这是由于以下事实：以文档中描述的方式获取hash128要求加载整个bundle，然后再从中以及从那里已经哈希值中接收<b>AssetBundleManifest</b>资产。</i>  <i>这种方法的缺点是整个AssetBundle都在摇摆，但是我们只需要避免这种情况。</i>  <i>因此，我们首先仅从服务器下载清单文件，并从中获取hash128，然后才在必要时下载捆绑文件，并且必须通过对行的解释来提取hash128的值。</i> <br><br><h3> 在编辑器模式下使用资源 </h3><br> 最后一个问题，或者更确切地说是调试和开发便利性的问题，是在编辑器模式下使用可下载的资源，如果常规文件没有问题，那么使用捆绑包就没有那么简单了。 当然，您可以每次构建它们的构建，将其上载到服务器，然后在Unity编辑器中启动应用程序，并观察一切工作原理，但是即使此描述听起来也像“拐杖”。 需要做一些事情， <b>AssetDatabase</b>类将为我们提供帮助。 <br><br> 为了统一使用包，我做了一个特殊的包装： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AssetBundleWrapper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AssetBundle _assetBundle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssetBundleWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AssetBundle assetBundle</span></span></span><span class="hljs-function">)</span></span> { _assetBundle = assetBundle; } }</code> </pre><br> 现在，根据我们是在编辑器中还是在构建中，我们需要添加两种使用资产的模式。 对于构建，我们对<b>AssetBundle</b>类的功能使用包装器，对于编辑器，我们使用上述的<b>AssetDatabase</b>类。 <br><br><div class="spoiler">  <b class="spoiler_title">因此，我们获得以下代码：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AssetBundleWrapper</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR private readonly List&lt;string&gt; _assets; public AssetBundleWrapper(string url) { var uri = new Uri(url); var bundleName = Path.GetFileNameWithoutExtension(uri.LocalPath); _assets = new List&lt;string&gt;(AssetDatabase.GetAssetPathsFromAssetBundle(bundleName)); } public T LoadAsset&lt;T&gt;(string name) where T : UnityEngine.Object { var assetPath = _assets.Find(item =&gt; { var assetName = Path.GetFileNameWithoutExtension(item); return string.CompareOrdinal(name, assetName) == 0; }); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!string.IsNullOrEmpty(assetPath)) { return AssetDatabase.LoadAssetAtPath&lt;T&gt;(assetPath); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { return default; } } public T[] LoadAssets&lt;T&gt;() where T : UnityEngine.Object { var returnedValues = new List&lt;T&gt;(); foreach(var assetPath in _assets) { returnedValues.Add(AssetDatabase.LoadAssetAtPath&lt;T&gt;(assetPath)); } return returnedValues.ToArray(); } public void LoadAssetAsync&lt;T&gt;(string name, Action&lt;T&gt; result) where T : UnityEngine.Object { result(LoadAsset&lt;T&gt;(name)); } public void LoadAssetsAsync&lt;T&gt;(Action&lt;T[]&gt; result) where T : UnityEngine.Object { result(LoadAssets&lt;T&gt;()); } public string[] GetAllScenePaths() { return _assets.ToArray(); } public void Unload(bool includeAllLoadedAssets = false) { _assets.Clear(); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> private readonly AssetBundle _assetBundle; public AssetBundleWrapper(AssetBundle assetBundle) { _assetBundle = assetBundle; } public T LoadAsset&lt;T&gt;(string name) where T : UnityEngine.Object { return _assetBundle.LoadAsset&lt;T&gt;(name); } public T[] LoadAssets&lt;T&gt;() where T : UnityEngine.Object { return _assetBundle.LoadAllAssets&lt;T&gt;(); } public void LoadAssetAsync&lt;T&gt;(string name, Action&lt;T&gt; result) where T : UnityEngine.Object { var request = _assetBundle.LoadAssetAsync&lt;T&gt;(name); TaskManager.Task.Create(request) .Subscribe(() =&gt; { result(request.asset as T); Unload(false); }) .Start(); } public void LoadAssetsAsync&lt;T&gt;(Action&lt;T[]&gt; result) where T : UnityEngine.Object { var request = _assetBundle.LoadAllAssetsAsync&lt;T&gt;(); TaskManager.Task.Create(request) .Subscribe(() =&gt; { var assets = new T[request.allAssets.Length]; for (var i = 0; i &lt; request.allAssets.Length; i++) { assets[i] = request.allAssets[i] as T; } result(assets); Unload(false); }) .Start(); } public string[] GetAllScenePaths() { return _assetBundle.GetAllScenePaths(); } public void Unload(bool includeAllLoadedAssets = false) { _assetBundle.Unload(includeAllLoadedAssets); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br></div></div><br>  <b>注意</b> ：该代码使用<b>TaskManager</b>类，下面将对其进行讨论，简而言之，这是使用<b>Coroutine</b>的包装器。 <br><br> 除上述内容外，在开发过程中查看我们下载的内容和当前在缓存中的内容也很有用。 为此，您可以利用设置自己的文件夹的功能，该文件夹将用于缓存（您也可以将下载的文本和其他文件写入同一文件夹）： <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR var path = Path.Combine(Directory.GetParent(Application.dataPath).FullName, "_EditorCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> var path = Path.Combine(Application.persistentDataPath, "_AppCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> Caching.currentCacheForWriting = Caching.AddCache(path);</span></span></code> </pre><br><h2> 我们编写网络请求管理器或使用Web服务器 </h2><br> 上面我们检查了在Unity中使用外部资源的主要方面，现在我想详细介绍API的实现，该API概括并统一了以上所有内容。 首先，让我们来谈谈网络查询管理器。 <br><br>  <b>注意</b> ： <i>此后，我们以<b>TaskManager</b>类的形式在<b>Coroutine上</b>使用包装器。</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我在另一篇文章中谈到了这个包装器</a> 。</i> <br><br> 让我们获得相应的类： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Network</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NetworkTypeEnum { None, Mobile, WiFi } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> NetworkTypeEnum NetworkType; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TaskManager _taskManager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskManager(); }</code> </pre><br> 应用程序需要<b>NetworkType</b>静态字段才能接收有关Internet连接类型的信息。 原则上，该值可以存储在任何地方，我决定将其放置在<b>Network</b>类中。 <br><br><div class="spoiler">  <b class="spoiler_title">添加向服务器发送请求的基本功能：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnityWebRequest request, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!Caching.ready) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (progress != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { request.SendWebRequest(); _currentRequests.Add(request); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!request.isDone) { progress(request.downloadProgress); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } progress(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.SendWebRequest(); } response(request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_currentRequests.Contains(request)) { _currentRequests.Remove(request); } request.Dispose(); }</code> </pre><br></div></div><br> 从代码中可以看到，与上一节中的代码相比，处理请求完成的方法已更改。 这是为了显示数据加载的进度。 同样，所有发送的请求都存储在列表中，以便在必要时可以将其取消。 <br><br><div class="spoiler">  <b class="spoiler_title">为AssetBundle添加基于链接的查询创建功能：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequestBundle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Hash128 hash, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequestAssetBundle.GetAssetBundle(url, hash, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebRequest(request, progress, response); }</code> </pre><br></div></div><br> 同样，为纹理，音频，文本，字节数组创建函数。 <br><br> 现在，您需要确保服务器通过Post命令发送数据。 通常，您需要将某些内容传递给服务器，然后根据确切的内容获得答案。 添加适当的功能。 <br><br><div class="spoiler">  <b class="spoiler_title">以键值集的形式发送数据：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequestPost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Dictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; formFields, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Post(url, formFields); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebRequest(request, progress, response); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">将数据作为json发送：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WebRequestPost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;UnityWebRequest&gt; response</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityWebRequest(url, UnityWebRequest.kHttpVerbPOST) { uploadHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UploadHandlerRaw(Encoding.UTF8.GetBytes(data)), downloadHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DownloadHandlerBuffer() }; request.uploadHandler.contentType = <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebRequest(request, progress, response); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">现在，我们将添加用于加载数据的公共方法，尤其是AssetBundle</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Hash128 hash, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action&lt;AssetBundle&gt; response, TaskManager.TaskPriorityEnum priority = TaskManager.TaskPriorityEnum.Default</span></span></span><span class="hljs-function">)</span></span> { _taskManager.AddTask(WebRequestBundle(url, hash, progress, (uwr) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!uwr.isHttpError &amp;&amp; !uwr.isNetworkError) { response(DownloadHandlerAssetBundle.GetContent(uwr)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarningFormat(<span class="hljs-string"><span class="hljs-string">"[Netowrk]: error request [{0}]"</span></span>, uwr.error); response(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }), priority); }</code> </pre><br></div></div><br> 同样，添加了纹理，音频文件，文本等方法。 <br><br><div class="spoiler">  <b class="spoiler_title">最后，我们添加了获取下载文件大小的功能和清除功能，以停止所有创建的请求。</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; response, TaskManager.TaskPriorityEnum priority = TaskManager.TaskPriorityEnum.Default</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = UnityWebRequest.Head(url); _taskManager.AddTask(WebRequest(request, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, uwr =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentLength = uwr.GetResponseHeader(<span class="hljs-string"><span class="hljs-string">"Content-Length"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(contentLength, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> returnValue)) { response(returnValue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response(<span class="hljs-number"><span class="hljs-number">-1</span></span>); } }), priority); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _taskManager.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _currentRequests) { request.Abort(); request.Dispose(); } _currentRequests.Clear(); }</code> </pre><br></div></div><br> 至此，我们用于网络请求的经理完成了。 如有必要，需要与服务器一起使用的游戏的每个子系统都可以创建自己的类实例。 <br><br><h2> 我们写加载外部资源的经理 </h2><br> 除了上述类之外，为了完全使用外部数据，我们还需要一个单独的管理器，该管理器不仅下载数据，而且还通知应用程序下载开始，完成，进度，可用空间不足以及缓存问题。 <br><br><div class="spoiler">  <b class="spoiler_title">我们开始相应的类，在我的情况下是一个单例</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExternalResourceManager</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ResourceEnumType { Text, Texture, AssetBundle } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Network _network = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Network(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExternalResourceManager</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR var path = Path.Combine(Directory.GetParent(Application.dataPath).FullName, "_EditorCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> var path = Path.Combine(Application.persistentDataPath, "_AppCache"); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!System.IO.Directory.Exists(path)) { System.IO.Directory.CreateDirectory(path); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_IOS UnityEngine.iOS.Device.SetNoBackupFlag(path); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } Caching.currentCacheForWriting = Caching.AddCache(path); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，设计器将文件夹设置为缓存，具体取决于我们是否在编辑器中。</font><font style="vertical-align: inherit;">另外，我们为Network类的实例设置了一个私有字段，我们在前面已经介绍过。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们将添加辅助功能以使用缓存，以及确定下载文件的大小并检查其可用空间。</font><font style="vertical-align: inherit;">在下面的内容中，将在使用AssetBundle的示例上给出代码，对于其余资源，所有操作均以此类推。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辅助功能代码</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearAssetBundleCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileName = GetFileNameFromUrl(url); Caching.ClearAllCachedVersions(fileName); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearAllRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _network.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssetBundleIsCached</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> manifestFileUrl = <span class="hljs-string"><span class="hljs-string">"{0}.manifest"</span></span>.Fmt(url); _network.Request(manifestFileUrl, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> manifest) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(manifest) ? <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> : GetHashFromManifest(manifest); result(Caching.IsVersionCached(url, hash)); } , TaskManager.TaskPriorityEnum.RunOutQueue); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckFreeSpace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { GetSize(url, lengthInMb =&gt; { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR_WIN var logicalDrive = Path.GetPathRoot(Utils.Path.Cache); var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(logicalDrive); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> UNITY_EDITOR_OSX var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> UNITY_IOS var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> UNITY_ANDROID var availableSpace = SimpleDiskUtils.DiskUtils.CheckAvailableSpace(true); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> result(availableSpace &gt; lengthInMb, lengthInMb); }); } public void GetSize(string url, Action&lt;float&gt; result) { _network.Request(url, length =&gt; result(length / 1048576f)); } private string GetFileNameFromUrl(string url) { var uri = new Uri(url); var fileName = Path.GetFileNameWithoutExtension(uri.LocalPath); return fileName; } private Hash128 GetHashFromManifest(string manifest) { var hashRow = manifest.Split("\n".ToCharArray())[5]; var hash = Hash128.Parse(hashRow.Split(':')[1].Trim()); return hash; }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，使用AssetBundle示例添加数据加载功能。</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAssetBundle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Action start, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action stop, Action&lt;AssetBundleWrapper&gt; result, TaskManager.TaskPriorityEnum taskPriority = TaskManager.TaskPriorityEnum.Default</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DONT_USE_SERVER_IN_EDITOR start?.Invoke(); result(new AssetBundleWrapper(url)); stop?.Invoke(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> void loadAssetBundle(Hash128 bundleHash) { start?.Invoke(); _network.Request(url, bundleHash, progress, (AssetBundle value) =&gt; { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(value != null) { _externalResourcesStorage.SetCachedHash(url, bundleHash); } result(new AssetBundleWrapper(value)); stop?.Invoke(); }, taskPriority); }; var manifestFileUrl = "{0}.manifest".Fmt(url); _network.Request(manifestFileUrl, null, (string manifest) =&gt; { var hash = string.IsNullOrEmpty(manifest) ? default : GetHashFromManifest(manifest); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!hash.isValid || hash == default) { hash = _externalResourcesStorage.GetCachedHash(url); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!hash.isValid || hash == default) { result(new AssetBundleWrapper(null)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { loadAssetBundle(hash); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Caching.IsVersionCached(url, hash)) { loadAssetBundle(hash); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { CheckFreeSpace(url, (spaceAvailable, length) =&gt; { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (spaceAvailable) { loadAssetBundle(hash); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { result(new AssetBundleWrapper(null)); NotEnoughDiskSpace.Call(); } }); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 那么此函数会发生什么： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预编译指令DONT_USE_SERVER_IN_EDITOR用于禁用从服务器实际加载捆绑软件。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第一步是向服务器发出请求，以获取捆绑软件的清单文件 </font></font></li><li>    -    ,    ,   -   ( <b>_externalResourcesStorage</b> )  ,  ,               (  ,     ),  ,   null  </li><li>     ,     Caching      ,       ,         (   ) </li><li>  ,     ,      ,   ,             -       (   ).   ,              (     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ) </li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是要理解为什么哈希值是分开存储的。</font><font style="vertical-align: inherit;">对于没有互联网，连接不稳定或出现某种网络错误并且无法从服务器下载捆绑软件的情况，这是必要的，在这种情况下，我们保证从那里从缓存中下载捆绑软件</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与上述方法类似，在管理器中，您可以/需要获取其他用于处理数据的功能：GetJson，GetTexture，GetText，GetAudio等。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，您需要获得一种允许您下载资源集的方法。</font><font style="vertical-align: inherit;">如果我们需要在应用程序启动时下载或更新某些内容，则此方法将非常有用。</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Dictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ResourceEnumType&gt; urls, Action start, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; progress, Action stop, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> commonProgress = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)urls.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentProgress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completeCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">progressHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { currentProgress += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; progress?.Invoke(currentProgress / commonProgress); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { completeCounter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completeCounter == urls.Count) { stop?.Invoke(); } }; start?.Invoke(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> urls.Keys) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resourceType = urls[url]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (resourceType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ResourceEnumType.Text: { GetText(url, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, progressHandler, completeHandler, (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached) =&gt; { result(url, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached); }); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ResourceEnumType.Texture: { GetTexture(url, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, progressHandler, completeHandler, (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached) =&gt; { result(url, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, isCached); }); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ResourceEnumType.AssetBundle: { GetAssetBundle(url, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, progressHandler, completeHandler, (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) =&gt; { result(url, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里值得了解</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的特殊性</font><font style="vertical-align: inherit;">，它在网络请求管理器中使用，默认情况下它可以工作，依次执行所有任务。因此，将相应地进行文件下载。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：对于那些不喜欢</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutine的人</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以将所有内容轻松转换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是在这种情况下，在本文中，我决定为初学者使用一个更易理解的选项（在我看来）。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我试图尽可能紧凑地描述使用游戏应用程序的外部资源。</font><font style="vertical-align: inherit;">在我的参与下，这些方法和代码用于已发布和正在开发的项目中。</font><font style="vertical-align: inherit;">它非常简单并且适用于与服务器之间不存在持续通信的简单游戏（MMO和其他复杂的f2p游戏），但是如果我们需要下载其他材料，语言，对购买的服务器端验证以及其他数据进行验证，则可以极大地简化工作。一次或不太经常在应用程序中使用。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引用的参考文献的文章</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assetstore.unity.com/packages/tools/simple-disk-utils-59382 </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/post/352296 </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/post/282524</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433366/">https://habr.com/ru/post/zh-CN433366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433356/index.html">攻击者学会了绕过两因素身份验证Yahoo Mail和Gmail</a></li>
<li><a href="../zh-CN433358/index.html">熟悉Python测试。 第一部分</a></li>
<li><a href="../zh-CN433360/index.html">科学家试图预测何时电动飞机将成为现实</a></li>
<li><a href="../zh-CN433362/index.html">UX中美观，简单和护理的9条原则</a></li>
<li><a href="../zh-CN433364/index.html">LDraw + Unity。 我如何产生乐高</a></li>
<li><a href="../zh-CN433368/index.html">如何将杂货店思维应用于世界：运动衫的一个例子</a></li>
<li><a href="../zh-CN433370/index.html">分片理论</a></li>
<li><a href="../zh-CN433372/index.html">汽车自行车</a></li>
<li><a href="../zh-CN433374/index.html">关于RTOS的全部真相。 第26条。 渠道：辅助服务和数据结构</a></li>
<li><a href="../zh-CN433376/index.html">麻省理工学院的课程“计算机系统安全”。 第21课：数据跟踪，第1部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>