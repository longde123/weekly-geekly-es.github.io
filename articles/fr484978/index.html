<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎧 🌋 🎏 PubSub est presque gratuit: NOTIFY fonctionnalités de PostgreSQL 🌥️ 💕 🏚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vos microservices utilisent déjà une base de données PostgreSQL commune pour stocker des données, ou si plusieurs instances du même service l'utili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PubSub est presque gratuit: NOTIFY fonctionnalités de PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484978/">  Si vos microservices <u>utilisent déjà une base de données PostgreSQL commune</u> pour stocker des données, ou si plusieurs instances du même service l'utilisent sur des serveurs différents, il est relativement <b>bon marché d'avoir la possibilité d'échanger des messages</b> (PubSub) entre eux sans intégration dans l'architecture Redis, le cluster RabbitMQ ou l'incorporation dans le code applications d' <a href="https://habr.com/ru/post/326880/">un autre système MQ</a> . <br><br>  Pour cela, nous <b>n'écrirons pas de</b> <a href="https://habr.com/ru/post/483014/">messages dans les tables de la base de données</a> , car cela entraîne trop de surcharge, d'abord pour <a href="https://habr.com/ru/company/postgrespro/blog/459250/">écrire</a> ce qui est <a href="https://habr.com/ru/company/postgrespro/blog/459250/">transmis</a> , puis aussi pour <a href="https://habr.com/post/481866/">effacer de ce qui a déjà été lu</a> . <br><br>  Nous transmettrons et recevrons des données à l'aide du mécanisme <a href="https://postgrespro.ru/docs/postgresql/12/sql-notify">NOTIFY</a> / <a href="https://postgrespro.ru/docs/postgresql/12/sql-listen">LISTEN</a> , et nous collecterons une implémentation de modèle pour Node.js. <br><br><img src="https://habrastorage.org/webt/er/e_/dv/ere_dvhj_y3sjkypbqeezzg_xn4.png"><br><br>  Mais sur ce chemin, il y a un râteau qui devra être soigneusement contourné. <br><a name="habracut"></a><br><h2>  Caractéristiques du protocole </h2><br><h4>  Écoutez </h4><br><pre><code class="sql hljs">LISTEN </code> </pre> <blockquote>  Une application utilisant la bibliothèque libpq exécute la commande LISTEN en tant que commande SQL standard, puis elle doit périodiquement appeler la fonction PQnotifies pour vérifier les nouvelles notifications. </blockquote>  Si vous n'écrivez pas une bibliothèque pour travailler avec PG, mais déjà une application spécifique, dans la plupart des cas, vous n'aurez pas accès à l'appel à cette fonction. <br><br>  Mais si une telle bibliothèque a déjà été écrite pour vous conformément aux recommandations de traitement <a href="https://postgrespro.ru/docs/postgresql/12/libpq-async">des demandes</a> et <a href="https://postgrespro.ru/docs/postgresql/12/libpq-notify">notifications</a> <a href="https://postgrespro.ru/docs/postgresql/12/libpq-async">asynchrones</a> , vous recevrez automatiquement un message dans le code de l'application.  Sinon, vous pouvez simplement <b>exécuter périodiquement <code>SELECT 1</code></b> sur la connexion, puis une notification accompagnera le résultat de la requête: <blockquote>  Dans les versions très anciennes de libpq, il n'y avait qu'une seule façon de garantir la réception en temps opportun des messages de la commande NOTIFY - d'envoyer constamment des commandes, même vides, puis de vérifier PQnotifies après chaque appel PQexec.  Bien que cette méthode fonctionne toujours, elle est considérée comme obsolète en raison d'une utilisation inefficace du processeur. </blockquote>  En termes de <a href="https://postgrespro.ru/docs/postgresql/12/app-psql">psql</a> , par exemple <a href="https://postgrespro.ru/docs/postgresql/12/app-psql">,</a> cela ressemble à ceci: <br><br><pre> <code class="plaintext hljs">_tmp=# LISTEN test; LISTEN _tmp=# SELECT 1; ?column? ---------- 1 (1 row) Asynchronous notification "test" with payload "abc123" received from server process with PID 63991.</code> </pre><br>  Si pour une tâche appliquée, nous pouvons convenir d'un délai maximum pour la livraison d'un message en 1 seconde, avec un tel intervalle, nous exécutons la demande.  Dans le même temps, cette méthode permet de <b>surveiller la «vivacité» de la connexion</b> , en veillant à ce que personne ne la coupe accidentellement du côté serveur via <code>pg_terminate_backend</code> , ou qu'il n'y ait pas eu de «plantage» soudain du PG sans aucune notification aux clients. <br><br><h4>  NOTIFIER </h4><br><pre> <code class="sql hljs">NOTIFY  [ ,  ]</code> </pre> <br><blockquote>  La commande NOTIFY envoie un événement de notification ainsi qu'une ligne de «message» supplémentaire à toutes les applications clientes qui ont précédemment exécuté un canal avec le nom de canal spécifié dans la base de données LISTEN actuelle. <br>  ... <br>  La ligne "message" qui sera transmise avec la notification ... doit être une <a href="https://postgrespro.ru/docs/postgresql/12/sql-syntax-lexical">simple constante de texte</a> .  Dans une configuration standard, sa <b>longueur doit être inférieure à 8 000 octets</b> . </blockquote>  Autrement dit, si notre «message» contient soudainement quelque chose de très différent de l'ASCII, alors nous <u>devrons le filtrer</u> , et s'il dépasse la taille de 8000 octets (pas de caractères!), Puis le <u>couper en blocs et le coller</u> .  Dans le même temps, nous devons économiser à la fois la bande passante du canal et les ressources du serveur pour traiter le transfert de ces blocs - c'est-à-dire, ajouter le moins de «liaison» de service possible au contenu utile, mais également ne pas «étrangler» l'application cliente, la forçant à emballer avec <code>gzip -9</code> . <br><br>  Parmi les avantages supplémentaires du mécanisme, on peut également noter la liaison à la "source" du message ... <br><blockquote>  ... un travail supplémentaire peut être évité en vérifiant si le <b>PID du processus de signalisation</b> (indiqué dans les données d'événement) correspond au PID de la session (vous pouvez le trouver en contactant libpq).  S'ils correspondent, la session a reçu une notification de ses propres actions, afin qu'elle puisse être ignorée. </blockquote>  ... et bon de livraison garanti: <br><blockquote>  Outre le filtrage des instances ultérieures de notifications en double, NOTIFY garantit que les notifications d'une transaction unique arrivent toujours dans le même ordre dans lequel elles ont été envoyées.  Il est également garanti que les <b>messages de différentes transactions arrivent dans l'ordre dans lequel ces transactions sont validées</b> . </blockquote>  Nous ne combinerons rien spécifiquement, donc chacune de nos demandes correspondra simplement à une transaction distincte. <br><br>  Mais rappelez-vous que s'il y a également une activité d'application sur la connexion utilisée pour l'échange, notre NOTIFY peut ne pas être dans la transaction de notre propre gré, donc <u>des effets secondaires peuvent se produire</u> : <br><blockquote>  Les transactions ont un impact significatif sur NOTIFY.  Premièrement, si NOTIFY est exécuté à l'intérieur d'une transaction, les notifications sont envoyées aux destinataires une fois la transaction validée, et uniquement dans ce cas.  Ceci est raisonnable, car <b>en cas d'interruption d'une transaction, l'action de toutes les commandes qu'elle contient est annulée, y compris NOTIFY</b> . </blockquote>  Par conséquent, il est préférable d'utiliser une connexion où il n'y a évidemment pas de transactions ou de longues requêtes. <br><br><h4>  AccessExclusiveLock sur l'objet 0 de la classe 1262 de la base de données 0 </h4><br>  Si tout à coup vos NOTIFY ont commencé à émousser et à enregistrer l'attente d'une telle serrure, alors vous avez toujours "grandi en pantalon court", et il est temps de penser au MQ "adulte". <br><br>  Après tout, la file d'attente de notification, bien qu'assez grande (8 Go dans les versions standard), est toujours limitée.  Selon <a href="">la réponse de Tom Lane</a> : <br><blockquote>  <i>Ce verrou est maintenu lors de l'insertion du ou des messages de notification de la transaction, après quoi la transaction valide et libère le verrou.</i> </blockquote>  Autrement dit, il n'y a pas trop d'options pour contourner: <br><br><ul><li>  <b>envoyer mais moins souvent</b> <br>  Autrement dit, pour agréger les indicateurs envoyés, s'il s'agit de certains compteurs, sur un intervalle plus long. </li><li>  <b>envoyer moins</b> <br>  Par exemple, pour supprimer «par défaut» du point de vue des valeurs de clé d'application du JSON transmis. </li><li>  <b>envoyer uniquement du signal</b> , pas de contenu du tout <br>  En option - pour démarrer plusieurs chaînes, le nom de chacune portera déjà en soi un certain sens appliqué. </li><li>  toujours <b>faire un envoi à partir de la base de données</b> </li></ul><br><h2>  Envoi de messages complexes </h2><br><h4>  Encodage du corps </h4><br>  Dans le cas général, nous pouvons vouloir transmettre dans le message non seulement des caractères autorisés, mais aussi des lettres russes et «tous les binaires» - par conséquent, il serait pratique d'utiliser la <u>conversion en représentation hexadécimale</u> pour former la chaîne transmise.  Et oui, cette méthode fonctionne plutôt bien: <br><br><pre> <code class="sql hljs">NOTIFY test, E'\x20\x21'</code> </pre> <br><pre> <code class="plaintext hljs">Asynchronous notification "test" with payload " !" received from server process with PID 63991.</code> </pre> <br>  Mais revenons à la documentation: <br><blockquote>  Vous devez vous assurer que les séquences d'octets que vous créez de cette manière, en particulier en notation octale et hexadécimale, forment <b>des caractères codés par le serveur valides</b> .  Lorsque le serveur fonctionne avec le codage UTF-8, au lieu d'un tel enregistrement d'octets, utilisez des séquences spéciales Unicode ou la syntaxe alternative Unicode décrite à la section 4.1.2.3.  (Sinon, vous devrez encoder manuellement les caractères UTF-8 et les écrire par octets, ce qui est très gênant.) </blockquote>  Par conséquent, même avec le symbole banal de la patte de guillemet de win1251, nous prenons du pain dans la douleur: <br><br><pre> <code class="sql hljs">NOTIFY test, E'\x98' <span class="hljs-comment"><span class="hljs-comment">-- ERROR: invalid byte sequence for encoding "UTF8": 0x98</span></span></code> </pre> <br>  Comme nous ne voulons pas " <i>coder manuellement les caractères UTF-8 et les écrire par octets</i> ", nous accepterons immédiatement d'envoyer le corps du message <b>emballé en base64</b> s'il y a des caractères en dehors de la plage <code>\x20-\x7E</code> ou, si nécessaire, une segmentation.  D'une part, cette méthode de packaging n'augmente pas trop la redondance (coefficient 4: 3), d'autre part, elle est implémentée au niveau des bibliothèques système dans n'importe quelle langue et fournira une charge supplémentaire minimale. <br><br>  Mais même si nous n'avons pas de caractères «étranges» et que le message tient dans un segment, il y a encore une fonctionnalité - <b>échapper à l'apostrophe</b> : <br><blockquote>  Pour inclure une apostrophe dans une ligne, écrivez <u>deux apostrophes</u> à <u>côté d'elle</u> , par exemple: «Jeanne d'Arc».  Notez que ce n'est pas la même chose que les guillemets doubles ("). </blockquote><br><h4>  Identification de segment </h4><br>  La tâche suivante consiste à "couper" correctement le message en <b>blocs</b> autorisés pour la transmission <b>de 7999 octets</b> , si sa taille dépasse soudainement cette valeur.  Et pour que le destinataire puisse le récupérer sans casser l'ordre ou tomber dans la chaîne des segments «étrangers».  Pour cela, chacun d'eux doit être identifié d'une manière ou d'une autre. <br><br>  En fait, nous connaissons déjà les deux «coordonnées» - c'est le <u>PID du processus d'envoi</u> et le <u>nom du canal</u> qui vient dans chaque notification.  Et l'ordre d'arrivée des segments nous est garanti par le protocole lui-même. <br><br><div class="spoiler">  <b class="spoiler_title">Écriture de voisins</b> <div class="spoiler_text">  Nous ne considérerons pas le cas lorsque <i>plusieurs écrivains sur le même canal</i> sont actifs en même temps que la <i>connexion à la base de données</i> (c'est-à-dire, évidemment dans le même processus de demande).  Techniquement, cela peut être pris en charge en passant un identifiant supplémentaire dans l'en-tête du segment - mais il est préférable de «partager» un seul objet PubSub à l'intérieur de votre application. <br></div></div><br><h4>  Limite de conteneur </h4><br>  Pour assembler un conteneur intégral à partir de plusieurs segments, nous devons connaître le moment de sa réalisation.  Il y a deux manières typiques de procéder: <br><br><ul><li>  transfert de la taille cible (en octets ou segments) dans le premier d'entre eux </li><li>  transmission du signe [pas] du dernier segment dans chacun d'eux </li></ul><br>  Puisque nous écrivons PubSub après tout, la plupart de nos messages seront courts et il n'est pas rentable de réserver beaucoup d'octets pour le transfert de taille.  Par conséquent, nous utiliserons la deuxième méthode, ayant réservé le <u>premier caractère des données de segment</u> comme indicateur de continuation / fin du conteneur. <br><br><h4>  Transfert d'objets </h4><br>  Afin de transmettre à la fois des chaînes de texte brut et des objets JSON en tant que «message», nous ajoutons <u>un signe</u> de <u>symbole supplémentaire</u> pour la transformation inverse du côté destinataire. <br><br>  Puisque nous avons décidé d'encoder "non-format" en base64, pour les drapeaux, nous pouvons prendre tous les caractères autorisés qui ne sont pas dans cet ensemble. <br><br>  Au total, nous avons obtenu les options suivantes pour les segments transmis: <br><br><pre> <code class="plaintext hljs">-- ""   !simple string -- "  "  @{"a":1} --    base64 #&lt;segment&gt; --    base64 $&lt;segment&gt;</code> </pre><br>  Comme vous pouvez le voir, il suffit d'analyser lors de la réception d'un segment uniquement le premier caractère pour comprendre ce que vous devez en faire. <br><br><h2>  Écrire une implémentation PubSub </h2><br>  Notre application sera sur Node.js, nous allons donc utiliser le <a href="https://www.npmjs.com/package/pg">module node-postgres</a> pour travailler avec PostgreSQL. <br><br><div class="spoiler">  <b class="spoiler_title">On écrit la trame de départ</b> <div class="spoiler_text">  Pour commencer, créons PubSub en tant qu'héritier de l' <a href="https://nodejs.org/dist/latest-v12.x/docs/api/events.html">EventEmitter</a> , afin de pouvoir générer des événements pour ceux qui se sont abonnés à des chaînes spécifiques: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PubSub = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connection, interval, skipSelf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     this.connection = connection; //        this.connection.on('notification', p._onmessage.bind(this)); //         this.skipSelf = skipSelf; //  "" setInterval(() =&gt; { this.connection.query('SELECT 1'); }, interval); //     ""  this.slices = {}; }; util.inherits(PubSub, EventEmitter); const p = PubSub.prototype;</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Nous travaillons avec des canaux</b> <div class="spoiler_text">  Étant donné que LISTEN / UNLISTEN ne jure en aucune façon lors de la réinscription à une chaîne ou de la désinscription de ce à quoi nous n'étions pas abonnés, nous ne compliquerons rien. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     - "",      //     -        const quot = str =&gt; /^[_a-z][0-9a-z_\$]*$/.test(str) ? str : `"${str}"`; p.subscribe = function(channel) { this.connection.query(`LISTEN ${quot(channel)}`); return this; }; p.unsubscribe = function(channel) { this.connection.query(`UNLISTEN ${quot(channel)}`); return this; };</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Envoi et réception de messages</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_LIMIT = <span class="hljs-number"><span class="hljs-number">8000</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_STR = <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_OBJ = <span class="hljs-string"><span class="hljs-string">'@'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_SEQ = <span class="hljs-string"><span class="hljs-string">'#'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_FIN = <span class="hljs-string"><span class="hljs-string">'$'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_SZ_HEAD = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_SZ_DATA = PAYLOAD_LIMIT - PAYLOAD_SZ_HEAD; <span class="hljs-comment"><span class="hljs-comment">//  ""  const reASCII = /^[\x20-\x7E]*$/; //  p.publish = function(channel, payload) { let query = `NOTIFY ${quot(channel)}`; if (payload !== null &amp;&amp; payload !== undefined) { //    -    let str = typeof payload == 'string' ? PAYLOAD_FL_STR + payload : PAYLOAD_FL_OBJ + JSON.stringify(payload); if (str.length &gt; PAYLOAD_LIMIT || !reASCII.test(str)) { //   base64- const b64 = Buffer.from(str).toString('base64'); for (let pos = 0, len = b64.length; pos &lt; len; pos += PAYLOAD_SZ_DATA) { let fin = pos + PAYLOAD_SZ_DATA; let seg = fin &gt;= len ? PAYLOAD_FL_FIN + b64.slice(pos) : PAYLOAD_FL_SEQ + b64.slice(pos, fin); this.connection.query(`${query}, '${seg}'`); } } else { //        ? //     str = str.replace(/'/g, "''"); this.connection.query(`${query}, '${str}'`); } } else { //       this.connection.query(query); } return this; }; //    p._onmessage = function(msg) { const {processId, channel, payload} = msg; //  "" if (processId == this.connection.processID &amp;&amp; this.skipSelf) { return; } // ""  const id = `${processId}:${channel}`; let rv; //   let fl = payload.charAt(0); if (fl == PAYLOAD_FL_SEQ || fl == PAYLOAD_FL_FIN) { // base64 const str = payload.slice(PAYLOAD_SZ_HEAD); const slices = this.slices; let b64; if (fl == PAYLOAD_FL_FIN) { //   if (slices[id]) { slices[id].push(str); b64 = slices[id].join(''); delete slices[id]; } else { b64 = str; } } else { //     if (slices[id]) { slices[id].push(str); } else { slices[id] = [str]; } } if (b64) { rv = Buffer.from(b64, 'base64').toString(); fl = rv.charAt(0); } } else { //  / rv = payload; } if (rv !== undefined) { //   '' let res = { processId , channel }; if (rv) { //       let data = rv.slice(1); res.payload = fl == PAYLOAD_FL_OBJ ? JSON.parse(data) : data; } this.emit(channel, res); } };</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Quelques tests</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pg = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pgsql = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pg.Client({ <span class="hljs-attr"><span class="hljs-attr">host</span></span> : <span class="hljs-string"><span class="hljs-string">'example-db'</span></span> , <span class="hljs-attr"><span class="hljs-attr">port</span></span> : <span class="hljs-number"><span class="hljs-number">5432</span></span> , <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> , <span class="hljs-attr"><span class="hljs-attr">password</span></span> : <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> , <span class="hljs-attr"><span class="hljs-attr">database</span></span> : <span class="hljs-string"><span class="hljs-string">'_tmp'</span></span> }); pgsql.connect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> psA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSub(pgsql, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> psB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSub(pgsql, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chA = <span class="hljs-string"><span class="hljs-string">'channel:A'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chB = <span class="hljs-string"><span class="hljs-string">'channel:B'</span></span>; psA.subscribe(chA); psB.subscribe(chB); psA.on(chA, (msg) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'A:rcv'</span></span>, msg); }); psB.on(chB, (msg) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'B:rcv'</span></span>, msg); }); psB.publish(chA); psB.publish(chA, <span class="hljs-string"><span class="hljs-string">'simple string'</span></span>); psB.publish(chA, <span class="hljs-string"><span class="hljs-string">'  '</span></span>); psB.publish(chA, {<span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>}); psA.publish(chB, <span class="hljs-string"><span class="hljs-string">'   100  '</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">100</span></span>)); });</code> </pre></div></div><br>  Tout est assez simple, vous pouvez donc l'implémenter facilement sur n'importe quel autre PL utilisé dans votre projet, en prenant comme exemple la base pour travailler avec des notifications asynchrones: <br><br><ul><li>  <a href="http://initd.org/psycopg/docs/advanced.html">Python</a> </li><li>  <a href="https://tapoueh.org/blog/2018/07/postgresql-listen-notify/">Allez</a> </li><li>  <a href="https://omniti.com/seeds/stop-collaborate-and-listen-notify.html">Perl</a> </li><li>  <a href="https://blog.lelonek.me/listen-and-notify-postgresql-commands-in-elixir-187c49597851">Elixir</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484978/">https://habr.com/ru/post/fr484978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484964/index.html">Configuration de l'équilibrage de charge sur InfoWatch Traffic Monitor</a></li>
<li><a href="../fr484966/index.html">Modèle prêt à l'emploi pour les tests à l'aide de Spring</a></li>
<li><a href="../fr484968/index.html">WPF DataGrid. Battez-vous pour le modèle</a></li>
<li><a href="../fr484972/index.html">Wine 5.0 est sorti</a></li>
<li><a href="../fr484974/index.html">Tuiles Wang pour la simulation de la machine de Turing</a></li>
<li><a href="../fr484982/index.html">Est-il facile d'organiser votre entreprise pour un spécialiste informatique</a></li>
<li><a href="../fr484984/index.html">Développeur de jeux Unity. Nouveau cours d'OTUS</a></li>
<li><a href="../fr484990/index.html">Luxoft TechTalks - podcasts vidéo de gourous informatiques mondiaux et plus</a></li>
<li><a href="../fr484992/index.html">Plus joli dans les grands projets: passez 20 minutes sur la configuration, oubliez le formatage pour toujours</a></li>
<li><a href="../fr484996/index.html">PBX virtuel Beeline. Ce que le manager ne vous dira pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>