<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåè üë®üèæ‚Äçüåæ üç∏ OpenSceneGraph: Plugin-System üï∑Ô∏è üóª ü§≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 In fr√ºheren Lektionen wurde bereits gesagt, dass OSG das Laden verschiedener Arten von Ressourcen unterst√ºtzt, z. B. Rasterbilder, 3D-Mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Plugin-System</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438296/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  In fr√ºheren Lektionen wurde bereits gesagt, dass OSG das Laden verschiedener Arten von Ressourcen unterst√ºtzt, z. B. Rasterbilder, 3D-Modelle in verschiedenen Formaten oder beispielsweise Schriftarten √ºber ein eigenes Plug-In-System.  Das OSG-Plugin ist eine separate Komponente, die die Funktionalit√§t der Engine erweitert und √ºber eine innerhalb des OSG standardisierte Schnittstelle verf√ºgt.  Das Plugin ist als dynamische gemeinsam genutzte Bibliothek implementiert (DLL unter Windows, also unter Linux usw.).  Die Namen der Plugin-Bibliotheken entsprechen einer bestimmten Konvention <br><br><pre><code class="plaintext hljs">osgdb_&lt; &gt;.dll</code> </pre> <br>  Das hei√üt, der Name des Plugins enth√§lt immer das Pr√§fix osgdb_.  Eine Dateierweiterung teilt der Engine mit, welches Plug-In zum Herunterladen einer Datei mit dieser Erweiterung verwendet werden soll.  Zum Beispiel, wenn wir eine Funktion in Code schreiben <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>);</code> </pre><br>  Die Engine sieht die Erweiterung osg und l√§dt ein Plugin mit dem Namen osgdb_osg.dll (oder osgdb_osg.so bei Linux).  Der Plugin-Code erledigt die ganze Drecksarbeit, indem er uns einen Zeiger auf einen Knoten zur√ºckgibt, der das Cessna-Modell beschreibt.  Ebenso wird versucht, ein PNG-Bild zu laden <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg:Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.png"</span></span>);</code> </pre><br>  Dadurch wird das Plugin osgdb_png.dll geladen, das einen Algorithmus zum Lesen von Daten aus einem PNG-Bild und zum Platzieren dieser Daten in einem Objekt vom Typ osg :: Image implementiert. <br><a name="habracut"></a><br>  Alle Operationen zur Arbeit mit externen Ressourcen werden durch die Funktionen der osgDB-Bibliothek implementiert, mit denen wir die Programme immer von Beispiel zu Beispiel verkn√ºpfen.  Diese Bibliothek basiert auf dem OSG-Plugin-System.  Bisher enth√§lt das OSG-Paket viele Plug-Ins, die mit den meisten in der Praxis verwendeten Bildformaten, 3D-Modellen und Schriftarten funktionieren.  Plugins bieten sowohl das Lesen von Daten (Importieren) eines bestimmten Formats als auch das Schreiben von Daten in eine Datei des erforderlichen Formats (Exportieren).  Insbesondere mit dem Dienstprogramm osgconv k√∂nnen Sie Daten von einem Format in ein anderes konvertieren, z. B. das Plug-In-System. <br><br><pre> <code class="plaintext hljs">$ osgconv cessna.osg cessna.3ds</code> </pre><br>  Es konvertiert das cessna osg-Modell einfach und nat√ºrlich in das 3DS-Format, das dann in einen 3D-Editor importiert werden kann, z. B. in Blender (es gibt √ºbrigens eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterung f√ºr die direkte Arbeit mit osg</a> f√ºr Blender). <br><br><img src="https://habrastorage.org/webt/vy/dm/qm/vydmqm2a3evtdqxu2vtf_kknmrw.png"><br><br>  Es gibt eine offizielle Liste von Standard-OSG-Plugins mit einer Beschreibung ihres Zwecks, aber sie ist lang und ich bin zu faul, um sie hierher zu bringen.  Es ist einfacher, den Installationspfad der Bibliothek im Ordner bin / ospPlugins-xyz anzuzeigen, wobei x, y, z die OSG-Versionsnummer ist.  Aus dem Namen der Plugin-Datei ist leicht ersichtlich, welches Format sie verarbeitet. <br><br>  Wenn das OSG vom MinGW-Compiler kompiliert wird, wird dem Standardnamen des Plugins ein zus√§tzliches Pr√§fix mingw_ hinzugef√ºgt, dh der Name sieht folgenderma√üen aus <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;.dll</code> </pre><br>  Die in der DEBUG-Konfiguration kompilierte Version des Plugins ist zus√§tzlich mit dem Suffix d am Ende des Namens ausgestattet, dh das Format wird sein <br><br><pre> <code class="plaintext hljs">osgdb_&lt; &gt;d.dll</code> </pre><br>  oder <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;d.dll</code> </pre><br>  beim Zusammenbau von MinGW. <br><br><h1>  1. Plugins Pseudo-Lader </h1><br>  Einige OSG-Plugins erf√ºllen die Funktionen sogenannter Pseudo-Loader. Dies bedeutet, dass sie nicht an eine bestimmte Dateierweiterung gebunden sind. Durch Hinzuf√ºgen eines Suffixes am Ende des Dateinamens k√∂nnen Sie beispielsweise angeben, welches Plug-In zum Herunterladen dieser Datei verwendet werden soll <br><br><pre> <code class="plaintext hljs">$ osgviewer worldmap.shp.ogr</code> </pre><br>  In diesem Fall lautet der tats√§chliche Name der Datei auf der Festplatte worldmap.shp. In dieser Datei wird eine Weltkarte im ESRI-Shapefile-Format gespeichert.  Das Suffix .ogr weist die osgDB-Bibliothek an, das Plugin osgdb_ogr zum Laden dieser Datei zu verwenden.  Andernfalls wird das Plugin osgdb_shp verwendet. <br><br>  Ein weiteres gutes Beispiel ist das Plugin osgdb_ffmpeg.  Die FFmpeg-Bibliothek unterst√ºtzt √ºber 100 verschiedene Codecs.  Um eines davon zu lesen, k√∂nnen wir einfach das Suffix .ffmpeg nach dem Namen der Mediendatei hinzuf√ºgen. <br><br>  Dar√ºber hinaus erm√∂glichen uns einige Pseudo-Lader, eine Reihe von Parametern durch ein Suffix zu √ºbergeben, die sich auf den Status des geladenen Objekts auswirken. Dies ist uns bereits in einem Beispiel mit Animation begegnet <br><br><pre> <code class="cpp hljs">node = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  Die Zeile 0.90 zeigt dem osgdb_osg-Plugin die anf√§nglichen Orientierungsparameter des geladenen Modells an.  Einige Pseudo-Lader ben√∂tigen zum Arbeiten vollst√§ndig spezifische Parameter. <br><br><h1>  2. API zum Entwickeln von Plugins von Drittanbietern </h1><br>  Es ist v√∂llig logisch, wenn Sie nach all dem Lesen die Idee hatten, dass es wahrscheinlich nicht schwierig sein w√ºrde, ein eigenes Plug-In f√ºr OSG zu schreiben, mit dem Sie ein nicht standardm√§√üiges Format von 3D-Modellen oder Bildern importieren k√∂nnen.  Und das ist ein wahrer Gedanke!  Der Plugin-Mechanismus wurde nur entwickelt, um die Funktionalit√§t der Engine zu erweitern, ohne das OSG selbst zu √§ndern.  Um die Grundprinzipien des Schreibens eines Plugins zu verstehen, versuchen wir, ein einfaches Beispiel zu implementieren. <br><br>  Die Entwicklung des Plugins besteht darin, die von OSG bereitgestellte virtuelle Lese- / Schreibschnittstelle zu erweitern.  Diese Funktionalit√§t wird von der virtuellen Klasse osgDB :: ReaderWriter bereitgestellt.  Diese Klasse bietet eine Reihe von virtuellen Methoden, die vom Plugin-Entwickler neu definiert wurden. <br><table><thead><tr><th>  Methode </th><th>  Beschreibung </th></tr></thead><tbody><tr><td>  unterst√ºtztExtensions () </td><td>  Es werden zwei Zeichenfolgenparameter akzeptiert: Dateierweiterung und Beschreibung.  Die Methode wird immer im Konstruktor der Unterklasse aufgerufen. </td></tr><tr><td>  akzeptiertExtension () </td><td>  Gibt true zur√ºck, wenn die als Argument √ºbergebene Erweiterung vom Plugin unterst√ºtzt wird </td></tr><tr><td>  fileExists () </td><td>  Hier k√∂nnen Sie feststellen, ob eine bestimmte Datei auf der Festplatte vorhanden ist (der Pfad wird als Parameter √ºbergeben) (gibt bei Erfolg true zur√ºck). </td></tr><tr><td>  readNode () </td><td>  Akzeptiert den Dateinamen und die Optionen als osgDB :: Option-Objekt.  Funktionen zum Lesen von Daten aus einer Datei werden vom Entwickler implementiert </td></tr><tr><td>  writeNode () </td><td>  Akzeptiert den Knotennamen, den gew√ºnschten Dateinamen und die Optionen.  Die Funktionen zum Schreiben von Daten auf die Festplatte werden vom Entwickler implementiert </td></tr><tr><td>  readImage () </td><td>  Lesen von Festplatten-Bitmap-Daten </td></tr><tr><td>  writeImage () </td><td>  Schreiben einer Bitmap auf die Festplatte </td></tr></tbody></table><br>  Die Implementierung der Methode readNode () kann durch den folgenden Code beschrieben werden <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         bool recognizableExtension = ...; bool fileExists = ...; if (!recognizableExtension) return ReadResult::FILE_NOT_HANDLED; if (!fileExists) return ReadResult::FILE_NOT_FOUND; //          osg::Node *root = ...; //       -     . //    -      bool errorInParsing = ...; if (errorInParsing) return ReadResult::ERROR_IN_READING_FILE; return root; }</span></span></code> </pre><br>  Es ist ein wenig √ºberraschend, dass die Methode anstelle eines Zeigers auf den Knoten des Szenendiagramms den Typ osgDB :: ReaderWriter :: ReadResult zur√ºckgibt.  Dieser Typ ist ein Leseergebnisobjekt und kann als Knotencontainer, Bild, Statusaufz√§hler (z. B. FILE_NOT_FOUND), ein anderes spezielles Objekt oder sogar als Fehlermeldung verwendet werden.  Es gibt viele implizite Konstruktoren zum Implementieren der beschriebenen Funktionen. <br><br>  Eine weitere n√ºtzliche Klasse ist osgDB :: Options.  Mit den Methoden setOptionString () und getOptionString () k√∂nnen Sie eine Reihe von Ladeoptionen festlegen oder abrufen.  Das √úbergeben dieser Zeichenfolge an den Konstruktor dieser Klasse als Argument ist ebenfalls zul√§ssig. <br><br>  Der Entwickler kann das Verhalten des Plugins steuern, indem er die Einstellungen in der Parameterzeichenfolge festlegt, die beispielsweise beim Laden des Objekts √ºbergeben wird <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    osg::Node* node1 = osgDB::readNodeFile("cow.osg"); //     string osg::Node* node2 = osgDB::readNodeFile("cow.osg", new osgDB::Options(string));</span></span></code> </pre><br><h1>  3. Datenflussverarbeitung im OSG-Plugin </h1><br>  Die Basisklasse osgDB :: ReaderWriter enth√§lt eine Reihe von Methoden, die die Daten von Eingabe- / Ausgabestreams verarbeiten, die von der Standard-C ++ - Bibliothek bereitgestellt werden.  Der einzige Unterschied zwischen diesen Lese- / Schreibmethoden und den oben beschriebenen besteht darin, dass sie anstelle des Dateinamens std :: istream &amp; Eingabestreams oder std :: ostream &amp; Ausgabestream akzeptieren.  Die Verwendung eines Datei-E / A-Streams ist immer der Verwendung eines Dateinamens vorzuziehen.  Um Dateilesevorg√§nge auszuf√ºhren, k√∂nnen wir das folgende Schnittstellendesign verwenden: <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... osgDB::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file.c_str(), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadResult::ERROR_IN_READING_FILE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readNode(stream, options); } ... osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         osg::Node *root = ...; return root; }</span></span></code> </pre><br>  Nach der Implementierung des Plugins k√∂nnen wir die Standardfunktionen osgDB :: readNodeFile () und osgDB :: readImageFile () verwenden, um Modelle und Bilder zu laden, indem wir einfach den Dateipfad angeben.  OSG findet das von uns geschriebene Plugin und l√§dt es herunter. <br><br><h1>  4. Wir schreiben unser eigenes Plugin </h1><br><br>  Daher st√∂rt uns niemand daran, ein eigenes Format zum Speichern von Daten zur dreidimensionalen Geometrie zu entwickeln, und wir werden es uns einfallen lassen <br><br>  <strong>piramide.pmd</strong> <br><br><pre> <code class="plaintext hljs">vertex: 1.0 1.0 0.0 vertex: 1.0 -1.0 0.0 vertex: -1.0 -1.0 0.0 vertex: -1.0 1.0 0.0 vertex: 0.0 0.0 2.0 face: 0 1 2 3 face: 0 3 4 face: 1 0 4 face: 2 1 4 face: 3 2 4</code> </pre><br>  Hier am Anfang der Datei befindet sich eine Liste der Eckpunkte mit ihren Koordinaten.  Scheitelpunktindizes gehen in der Reihenfolge von Null aus.  Nach der Liste der Eckpunkte folgt eine Liste der Gesichter.  Jede Fl√§che wird durch eine Liste von Scheitelpunktindizes definiert, aus denen sie gebildet wird.  Anscheinend nichts kompliziertes.  Die Aufgabe besteht darin, diese Datei von der Festplatte zu lesen und auf ihrer Basis eine dreidimensionale Geometrie zu bilden. <br><br><h1>  5. Plugin-Projekt-Setup: Erstellen Sie Skriptfunktionen </h1><br>  Wenn wir zuvor Anwendungen erstellt haben, m√ºssen wir jetzt eine dynamische Bibliothek schreiben, und zwar nicht nur eine Bibliothek, sondern ein OSG-Plug-In, das bestimmte Anforderungen erf√ºllt.  Wir werden beginnen, diese Anforderungen mit einem Projekterstellungsskript zu erf√ºllen, das so aussieht <br><br>  <strong>plugin.pro</strong> <br><br><pre> <code class="cmake hljs">TEMPLATE = lib CONFIG += plugin CONFIG += no_plugin_name_prefix <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,) win32 { OSG_LIB_DIRECTORY = $$(OSG_BIN_PATH) OSG_INCLUDE_DIRECTORY = $$(OSG_INCLUDE_PATH) DESTDIR = $$(OSG_PLUGINS_PATH) CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -L$$OSG_LIB_DIRECTORY -losgd LIBS += -L$$OSG_LIB_DIRECTORY -losgViewerd LIBS += -L$$OSG_LIB_DIRECTORY -losgDBd LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreadsd LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -L$$OSG_LIB_DIRECTORY -losg LIBS += -L$$OSG_LIB_DIRECTORY -losgViewer LIBS += -L$$OSG_LIB_DIRECTORY -losgDB LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreads LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil } INCLUDEPATH += $$OSG_INCLUDE_DIRECTORY } unix { DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -losgd LIBS += -losgViewerd LIBS += -losgDBd LIBS += -lOpenThreadsd LIBS += -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -losg LIBS += -losgViewer LIBS += -losgDB LIBS += -lOpenThreads LIBS += -losgUtil } } INCLUDEPATH += ./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> HEADERS += $$files(./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/*.h) SOURCES += $$files(./src/*.cpp)</code> </pre><br>  Wir werden einzelne Nuancen genauer analysieren <br><br><pre> <code class="cmake hljs">TEMPLATE = lib</code> </pre><br>  bedeutet, wir werden die Bibliothek bauen.  Um die Erzeugung symbolischer Verkn√ºpfungen zu verhindern, mit deren Hilfe Probleme mit Bibliotheksversionskonflikten in * nix-Systemen gel√∂st werden, weisen wir das Build-System darauf hin, dass diese Bibliothek ein Plug-In ist, dh "on the fly" in den Speicher geladen wird. <br><br><pre> <code class="cmake hljs">CONFIG += plugin</code> </pre><br>  Als n√§chstes schlie√üen wir die Generierung des lib-Pr√§fixes aus, das bei Verwendung der Compiler der gcc-Familie hinzugef√ºgt wird und von der Laufzeitumgebung beim Laden der Bibliothek ber√ºcksichtigt wird <br><br><pre> <code class="cmake hljs">CONFIG += no_plugin_name_prefix</code> </pre><br>  Legen Sie den Namen der Bibliotheksdatei fest <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd</code> </pre><br>  Dabei ist pmd die Dateierweiterung des von uns erfundenen 3D-Modellformats.  Ferner m√ºssen wir angeben, dass im Fall einer MinGW-Assembly das Pr√§fix mingw_ notwendigerweise zum Namen hinzugef√ºgt wird <br><br><pre> <code class="cmake hljs">win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,)</code> </pre><br>  Geben Sie den Erstellungspfad der Bibliothek an: f√ºr Windows <br><br><pre> <code class="cmake hljs">DESTDIR = $$(OSG_PLUGINS_PATH)</code> </pre><br>  f√ºr Linux <br><br><pre> <code class="cmake hljs">DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  F√ºr Linux geben wir mit einer solchen Angabe des Pfades (der zweifellos eine Kr√ºcke ist, aber ich habe noch keine andere L√∂sung gefunden) das Recht, mit OSG-Plugins von einem normalen Benutzer in den angegebenen Ordner zu schreiben <br><br><pre> <code class="plaintext hljs"># chmod 666 /usr/lib/osgPlugins-3.7.0</code> </pre><br>  Alle anderen Build-Einstellungen √§hneln denen, die zuvor beim Zusammenstellen von Beispielanwendungen verwendet wurden. <br><br><h1>  6. Setup des Plugin-Projekts: Funktionen im Debug-Modus </h1><br>  Da es sich bei diesem Projekt um eine dynamische Bibliothek handelt, muss ein Programm vorhanden sein, das diese Bibliothek w√§hrend der Ausf√ºhrung l√§dt.  Dies kann jede Anwendung sein, die OSG verwendet und in der die Funktion aufgerufen wird <br><br><pre> <code class="cpp hljs">node = osdDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"piramide.pmd"</span></span>);</code> </pre><br>  In diesem Fall wird unser Plugin geladen.  Um ein solches Programm nicht selbst zu schreiben, verwenden wir eine vorgefertigte L√∂sung - den Standard-Osgviewer-Viewer, der im Lieferpaket der Engine enthalten ist.  Wenn in der Konsole ausf√ºhren <br><br><pre> <code class="plaintext hljs">$ osgviewer piramide.pmd</code> </pre><br>  dann wird auch das Plugin ausgel√∂st.  Geben Sie in den Einstellungen f√ºr den Projektstart den Pfad zu osgviewerd als Arbeitsverzeichnis an, geben Sie das Verzeichnis an, in dem sich die Datei piramide.pmd befindet, und geben Sie dieselbe Datei in den Befehlszeilenoptionen von osgviewer an <br><br><img src="https://habrastorage.org/webt/v8/9y/xa/v89yxafvygysowtw7aeihf9mgcs.png"><br><br>  Jetzt k√∂nnen wir das Plugin ausf√ºhren und es direkt von der QtCreator-IDE aus debuggen. <br><br><h1>  6. Wir implementieren das Plugin Framework </h1><br>  Dieses Beispiel verallgemeinert in gewissem Ma√üe das Wissen, das wir bereits aus fr√ºheren Lektionen √ºber OSG erhalten haben.  Wenn wir ein Plugin schreiben, m√ºssen wir <br><br><ol><li>  W√§hlen Sie eine Datenstruktur aus, um Informationen zur Modellgeometrie zu speichern, die aus einer Modelldatei gelesen wurden <br></li><li>  Lesen und analysieren Sie die Modelldatendatei <br></li><li>  Konfigurieren Sie das geometrische Objekt osg :: Drawable basierend auf den aus der Datei gelesenen Daten korrekt <br></li><li>  Erstellen Sie einen Szenenuntergraphen f√ºr ein geladenes Modell <br></li></ol><br>  Daher werde ich traditionell den gesamten Quellcode des Plugins angeben <br><br><div class="spoiler">  <b class="spoiler_title">Osgdb_pmd Plugin</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgDB/FileNameUtils&gt; #include &lt;osgDB/FileUtils&gt; #include &lt;osgDB/Registry&gt; #include &lt;osgUtil/SmoothingVisitor&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct face_t { std::vector&lt;unsigned int&gt; indices; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct pmd_mesh_t { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; std::vector&lt;face_t&gt; faces; pmd_mesh_t() : vertices(new osg::Vec3Array) , normals(new osg::Vec3Array) { } osg::Vec3 calcFaceNormal(const face_t &amp;face) const { osg::Vec3 v0 = (*vertices)[face.indices[0]]; osg::Vec3 v1 = (*vertices)[face.indices[1]]; osg::Vec3 v2 = (*vertices)[face.indices[2]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); return n * (1 / n.length()); } }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ReaderWriterPMD : public osgDB::ReaderWriter { public: ReaderWriterPMD(); virtual ReadResult readNode(const std::string &amp;filename, const osgDB::Options *options) const; virtual ReadResult readNode(std::istream &amp;stream, const osgDB::Options *options) const; private: pmd_mesh_t parsePMD(std::istream &amp;stream) const; std::vector&lt;std::string&gt; parseLine(const std::string &amp;line) const; }; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ ReaderWriterPMD::ReaderWriterPMD() { supportsExtension("pmd", "PMD model file"); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( const std::string &amp;filename, const osgDB::Options *options) const { std::string ext = osgDB::getLowerCaseFileExtension(filename); if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; return readNode(stream, options); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( std::istream &amp;stream, const osgDB::Options *options) const { (void) options; pmd_mesh_t mesh = parsePMD(stream); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(mesh.vertices.get()); for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); geom-&gt;addPrimitiveSet(polygon.get()); } geom-&gt;setNormalArray(mesh.normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); return geode.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ pmd_mesh_t ReaderWriterPMD::parsePMD(std::istream &amp;stream) const { pmd_mesh_t mesh; while (!stream.eof()) { std::string line; std::getline(stream, line); std::vector&lt;std::string&gt; tokens = parseLine(line); if (tokens[0] == "vertex") { osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); mesh.vertices-&gt;push_back(point); } if (tokens[0] == "face") { unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } mesh.faces.push_back(face); mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::string delete_symbol(const std::string &amp;str, char symbol) { std::string tmp = str; tmp.erase(std::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); return tmp; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::vector&lt;std::string&gt; ReaderWriterPMD::parseLine(const std::string &amp;line) const { std::vector&lt;std::string&gt; tokens; std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; while ( (pos = tmp.find(':')) != std::string::npos ) { token = tmp.substr(0, pos); tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } tokens.push_back(tmp); return tokens; } REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</span></span></span></span></code> </pre><br></div></div><br>  Zun√§chst k√ºmmern wir uns um die Strukturen zum Speichern von Geometriedaten. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">face_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; };</code> </pre><br>  - beschreibt die Fl√§che, die durch die Liste der Indizes der zu dieser Fl√§che geh√∂renden Scheitelpunkte definiert ist.  Das Modell als Ganzes wird durch eine solche Struktur beschrieben <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pmd_mesh_t</span></span></span><span class="hljs-class"> {</span></span> osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">face_t</span></span>&gt; faces; <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { } osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcFaceNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">face_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;face)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ osg::Vec3 v0 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; osg::Vec3 v1 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; osg::Vec3 v2 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * (<span class="hljs-number"><span class="hljs-number">1</span></span> / n.length()); } };</code> </pre><br>  Die Struktur besteht aus Elementvariablen zum Speichern von Daten: Scheitelpunkte - zum Speichern eines Arrays von Scheitelpunkten eines geometrischen Objekts;  Normalen - eine Reihe von Normalen zu den Fl√§chen des Objekts;  Gesichter - eine Liste der Gesichter des Objekts.  Der Strukturkonstruktor initialisiert sofort intelligente Zeiger <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { }</code> </pre><br>  Dar√ºber hinaus enth√§lt die Struktur eine Methode, mit der Sie den Normalenvektor f√ºr das Gesicht berechnen k√∂nnen calcFaceNormal () als Parameter, der eine Struktur verwendet, die das Gesicht beschreibt.  Wir werden noch nicht auf Details der Implementierung dieser Methode eingehen, wir werden sie etwas sp√§ter analysieren. <br><br>  Daher haben wir uns f√ºr die Strukturen entschieden, in denen wir die Geometriedaten speichern werden.  Schreiben wir nun das Framework unseres Plugins, n√§mlich die Implementierung der Vererbungsklasse osgDB :: ReaderWriter <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReaderWriterPMD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgDB::ReaderWriter { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReaderWriterPMD(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; };</code> </pre><br>  Wie in der Beschreibung der API f√ºr die Entwicklung von Plugins empfohlen, definieren wir in dieser Klasse die Methoden zum Lesen von Daten aus einer Datei und zum Konvertieren in einen Untergraphen der Szene neu.  Die readNode () -Methode f√ºhrt zwei √úberladungen durch - eine akzeptiert den Dateinamen als Eingabe, die andere empf√§ngt Standardeingaben.  Der Klassenkonstruktor definiert die vom Plugin unterst√ºtzten Dateierweiterungen <br><br><pre> <code class="cpp hljs">ReaderWriterPMD::ReaderWriterPMD() { supportsExtension(<span class="hljs-string"><span class="hljs-string">"pmd"</span></span>, <span class="hljs-string"><span class="hljs-string">"PMD model file"</span></span>); }</code> </pre><br>  Die erste √úberladung der Methode readNode () analysiert die Richtigkeit des Dateinamens und des Pfads zu dieser Datei, ordnet der Datei einen Standardeingabestream zu und ruft die zweite √úberladung auf, die die Hauptarbeit erledigt <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;filename, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       std::string ext = osgDB::getLowerCaseFileExtension(filename); // ,      if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; // ,       std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; //      std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; //      readNode() return readNode(stream, options); }</span></span></code> </pre><br>  In der zweiten √úberladung implementieren wir den Objekterzeugungsalgorithmus f√ºr OSG <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) options; <span class="hljs-comment"><span class="hljs-comment">//   *.pmd       pmd_mesh_t mesh = parsePMD(stream); //    osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; //    geom-&gt;setVertexArray(mesh.vertices.get()); //    for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { //    GL_POLYGON      (  - 0) osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); //       for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); //     geom-&gt;addPrimitiveSet(polygon.get()); } //    geom-&gt;setNormalArray(mesh.normals.get()); //  OpenGL,       geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); //             osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); //     return geode.release(); }</span></span></code> </pre><br>  Rufen Sie am Ende der Datei main.cpp das Makro REGISTER_OSGPLUGIN () auf. <br><br><pre> <code class="cpp hljs">REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</code> </pre><br>  Dieses Makro generiert zus√§tzlichen Code, mit dem OSG in Form der osgDB-Bibliothek ein Objekt vom Typ ReaderWriterPMD erstellen und seine Methoden zum Laden von Dateien vom Typ pmd aufrufen kann.  Damit das Plugin-Framework fertig ist, bleibt die Sache f√ºr kleine - das Laden und Parsen der pmd-Datei zu implementieren. <br><br><h1>  7. Parsim 3D-Modelldatei </h1><br>  Jetzt beruht die gesamte Funktionalit√§t des Plugins auf der Implementierung der parsePMD () -Methode <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> ReaderWriterPMD::parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> mesh; <span class="hljs-comment"><span class="hljs-comment">//    while (!stream.eof()) { //      std::string line; std::getline(stream, line); //     -     std::vector&lt;std::string&gt; tokens = parseLine(line); //    -  if (tokens[0] == "vertex") { //       osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); //      mesh.vertices-&gt;push_back(point); } //    -  if (tokens[0] == "face") { //         unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } //      mesh.faces.push_back(face); //     mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die ParseLine () -Methode analysiert die Zeile der pmd-Datei </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; ReaderWriterPMD::parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tokens; <span class="hljs-comment"><span class="hljs-comment">//   ,        ( Windows) std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; //      ,     : //      while ( (pos = tmp.find(':')) != std::string::npos ) { //     (vertex  face   ) token = tmp.substr(0, pos); //         tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } //        tokens.push_back(tmp); return tokens; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Methode verwandelt die Zeichenfolge "Vertex: 1.0 -1.0 0.0" in eine Liste der beiden Zeilen "Vertex" und "1.0 -1.0 0.0". </font><font style="vertical-align: inherit;">In der ersten Zeile identifizieren wir den Datentyp - den Scheitelpunkt oder die Fl√§che, aus der zweiten extrahieren wir die Daten auf den Koordinaten des Scheitelpunkts. </font><font style="vertical-align: inherit;">Um die Funktionsweise dieser Methode sicherzustellen, ben√∂tigen wir die Hilfsfunktion delete_symbol (), die das angegebene Zeichen aus der Zeichenfolge entfernt und eine Zeichenfolge zur√ºckgibt, die dieses Zeichen nicht enth√§lt</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_symbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp = str; tmp.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das hei√üt, jetzt haben wir alle Funktionen unseres Plugins implementiert und k√∂nnen es testen. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Testen des Plugins </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir kompilieren das Plugin und f√ºhren das Debugging aus (F5). </font><font style="vertical-align: inherit;">Es wird eine Debug-Version des Standard-Osgviewerd-Viewers gestartet, die die an sie √ºbergebene Datei piramide.pmd analysiert, unser Plugin l√§dt und die Methode readNode () aufruft. </font><font style="vertical-align: inherit;">Wenn wir alles richtig gemacht haben, erhalten wir ein solches Ergebnis. </font></font><br><br><img src="https://habrastorage.org/webt/s3/5g/-y/s35g-ykmmlet5z8jisj7efkz7je.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass die Liste der Eckpunkte und Fl√§chen in unserer erfundenen Datei des 3D-Modells eine viereckige Pyramide verbarg. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum haben wir die Normalen selbst berechnet? </font><font style="vertical-align: inherit;">In einer der Lektionen wurde uns die folgende Methode zur automatischen Berechnung gegl√§tteter Normalen angeboten</font></font><br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir wenden diese Funktion in unserem Beispiel an, anstatt unsere eigenen Normalen zuzuweisen </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//geom-&gt;setNormalArray(mesh.normals.get()); //geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osgUtil::SmoothingVisitor::smooth(*geom);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und wir erhalten das folgende Ergebnis: Die </font></font><br><br><img src="https://habrastorage.org/webt/eb/gd/kt/ebgdktxsplxyqatprxunnwd8r2o.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalen beeinflussen die Berechnung der Beleuchtung des Modells, und wir sehen, dass in dieser Situation die gegl√§tteten Normalen zu falschen Ergebnissen der Berechnung der Beleuchtung der Pyramide f√ºhren. </font><font style="vertical-align: inherit;">Aus diesem Grund haben wir unser Fahrrad auf die Berechnung von Normalen angewendet. </font><font style="vertical-align: inherit;">Aber ich denke, dass es den Rahmen dieser Lektion sprengt, die Nuancen zu erkl√§ren.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438296/">https://habr.com/ru/post/de438296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438286/index.html">Arbeiten mit Zeitzonen in JavaScript</a></li>
<li><a href="../de438288/index.html">Furchtloser Schutz. Speichersicherheit in Rust</a></li>
<li><a href="../de438290/index.html">Post-mortem mit GGJ-2019: wie man Unebenheiten bekommt, aber trotzdem das Spiel macht</a></li>
<li><a href="../de438292/index.html">Apartment Automation mit HomePod, Raspberry Pi und Node.js.</a></li>
<li><a href="../de438294/index.html">Zuckende Streamer in einem PUBG-Match finden</a></li>
<li><a href="../de438298/index.html">Warum unterrichten, wenn das Entwickeln rentabler ist? Gespr√§ch mit GeekBrains</a></li>
<li><a href="../de438302/index.html">Die erstaunliche Kreativit√§t der digitalen Evolution</a></li>
<li><a href="../de438304/index.html">Vergabe von Unterauftr√§gen? Cool du schl√§gst</a></li>
<li><a href="../de438306/index.html">Strahlung: Wochentags radiochemisches Labor</a></li>
<li><a href="../de438310/index.html">Instagram verwendet maschinelles Lernen, um gef√§lschte Follower zu entfernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>