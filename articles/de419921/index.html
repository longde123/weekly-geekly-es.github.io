<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîü üíª üê† So verwerfen Sie 10 Millionen Pakete pro Sekunde üìñ üßëüèº üçÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Unternehmen wird unser Team zur Abwehr von DDoS-Angriffen als "Packet Dropper" bezeichnet. W√§hrend alle anderen Teams coole Dinge mit dem Verkehr t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So verwerfen Sie 10 Millionen Pakete pro Sekunde</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419921/"> Im Unternehmen wird unser Team zur Abwehr von DDoS-Angriffen als "Packet Dropper" bezeichnet.  W√§hrend alle anderen Teams coole Dinge mit dem Verkehr tun, der durch unser Netzwerk flie√üt, haben wir Spa√ü daran, neue Wege zu finden, um ihn loszuwerden. <br><br><img src="https://habrastorage.org/webt/s-/3y/un/s-3yun8pllqd7-e077fuxbk9jiw.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brian Evans</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-SA 2.0</a></i> <br><br>  Die F√§higkeit, Pakete schnell zu verwerfen, ist sehr wichtig, um DDoS-Angriffen entgegenzuwirken. <br><br>  Drop-Pakete, die unsere Server erreichen, k√∂nnen auf mehreren Ebenen ausgef√ºhrt werden.  Jede Methode hat ihre Vor- und Nachteile.  Unter dem Schnitt schauen wir uns alles an, was wir getestet haben. <br><a name="habracut"></a><br><blockquote>  <i>Anmerkung des √úbersetzers: In der Ausgabe einiger der vorgestellten Befehle wurden zus√§tzliche Leerzeichen entfernt, um die Lesbarkeit zu gew√§hrleisten.</i> </blockquote><h1>  Teststelle </h1><br>  Um den Vergleich der Methoden zu vereinfachen, stellen wir Ihnen einige Zahlen zur Verf√ºgung. Nehmen Sie diese jedoch aufgrund der K√ºnstlichkeit der Tests nicht zu w√∂rtlich.  Wir werden eine unserer Intel 10Gb / s-Netzwerkkarten verwenden.  Die verbleibenden Servereigenschaften sind nicht so wichtig, da wir uns auf die Einschr√§nkungen des Betriebssystems konzentrieren m√∂chten, nicht auf die Hardware. <br><br>  Unsere Tests werden wie folgt aussehen: <br><br><ul><li>  Wir erstellen eine gro√üe Anzahl kleiner UDP-Pakete, die einen Wert von 14 Millionen Paketen pro Sekunde erreichen. </li><li>  Der gesamte Datenverkehr wird an einen Prozessorkern des ausgew√§hlten Servers geleitet. </li><li>  Wir messen die Anzahl der vom Kernel verarbeiteten Pakete auf einem einzelnen Prozessorkern. </li></ul><br>  K√ºnstlicher Verkehr wird so erzeugt, dass eine maximale Last entsteht: Zuf√§llige IP-Adresse und Absenderport werden verwendet.  So sieht es in tcpdump aus: <br><br><pre><code class="bash hljs">$ tcpdump -ni vlan100 -c 10 -t udp and dst port 1234 IP 198.18.40.55.32059 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.51.16.30852 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.35.51.61823 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.44.42.30344 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.106.227.38592 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.48.67.19533 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.49.38.40566 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.50.73.22989 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.43.204.37895 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.104.128.1543 &gt; 198.18.0.12.1234: UDP, length 16</code> </pre> <br>  Auf dem ausgew√§hlten Server befinden sich alle Pakete in einer Empfangswarteschlange und werden daher von einem Kern verarbeitet.  Dies erreichen wir mit der Hardware-Flusskontrolle: <br><br><pre> <code class="bash hljs">ethtool -N ext0 flow-type udp4 dst-ip 198.18.0.12 dst-port 1234 action 2</code> </pre><br>  Leistungstests sind ein komplexer Prozess.  Bei der Vorbereitung der Tests haben wir festgestellt, dass das Vorhandensein aktiver Raw-Sockets die Leistung negativ beeinflusst. Bevor Sie die Tests ausf√ºhren, m√ºssen Sie sicherstellen, dass kein <code>tcpdump</code> wird.  Es gibt eine einfache M√∂glichkeit, nach schlechten Prozessen zu suchen: <br><br><pre> <code class="bash hljs">$ ss -A raw,packet_raw -l -p|cat Netid State Recv-Q Send-Q Local Address:Port p_raw UNCONN 525157 0 *:vlan100 users:((<span class="hljs-string"><span class="hljs-string">"tcpdump"</span></span>,pid=23683,fd=3))</code> </pre><br>  Und schlie√ülich schalten wir Intel Turbo Boost auf unserem Server aus: <br><br><pre> <code class="hljs pgsql">echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee /sys/devices/<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>/cpu/intel_pstate/no_turbo</code> </pre> <br>  Trotz der Tatsache, dass Turbo Boost eine gro√üartige Sache ist und den Durchsatz um mindestens 20% erh√∂ht, wird die Standardabweichung in unseren Tests erheblich beeintr√§chtigt.  Bei eingeschaltetem Turbo erreicht die Abweichung ¬± 1,5%, ohne sie nur 0,25%. <br><br><img src="https://habrastorage.org/webt/ic/ik/jq/icikjqda_ztydjswe8xjq07u5sa.png"><br><br><h3>  Schritt 1. Verwerfen Sie Pakete in der Anwendung </h3><br>  Beginnen wir mit der Idee, alle Pakete an die Anwendung zu liefern und dort zu ignorieren.  Stellen Sie zur Ehrlichkeit des Experiments sicher, dass iptables die Leistung in keiner Weise beeintr√§chtigt: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t mangle -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I INPUT -t filter -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT</code> </pre><br>  Die Anwendung ist ein einfacher Zyklus, in dem die empfangenen Daten sofort verworfen werden: <br><br><pre> <code class="python hljs">s = socket.socket(AF_INET, SOCK_DGRAM) s.bind((<span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>, <span class="hljs-number"><span class="hljs-number">1234</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: s.recvmmsg([...])</code> </pre><br>  Wir haben den <a href="">Code</a> bereits vorbereitet, f√ºhren Sie aus: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=171261 bytes=1940176</code> </pre><br>  Diese L√∂sung erm√∂glicht es dem Kernel, nur <code>ethtool</code> Pakete aus der Hardware-Warteschlange zu entnehmen, wie vom <code>ethtool</code> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseren</a> <code>mmwatch</code> gemessen wurde: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|grep rx_2'</span></span> rx2_packets: 174.0k/s</code> </pre><br>  Technisch gesehen kommen 14 Millionen Pakete pro Sekunde auf dem Server an, jedoch kann ein Prozessorkern ein solches Volumen nicht bew√§ltigen.  <code>mpstat</code> best√§tigt dies: <br><br><pre> <code class="bash hljs">$ watch <span class="hljs-string"><span class="hljs-string">'mpstat -u -I SUM -P ALL 1 1|egrep -v Aver'</span></span> 01:32:05 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 01:32:06 PM 0 0.00 0.00 0.00 2.94 0.00 3.92 0.00 0.00 0.00 93.14 01:32:06 PM 1 2.17 0.00 27.17 0.00 0.00 0.00 0.00 0.00 0.00 70.65 01:32:06 PM 2 0.00 0.00 0.00 0.00 0.00 100.00 0.00 0.00 0.00 0.00 01:32:06 PM 3 0.95 0.00 1.90 0.95 0.00 3.81 0.00 0.00 0.00 92.38</code> </pre><br><br>  Wie wir sehen k√∂nnen, ist die Anwendung kein Engpass: CPU # 1 wird mit 27,17% + 2,17% verwendet, w√§hrend die Interrupt-Behandlung 100% auf CPU # 2 beansprucht. <br><br>  Die Verwendung von <code>recvmessagge(2)</code> spielt eine wichtige Rolle.  Nachdem die Spectre-Sicherheitsanf√§lligkeit entdeckt wurde, wurden Systemaufrufe aufgrund des im Kernel verwendeten <abbr title="Isolierung der Kernel-Seitentabelle">KPTI</abbr> und der <abbr title="Trampolin zur√ºckgeben">Retpoline</abbr> noch teurer <br><br><pre> <code class="hljs ruby">$ tail -n +<span class="hljs-number"><span class="hljs-number">1</span></span> /sys/devices/system/cpu/vulnerabilities/* ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/meltdown</span></span> &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> PTI ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v1 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> __user pointer sanitization ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v2 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> Full generic retpoline, IBPB, IBRS_FW</code> </pre><br><br><h3>  Schritt 2. Conntrack t√∂ten </h3><br>  Wir haben eine solche Last speziell mit unterschiedlichen IP- und Absenderports erstellt, um so viel wie m√∂glich Conntrack zu laden.  Die Anzahl der Eintr√§ge in conntrack w√§hrend des Tests ist maximal und wir k√∂nnen dies √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">$ conntrack -C 2095202 $ sysctl net.netfilter.nf_conntrack_max net.netfilter.nf_conntrack_max = 2097152</code> </pre><br>  Dar√ºber hinaus k√∂nnen Sie in <code>dmesg</code> auch Conntrack-Schreie sehen: <br><br><pre> <code class="bash hljs">[4029612.456673] nf_conntrack: nf_conntrack: table full, dropping packet [4029612.465787] nf_conntrack: nf_conntrack: table full, dropping packet [4029617.175957] net_ratelimit: 5731 callbacks suppressed</code> </pre><br>  Schalten wir es also aus: <br><br><pre> <code class="bash hljs">iptables -t raw -I PREROUTING -d 198.18.0.12 -p udp -m udp --dport 1234 -j NOTRACK</code> </pre><br>  Und starten Sie die Tests neu: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=331008 bytes=5296128</code> </pre><br><br>  Dadurch konnten wir die Marke von 333.000 Paketen pro Sekunde erreichen.  Hurra! <br>  PS Mit SO_BUSY_POLL k√∂nnen wir bis zu 470.000 pro Sekunde erreichen. Dies ist jedoch ein Thema f√ºr einen separaten Beitrag. <br><br><h3>  Schritt 3. Berkeley Batch Filter </h3><br>  Lass uns weitermachen.  Warum m√ºssen wir Pakete an die Anwendung liefern?  Obwohl dies keine √ºbliche L√∂sung ist, k√∂nnen wir den klassischen Berkeley-Paketfilter an den Socket binden, indem <code>setsockopt(SO_ATTACH_FILTER)</code> und den Filter so konfigurieren, dass Pakete zur√ºck in den Kernel fallen. <br>  Bereiten Sie den <a href="">Code vor</a> und f√ºhren Sie Folgendes aus: <br><br><pre> <code class="bash hljs">$ ./bpf-drop packets=0 bytes=0</code> </pre><br>  Mit einem Paketfilter (klassische und erweiterte Berkeley-Filter bieten eine ungef√§hr √§hnliche Leistung) erreichen wir ungef√§hr 512.000 Pakete pro Sekunde.  Dar√ºber hinaus befreit das Verwerfen eines Pakets w√§hrend eines Interrupts den Prozessor davon, die Anwendung aufwecken zu m√ºssen. <br><br><h3>  Schritt 4. iptables DROP nach dem Routing </h3><br>  Jetzt k√∂nnen wir Pakete verwerfen, indem wir iptables in der INPUT-Kette die folgende Regel hinzuf√ºgen: <br><br><pre> <code class="bash hljs">iptables -I INPUT -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre><br>  Ich m√∂chte Sie daran erinnern, dass wir conntrack bereits mit der <code>-j NOTRACK</code> Regel <code>-j NOTRACK</code> .  Diese beiden Regeln geben uns 608.000 Pakete pro Sekunde. <br><br>  Schauen wir uns die Zahlen in iptables an: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'iptables -L -v -n -x | head'</span></span> Chain INPUT (policy DROP 0 packets, 0 bytes) pkts bytes target prot opt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> out <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> destination 605.9k/s 26.7m/s DROP udp -- * * 0.0.0.0/0 198.18.0.12 udp dpt:1234</code> </pre><br>  Nicht schlecht, aber wir k√∂nnen es besser machen. <br><br><h3>  Schritt 5. iptabes DROP in PREROUTING </h3><br>  Eine schnellere Methode besteht darin, Pakete vor dem Routing mit dieser Regel zu verwerfen: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre> <br>  Dies erm√∂glicht es uns, betr√§chtliche 1,688 Millionen Pakete pro Sekunde zu verwerfen. <br><br>  In der Tat ist dies ein etwas √ºberraschender Leistungssprung.  Ich verstehe die Gr√ºnde immer noch nicht, vielleicht ist unser Routing kompliziert oder nur ein Fehler in der Serverkonfiguration. <br><br>  In jedem Fall sind rohe Iptables viel schneller. <br><br><h3>  Schritt 6. nftables DROP </h3><br>  Das Dienstprogramm iptables ist jetzt etwas alt.  Sie wurde durch Nftables ersetzt.  Schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Video-Erkl√§rung an,</a> warum nftables top ist.  Nftables verspricht aus verschiedenen Gr√ºnden schneller zu sein als grau werdende Iptables, einschlie√ülich Ger√ºchten, dass Retpolinen Iptables stark verlangsamen. <br><br>  In unserem Artikel geht es jedoch immer noch nicht um den Vergleich von iptables und nftables. Versuchen wir also einfach das schnellste, was ich tun kann: <br><br><pre> <code class="bash hljs">nft add table netdev filter nft -- add chain netdev filter input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500 \; policy accept \; } nft add rule netdev filter input ip daddr 198.18.0.0/24 udp dport 1234 counter drop nft add rule netdev filter input ip6 daddr fd00::/64 udp dport 1234 counter drop</code> </pre><br>  Z√§hler k√∂nnen so gesehen werden: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'nft --handle list chain netdev filter input'</span></span> table netdev filter { chain input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500; policy accept; ip daddr 198.18.0.0/24 udp dport 1234 counter packets 1.6m/s bytes 69.6m/s drop <span class="hljs-comment"><span class="hljs-comment"># handle 2 ip6 daddr fd00::/64 udp dport 1234 counter packets 0 bytes 0 drop # handle 3 } }</span></span></code> </pre><br>  Der nftables-Eingabehaken zeigte Werte von ungef√§hr 1,53 Millionen Paketen.  Dies ist etwas weniger als die PREROUTING-Kette in iptables.  Dies ist jedoch ein R√§tsel: Theoretisch geht der nftables-Hook fr√ºher als PREROUTING iptables und sollte daher schneller verarbeitet werden. <br><br>  In unserem Test ist nftables etwas langsamer als iptables, aber nftables sind trotzdem cooler.  : P. <br><br><h3>  Schritt 7. tc DROP </h3><br>  Etwas unerwartet tritt der tc-Haken (Traffic Control) fr√ºher auf als iptables PREROUTING.  Mit tc k√∂nnen wir Pakete nach einfachen Kriterien ausw√§hlen und nat√ºrlich verwerfen.  Die Syntax ist etwas ungew√∂hnlich, daher empfehlen wir, <a href="">dieses Skript</a> f√ºr die Konfiguration zu verwenden.  Und wir brauchen eine ziemlich komplizierte Regel, die so aussieht: <br><br><pre> <code class="bash hljs">tc qdisc add dev vlan100 ingress tc filter add dev vlan100 parent ffff: prio 4 protocol ip u32 match ip protocol 17 0xff match ip dport 1234 0xffff match ip dst 198.18.0.0/24 flowid 1:1 action drop tc filter add dev vlan100 parent ffff: protocol ipv6 u32 match ip6 dport 1234 0xffff match ip6 dst fd00::/64 flowid 1:1 action drop</code> </pre><br>  Und wir k√∂nnen es in Aktion √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'tc -s filter show dev vlan100 ingress'</span></span> filter parent ffff: protocol ip pref 4 u32 filter parent ffff: protocol ip pref 4 u32 fh 800: ht divisor 1 filter parent ffff: protocol ip pref 4 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1 (rule hit 1.8m/s success 1.8m/s) match 00110000/00ff0000 at 8 (success 1.8m/s ) match 000004d2/0000ffff at 20 (success 1.8m/s ) match c612000c/ffffffff at 16 (success 1.8m/s ) action order 1: gact action drop random <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> none pass val 0 index 1 ref 1 <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> 1 installed 1.0/s sec Action statistics: Sent 79.7m/s bytes 1.8m/s pkt (dropped 1.8m/s, overlimits 0 requeues 0)</code> </pre><br>  Mit dem TC-Hook konnten wir bis zu 1,8 Millionen Pakete pro Sekunde auf einem einzigen Kern ablegen.  Das ist gro√üartig! <br>  Aber wir k√∂nnen es noch schneller machen ... <br><br><h3>  Schritt 8. XDP_DROP </h3><br>  Und schlie√ülich unsere st√§rkste Waffe: XDP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eXpress Data Path</a> .  Mit XDP k√∂nnen wir den erweiterten eBPF-Code (Berkley Packet Filter) direkt im Kontext des Netzwerktreibers und vor allem noch vor der Zuweisung von Speicher f√ºr <code>skbuff</code> , was uns eine Erh√∂hung der Geschwindigkeit verspricht. <br><br>  In der Regel besteht ein XDP-Projekt aus zwei Teilen: <br><br><ul><li>  Herunterladbarer eBPF-Code </li><li>  Bootloader, der Code in die richtige Netzwerkschnittstelle einf√ºgt </li></ul><br>  Das Schreiben Ihres Bootloaders ist eine schwierige Aufgabe. Verwenden Sie einfach den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuen iproute2-Chip</a> und laden Sie den Code mit einem einfachen Befehl: <br><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev ext0 xdp obj xdp-drop-ebpf.o</code> </pre><br>  Ta Dam! <br><br>  Den Quellcode f√ºr das <a href="">herunterladbare eBPF-Programm finden Sie hier</a> .  Das Programm untersucht Eigenschaften von IP-Paketen wie das UDP-Protokoll, das Absendersubnetz und den Zielport: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h_proto == htons(<span class="hljs-type"><span class="hljs-type">ETH_P_IP</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iph-&gt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPPROTO_UDP</span></span></span><span class="hljs-class"> &amp;&amp; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htonl</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">daddr</span></span></span><span class="hljs-class">) &amp; 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xFFFFFF00</span></span></span><span class="hljs-class">) == 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xC6120000</span></span></span><span class="hljs-class"> // 198.18.0.0/24 &amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dest</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htons</span></span></span><span class="hljs-class">(1234)) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">XDP_DROP</span></span>; } }</code> </pre><br>  Das XDP-Programm muss mit modernem Clang erstellt werden, der BPF-Bytecode generieren kann.  Danach k√∂nnen wir die Funktionalit√§t des BFP-Programms herunterladen und testen: <br><br><pre> <code class="bash hljs">$ ip link show dev ext0 4: ext0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc fq state UP mode DEFAULT group default qlen 1000 link/ether 24:8a:07:8a:59:8e brd ff:ff:ff:ff:ff:ff prog/xdp id 5 tag aedc195cc0471f51 jited</code> </pre><br>  Und dann sehen Sie sich die Statistiken in <code>ethtool</code> : <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|egrep "rx"|egrep -v ": 0"|egrep -v "cache|csum"'</span></span> rx_out_of_buffer: 4.4m/s rx_xdp_drop: 10.1m/s rx2_xdp_drop: 10.1m/s</code> </pre><br>  Yoo hoo!  Mit XDP k√∂nnen wir bis zu 10 Millionen Pakete pro Sekunde verwerfen! <br><br><img src="https://habrastorage.org/webt/fq/mf/e5/fqmfe5jgs1qylz7fpwryoeey0ag.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Filer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-SA 2.0</a></i> <br><br><h3>  Schlussfolgerungen </h3><br>  Wir haben das Experiment f√ºr IPv4 und IPv6 wiederholt und dieses Diagramm erstellt: <br><br><img src="https://habrastorage.org/webt/dl/sc/qa/dlscqatdfii2rihttytjnfvtfea.png"><br>  Im Allgemeinen kann argumentiert werden, dass unser Setup f√ºr IPv6 etwas langsamer ist.  Da IPv6-Pakete jedoch etwas gr√∂√üer sind, wird ein Geschwindigkeitsunterschied erwartet. <br><br>  Linux hat viele M√∂glichkeiten, Pakete zu filtern, jedes mit seiner eigenen Geschwindigkeit und Komplexit√§t. <br><br>  Zum Schutz vor DDoS ist es durchaus sinnvoll, der Anwendung Pakete zu geben und diese dort zu verarbeiten.  Eine gut abgestimmte Anwendung kann gute Ergebnisse zeigen. <br><br>  Bei DDoS-Angriffen mit zuf√§lliger oder gef√§lschter IP kann es n√ºtzlich sein, conntrack zu deaktivieren, um die Geschwindigkeit geringf√ºgig zu erh√∂hen. Seien Sie jedoch vorsichtig: Es gibt Angriffe, gegen die conntrack sehr n√ºtzlich ist. <br><br>  In anderen F√§llen ist es sinnvoll, die Linux-Firewall hinzuzuf√ºgen, um den DDoS-Angriff abzuschw√§chen.  In einigen F√§llen ist es besser, die Tabelle "-t raw PREROUTING" zu verwenden, da sie viel schneller als die Filtertabelle ist. <br><br>  In den fortgeschrittensten F√§llen verwenden wir immer XDP.  Und ja, das ist eine sehr m√§chtige Sache.  Hier ist eine Grafik wie oben, nur mit XDP: <br><br><img src="https://habrastorage.org/webt/o4/un/dm/o4undm-syfgavdxop6izkvpckyk.png"><br>  Wenn Sie das Experiment wiederholen m√∂chten, finden Sie hier die <a href="">README-Datei, in der wir alles dokumentiert haben</a> . <br><br>  Wir bei CloudFlare verwenden ... fast alle diese Techniken.  Einige Tricks im Benutzerbereich sind in unsere Anwendungen integriert.  Die iptables-Technik finden Sie in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gatebot</a> .  Schlie√ülich ersetzen wir unsere eigene Kernl√∂sung durch XDP. <br><br>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jesper Dangaard Brouer</a> f√ºr ihre Hilfe. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419921/">https://habr.com/ru/post/de419921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419911/index.html">Erstellen von Umlaufbahnen von Himmelsk√∂rpern mit Python</a></li>
<li><a href="../de419913/index.html">IKEA und Smart Home. Teil 2</a></li>
<li><a href="../de419915/index.html">Bonding und SSH-Server in initramfs</a></li>
<li><a href="../de419917/index.html">Neuronale Netze: Umsetzung der Aufgabe √ºber Pilze auf Tensor Flow und Python</a></li>
<li><a href="../de419919/index.html">Versionskontrolle in SQL Server</a></li>
<li><a href="../de419923/index.html">Meine Zeitarbeit, Motherboard-Uhren</a></li>
<li><a href="../de419925/index.html">Versionskontrolle einzelner Dateien mit dem GitHub Gist</a></li>
<li><a href="../de419927/index.html">[DotNetBook] Ausnahmen: Typ Systemarchitektur</a></li>
<li><a href="../de419929/index.html">[DotNetBook] Ausnahmeereignisse und wie Sie StackOverflow und ExecutionEngineException von Grund auf neu erstellen</a></li>
<li><a href="../de419931/index.html">[DotNetBook] Zeit f√ºr unterhaltsame Geschichten: au√üergew√∂hnlich au√üergew√∂hnliche Situationen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>