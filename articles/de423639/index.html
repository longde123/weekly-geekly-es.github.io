<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòä ü•ñ üö¥üèª Effizienteres Schreiben von Arrays in den dauerhaften Speicher eines intelligenten Vertrags in Solidity üí≠ üÉè üòµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem musste ich ein bisschen mit der Ethereum-Blockchain arbeiten . Die Idee, an der ich arbeitete, erforderte das Speichern einer ziemlich gro√ü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Effizienteres Schreiben von Arrays in den dauerhaften Speicher eines intelligenten Vertrags in Solidity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423639/"> Vor kurzem musste ich ein bisschen mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum-Blockchain arbeiten</a> .  Die Idee, an der ich arbeitete, erforderte das Speichern einer ziemlich gro√üen Anzahl von Ganzzahlen direkt in der Blockchain, damit der intelligente Vertrag bequem darauf zugreifen konnte.  In den meisten Lektionen zur Entwicklung intelligenter Vertr√§ge hei√üt es: "Speichern Sie nicht viele Daten in der Blockchain, es ist teuer!"  Aber wie viel ist ‚Äûviel‚Äú und wie viel wird der Preis f√ºr den praktischen Gebrauch zu hoch?  Ich musste herausfinden, dass die gesamte Idee zusammenbrach, da wir unsere Daten nicht au√üerhalb der Kette machen konnten. <br><br>  Ich fange gerade erst an, mit Solidity und EVM zu arbeiten, daher behauptet dieser Artikel nicht, die ultimative Wahrheit zu sein, aber ich konnte weder auf Russisch noch auf Englisch andere Materialien zu diesem Thema finden (obwohl es sehr schlimm ist, dass ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> vorher nicht gefunden habe ), also hoffe ich, dass es jemandem n√ºtzlich sein kann.  Nun, oder als letztes Mittel kann es f√ºr mich n√ºtzlich sein, wenn erfahrene Kameraden mir sagen, wie und wo genau ich mich darin irre. <br><br>  Zun√§chst habe ich mich entschlossen, schnell herauszufinden, ob wir das schaffen k√∂nnen.  Nehmen wir den weit verbreiteten Standardvertragstyp - den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ERC20-</a> Token.  Zumindest speichert ein solcher Vertrag in der Blockchain die Entsprechung der Adressen der Personen, die die Token gekauft haben, zu ihrem Guthaben.  In der Realit√§t werden nur Salden gespeichert, von denen jede 32 Bytes ben√∂tigt (tats√§chlich ist es aufgrund der Merkmale von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solidity</a> und EVM nicht sinnvoll, hier zu speichern).  Ein mehr oder weniger erfolgreiches Token kann leicht Zehntausende von Besitzern haben, und daher ist das Speichern von etwa 320.000 Bytes in der Blockchain durchaus akzeptabel.  Und mehr brauchen wir nicht! <br><br><h2>  Naiver Ansatz </h2><br>  Versuchen wir, unsere Daten zu speichern.  Ein wesentlicher Teil von ihnen sind 8-Bit-Ganzzahlen ohne Vorzeichen, daher werden wir ihr Array in den Vertrag √ºbertragen und versuchen, sie in den Nur-Lese-Speicher zu schreiben: <br><a name="habracut"></a><br><pre><code class="javascript hljs">uint8[] m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint8[] data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre> <br>  Goofy!  Diese Funktion frisst Gas, als ob es nicht an sich w√§re.  Der Versuch, 100 Werte zu sparen, kostete uns 814033 Gas, 8100 Gas pro Byte! <br><br>  Atme aus und mache einen Schritt zur√ºck zur Theorie.  Was sind die Mindestkosten (in Gas) f√ºr die Speicherung von Daten in der Ethereum-Blockchain?  Es ist zu beachten, dass Daten in Bl√∂cken von 32 Bytes gespeichert werden.  EVM kann nur einen ganzen Block gleichzeitig lesen oder schreiben. Idealerweise sollten die zu schreibenden Daten so effizient wie m√∂glich gepackt werden, damit ein einzelner Schreibbefehl sofort spart.  Denn der gleiche Aufzeichnungsbefehl - SSTORE - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostet</a> allein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">20.000 Gas</a> (wenn wir in eine Speicherzelle schreiben, in die wir vorher noch nicht geschrieben haben).  Unser theoretisches Minimum, das alle anderen Ausgaben ignoriert, betr√§gt ungef√§hr 625 Gas pro Byte.  Weit entfernt von den 8100, die wir im obigen Beispiel bekommen haben!  Jetzt ist es an der Zeit, tiefer zu graben und herauszufinden, wer unser Gas isst und wie man es aufh√§lt. <br><br>  Unser erster Impuls sollte sein, den vom Solidity-Compiler aus unserer einzelnen Zeile generierten Code (m_test = data) zu betrachten, da nichts mehr zu sehen ist.  Dies ist ein guter, korrekter Impuls, der uns mit einer schrecklichen Tatsache vertraut machen wird - der Compiler an diesem Ort hat einige uralte Schrecken erzeugt, die Sie auf den ersten Blick nicht verstehen werden!  Wenn wir uns die Liste kurz ansehen, sehen wir dort nicht nur SSTORE (was erwartet wird), sondern auch SLOAD (Laden aus dem Nur-Lese-Speicher) und sogar EXP (Exponentiation)!  Alles in allem scheint dies eine sehr teure M√∂glichkeit zu sein, Daten aufzuzeichnen.  Und das Schlimmste ist, dass SSTORE zu oft aufgerufen wird.  Was ist hier los? <br><br>  Ein paar Dinge.  Es stellt sich heraus, dass das Speichern von 8-Bit-Ganzzahlen fast das Schlimmste ist, was Sie mit EVM / Solidity tun k√∂nnen (der Artikel, auf den ich am Anfang verwiesen habe, spricht dar√ºber).  Wir verlieren auf Schritt und Tritt an Produktivit√§t (was bedeutet, dass wir mehr Benzin bezahlen).  Erstens, wenn wir ein Array von 8-Bit-Werten an den Eingang unserer Funktion √ºbergeben, wird jeder von ihnen auf 256 Bit erweitert.  Das hei√üt, nur durch die Gr√∂√üe der Transaktionsdaten verlieren wir bereits 32 Mal!  Sch√∂n  Ein aufmerksamer Leser wird jedoch feststellen, dass die Kosten f√ºr das gespeicherte Byte dennoch nur 13-mal h√∂her sind als das theoretische Minimum und nicht 32-mal, was bedeutet, dass beim Speichern des Vertrags im permanenten Speicher nicht alles so schlecht ist.  Hier ist die Sache: Beim Speichern werden die Daten immer noch gepackt, und im permanenten Speicher des Vertrags werden unsere 8-Bit-Nummern auf die effizienteste Weise gespeichert, 32 Teile in jedem Speicherblock.  Dies wirft die Frage auf, aber wie erfolgt die Konvertierung der entpackten 256-Bit-Zahlen, die bei der Eingabe der Funktion zu uns gekommen sind, in eine gepackte Form?  Die Antwort lautet "die d√ºmmste Art, die ich mir vorstellen kann." <br><br>  Wenn wir alles, was passiert, in vereinfachter Form aufschreiben, wird unsere einsame Codezeile zu einem unheimlichen Zyklus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.length; ++i) { <span class="hljs-comment"><span class="hljs-comment">//      ,    256-bit  8-bit uint8 from_value = uint8(data[i]); //  32-     -        ,     uint256 to_value = get_storage_data_at_offset(m_test, i); //        (    2  ) add_byte_to_value(to_value, i % 32, from_value); //  32-      set_storage_data_at_offset(m_test, i, to_value); }</span></span></code> </pre><br>  Das Aussehen dieses Codes wird durch das Ein- und Ausschalten der Optimierung (zumindest in der Solidity-Compiler-Version 0.4.24) kaum beeinflusst. Wie Sie sehen, wird SSTORE (als Teil von set_storage_data_at_offset) 32-mal h√§ufiger als erforderlich aufgerufen (einmal f√ºr jede 8-Bit-Nummer und nicht einmal f√ºr 32 solcher Nummern).  Was uns vor dem kompletten Fiasko bewahrt, ist, dass die Neuaufnahme in derselben Zelle nicht 20.000, sondern 5.000 Gas kostet.  Alle 32 Bytes kosten uns also 20.000 + 5.000 * 31 = 125.000 Gas oder ungef√§hr 4.000 Gas pro Byte.  Der Rest des Wertes, den wir oben gesehen haben, stammt aus dem Lesen des Speichers (ebenfalls keine billige Operation) und anderen Berechnungen, die im obigen Code in Funktionen versteckt sind (und es gibt viele davon). <br><br>  Nun, wir k√∂nnen mit dem Compiler nichts anfangen, <s>also werden wir nach einer Schaltfl√§che suchen</s> .  Es bleibt nur zu schlie√üen, dass es nicht notwendig ist, auf diese Weise Arrays von 8-Bit-Zahlen zu √ºbertragen und in den Vertragsfeldern zu speichern. <br><br><h2>  Einfache L√∂sung f√ºr 8-Bit-Zahlen </h2><br>  Und was ist notwendig?  Und so: <br><br><pre> <code class="javascript hljs">bytes m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre><br>  Wir arbeiten in allen Bereichen von Typbytes.  Mit diesem Ansatz kostet das Speichern von 100 Werten 129914 Gas - nur 1300 Gas pro Byte, sechsmal besser als mit uint8 []!  Die Kosten hierf√ºr sind einige Unannehmlichkeiten - die Elemente eines Arrays von Typbytes sind vom Typ Bytes1, die nicht automatisch in einen der √ºblichen Ganzzahltypen konvertiert werden. Daher m√ºssen Sie die explizite Typkonvertierung an den richtigen Stellen platzieren.  Nicht sehr sch√∂n, aber der Gewinn ist sechsmal so hoch wie die Kosten f√ºr die Aufnahme. Ich denke, es lohnt sich!  Und ja, wir werden ein wenig verlieren, wenn wir mit diesen Daten arbeiten, dann beim Lesen, verglichen mit dem Speichern jeder Zahl als 256-Bit, aber hier beginnt die Skalierung eine Rolle zu spielen: Der Gewinn durch das Speichern von tausend oder zwei 8-Bit-Zahlen in gepackter Form kann √ºberwiegen je nach Aufgabe die Verluste, wenn Sie sie sp√§ter lesen. <br><br>  Bevor ich zu diesem Ansatz kam, habe ich zun√§chst versucht, eine effizientere Funktion zum Speichern von Daten im lokalen Makro-Assembler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JULIA</a> zu schreiben, aber ich bin auf einige Probleme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesto√üen</a> , die meine L√∂sung etwas weniger effizient machten und einen Verbrauch von etwa 1530 Gas ergaben pro Byte.  In diesem Artikel ist es jedoch immer noch n√ºtzlich, sodass die Arbeit nicht umsonst ausgef√ºhrt wurde. <br><br>  Au√üerdem stelle ich fest, dass je mehr Daten Sie gleichzeitig speichern, desto weniger Kosten pro Byte anfallen, was darauf hindeutet, dass ein Teil der Kosten feststeht.  Wenn Sie beispielsweise 3000 Werte speichern, erhalten wir bei Ann√§herung an Bytes 900 Gas pro Byte. <br><br><h2>  Allgemeinere L√∂sung </h2><br>  Nun, das ist alles gut, das endet gut, oder?  Unsere Probleme endeten hier jedoch nicht, da wir manchmal nicht nur 8-Bit-Zahlen in den Vertragsspeicher schreiben m√∂chten, sondern auch andere Datentypen, die nicht direkt mit dem Bytetyp √ºbereinstimmen.  Das hei√üt, es ist klar, dass alles in den Bytepuffer codiert werden kann, aber es sp√§ter m√∂glicherweise nicht mehr bequem und sogar teuer zu bekommen, da unn√∂tige Gesten zum Konvertieren des Rohspeichers in den gew√ºnschten Typ erforderlich sind.  Daher ist die Funktion, mit der das √ºbertragene Byte-Array in einem Array des gew√ºnschten Typs gespeichert wird, f√ºr uns weiterhin n√ºtzlich.  Es ist ganz einfach, aber ich habe lange gebraucht, um alle notwendigen Informationen zu finden und EVM und JULIA zu verstehen, um sie zu schreiben, und all dies wurde nicht an einem Ort gesammelt.  Daher denke ich, dass es n√ºtzlich sein wird, wenn ich hierher bringe, was ich ausgegraben habe. <br><br>  Lassen Sie uns zun√§chst dar√ºber sprechen, wie Solidity ein Array im Speicher speichert.  Arrays sind ein Konzept, das nur im Rahmen von Solidity existiert. EVM wei√ü nichts √ºber sie, sondern speichert einfach ein virtuelles Array von 2 ^ 256 32-Byte-Bl√∂cken.  Es ist klar, dass leere Bl√∂cke nicht gespeichert werden, aber tats√§chlich haben wir eine Tabelle mit nicht leeren Bl√∂cken, deren Schl√ºssel eine 256-Bit-Zahl ist.  Und genau diese Zahl akzeptieren die Befehle EVM SSTORE und SLOAD (dies ist aus der Dokumentation nicht ganz ersichtlich). <br><br>  Um Arrays zu speichern, macht Solidity eine so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">knifflige Sache</a> : Erstens wird das "Haupt" -Blockarray irgendwo im konstanten Speicher in der √ºblichen Reihenfolge der Platzierung von Vertragsmitgliedern (oder Strukturen, aber dies ist ein separates Lied) zugewiesen, als ob es w√§re regul√§re 256-Bit-Nummer.  Dies stellt sicher, dass das Array unabh√§ngig von anderen gespeicherten Variablen einen vollst√§ndigen Block empf√§ngt.  Dieser Block speichert die L√§nge des Arrays.  Da dies jedoch nicht im Voraus bekannt ist und sich m√∂glicherweise √§ndert (wir sprechen hier von dynamischen Arrays), mussten die Autoren von Solidity herausfinden, wo die Daten des Arrays abgelegt werden m√ºssen, damit sie sich nicht versehentlich mit den Daten eines anderen Arrays √ºberschneiden.  Genau genommen ist dies eine unl√∂sbare Aufgabe: Wenn Sie zwei Arrays erstellen, die l√§nger als 2 ^ 128 sind, schneiden sie sich garantiert dort, wo Sie sie nicht platzieren. In der Praxis sollte dies jedoch niemand tun. Daher wird dieser einfache Trick verwendet: Nehmen Sie den SHA3-Hash aus der Nummer des Hauptblocks des Arrays und die resultierende Zahl wird als Schl√ºssel in der Tabelle der Bl√∂cke verwendet (die, wie ich mich erinnere, 2 ^ 256).  Mit diesem Schl√ºssel wird der erste Block von Array-Daten platziert und der Rest - bei Bedarf nacheinander.  Die Wahrscheinlichkeit einer Kollision von Nicht-Riesen-Arrays ist √§u√üerst gering. <br><br>  Theoretisch m√ºssen wir also nur herausfinden, wo sich die Array-Daten befinden, und den an uns √ºbergebenen Byte-Puffer Block f√ºr Block kopieren.  W√§hrend wir mit Typen arbeiten, die kleiner als die H√§lfte der Blockgr√∂√üe sind, werden wir die vom Compiler generierte ‚Äûnaive‚Äú L√∂sung zumindest geringf√ºgig gewinnen. <br><br>  Es gibt nur noch ein Problem: Wenn alles so gemacht wird, werden die Bytes in unserem Array r√ºckw√§rts angezeigt.  Weil EVM Big-Endian ist.  Der einfachste und effektivste Weg ist nat√ºrlich das Bereitstellen von Bytes beim Senden. Aus Gr√ºnden der Einfachheit der API habe ich mich jedoch dazu entschlossen, dies im Vertragscode zu tun.  Wenn Sie mehr speichern m√∂chten, k√∂nnen Sie diesen Teil der Funktion verwerfen und zum Zeitpunkt des Sendens alles tun. <br><br>  Hier ist die Funktion, mit der ich ein Array von Bytes in ein Array von 64-Bit-Ganzzahlen mit Vorzeichen umwandeln kann (es kann jedoch leicht an andere Typen angepasst werden): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign_int64_storage_from_bytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int64[] storage to, bytes memory from</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    .      int64,     8    (sizeof  Solidity  :( ) to.length = from.length / 8; //     ,  SHA3      uint256 addr; bytes32 base; assembly{ // keccak256   ,    ,          mstore(addr, to_slot) base := keccak256(addr, 32) } uint i = 0; for(uint offset = 0; offset &lt; from.length; offset += 32) { //  32-     //     32  -  ,   ,     uint256 tmp; assembly{ tmp := mload(add(from, add(offset,32))) } //   .  ,     ,       . for(uint b = 0; b &lt; 16; ++b) { uint shift = b*8; uint shift2 = (256 - (b+1)*8); uint low = (tmp &amp; (0xFF &lt;&lt; shift)) &gt;&gt; shift; uint high = (tmp &amp; (0xFF &lt;&lt; shift2)) &gt;&gt; shift2; tmp = tmp &amp; ~( (0xFF &lt;&lt; shift) | (0xFF &lt;&lt; shift2)); tmp = tmp | (low &lt;&lt; shift2) | (high &lt;&lt; shift); } //      assembly{ sstore(add(base, i), tmp) } i += 1; } }</span></span></code> </pre><br>  Mit 64-Bit-Zahlen haben wir im Vergleich zu dem vom Compiler generierten Code nicht so viel gewonnen wie mit 8-Bit-Zahlen. Dennoch verbraucht diese Funktion 718466 Gas (7184 Gas pro Zahl, 898 Gas pro Byte) gegen√ºber 1003225 f√ºr Naive L√∂sungen (1003 Gas pro Zahl, 1254 pro Byte), was seine Verwendung sehr aussagekr√§ftig macht.  Und wie oben erw√§hnt, k√∂nnen Sie mehr sparen, indem Sie die Byteadresse f√ºr den Anrufer entfernen. <br><br>  Es ist erw√§hnenswert, dass das Gaslimit pro Einheit in Ethereum ein Limit f√ºr die Anzahl der Daten festlegt, die wir in einer Transaktion aufzeichnen k√∂nnen.  Um die Sache noch schlimmer zu machen, ist das Anh√§ngen von Daten an ein bereits gef√ºlltes Array eine viel kompliziertere Aufgabe, es sei denn, der zuletzt verwendete Block des Arrays wurde bis zum Limit gef√ºllt (in diesem Fall k√∂nnen Sie dieselbe Funktion verwenden, jedoch mit einem anderen Einzug).  Derzeit liegt die Gasgrenze pro Block bei etwa 6 Millionen, was bedeutet, dass wir mehr oder weniger 6 KB Daten gleichzeitig speichern k√∂nnen, in Wirklichkeit jedoch aufgrund anderer Kosten sogar noch weniger. <br><br><h2>  Bevorstehende √Ñnderungen </h2><br>  Die bevorstehenden √Ñnderungen im Ethereum-Netzwerk im Oktober, die mit der Aktivierung von EIPs aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstantinopel</a> einhergehen, d√ºrften das Speichern von Daten einfacher und billiger machen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EIP 1087</a> schl√§gt vor, dass die Geb√ºhr f√ºr die Datenspeicherung nicht f√ºr jeden SSTORE-Befehl, sondern f√ºr berechnet wird Die Anzahl der ge√§nderten Bl√∂cke, die den vom Compiler verwendeten naiven Ansatz fast so rentabel machen wie manuell geschriebener Code in JULIA (aber nicht ganz - es wird dort viele zus√§tzliche K√∂rperbewegungen geben, insbesondere f√ºr 8-Bit-Werte).  Der geplante √úbergang zu WebAssembly als Basissprache von EVM wird das Bild noch mehr ver√§ndern, aber dies ist noch eine sehr entfernte Perspektive, und wir m√ºssen die Probleme jetzt l√∂sen. <br><br>  Dieser Beitrag erhebt nicht den Anspruch, die beste L√∂sung f√ºr das Problem zu sein, und ich bin froh, wenn jemand eine effektivere L√∂sung anbietet. Ich habe gerade erst mit Ethereum begonnen und k√∂nnte einige EVM-Funktionen aus den Augen verlieren, die mir helfen k√∂nnten.  Bei meinen Suchanfragen im Internet habe ich jedoch nichts zu diesem Thema gesehen, und m√∂glicherweise sind die oben genannten Gedanken und der obige Code f√ºr jemanden als Ausgangspunkt f√ºr die Optimierung hilfreich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423639/">https://habr.com/ru/post/de423639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423629/index.html">√Ñnderungsmanagement f√ºr die Mars-IT-Infrastruktur</a></li>
<li><a href="../de423631/index.html">Zwei F√§higkeiten, die Ihnen helfen, ein gro√üartiger Entwickler zu werden</a></li>
<li><a href="../de423633/index.html">Wir verwenden 54 Bundesgesetze zum Nutzen der Hausbuchhaltung</a></li>
<li><a href="../de423635/index.html">H√∂rbuchspieler im Retro-Stil</a></li>
<li><a href="../de423637/index.html">7 praktische Lektionen zu UX</a></li>
<li><a href="../de423641/index.html">Deep Learning und OpenVINO Toolkit. Intel Experten Antworten</a></li>
<li><a href="../de423643/index.html">Banken √ºberwachen zunehmend die Reputation ihrer Kunden: Business Insider-Untersuchung</a></li>
<li><a href="../de423645/index.html">Wie wir der Luzhniki-IT-Infrastruktur w√§hrend der Weltmeisterschaft gedient haben</a></li>
<li><a href="../de423647/index.html">Erstellen Sie ein einfaches neuronales Netzwerk</a></li>
<li><a href="../de423651/index.html">Wir laden alle zum Hackathon SmartMail Hack: About Welcome ein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>