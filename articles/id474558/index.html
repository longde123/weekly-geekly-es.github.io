<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏻 ↔️ 🧗🏾 Pemrograman Berorientasi Protokol, Bagian 2 👌 🏆 🧑‍🤝‍🧑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam kelanjutan topik, kami akan memeriksa jenis protokol dan kode umum. 


 Masalah-masalah berikut akan dipertimbangkan sepanjang jalan: 


- imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman Berorientasi Protokol, Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474558/"><p>  Dalam kelanjutan topik, kami akan memeriksa jenis protokol dan kode umum. </p><br><p>  Masalah-masalah berikut akan dipertimbangkan sepanjang jalan: </p><br><ul><li>  implementasi polimorfisme tanpa jenis warisan dan referensi </li><li>  bagaimana objek tipe protokol disimpan dan digunakan </li><li>  bagaimana metode pengiriman bekerja dengan mereka </li></ul><a name="habracut"></a><br><h2 id="protokolnye-tipy">  <strong>Jenis Protokol</strong> </h2><br><p>  <strong>Implementasi polimorfisme tanpa jenis warisan dan referensi:</strong> </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, x2, y1, y2: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawbles = [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawbles { d.draw() }</code> </pre> <br><ol><li>  Nyatakan protokol Drawable, yang memiliki metode draw. </li><li>  Kami menerapkan protokol ini untuk Point dan Line - sekarang Anda dapat menanganinya dengan Drawable (panggil metode draw) </li></ol><br><p>  Kami masih memiliki kode polimorfik.  Elemen d dari array drawables memiliki satu antarmuka, yang ditunjukkan dalam protokol Drawable, tetapi memiliki implementasi metode yang berbeda, yang ditunjukkan dalam Line dan Point. </p><br><blockquote>  Prinsip utama (ad-hoc) dari polimorfisme: "Antarmuka umum - banyak implementasi" </blockquote><p>  <strong>Pengiriman dinamis tanpa tabel virtual</strong> </p><br><p>  Ingat bahwa definisi implementasi metode yang benar ketika bekerja dengan kelas (tipe referensi) dicapai melalui Dynamic Submission dan tabel virtual.  Setiap tipe kelas memiliki tabel virtual, ia menyimpan implementasi dari metodenya.  Dynamic dispatch mendefinisikan implementasi metode untuk suatu tipe dengan melihat tabel virtualnya.  Semua ini diperlukan karena kemungkinan pewarisan dan penggantian metode. </p><br><p>  Dalam kasus struktur, pewarisan, serta redefinisi metode, adalah mustahil.  Kemudian, pada pandangan pertama, tidak perlu meja virtual, tetapi bagaimana kemudian pengiriman dinamis bekerja?  Bagaimana program memahami metode mana yang akan dipanggil pada d.draw ()? </p><br><blockquote>  Perlu dicatat bahwa jumlah implementasi metode ini sama dengan jumlah jenis yang sesuai dengan protokol Drawable. </blockquote><br><h2 id="protocol-witness-table">  <strong>Tabel saksi protokol</strong> </h2><br><p>  adalah jawaban untuk pertanyaan ini.  Setiap jenis yang mengimplementasikan protokol memiliki tabel ini.  Seperti tabel virtual untuk kelas, ia menyimpan implementasi metode yang diperlukan protokol. </p><br><blockquote>  selanjutnya, Tabel Saksi Protokol akan disebut “tabel metode protokol” </blockquote><p>  Oke, sekarang kita tahu di mana harus mencari implementasi metode.  Hanya dua pertanyaan yang tersisa: </p><br><ol><li>  Bagaimana menemukan tabel metode protokol yang sesuai untuk objek yang mengimplementasikan protokol ini?  Bagaimana dalam kasus kami menemukan tabel ini untuk elemen d dari array yang dapat ditarik? </li><li>  Elemen array harus berukuran sama (ini adalah inti dari array).  Lalu bagaimana sebuah array yang dapat digambar memenuhi persyaratan ini jika dapat menyimpan Line dan Point di dalamnya, dan mereka memiliki ukuran yang berbeda? </li></ol><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)) <span class="hljs-comment"><span class="hljs-comment">// 32 bits MemoryLayout.size(ofValue: Point(...)) // 16 bits</span></span></code> </pre> <br><h3 id="ekzistencialnyy-konteyner">  Wadah yang ada </h3><br><p>  Untuk mengatasi dua masalah ini, Swift menggunakan skema penyimpanan khusus untuk contoh tipe protokol yang disebut wadah eksistensial.  Ini terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/ru/nt/v_/runtv_rsqkbtwyq0soofiqidbde.jpeg"></p><br><p>  Dibutuhkan 5 kata mesin (dalam sistem x64 bit 5 * 8 = 40 bit).  Ini dibagi menjadi tiga bagian: </p><br><p>  value buffer - ruang untuk instance itu sendiri <br>  vwt - penunjuk ke Tabel Nilai Saksi <br>  pwt - pointer ke Protokol Witness Table </p><br><p>  Pertimbangkan ketiga bagian secara lebih rinci: </p><br><p>  <strong>Penyangga Konten</strong> </p><br><p>  Hanya tiga kata mesin untuk menyimpan sebuah instance.  Jika instance dapat masuk dalam buffer konten, maka ia disimpan di dalamnya.  Jika instance memiliki lebih dari 3 kata mesin, maka itu tidak akan muat di buffer dan program dipaksa untuk mengalokasikan memori pada heap, meletakkan instance di sana, dan meletakkan pointer ke memori ini di buffer konten.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...)</code> </pre> <br><p>  Point () menempati 2 kata mesin dan sangat cocok dengan buffer nilai - program akan meletakkannya di sana: </p><br><p><img src="https://habrastorage.org/webt/c3/it/ir/c3itirb85eqbbrvpop_9jstl0vm.jpeg"></p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)</code> </pre> <br><p>  Line () menempati 4 kata mesin dan tidak dapat masuk dalam buffer nilai - program akan mengalokasikan memori untuk heap, dan menambahkan pointer ke memori ini dalam buffer nilai: </p><br><p><img src="https://habrastorage.org/webt/jm/5w/yj/jm5wyjsk6zazutscdsx8a1a32y4.jpeg"></p><br><p>  ptr menunjuk ke instance Line () yang ditempatkan di heap: </p><br><p><img src="https://habrastorage.org/webt/we/sk/td/wesktdeuiw6iypty_2dkbklezgm.jpeg"></p><br><p>  <strong>Tabel siklus hidup</strong> </p><br><p>  Seperti halnya tabel metode protokol, setiap tabel yang memiliki protokol memiliki tabel ini.  Ini berisi implementasi empat metode: mengalokasikan, menyalin, merusak, membatalkan alokasi.  Metode-metode ini mengendalikan seluruh siklus hidup suatu objek.  Pertimbangkan sebuah contoh: </p><br><ol><li>  Saat membuat objek (Point (...) sebagai Drawable), metode alokasi dari T.Zh.  objek ini.  Metode alokasi akan memutuskan di mana konten objek harus ditempatkan (di buffer nilai atau di heap), dan jika harus ditempatkan di heap, itu akan mengalokasikan jumlah memori yang diperlukan. </li><li>  Metode penyalinan akan menempatkan konten objek di tempat yang sesuai. </li><li>  Setelah menyelesaikan pekerjaan dengan objek, metode destruct akan dipanggil, yang akan mengurangi semua jumlah tautan, jika ada </li><li>  Setelah destruct, metode deallocate akan dipanggil, yang akan membebaskan memori yang dialokasikan pada heap, jika ada </li></ol><br><p>  <strong>Tabel metode protokol</strong> </p><br><p>  Seperti dijelaskan di atas, ini berisi implementasi metode yang diperlukan oleh protokol untuk jenis yang terikat tabel ini. </p><br><p>  <strong>Wadah Eksistensial - Jawaban</strong> </p><br><p>  Jadi, kami menjawab dua pertanyaan yang diajukan: </p><br><ol><li>  Tabel metode protokol disimpan dalam wadah Eksistensial dari objek ini dan dapat dengan mudah diperoleh darinya </li><li>  Jika tipe elemen dari array adalah sebuah protokol, maka setiap elemen dari array ini mengambil nilai tetap dari 5 kata-kata mesin - ini adalah persis apa yang diperlukan untuk sebuah wadah Eksistensial.  Jika konten elemen tidak dapat ditempatkan di buffer nilai, maka itu akan ditempatkan di heap.  Jika bisa, maka semua konten akan ditempatkan di buffer nilai.  Bagaimanapun, kita mendapatkan bahwa ukuran objek dengan tipe protokol adalah 5 kata-kata mesin (40 bit), dan karena itu semua elemen array akan memiliki ukuran yang sama. </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: line) <span class="hljs-comment"><span class="hljs-comment">// 40 bits let drawables: [Drawable] = [Line(...), Point(...), Line(...)] MemoryLayout.size(ofValue: drawables._content) // 120 bits</span></span></code> </pre> <br><p>  <strong>Wadah Eksistensial - Contoh</strong> </p><br><p>  Pertimbangkan perilaku wadah eksistensial dalam kode ini: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) drawACopy(val)</code> </pre> <br><p>  Wadah eksistensial dapat direpresentasikan seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExistContDrawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBuffer: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vwt: <span class="hljs-type"><span class="hljs-type">ValueWitnessTable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pwt: <span class="hljs-type"><span class="hljs-type">ProtocolWitnessTable</span></span> }</code> </pre> <br><p>  <strong>Kode palsu</strong> </p><br><p>  Di belakang layar, fungsi drawACopy mengambil dalam ExistContDrawable: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... }</code> </pre> <br><p>  Parameter fungsi dibuat secara manual: buat wadah, isi bidangnya dari argumen yang diterima: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> local = <span class="hljs-type"><span class="hljs-type">ExistContDrawable</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vwt = val.vwt <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pwt = val.pwt local.type = type local.pwt = pwt ... }</code> </pre> <br><p>  Kami memutuskan di mana konten akan disimpan (di buffer atau heap).  Kami memanggil vwt.allocate dan vwt.copy untuk mengisi konten lokal dengan val: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.allocateBufferAndCopy(&amp;local, val) }</code> </pre> <br><p>  Kami memanggil metode draw dan memberikannya pointer ke self (metode projectBuffer akan memutuskan di mana self berada - di buffer atau di heap - dan mengembalikan pointer yang benar): </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... pwt.draw(vwt.projectBuffer(&amp;local)) }</code> </pre> <br><p>  Kami selesai bekerja dengan lokal.  Kami membersihkan semua tautan pinggul dari lokal.  Fungsi mengembalikan nilai - kami menghapus semua memori yang dialokasikan untuk drawACopy (bingkai tumpukan): </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.destructAndDeallocateBuffer(&amp;local) }</code> </pre> <br><p>  <strong>Wadah Eksistensial - Tujuan</strong> </p><br><p>  Menggunakan wadah eksistensial membutuhkan banyak pekerjaan - contoh di atas mengkonfirmasi ini - tetapi mengapa itu perlu, apa tujuannya?  Tujuannya adalah untuk mengimplementasikan polimorfisme menggunakan protokol dan tipe yang mengimplementasikannya.  Dalam OOP, kami menggunakan kelas abstrak dan mewarisinya dengan metode utama.  Di EPP, kami menggunakan protokol dan menerapkan persyaratannya.  Sekali lagi, bahkan dengan protokol, menerapkan polimorfisme adalah pekerjaan yang besar dan menghabiskan energi.  Karena itu, untuk menghindari pekerjaan yang "tidak perlu", Anda perlu memahami kapan polimorfisme dibutuhkan, dan kapan tidak. </p><br><p>  Polimorfisme dalam implementasi EPP menang dalam kenyataan bahwa, dengan menggunakan struktur, kita tidak memerlukan penghitungan referensi konstan, tidak ada pewarisan kelas.  Ya, semuanya sangat mirip, kelas menggunakan tabel virtual untuk menentukan implementasi suatu metode, protokol menggunakan protokol-metode.  Kelas ditempatkan di heap, struktur juga kadang-kadang dapat ditempatkan di sana.  Tetapi masalahnya adalah bahwa setiap kelas pointer dapat diarahkan ke kelas yang ditempatkan di heap, dan penghitungan referensi diperlukan, tetapi hanya satu pointer ke struktur yang ditempatkan di heap dan disimpan dalam wadah eksistensial. </p><br><p>  Bahkan, penting untuk dicatat bahwa struktur yang disimpan dalam wadah eksistensial akan mempertahankan semantik tipe nilai, terlepas dari apakah itu ditempatkan di tumpukan atau tumpukan.  Tabel Siklus Hidup bertanggung jawab untuk pelestarian semantik karena menjelaskan metode yang menentukan semantik. </p><br><p>  <strong>Wadah Eksistensial - Properti Tersimpan</strong> </p><br><p>  Kami memeriksa bagaimana variabel tipe protokol dilewatkan dan digunakan oleh suatu fungsi.  Mari kita pertimbangkan bagaimana variabel-variabel tersebut disimpan: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> f: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> s: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>) { first = f second = s } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Line</span></span>(), <span class="hljs-type"><span class="hljs-type">Point</span></span>())</code> </pre> <br><p>  Bagaimana dua struktur yang dapat ditarik ini disimpan di dalam struktur Pair?  Apa isi dari pasangan  Ini terdiri dari dua wadah eksistensial - satu untuk pertama, yang lain untuk kedua.  Garis tidak dapat masuk dalam buffer dan ditempatkan di heap.  Poin pas di buffer.  Ini juga memungkinkan struktur Pair untuk menyimpan objek dengan ukuran berbeda: </p><br><pre> <code class="swift hljs">pair.second = <span class="hljs-type"><span class="hljs-type">Line</span></span>()</code> </pre> <br><p>  Sekarang, isi detik juga diletakkan di heap, karena tidak muat di buffer.  Pertimbangkan apa yang menyebabkan hal ini: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p>  Setelah menjalankan kode ini, program akan menerima status memori berikut: </p><br><p><img src="https://habrastorage.org/webt/yp/qz/td/ypqztdofriyggwgvlrl2rc3wvtc.jpeg"></p><br><p>  Kami memiliki 4 alokasi memori di heap, yang tidak bagus.  Mari kita coba perbaiki: </p><br><ol><li>  Buat Garis kelas analog </li></ol><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineStorage</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><ol><li>  Kami menggunakannya dalam Pair </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lineStorage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(lineStorage, lineStorage) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p>  Kami mendapatkan satu penempatan di heap dan 4 petunjuk untuk itu: </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p>  Tapi kami berurusan dengan perilaku referensial.  Mengubah copy.first akan memengaruhi pair.first (sama dengan .second), yang tidak selalu seperti yang kita inginkan. </p><br><p>  <strong>Penyimpanan tidak langsung dan menyalin pada perubahan (copy-on-write)</strong> </p><br><p>  Sebelum itu, disebutkan bahwa String adalah struktur copy-on-write (menyimpan kontennya di heap dan menyalinnya ketika itu berubah).  Pertimbangkan bagaimana Anda dapat menerapkan struktur Anda, yang disalin ketika mengubah: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BetterLine</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storage: <span class="hljs-type"><span class="hljs-type">LineStorage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isKnownUniquelyReferenced(&amp;storage) { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.storage) } <span class="hljs-comment"><span class="hljs-comment">// storage editing } }</span></span></code> </pre> <br><ol><li>  BetterLine menyimpan semua properti dalam penyimpanan, dan penyimpanan adalah kelas dan disimpan di heap. </li><li>  Penyimpanan hanya dapat diubah menggunakan metode pindah.  Di dalamnya, kami memeriksa bahwa hanya satu pointer yang menunjuk ke penyimpanan.  Jika ada lebih banyak petunjuk, maka BetterLine ini berbagi penyimpanan dengan seseorang, dan agar BetterLine berperilaku sepenuhnya sebagai struktur, penyimpanan harus bersifat individu - kami membuat salinan dan bekerja dengannya di masa mendatang. </li></ol><br><p>  Mari kita lihat cara kerjanya di memori: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">BetterLine</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair copy.second.x1 = <span class="hljs-number"><span class="hljs-number">3.0</span></span></code> </pre> <br><p>  Sebagai hasil dari mengeksekusi kode ini, kita mendapatkan: </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p>  Dengan kata lain, kami memiliki dua instance Pair yang berbagi penyimpanan yang sama: LineStorage.  Saat mengubah penyimpanan di salah satu penggunanya (pertama / kedua), salinan penyimpanan terpisah untuk pengguna ini akan dibuat sehingga perubahannya tidak memengaruhi orang lain.  Ini memecahkan masalah pelanggaran semantik tipe nilai dari contoh sebelumnya. </p><br><h2 id="protokolnye-tipy---itog">  Jenis Protokol - Ringkasan </h2><br><ol><li>  <em>Nilai kecil</em> .  Jika kita bekerja dengan objek yang menghabiskan sedikit memori dan dapat ditempatkan di buffer wadah eksistensial, maka: </li></ol><br><ul><li>  tidak akan ada penempatan di heap </li><li>  tidak ada penghitungan referensi </li><li>  polimorfisme (pengiriman dinamis) menggunakan tabel protokol </li></ul><br><ol><li>  <em>Nilai luar biasa.</em>  Jika kami bekerja dengan objek yang tidak sesuai dengan buffer, maka: </li></ol><br><ul><li>  penempatan tumpukan </li><li>  referensi menghitung jika benda mengandung tautan. </li></ul><br><blockquote>  Mekanisme penggunaan penulisan ulang untuk perubahan dan penyimpanan tidak langsung telah ditunjukkan dan dapat secara signifikan memperbaiki situasi dengan penghitungan referensi jika ada banyak dari mereka. </blockquote><p>  Kami menemukan bahwa jenis protokol, seperti kelas, mampu mewujudkan polimorfisme.  Ini terjadi dengan menyimpan dalam wadah eksistensial dan menggunakan tabel protokol - tabel siklus hidup dan tabel metode protokol. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474558/">https://habr.com/ru/post/id474558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474546/index.html">Pindah dari Terraform ke CloudFormation - dan menyesal</a></li>
<li><a href="../id474548/index.html">Google BERT adalah algoritma pencarian baru. Bagaimana peringkat akan berubah dan apa yang harus dilakukan sekarang?</a></li>
<li><a href="../id474550/index.html">Bagaimana cara mengembalikan indikator TLS hijau di Firefox 70 yang baru?</a></li>
<li><a href="../id474554/index.html">Intel Tremont - Mikroarsitektur Baru untuk Efisiensi Energi</a></li>
<li><a href="../id474556/index.html">Cara membuat dukungan PCRE2 untuk Apache 2.4</a></li>
<li><a href="../id474560/index.html">4 langkah dari seorang ekonom ke manajer pengembangan kustom, atau TI sebagai cara untuk mengatasi kebosanan</a></li>
<li><a href="../id474562/index.html">LEGO MINDSTORMS Education EV3 + MicroPython: kami memprogram konstruktor anak-anak dalam bahasa dewasa</a></li>
<li><a href="../id474564/index.html">Autosampler - Kehidupan Setelah Kehidupan</a></li>
<li><a href="../id474566/index.html">Kota ini membutuhkan pahlawan baru: ulasan tentang ransel tahan-bukti Bobby Hero</a></li>
<li><a href="../id474568/index.html">Susu dari gigi: perubahan profesi untuk sel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>