<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµ üîµ üçî Como o PageRank funciona: implementando em R via √°lgebra linear e o m√©todo de pot√™ncia üë©üèº‚Äç‚öñÔ∏è üëãüèª ü§µüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°, cidad√£os de Habrovsk! 

 Meu nome √© Alex. Desta vez, eu transmito do local de trabalho no ITAR-TASS. 

 Neste breve texto, apresentarei o m√©todo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o PageRank funciona: implementando em R via √°lgebra linear e o m√©todo de pot√™ncia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439332/">  Ol√°, cidad√£os de Habrovsk! <br><br>  Meu nome √© Alex.  Desta vez, eu transmito do local de trabalho no ITAR-TASS. <br><br>  Neste breve texto, apresentarei o m√©todo de c√°lculo do PageRank ¬© (a seguir denominado PR) usando exemplos simples e compreens√≠veis, na linguagem R. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O algoritmo</a> √© uma propriedade intelectual do Google, mas, devido √† sua utilidade para tarefas de an√°lise de dados, muitas tarefas s√£o usadas , que pode ser reduzido √† pesquisa de n√≥s grandes no gr√°fico e √† classifica√ß√£o por import√¢ncia. <br><br>  Mencionar uma grande empresa em um post n√£o √© um an√∫ncio. <br><a name="habracut"></a><br>  Como n√£o sou um matem√°tico profissional, uso - e recomendo a voc√™ - este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> e este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial</a> como guia. <br><br><h3>  Compreens√£o intuitiva do PR </h3><br>  Compreender como isso funciona n√£o √© dif√≠cil.  H√° um conjunto de elementos que est√£o interconectados.  Eis como exatamente eles est√£o conectados - essa √© uma pergunta ampla: talvez por meio de links (como o Google), talvez por refer√™ncias uns aos outros (quase os mesmos links), as probabilidades de transi√ß√µes entre elementos (matriz do processo de Markov) possam ser especificadas a priori sem especificar o f√≠sico significado da comunica√ß√£o.  Eu gostaria de atribuir a esses elementos um certo crit√©rio de import√¢ncia, o qual conteria informa√ß√µes sobre a <b>probabilidade de</b> esse elemento ser visitado por alguma part√≠cula abstrata que viaja pelo gr√°fico no processo de difus√£o. <br><br>  Hum, isso n√£o parece muito claro.  √â mais f√°cil imaginar um cara usando um laptop com uma <s>papoula</s> , navegando nas p√°ginas dos resultados de pesquisa, fumando um cachimbo de √°gua, seguindo links de uma p√°gina para outra e cada vez mais aparecendo na mesma p√°gina (ou p√°ginas). <br><br>  Isso se deve ao fato de que algumas p√°ginas que ele visita cont√™m informa√ß√µes t√£o interessantes na fonte original que outras s√£o for√ßadas a reimprimi-las com uma indica√ß√£o do link. <br><br>  Um cara do Google foi nomeado surfista aleat√≥rio.  Ele √© uma part√≠cula no processo de difus√£o: uma discreta mudan√ßa de posi√ß√£o no gr√°fico ao longo do tempo.  E a probabilidade com que ele visita a p√°gina com um tempo de difus√£o tendendo ao infinito √© PR. <br><br><h3>  Implementa√ß√£o simples do c√°lculo de RP </h3><br>  Vamos concordar - trabalhamos com 10 elementos, em um gr√°fico t√£o pequeno e acolhedor. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark)</span></span></code> </pre> <br>  Cada um dos 10 elementos (n√≥s) cont√©m de 10 a 14 refer√™ncias a outros n√≥s em uma ordem aleat√≥ria, excluindo-se.  No momento, apenas decidimos que os dados mencionados s√£o um link da web. <br><br>  √â claro que pode acontecer que algum elemento seja mencionado com mais frequ√™ncia do que outros.  Veja isso. <br><blockquote>  A prop√≥sito, eu recomendo usar o pacote data.table para experimentos.  Em conjunto com os princ√≠pios da arruma√ß√£o, tudo acontece de forma eficiente e r√°pida. </blockquote><img src="https://habrastorage.org/webt/jl/qc/jm/jlqcjm-czf_eyevyiz1uxlssav0.png"><br><br>  √â assim que a nossa matriz de links se parece (chamada em ingl√™s geralmente a matriz de adjac√™ncia). <br><br>  A soma em cada coluna √© maior que zero, o que significa que h√° uma conex√£o de cada elemento com outro elemento (isso √© importante para an√°lises posteriores). <br><blockquote>  &gt; aplicar (dt [, - 1, com = F], 2, soma) <br>  abcdefghij <br>  11 14 10 10 11 13 11 11 11 12 <br></blockquote><br>  Com base nessa tabela, podemos criar a chamada matriz de afinidade, ou, em nossa opini√£o, a matriz de proximidade (e tamb√©m √© chamada de matriz de transi√ß√£o), que os matem√°ticos chamam de matriz estoc√°stica (matriz estoc√°stica de coluna): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fonte principal</a> <br><br>  Atribua-o a uma vari√°vel chamada A. <br><br><img src="https://habrastorage.org/webt/xv/x-/f0/xvx-f0z6eow64ngtc4tkofqolj8.png"><br><br>  O mais importante agora √© que a soma em todas as colunas seja igual a uma. <br><blockquote>  &gt; colSums (A) <br>  abcdefghij <br>  1 1 1 1 1 1 1 1 1 1 1 <br></blockquote><br>  Aqui est√° - uma matriz de transi√ß√µes, √© Markov, s√£o semelhan√ßas.  As figuras s√£o as probabilidades de transi√ß√µes de um elemento em uma coluna para um elemento em uma linha. <br><br>  Naturalmente, essas n√£o s√£o "semelhan√ßas" reais.  O presente seria, por exemplo, se calcularmos o cosseno do √¢ngulo entre a apresenta√ß√£o dos documentos.  Mas √© importante que a matriz de transi√ß√£o seja reduzida a (pseudo-) probabilidades, para que a soma de cada coluna seja igual a uma. <br><br>  Vejamos o gr√°fico de transi√ß√£o de Markov (nosso A): <br><br><img src="https://habrastorage.org/webt/s9/yv/br/s9yvbr-kaqvsyfqs0wokofkojpk.png"><br><br>  Tudo √© aproximadamente igualmente confuso).  Isso ocorre porque especificamos transi√ß√µes equiprob√°veis. <br><br>  <b>E agora √© a hora da m√°gica!</b> <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2))</span></span></code> </pre><br>  Para uma matriz estoc√°stica A, o primeiro valor pr√≥prio deve ser igual √† unidade e o vetor pr√≥prio correspondente √© o vetor PageRank. <br><blockquote>  &gt; impress√£o (redonda (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Esse √© o vetor dos valores de PR - este √© o vetor pr√≥prio normalizado da matriz de transi√ß√£o A correspondente ao valor pr√≥prio dessa matriz igual √† unidade - o vetor pr√≥prio dominante. <br><br>  Agora voc√™ pode classificar os elementos.  Mas, devido √†s especificidades do experimento, eles t√™m um peso muito semelhante. <br><br><h3>  Problemas e suas solu√ß√µes usando o m√©todo de pot√™ncia </h3><br>  A matriz de transi√ß√£o A pode n√£o satisfazer as condi√ß√µes de estoc√°stica. <br><br>  <b>Primeiro, pode haver elementos que n√£o se referem a lugar algum, ou seja, com a aus√™ncia de feedback (eles podem se referir a eles mesmos).</b>  <b>Para grandes gr√°ficos reais, esse √© um problema prov√°vel.</b>  <b>Isso significa que uma das colunas da matriz ter√° apenas zeros.</b>  <b>Nesse caso, a solu√ß√£o atrav√©s de vetores pr√≥prios n√£o funcionar√°.</b> <br><br>  O Google resolveu esse problema preenchendo uma coluna com uma distribui√ß√£o de probabilidade uniforme p = 1 / N.  Onde N √© o n√∫mero de todos os elementos. <br><br><pre> <code class="python hljs">dim<span class="hljs-number"><span class="hljs-number">.1</span></span> &lt;- dim(A)[<span class="hljs-number"><span class="hljs-number">1</span></span>] A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.data.table(A) nul_cols &lt;- apply(A, <span class="hljs-number"><span class="hljs-number">2</span></span>, function(x) sum(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sum(nul_cols) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) <span class="hljs-number"><span class="hljs-number">1</span></span> / dim<span class="hljs-number"><span class="hljs-number">.1</span></span>) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.matrix(A)</code> </pre><br>  <b>Em segundo lugar, o gr√°fico pode conter elementos com feedback um para o outro, mas n√£o os elementos restantes do gr√°fico.</b>  <b>Esse tamb√©m √© um problema intranspon√≠vel para √°lgebra linear devido √† viola√ß√£o de suposi√ß√µes.</b> <br><br>  Isso √© resolvido atrav√©s da introdu√ß√£o de uma constante chamada fator de amortecimento, que indica a probabilidade a priori de uma transi√ß√£o de um elemento para outro, mesmo que n√£o haja links f√≠sicos.  Em outras palavras, a difus√£o √© poss√≠vel em qualquer estado. <br><br><pre> <code class="python hljs">d = <span class="hljs-number"><span class="hljs-number">0.15</span></span> <span class="hljs-comment"><span class="hljs-comment">#damping factor (to ensure algorithm convergence) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix</span></span></code> </pre><br>  Se aplicarmos essas transforma√ß√µes √† nossa matriz, ela poder√° ser resolvida novamente por meio de vetores pr√≥prios! <br><br>  <b>Em terceiro lugar, a matriz brega pode n√£o ser quadrada, mas isso √© cr√≠tico!</b>  <b>N√£o vou me debru√ßar sobre este momento, porque acredito que voc√™ mesmo descobrir√° como consert√°-lo.</b> <br><br>  Mas existe um m√©todo mais r√°pido e preciso, que tamb√©m √© mais econ√¥mico na mem√≥ria (que pode ser relevante para gr√°ficos grandes): M√©todo de pot√™ncia. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names</span></span></code> </pre><br>  Voila! <br><blockquote>  &gt; impress√£o (redonda (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br>  &gt; print (redondo (pr2, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Nisto terminarei o tutorial.  Espero que voc√™ ache √∫til. <br><br>  Esqueci de dizer que, para construir uma matriz de transi√ß√µes (probabilidades), voc√™ pode usar a semelhan√ßa de textos, o n√∫mero de refer√™ncias, o fato de um link e outras m√©tricas que levam a pseudo-probabilidades ou s√£o probabilidades.  Um exemplo bastante interessante √© a classifica√ß√£o das senten√ßas no texto na matriz de similaridade dos sacos de palavras tf-idf para destacar a frase que resume o texto inteiro.  Pode haver outros usos criativos do PR. <br><br>  Eu recomendo tentar por conta pr√≥pria brincar com a matriz de transi√ß√£o e garantir valores legais de RP, que tamb√©m s√£o f√°ceis de interpretar. <br><br>  Se voc√™ vir imprecis√µes ou erros comigo - indique nos coment√°rios ou na mensagem e eu corrigirei tudo. <br><br>  Todo o c√≥digo √© compilado aqui: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark) ## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2)) ## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names print(round(pr, 2)) print(round(pr2, 2))</span></span></code> </pre><br></div></div><br>  PS: toda essa ideia tamb√©m √© facilmente implementada em outras linguagens, pelo menos em Python, fiz tudo sem dificuldade. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439332/">https://habr.com/ru/post/pt439332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439320/index.html">Como diversificar as aulas de programa√ß√£o para crian√ßas de diferentes idades</a></li>
<li><a href="../pt439324/index.html">Usando uma √°rvore bin√°ria em swift com enum usando OCR como exemplo</a></li>
<li><a href="../pt439326/index.html">Captador el√©trico Ford F-150 EV - no prot√≥tipo e testado na estrada</a></li>
<li><a href="../pt439328/index.html">Ok Google! Voc√™ √© bom ou mau?</a></li>
<li><a href="../pt439330/index.html">Reconhecimento de n√∫meros. Como obtivemos 97% de precis√£o para n√∫meros ucranianos. Parte 2</a></li>
<li><a href="../pt439334/index.html">Cerca de 2 bilh√µes de rublos alocados para a implementa√ß√£o do projeto de lei sobre runas sustent√°veis</a></li>
<li><a href="../pt439336/index.html">Estamos procurando uma agulha em uma pilha sem usar algoritmos conhecidos</a></li>
<li><a href="../pt439338/index.html">Esque√ßa a privacidade: voc√™ ainda tem uma segmenta√ß√£o terr√≠vel</a></li>
<li><a href="../pt439340/index.html">Backup do GDPR - como a nova ferramenta ajudar√°</a></li>
<li><a href="../pt439342/index.html">DIYorDIE Winter Meetup 17 de fevereiro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>