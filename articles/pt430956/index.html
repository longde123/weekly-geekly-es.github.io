<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÆ üôÖ üî´ Ensinamos um porco a monoides a acreditar em si mesmos e voar üë®üèæ‚Äç‚úàÔ∏è üå¨Ô∏è üë©üèø‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um dos artigos anteriores, falei sobre como voc√™ pode criar um executor de programa para uma m√°quina de pilha virtual usando abordagens de programa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ensinamos um porco a monoides a acreditar em si mesmos e voar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430956/"><p> Em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> dos artigos anteriores, falei sobre como voc√™ pode criar um executor de programa para uma m√°quina de pilha virtual usando abordagens de programa√ß√£o funcional e orientada a linguagem.  A estrutura matem√°tica da linguagem sugeriu a estrutura b√°sica para a implementa√ß√£o de seu tradutor, com base no conceito de semigrupos e monoides.  Essa abordagem me permitiu criar uma implementa√ß√£o bonita e expans√≠vel e quebrar os aplausos, mas a primeira pergunta da plat√©ia me fez sair da tribuna e entrar no Emacs novamente. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p>  Realizei um teste simples e certifiquei-me de que, em tarefas simples que usam apenas a pilha, a m√°quina virtual funcione de maneira inteligente e, ao usar a "mem√≥ria" - uma matriz com acesso aleat√≥rio - grandes problemas come√ßam.  Sobre como conseguimos resolv√™-los sem alterar os princ√≠pios b√°sicos da arquitetura do programa e alcan√ßar uma acelera√ß√£o mil vezes maior do programa, e ser√° discutido neste artigo. </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell √© uma linguagem peculiar com um nicho especial.  O principal objetivo de sua cria√ß√£o e desenvolvimento foi a necessidade da lingua franca expressar e testar id√©ias de programa√ß√£o funcional.  Isso justifica suas caracter√≠sticas mais marcantes: pregui√ßa, extrema pureza, √™nfase nos tipos e manipula√ß√µes com eles.  N√£o foi projetado para o desenvolvimento cotidiano, nem para programa√ß√£o industrial, nem para uso generalizado.  O fato de ser realmente usado para criar projetos de larga escala no setor de redes e no processamento de dados √© a boa vontade dos desenvolvedores, prova de conceito, se voc√™ preferir.  Mas at√© agora, o produto mais importante, amplamente utilizado e surpreendentemente poderoso escrito em Haskell √© ... o compilador ghc.  E isso √© completamente justificado do ponto de vista de seu objetivo - ser uma ferramenta para pesquisas no campo da ci√™ncia da computa√ß√£o.  O princ√≠pio proclamado por Simon Payton-Johnson: "Evite o sucesso a todo custo" √© necess√°rio para que o idioma continue sendo um instrumento.  Haskell √© como uma c√¢mara est√©ril no laborat√≥rio de um centro de pesquisa que desenvolve tecnologias semicondutoras ou nanomateriais.  √â terrivelmente inconveniente trabalhar, e para a pr√°tica cotidiana tamb√©m restringe a liberdade de a√ß√£o, mas sem esses inconvenientes, sem ader√™ncia intransigente √†s restri√ß√µes, n√£o ser√° poss√≠vel observar e estudar os efeitos sutis que mais tarde se tornar√£o a base dos desenvolvimentos industriais.  Ao mesmo tempo, na ind√∫stria, a esterilidade ser√° necess√°ria apenas no volume mais necess√°rio, e os resultados dessas experi√™ncias aparecer√£o em nossos bolsos na forma de gadgets.  Estudamos estrelas e gal√°xias n√£o porque esperamos receber benef√≠cios diretos deles, mas porque, na escala desses objetos impratic√°veis, efeitos qu√¢nticos e relativ√≠sticos se tornam observ√°veis ‚Äã‚Äãe estudados, tanto que, mais tarde, podemos usar esse conhecimento para desenvolver algo muito utilit√°rio.  Portanto, Haskell, com suas linhas "erradas", pregui√ßa impratic√°vel de c√°lculos, rigidez de alguns algoritmos de infer√™ncia de tipos, com uma curva de entrada extremamente √≠ngreme, finalmente n√£o permite que voc√™ crie facilmente um aplicativo inteligente no joelho ou em um sistema operacional.  No entanto, lentes, m√¥nadas, an√°lise combinat√≥ria, uso generalizado de mon√≥ides, m√©todos de comprova√ß√£o autom√°tica de teoremas, gerenciadores de pacotes funcionais declarativos, tipos lineares e dependentes est√£o se aproximando do mundo pr√°tico.  Ele encontra aplica√ß√£o em condi√ß√µes menos est√©reis nos idiomas Python, Scala, Kotlin, F #, Rust e muitos outros.  Mas eu n√£o usaria nenhuma dessas linguagens maravilhosas para ensinar os princ√≠pios da programa√ß√£o funcional: levaria o aluno ao laborat√≥rio, mostraria como ele funciona em exemplos claros e claros e, ent√£o, voc√™ poder√° ver esses princ√≠pios em a√ß√£o na f√°brica. uma m√°quina grande e incompreens√≠vel, mas muito r√°pida.  Evitar o sucesso a todo custo √© prote√ß√£o contra tentativas de colocar uma cafeteira em um microsc√≥pio eletr√¥nico, a fim de populariz√°-lo.  E nas competi√ß√µes cujo idioma √© mais legal, Haskell estar√° sempre fora das indica√ß√µes usuais. </p><br><p>  No entanto, a pessoa √© fraca e um dem√¥nio tamb√©m vive em mim, o que me faz querer comparar, avaliar e defender "minha l√≠ngua favorita" na frente dos outros.  Ent√£o, depois de escrever uma implementa√ß√£o elegante de uma m√°quina empilhada, com base em uma composi√ß√£o monoidal, com o √∫nico objetivo de verificar se essa ideia funciona para mim, fiquei imediatamente chateado por perceber que a implementa√ß√£o funcionava de maneira brilhante, mas terrivelmente ineficiente!  √â como se eu realmente fosse us√°-lo para tarefas s√©rias ou vender minha m√°quina empilhada no mesmo mercado em que as m√°quinas virtuais Python ou Java s√£o oferecidas.  Mas, caramba, o artigo sobre o leit√£o com o qual toda essa conversa come√ßou deu n√∫meros t√£o saborosos: centenas de milissegundos para o leit√£o, segundos para Python ... e meu lindo mon√≥ide n√£o consegue lidar com a mesma tarefa em uma hora!  Eu tenho que ter sucesso!  Meu microsc√≥pio preparar√° caf√© expresso como uma m√°quina de caf√© no corredor do instituto!  O Pal√°cio de Cristal pode ser disperso e lan√ßado no espa√ßo! </p><br><p>  Mas o que voc√™ est√° pronto para desistir, o anjo matem√°tico me pergunta?  A pureza e transpar√™ncia da arquitetura do pal√°cio?  A flexibilidade e extensibilidade que os homomorfismos dos programas para outras solu√ß√µes oferecem?  O dem√¥nio e o anjo s√£o teimosos, e o s√°bio tao√≠sta, a quem eu tamb√©m me permito viver, prop√¥s seguir o caminho que combina com ambos e segui-lo o maior tempo poss√≠vel.  No entanto, n√£o com o objetivo de identificar o vencedor, mas de conhecer o caminho em si, descobrir at√© onde ele leva e ganhar novas experi√™ncias.  E ent√£o eu conhecia a triste tristeza e a alegria da otimiza√ß√£o. </p><br><p> Antes de come√ßarmos, acrescentamos que as compara√ß√µes de <em>idiomas</em> em termos de efic√°cia s√£o in√∫teis.  Voc√™ precisa comparar tradutores (int√©rpretes ou compiladores) ou o desempenho de um programador que usa o idioma.  No final, √© f√°cil refutar a afirma√ß√£o de que os programas C s√£o os mais r√°pidos escrevendo um int√©rprete C completo no BASIC, por exemplo.  Portanto, n√£o estamos comparando Haskell e javascript, mas o desempenho de programas executados por um tradutor compilado pelo <code>ghc</code> e programas executados, digamos, em um navegador espec√≠fico.  Toda terminologia su√≠na vem de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> inspirador sobre m√°quinas empilhadas.  Todo o c√≥digo Haskell que acompanha o artigo pode ser estudado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> . </p><br><h3 id="vyhodim-iz-zony-komforta">  Sa√≠mos da zona de conforto </h3><br><p>  A posi√ß√£o inicial ser√° a implementa√ß√£o de uma m√°quina de empilhamento monoidal na forma de <abbr title="Idioma orientado a dom√≠nio incorporado">EDSL</abbr> - uma pequena linguagem simples que permite combinar duas d√∫zias de primitivas para renderizar programas para uma m√°quina de empilhamento virtual.  Assim que ele entrou no segundo artigo, damos a ele o nome <code>monopig</code> .  √â baseado no fato de que os idiomas para m√°quinas empilhadas formam um <em>mon√≥ide</em> com uma opera√ß√£o de concatena√ß√£o e uma opera√ß√£o vazia como uma unidade.  Consequentemente, ele pr√≥prio foi constru√≠do na forma de uma transforma√ß√£o mon√≥ide do estado da m√°quina.  O estado inclui uma pilha, mem√≥ria na forma de um vetor (uma estrutura que fornece acesso aleat√≥rio a elementos), um sinalizador de parada de emerg√™ncia e uma bateria monoidal para acumular informa√ß√µes de depura√ß√£o.  Toda essa estrutura √© transmitida ao longo de uma cadeia de endomorfismos de opera√ß√£o para opera√ß√£o, realizando um processo computacional.  Uma estrutura isom√≥rfica <em>de c√≥digos de</em> programa foi constru√≠da a partir da estrutura que os programas formam e, a partir dele, homomorfismos em outras estruturas √∫teis que representam os requisitos do programa em termos de n√∫mero de argumentos e mem√≥ria.  O est√°gio final da constru√ß√£o foi a cria√ß√£o de monoides de transforma√ß√£o na categoria Claysley, que permitem imergir os c√°lculos em uma m√¥nada arbitr√°ria.  Portanto, a m√°quina obteve os recursos de entrada-sa√≠da e c√°lculos amb√≠guos.  Vamos come√ßar com esta implementa√ß√£o.  O c√≥digo dela pode ser encontrado <a href="">aqui</a> . </p><br><p>  Testaremos a efic√°cia do programa na implementa√ß√£o ing√™nua da peneira de Erat√≥stenes, que enche a mem√≥ria (matriz) de zeros e uns, denotando n√∫meros primos por zero.  Fornecemos o c√≥digo processual do algoritmo em <code>javascript</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p>  O algoritmo √© imediatamente ligeiramente otimizado.  Elimina a m√° caminhada atrav√©s das c√©lulas de mem√≥ria j√° preenchidas.  Meu anjo matem√°tico n√£o concordou com uma vers√£o <em>realmente</em> ing√™nua de um exemplo no projeto <code>PorosenokVM</code> , pois essa otimiza√ß√£o custa apenas cinco instru√ß√µes da linguagem da pilha.  Veja como o algoritmo se traduz em <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p>  E aqui est√° como voc√™ pode escrever uma implementa√ß√£o equivalente desse algoritmo no Haskell idiom√°tico, usando os mesmos tipos que no <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p>  Ele usa o tipo <code>Data.Vector</code> e ferramentas para trabalhar com ele, que n√£o s√£o muito comuns para o trabalho di√°rio em Haskell.  Express√£o <code>m ! k</code>  <code>m ! k</code> retorna o <code>k</code> √©simo elemento do vetor me <code>m // [(n,1)]</code> - define o elemento com o n√∫mero <code>n</code> como 1. Estou escrevendo isso aqui porque precisei pedir ajuda a eles, mesmo trabalhando em Haskell quase todo dia.  O fato √© que estruturas com acesso aleat√≥rio em uma implementa√ß√£o funcional s√£o ineficientes e, por esse motivo, n√£o s√£o amadas. </p><br><p>  De acordo com as condi√ß√µes de competi√ß√£o especificadas no artigo sobre o leit√£o, o algoritmo √© executado 100 vezes.  E, para se livrar de um computador espec√≠fico, vamos comparar as velocidades de execu√ß√£o desses tr√™s programas, referindo-os ao desempenho do programa <code>javascript</code> que foi executado no Chrome. </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p>  Horror horror !!!  O <code>monopig</code> n√£o apenas <code>monopig</code> velocidade de Deus, como tamb√©m a vers√£o nativa n√£o √© muito melhor!  Haskell, √© claro, √© legal, mas n√£o tanto quanto inferior a um programa em execu√ß√£o em um navegador ?!  Como os treinadores nos ensinam, voc√™ n√£o pode viver assim, √© hora de sair da zona de conforto que Haskell nos fornece! </p><br><h3 id="preodolevaem-len">  Superar a pregui√ßa </h3><br><p>  Vamos acertar.  Para fazer isso, compile um programa no <code>monopig</code> com o sinalizador <code>-rtsopts</code> para <code>-rtsopts</code> estat√≠sticas <code>-rtsopts</code> e ver o que precisamos para executar a peneira de Erat√≥stenes uma vez: </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p>  A √∫ltima linha nos diz que o programa estava envolvido em computa√ß√£o produtiva apenas um ter√ßo do tempo.  Durante o resto do tempo, o coletor de lixo ficou sem mem√≥ria e foi limpo para c√°lculos pregui√ßosos.  Quantas vezes nos disseram na inf√¢ncia que a pregui√ßa n√£o √© boa!  Aqui, a principal caracter√≠stica de Haskell fez um desservi√ßo, tentando criar v√°rios bilh√µes de vetores adiados e transforma√ß√µes de pilha. </p><br><p>  Um anjo matem√°tico, neste momento, levanta o dedo e fala alegremente sobre o fato de que, desde os tempos da Igreja de Alonzo, h√° um teorema que afirma que a estrat√©gia de c√°lculo n√£o afeta o resultado, o que significa que somos livres para escolh√™-lo por raz√µes de efici√™ncia.  Alterar os c√°lculos para estrito n√£o √© nada dif√≠cil - coloque um sinal <code>!</code>  na declara√ß√£o do tipo de pilha e mem√≥ria e, assim, tornar esses campos estritos. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  N√£o alteraremos mais nada e verificaremos imediatamente o resultado: </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p>  A produtividade cresceu significativamente.  Os custos totais de mem√≥ria ainda permaneceram impressionantes devido √† imutabilidade dos dados, mas o mais importante √© que agora que limitamos a pregui√ßa dos dados, o coletor de lixo tem a oportunidade de ser pregui√ßoso, apenas 5% do trabalho permanece nele.  Digite uma nova entrada na classifica√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p>  Bem, c√°lculos rigorosos nos aproximaram da velocidade do c√≥digo Haskell nativo, que vergonhosamente diminui sem nenhuma m√°quina virtual.  Isso significa que a sobrecarga do uso de um vetor imut√°vel excede <em>significativamente</em> o custo de manuten√ß√£o de uma m√°quina empilhada.  E isso significa que √© hora de dizer adeus √† imutabilidade da mem√≥ria. </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn">  Deixar Mudan√ßas na Vida </h3><br><p>  O tipo <code>Data.Vector</code> bom, mas, usando-o, passamos muito tempo copiando, em nome da preserva√ß√£o da pureza do processo de computa√ß√£o.  Substituindo-o <code>Data.Vector.Unpacked</code> tipo <code>Data.Vector.Unpacked</code> pelo menos economizamos no empacotamento da estrutura, mas isso n√£o altera fundamentalmente a imagem.  A solu√ß√£o correta seria remover a mem√≥ria do estado da m√°quina e fornecer acesso ao vetor externo usando a categoria Kleisley.  Ao mesmo tempo, junto com vetores puros, voc√™ pode usar os chamados vetores mut√°veis ‚Äã‚Äã(mut√°veis) <code>Data.Vector.Mutable</code> . </p><br><p>  Vamos conectar os m√≥dulos apropriados e pensar em como lidar com dados mut√°veis ‚Äã‚Äãem um programa funcional limpo. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p>  Esses tipos sujos devem ser isolados do p√∫blico puro.  Eles est√£o contidos nas m√¥nadas da classe <code>PrimMonad</code> (elas incluem <code>ST</code> ou <code>IO</code> ), onde programas limpos inserem cuidadosamente instru√ß√µes para a√ß√µes escritas em uma linguagem funcional cristalina em pergaminho precioso.  Assim, o comportamento desses animais impuros √© determinado por cen√°rios estritamente ortodoxos e n√£o √© perigoso.  Nem todos os programas de nossa m√°quina usam mem√≥ria; portanto, n√£o h√° necessidade de condenar toda a arquitetura √† imers√£o na m√¥nada de <code>IO</code> S.  Juntamente com um subconjunto limpo da linguagem <code>monopig</code> criaremos quatro instru√ß√µes que fornecem acesso √† mem√≥ria, e somente elas ter√£o acesso ao territ√≥rio perigoso. </p><br><p>  O tipo de m√°quina limpa est√° ficando mais curto: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Os projetistas de programas e os pr√≥prios programas dificilmente perceber√£o essa altera√ß√£o, mas seus tipos mudar√£o.  Al√©m disso, faz sentido definir v√°rios tipos de sin√¥nimos para simplificar as assinaturas. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p>  Os construtores ter√£o outro argumento representando o acesso √† mem√≥ria.  Os executores mudar√£o significativamente, especialmente aqueles que mant√™m um log de c√°lculo, porque agora precisam solicitar o estado do vetor vari√°vel.  O <a href="">c√≥digo</a> completo pode ser visto e estudado no reposit√≥rio, mas aqui darei o mais interessante: a implementa√ß√£o dos componentes b√°sicos para trabalhar com a mem√≥ria para mostrar como isso √© feito. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p>  O daemon otimizador imediatamente se ofereceu para economizar um pouco mais na verifica√ß√£o dos valores de √≠ndice permitidos na mem√≥ria, porque para os <code>geti</code> <code>puti</code> e <code>geti</code> √≠ndices s√£o conhecidos no est√°gio de cria√ß√£o do programa e os valores incorretos podem ser eliminados antecipadamente.  Os √≠ndices definidos dinamicamente para comandos <code>put</code> e <code>get</code> n√£o garantem seguran√ßa, e o anjo matem√°tico n√£o permitiu que chamadas perigosas fossem feitas a eles. </p><br><p>  Todo esse barulho de colocar a mem√≥ria em um argumento separado parece complicado.  Mas mostra muito claramente os dados a serem alterados por seu local - <em>eles devem estar fora</em> .  Lembro que estamos tentando levar um entregador de pizza a um laborat√≥rio est√©ril.  As fun√ß√µes puras sabem o que fazer com elas, mas esses objetos nunca se tornar√£o cidad√£os de primeira classe, e n√£o vale a pena preparar pizza no laborat√≥rio. </p><br><p>  Vamos verificar o que compramos com essas altera√ß√µes: </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p>  Isso j√° √© progresso!  O uso da mem√≥ria foi reduzido oito vezes, a velocidade de execu√ß√£o do programa aumentou 180 vezes e o coletor de lixo permaneceu quase completamente sem trabalho. </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p>  A solu√ß√£o apareceu <em>monopig st.</em>  <em>mut.</em>  , que √© dez vezes mais lento que a solu√ß√£o nativa em <code>js</code> , mas, al√©m disso, a solu√ß√£o nativa em Haskell, usando vetores mut√°veis.  Aqui est√° o c√≥digo dele: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p>  Come√ßa da seguinte maneira </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p>  E agora Haskell finalmente mostra que ele n√£o √© uma linguagem de brinquedo.  Voc√™ s√≥ precisa us√°-lo com sabedoria.  A prop√≥sito, o c√≥digo acima usa o fato de que o tipo <code>IO ()</code> forma um semigrupo com a opera√ß√£o de execu√ß√£o sequencial de programas <code>(&gt;&gt;)</code> e, com a ajuda de <code>stimes</code> , repetimos 100 vezes o c√°lculo do problema de teste. </p><br><p>  Agora est√° claro por que existe uma antipatia por matrizes funcionais e por que ningu√©m se lembra de como trabalhar com elas: assim que um programador Haskell realmente precisa de estruturas de acesso aleat√≥rio, ele se concentra em dados mut√°veis ‚Äã‚Äãe trabalha em m√¥nadas ST ou IO. </p><br><p>  Colocar parte de comandos em uma zona especial questiona a legalidade do <em>c√≥digo</em> de isomorfismo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>o programa</em> .  Afinal, n√£o podemos transformar o c√≥digo simultaneamente em programas puros e mon√°dicos, isso n√£o permite que o sistema de tipos fa√ßa isso.  No entanto, as classes de tipo s√£o flex√≠veis o suficiente para que esse isomorfismo exista.  <em>C√≥digo do</em> homomorfismo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script>  <em>o programa</em> agora <em>est√°</em> dividido em v√°rios homomorfismos para diferentes subconjuntos do idioma.  Como exatamente isso √© feito pode ser visto no [c√≥digo] () completo do programa. </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom">  N√£o pare por a√≠ </h3><br><p>  Eliminar chamadas de fun√ß√£o desnecess√°rias e incorporar seu c√≥digo diretamente usando o pragma <code>{-# INLINE #-}</code> ajudar√° a alterar levemente a produtividade do programa.  Este m√©todo n√£o √© adequado para fun√ß√µes recursivas, mas √© √≥timo para componentes b√°sicos e fun√ß√µes de configura√ß√£o.  Reduz o tempo de execu√ß√£o do programa de teste em outros 25% (consulte <a href="">Monopig51.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p>  O pr√≥ximo passo razo√°vel ser√° livrar-se das ferramentas de registro quando elas n√£o forem necess√°rias.  No est√°gio de forma√ß√£o do endomorfismo que representa o programa, usamos um argumento externo, que determinamos na inicializa√ß√£o.  <code>program</code> construtores inteligentes e <code>programM</code> podem ser avisados ‚Äã‚Äãde que n√£o pode haver nenhum argumento-logger.  Nesse caso, o c√≥digo do conversor n√£o cont√©m nada de sup√©rfluo: apenas a funcionalidade e a verifica√ß√£o do status da m√°quina. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p>  Agora, as fun√ß√µes de execu√ß√£o devem indicar explicitamente a presen√ßa ou aus√™ncia de log n√£o usando o stub <code>none</code> , mas usando o tipo <code>Maybe (Logger ma)</code> .  Por que isso funcionaria, porque se houver registro ou n√£o, os componentes do programa descobrir√£o "no √∫ltimo momento", antes da execu√ß√£o?  O c√≥digo desnecess√°rio n√£o seria costurado no est√°gio de composi√ß√£o da composi√ß√£o do programa?  Haskell √© uma linguagem pregui√ßosa e aqui ela toca em nossas m√£os.  √â antes da execu√ß√£o que o c√≥digo final √© otimizado para uma tarefa espec√≠fica.  Essa otimiza√ß√£o reduziu o tempo de execu√ß√£o do programa em outros 40% (consulte <a href="">Monopig52.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p>  Com isso, concluiremos o trabalho de acelera√ß√£o do leit√£o monoidal.  Ele j√° est√° correndo r√°pido o suficiente para que tanto o anjo quanto o dem√¥nio possam se acalmar.  Obviamente, isso n√£o √© C, ainda usamos uma lista limpa como uma pilha, mas substitu√≠-la por uma matriz levar√° a uma escava√ß√£o completa do c√≥digo e √† recusa de usar modelos elegantes nas defini√ß√µes de comandos b√°sicos.  Eu queria passar com mudan√ßas m√≠nimas, e principalmente no n√≠vel dos tipos. </p><br><p>  Alguns problemas permanecem com o log.  Uma simples contagem do n√∫mero de etapas ou o uso da pilha funciona bem (tornamos o campo de registro estrito), mas combin√°-las j√° come√ßa a consumir mem√≥ria, voc√™ precisa se preocupar com chutes usando <code>seq</code> , o que j√° √© bastante irritante.  Mas diga-me, quem registrar√° os 14 bilh√µes de etapas, se voc√™ puder depurar a tarefa nas primeiras centenas?  Portanto, n√£o vou gastar meu tempo acelerando para acelerar. </p><br><p>  Resta apenas acrescentar que, no artigo sobre o leit√£o, como um dos m√©todos para otimizar c√°lculos, o rastreamento √© dado: a aloca√ß√£o de se√ß√µes lineares do c√≥digo, <em>rastreamentos</em> nos quais os c√°lculos podem ser realizados ignorando o ciclo principal de despacho de comando (bloco de <code>switch</code> ).  No nosso caso, a composi√ß√£o monoidal dos componentes do programa cria esses tra√ßos durante a forma√ß√£o do programa a partir dos componentes EDSL ou durante a opera√ß√£o do homomorfismo <code>fromCode</code> .  Esse m√©todo de otimiza√ß√£o nos chega de gra√ßa, por assim dizer, por constru√ß√£o. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhjhYccUpNIVzR2rHQSpR-nsp_CBVg#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  Existem muitas solu√ß√µes <code>Conduits</code> e r√°pidas no ecossistema Haskell, como fluxos de <code>Conduits</code> ou <code>Pipes</code> , existem excelentes substitui√ß√µes de <code>String</code> e criadores de XML √°geis como blaze-html, e o analisador <code>attoparsec</code> √© um padr√£o para an√°lise combinat√≥ria para gram√°ticas LL (‚àû).  Tudo isso √© necess√°rio para a opera√ß√£o normal.  Mas ainda mais necess√°ria √© a pesquisa que leva a essas decis√µes.  Haskell tem sido e continua sendo uma ferramenta de pesquisa que atende a requisitos espec√≠ficos n√£o necess√°rios ao p√∫blico em geral.  Vi em Kamchatka como os ases de um helic√≥ptero Mi-4 fechavam as caixas de f√≥sforos em uma discuss√£o, empurrando o trem de pouso com uma roda enquanto pairavam no ar.  Isso pode ser feito e √© legal, mas n√£o √© necess√°rio. </p><br><p>  Mas, no entanto, isso √© legal !! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430956/">https://habr.com/ru/post/pt430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430944/index.html">A NASA decidiu os participantes para sua competi√ß√£o de mini-moon rover</a></li>
<li><a href="../pt430948/index.html">Minist√©rio das Comunica√ß√µes prop√µe refor√ßar o controle sobre dados pessoais</a></li>
<li><a href="../pt430950/index.html">Fazendo a Constru√ß√£o Moderna</a></li>
<li><a href="../pt430952/index.html">Carros el√©tricos e carros h√≠bridos ter√£o que emitir sons adicionais: por que isso √© necess√°rio</a></li>
<li><a href="../pt430954/index.html">Qt Everywhere: WebAssembly e WebGL Streaming</a></li>
<li><a href="../pt430958/index.html">Lan√ßamos o cont√™iner com testes de unidade no Azure DevOps (VSTS)</a></li>
<li><a href="../pt430960/index.html">Sobre o gamedev de uma exposi√ß√£o na √°rea de trabalho</a></li>
<li><a href="../pt430962/index.html">Suporte do Razor no c√≥digo do Visual Studio</a></li>
<li><a href="../pt430964/index.html">Pensamento declarativo</a></li>
<li><a href="../pt430966/index.html">Sprints gerais na Atlassian Jira Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>