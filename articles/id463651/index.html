<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏾 👩 👩🏼‍✈️ Matematika diskrit untuk WMS: algoritma untuk mengompresi barang dalam sel (bagian 2) 🕵️ 💸 ⛺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, kami akan menjelaskan bagaimana kami mengembangkan algoritma untuk kompresi optimal dari barang yang tersisa dalam sel. Kami akan m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matematika diskrit untuk WMS: algoritma untuk mengompresi barang dalam sel (bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463651/"><img src="https://habrastorage.org/webt/pk/sw/xk/pkswxkfx_bl-w83edqla_aaq9vq.jpeg"><br><br>  Dalam artikel ini, kami akan menjelaskan bagaimana kami mengembangkan algoritma untuk kompresi optimal dari barang yang tersisa dalam sel.  Kami akan memberi tahu Anda bagaimana memilih metaheuristik yang diperlukan dari lingkungan kerangka kebun binatang: pencarian tabu, algoritma genetika, koloni semut, dll. <br><br>  Kami akan melakukan percobaan komputasi untuk menganalisis waktu operasi dan keakuratan algoritma.  Kami merangkum dan merangkum pengalaman berharga yang diperoleh dalam menyelesaikan masalah optimisasi dan implementasi "teknologi cerdas" ini dalam proses bisnis pelanggan. <br><br>  Artikel ini akan berguna bagi mereka yang menerapkan teknologi cerdas, bekerja di gudang atau industri logistik produksi, serta programmer yang tertarik pada aplikasi matematika dalam bisnis dan optimalisasi proses di perusahaan. <br><br><a name="habracut"></a><h4>  Bagian pengantar </h4><br>  Publikasi ini melanjutkan serangkaian artikel yang kami bagikan pengalaman sukses kami dalam menerapkan algoritma pengoptimalan dalam proses gudang.  Publikasi sebelumnya: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma pengelompokan kiriman dalam persediaan.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah algoritma untuk mengompresi barang residu dalam sel (bagian 1).</a> </li></ul><br>  Cara membaca artikel.  Jika Anda membaca artikel sebelumnya, Anda dapat langsung melanjutkan ke bab "Pengembangan algoritma untuk menyelesaikan masalah", jika tidak, maka uraian masalah yang harus dipecahkan dalam spoiler di bawah ini. <br><br><div class="spoiler">  <b class="spoiler_title">Deskripsi masalah yang harus dipecahkan di gudang pelanggan</b> <div class="spoiler_text"><h4>  Proses bottleneck </h4><br>  Pada tahun 2018, kami membuat proyek untuk memperkenalkan sistem <i>WMS</i> di gudang perusahaan LD Trading House di Chelyabinsk.  Memperkenalkan produk "1C-Logistik: Manajemen Gudang 3" untuk 20 pekerjaan: operator <i>WMS</i> , pemilik toko, pengemudi forklift.  Gudang memiliki rata-rata sekitar 4 ribu m2, jumlah sel adalah 5.000 dan jumlah SKU 4500. Katup bola dari produksi kami sendiri dengan ukuran berbeda dari 1 kg hingga 400 kg disimpan di gudang.  Persediaan di gudang disimpan dalam konteks bets karena kebutuhan untuk memilih barang sesuai dengan FIFO dan spesifik “in-line” penempatan produk (penjelasan di bawah). <br><br>  Ketika merancang skema otomasi untuk proses gudang, kami dihadapkan dengan masalah penyimpanan stok yang tidak optimal.  Penumpukan dan penyimpanan crane memiliki, seperti yang telah kita katakan, "baris" spesifik.  Artinya, produk-produk dalam sel ditumpuk dalam satu baris di atas yang lain, dan kemampuan untuk meletakkan sepotong pada sepotong sering tidak ada (mereka jatuh, dan beratnya tidak kecil).  Karena itu, ternyata hanya satu nomenklatur dari satu bets yang dapat berada dalam satu unit penyimpanan, jika tidak, nomenklatur lama tidak dapat ditarik keluar dari yang baru tanpa "menyekop" seluruh sel. <br><br>  Produk tiba di gudang setiap hari dan setiap kedatangan adalah batch yang terpisah.  Secara total, sebagai hasil dari operasi gudang selama 1 bulan, 30 lot terpisah dibuat, meskipun masing-masing harus disimpan dalam sel yang terpisah.  Barang sering dipilih bukan dalam palet utuh, tetapi dalam potongan, dan sebagai hasilnya, di daerah pemilihan potongan, dalam banyak sel gambar berikut diamati: dalam sel dengan volume lebih dari 1 m3 ada beberapa potongan crane yang menempati kurang dari 5-10% volume sel (lihat Gambar 1). ) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/qf/bx/hxqfbxlkzhrwql3k0hmcz9l2cem.jpeg"></div><br>  <i>Gambar 1. Foto beberapa potong dalam sel</i> <br><br>  Di muka penggunaan kapasitas penyimpanan yang kurang optimal.  Untuk membayangkan skala bencana, saya dapat mengutip angka-angka: rata-rata ada antara 100 dan 300 sel seperti sel dengan sedikit sisa dalam periode yang berbeda dari operasi gudang.  Karena gudang relatif kecil, pada musim pemuatan gudang faktor ini menjadi "leher sempit" dan sangat menghambat proses penerimaan dan pengiriman gudang. <br><br><h4>  Gagasan memecahkan masalah </h4><br>  Idenya muncul: untuk membawa kumpulan residu dengan tanggal terdekat ke satu batch tunggal dan menempatkan keseimbangan tersebut dengan batch terpadu secara kompak dalam satu sel, atau dalam beberapa jika tidak ada ruang yang cukup dalam satu untuk mengakomodasi jumlah total saldo.  Contoh "kompresi" seperti itu ditunjukkan pada Gambar 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c-/cx/0g/c-cx0gs5mwn14uwupmefgmytzto.jpeg"></div><br>  <i>Fig. 2.</i>  <i>Skema kompresi sel</i> <br><br>  Ini memungkinkan Anda untuk secara signifikan mengurangi ruang gudang yang ditempati, yang akan digunakan untuk barang yang baru ditempatkan.  Dalam situasi kelebihan kapasitas gudang, langkah seperti itu sangat diperlukan, jika tidak mungkin tidak ada cukup ruang kosong untuk menempatkan barang baru, yang akan menyebabkan penghenti dalam proses penempatan dan pengisian gudang, dan sebagai akibatnya, penghenti untuk penerimaan dan pengiriman.  Sebelumnya, sebelum implementasi sistem WMS, operasi seperti itu dilakukan secara manual, yang tidak efektif, karena proses menemukan residu yang sesuai dalam sel cukup lama.  Sekarang, dengan diperkenalkannya sistem WMS, mereka memutuskan untuk mengotomatiskan proses, mempercepatnya dan membuatnya cerdas. <br><br>  Proses pemecahan masalah ini dibagi menjadi 2 tahap: <br><br><ul><li>  pada tahap pertama, kami menemukan kelompok-kelompok pihak yang tanggal dekat untuk dikompres (ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> untuk tugas penahbisan ini); </li><li>  pada tahap kedua, untuk setiap kelompok batch kami menghitung penempatan residu produk yang paling kompak dalam sel. </li></ul><br>  Pada artikel saat ini, kita selesai dengan deskripsi tahap kedua dari proses solusi dan langsung mempertimbangkan algoritma optimasi itu sendiri. </div></div><br><h4>  Pengembangan suatu algoritma untuk memecahkan masalah </h4><br>  Sebelum melanjutkan dengan deskripsi langsung dari algoritma optimasi, perlu untuk mengatakan tentang kriteria utama untuk pengembangan algoritma seperti itu, yang ditetapkan sebagai bagian dari proyek implementasi sistem <i>WMS</i> . <br><br><ul><li>  Pertama, algoritme harus <b>mudah dipahami</b> .  Ini adalah persyaratan alami, karena diasumsikan bahwa algoritma akan didukung dan dikembangkan lebih lanjut oleh layanan TI pelanggan di masa depan, yang seringkali jauh dari kehalusan dan kebijaksanaan matematis. </li><li>  Kedua, algoritme harus <b>cepat</b> .  Hampir semua barang di gudang terlibat dalam prosedur kompresi (ini adalah sekitar 3.000 item) dan untuk setiap produk perlu untuk menyelesaikan masalah dimensi sekitar 10x100. </li><li>  Ketiga, algoritma harus menghitung solusi yang <b>mendekati optimal</b> . </li><li>  Keempat, waktu untuk mendesain, mengimplementasikan, men-debug, menganalisis dan menguji internal algoritma relatif kecil.  Ini merupakan persyaratan penting, karena <b>anggaran proyek</b> , termasuk untuk tugas ini, <b>terbatas</b> . </li></ul><br>  Perlu dikatakan bahwa sampai saat ini, matematikawan telah mengembangkan banyak algoritma yang efektif untuk menyelesaikan masalah Masalah Lokasi Fasilitas Sumber Tunggal.  Pertimbangkan varietas utama dari algoritma yang tersedia. <br><br>  Beberapa algoritma yang paling efisien didasarkan pada pendekatan yang disebut relaksasi Lagrange.  Sebagai aturan, ini adalah algoritma yang agak rumit yang sulit dipahami bagi seseorang yang tidak tenggelam dalam seluk-beluk optimasi diskrit.  “Kotak hitam” dengan algoritma kompleks Lagrange yang efektif namun tidak sesuai untuk pelanggan. <br><br>  Ada metaheuristik yang cukup efektif (apa yang dibaca metaheuristik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , apa heuristik baca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ), misalnya, algoritma genetika, algoritma annealing disimulasikan, algoritma koloni semut, algoritma pencarian Tabu dan lain-lain (gambaran metaheuristik seperti itu dalam bahasa Rusia dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Tetapi algoritma tersebut telah memuaskan pelanggan, karena: <br><br><ul><li>  Mampu menghitung solusi untuk masalah yang sangat dekat dengan optimal. </li><li>  Cukup sederhana untuk dipahami, dukungan lebih lanjut, debug dan perbaiki. </li><li>  Mereka dapat dengan cepat menghitung solusi untuk suatu masalah. </li></ul><br>  Diputuskan untuk menggunakan metaheuristik.  Sekarang tinggal memilih satu "kerangka kerja" di antara "kebun binatang" besar metaheuristik terkenal untuk menyelesaikan Masalah Lokasi Fasilitas Fasilitas Sumber Tunggal.  Setelah meninjau sejumlah artikel yang menganalisis efektivitas berbagai metaheuristik, pilihan kami jatuh pada algoritma GRASP, karena dibandingkan dengan metaheuristik lainnya itu menunjukkan hasil yang cukup baik pada keakuratan solusi yang dihitung untuk masalah, adalah salah satu yang tercepat dan, yang paling penting, ia memiliki yang paling sederhana dan paling sederhana. dan logika transparan. <br><br>  <b>Skema algoritma GRASP</b> dalam kaitannya dengan tugas Masalah Lokasi Fasilitas Berkapasitas Sumber Tunggal dijelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> .  Skema umum dari algoritma adalah sebagai berikut. <br><br><ul><li>  <b>Tahap 1.</b> Hasilkan beberapa solusi yang layak untuk masalah dengan algoritma acak serakah. </li><li>  <b>Tahap 2.</b> Tingkatkan solusi yang dihasilkan di tahap 1 menggunakan algoritma pencarian lokal di sejumlah lingkungan. </li><li>  Jika kondisi berhenti terpenuhi, maka selesaikan algoritme, jika tidak, lanjutkan ke langkah 1. Solusi dengan biaya total terendah di antara semua solusi yang ditemukan adalah hasil dari algoritma. </li></ul><br>  Kondisi untuk menghentikan algoritma dapat berupa batasan sederhana pada jumlah iterasi atau batasan pada jumlah iterasi tanpa perbaikan dalam solusi. <br><br><div class="spoiler">  <b class="spoiler_title">Kode skema umum dari algoritma</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeProblemSolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aCellsData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatDist, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellsNumb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatSolution, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatAssignmentSolution)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //  int     .      WMS   3  ( .,    10 ),         // aMatSolutionIteration -    : // [i][0]  , [i][1]     , [i][2]             // [i][3]        int **aMatSolutionIteration = new int*[cellsNumb]; for (int count = 0; count &lt; cellsNumb; count++) aMatSolutionIteration[count] = new int[4]; // aMatAssignmentSolutionIteration -     . [i][j] = 1 -  j   i, 0    int **aMatAssignmentSolutionIteration = new int*[cellsNumb]; for (int count = 0; count &lt; cellsNumb; count++) aMatAssignmentSolutionIteration[count] = new int[cellsNumb]; const int maxIteration = 10; int iter = 0, recordCosts = 1000000; //    ,      int totalDemand = 0; for (int i = 0; i &lt; cellsNumb; i++) totalDemand += aCellsData[i][1]; while (iter &lt; maxIteration) { //     setValueIn2Array(aMatAssignmentSolutionIteration, cellsNumb, cellsNumb, 0); //    setClearSolutionArray(aMatSolutionIteration, cellsNumb, 4); //      int *aFreeContainersFitnessFunction = new int[cellsNumb]; //   ,       findGreedyRandomSolution(aCellsData, aMatDist, cellsNumb, aMatSolutionIteration, aMatAssignmentSolutionIteration, aFreeContainersFitnessFunction, false); //         improveSolutionLocalSearch(aCellsData, aMatDist, cellsNumb, aMatSolutionIteration, aMatAssignmentSolutionIteration, totalDemand); //     (      ) bool feasible = isSolutionFeasible(aMatSolutionIteration, aCellsData, cellsNumb); //    ,    if (feasible == false) { getFeasibleSolution(aCellsData, aMatDist, cellsNumb, aMatSolutionIteration, aMatAssignmentSolutionIteration); } //        ,  ,          int totalCostsIteration = getSolutionTotalCosts(aMatSolutionIteration, cellsNumb); if (totalCostsIteration &lt; recordCosts) { recordCosts = totalCostsIteration; copy2Array(aMatSolution, aMatSolutionIteration, cellsNumb, 3); } iter++; } delete2Array(aMatSolutionIteration, cellsNumb); delete2Array(aMatAssignmentSolutionIteration, cellsNumb); return recordCosts; }</span></span></code> </pre> </div></div><br>  Mari kita pertimbangkan lebih detail pengoperasian <b>algoritma acak serakah</b> pada tahap 1. Dipercayai bahwa pada awalnya tidak satu sel-kontainer dipilih. <br><br><ul><li>  <b>Langkah 1.</b> Untuk setiap sel kontainer yang saat ini tidak dipilih, nilainya dihitung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-msubsup" id="MJXp-Span-2"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3" style="margin-right: 0.05em;">F</span><span class="MJXp-script-box" style="height: 2.036em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: 0.05em;"><span class="MJXp-mrow" id="MJXp-Span-6"><span class="MJXp-msup" id="MJXp-Span-7"><span class="MJXp-mi" id="MJXp-Span-8" style="margin-right: 0.05em;"></span><span class="MJXp-mo MJXp-script" id="MJXp-Span-9" style="vertical-align: 0.4em;">′</span></span></span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -1.07em;"><span class="MJXp-mrow" id="MJXp-Span-4"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5">i</span></span></span></span></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.531ex" height="3.142ex" viewBox="0 -935.7 1089.8 1352.7" role="img" focusable="false" style="vertical-align: -0.969ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-46" x="0" y="0"></use><g transform="translate(781,344)"><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMAIN-2032" x="0" y="513"></use></g><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-69" x="910" y="-430"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> F_ {i} ^ {'} </script>  rumus biaya <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-10"><span class="MJXp-msubsup" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12" style="margin-right: 0.05em;">F</span><span class="MJXp-script-box" style="height: 2.036em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: 0.05em;"><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-msup" id="MJXp-Span-16"><span class="MJXp-mi" id="MJXp-Span-17" style="margin-right: 0.05em;"></span><span class="MJXp-mo MJXp-script" id="MJXp-Span-18" style="vertical-align: 0.4em;">′</span></span></span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -1.07em;"><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">i</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-20">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">c</span><span class="MJXp-mrow" id="MJXp-Span-25"><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;">F</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">i</span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">N</span></span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processed" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.779ex" height="3.142ex" viewBox="0 -935.7 6793.7 1352.7" role="img" focusable="false" style="vertical-align: -0.969ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-46" x="0" y="0"></use><g transform="translate(781,344)"><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMAIN-2032" x="0" y="513"></use></g><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-69" x="910" y="-430"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMAIN-3D" x="1367" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-66" x="2673" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-72" x="3224" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-61" x="3675" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-63" x="4205" y="0"></use><g transform="translate(4638,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-69" x="910" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-4E" x="5626" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMAIN-2C" x="6515" y="0"></use></g></svg></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> F_ {i} ^ {'} = \ frac {F_ {i}} {N}, </script></p>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-msubsup" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35" style="margin-right: 0.05em;">F</span><span class="MJXp-script-box" style="height: 2.036em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: 0.05em;"><span class="MJXp-mrow" id="MJXp-Span-38"><span class="MJXp-msup" id="MJXp-Span-39"><span class="MJXp-mi" id="MJXp-Span-40" style="margin-right: 0.05em;"></span><span class="MJXp-mo MJXp-script" id="MJXp-Span-41" style="vertical-align: 0.4em;">′</span></span></span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -1.07em;"><span class="MJXp-mrow" id="MJXp-Span-36"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">i</span></span></span></span></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.531ex" height="3.142ex" viewBox="0 -935.7 1089.8 1352.7" role="img" focusable="false" style="vertical-align: -0.969ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-46" x="0" y="0"></use><g transform="translate(781,344)"><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMAIN-2032" x="0" y="513"></use></g><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-69" x="910" y="-430"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> F_ {i} ^ {'} </script>  - jumlah biaya memilih wadah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.802ex" height="1.937ex" viewBox="0 -728.2 345.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-69" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> i </script>  dan total biaya untuk memindahkan barang dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script>  sel-sel yang belum melekat pada wadah apa pun ke dalam wadah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.802ex" height="1.937ex" viewBox="0 -728.2 345.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463651/&amp;usg=ALkJrhg-hWhoGw1TbpmI0tNlm8978TglPg#MJMATHI-69" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> i </script>  .  Seperti itu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> N </script>  sel dipilih sehingga total volume barang di dalamnya tidak melebihi kapasitas wadah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-50"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> i </script>  .  Sel-sel donor dipilih secara berurutan untuk dipindahkan ke wadah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> i </script>  dalam rangka meningkatkan biaya memindahkan jumlah barang ke dalam wadah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-54"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> i </script>  .  Pemilihan sel dilakukan sampai kapasitas wadah terlampaui. </li><li>  <b>Langkah 2.</b> Set terbentuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-56"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> R </script>  wadah dengan nilai fungsi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">F</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> F </script>  tidak melebihi nilai ambang batas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mtext" id="MJXp-Span-61">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">n</span><span class="MJXp-mo" id="MJXp-Span-65" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">F</span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mtext" id="MJXp-Span-68">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">t</span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-74">1</span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">a</span><span class="MJXp-mo" id="MJXp-Span-77" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> \ min (F) \ cdot (1 + a) </script>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-78"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> a </script>  dalam kasus kami adalah 0,2. </li><li>  <b>Langkah 3.</b> Secara acak dari set <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> R </script>  wadah dipilih <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-82"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-83">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> i </script>  . <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-84"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> N </script>  sel yang sebelumnya dipilih dalam wadah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> i </script>  pada langkah 1, mereka akhirnya ditugaskan ke wadah seperti itu dan tidak berpartisipasi lebih lanjut dalam perhitungan algoritma serakah. </li><li>  <b>Langkah 4.</b> Jika semua sel donor ditugaskan ke wadah, algoritma serakah berhenti bekerja, jika tidak kembali ke langkah 1. </li></ul><br>  Algoritma acak pada setiap iterasi mencoba untuk membangun solusi sedemikian rupa sehingga ada keseimbangan antara kualitas solusi yang dibangunnya, serta keanekaragamannya.  Dua persyaratan ini untuk memulai keputusan adalah syarat utama untuk keberhasilan operasi algoritma, karena: <br><br><ul><li>  jika solusinya berkualitas buruk, maka peningkatan selanjutnya pada tahap 2 tidak akan menghasilkan hasil yang signifikan, karena bahkan memperbaiki solusi yang buruk, kami akan sangat sering mendapatkan solusi berkualitas buruk yang sama; </li><li>  Jika semua solusi baik, tetapi sama, maka prosedur pencarian lokal akan menyatu dengan solusi yang sama, itu sama sekali bukan fakta yang optimal.  Efek ini disebut memukul minimum lokal dan harus selalu dihindari. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Kode algoritma acak serakah</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findGreedyRandomSolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aCellsData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatDist, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellsNumb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatSolutionIteration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatAssignmentSolutionIteration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *aFreeContainersFitnessFunction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isOldSolution)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     int numCellsInSolution = 0; if (isOldSolution) { //     ,   aFreeContainersFitnessFunction //  numCellsInSolution ,       for (int i = 0; i &lt; cellsNumb; i++) { for (int j = 0; j &lt; cellsNumb; j++) { if (aMatAssignmentSolutionIteration[i][j] == 1) numCellsInSolution++; } } } //  ,        aFreeContainersFitnessFunction,     // [i][j] = 1,   j    i, 0  int **aFreeContainersAssigntCells = new int*[cellsNumb]; for (int count = 0; count &lt; cellsNumb; count++) aFreeContainersAssigntCells[count] = new int[cellsNumb]; while (numCellsInSolution != cellsNumb) { setValueIn2Array(aFreeContainersAssigntCells, cellsNumb, cellsNumb, 0); //    //               setFreeContainersFitnessFunction(aCellsData, aMatDist, cellsNumb, aFreeContainersFitnessFunction, aFreeContainersAssigntCells); //   ,    //       ,          int selectedRandomContainer = selectGoodRandomContainer(aFreeContainersFitnessFunction, cellsNumb); //          aMatSolutionIteration[selectedRandomContainer][0] = selectedRandomContainer; aMatSolutionIteration[selectedRandomContainer][1] = 0; aMatSolutionIteration[selectedRandomContainer][2] = aCellsData[selectedRandomContainer][2]; for (int j = 0; j &lt; cellsNumb; j++) { if (aFreeContainersAssigntCells[selectedRandomContainer][j] == 1) { aMatAssignmentSolutionIteration[selectedRandomContainer][j] = 1; aMatSolutionIteration[selectedRandomContainer][1] += aCellsData[j][1]; aMatSolutionIteration[selectedRandomContainer][2] += aMatDist[selectedRandomContainer][j]; aMatSolutionIteration[selectedRandomContainer][3] = 0; aFreeContainersFitnessFunction[j] = 10000; numCellsInSolution++; } } } delete2Array(aFreeContainersAssigntCells, cellsNumb); delete[] aFreeContainersFitnessFunction; } void setFreeContainersFitnessFunction(int **aCellsData, int **aMatDist, int cellsNumb, int *aFreeContainersFitnessFunction, int **aFreeContainersAssigntCells) { //  ,        i // [0][k] -      , [1][k] -   int **aCurrentDist = new int*[2]; for (int count = 0; count &lt; 2; count++) aCurrentDist[count] = new int[cellsNumb]; for (int i = 0; i &lt; cellsNumb; i++) { // 10000 -      ,        if (aFreeContainersFitnessFunction[i] &gt;= 10000) continue; //       int containerCurrentVolume = aCellsData[i][1]; //      int containerCosts = aCellsData[i][2]; //  -,    i int amountAssignedCell = 0; setCurrentDist(aMatDist, cellsNumb, aCurrentDist, i); for (int j = 0; j &lt; cellsNumb; j++) { int currentCell = aCurrentDist[1][j]; if (currentCell == i) continue; if (aFreeContainersFitnessFunction[currentCell] &gt;= 10000) continue; if (aCellsData[i][0] &lt; containerCurrentVolume + aCellsData[currentCell][1]) continue; aFreeContainersAssigntCells[i][currentCell] = 1; containerCosts += aCurrentDist[0][j]; containerCurrentVolume += aCellsData[currentCell][1]; amountAssignedCell++; } //           (     ) if (aCellsData[i][1] &gt; 0) { aFreeContainersAssigntCells[i][i] = 1; amountAssignedCell++; } //       1 (     ),       //           1. //          .      ,     //     (   )            . //         (     ),        //   ,             . if (amountAssignedCell &gt; 1) amountAssignedCell *= 10; if (amountAssignedCell &gt; 0) aFreeContainersFitnessFunction[i] = containerCosts / amountAssignedCell; else aFreeContainersFitnessFunction[i] = 10000; } delete2Array(aCurrentDist, 2); } int selectGoodRandomContainer(int *aFreeContainersFitnessFunction, int cellsNumb) { int minFit = 10000; for (int i = 0; i &lt; cellsNumb; i++) { if (minFit &gt; aFreeContainersFitnessFunction[i]) minFit = aFreeContainersFitnessFunction[i]; } int threshold = minFit * (1.2); // 20 %      //       int *aFreeContainersThresholdFitnessFunction = new int[cellsNumb]; int containerNumber = 0; for (int i = 0; i &lt; cellsNumb; i++) { if (threshold &gt;= aFreeContainersFitnessFunction[i] &amp;&amp; aFreeContainersFitnessFunction[i] &lt; 10000) { aFreeContainersThresholdFitnessFunction[containerNumber] = i; containerNumber++; } } int randomNumber = rand() % containerNumber; int randomContainer = aFreeContainersThresholdFitnessFunction[randomNumber]; delete[] aFreeContainersThresholdFitnessFunction; return randomContainer; }</span></span></code> </pre> </div></div><br>  Setelah solusi "permulaan" dibangun pada tahap 1, algoritma dilanjutkan ke tahap 2, di mana peningkatan solusi yang ditemukan tersebut dilakukan, di mana peningkatan secara alami berarti mengurangi total biaya.  Logika dari <b>algoritma pencarian lokal</b> pada langkah 2 adalah sebagai berikut. <br><br><ul><li>  <b>Langkah 1.</b> Untuk solusi saat ini <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">S</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> S </script>  semua solusi "tetangga" dibangun sesuai dengan beberapa jenis lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">N</span><span class="MJXp-mn" id="MJXp-Span-92">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> N1 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">N</span><span class="MJXp-mn" id="MJXp-Span-95">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> N2 </script>  ... <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">N</span><span class="MJXp-mn" id="MJXp-Span-98">5</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> N5 </script>  dan untuk setiap solusi "tetangga", nilai total biaya dihitung. </li><li>  <b>Langkah 2.</b> Jika di antara solusi tetangga ada solusi yang lebih baik <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-99"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">S</span><span class="MJXp-mn" id="MJXp-Span-101">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> S1 </script>  dari solusi aslinya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">S</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> S </script>  lalu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">S</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> S </script>  diasumsikan sama <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">S</span><span class="MJXp-mn" id="MJXp-Span-108">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> S1 </script>  dan algoritma melanjutkan ke langkah 1. Jika tidak, jika di antara solusi tetangga tidak ada solusi yang lebih baik daripada yang asli, maka tampilan lingkungan berubah ke yang baru yang belum dipertimbangkan sebelumnya, dan algoritma melanjutkan ke langkah 1. Jika semua pandangan yang tersedia dari lingkungan dipertimbangkan, tetapi gagal menemukan solusi yang lebih baik daripada yang asli, algoritma mengakhiri pekerjaannya. </li></ul><br>  Tampilan lingkungan dipilih secara berurutan dari tumpukan berikut: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">N</span><span class="MJXp-mn" id="MJXp-Span-111">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> N1 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">N</span><span class="MJXp-mn" id="MJXp-Span-114">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> N2 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-115"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-116">N</span><span class="MJXp-mn" id="MJXp-Span-117">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> N3 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">N</span><span class="MJXp-mn" id="MJXp-Span-120">4</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> N4 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-121"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">N</span><span class="MJXp-mn" id="MJXp-Span-123">5</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> N5 </script>  .  Tampilan area sekitarnya dibagi menjadi 2 jenis: tipe pertama (lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">N</span><span class="MJXp-mn" id="MJXp-Span-126">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> N1 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-127"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">N</span><span class="MJXp-mn" id="MJXp-Span-129">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> N2 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-130"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">N</span><span class="MJXp-mn" id="MJXp-Span-132">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> N3 </script>  ), di mana banyak wadah tidak berubah, tetapi hanya opsi untuk melampirkan sel donor berubah;  tipe kedua (lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-133"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134">N</span><span class="MJXp-mn" id="MJXp-Span-135">4</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> N4 </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137">N</span><span class="MJXp-mn" id="MJXp-Span-138">5</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> N5 </script>  ), di mana tidak hanya opsi untuk menempelkan sel ke wadah berubah, tetapi juga banyak wadah itu sendiri. <br><br>  Kami menunjukkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-139"><span class="MJXp-mrow" id="MJXp-Span-140"><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">J</span><span class="MJXp-mrow" id="MJXp-Span-143"><span class="MJXp-mo" id="MJXp-Span-144" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> | J | </script>  - jumlah elemen dalam set <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-145"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">J</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> J </script>  .  Angka-angka di bawah ini menggambarkan opsi untuk jenis <b>lingkungan pertama</b> . <br><br><img src="https://habrastorage.org/webt/cz/je/zc/czjezclnxomxtpya4venw2kc1ke.jpeg"><br>  <i>Fig.</i>  <i>7. Lingkungan</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-147"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">N</span><span class="MJXp-mn" id="MJXp-Span-149">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> N1 </script></i> <br><br>  Lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-150"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151">N</span><span class="MJXp-mn" id="MJXp-Span-152">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> N1 </script>  (atau <b>shift</b> neighborhood): berisi semua opsi untuk menyelesaikan masalah yang berbeda dari aslinya dengan mengubah lampiran hanya satu sel donor ke wadah.  Ukuran lingkungan tidak lebih <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-153"><span class="MJXp-mrow" id="MJXp-Span-154"><span class="MJXp-mo" id="MJXp-Span-155" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156">J</span><span class="MJXp-mrow" id="MJXp-Span-157"><span class="MJXp-mo" id="MJXp-Span-158" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> | J | </script>  opsi. <br><br><img src="https://habrastorage.org/webt/wd/kd/qt/wdkdqtp5up59kdivwqopwsanijq.jpeg"><br>  <i>Fig.</i>  <i>8. Lingkungan</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-159"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">N</span><span class="MJXp-mn" id="MJXp-Span-161">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> N2 </script></i> <br><br><div class="spoiler">  <b class="spoiler_title">Kode algoritma pencarian lokal di lingkungan N1</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findBestSolutionInNeighborhoodN1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aCellsData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatDist, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellsNumb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatSolutionIteration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **aMatAssignmentSolutionIteration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> totalDemand, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stayFeasible)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        int recordDeltaCosts, recordCell, recordNewContainer, recordNewCosts, recordNewPenalty, recordOldContainer, recordOldCosts, recordOldPenalty; do { recordDeltaCosts = 10000; int totalContainersCapacity = 0; for (int i = 0; i &lt; cellsNumb; i++) if (aMatSolutionIteration[i][1] &gt; 0) totalContainersCapacity += aCellsData[i][0]; //   - for (int j = 0; j &lt; cellsNumb; j++) { //   ,     j int currentContainer; for (int i = 0; i &lt; cellsNumb; i++) { if (aMatAssignmentSolutionIteration[i][j] == 1) { currentContainer = i; break; } } //   ,     j (  ) int numbAssignedCells = 0; if (aMatSolutionIteration[j][0] &gt;= 0) { for (int i = 0; i &lt; cellsNumb; i++) { if (aMatAssignmentSolutionIteration[j][i] == 1) { numbAssignedCells = i; } } } else { numbAssignedCells = 0; } //    j        ,     j,       //     ""           ,     if (j == currentContainer &amp;&amp; numbAssignedCells &gt; 1) { continue; } //         int currentTotalContainersCapacity = totalContainersCapacity - aCellsData[currentContainer][0]; //  ,   ,        j    int currentCosts = aMatDist[currentContainer][j]; //        j         ,      if (aMatSolutionIteration[currentContainer][1] - aCellsData[j][1] == 0) currentCosts += aCellsData[currentContainer][2]; //        j        ,      int currentPenelty = getPenaltyValueForSingleCell(aCellsData, aMatSolutionIteration, currentContainer, j, 0); currentCosts += currentPenelty; for (int i = 0; i &lt; cellsNumb; i++) { if (i == currentContainer) continue; if (stayFeasible) { if (max(0, aMatSolutionIteration[i][1]) + aCellsData[j][1] &gt; aCellsData[i][0]) continue; } else { if (currentTotalContainersCapacity + aCellsData[i][0] &lt; totalDemand) continue; } //     int newCosts = aMatDist[i][j]; //      if (aMatSolutionIteration[i][0] == -1) newCosts += aCellsData[i][2]; //        int newPenalty = getPenaltyValueForSingleCell(aCellsData, aMatSolutionIteration, i, j, 1); newCosts += newPenalty; int deltaCosts = newCosts - currentCosts; if (deltaCosts &lt; 0 &amp;&amp; deltaCosts &lt; recordDeltaCosts) { recordDeltaCosts = deltaCosts; recordCell = j; recordNewContainer = i; recordNewCosts = newCosts; recordNewPenalty = newPenalty; recordOldContainer = currentContainer; recordOldCosts = currentCosts; recordOldPenalty = currentPenelty; } } } //   ,       if (recordDeltaCosts &lt; 0) { //             aMatSolutionIteration[recordOldContainer][1] -= aCellsData[recordCell][1]; aMatSolutionIteration[recordOldContainer][2] -= recordOldCosts; if (aMatSolutionIteration[recordOldContainer][1] == 0) aMatSolutionIteration[recordOldContainer][0] = -1; aMatSolutionIteration[recordOldContainer][3] -= recordOldPenalty; aMatAssignmentSolutionIteration[recordOldContainer][recordCell] = 0; //             aMatSolutionIteration[recordNewContainer][1] += aCellsData[recordCell][1]; aMatSolutionIteration[recordNewContainer][2] += recordNewCosts; if (aMatSolutionIteration[recordNewContainer][0] == -1) aMatSolutionIteration[recordNewContainer][0] = recordNewContainer; aMatSolutionIteration[recordNewContainer][3] += recordNewPenalty; aMatAssignmentSolutionIteration[recordNewContainer][recordCell] = 1; //checkCorrectnessSolution(aCellsData, aMatDist, aMatAssignmentSolutionIteration, aMatSolutionIteration, cellsNumb); } } while (recordDeltaCosts &lt; 0); }</span></span></code> </pre> </div></div><br>  Lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-162"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-163">N</span><span class="MJXp-mn" id="MJXp-Span-164">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-43"> N2 </script>  (atau <b>bertukar</b> lingkungan): berisi semua opsi untuk menyelesaikan masalah yang berbeda dari yang asli dengan saling menukar lampiran ke wadah untuk sepasang sel donor.  Ukuran lingkungan tidak lebih <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-165"><span class="MJXp-mrow" id="MJXp-Span-166"><span class="MJXp-mo" id="MJXp-Span-167" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168">J</span><span class="MJXp-msubsup" id="MJXp-Span-169"><span class="MJXp-mrow" id="MJXp-Span-170" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-171" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-172" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-44"> | J | ^ 2 </script>  opsi. <br><br><img src="https://habrastorage.org/webt/jg/gz/sf/jggzsff9yfubrbmgn5f79z_nd18.jpeg"><br>  <i>Fig.</i>  <i>9. Lingkungan</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-173"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-174">N</span><span class="MJXp-mn" id="MJXp-Span-175">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-45"> N3 </script></i> <br><br>  Lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-176"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177">N</span><span class="MJXp-mn" id="MJXp-Span-178">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46"> N3 </script>  : berisi semua opsi untuk menyelesaikan masalah, yang berbeda dari yang asli dengan saling menggantikan lampiran semua sel untuk satu pasang wadah.  Ukuran lingkungan tidak lebih <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-179"><span class="MJXp-mrow" id="MJXp-Span-180"><span class="MJXp-mo" id="MJXp-Span-181" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182">I</span><span class="MJXp-mrow" id="MJXp-Span-183"><span class="MJXp-mo" id="MJXp-Span-184" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47"> | I | </script>  opsi. <br><br>  <b>Tipe kedua dari lingkungan</b> dianggap sebagai mekanisme "diversifikasi" keputusan, ketika sudah tidak mungkin untuk mendapatkan perbaikan dengan mencari lingkungan "dekat" dari tipe pertama. <br><br><img src="https://habrastorage.org/webt/qu/d4/uv/qud4uvctwiev2bmimavak7mp43m.jpeg"><br>  <i>Fig.</i>  <i>10. Lingkungan</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-185"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186">N</span><span class="MJXp-mn" id="MJXp-Span-187">4</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-48"> N4 </script></i> <br><br>  Lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-188"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">N</span><span class="MJXp-mn" id="MJXp-Span-190">4</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-49-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-49"> N4 </script>  : berisi semua opsi untuk menyelesaikan masalah yang berbeda dari aslinya dengan menghapus satu sel wadah dari solusi.  Sel-sel donor yang melekat pada wadah seperti itu yang dikeluarkan dari solusi melekat pada wadah lain untuk meminimalkan jumlah biaya transportasi dan penalti untuk melebihi kapasitas wadah.  Ukuran lingkungan tidak lebih <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-191"><span class="MJXp-mrow" id="MJXp-Span-192"><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-194">I</span><span class="MJXp-mrow" id="MJXp-Span-195"><span class="MJXp-mo" id="MJXp-Span-196" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-50-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-50"> | I | </script>  opsi. <br><br><img src="https://habrastorage.org/webt/4r/vr/rz/4rvrrzul-b_nsdsehtj1goxvsau.jpeg"><br>  <i>Fig.</i>  <i>11. Lingkungan sekitar</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-197"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198">N</span><span class="MJXp-mn" id="MJXp-Span-199">5</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51"> N5 </script></i> <br><br>  Lingkungan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-200"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">N</span><span class="MJXp-mn" id="MJXp-Span-202">5</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52"> N5 </script>  : berisi semua opsi untuk menyelesaikan masalah yang berbeda dari yang asli dengan memisahkan sel dari satu wadah dan melampirkan sel tersebut ke wadah kosong lainnya untuk satu pasang wadah yang sewenang-wenang.  Ukuran lingkungan tidak lebih <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-203"><span class="MJXp-mrow" id="MJXp-Span-204"><span class="MJXp-mo" id="MJXp-Span-205" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206">I</span><span class="MJXp-msubsup" id="MJXp-Span-207"><span class="MJXp-mrow" id="MJXp-Span-208" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-209" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-210" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-53-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-53"> | I | ^ 2 </script>  opsi. <br><br>  Para penulis artikel mengatakan bahwa, berdasarkan hasil eksperimen komputasi, pilihan terbaik adalah pertama-tama mencari lingkungan "dekat" dari jenis pertama, dan kemudian mencari lingkungan "jauh". <br><br>  Perhatikan bahwa penulis artikel merekomendasikan melakukan pencarian di sekitarnya tanpa memperhitungkan batasan kapasitas masing-masing kontainer.  Sebaliknya, jika kapasitas wadah terlampaui, maka tambahkan ke total biaya solusi sejumlah positif "baik", yang akan mengganggu daya tarik solusi seperti itu dibandingkan dengan solusi lain.  Satu-satunya batasan ditempatkan pada total volume kontainer, yaitu total volume barang yang diangkut dari sel donor tidak boleh melebihi kapasitas total kontainer.  Penghapusan pembatasan ini dilakukan karena jika pembatasan diperhitungkan, maka seringkali lingkungan tidak akan berisi solusi tunggal yang dapat diterima dan algoritma pencarian lokal akan menyelesaikan pekerjaannya segera setelah dimulai, tanpa melakukan perbaikan apa pun.  Gambar 12 menunjukkan contoh operasi pencarian lokal tanpa memperhitungkan batasan kapasitas masing-masing kontainer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fa/yo/pg/fayopguk6rdqukl6pscagxus3bi.jpeg"></div><br>  <i>Fig.</i>  <i>12. Pekerjaan pencarian lokal tanpa memperhitungkan batasan kapasitas masing-masing kontainer</i> <br><br>  Dalam gambar ini, diasumsikan bahwa residu merah dan hijau dari beberapa sel donor tidak menguntungkan untuk dipindahkan ke wadah lain kecuali yang kedua.  Ini berarti bahwa perbaikan lebih lanjut dari solusi tidak mungkin, karena solusi baru yang layak untuk masalah, di mana pembatasan kapasitas dihormati, akan lebih buruk daripada yang asli dalam hal biaya transportasi.  Seperti yang Anda lihat, algoritma untuk 2 iterasi membangun solusi yang layak jauh lebih baik daripada yang asli, meskipun fakta bahwa iterasi pertama membangun solusi yang tidak valid dengan kapasitas berlebih. <br><br>  Perhatikan bahwa pendekatan ini memperkenalkan "penalti" untuk tidak dapat diterimanya solusi cukup umum dalam optimasi diskrit dan sering digunakan dalam algoritma seperti algoritma genetika, pencarian tabu, dll. <br><br>  Setelah algoritma pencarian lokal selesai, jika solusi yang ditemukan masih tidak dapat diterima, yaitu, batas kapasitas kontainer telah dilampaui di suatu tempat, kami harus membawa solusi yang ditemukan ke bentuk yang dapat diterima, di mana semua pembatasan pada kapasitas kontainer dihormati.  Algoritma untuk menyelesaikan tidak dapat diterimanya solusi adalah sebagai berikut. <br><br><ul><li>  <b>Langkah 1.</b> Lakukan pencarian lokal di lingkungan <b>shift</b> dan <b>swap</b> .  Dalam hal ini, transisi hanya dilakukan dalam keputusan yang mengurangi jumlah "denda".  Jika pengurangan penalti tidak memungkinkan, maka solusi dengan total biaya yang lebih rendah dipilih.  Jika perbaikan lebih lanjut dengan pencarian lokal tidak mungkin dilakukan, lanjutkan ke langkah 2, jika tidak, jika solusi yang dihasilkan valid, maka selesaikan algoritme. </li><li>  <b>Langkah 2.</b> Jika solusinya masih tidak dapat diterima, maka dari masing-masing wadah di mana terdapat kelebihan kapasitas, sel donor dilepaskan untuk meningkatkan volume barang hingga pembatasan kapasitas terpenuhi.  Untuk sel-sel terpisah seperti itu, semua langkah dari algoritma, mulai dari yang pertama, diulangi, terlepas dari kenyataan bahwa set wadah yang tersedia tersedia dan cara untuk menempelkan sel-sel yang tersisa ke mereka tetap dan tidak dapat diubah.  Perhatikan bahwa langkah 2 seperti itu, seperti yang diperlihatkan percobaan komputasi, harus dilakukan dengan sangat jarang. </li></ul><br><h4>  Eksperimen komputasi dan analisis efisiensi algoritma </h4><br>  Algoritma GRASP diimplementasikan dari awal di <i>C ++</i> , karena kami tidak menemukan kode sumber untuk algoritma yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> .  Kode program dikompilasi menggunakan g ++ dengan opsi optimasi -O2. <br><br>  Kode proyek Visual Studio tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Satu-satunya hal yang diminta pelanggan adalah menghapus beberapa prosedur pencarian lokal paling kompleks untuk alasan kekayaan intelektual, rahasia dagang, dll. <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> yang menggambarkan algoritma GRASP, efisiensi tinggi dinyatakan, di mana dengan efisiensi itu berarti bahwa itu secara stabil menghitung solusi yang sangat dekat dengan optimal, dan itu bekerja cukup cepat.  Untuk memverifikasi keefektifan nyata dari algoritma GRASP seperti itu, kami melakukan eksperimen komputasi kami sendiri.  Data input dari masalah dihasilkan oleh kami secara acak dengan distribusi yang seragam.  Solusi yang dihitung oleh algoritma dibandingkan dengan solusi optimal, yang dihitung dengan algoritma yang tepat yang diusulkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> .  Sumber dari algoritma yang tepat seperti itu tersedia secara bebas di GitHub dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi</a> .  Dimensi tugas, misalnya, 10x100 berarti kita memiliki 10 sel donor dan 100 sel wadah. <br><br>  Perhitungan dilakukan pada komputer pribadi dengan karakteristik sebagai berikut: CPU 2.50 GHz, Intel Core i5-3210M, RAM 8 GB, sistem operasi Windows 10 (x64). <br><div class="scrollable-table"><table><tbody><tr><th>   </th><th>  <br>  <br>  </th><th>   <br>   GRASP </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rata-rata waktu berjalan </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma yang </font><font style="vertical-align: inherit;">tepat</font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesalahan rata-rata dari </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma GRASP,%</font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5x50 </font></font></td><td>  50 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,08 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.22 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,2 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10x50 </font></font></td><td>  50 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,14 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3,75 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,4 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10x100 </font></font></td><td>  50 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,55 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.81 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.4 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10x200 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82,73 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20x100 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 264.15 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2,3 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20x200 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 797.39 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.7 </font></font></td></tr></tbody></table></div> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel 3. Perbandingan waktu operasi dari algoritma GRASP dan algoritma yang tepat</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti dapat dilihat dari tabel 3, algoritma GRASP benar-benar menghitung dekat dengan solusi optimal, dan dengan peningkatan dimensi masalah, kualitas solusi algoritma sedikit memburuk. </font><font style="vertical-align: inherit;">Juga terlihat dari hasil percobaan bahwa algoritma GRASP cukup cepat, misalnya, ia memecahkan masalah dimensi 10x100 rata-rata dalam 0,5 detik. </font><font style="vertical-align: inherit;">Perlu disebutkan pada akhirnya bahwa hasil percobaan komputasi kami konsisten dengan hasil dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menjalankan algoritma dalam produksi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah algoritma dikembangkan, didebug dan diuji dalam percobaan komputasi, tibalah saatnya untuk menjalankannya. </font><font style="vertical-align: inherit;">Algoritme diimplementasikan dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan ditempatkan dalam DLL yang terhubung ke aplikasi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1C</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai komponen eksternal dari tipe asli. </font><font style="vertical-align: inherit;">Baca </font><font style="vertical-align: inherit;">tentang komponen eksternal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1C</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan cara mengembangkan dan menghubungkannya dengan benar ke aplikasi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1C di </font></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam program "1C: Warehouse Management 3", formulir pemrosesan dikembangkan di mana pengguna dapat memulai prosedur untuk mengompresi residu dengan parameter yang ia butuhkan. </font><font style="vertical-align: inherit;">Tangkapan layar formulir ditunjukkan di bawah ini. </font></font><br><br><img src="https://habrastorage.org/webt/6z/tx/1t/6ztx1tuxo69y0fwnbjavsfozpug.jpeg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. 13. </font><font style="vertical-align: inherit;">Bentuk prosedur untuk "kompresi" saldo dalam Lampiran 1C: Manajemen Gudang 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengguna dapat memilih parameter kompresi untuk residu dalam bentuk: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mode kompresi: dengan pengelompokan batch (lihat artikel pertama) dan tanpa itu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gudang, di sel-sel yang diperlukan untuk melakukan kompresi. </font><font style="vertical-align: inherit;">Dalam satu ruangan bisa ada beberapa gudang untuk organisasi yang berbeda. </font><font style="vertical-align: inherit;">Situasi seperti itu terjadi pada klien kami.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain itu, pengguna dapat secara interaktif menyesuaikan jumlah barang yang ditransfer dari sel donor ke wadah dan menghapus item dari daftar untuk kompresi, jika karena alasan tertentu ia ingin agar tidak berpartisipasi dalam prosedur kompresi. </font></font></li></ul><br><h4>  Kesimpulan </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada akhir artikel ini saya ingin merangkum pengalaman yang didapat sebagai hasil dari pengenalan algoritma optimasi. </font></font><br><br><ul><li>      <b>  </b>     .        :  ,  ,     .               <b>- </b> : <br><ol><li> <b></b> ,        ; </li><li> <b>  </b>      . </li></ol></li><li> <b>   </b>      (          ), ,     .    «»,      -       .    ,      ,       . , ,      ,   - ,  . </li><li>        ,       (   ),  <b>    </b>   .   ,      ,            .    ,       .            .          ,     . </li><li>         : <br><ol><li>      . </li><li>        . </li><li>        .      ,  . </li><li>       .   ,     .          ,  ,            ,  ,    . </li><li> ,     .           (    )          .               ,      . </li><li>       . </li></ol></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan, saya pikir, hal yang paling penting. Proses optimisasi dalam perusahaan seringkali harus mengikuti setelah selesainya proses informatisasi. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimasi tanpa informasi awal tidak banyak berguna</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena tidak ada tempat untuk mendapatkan data dan tidak ada tempat untuk menulis data dari solusi algoritma. Saya berpikir bahwa sebagian besar perusahaan domestik menengah dan besar telah menutup kebutuhan dasar untuk otomatisasi dan informatisasi dan siap untuk lebih mengoptimalkan proses "fine-tuning". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, kami berlatih setelah penerapan sistem informasi, baik itu ERP, WMS, TMS, dll. buat ekstra kecil. proyek untuk mengoptimalkan proses-proses yang diidentifikasi selama implementasi sistem informasi sebagai masalah dan penting bagi klien. Saya pikir ini adalah praktik yang menjanjikan yang akan mendapatkan momentum di tahun-tahun mendatang.</font></font><br><br> <i>  <br>  ,   , <br>   , . </i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463651/">https://habr.com/ru/post/id463651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463631/index.html">Dialog tentang surat</a></li>
<li><a href="../id463637/index.html">Menguji infrastruktur Anda sebagai kode dengan Pulumi. Bagian 2</a></li>
<li><a href="../id463639/index.html">Yah Apple BLEee</a></li>
<li><a href="../id463647/index.html">Video dan laporan dengan SmartMail Meetup: Frontend</a></li>
<li><a href="../id463649/index.html">Catatan analitik. Ulasan urutan Kementerian Energi Federasi Rusia 6 November 2018 N 1015</a></li>
<li><a href="../id463653/index.html">Keterbatasan game 16-bit dan rekreasi mereka di Unity</a></li>
<li><a href="../id463655/index.html">Kelahiran satu proyek atau cara menulis CMS Anda sendiri</a></li>
<li><a href="../id463657/index.html">Chatbots menyebalkan</a></li>
<li><a href="../id463663/index.html">10 buku untuk memahami struktur pasar saham, investasi di bursa saham dan perdagangan otomatis</a></li>
<li><a href="../id463665/index.html">1,1 miliar naik taksi: klaster ClickHouse 108-inti</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>