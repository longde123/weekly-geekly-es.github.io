<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🌾 👩🏿‍⚕️ 😎 Configurer le cluster nomade avec Consul et l'intégrer avec Gitlab 🔊 😒 🐠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 

 Récemment, la popularité de Kubernetes augmente rapidement - de plus en plus de projets le mettent en œuvre à la maison. Je voulais to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Configurer le cluster nomade avec Consul et l'intégrer avec Gitlab</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453322/"><h2>  Présentation </h2><br><br>  Récemment, la popularité de Kubernetes augmente rapidement - de plus en plus de projets le mettent en œuvre à la maison.  Je voulais toucher un orchestrateur comme Nomad: il est parfait pour les projets qui utilisent déjà d'autres solutions de HashiCorp, par exemple, Vault et Consul, et les projets eux-mêmes ne sont pas compliqués en termes d'infrastructure.  Cet article fournira des instructions sur l'installation de Nomad, la combinaison de deux nœuds dans un cluster et l'intégration de Nomad avec Gitlab. <br><br><img src="https://habrastorage.org/webt/bu/yn/4v/buyn4vqshurhgc9kavloja-fzsm.png"><br><br><a name="habracut"></a><br><br><h2>  Banc d'essai </h2><br><br>  Un peu sur le banc de test: trois serveurs virtuels sont utilisés avec les caractéristiques de 2 CPU, 4 RAM, SSD 50 Go, réunis dans un réseau local commun.  Leurs noms et adresses IP: <br><br><ol><li>  <b>nomad-livelinux-01</b> : 172.30.0.5 </li><li>  <b>nomad-livelinux-02</b> : 172.30.0.10 </li><li>  <b>consul-livelinux-01</b> : 172.30.0.15 </li></ol><br><br><h2>  Installation de Nomad, Consul.  Création d'un cluster nomade </h2><br><br>  Passons à l'installation de base.  Malgré la facilité d'installation, je vais le décrire pour l'intégrité de l'article: en fait, il a été créé à partir de brouillons et de notes pour un accès rapide si nécessaire. <br><br>  Avant de commencer la pratique, nous discuterons de la partie théorique, car à ce stade, il est important de comprendre la structure future. <br><br>  Nous avons deux nœuds nomades et nous voulons les combiner en un cluster, et pour l'avenir, nous aurons besoin d'une mise à l'échelle automatique du cluster - pour cela, nous avons besoin de Consul.  À l'aide de cet outil, le clustering et l'ajout de nouveaux nœuds deviennent une tâche très simple: le nœud Nomad créé se connecte à l'agent Consul, puis se connecte au cluster Nomad existant.  Par conséquent, au début, nous allons installer le serveur Consul, configurer l'autorisation http de base pour le panneau Web (elle est par défaut sans autorisation et peut être consultée à une adresse externe), ainsi que les agents Consul eux-mêmes sur les serveurs Nomad, après quoi nous démarrons simplement Nomad. <br><br>  L'installation des outils HashiCorp est très simple: en fait, nous déplaçons simplement le fichier binaire dans le répertoire bin, configurons le fichier de configuration de l'outil et créons son fichier de service. <br><br>  Téléchargez le fichier binaire Consul et décompressez-le dans le répertoire personnel de l'utilisateur: <br><br><pre><code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># wget https://releases.hashicorp.com/consul/1.5.0/consul_1.5.0_linux_amd64.zip root@consul-livelinux-01:~# unzip consul_1.5.0_linux_amd64.zip root@consul-livelinux-01:~# mv consul /usr/local/bin/</span></span></code> </pre> <br><br>  Nous avons maintenant un fichier consul binaire prêt à l'emploi pour une configuration supplémentaire. <br><br>  Pour travailler avec Consul, nous devons créer une clé unique à l'aide de la commande keygen: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># consul keygen</span></span></code> </pre><br><br>  Passons à la configuration du Consul, créons le répertoire /etc/consul.d/ avec la structure suivante: <br><br><pre> <code class="bash hljs">/etc/consul.d/ ├── bootstrap │ └── config.json</code> </pre> <br><br>  Le répertoire bootstrap contiendra le fichier de configuration config.json - nous y définirons les paramètres Consul.  Son contenu: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"bootstrap"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"server"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"datacenter"</span></span>: <span class="hljs-string"><span class="hljs-string">"dc1"</span></span>, <span class="hljs-string"><span class="hljs-string">"data_dir"</span></span>: <span class="hljs-string"><span class="hljs-string">"/var/consul"</span></span>, <span class="hljs-string"><span class="hljs-string">"encrypt"</span></span>: <span class="hljs-string"><span class="hljs-string">"your-key"</span></span>, <span class="hljs-string"><span class="hljs-string">"log_level"</span></span>: <span class="hljs-string"><span class="hljs-string">"INFO"</span></span>, <span class="hljs-string"><span class="hljs-string">"enable_syslog"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"start_join"</span></span>: [<span class="hljs-string"><span class="hljs-string">"172.30.0.15"</span></span>] }</code> </pre> <br><br>  Examinons séparément les principales directives et leur signification: <br><br><ul><li>  <b>bootstrap</b> : vrai.  Nous activons l'ajout automatique de nouveaux nœuds s'ils sont connectés.  Je note que nous n'indiquons pas ici le nombre exact de nœuds attendus. </li><li>  <b>serveur</b> : vrai.  Activez le mode serveur.  Le consul sur cette machine virtuelle sera le seul serveur et maître pour le moment, VM Nomad sera client. </li><li>  <b>centre de données</b> : dc1.  Spécifiez le nom du centre de données pour créer un cluster.  Il doit être identique sur les clients et les serveurs. </li><li>  <b>crypter</b> : votre-clé.  Une clé qui doit également être unique et correspondre à tous les clients et serveurs.  Généré à l'aide de la commande consul keygen. </li><li>  <b>start_join</b> .  Dans cette liste, nous indiquons la liste des adresses IP auxquelles la connexion sera établie.  Pour le moment, nous ne laissons que notre propre adresse. </li></ul><br><br>  À ce stade, nous pouvons démarrer consul en utilisant la ligne de commande: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># /usr/local/bin/consul agent -config-dir /etc/consul.d/bootstrap -ui</span></span></code> </pre> <br><br>  C'est un bon moyen de déboguer maintenant, cependant, sur une base continue, l'utilisation de cette méthode ne fonctionnera pas pour des raisons évidentes.  Créez un fichier de service pour gérer Consul via systemd: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># nano /etc/systemd/system/consul.service</span></span></code> </pre><br><br>  Le contenu du fichier consul.service: <br><br><pre> <code class="bash hljs">[Unit] Description=Consul Startup process After=network.target [Service] Type=simple ExecStart=/bin/bash -c <span class="hljs-string"><span class="hljs-string">'/usr/local/bin/consul agent -config-dir /etc/consul.d/bootstrap -ui'</span></span> TimeoutStartSec=0 [Install] WantedBy=default.target</code> </pre> <br><br>  Exécutez Consul via systemctl: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># systemctl start consul</span></span></code> </pre><br><br>  Nous vérifions: notre service doit être démarré, et en exécutant la commande consul members, nous devrions voir notre serveur: <br><br><pre> <code class="bash hljs">root@consul-livelinux:/etc/consul.d<span class="hljs-comment"><span class="hljs-comment"># consul members consul-livelinux 172.30.0.15:8301 alive server 1.5.0 2 dc1 &lt;all&gt;</span></span></code> </pre> <br><br>  L'étape suivante: installer Nginx et configurer un proxy, autorisation http.  Installez nginx via le gestionnaire de packages et dans le répertoire / etc / nginx / sites-enabled créez le fichier de configuration consul.conf avec le contenu suivant: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> consul-auth { <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> localhost:<span class="hljs-number"><span class="hljs-number">8500</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> consul.doman.name; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://consul-auth; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">auth_basic_user_file</span></span> /etc/nginx/.htpasswd; <span class="hljs-attribute"><span class="hljs-attribute">auth_basic</span></span> <span class="hljs-string"><span class="hljs-string">"Password-protected Area"</span></span>; } }</code> </pre> <br><br>  N'oubliez pas de créer un fichier .htpasswd et de générer un nom d'utilisateur et un mot de passe pour celui-ci.  Cet élément est requis pour que le panneau Web ne soit pas accessible à tous ceux qui connaissent notre domaine.  Cependant, lors de la configuration de Gitlab, nous devrons l'abandonner - sinon nous ne pourrons pas déployer notre application sur Nomad.  Dans mon projet, Gitlab et Nomad sont uniquement sur le réseau gris, il n'y a donc pas de problème. <br><br>  Sur les deux autres serveurs, installez les agents Consul conformément aux instructions suivantes.  Répétez les étapes avec le fichier binaire: <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># wget https://releases.hashicorp.com/consul/1.5.0/consul_1.5.0_linux_amd64.zip root@nomad-livelinux-01:~# unzip consul_1.5.0_linux_amd64.zip root@nomad-livelinux-01:~# mv consul /usr/local/bin/</span></span></code> </pre> <br><br>  Par analogie avec le serveur précédent, nous créons un répertoire pour les fichiers de configuration /etc/consul.d avec la structure suivante: <br><br><pre> <code class="bash hljs">/etc/consul.d/ ├── client │ └── config.json</code> </pre> <br><br>  Le contenu du fichier config.json: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"datacenter"</span></span>: <span class="hljs-string"><span class="hljs-string">"dc1"</span></span>, <span class="hljs-string"><span class="hljs-string">"data_dir"</span></span>: <span class="hljs-string"><span class="hljs-string">"/opt/consul"</span></span>, <span class="hljs-string"><span class="hljs-string">"log_level"</span></span>: <span class="hljs-string"><span class="hljs-string">"DEBUG"</span></span>, <span class="hljs-string"><span class="hljs-string">"node_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"nomad-livelinux-01"</span></span>, <span class="hljs-string"><span class="hljs-string">"server"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"encrypt"</span></span>: <span class="hljs-string"><span class="hljs-string">"your-private-key"</span></span>, <span class="hljs-string"><span class="hljs-string">"domain"</span></span>: <span class="hljs-string"><span class="hljs-string">"livelinux"</span></span>, <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>: { <span class="hljs-string"><span class="hljs-string">"dns"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"https"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"grpc"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"http"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span> }, <span class="hljs-string"><span class="hljs-string">"bind_addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"172.30.0.5"</span></span>, #    <span class="hljs-string"><span class="hljs-string">"start_join"</span></span>: [<span class="hljs-string"><span class="hljs-string">"172.30.0.15"</span></span>], #     <span class="hljs-string"><span class="hljs-string">"ports"</span></span>: { <span class="hljs-string"><span class="hljs-string">"dns"</span></span>: <span class="hljs-number"><span class="hljs-number">53</span></span> } }</code> </pre><br><br>  Nous enregistrons les modifications et procédons à la configuration du fichier de service, son contenu: <br><br>  /etc/systemd/system/consul.service: <br><br><pre> <code class="bash hljs">[Unit] Description=<span class="hljs-string"><span class="hljs-string">"HashiCorp Consul - A service mesh solution"</span></span> Documentation=https://www.consul.io/ Requires=network-online.target After=network-online.target [Service] User=root Group=root ExecStart=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/consul agent -config-dir=/etc/consul.d/client ExecReload=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/consul reload KillMode=process Restart=on-failure [Install] WantedBy=multi-user.target</code> </pre> <br><br>  Nous commençons consul sur le serveur.  Maintenant, après le démarrage, nous devrions voir le service configuré dans les membres nsul.  Cela signifie qu'il s'est connecté avec succès au cluster en tant que client.  Répétez la même chose sur le deuxième serveur et après cela, nous pourrons commencer à installer et configurer Nomad. <br><br>  Une installation plus détaillée de Nomad est décrite dans sa documentation officielle.  Il existe deux méthodes d'installation traditionnelles: le téléchargement d'un fichier binaire et la compilation à partir des sources.  Je choisirai la première méthode. <br><br>  <b>Remarque</b> : le projet se développe très rapidement, de nouvelles mises à jour sortent souvent.  Peut-être qu'une nouvelle version sera publiée au moment où cet article sera terminé.  Par conséquent, je recommande qu'avant de lire, vérifiez la version actuelle de Nomad pour le moment et téléchargez-la. <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># wget https://releases.hashicorp.com/nomad/0.9.1/nomad_0.9.1_linux_amd64.zip root@nomad-livelinux-01:~# unzip nomad_0.9.1_linux_amd64.zip root@nomad-livelinux-01:~# mv nomad /usr/local/bin/ root@nomad-livelinux-01:~# nomad -autocomplete-install root@nomad-livelinux-01:~# complete -C /usr/local/bin/nomad nomad root@nomad-livelinux-01:~# mkdir /etc/nomad.d</span></span></code> </pre> <br><br>  Après le déballage, nous obtiendrons un fichier binaire Nomad'a pesant 65 Mo - il doit être déplacé vers / usr / local / bin. <br><br>  Créez un répertoire de données pour Nomad et éditez son fichier de service (il n'existera probablement pas au début): <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># mkdir --parents /opt/nomad root@nomad-livelinux-01:~# nano /etc/systemd/system/nomad.service</span></span></code> </pre> <br><br>  Insérez-y les lignes suivantes: <br><br><pre> <code class="bash hljs">[Unit] Description=Nomad Documentation=https://nomadproject.io/docs/ Wants=network-online.target After=network-online.target [Service] ExecReload=/bin/<span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -HUP <span class="hljs-variable"><span class="hljs-variable">$MAINPID</span></span> ExecStart=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/nomad agent -config /etc/nomad.d KillMode=process KillSignal=SIGINT LimitNOFILE=infinity LimitNPROC=infinity Restart=on-failure RestartSec=2 StartLimitBurst=3 StartLimitIntervalSec=10 TasksMax=infinity [Install] WantedBy=multi-user.target</code> </pre> <br><br>  Cependant, nous ne sommes pas pressés d'exécuter nomade - nous n'avons pas encore créé son fichier de configuration: <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># mkdir --parents /etc/nomad.d root@nomad-livelinux-01:~# chmod 700 /etc/nomad.d root@nomad-livelinux-01:~# nano /etc/nomad.d/nomad.hcl root@nomad-livelinux-01:~# nano /etc/nomad.d/server.hcl</span></span></code> </pre><br><br>  La structure finale du répertoire sera la suivante: <br><br><pre> <code class="bash hljs">/etc/nomad.d/ ├── nomad.hcl └── server.hcl</code> </pre> <br><br>  Le fichier nomad.hcl doit contenir la configuration suivante: <br><br><pre> <code class="bash hljs">datacenter = <span class="hljs-string"><span class="hljs-string">"dc1"</span></span> data_dir = <span class="hljs-string"><span class="hljs-string">"/opt/nomad"</span></span></code> </pre> <br><br>  Le contenu du fichier server.hcl: <br><br><pre> <code class="bash hljs">server { enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> bootstrap_expect = 1 } consul { address = <span class="hljs-string"><span class="hljs-string">"127.0.0.1:8500"</span></span> server_service_name = <span class="hljs-string"><span class="hljs-string">"nomad"</span></span> client_service_name = <span class="hljs-string"><span class="hljs-string">"nomad-client"</span></span> auto_advertise = <span class="hljs-literal"><span class="hljs-literal">true</span></span> server_auto_join = <span class="hljs-literal"><span class="hljs-literal">true</span></span> client_auto_join = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } bind_addr = <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span> advertise { http = <span class="hljs-string"><span class="hljs-string">"172.30.0.5"</span></span> } client { enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><br>  N'oubliez pas de changer le fichier de configuration sur le deuxième serveur - là, vous devrez changer la valeur de la directive http. <br><br>  Le dernier à ce stade est la configuration de Nginx pour le proxy et la définition de l'autorisation http.  Le contenu du fichier nomad.conf: <br><br><pre> <code class="bash hljs">upstream nomad-auth { server 172.30.0.5:4646; } server { server_name nomad.domain.name; location / { proxy_pass http://nomad-auth; proxy_set_header Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; auth_basic_user_file /etc/nginx/.htpasswd; auth_basic <span class="hljs-string"><span class="hljs-string">"Password-protected Area"</span></span>; } }</code> </pre> <br><br>  Nous pouvons maintenant accéder au panneau Web via un réseau externe.  Nous nous connectons et allons sur la page des serveurs: <br><br><img src="https://habrastorage.org/webt/en/uq/ck/enuqck8krqstsbt8b6uwbytoy0e.png"><br>  <b>Figure 1.</b> Liste des serveurs dans un cluster Nomad <br><br>  Les deux serveurs sont affichés avec succès dans le panneau, la même chose que nous verrons dans la sortie de la commande d'état du nœud nomade: <br><br><img src="https://habrastorage.org/webt/c1/gv/82/c1gv82tjvwtw0onqxqv3huchv1w.png"><br>  <b>Image 2.</b> La sortie de la commande nomad node status <br><br>  Et le consul?  Voyons voir.  Accédez au panneau de configuration Consul, à la page des nœuds: <br><img src="https://habrastorage.org/webt/m5/6w/tj/m56wtjjgkos9ed5e_jy9lidmutg.png"><br>  <b>Figure 3.</b> Liste des nœuds du cluster Consul <br><br>  Nous avons maintenant préparé Nomad, en collaboration avec le consul.  Dans la dernière étape, nous allons commencer la partie la plus intéressante: nous allons configurer la livraison des conteneurs Docker de Gitlab à Nomad, ainsi que parler de certaines de ses autres caractéristiques distinctives. <br><br><h2>  Créer Gitlab Runner <br></h2><br><br>  Pour déployer des images de docker sur Nomad, nous utiliserons un exécuteur séparé avec le fichier binaire Nomad à l'intérieur (ici, au fait, une autre fonctionnalité des applications Hashicorp peut être notée - individuellement, il s'agit du seul fichier binaire).  Téléchargez-le dans le répertoire runner.  Pour lui, créez le Dockerfile le plus simple avec le contenu suivant: <br><br><pre> <code class="bash hljs">FROM alpine:3.9 RUN apk add --update --no-cache libc6-compat gettext COPY nomad /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/nomad</code> </pre><br><br>  Dans le même projet, créez .gitlab-ci.yml: <br><br><pre> <code class="bash hljs">variables: DOCKER_IMAGE: nomad/nomad-deploy DOCKER_REGISTRY: registry.domain.name stages: - build build: stage: build image: <span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/nomad/alpine:3 script: - tag=<span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${DOCKER_IMAGE}</span></span>:latest - docker build --pull -t <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span> -f Dockerfile . - docker push <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span></code> </pre> <br><br>  En conséquence, nous aurons une image accessible du runner Nomad dans le registre Gitlab, maintenant nous pouvons aller directement au référentiel du projet, créer un Pipeline et configurer le job nomade Nomad. <br><br><h2>  Configuration du projet <br></h2><br><br>  Commençons par le dossier de travail pour Nomad.  Mon projet dans cet article sera assez primitif: il consistera en une tâche.  Le contenu de .gitlab-ci sera le suivant: <br><br><pre> <code class="bash hljs">variables: NOMAD_ADDR: http://nomad.address.service:4646 DOCKER_REGISTRY: registry.domain.name DOCKER_IMAGE: example/project stages: - build - deploy build: stage: build image: <span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/nomad-runner/alpine:3 script: - tag=<span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${DOCKER_IMAGE}</span></span>:<span class="hljs-variable"><span class="hljs-variable">${CI_COMMIT_SHORT_SHA}</span></span> - docker build --pull -t <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span> -f Dockerfile . - docker push <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span> deploy: stage: deploy image: registry.example.com/nomad/nomad-runner:latest script: - envsubst <span class="hljs-string"><span class="hljs-string">'${CI_COMMIT_SHORT_SHA}'</span></span> &lt; project.nomad &gt; job.nomad - cat job.nomad - nomad validate job.nomad - nomad plan job.nomad || <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -eq 255 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 255; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"success"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> - nomad run job.nomad environment: name: production allow_failure: <span class="hljs-literal"><span class="hljs-literal">false</span></span> when: manual</code> </pre> <br><br>  Ici, le déploiement se produit en mode manuel, mais vous pouvez le configurer pour modifier le contenu du répertoire du projet.  Le pipeline comprend deux étapes: de l'assemblage de l'image et de son déploiement au nomade.  Dans un premier temps, nous collectons l'image docker et la poussons dans notre Registre; dans un second temps, nous lançons notre travail dans Nomad. <br><br><pre> <code class="bash hljs">job <span class="hljs-string"><span class="hljs-string">"monitoring-status"</span></span> { datacenters = [<span class="hljs-string"><span class="hljs-string">"dc1"</span></span>] migrate { max_parallel = 3 health_check = <span class="hljs-string"><span class="hljs-string">"checks"</span></span> min_healthy_time = <span class="hljs-string"><span class="hljs-string">"15s"</span></span> healthy_deadline = <span class="hljs-string"><span class="hljs-string">"5m"</span></span> } group <span class="hljs-string"><span class="hljs-string">"zhadan.ltd"</span></span> { count = 1 update { max_parallel = 1 min_healthy_time = <span class="hljs-string"><span class="hljs-string">"30s"</span></span> healthy_deadline = <span class="hljs-string"><span class="hljs-string">"5m"</span></span> progress_deadline = <span class="hljs-string"><span class="hljs-string">"10m"</span></span> auto_revert = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } task <span class="hljs-string"><span class="hljs-string">"service-monitoring"</span></span> { driver = <span class="hljs-string"><span class="hljs-string">"docker"</span></span> config { image = <span class="hljs-string"><span class="hljs-string">"registry.domain.name/example/project:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${CI_COMMIT_SHORT_SHA}</span></span></span><span class="hljs-string">"</span></span> force_pull = <span class="hljs-literal"><span class="hljs-literal">true</span></span> auth { username = <span class="hljs-string"><span class="hljs-string">"gitlab_user"</span></span> password = <span class="hljs-string"><span class="hljs-string">"gitlab_password"</span></span> } port_map { http = 8000 } } resources { network { port <span class="hljs-string"><span class="hljs-string">"http"</span></span> {} } } } } }</code> </pre> <br><br>  Veuillez noter que j'ai un registre privé et que pour un pool d'images Docker réussi, je dois me connecter.  La meilleure solution dans ce cas est d'entrer un identifiant et un mot de passe dans Vault avec son intégration ultérieure avec Nomad.  Nomad prend en charge nativement Vault.  Mais d'abord, dans Vault lui-même, nous installerons les politiques nécessaires pour Nomad, vous pouvez les télécharger: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Download the policy and token role $ curl https://nomadproject.io/data/vault/nomad-server-policy.hcl -O -s -L $ curl https://nomadproject.io/data/vault/nomad-cluster-role.json -O -s -L # Write the policy to Vault $ vault policy write nomad-server nomad-server-policy.hcl # Create the token role with Vault $ vault write /auth/token/roles/nomad-cluster @nomad-cluster-role.json</span></span></code> </pre> <br><br>  Maintenant, après avoir créé les politiques nécessaires, nous allons ajouter l'intégration avec Vault dans le bloc de tâches du fichier job.nomad: <br><br><pre> <code class="bash hljs">vault { enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> address = <span class="hljs-string"><span class="hljs-string">"https://vault.domain.name:8200"</span></span> token = <span class="hljs-string"><span class="hljs-string">"token"</span></span> }</code> </pre> <br><br>  J'utilise l'autorisation par token et l'écris directement ici, il y a aussi la possibilité de spécifier le token comme variable lors de l'exécution de l'agent nomade: <br><br><pre> <code class="bash hljs">$ VAULT_TOKEN=&lt;token&gt; nomad agent -config /path/to/config</code> </pre><br><br>  Maintenant, nous pouvons utiliser les clés avec Vault.  Le principe de fonctionnement est simple: on crée un fichier dans le job Nomad, qui va stocker les valeurs des variables, par exemple: <br><br><pre> <code class="bash hljs">template { data = &lt;&lt;EOH {{with secret <span class="hljs-string"><span class="hljs-string">"secrets/pipeline-keys"</span></span>}} REGISTRY_LOGIN=<span class="hljs-string"><span class="hljs-string">"{{ .Data.REGISTRY_LOGIN }}"</span></span> REGISTRY_PASSWORD=<span class="hljs-string"><span class="hljs-string">"{{ .Data.REGISTRY_LOGIN }}{{ end }}"</span></span> EOH destination = <span class="hljs-string"><span class="hljs-string">"secrets/service-name.env"</span></span> env = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><br>  Avec cette approche simple, vous pouvez configurer la livraison des conteneurs au cluster Nomad et travailler avec lui à l'avenir.  Je dirai que dans une certaine mesure, je sympathise avec Nomad - il convient mieux aux petits projets où Kubernetes peut causer des difficultés supplémentaires et ne réalisera pas son potentiel à la fin.  De plus, Nomad est parfait pour les débutants - il est facile à installer et à configurer.  Cependant, lors de tests sur certains projets, je rencontre le problème de ses versions antérieures - de nombreuses fonctions de base n'existent tout simplement pas ou ne fonctionnent pas correctement.  Néanmoins, je pense que Nomad va continuer à se développer et à l'avenir acquérir toutes les fonctions nécessaires. <br><br>  <i>Publié par Ilya Andreev, édité par Alexei Zhadan et Live Linux Team</i> <i><br></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453322/">https://habr.com/ru/post/fr453322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453310/index.html">Échangez des données entre les composants React à l'aide de la bibliothèque RxJS</a></li>
<li><a href="../fr453312/index.html">Générateur d'e-mails professionnels PDF basé sur des données XML</a></li>
<li><a href="../fr453314/index.html">DIY Black Mirror - enseignez un bot basé sur son historique de chat</a></li>
<li><a href="../fr453316/index.html">Le fabricant de puces britannique ARM cesse sa coopération avec Huawei</a></li>
<li><a href="../fr453318/index.html">5 erreurs dans l'implémentation des notifications push pour les applications mobiles</a></li>
<li><a href="../fr453324/index.html">Diode comme redresseur</a></li>
<li><a href="../fr453326/index.html">Comment automatiser la gestion de l'infrastructure informatique - discutez de trois tendances</a></li>
<li><a href="../fr453328/index.html">Dix ans sur un site distant</a></li>
<li><a href="../fr453330/index.html">Que faire si la RAM tombe en panne. Anamnèse et méthodes de traitement</a></li>
<li><a href="../fr453332/index.html">À propos de l'étrange méthode pour économiser de l'espace sur le disque dur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>