<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👪 ➡️ 👩‍👧‍👦 Online-Checks im Bundesnetz durch RabbitMQ, 1C und Black Magic 🚶 🔛 🤘🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vergangenen Jahr hat uns der IT-Direktor einer der größten agroindustriellen Beteiligungen in Russland kontaktiert. Die Herangehensweise unseres Ku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Online-Checks im Bundesnetz durch RabbitMQ, 1C und Black Magic</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422151/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/89/-z/xo/89-zxong6o-oxnwst3edu20hxba.png"></div><br><p>  Im vergangenen Jahr hat uns der IT-Direktor einer der größten agroindustriellen Beteiligungen in Russland kontaktiert.  Die Herangehensweise unseres Kunden an das Geschäft war beeindruckend.  Er war einer der ersten, der die Idee eines Vollzyklusunternehmens umsetzte - vom Feld bis zum Regal im Lebensmittelgeschäft.  Aufgrund der Verfügbarkeit und der hohen Qualität der Produkte hat sich diese Holding zu einer anerkannten Marke entwickelt, die sie kennen und auswählen.  Zu dieser Zeit umfasste die Holding mehr als 650 Filialen und mehr als 20.000 Mitarbeiter, die in der gesamten Russischen Föderation verteilt waren. </p><br><p>  Der Kunde musste sicherstellen, dass Schecks von allen Einzelhandelsgeschäften in Russland schnellstmöglich an das Zentrum geliefert werden, einschließlich Essensständen in abgelegenen Dörfern mit gelegentlichem Internet und minimaler Computerisierung. </p><br><p>  Angesichts dieser Besonderheit wurde die Lösung des Problems zu einem aufregenden Abenteuer mit Tamburin, Schamanen und Kaninchenpfoten angesichts von RabbitMQ.  Wie wir einen zusammengeschlossenen Cluster von Warteschlangen aufgebaut haben und was uns begegnet ist - unter dem Schnitt. </p><a name="habracut"></a><br><h2 id="o-problematike-zakazchika">  Über Kundenprobleme </h2><br><p>  Das Halten mit einer großen Anzahl verteilter Verkaufsstellen, die unter den Bedingungen eines harten Wettbewerbs operieren, verlangte von ihren Führungskräften, unverzüglich Managemententscheidungen zu treffen.  Zu diesem Zweck benötigten die Manager Informationen zu Überprüfungen im Echtzeitmodus. </p><br><p>  Im aktuellen System betrug die Lieferzeit des Schecks vom Kassierer zum zentralen System 3 Tage.  Gleichzeitig wurden Informationen über den perfekten Kauf nicht regelmäßig erfasst (Scheckverlust). </p><br><p>  Es war erforderlich, Informationen über den Verkauf „hier und jetzt“ bereitzustellen, um die Lieferung der Produkte an die Verkaufsstellen zu optimieren und schnell auf Änderungen im Gleichgewicht zwischen Waren und Nachfrage zu reagieren.  Diese Informationen sollten gleichzeitig an den zentralen IS der auf 1C basierenden Holding und an den Computer des Merchandisers in einem bestimmten Geschäft / Outlet gesendet werden. </p><br><p>  Darüber hinaus war es notwendig, eine zentralisierte und betriebliche Neubewertung der Waren über das Netzwerk sicherzustellen und einen Online-Datenstrom von allen Verkaufsstellen an das BI-System der Holding anzuschließen. <br>  Als Ergebnis wurden Kriterien für den Erfolg des Projekts gebildet: </p><br><ul><li>  Schecks, die an der Kasse des Geschäfts ausgestellt wurden, sollten im zentralen 1C-System spätestens 1 Sekunde nach ihrer „Fiskalisierung“ an der Kasse in Gegenwart (Kommunikation) der Kommunikation sichtbar sein. </li><li>  Stellen Sie bei vorübergehenden Kommunikationsfehlern sicher, dass die Schecks nach Wiederherstellung des Kommunikationskanals sofort garantiert an das zentrale System gesendet werden. </li></ul><br><p>  Für das Silver Bullet-Team war dies eine sehr verlockende Sache, da wir zu diesem Zeitpunkt bereits unseren 1C-Adapter für RabbitMQ entwickelt hatten und die Fähigkeit, ihn über große Entfernungen und Lasten in den Kampf zu ziehen, geekige Köpfe anzog.  Das Konzept der „Position des Schecks in der Mitte in 1 Sekunde“ ist nicht so neu. Bereits 2013 haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Idee der Verwendung von Warteschlangen</a> in 1C vorgestellt und sogar in einem Handelsnetzwerk getestet. Zu dieser Zeit waren es jedoch sehr experimentelle Krücken, zu denen neben Rabbit auch gehörten + 1C ist immer noch C #, WCF und sogar ein bisschen C ++. </p><br><p>  Natürlich haben wir es alle in intelligenten Büchern ausspioniert, die noch früher geschrieben wurden.  Daher werde ich es nicht wagen, genau zu beurteilen, wann die Idee von Linien in Integrationsprojekten die Welt eroberte. </p><br><p>  Auf die eine oder andere Weise haben der theoretische Teil und das Architekturkonzept ihre Wirksamkeit bewiesen, nur ein wenig blieb übrig - alles zu tun, zu testen, Fehler zu beheben, zu dokumentieren und bereitzustellen.  : trollface: </p><br><h2 id="nyryaem-s-golovoy">  Tauchen mit dem Kopf </h2><br><p>  Niemand weiß besser als der Geschäftsinhaber über seine Stärken und Schwächen Bescheid. Daher beginnen alle Integrationsprojekte mit einer Prüfung der Prozesse des Kunden und dem Verständnis des Ausgangspunkts (AS IS).  In der Regel umfasst eine Unternehmensumfrage Folgendes: </p><br><ul><li>  Analyse von Informationen darüber, wie Geschäftsprozesse jetzt ablaufen; </li><li>  Sammeln von Anforderungen an das System durch Befragung wichtiger Mitarbeiter, um zu verstehen, wie ihrer Meinung nach Geschäftsprozesse angeordnet werden sollten; </li><li>  Formalisierung und Optimierung von Geschäftsprozessen. </li></ul><br><p>  Um Unstimmigkeiten zu beseitigen, verwenden wir die Formalisierung von AS IS- und TO BE-Geschäftsprozessen in Form von BPMN-Schemata.  Es ist einfacher, es selbst zu verstehen, und es ist für den Kunden einfacher, nichts zu verpassen, wenn wir gemeinsam mit ihm das Prozessdiagramm durchgehen. </p><br><p>  Aus den technischen Merkmalen ergab sich während des Audits, dass: </p><br><ul><li>  Outlets verwenden Windows-basierte Computer - mit heterogenen Betriebssystemen (abhängig vom Erstellungsjahr) von Windows XP bis Windows 7, 8, 10; </li><li>  An den Registrierkassen wird die Frontol-Firmware mit Windows Embedded ausgeführt. </li><li>  Die Einzelhandelsverwaltung verwendet heterogene Software, die sowohl Lösungen von 1C-Anbietern als auch eigene Entwicklungen umfasst. </li><li>  Kommunikationskanäle werden nach dem Prinzip „Was ist das?“ im Bereich von Kabelleitungen bis zu USB-Whistle-Modems implementiert. </li><li>  Einzelhandelsgeschäfte werden von lokalen Outsourcing-Unternehmen und nicht von einem zentralen Holding-Service bedient. </li><li>  Die Funktionsweise des Systems hängt im Wesentlichen von der Wartungsfreundlichkeit (ordnungsgemäße Funktionsweise) des Computers des Warenverwalters an jeder Verkaufsstelle ab. </li></ul><br><p><img src="https://habrastorage.org/webt/cv/hw/xl/cvhwxlmawid2vavdngll1nqs4ca.png" alt="AS-IS-Integrationsschema"></p><br><p>  <em>AS-IS-Integrationsschema</em> </p><br><p>  Die Prüfung ergab auch, dass die Geschäftsprozesse des Unternehmens praktisch nicht angepasst werden müssen, aber eine Verbesserung der Infrastruktur erforderlich ist, um einen unterbrechungsfreien Informationsfluss sicherzustellen. </p><br><p>  Im Allgemeinen standen wir vor der Aufgabe, Dokumente zwischen den drei Komponenten des Prozesses zuverlässig zu liefern: Registrierkasse, Computer-Merchandiser und Zentrale.  Gleichzeitig ist der Computer des Merchandisers eine Maschine „unter dem Tisch“.  Sie kann auf Wunsch des Händlers ein- und ausgeschaltet werden.  Oder sogar 23 von 24 Stunden ausgeschaltet sein.  Beim Verlassen der Abenddämmerung muss der Händler jedoch einen tatsächlichen Satz von Preisen, Salden, Lagerartikeln usw. sehen. </p><br><h2 id="vybor-resheniya-sbor-grabley-i-rasstanovka-kostyley">  Eine Lösung auswählen, einen Rechen einsammeln und Krücken platzieren </h2><br><p>  Die Integration von Warteschlangen ist seit langem ein gängiges Muster.  Wenn Sie etwas mit vielen Links in einer unzuverlässigen Umgebung übertragen und gleichzeitig Datenströme weiterleiten müssen, benötigen Sie Ereignisse und Warteschlangen.  Aus diesem Grund haben wir uns für RabbitMQ entschieden, da es sich problemlos in jede (uns erschienene) Umgebung integrieren lässt, einschließlich der 1C-Plattform, für die wir bereits einen eigenen Adapter für das AMQP-Protokoll hatten. </p><br><p>  RMQ ist eine Art Datenflussmanager und ermöglicht die Integration in den "fast Echtzeit" -Modus, während eine schwache Systemkonnektivität beibehalten wird, Belastungen standgehalten werden usw. Ein guter Server, kurz gesagt, auf Habré wurde viel darüber geschrieben. </p><br><p>  Eine der netten Funktionen ist das Out-of-Box-Clustering und die Möglichkeit, verteilte Servercluster zu erstellen, die zusammenarbeiten. </p><br><p><img src="https://habrastorage.org/webt/3t/4z/ze/3t4zzefa40o467uuhiwepzb4_fs.png" alt="Bild"></p><br><p>  Ich mochte immer die Bilder mit der Architektur der Integration in die Warteschlangen.  Sie bestehen immer aus drei Würfeln, in deren Mitte sich ein Nachrichtenbroker befindet.  Lassen Sie ein solches Bild in diesem Artikel sein, um den Kanon nicht zu verletzen. </p><br><p>  Bei der Erstellung des Schemas stellte sich die Frage, wo sich der Warteschlangenserver befinden sollte.  Unter welchen Bedingungen kann unser System enden?  Wir haben herausgefunden, dass es 5 Notsituationen gibt, in denen die Arbeit nicht aufhören sollte. </p><br><ol><li>  Alle Blöcke sind enthalten. </li><li>  Das Zentrum ist nicht verbunden, es besteht Zugang zu einem Merchandiser. </li><li>  Der Merchandiser ist nicht verbunden, es besteht Zugang zum Center. </li><li>  Behinderte und Merchandiser und Zentrum. </li><li>  1C-System deaktiviert. </li></ol><br><p>  Schecks in all diesen Situationen müssen durchbrechen, der Handel sollte nicht aufhören.  Bei der Wiederherstellung des Kanals müssen Schecks beim Teilnehmer eintreffen.  Ich möchte Sie daran erinnern, dass eine Verkaufsstelle auch ein ländlicher Stand sein kann.  Es ist kein separater Server installiert, auf dem RMQ installiert werden könnte.  Es stellte sich heraus, dass sich der Nachrichtenbroker direkt an der Kasse befinden sollte.  Server sind ein unzulässiger Luxus, und Rabbit ist recht leicht und kann an einem kleinen POS-Terminal arbeiten.  Warum also nicht ja? </p><br><p>  Natürlich haben wir POS nicht zum einzigen Knoten des RMQ-Clusters gemacht, aber wir haben einen der Knoten des Verbundclusters direkt auf dem Handelsterminal platziert und Windows Embedded ausgeführt.  Zu sagen, dass dies etwas einfacher war als zu tun, aber wir haben es fröhlich und rücksichtslos gemacht.  Was ich dir jetzt sage. </p><br><h3 id="kak-postavit-rmq-terminal-frontol">  So setzen Sie das RMQ-Terminal Frontol ein </h3><br><p>  Ich muss sagen, dass Erlang und der RMQ-Server selbst fast ohne Probleme zum Windows-Terminal gelangt sind.  Im Client traten Probleme auf, die über die Registrierkassensoftware mit dem Server interagieren sollten. </p><br><p>  Die Frontol-Registrierkassensoftware verfügt über eine recht gute Dokumentation, aus der hervorgeht, dass es möglich ist, das Verhalten mithilfe von Javascript anzupassen.  "Yuhu!"  - sagten wir und begannen, den JS-Client für RabbitMQ zu googeln.  Es wurde schnell klar, dass ein Mist auf uns wartete.  Auf der Vorderseite nicht ganz Javascript.  Nun, d.h.  Formal, ja, die Syntax ist dort dieselbe, aber der JavaScript-Computer selbst stammt von Windows Script Host, dem gleichen wie VBScript, cscript.exe und mehr.  Kurz gesagt, es ist sehr alt, Microsoft-spezifisch und kein einziger vernünftiger Kaninchen-JS-Client wird daran arbeiten. </p><br><p>  Im WSH-Ökosystem können Sie jedoch COM-Objekte verwenden, und wir gingen zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RMQ-</a> Client <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für .NET</a> . </p><br><p>  Moderne Versionen dieses Clients unterstützen nicht mehr das .NET 3.5, das uns auf dem POS-Terminal zur Verfügung stand. Glücklicherweise sind die Quellen des Clients geöffnet, und außerdem wurden Tags auf dem Github des Projekts gespeichert, in dem .NET 3.5 noch unterstützt wurde.  Ehre sei der Open Source!  Es blieb, den Quellcode der alten Version des .NET-Clients zu entleeren, das Kontrollkästchen Com-Visible dort zu aktivieren und auf dem Terminal bereitzustellen. </p><br><h3 id="vzaimodeystvie-s-kassoy-frontol">  Frontol Checkout-Interaktion </h3><br><p>  Registrierkassensoftware verfügt über eine API, die für die Interaktion verwendet werden kann. </p><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ frontol.addEventListener(<span class="hljs-string"><span class="hljs-string">"openDocument"</span></span>, <span class="hljs-string"><span class="hljs-string">"beforeOpenDocument"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); frontol.addEventListener(<span class="hljs-string"><span class="hljs-string">"closeDocument"</span></span>, <span class="hljs-string"><span class="hljs-string">"beforeCloseDocument"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); frontol.addEventListener(<span class="hljs-string"><span class="hljs-string">"closeDocument"</span></span>, <span class="hljs-string"><span class="hljs-string">"afterCloseDocument"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); frontol.addEventListener(<span class="hljs-string"><span class="hljs-string">"closeSession"</span></span>, <span class="hljs-string"><span class="hljs-string">"beforeCloseSession"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); frontol.addEventListener(<span class="hljs-string"><span class="hljs-string">"closeSession"</span></span>, <span class="hljs-string"><span class="hljs-string">"afterCloseSession"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); addPolyfills(); <span class="hljs-comment"><span class="hljs-comment">//   ) initRmqVariables(); createRMQConnection(); }</span></span></code> </pre> <br><p>  Die Funktionen des nativen JS an Bord von Windows sind äußerst schlecht.  Beispielsweise gibt es kein Array.indexOf oder JSON.stringify.  Aber die Welt ist nicht ohne gute Leute.  Wir erinnerten uns an die beliebte browserbasierte Krücke „Polyphillas“ und bauten sie glücklich in die Kasse ein.  Abgesehen von den Witzen wurden alle Zaubertricks mit JS absichtlich akribisch kommentiert, damit Generationen zukünftiger Administratoren klar und schnell verstehen können, was passiert, woher es kommt und wie es funktioniert. </p><br><p><img src="https://habrastorage.org/webt/dy/r4/wt/dyr4wtajznottdsc0kf4hdxm-vq.png"></p><br><p><img src="https://habrastorage.org/webt/5f/zn/6o/5fzn6okjyzwwcmyaauou07ny818.png"></p><br><p>  Es wurde schnell klar, dass die JS-API einen Teil unserer Fälle nicht abdeckt. Da Frontol jedoch ein Firebird-DBMS enthält und es einen ODBC-Anbieter gibt, können wir Javascript verwenden, um die Datenbank des Kassierers mithilfe von Javascript direkt zu kontaktieren Holen Sie sich die Daten, die wir dort brauchen. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterCloseSession</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connection = getDatabaseConnection(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> qSelect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActiveXObject(<span class="hljs-string"><span class="hljs-string">"ADODB.Command"</span></span>); qSelect.ActiveConnection = connection; qSelect.CommandText = <span class="hljs-string"><span class="hljs-string">"SELECT ChequeNumber "</span></span> + <span class="hljs-string"><span class="hljs-string">"FROM Document "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE "</span></span> + <span class="hljs-string"><span class="hljs-string">" State = 1 "</span></span> + <span class="hljs-string"><span class="hljs-string">" AND(ChequeType IN(0, 1, 2)) "</span></span></code> </pre><br><p>  Und schließlich sieht die direkte Arbeit mit dem Warteschlangenserver von unserem JS so aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRMQConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActiveXObject(<span class="hljs-string"><span class="hljs-string">"RabbitMQ.Client.ConnectionFactory"</span></span>); factory.UserName = rmqUser; factory.Password = rmqPass; factory.VirtualHost = <span class="hljs-string"><span class="hljs-string">"/"</span></span>; factory.HostName = <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { rmqConnection = factory.CreateConnection(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"     .   !\n"</span></span> + e.message); } rmqChannel = rmqConnection.CreateModel(); rmqMessageProperties = rmqChannel.CreateBasicProperties(); rmqMessageProperties.ContentType = <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>; rmqMessageProperties.ContentEncoding = <span class="hljs-string"><span class="hljs-string">"string"</span></span>; rmqMessageProperties.DeliveryMode = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><h2 id="obschaya-kartina-resheniya">  Das Gesamtbild der Lösung </h2><br><p>  In der Architektur wurden folgende Prinzipien festgelegt: </p><br><ul><li>  Federation of RabbitMQ-Server - RMQ - Federation Server-Modus, damit Ereignisse an alle Empfänger übermittelt werden; </li><li>  Überleben der lokalen Kasse - Wenn ein Ereignis an der Kasse eingetreten ist, muss es auf jeden Fall zugestellt werden, auch wenn die Kasse derzeit nicht über das Netzwerk erreichbar ist. </li><li>  2 Datenanbieter - Im normalen Modus werden die Daten über den Server (den Computer des Merchandisers) geliefert. Wenn der Computer des Merchandisers nicht verfügbar ist (infolge eines Unfalls oder aus anderen Gründen), liefert der Kassierer die Lieferung, wenn der Computer des Merchandisers eingeschaltet ist, erhält er seinen Teil der Ereignisse später als im Zentrum garantiert; </li><li>  RMQ - Dienst RabbitMQ-Server mit offenen TCP-Ports für Clustering und Messaging; </li><li>  Um die garantierte Zustellung von Nachrichten zu gewährleisten, wird Datenflussredundanz angewendet.  Dies minimiert die Auswirkungen von Netzwerkverbindungen zwischen Systemknoten. </li><li>  In 1C: Center wurde beschlossen, eine Reihe von RMQ-Servern im HA-Modus zu installieren - hohe Verfügbarkeit des zentralen Servers, inkl.  Es gibt eine doppelte Reservierung und Ereignisreplikation, um die Lieferung zu garantieren. </li></ul><br><p><img src="https://habrastorage.org/webt/st/tp/vs/sttpvss5ldov15shsqsfa_88xao.png"></p><br><p>  In Übereinstimmung mit der Architekturlösung wurde das folgende Datenflussdiagramm erstellt: </p><br><ul><li>  Frontol, 1C - Start- und Endpunkte des Austauschs - Objekte, die Quellen und Empfänger von Nachrichten sind; </li><li>  Verbundwarteschlange - Ein spezieller Warteschlangentyp, mit dem Sie ein verteiltes System zum Senden von Nachrichten erstellen können, in dem die Warteschlange im Knoten am Ausgang (Upstream) veröffentlicht und von der Warteschlange in der Mitte (Downstream) empfangen werden kann.  Für die Übertragung von Nachrichten von Upstream zu Downstream ist auf dem zentralen Warteschlangenserver ein spezielles Plug-In (Federation PlugIn) installiert. </li><li>  Schaufel - (wörtlich "Schaufel") - ein Mechanismus zum Übertragen von Nachrichten von einem Objekt (Warteschlange) zu einem anderen.  Objekte können zu einem oder verschiedenen Servern gehören. </li><li>  Die Systemarchitektur ermöglicht die Remote-Bereitstellungsverwaltung, dh die Möglichkeit, RabbitMQ-Server von einem einzigen Center aus auf jedem Computer im Holding-Netzwerk zu installieren. </li><li>  Die Konfiguration und Verbindung zum Verbund erfolgt über die sogenannten Post-Install-Skripte, die standardmäßig mit der Bereitstellung von RMQ-Servern geliefert werden. Die erforderliche Konfiguration der Netzwerkparameter wird im Netzwerk des Kunden akzeptiert. </li></ul><br><p>  Die resultierende Schaltung liefert die geordneten Geschwindigkeitseigenschaften und arbeitet stabil, wenn eine der Komponenten herausfällt.  Nachdem die Verbindung unterbrochen und wiederhergestellt wurde, gehen die gesammelten Daten innerhalb von 5-10 Sekunden in die Mitte.  In der Praxis hat sich die Technologie lose gekoppelter Systeme bewährt.  Alle Ereignisse finden wie in einem Büro statt, ohne die verschiedenen Arten von Verzögerungen im Zusammenhang mit der territorialen Verteilung und den unterschiedlichen Grad der Verfügbarkeit der damit verbundenen Kommunikationskanäle zu berücksichtigen. </p><br><h2 id="kratkoe-zaklyuchenie">  Kurzer Abschluss </h2><br><p>  Ich möchte separat genießen, in was für einer erstaunlichen Zeit wir leben.  In jüngerer Zeit war die Verwendung von Open Source in einem Produkt eine Art Askese.  "Funktioniert Ihre Open Source-Software?"  Wie gefällt dir dieser Kaktus? “  Dies ist heute eine absolute Maxime. </p><br><p>  Ich kann mir kein Unternehmen vorstellen, das keine Open Source-Produkte im Produkt hat.  Dank der Verfügbarkeit von Informationen und Open Source-Software ist die Umsetzung von Geschäftsideen viel einfacher und schneller geworden.  Müssen Sie RMQ auf altes benutzerdefiniertes Javascript und Windows setzen?  Einfacher geht es nicht.  Eine gegoogelte Lösung ist etwas unangemessen?  - sehen Sie, wie es gemacht wird und fügen Sie die fehlenden hinzu.  Die Markteinführungszeit bei Verwendung offener Produkte wird erheblich verkürzt.  Und jeder weiß, dass eine schnelle Freigabe einer Lösung einen Wettbewerbsvorteil bedeutet. </p><br><p>  Github, Stackoverflow, offene Dokumentation und Standards ermöglichen den Start in wenigen Wochen, was zuvor langjähriges Know-how in verschiedenen Bereichen des Computerwissens erfordert hätte. </p><br><p>  Und natürlich ist es besonders erfreulich, dass die 1C-Spitznamen-Community jedes Jahr ihre geschlossene Welt verlässt und sich in die globale IT einfügt.  Zum Beispiel ist „1C: Enterprise“ heute eine der offiziellen Sprachen, die von Github unterstützt werden, und Leute aus der 1C-Community haben es dieser Sprache „beigebracht“.  Diese Geschichte verdient wahrscheinlich einen separaten Artikel, vielleicht schreibe ich sie eines Tages.  In der Zwischenzeit alles Gute und viel Glück! </p><br><p>  Danke für deine Zeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422151/">https://habr.com/ru/post/de422151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422139/index.html">Mobile Version von Habr. Version 3.0</a></li>
<li><a href="../de422141/index.html">Remote-Bereitstellung und Debugging von Dotnet-Kernanwendungen unter * nix</a></li>
<li><a href="../de422143/index.html">Das Rezept für eine nützliche Codeüberprüfung durch den Entwickler von Yandex</a></li>
<li><a href="../de422147/index.html">Erhöhen Sie Ihren Speedtest-Knoten</a></li>
<li><a href="../de422149/index.html">Wie ist es - Flugbegleiter zu sein</a></li>
<li><a href="../de422155/index.html">Geheime Phrase des Auditors</a></li>
<li><a href="../de422157/index.html">CPE - Zahlungsmodell für den am mobilen Retargeting beteiligten Benutzer</a></li>
<li><a href="../de422161/index.html">Verringern der Konnektivität mithilfe von DI zur Verbesserung der Codetestbarkeit, Implementierungsbeispiel</a></li>
<li><a href="../de422163/index.html">Entwicklung eines 264 to avi Videokonverters für die QCM-08DL Dashcam</a></li>
<li><a href="../de422165/index.html">Welchen Microsoft-Client sollte ich auf Dynamics 365 aktualisieren?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>