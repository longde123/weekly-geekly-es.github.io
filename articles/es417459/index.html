<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèº ü§≥üèº ü•ï Conoce tu JIT: m√°s cerca del auto üë©‚Äç‚ù§Ô∏è‚Äçüë© üî∂ üßùüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antes de que se ejecute el c√≥digo escrito por nosotros, es bastante largo. Andrey Melikhov en su informe sobre RIT ++ 2018 examin√≥ cada paso en este c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conoce tu JIT: m√°s cerca del auto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417459/"> Antes de que se ejecute el c√≥digo escrito por nosotros, es bastante largo.  <strong>Andrey Melikhov</strong> en su informe sobre RIT ++ 2018 examin√≥ cada paso en este camino utilizando el ejemplo del motor V8.  Ac√©rquese al gato para descubrir qu√© nos da una comprensi√≥n profunda de los principios del compilador y c√≥mo hacer que el c√≥digo JavaScript sea m√°s productivo. <br><br><img src="https://habrastorage.org/webt/iy/2r/ke/iy2rkenolmtnchwu_whyurlrw80.jpeg"><br><br>  Descubriremos si WASM es una bala de plata para mejorar el rendimiento del c√≥digo y si las optimizaciones siempre est√°n justificadas. <br><br>  <strong><em>Spoiler:</em></strong> "La optimizaci√≥n prematura es la ra√≠z de todos los males", Donald Knuth. <br><br><img src="https://habrastorage.org/webt/rd/-o/q7/rd-oq7q2m9bjipzyqo1l3jrlqti.jpeg"><br><br>  <strong><em>Sobre el orador:</em></strong> Andrei Melikhov trabaja en Yandex.Money, escribe activamente en Node.js y menos en el navegador, por lo que el servidor JavaScript est√° m√°s cerca de √©l.  Andrew apoya y desarrolla la comunidad devShacht, as√≠ que echa un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Medium</a> . <br><a name="habracut"></a><br><h2>  <strong>Motivaci√≥n y Glosario</strong> </h2><br>  Hoy hablaremos sobre la compilaci√≥n JIT.  Creo que esto es interesante para ti, ya que est√°s leyendo esto.  Sin embargo, aclaremos por qu√© necesita saber qu√© es JIT y c√≥mo funciona V8, y por qu√© escribir React en un navegador no es suficiente. <br><br><ul><li>  Le permite <strong>escribir c√≥digo m√°s eficiente</strong> , porque nuestro idioma es espec√≠fico. </li><li>  <strong>Revela rompecabezas de</strong> por qu√© en las bibliotecas de otras personas el c√≥digo se escribe de esta manera, y no de otra manera.  A veces nos encontramos con viejas bibliotecas y vemos que lo que est√° escrito all√≠ es de alguna manera extra√±o, pero si esto es necesario, no es necesario, no est√° claro.  Cuando sabes c√≥mo funciona, entiendes por qu√© se hizo esto. <br></li><li>  <strong>Esto es simplemente interesante</strong> .  Adem√°s, nos permite entender lo que Axel Rauschmeier, Benedict Moyrer y Dan Abramov comunican en Twitter. <br></li></ul><br><img src="https://habrastorage.org/webt/le/oy/yg/leoyyg4b8ru_n_2djyzkg6hbe1a.jpeg"><br><br>  Wikipedia dice que JavaScript es un lenguaje de programaci√≥n interpretado de alto nivel con escritura din√°mica.  Nos ocuparemos de estos t√©rminos. <br><br>  <strong>Compilaci√≥n e interpretaci√≥n</strong> <br><br>  Compilaci√≥n: cuando el programa se entrega en c√≥digo binario y se optimiza inicialmente para el entorno en el que funcionar√°. <br><br>  Interpretaci√≥n: cuando entregamos el c√≥digo tal como est√°. <br><br>  JavaScript se entrega tal como est√°: es un lenguaje interpretado, tal como est√° escrito en Wikipedia. <br><br>  <strong>Tipificaci√≥n din√°mica y est√°tica</strong> <br><br>  La escritura est√°tica y din√°mica a menudo se confunde con la escritura d√©bil y fuerte.  Por ejemplo, C es un lenguaje con escritura d√©bil est√°tica.  JavaScript tiene una escritura din√°mica d√©bil. <br><br>  Cual es mejor?  Si el programa se compila, est√° orientado hacia el entorno en el que se ejecutar√°, lo que significa que funcionar√° mejor.  La escritura est√°tica hace que este c√≥digo sea m√°s eficiente.  En JavaScript, lo contrario es cierto. <br><br>  Pero al mismo tiempo, nuestra aplicaci√≥n se est√° volviendo m√°s compleja: tanto en el cliente como en el servidor, aparecen grandes grupos en Node.js, que funcionan bien y reemplazan las aplicaciones Java. <br><br>  Pero, ¬øc√≥mo funciona todo si inicialmente parece ser un perdedor? <br><br><blockquote>  ¬°JIT reconciliar√° a todos!  O al menos int√©ntalo. </blockquote><br>  Tenemos un JIT (compilaci√≥n Just In Time) que ocurre en tiempo de ejecuci√≥n.  Hablaremos de ella. <br><br><h3>  <strong>Motores Js</strong> </h3><br><ul><li>  Chakra no amado, que se encuentra en Internet Explorer.  Ni siquiera funciona con JavaScript, pero con Jscript, existe un subconjunto. <br></li><li>  Chakra moderno y ChakraCore que funcionan en Edge; <br></li><li>  SpiderMonkey en FireFox; </li><li>  JavaScriptCore en WebKit.  Tambi√©n se usa en React Native.  Si tiene una aplicaci√≥n RN para Android, tambi√©n se ejecuta en JavaScriptCore: el motor viene incluido con la aplicaci√≥n. <br></li><li>  V8 es mi favorito.  No es el mejor, solo trabajo con Node.js, en el que es el motor principal, como en todos los navegadores basados ‚Äã‚Äãen Chrome. <br></li><li>  Rhino y Nashorn son los motores utilizados en Java.  Con su ayuda, tambi√©n puede ejecutar JavaScript all√≠. <br></li><li>  JerryScript: para dispositivos integrados; <br></li><li>  y otros ... </li></ul><br>  Puede escribir su propio motor, pero si avanza hacia una ejecuci√≥n efectiva, obtendr√° aproximadamente el mismo esquema, que mostrar√© m√°s adelante. <br><br>  Hoy hablaremos sobre el V8, y s√≠, lleva el nombre del motor de 8 cilindros. <br><br><h2>  <strong>Subimos bajo el cap√≥</strong> </h2><br>  ¬øC√≥mo se ejecuta JavaScript? <br><br><ul><li>  Hay un c√≥digo escrito en JavaScript, que se suministra. <br></li><li>  √©l est√° analizando; </li><li>  est√° siendo ejecutado; </li><li>  Se obtiene el resultado. <br></li></ul><br><img src="https://habrastorage.org/webt/wj/n0/us/wjn0ustvepwu4kmulit2v6xxtsy.jpeg"><br><br>  El an√°lisis convierte el c√≥digo en un <strong>√°rbol de sintaxis abstracta</strong> .  AST es una visualizaci√≥n de la estructura sint√°ctica del c√≥digo en forma de √°rbol.  Esto es realmente conveniente para el programa, aunque es dif√≠cil de leer. <br><img src="https://habrastorage.org/webt/3i/1p/y-/3i1py-dcnwj6enma0zveqcv67tq.jpeg"><br><br>  Obtener un elemento de matriz con el √≠ndice 1 en forma de √°rbol se representa como un operador y dos operandos: cargue la propiedad por clave y estas claves. <br><br><h3>  <strong>¬øD√≥nde se usa AST?</strong> </h3><br>  AST no es solo en motores.  Usando AST, muchas utilidades escriben extensiones, incluyendo: <br><br><ul><li>  ESLint; </li><li>  Babel </li><li>  M√°s bonita </li><li>  Jscodeshift. </li></ul><br>  Por ejemplo, lo bueno que Jscodeshift, de lo que no todos saben a√∫n, le permite escribir transformaciones.  Si cambia la API de una funci√≥n, puede establecer estas transformaciones en ella y realizar cambios en todo el proyecto. <br><br><img src="https://habrastorage.org/webt/wl/ct/8e/wlct8ejmclt1hoqiinm9jwbayyg.jpeg"><br><br>  Seguimos adelante.  El procesador no entiende el √°rbol de sintaxis abstracta; necesita <strong>c√≥digo de m√°quina</strong> .  Por lo tanto, se lleva a cabo una mayor transformaci√≥n a trav√©s del int√©rprete, porque el lenguaje se interpreta. <br><img src="https://habrastorage.org/webt/i6/cj/zh/i6cjzhohklmcdyenrvrjmdw6fyk.jpeg"><br><br>  As√≠ fue, mientras que los navegadores ten√≠an un poco de JavaScript: resalta la l√≠nea, abre algo, cierra.  Pero ahora tenemos aplicaciones: SPA, Node.js, y el <strong>int√©rprete se est√° convirtiendo en un cuello de botella</strong> . <br><br><h2>  <strong>Optimizando el compilador JIT</strong> </h2><br>  En lugar de un int√©rprete, aparece un compilador JIT optimizador, es decir, un compilador Just-in-time.  Los compiladores anticipados funcionan antes de la ejecuci√≥n de la aplicaci√≥n y JIT, durante.  En el tema de la optimizaci√≥n, el compilador JIT intenta adivinar c√≥mo se ejecutar√° el c√≥digo, qu√© tipos se utilizar√°n y optimizar el c√≥digo para que funcione mejor. <br><br>  Dicha optimizaci√≥n se llama <strong>especulativa</strong> , porque especula sobre el conocimiento de lo que sucedi√≥ con el c√≥digo antes.  Es decir, si algo con el tipo de n√∫mero se llam√≥ 10 veces, el compilador piensa que esto suceder√° todo el tiempo y se optimiza para este tipo. <br><br>  Naturalmente, si Boolean entra en la entrada, se produce la desoptimizaci√≥n.  Considere una funci√≥n que agrega n√∫meros. <br><br> <code>const foo=(a, b) =&gt; a + b; <br> foo (1, 2); <br> foo (2, 3);</code> <br> <br>  Doblado una vez, la segunda vez.  El compilador construye la predicci√≥n: "¬°Son n√∫meros, tengo una soluci√≥n genial para sumar n√∫meros!"  Y escribe <code>foo('WTF', 'JS')</code> y pasa las l√≠neas a la funci√≥n: tenemos JavaScript, podemos agregar una l√≠nea con un n√∫mero. <br><br>  En este punto, se produce la desoptimizaci√≥n. <br><br><img src="https://habrastorage.org/webt/h4/bf/d-/h4bfd-9twvmsqlk-euvv34he48u.jpeg"><br><br>  Entonces, el int√©rprete fue reemplazado por el compilador.  El diagrama de arriba parece tener una tuber√≠a muy simple.  En realidad, todo es un poco diferente. <br><br><img src="https://habrastorage.org/webt/zp/ma/oo/zpmaoosvxia3btjyxstyyaq5nnc.jpeg"><br><br>  Eso fue hasta el a√±o pasado.  El a√±o pasado, se pod√≠an escuchar muchos informes de Google de que lanzaron una nueva tuber√≠a con TurboFan y ahora el esquema parece m√°s simple. <br><br><img src="https://habrastorage.org/webt/qz/wo/2x/qzwo2xg_2ju3fafi6hb4y8ssm24.jpeg"><br><br>  Curiosamente, un int√©rprete apareci√≥ aqu√≠. <br><br><img src="https://habrastorage.org/webt/w5/tu/u4/w5tuu4i3irrzbsck7e2ohdnzgai.jpeg"><br><br>  Se necesita un int√©rprete para convertir un √°rbol de sintaxis abstracta en un bytecode y pasar el bytecode a un compilador.  En el caso de desoptimizaci√≥n, vuelve a acudir al int√©rprete. <br><br><h2>  <strong>Encendido de int√©rprete</strong> </h2><br>  Anteriormente, no hab√≠a un esquema de int√©rprete de encendido.  Google dijo inicialmente que no se necesita un int√©rprete (JavaScript ya es lo suficientemente compacto e interpretable), no ganaremos nada. <br><br>  Pero el equipo que trabaj√≥ con aplicaciones m√≥viles se encontr√≥ con el siguiente problema. <br><br><img src="https://habrastorage.org/webt/7e/ms/yd/7emsydqevnntiujqhsa_rtrvdec.jpeg"><br><br>  En 2013-2014, las personas comenzaron a usar dispositivos m√≥viles para acceder a Internet con m√°s frecuencia que el escritorio.  B√°sicamente, este no es un iPhone, sino de dispositivos m√°s simples: tienen poca memoria y un procesador d√©bil. <br><br><img src="https://habrastorage.org/webt/8b/0l/zi/8b0lzi2wb8mqqbsetc88t2lsale.jpeg"><br><br>  Arriba hay un gr√°fico del an√°lisis inicial de 1 MB de c√≥digo antes de iniciar el int√©rprete.  Se puede ver que el escritorio gana mucho.  El iPhone tampoco est√° mal, pero tiene un motor diferente, y estamos hablando de V8, que funciona en Chrome. <br><br><blockquote>  ¬øSab√≠a que si instala Chrome en el iPhone, seguir√° funcionando en JavaScriptCore? </blockquote><br>  Por lo tanto, se pierde tiempo, y esto es solo an√°lisis, no ejecuci√≥n, su archivo se ha cargado y est√° tratando de entender lo que est√° escrito en √©l. <br><img src="https://habrastorage.org/webt/kx/kv/l5/kxkvl5nr4j2cxe5d6kuhwegffnk.jpeg"><br><br>  Cuando se produce la desoptimizaci√≥n, debe volver a tomar el c√≥digo fuente, es decir.  necesita ser almacenado en alguna parte.  Tom√≥ mucha memoria. <br><br>  Por lo tanto, el int√©rprete ten√≠a dos tareas: <br><br><ol><li>  reducir el an√°lisis por encima de la cabeza; <br></li><li>  Reduce el consumo de memoria. <br></li></ol><br>  Las tareas se resolvieron cambiando a un int√©rprete de c√≥digo de bytes. <br><img src="https://habrastorage.org/webt/yr/ky/sk/yrkyskmi_annr0w3jnps13y5alc.jpeg"><br><br>  <strong>Bytecode en Chrome es una m√°quina de registro con una bater√≠a</strong> .  SpiderMonkey tiene una m√°quina apilada, all√≠ todos los datos est√°n en la pila, pero no hay registros.  Aqu√≠ est√°n <br><br>  No analizaremos completamente c√≥mo funciona esto, solo mira el fragmento de c√≥digo. <br><br><img src="https://habrastorage.org/webt/vu/is/fh/vuisfhp0lin_et7pozzqny-g6q0.jpeg"><br><br>  Aqu√≠ dice: tome el valor que se encuentra en la bater√≠a y agr√©guelo al valor que se encuentra en el registro <strong>a0</strong> , es decir, en la variable <strong>a</strong> .  Todav√≠a no se sabe nada sobre los tipos aqu√≠.  Si se tratara de un c√≥digo de ensamblador real, se escribir√≠a con un entendimiento de qu√© tipo de cambios hay en la memoria, qu√© hay en √©l.  Aqu√≠ hay solo una instrucci√≥n: tome lo que se encuentra en el registro <strong>a0</strong> y agr√©guelo al valor que se encuentra en la bater√≠a. <br><br>  Por supuesto, el int√©rprete no solo toma el √°rbol de sintaxis abstracta y lo traduce a bytecode. <br><img src="https://habrastorage.org/webt/vv/4g/i6/vv4gi6zw_zrtlsgl5lsb7ebqqza.jpeg"><br><br>  Tambi√©n hay optimizaciones, por ejemplo, eliminaci√≥n de c√≥digo muerto. <br>  Si no se llama a una secci√≥n de c√≥digo, se descarta y no se almacena m√°s.  Si Ignition ve la suma de dos n√∫meros, los suma y los deja de tal manera que no almacenen informaci√≥n innecesaria.  Solo despu√©s de esto se obtiene el bytecode. <br><br><h2>  <strong>Optimizaci√≥n y desoptimizaci√≥n.</strong> </h2><br><h3>  Caracter√≠sticas fr√≠as y calientes </h3><br>  Este es el tema m√°s f√°cil. <br><br>  Las funciones en fr√≠o son las que se llamaron una vez o no se llamaron en absoluto, las funciones en caliente son las que se llamaron varias veces.  Es imposible decir exactamente cu√°ntas veces, en cualquier momento, esto puede rehacerse.  Pero en alg√∫n momento, la funci√≥n se calienta y el motor comprende que debe optimizarse. <br><br><img src="https://habrastorage.org/webt/mk/1t/vr/mk1tvrgq5h2l7mp72g4p6vg6wlm.jpeg"><br><br>  El esquema de trabajo. <br><br><ul><li>  Ignition (int√©rprete) recopila informaci√≥n.  No solo convierte JavaScript en bytecode, sino que tambi√©n comprende qu√© tipos entraron, qu√© funciones se pusieron de moda, y le cuenta al compilador sobre todo esto. </li><li>  Hay una optimizaci√≥n. </li><li>  El compilador ejecuta el c√≥digo.  Todo funciona bien, pero aqu√≠ llega un tipo que no esperaba, no tiene c√≥digo para trabajar con este tipo. </li><li>  Se produce desoptimizaci√≥n.  El compilador accede al int√©rprete de encendido para este c√≥digo. </li></ul><br>  Este es un ciclo normal que ocurre todo el tiempo, pero no es infinito.  En alg√∫n momento, el motor dice: "No, es imposible de optimizar" y comienza a ejecutarse sin optimizaci√≥n.  Es importante entender que se debe observar el monomorfismo. <br><br>  <strong>El monomorfismo</strong> es cuando los mismos tipos siempre llegan a la entrada de su funci√≥n.  Es decir, si obtiene cadena todo el tiempo, entonces no necesita pasar booleano all√≠. <br><br>  ¬øPero qu√© hacer con los objetos?  Los objetos son todos objeto.  Tenemos clases, pero no son reales, es solo az√∫car sobre el modelo prototipo.  Pero dentro del motor hay las llamadas clases ocultas. <br><br><h3>  Clases ocultas </h3><br>  Hay clases ocultas en todos los motores, no solo en V8.  En todas partes se les llama de manera diferente, en t√©rminos de V8 es Mapa. <br><br>  Todos los objetos que ha creado tienen clases ocultas.  Si tu <br>  mire el generador de perfiles de memoria, ver√° que hay elementos donde se almacena la lista de elementos, propiedades donde se almacena la propiedad y mapa (generalmente el primer par√°metro), donde se indica un enlace a √©l en su clase oculta. <br><br>  Map describe la estructura de los objetos, porque en principio, en JavaScript, la escritura es posible solo estructural, no nominal.  Podemos describir c√≥mo se ve nuestro objeto, para qu√© sirve. <br><br>  Al eliminar / agregar propiedades de objetos de clases ocultas, el objeto cambia y se asigna uno nuevo.  Miremos el c√≥digo. <br><img src="https://habrastorage.org/webt/4i/ia/bs/4iiabsuemjg-7nu0yiywvlsd9hc.jpeg"><br><br>  Tenemos un constructor que crea un nuevo objeto de tipo Point. <br><br><ul><li>  Crea un objeto. </li><li>  Asociarle una clase oculta, que dice que es un objeto de tipo Punto. </li><li>  Agregamos el campo x, una nueva clase oculta que dice que es un objeto de tipo Point, en el que el valor x es lo primero. </li><li>  Se agreg√≥ y: las nuevas clases ocultas, en las que x y luego y. </li><li>  Cre√≥ otro objeto, sucede lo mismo.  Es decir, tambi√©n une lo que ya se ha creado.  En este momento, estos dos objetos son del mismo tipo (a trav√©s de clases ocultas). </li><li>  Cuando se agrega un nuevo campo al segundo objeto, aparecen nuevas clases ocultas en el objeto.  Ahora para el motor p1 y p2, estos son objetos de diferentes clases, porque tienen estructuras diferentes </li><li>  Si transfiere el primer objeto a alg√∫n lugar, cuando transfiera el segundo all√≠, se producir√° una desoptimizaci√≥n.  La primera se refiere a una clase oculta, la segunda a otra. </li></ul><br>  <strong>¬øC√≥mo puedo verificar las clases ocultas?</strong> <br><br>  En Node.js, puede ejecutar el nodo ‚Äîallow-natives-syntax.  Entonces tendr√° la oportunidad de escribir comandos en una sintaxis especial, que, por supuesto, no se puede usar en producci√≥n.  Se ve as√≠: <br><br><pre> <code class="javascript hljs">%HaveSameMap({<span class="hljs-string"><span class="hljs-string">'a'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  Nadie garantiza que ma√±ana estos comandos funcionar√°n, no est√°n en la especificaci√≥n ECMAScript, eso es todo para la depuraci√≥n. <br><br>  ¬øCu√°l cree que ser√° el resultado de llamar a la funci√≥n% HaveSameMap para dos objetos?  La respuesta correcta es falsa, porque una tiene un campo y la otra tiene <strong>b</strong> .  Estos son diferentes objetos.  Este conocimiento se puede utilizar para la t√©cnica de cach√©s en l√≠nea. <br><br><h3>  Cach√©s en l√≠nea </h3><br>  Llamamos a una funci√≥n muy simple que devuelve un campo de un objeto.  Devolver la unidad parece ser muy simple.  Pero si observa la especificaci√≥n ECMAScript, ver√° que hay una gran lista de lo que debe hacer para obtener el campo del objeto.  Porque, si el campo no est√° en el objeto, es posible que est√© en su prototipo.  Tal vez sea setter, getter, etc.  Todo esto necesita ser verificado. <br><img src="https://habrastorage.org/webt/02/dn/nj/02dnnjtvkqa7fn87e8ioa3kwgpy.jpeg"><br><br>  En este caso, el objeto tiene un enlace al mapa, que dice: para obtener el campo <strong>x</strong> , necesita hacer un desplazamiento por uno, y obtenemos <strong>x</strong> .  No tienes que subir a ning√∫n lado, en ning√∫n prototipo, todo est√° cerca.  Los cach√©s en l√≠nea usan esto. <br><br><img src="https://habrastorage.org/webt/ck/53/ny/ck53nyrhuj7ihixe7vi7ds_vjvc.jpeg"><br><br><ul><li>  Si llamamos a la funci√≥n por primera vez, todo est√° bien, el int√©rprete ha realizado la optimizaci√≥n </li><li>  Para la segunda llamada, se guarda un estado monom√≥rfico. </li><li>  Llamo a la funci√≥n por tercera vez, paso un objeto ligeramente diferente {x: 3, y: 1}.  La desoptimizaci√≥n ocurre, si aparece, entramos en un estado polim√≥rfico.  Ahora el c√≥digo que ejecuta esta funci√≥n sabe que dos tipos diferentes de objetos pueden volar hacia √©l. </li><li>  Si pasamos diferentes objetos varias veces, permanece en un estado polim√≥rfico, agregando nuevos ifs.  Pero en alg√∫n momento se rinde y entra en un estado megam√≥rfico, es decir  cuando: "Llegan demasiados tipos diferentes a la entrada, ¬°no s√© c√≥mo optimizarlo!" </li></ul><br>  Parece que ahora se permiten 4 estados polim√≥rficos, pero ma√±ana puede haber 8. Esto lo deciden los desarrolladores del motor.  Ser√° mejor que nos quedemos en un estado monom√≥rfico, en casos extremos, polim√≥rficos.  La transici√≥n entre los estados monom√≥rficos y polim√≥rficos es costosa, ya que tendr√° que ir al int√©rprete, obtener el c√≥digo nuevamente y optimizarlo nuevamente. <br><br><h3>  Matrices </h3><br>  En JavaScript, aparte de las matrices tipificadas espec√≠ficas, hay un tipo <br>  matriz.  Hay 6 de ellos en el motor V8: <br><br>  1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS: solo una matriz empaquetada de n√∫meros enteros peque√±os.  Hay optimizaciones para √©l. <br><br>  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS: una matriz llena de elementos dobles, tambi√©n hay optimizaciones para ella, pero m√°s lentas. <br><br>  3. [1, 2, 3, 4, 'X'] // PACKED_ELEMENTS: una matriz empaquetada en la que hay objetos, cadenas y todo lo dem√°s.  Para √©l, tambi√©n, hay optimizaciones. <br><br>  Los siguientes tres tipos son matrices del mismo tipo que los primeros tres, pero con agujeros: <br><br>  4. [1, / * hoyo * /, 2, / * hoyo * /, 3, 4] // HOLEY_SMI_ELEMENTS <br><br>  5. [1.2, / * hoyo * /, 2, / * hoyo * /, 3,4] // HOLEY_DOUBLE_ELEMENTS <br><br>  6. [1, / * hoyo * /, 'X'] // HOLEY_ELEMENTS <br><br>  Cuando aparecen agujeros en sus matrices, las optimizaciones se vuelven menos eficientes.  Comienzan a funcionar mal, porque es imposible pasar por esta matriz en una fila, ordenando las iteraciones.  Cada tipo posterior est√° menos optimizado <br><br><img src="https://habrastorage.org/webt/qb/rw/zf/qbrwzflusrdjbboqwgsth1ezozu.jpeg"><br><br>  En el diagrama, todo lo anterior est√° optimizado m√°s r√°pido.  Es decir, todos sus m√©todos nativos (mapear, reducir, ordenar) est√°n bien optimizados.  Pero con cada tipo, la optimizaci√≥n empeora. <br><br>  Por ejemplo, una matriz simple [ <strong>1</strong> , <strong>2</strong> , <strong>3</strong> ] lleg√≥ a la entrada (entero peque√±o lleno de tipos).  Cambiamos ligeramente esta matriz al agregarle un doble: pasamos al estado PACKED_DOUBLE_ELEMENTS.  Agregue un objeto: vaya al siguiente estado, el rect√°ngulo verde PACKED_ELEMENTS.  Agregue agujeros: vaya al estado HOLEY_ELEMENTS.  Queremos restaurarlo a su estado anterior para que se vuelva "bueno" nuevamente: eliminamos todo lo que escribimos y permanecemos en el mismo estado ... ¬°con agujeros!  Es decir, HOLEY_ELEMENTS en la esquina inferior derecha del diagrama.  Atr√°s esto no funciona.  Sus matrices solo pueden empeorar, pero no al rev√©s. <br><br><h2>  <strong>Objeto tipo matriz</strong> </h2><br>  A menudo nos encontramos con objetos tipo matriz: son objetos que parecen matrices porque tienen un signo de longitud.  De hecho, son como un gato pirata, es decir, parecen ser similares, pero en la eficiencia del consumo de ron, un gato ser√° peor que un pirata.  Del mismo modo, un objeto tipo matriz es como una matriz, pero no es eficiente. <br><img src="https://habrastorage.org/webt/uf/f4/u_/uff4u_bbjb3elwmhhor3lv2tiwm.jpeg"><br><br>  Nuestros dos objetos favoritos de tipo matriz son argumentos y document.querySelectorAII.  Hay cosas tan hermosas y funcionales. <br><img src="https://habrastorage.org/webt/i7/_j/ul/i7_juluulfkpnerhxwnif4tjnoa.jpeg"><br><br>  Tenemos un mapa, lo sacamos del prototipo y aparentemente podemos usarlo.  Pero si no lleg√≥ una matriz a su entrada, no habr√° optimizaci√≥n.  Nuestro motor no puede hacer optimizaci√≥n en objetos. <br><br>  ¬øQu√© hay que hacer? <br><br><ul><li>  La opci√≥n de la vieja escuela: a trav√©s de slice.call () se convierte en una matriz real. </li><li>  La opci√≥n moderna es a√∫n mejor: escribir (... descansar), obtener una matriz limpia, no argumentos, ¬°todo est√° bien! </li></ul><br>  Con querySelectorAll lo mismo: debido a la propagaci√≥n, podemos convertirlo en una matriz completa y trabajar con todas las optimizaciones. <br><br><h2>  <strong>Grandes matrices</strong> </h2><br><blockquote>  <strong>Riddle:</strong> nueva matriz (1000) vs matriz = [] <br>  ¬øQu√© opci√≥n es mejor: crear inmediatamente una gran matriz y llenarla con 1000 objetos en un bucle, o crear una vac√≠a y llenarla gradualmente? <br></blockquote><br>  <strong>Respuesta correcta:</strong> depende de. <br><br>  Cual es la diferencia <br><br><ul><li>  Cuando creamos una matriz de la primera manera y llenamos 1000 elementos, creamos 1000 agujeros.  Esta matriz no se optimizar√°.  Pero √©l escribir√° r√°pidamente. <br></li><li>  Al crear una matriz de acuerdo con la segunda variante, se asigna un poco de memoria, escribimos, por ejemplo, 60 elementos, se asigna un poco m√°s de memoria, etc. </li></ul><br>  Es decir, en el primer caso escribimos r√°pidamente: trabajamos lentamente;  en el segundo escribimos lentamente, trabajamos r√°pido. <br><br><h2>  <strong>Recolector de basura</strong> </h2><br>  El recolector de basura tambi√©n consume un poco de tiempo y recursos.  Sin sumergirme profundamente, dar√© la base m√°s com√∫n. <br><br><img src="https://habrastorage.org/webt/fg/8e/1c/fg8e1csx9x1mo4y2hlvuzzjvgem.jpeg"><br><br>  Nuestro modelo generativo tiene un <strong>espacio de objetos j√≥venes y viejos</strong> .  El objeto creado cae en el espacio de los objetos j√≥venes.  Despu√©s de un tiempo, comienza la limpieza.  Si no se puede alcanzar el objeto mediante enlaces desde la ra√≠z, se puede recolectar en la basura.  Si el objeto todav√≠a est√° en uso, se mueve al espacio de los objetos antiguos, que se limpia con menos frecuencia.  Sin embargo, en alg√∫n momento, los objetos antiguos se eliminan. <br><img src="https://habrastorage.org/webt/ac/rd/1l/acrd1lqmylajg5b3crff97j-9h8.jpeg"><br><br>  As√≠ es como funciona un recolector de basura autom√°tico: limpia los objetos sobre la base de que no hay enlaces a ellos.  Estos son dos algoritmos diferentes. <br><br><ol><li>  <strong>Scavenge</strong> es r√°pido pero no efectivo. <br></li><li>  <strong>Mark-Sweep</strong> es lento pero eficiente. <br></li></ol><br>  Si comienza a perfilar el consumo de memoria en Node.js, obtendr√° algo como esto. <br><br><img src="https://habrastorage.org/webt/yp/uj/1b/ypuj1bus74-w473vsmczkvgwi0s.jpeg"><br><br>  Al principio, crece abruptamente: este es el trabajo del algoritmo Scavenge.  Luego se produce una fuerte ca√≠da: este algoritmo Mark-Sweep ha recolectado basura en el espacio de los objetos antiguos.  En este momento, todo comienza a disminuir un poco.  <strong>No puede controlarlo</strong> , porque no sabe cu√°ndo suceder√°.  Solo puedes ajustar los tama√±os. <br><br>  Por lo tanto, la tuber√≠a tiene una etapa de recolecci√≥n de basura que consume tiempo. <br><br><img src="https://habrastorage.org/webt/zi/_3/ya/zi_3yao0kydtrtagdizs4oklcr0.jpeg"><br><br><h2>  <strong>¬øIncluso m√°s r√°pido?</strong> </h2><br>  Miremos hacia el futuro.  ¬øQu√© hacer a continuaci√≥n, c√≥mo ser m√°s r√°pido? <br><img src="https://habrastorage.org/webt/ts/vc/fz/tsvcfzihzzewt_udo-39cjqea8c.jpeg"><br><br>  En esta l√≠nea, los tama√±os de bloque est√°n m√°s o menos relacionados en el tiempo que lleva. <br><br>  Lo primero que les viene a la mente a las personas que han escuchado sobre el bytecode (enviar inmediatamente un bytecode a la entrada y decodificarlo, en lugar de analizarlo) ser√° m√°s r√°pido. <br><br><img src="https://habrastorage.org/webt/7i/lf/xd/7ilfxdfdm0dbkdknw0ecpushflo.jpeg"><br><br>  El problema es que el c√≥digo de bytes es diferente ahora.  Como dije: en Safari uno, en FireFox otro, en Chrome tercero.  Sin embargo, los desarrolladores de Mozilla, Bloomberg y Facebook han presentado una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propuesta de este tipo</a> , pero este es el futuro. <br><br>  Hay otro problema: compilaci√≥n, optimizaci√≥n y reoptimizaci√≥n, si el compilador no lo adivin√≥.  Imagine que hay un lenguaje est√°ticamente tipado en la entrada que produce un c√≥digo efectivo, lo que significa que ya no es necesario volver a optimizarlo, porque lo que obtuvimos ya es eficiente.  Dicha entrada solo se puede compilar y optimizar una vez.  El c√≥digo resultante ser√° m√°s eficiente y se ejecutar√° m√°s r√°pido. <br><br>  ¬øQu√© m√°s se puede hacer?  Imagine que este lenguaje tiene administraci√≥n de memoria manual.  Entonces no necesita un recolector de basura.  La l√≠nea se ha vuelto m√°s corta y m√°s r√°pida. <br><br><img src="https://habrastorage.org/webt/e0/36/ut/e036utlk16ybet20xbica5qziey.jpeg"><br><br>  ¬øAdivina c√≥mo se ve?  <strong>WebAssembly</strong> aproximadamente <br>  as√≠ es como funciona: gesti√≥n manual de memoria, tipada est√°ticamente <br>  idiomas y ejecuci√≥n r√°pida. <br><img src="https://habrastorage.org/webt/qf/cd/8h/qfcd8hamo_iv_fznbksf35whw9q.jpeg"><br><br>  ¬øEs WebAssembly una bala de plata? <br><img src="https://habrastorage.org/webt/ke/ip/pd/keippdq9hmpt3ueb7-kgd-zt1ig.jpeg"><br><br>  No, porque significa JavaScript.  WASM no puede hacer nada todav√≠a.  √âl no tiene acceso a la API DOM.  Est√° dentro del motor de JavaScript, ¬°dentro del mismo motor!  Hace todo a trav√©s de JavaScript, por lo que <strong>WASM no acelerar√° su c√≥digo</strong> .  Puede acelerar los c√°lculos individuales, pero su intercambio entre JavaScript y WASM ser√° un cuello de botella. <br><br>  Por lo tanto, mientras nuestro lenguaje es JavaScript y solo √©l, y algo de ayuda del cuadro negro. <br><br><h2>  <strong>Total</strong> </h2><br>  Se pueden distinguir tres tipos de optimizaci√≥n. <br><br>  ‚óè <strong>optimizaciones algor√≠tmicas</strong> <br><br>  Hay un art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quiz√°s no necesites Rust para acelerar tu JS</a> " de Vyacheslav Egorov, quien una vez desarroll√≥ V8 y ahora est√° desarrollando Dart.  Repetir brevemente su historia. <br><br>  Hab√≠a una biblioteca de JavaScript que no funcionaba muy r√°pido.  Algunos chicos lo volvieron a escribir en Rust, compilaron y obtuvieron WebAssembly, y la aplicaci√≥n comenz√≥ a funcionar m√°s r√°pido.  Vyacheslav Egorov, como desarrollador experimentado de JS, decidi√≥ responderlas.  Aplic√≥ optimizaciones algor√≠tmicas, y la soluci√≥n de JavaScript se volvi√≥ mucho m√°s r√°pida que la soluci√≥n de Rust.  A su vez, esos tipos vieron esto, hicieron las mismas optimizaciones y ganaron nuevamente, pero no mucho, depende del motor: en Mozilla ganaron, en Chrome no. <br><br>  Hoy no hablamos de optimizaciones algor√≠tmicas, y los renderizados front-end generalmente no hablan de ellas.  Esto es muy malo, porque los <strong>algoritmos tambi√©n permiten que el c√≥digo se ejecute m√°s r√°pido</strong> .  Simplemente eliminas los ciclos que no necesitas. <br><br>  ‚óè <strong>optimizaciones espec√≠ficas del idioma</strong> <br><br>  De esto es de lo que hablamos hoy: nuestro lenguaje se interpreta de forma din√°mica.  Comprender c√≥mo funcionan las matrices, los objetos y el monomorfismo le <strong>permite escribir c√≥digo eficiente</strong> .  Esto debe ser conocido y escrito correctamente. <br><br>  ‚óè <strong>Optimizaciones espec√≠ficas del motor.</strong> <br><br>  Estas son las optimizaciones m√°s peligrosas.  Si es un desarrollador muy inteligente, pero no muy sociable, que aplic√≥ muchas de esas optimizaciones y no le cont√≥ a nadie sobre ellas, no escribi√≥ documentaci√≥n, entonces si abre el c√≥digo, no ver√° JavaScript, sino, por ejemplo, Crankshaft Script.  Es decir, JavaScript escrito con una profunda comprensi√≥n de c√≥mo funcionaba el motor del cig√ºe√±al hace dos a√±os.  Todo funciona, pero ahora ya no es necesario. <br><br>  Por lo tanto, tales optimizaciones deben necesariamente documentarse, cubrirse con pruebas que demuestren su efectividad en este momento.  Deben ser monitoreados.  Necesitas ir a ellos solo en el momento en que realmente desaceleraste en alg√∫n lugar, simplemente no puedes prescindir de conocimiento de dispositivos tan profundos.  Por lo tanto, la famosa frase de Donald Knuth parece l√≥gica. <br><img src="https://habrastorage.org/webt/yx/xo/1u/yxxo1uda9lkq9fim_uy9zzylxlw.jpeg"><br><br>  No es necesario intentar implementar ning√∫n tipo de optimizaciones dif√≠ciles solo porque lees cr√≠ticas positivas sobre ellas. <br><br>  Uno debe tener miedo de tales optimizaciones, aseg√∫rese de documentar y dejar m√©tricas.  En general siempre se recopilan m√©tricas.  <strong>¬°Las m√©tricas son importantes!</strong> <br><br>  <strong>Enlaces utiles:</strong> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Res√∫menes y presentaci√≥n del informe.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© pasa con el monomorfismo?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© hace que WebAssembly sea r√°pido?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La forma de entender el bytecode V8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Devshacht: Hardcore</a> </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Frontend Conf Moscow</a> <strong>4  5 </strong>               . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> <strong> 15 </strong> ,  ,     : <br><br><ul><li> <strong> </strong> (KeepSolid)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,    Offline First    Persistent Storage </li><li> <strong> </strong> (TradingView)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>    WebGL  WebAssembly  ,        ,  <strong>  API</strong> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> <strong> </strong>  ,          Google Docs. <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417459/">https://habr.com/ru/post/es417459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417447/index.html">Expedici√≥n a los misteriosos c√≠rculos de hadas en el desierto de Namib</a></li>
<li><a href="../es417449/index.html">Mundo Jur√°sico: ¬øPodemos realmente resucitar dinosaurios?</a></li>
<li><a href="../es417451/index.html">Cinco errores comunes para principiantes</a></li>
<li><a href="../es417453/index.html">Organizaci√≥n de pasant√≠as para estudiantes: rastrillo y trucos.</a></li>
<li><a href="../es417457/index.html">Frontend Conf Moscow: entrada y salida del lado del cliente</a></li>
<li><a href="../es417461/index.html">Ivan Tulup: as√≠ncrono en JS bajo el cap√≥</a></li>
<li><a href="../es417463/index.html">Una reuni√≥n inesperada. Cap√≠tulo 17</a></li>
<li><a href="../es417465/index.html">Una descripci√≥n general de los m√©todos de enlace de texto</a></li>
<li><a href="../es417469/index.html">Cinco razones ego√≠stas para trabajar de forma reproducible</a></li>
<li><a href="../es417471/index.html">Soldadura simple MK936 SMD. Estaci√≥n de soldadura DIY para componentes SMD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>