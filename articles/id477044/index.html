<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚖️ 👌🏾 🙆🏻 Otomatisasi Pengujian Akhir-2-End dari sistem informasi terintegrasi. Bagian 2. Teknis 🐽 🈚️ 🈶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan artikel ini, kami melanjutkan serangkaian publikasi tentang bagaimana kami mengotomatisasi di salah satu proyek LANIT utama proses otomatis pen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomatisasi Pengujian Akhir-2-End dari sistem informasi terintegrasi. Bagian 2. Teknis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/477044/">  Dengan artikel ini, kami melanjutkan serangkaian publikasi tentang bagaimana kami mengotomatisasi di salah satu proyek LANIT utama proses otomatis pengujian manual (selanjutnya disebut sebagai autotests) dari sistem informasi besar (selanjutnya disebut sebagai Sistem) dan apa yang datang darinya. <br><br>  Bagian kedua dari publikasi ini terutama difokuskan pada para pemimpin kelompok otomasi pengujian end-2-end UI dan otomatisasi pengujian terkemuka.  Di sini mereka akan menemukan resep khusus untuk organisasi arsitektural kode dan penyebaran, yang mendukung pengembangan paralel-massal kelompok besar pengujian dalam menghadapi variabilitas spesifikasi pengujian yang konstan.  Bagian ini berisi daftar lengkap fungsi yang diperlukan untuk pengujian UI dengan beberapa detail implementasi, serta daftar kejutan yang mungkin Anda temui. <br><br>  <i>Di sini Anda akan menemukan <a href="https://habr.com/ru/company/lanit/blog/473426/"><b>Bagian 1. (Mengapa kita perlu otomatisasi. Organisasi pengembangan dan proses manajemen. Organisasi penggunaan)</b></a></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e47/985/776/e4798577680ae78fcb67f4c6c8976800.jpg"></div>  <i><a href="https://www.dreamstime.com/">Sumber</a></i> <br><a name="habracut"></a><br><h1>  Stack Arsitektur dan Teknologi </h1><br><h3>  Struktur umum sistem dan lingkungannya - Desain Tingkat Tinggi </h3><br>  Teknologi dan perpustakaan utama yang digunakan dalam proyek: <br><br><ul><li>  JavaSE8 &amp; maven &amp; JUnit - tumpukan pengembangan; </li><li>  <a href="https://www.seleniumhq.org/">Selenium</a> - perpustakaan untuk mengotomatiskan tindakan browser web; </li><li>  <a href="https://ru.selenide.org/">Selenide</a> - add-on untuk Selenium, yang memiliki API elegan yang sangat menyederhanakan interaksi dengan elemen browser dan halaman; </li><li>  <a href="https://aerokube.com/selenoid/latest/">Selenoid &amp; GGR</a> - implementasi Selenium Grid dan penyeimbang beban untuk menjalankan pengujian pada server CI + wadah yang telah dikonfigurasi sebelumnya dengan browser; </li><li>  <a href="http://allure.qatools.ru/">Yandex Allure</a> - untuk laporan di server CI. </li></ul><br>  Diagram umum dari komponen autotests dan infrastruktur Selenoid ditunjukkan pada diagram di bawah ini, termasuk komentar penjelasan: <br><br>  <b>Kerangka kerja protes otomatis</b> <br>  Aplikasi untuk otomatisasi regresi antarmuka pengguna. <br>  Dikirim dalam kode sumber.  Menggunakan JUnit4 <br><br>  <b>run.properties</b> <br>  File konfigurasi untuk menjalankan Autotests.  Menentukan nama kondisional dudukan yang digunakan dan jenis eksekusi - lokal atau melalui wadah eksternal dan variabel lainnya. <br><br>  <b>Plugin daya pikat</b> <br>  File yang dapat dieksekusi khusus yang diinstal pada server Bamboo. <br>  Membuat laporan pengujian HTML yang dapat diakses melalui server Bamboo. <br><br>  <b>Laporan pengujian</b> <br>  Tes laporan HTML tersedia melalui server Bamboo. <br>  Ini disimpan di server Bamboo di paket hasil dalam tab terpisah. <br><br>  <b>Bambu</b> <br>  Menyediakan peluncuran pengujian integrasi dalam mode otomatis dan manual. <br>  Menyimpan laporan pengujian dalam format Allure. <br><br>  <b>ggr-server</b> <br>  Server-penyeimbang server Selenoid. <br>  Menyediakan penyeimbangan permintaan dari autotests (RemoteWebDriver) ke beberapa contoh server selenium. <br><br>  <b>Docker</b> <br>  Server Docker untuk menjalankan kontainer dan browser server Selenoid. <br><br>  <b>Server selenoid</b> <br>  Server Pengujian Jarak Jauh <br>  Menyediakan peluncuran tes dalam wadah buruh pelabuhan khusus menggunakan browser "tanpa kepala". <br>  Melakukan tes dalam mode paralel sesuai dengan jumlah utas simultan yang ditentukan. <br><br>  <b>Selenoid-ui</b> <br>  Antarmuka pengguna server ke server Selenoid. <br>  Mengizinkan pemantauan kemajuan uji langsung melalui VNC. <br><br>  <b>Selenoid-webdriver</b> <br>  Wadah khusus dengan browser tanpa kepala untuk menjalankan pengujian jarak jauh. <br>  Disediakan dari repositori Selenoid. <br><br>  <b>Gitlab</b> <br>  Menyimpan kode sumber aplikasi Autotests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5d/cac/f81/c5dcacf817e4aa1529d7cc4d64be740d.png"></div><br><h3>  Skema kerja </h3><br>  Diagram berikut menunjukkan skema umum layanan AutoTests di tingkat Desain Tingkat Tinggi. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/ye/e8/ue/yee8uexl8oqy5spoqirropxglha.png"></a> </div><br><h3>  Instalasi dan Penempatan </h3><br>  Autotests didasarkan pada empat server, satu di antaranya adalah server eksekusi, dan tiga lainnya menyediakan peluncuran browser tanpa kepala dalam wadah.  Kekuatan autotest saat ini menyediakan 60 aliran simultan dan dapat diperluas jika perlu. <br><br>  Diagram penyebaran saat ini ditunjukkan pada diagram berikut.  Secara umum, jika Anda tidak membutuhkan lebih dari 20 browser simultan (pengujian thread), maka sangat mungkin untuk meletakkan semuanya di satu server 12 Kernel + 24 RAM.  Kami mulai dengan konfigurasi ini, tetapi ketika persyaratan untuk kekuatan autotest bertambah, kami menemukan secara empiris bahwa konfigurasi yang paling stabil dan hemat biaya adalah server 12 Kernel + 24 RAM “khas” + 24 RAM. <br><br>  Dalam pengalaman kami, untuk pengujian sistem dengan antarmuka web pada Angular, konfigurasi wadah yang dapat diterima dengan browser harus menjadi lantai kernel + GB memori.  Konfigurasi yang lebih kecil memperlambat browser dan bahkan dapat menyebabkan crash yang tidak dapat diidentifikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/152/65f/095/15265f09560a8abd9a744e5c06da1f61.png"></div><br><h1>  Struktur dan organisasi kode </h1><br>  Sebelum beralih ke struktur dan organisasi kode, saya akan sekali lagi mencantumkan kebijakan dan batasan yang pada akhirnya menentukan arah pengembangan arsitektur: <br><br><ul><li>  Sejumlah besar skrip uji ujung ke ujung yang kompleks.  Intensitas pembangunan yang tinggi; </li><li>  volatilitas tinggi skenario pengujian (variabilitasnya); </li><li>  kecepatan pengiriman skenario yang terus menerus tinggi (pengembangan dan revisi); </li><li>  kualifikasi awal pengembang autotest; </li><li>  Pengembangan pengembang yang terencana tinggi. </li></ul><br>  Berdasarkan hal tersebut di atas, driver arsitektur utama adalah sebagai berikut: <br><br><ul><li>  memastikan kode yang sangat terstruktur untuk kemudahan pembacaan dan pengelolaan; </li><li>  pemisahan dan isolasi maksimum antara implementasi aplikasi tes khusus dan kelas lintas fungsi fungsional umum; </li><li>  pengurangan maksimum dari dependensi yang diperlukan untuk kemudahan perubahan; </li><li>  Penggunaan kembali kode secara wajar di tingkat kelas lintas sektor dengan kemungkinan duplikasi kode di tingkat kelompok uji independen (subsistem fungsional) untuk mengurangi ketergantungan dan menggabungkan konflik di tingkat pengembangan; </li><li>  penolakan kerangka kerja yang kompleks seperti musim semi, aspekJ untuk mengurangi waktu untuk "masuknya" pengembang pemula ke dalam proyek. </li></ul><br>  Secara umum, pendekatan arsitektural ini memungkinkan untuk mengimplementasikan pengembangan cepat yang independen di bawah kondisi skenario dengan variabilitas tinggi dengan proses yang hampir berkesinambungan untuk memberikan pengujian baru kepada yang produktif.  Arsitektur dan sekarang berhasil menahan "pemuatan dan penyempurnaan" meskipun sistem telah menerapkan lebih dari 1.500 skenario bisnis. <br><br>  Struktur kode umum dan deskripsi dari solusi spesifik utama diberikan di bawah ini. <br><br><h3>  Struktur kode umum dan pola pengembangan </h3><br>  Struktur umum organisasi kode didasarkan pada arsitektur "berlapis" (lihat diagram), yang umumnya mewarisi Pola Halaman yang direkomendasikan oleh pengembang Selenium.  Kami memperluas pola ini dengan menambahkan tingkat elemen web ke pangkalan dan menyoroti tingkat skenario pengujian: <br><br><ul><li>  tingkat kelas tes </li><li>  tingkat skenario pengujian </li><li>  tingkat halaman web </li><li>  tingkat elemen web </li><li>  kerangka pengujian (ditunjukkan dengan meredupkan diagram). </li></ul><br>  Setiap tingkat dalam skema ini memiliki serangkaian tanggung jawab dan fungsi tertentu.  Perpotongan fungsional antara lapisan atau dependensi tidak sah di antara mereka tidak diizinkan dan merupakan alasan utama untuk mengembalikan komit untuk revisi sebagai bagian dari tinjauan kode sebelum permintaan penggabungan. <br><br>  Selain itu, struktur "berlapis" diperbaiki dalam pembagian kode ke dalam paket (lihat diagram di bawah). <br><br>  Skema semacam itu memungkinkan untuk membagi semua subsistem (yang ada secara signifikan lebih banyak daripada dalam skema) antara pengembang dan, sebagai hasilnya, memungkinkan untuk dikembangkan secara mandiri dengan jumlah konflik merger yang praktis menghilang. <br><br>  Diagram di bawah ini menunjukkan struktur umum implementasi kelas uji dan skema distribusi untuk implementasi paket proyek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c26/582/00e/c2658200ed322c07b65492aef2479074.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/528/329/caf52832908c9f9d739b891d1aafb29d.png"></div><br><h3>  Tes tingkat kelas </h3><br>  Level kelas tes mencakup satu kelas tunggal untuk tes individu tertentu (tes ini dijelaskan dalam sistem manajemen tes sebagai urutan linear dari skrip tes).  Kelas tes adalah kelas Junit dengan penjelasan tes @ metode yang sesuai.  Secara umum, kelas tes hanya mengimplementasikan satu metode tes. <br><br>  Setiap kelas uji mewarisi dari kelas dasar yang tugasnya adalah menginisialisasi semua TestRules di RuleChain, yaitu, menginisialisasi infrastruktur uji seperti menginisialisasi driver web, mengatur direktori sementara, dan penangan utilitas keperluan umum lainnya. <br><br>  Kelas tes bertanggung jawab untuk mengatur pelaksanaan skenario pengujian melalui: <br><br><ol><li>  inisialisasi data bisnis uji (tempat uji), </li><li>  panggilan berurutan dari skrip uji individual (Tindakan) sesuai dengan skenario yang diperlukan dengan transfer data uji yang diinisialisasi kepada mereka dari langkah 2. </li></ol><br>  Selain itu, pada langkah 2 harus ada urutan linier tanpa cabang atau titik keputusan.  Templat implementasi kelas ditunjukkan di bawah ini. <br><br><h3>  Tingkat uji kasus </h3><br>  Level test case bertanggung jawab untuk implementasi test case spesifik seperti yang dijelaskan.  Skenario pengujian dalam konteks ini adalah urutan operasi yang dilakukan oleh pengguna pada sistem melalui interaksi dengan elemen pada halaman web aplikasi. <br><br>  Tujuan utama dari kelas kasus uji: <br><br><ul><li>  jalankan urutan tertentu dari skrip uji dengan mengakses metode kelas bawah Halaman, menggunakan <br><br>  o mentransmisikan data adegan pengujian, <br>  o data diterima dari halaman web (dari kelas Halaman); </li><li>  Lakukan tes bisnis yang diperlukan untuk keberhasilan tes dalam konteks model bisnis dan suasana pengujian.  <b>Dengan kata lain, kelas test case TIDAK memeriksa markup, ketersediaan dan aksesibilitas elemen, tetapi beroperasi pada model bisnis dari adegan pengujian, sebenarnya melakukan pengujian bisnis.</b> </li></ul><br>  Kelas uji kasus diatur sebagai "antarmuka fungsional": <br><br><ul><li>  hanya mengandung satu metode publik "apply" (@ Step), yang: <br><br>  o menyediakan implementasi skrip sebagai panggilan ke urutan "tindakan" (metode yang disediakan oleh kelas Halaman), <br>  o menerima semua objek bisnis yang diperlukan sebagai input, sementara TIDAK MENCIPTAKAN objek bisnis itu sendiri dan TIDAK berinteraksi langsung dengan apa pun selain kelas Halaman; </li><li>  berisi metode pribadi X (@ Langkah), yang masing-masing menerapkan langkah terpisah yang terpisah dari skrip pengujian (seperti yang dijelaskan dalam TMS - Sistem Manajemen Tes); </li><li>  Tidak berinteraksi (tidak memanggil metode) dengan aktivitas lain, bahkan aktivitas subsistem yang sama; </li><li>  tidak menerima input dan tidak beroperasi pada data login.  Dengan kata lain, tidak tahu apa-apa tentang peran dari mana ia diluncurkan. </li></ul><br>  Organisasi kelas ini memungkinkan Anda untuk: <br><br><ul><li>  Berikan laporan dokumentasi mandiri.  Setiap metode sesuai dengan titik tertentu dalam spesifikasi pengujian dan dijelaskan oleh penjelasan daya tarik @ Langkah; </li><li>  menggunakan kembali kelas skrip tes dalam tes yang berbeda, karena skrip tes 1) tidak membuat adegan tes dan 2) tidak tergantung pada login pengguna (operasi login-relogin dilakukan pada level kelas tes) 3), tes tidak tergantung pada kelas lain scripting. </li></ul><br><h3>  Tingkat halaman web </h3><br>  Level halaman web adalah Pola Halaman klasik untuk pengujian di Selenium.  Kelas halaman berisi definisi elemen web tertentu dan serangkaian metode publik untuk melakukan tindakan grup tertentu dalam konteks langkah-langkah kasus pengujian. <br><br>  Kelas halaman secara langsung bertanggung jawab untuk memasukkan data bisnis ke elemen antarmuka spesifik, bekerja dengan driver web (meluncurkan JS, misalnya) dan, karenanya, menguji format, memeriksa tata letak dan struktur halaman web untuk pemeriksaan dasar seperti: elemen tidak ditemukan / tidak tersedia dan item tidak mengandung nilai yang diperlukan. <br><br>  Kelas halaman juga tidak termasuk dan tidak dapat mengakses halaman lain dan metode mereka.  Juga, kelas halaman tidak melakukan pemeriksaan bisnis, membatasi diri hanya untuk pemeriksaan struktural di tingkat elemen web dalam kasus umum, memberikan "hingga" ke tingkat data "script tes" yang diterima dari halaman. <br><br><h3>  Tingkat elemen web </h3><br>  Lapisan elemen web mencakup pustaka elemen hingga yang mungkin ada di halaman web.  Ini mencakup primitif spesifik dan konglomerat yang lebih kompleks, yang terdiri dari beberapa elemen yang kita sebut widget.  Contoh widget dapat berupa konstruksi seperti "pajinator", menu global, berbagai bingkai dan jendela modal, elemen kompleks seperti YandexMap atau pemutar Youtube.  Elemen web mengatur komposisi dengan kelas halaman tertentu dan juga tidak tahu apa-apa tentang elemen lain. <br><br>  Secara umum, jika proyek memiliki semacam identifikasi unik global dari semua elemen antarmuka dengan ID mereka, maka masuk akal untuk mengatur tingkat elemen web sebagai pustaka global dengan permintaan elemen tertentu dengan ID mereka melalui kelas konfigurasi pabrik atau \ xml di pustaka pegas.  Tetapi tidak di setiap proyek ini mungkin. <br><br><h3>  Kerangka pengujian </h3><br>  Konsep pengembangan autotest, seperti yang ditunjukkan pada diagram di atas, didasarkan pada gagasan kerangka kerja di mana seperangkat fungsi sistem disediakan untuk semua autotest - mereka terintegrasi dengan mulus dan memungkinkan pengembang autotest untuk fokus pada masalah spesifik implementasi bisnis kelas uji. <br><br>  Kerangka kerja ini meliputi blok fungsional berikut: <br><br><ul><li>  Aturan - inisialisasi dan finalisasi komponen infrastruktur pengujian sebagai inisialisasi WebDriver dan menerima tes video (dijelaskan secara lebih rinci di bawah); </li><li>  WebDriverHandlers - fungsi pembantu untuk bekerja dengan driver web seperti mengeksekusi Java Script atau mengakses log browser.  Diimplementasikan sebagai satu set metode statis tanpa-negara; </li><li>  WebElements - pustaka elemen web biasa atau grup mereka, berisi fungsionalitas lintas fungsi yang diperlukan dan perilaku tipikal.  Dalam kasus kami, fungsionalitas ini mencakup kemungkinan pemeriksaan penyelesaian operasi asinkron di sisi browser web.  Diimplementasikan sebagai ekstensi elemen web dari perpustakaan Selenium dan Selenide. </li></ul><br><h3>  Inisialisasi lingkungan pengujian.  Aturan </h3><br>  Kelas utama untuk semua kelas tes adalah BaseTest, dari mana semua kelas tes diwarisi.  Kelas BaseTest mendefinisikan "runner" Junit dari tes dan RuleChain yang digunakan, seperti yang ditunjukkan di bawah ini.  Akses dari kelas uji aplikasi ke fungsi yang disediakan oleh kelas aturan dilakukan melalui metode statis kelas aturan menggunakan "utas" pengenal utas sebagai kunci. <br><br>  Rincian implementasi kelas dasar untuk kerangka kerja autotest akan diperlihatkan di bagian selanjutnya artikel: lihat Bagian 2-1.  Implementasi kelas dasar untuk semua tes dan JUnit ChainRule. <br><br><h3>  Mendokumentasikan hasil melalui laporan Allure. </h3><br>  Untuk laporan terperinci tentang pengujian yang dilakukan, Allure Framework digunakan, terintegrasi dengan Bamboo melalui <a href="https://docs.qameta.io/allure/">Allure Plugin</a> .  Ini memberikan peluang bagi konsumen pengujian khusus (tim pengujian fungsional) tidak hanya untuk menerima data tentang fakta crash tes tertentu, tetapi juga untuk dengan mudah mengembalikan dan, jika perlu, ulangi tes jatuh secara manual. <br><br>  Untuk mendokumentasikan laporan pengujian, fungsi berikut digunakan: <br><br><ul><li>  Anotasi Allure dan Junit untuk menandai laporan dengan langkah-langkah skrip pengujian, serta deskripsi statis metadata untuk pengujian; </li><li>  Lampiran daya pikat untuk dilampirkan ke laporan informasi tambahan seperti tes video, tangkapan layar, hasil diagnostik tambahan dari penyebab kecelakaan, log browser web diunduh ke / dari browser file. </li></ul><br>  Anotasi Allure dan Junit berikut digunakan untuk menandai laporan. <br><br><ul><li>  Di tingkat kelas tes: <br><br>  o @ Fitur - nama subsistem fungsional yang menjadi tempat pengujian; <br>  o @ Story - nama kasus uji tertentu; <br>  o @ Pemilik - nama pengembang yang terakhir kali melakukan perubahan pada tes; <br>  o @ TmsLink - tautan ke deskripsi tes di “sistem manajemen pengujian” yang digunakan. </li><li>  Pada tingkat metode pengujian (@ Tes) dari kelas tes: <br><br>  o @ DisplayName - nama lengkap skrip uji.  Ini berbeda dari @ Story karena memungkinkan Anda untuk berbagi skrip yang sama, yang hanya berbeda dalam komposisi adegan pengujian; </li><li>  Pada tingkat metode yang sesuai dengan langkah-langkah spesifik dari skenario pengujian: <br><br>  o @ Step - nama yang berarti dari langkah uji yang mencerminkan esensi bisnis dari apa yang terjadi. </li></ul><br>  Penamaan langkah-langkah pengujian melalui @ Langkah memungkinkan Anda membuat laporan terperinci yang sepenuhnya mengulangi semua langkah dan item yang dijelaskan dalam skenario pengujian.  Hal ini memungkinkan pengguna autotest untuk dengan mudah melacak jalannya skenario pengujian dan membantu menentukan titik kejadian. <br><br>  Secara umum, menggunakan Allure Framework terbukti sangat berguna dan mudah, dengan pengecualian beberapa fitur yang terkait dengan sejumlah besar data yang dihasilkan dalam kasus kami untuk sejumlah besar skrip tes rumit yang panjang (dijelaskan nanti di bagian "Retrospektif"). <br><br><h3>  Apa yang mungkin telah dilakukan secara berbeda segera?  Gunakan Spring Framework </h3><br>  Terlepas dari kenyataan bahwa ketika menerapkan autotest, kami sengaja menolak untuk menggunakan Spring Core, secara umum, saya menganggap penggunaannya dibenarkan dan berfungsi.  Prototipe yang diimplementasikan menunjukkan bahwa menggunakan Spring Core berfungsi untuk tugas-tugas berikut (walaupun tentu saja kami tidak mengujinya sepenuhnya): <br><br><ul><li>  inisialisasi adegan uji; </li><li>  inisialisasi halaman web dan elemen. </li></ul><br>  Satu-satunya fitur adalah kebutuhan untuk menggunakan konteks lingkup "default" dari tingkat prototipe. <br><br>  Inisialisasi adegan uji.  Dalam autotest, adegan tes diinisialisasi dengan metode klasik untuk membuat instance kelas langsung di kelas tes melalui pabrik objek atau objek baru.  Di sini cukup masuk akal untuk menggunakan inisialisasi baik melalui kelas konfigurasi, atau melalui file xml atau file eksternal.  Keuntungannya adalah sebagai berikut: ini 1) menyederhanakan kode ulasan, karena perubahan pada adegan pengujian tidak lagi berlaku untuk kelas-kelas utama, 2) memungkinkan Anda untuk menghubungkan adegan pengujian yang berbeda untuk tegakan yang berbeda atau kondisi lainnya.  Sekarang poin 2 tidak digunakan bersama kami. <br><br>  Inisialisasi halaman web dan elemen.  Injeksi kelas halaman web dan elemen web bekerja berdasarkan malas inisialisasi malas elemen web selenide. <br><br>  Dengan demikian, menjadi mungkin untuk membuat perpustakaan elemen web dan halaman sesuai dengan spesifikasi global tertentu dari antarmuka pengguna dan menerima tautan kode ke elemen-elemen ini bukan oleh path dan id absolut, tetapi oleh id proyek sesuai dengan spesifikasi. <br><br>  Saya harus segera mengatakan bahwa saya tidak menguji ini dengan sangat hati-hati, bahkan saya membatasi diri saya pada implementasi uji “halaman” dari login dan “info” halaman pengguna pada prinsip ini. <br><br><h1>  Retrospektif.  Kejutan </h1><br>  Di sini saya menggambarkan kejutan tak terduga yang muncul selama pengembangan proyek, ditambah beberapa pertimbangan tentang apa yang bisa dilakukan dengan lebih baik jika “tidak”. <br><br><h3>  Markup front-end ramah selenium (Angular) </h3><br>  Salah satu kejutan paling serius yang kami temui adalah tata letak halaman "mengambang", yang mengarah pada fakta bahwa setelah memperbarui aplikasi Angular, tes jatuh karena Selenium tidak dapat menemukan elemen karena ID mereka (id, kelas atau ng-model) atau path (untuk XPath).  Hal ini menyebabkan ketidakstabilan tes dan ketidakjelasan alasan jatuh. <br><br>  Sayangnya, masalah ini pada umumnya tidak dapat diselesaikan.  Kami mengelak dengan langkah-langkah organisasi: 1) pada awal pengujian kandidat baru untuk rilis, semua pengembang autotest fokus pada penghapusan dan penyempurnaan cepat dalam hal mengedit nilai-nilai pencari elemen web;  2) pada akhirnya, kami datang untuk menggunakan XPath relatif, yang, sayangnya, tidak meningkatkan kinerja sama sekali. <br><br>       –            ,         -        . <br><br><h3>     «download»  </h3><br>  «»        : <br><br><ul><li>  «»   (    ) –   «»          .          ; </li><li>  «»  ( Bamboo)  «»       solenoid : <a href="http://selenoid-host.example.com:4444/download/%257BSESSION_ID%257D/%257BFILE_NAME%257D">selenoid-host.example.com:4444/download/{SESSION_ID}/{FILE_NAME}</a> </li></ul><br>    <a href="https://aerokube.com/selenoid/latest/"></a> . <br><br>            .     ,      ,         .           ,       . <br><br><h3>     </h3><br>         .        ,   «»          . ,                  ,  ,  ,     ,       - (    )  -     . <br><br>  ,       ,    ,       .             . <br><br>    ,    .         «» ,          ,     ,            . <br><br><h3>    </h3><br>              . ,      .      (~ 1000  )       6 . <br><br>          <a href="https://aerokube.com/ggr/latest/">Selenoid-ggr</a> .        junit  20 ( Selenoid-)  60 ( ),        . «» ,          60  . <br><br> ,    ,  ,         3-4 ,        preQA-.    . , ,   AWS c   ,    Selenoid-     ,         AWS   Selenoid,     in/out . <br>   ,       ,             E2E      .              preQA. <br><br><h3>  «»       </h3><br>        ,         60     60 . <br><br>    «Timeline»    « » (  ). ,             . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/580/84e/60b/58084e60b239a6157b54db4e8b9c496c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada dua alasan. </font><font style="vertical-align: inherit;">"Steker" awal disebabkan oleh seruan massa ke layanan otorisasi dan akun pribadi. </font><font style="vertical-align: inherit;">Semua browser secara bersamaan mulai masuk dan membebani layanan di sisi bangku tes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Kolom" berikutnya ternyata terkait dengan fakta bahwa kelas uji terletak di folder oleh subsistem dan junit menjalankannya hampir secara bersamaan, sehingga memuat subsistem fungsional spesifik dudukan dan melampaui batas kinerja konfigurasi dudukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memecahkan masalah pertama dengan membungkus metode skrip login di balancer, yang membatasi jumlah maksimum operasi login ke konstanta yang diberikan.</font></font><br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Step</span></span>(<span class="hljs-string"><span class="hljs-string">":    "</span></span>)     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {         LoadCounter.get(); <span class="hljs-comment"><span class="hljs-comment">//   .              try {                 applyLogin(user); //          } catch (Throwable t) {             throw t; //                   } finally {             LoadCounter.release(); //            }         } catch (LoadCounterException e) { //                  throw new StandRuntimeException("Can not get loadcounter for Login action.", e);     }     }</span></span></code> </pre> <br>  Masalah kedua diselesaikan dengan menyalakan opsi uji coba acak, yang dimiliki plugin junit maven. <br><br><pre> <code class="java hljs">   &lt;plugin&gt;               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;         &lt;version&gt;….&lt;/version&gt;            &lt;configuration&gt;                &lt;!-- Defines the order the tests will be run in. Supported values are <span class="hljs-string"><span class="hljs-string">"alphabetical"</span></span>,                     <span class="hljs-string"><span class="hljs-string">"reversealphabetical"</span></span>, <span class="hljs-string"><span class="hljs-string">"random"</span></span>,<span class="hljs-string"><span class="hljs-string">"hourly"</span></span>, <span class="hljs-string"><span class="hljs-string">"failedfirst"</span></span>, <span class="hljs-string"><span class="hljs-string">"balanced"</span></span> and <span class="hljs-string"><span class="hljs-string">"filesystem"</span></span>. --&gt;                &lt;runOrder&gt;random&lt;/runOrder&gt;                …</code> </pre><br>  Harus dicatat bahwa masalah ini terkait dengan fakta bahwa kami tidak memiliki kesempatan untuk meningkatkan kinerja bangku tes karena sumber daya yang terbatas, dan juga karena sumber daya ini akan menganggur sebagian besar waktu. <br><br>  Secara umum, ternyata sistem swa-uji E2E web-UI internal dapat digunakan untuk pengujian beban pengganti dan penyaringan kinerja dan stabilitas sistem yang diuji secara keseluruhan. <br><br><h3>  Beban tinggi di server Bamboo dan penyimpanannya </h3><br>  Jika Anda memiliki banyak tes dengan sejumlah besar operasi (misalnya, jumlah operasi yang masuk melalui <a href="https://habr.com/ru/users/step/" class="user_link">Langkah</a> adalah 200 hingga 2000 dengan jumlah tes sekitar 1300), maka volume laporan Allure menjadi lebih dari signifikan.  Jika Anda menambahkan di sini juga berbagai lampiran seperti tangkapan layar dan file yang diunggah / diunggah, maka volumenya sudah mencapai ratusan megabita.  Misalnya, sekarang untuk regresi setiap malam dari 900 tes, jumlah data yang diunggah ke Bamboo Allure saja sekitar 600 MB. <br><br>  Jelas bahwa para insinyur DevOps tidak antusias tentang intensitas konsumsi ruang disk dan secara aktif menyatakan ketidakpuasan, terutama sehubungan dengan kebutuhan untuk menyimpan data selama setidaknya satu tahun. <br><br>  Kami melihat jalan keluar dari situasi ini dengan menggunakan server eksternal untuk menyimpan dan memproses laporan, misalnya, seperti Allure Enterprise.  Server ini sudah dibayar, tetapi memungkinkan kami untuk menyelesaikan masalah ini.  Kami saat ini sedang mengerjakan pengujian dan mengintegrasikan Allure Enterprise ke dalam proyek kami. <br><br><h1>  Untuk dilanjutkan </h1><br>  Pada artikel berikutnya, kolega saya akan melanjutkan cerita dan menggambarkan sejarah yang menarik dari pengujian layanan web menggunakan Smartbear SoapUI Pro.  Kekuatan dua insinyur otomasi berhasil mengotomatisasi sekitar 500 skrip pengujian, untuk tujuan ini, saya harus menerapkan kerangka kerja tambahan yang secara signifikan memperluas fungsi fungsi SOAP UI standar, tetapi lebih pada hal itu nanti. <br><br>  <b><i>Artikel ini ditulis bekerja sama dengan manajer proyek dan pemilik produk <a href="https://habr.com/ru/users/kotalesssk/" class="user_link">kotalesssk</a> .</i></b> <br><br>  <a href="https://habr.com/ru/company/lanit/blog/473426/">Bagian 1. Organisasi dan manajerial.</a>  <a href="https://habr.com/ru/company/lanit/blog/473426/">Kenapa kita perlu otomatisasi.</a>  <a href="https://habr.com/ru/company/lanit/blog/473426/">Organisasi proses pengembangan dan manajemen.</a>  <a href="https://habr.com/ru/company/lanit/blog/473426/">Organisasi penggunaan</a> <br>  Bagian 2. Teknis.  Arsitektur dan tumpukan teknis.  Detail implementasi dan kejutan teknis <br>  Bagian 2-1.  Implementasi kelas dasar untuk semua tes dan JUnit ChainRule <br>  Bagian 2-2.  Implementasi proses mengunggah file dari wadah dengan browser ke kerangka uji.  Cari nama file yang diunduh oleh browser <br><br><div class="spoiler">  <b class="spoiler_title">Kami memiliki lowongan, datanglah ke kami!</b> <div class="spoiler_text"><ul><li>  <a href="https://job.lanit.ru/young/programs/Pages/dks2019testir.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2019-12-03%26utm_campaign%3Ddks">Program magang "Pengujian Otomatis"</a> </li><li>  <a href="https://job.lanit.ru/young/programs/Pages/dks-2019.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2019-12-03%26utm_campaign%3Ddks">Program magang "Load Testing"</a> </li><li>  <a href="https://job.lanit.ru/vacancy/Pages/CH-165.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2019-12-03%26utm_campaign%3Ddks">Trainee Tes Teknisi</a> </li><li>  <a href="https://job.lanit.ru/vacancy/Pages/BS-72.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2019-12-03%26utm_campaign%3Ddks">Spesialis Pengujian Fungsional Terkemuka</a> </li><li>  <a href="https://job.lanit.ru/vacancy/Pages/BS-46.aspx%3Futm_source%3Dhabr%26utm_medium%3Dpost-2019-12-03%26utm_campaign%3Ddks">Insinyur Pengujian Otomatis Timbal</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477044/">https://habr.com/ru/post/id477044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477026/index.html">JetBrains Hackathon Tahunan Ketujuh</a></li>
<li><a href="../id477032/index.html">Dari blockchain ke DAG: menyingkirkan perantara</a></li>
<li><a href="../id477038/index.html">Bahasa pemrograman terbaik untuk pemula</a></li>
<li><a href="../id477040/index.html">Gartner chart 2019: tentang apa semua kata kunci ini?</a></li>
<li><a href="../id477042/index.html">Optimalisasi Strategi Monte Carlo Blackjack</a></li>
<li><a href="../id477046/index.html">.Net Meetup di Raiffeisenbank 28/11 + Broadcast</a></li>
<li><a href="../id477048/index.html">Mengapa perusahaan dengan kapitalisasi $ 55 miliar berpikir untuk meninggalkan bursa</a></li>
<li><a href="../id477050/index.html">Black Friday 2019 untuk pengawasan video dan cloud.</a></li>
<li><a href="../id477052/index.html">Reaktor, WebFlux, Kotlin Coroutines, atau Asynchrony dengan Contoh Sederhana</a></li>
<li><a href="../id477054/index.html">Webasto Mengumumkan Sistem Baterai Otomotif Modular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>