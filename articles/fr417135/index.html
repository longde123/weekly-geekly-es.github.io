<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 🚠 🧕🏾 Unity3D: comment connaître le degré d'éclairage d'un point dans une scène? 🌌 🤷🏼 🤵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salutations! 

 Je sais, et au fond, vous savez ce qui manque à vos jeux de cartes ou aux jeux trois en un. Systèmes furtifs! 

 Et bien sûr, tout sys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity3D: comment connaître le degré d'éclairage d'un point dans une scène?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417135/">  Salutations! <br><br>  Je sais, et au fond, vous savez ce qui manque à vos jeux de cartes ou aux jeux trois en un.  Systèmes furtifs! <br><br>  Et bien sûr, tout système de furtivité qui se respecte devrait pouvoir prendre en compte l'illumination de l'environnement autour du joueur.  J'ai été étonné de découvrir le sujet et de trouver une quantité anormalement petite d'informations.  Par conséquent, je m'empresse de partager les fruits. <br><br>  Aujourd'hui, nous ne développerons pas un système de furtivité à part entière pour le joueur, nous considérerons uniquement des interactions avec l'éclairage. <br><a name="habracut"></a><br><h3>  Méthode 1: collisionneurs </h3><br>  Un moyen simple et peu gourmand en ressources. <br><br>  Nous ajoutons un collisionneur sphérique à chaque source de lumière.  Nous en faisons un déclencheur.  Nous fixons les dimensions approximativement égales au rayon de lumière. <br><br>  Le reste est aussi clair qu'une ombre.  Nous écrivons un script simple, où dans OnTriggerEnter () nous plaçons l'activation du calcul de la lumière (pour que les sources de lumière ne fonctionnent pas "inactives" lorsque le joueur n'est pas à proximité). <br><br>  Le calcul d'éclairage lui-même sera situé dans Update ().  En substance, c'est la physique habituelle.Raycast ().  S'il frappe le joueur, le joueur est dans la zone claire.  S'il ne tombe pas, cela signifie que le joueur est derrière des obstacles et donc à l'ombre. <br><br>  Vous pouvez également ajouter ici le calcul de la distance entre le lecteur et la source lumineuse.  Ainsi, pour déterminer l'illumination, nous utiliserons un flotteur simple, qui variera en fonction de la distance aux sources lumineuses.  Et vous pouvez l'utiliser partout où votre cœur le désire. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c9/nu/43/c9nu43wv6trcy2hg28eijiq4j_o.png"><br>  <i>Au point 1, l'éclairage est proche du maximum.</i>  <i>Au point 2, l'éclairage est minimal - il y a un obstacle entre la lumière et le point.</i>  <i>Au point 3, l'éclairage est moyen.</i> <br></div></div><br>  Et ce n’est pas tout!  Vous pouvez ajouter des collisionneurs déclencheurs à diverses «zones d'ombre» où le joueur doit se cacher.  Dans les meilleures traditions de Manhunt.  De même, vous pouvez marquer les zones lumineuses avec le collisionneur, simulant, par exemple, la lumière d'un projecteur. <br><br><h4>  Avantages: </h4><br><ul><li>  Lumières ponctuelles faciles à personnaliser. </li><li>  Assez économique en termes de ressources, si vous ne spammez pas les sources de lumière. </li></ul><br><h4>  Inconvénients: </h4><br><ul><li>  La lumière Spot et la lumière directionnelle sont fortement accordées.  Si pour le premier il suffit de positionner le collisionneur dans le champ de lumière (pour augmenter la visibilité du joueur à l'entrée), alors le second est une véritable horreur.  Vous devez soit placer des collisionneurs à chaque ombre (pour réduire la visibilité du joueur à l'entrée), soit vérifier constamment avec Physics.Raycast () entre le joueur et le «soleil» - il est situé sous les rayons ou dans l'ombre. </li><li>  Un grand nombre de collisionneurs encombrent la scène, compliquant la physique. </li><li>  Des précautions doivent être prises avec les sources de lumière qui se croisent. </li><li>  La lumière dynamique (en mouvement ou en variation d'intensité) doit être ajoutée séparément via des scripts. </li></ul><br><h3>  Méthode 2: RenderTexture </h3><br>  Que faisons-nous ici?  En fait, nous obtenons une «capture d'écran» de la caméra, et pas nécessairement de la caméra principale.  Et puis nous analysons la couleur de la capture d'écran pour savoir comment la lumière brillante tombe sur le sujet. <br><br>  Pour commencer, nous avons besoin d'un objet à partir duquel nous "lirons" la lumière.  Créez une sphère ou un plan régulier, faites-le petit (échelle de 0,1), placez-le près du sol, rendez-le blanc, retirez le collisionneur: <br><br><div class="spoiler">  <b class="spoiler_title">Texte masqué</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hb/ri/7o/hbri7op9p5lyq091ia1ozgeiasc.png"><br></div></div><br>  Ajoutez une caméra (assurez-vous de supprimer l'écouteur audio et vérifiez que la balise MainCamera n'en vaut pas la peine).  Liez-le à notre objet.  On le met un peu plus haut, on le dirige vers le bas.  Nous exposons dans les paramètres pas l'affichage principal.  Le faire orthographique est à votre goût. <br><br>  Au final, nous le positionnons pour qu'il regarde notre objet et seulement lui. <br><br><div class="spoiler">  <b class="spoiler_title">Texte masqué</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uv/de/3y/uvde3ygsuysuvuysojxbsvmbml8.png"><br></div></div><br>  Au final, configurez le masque Culling des caméras primaire et secondaire pour que le primaire n'affiche pas nos objets «légers», tandis que les secondaires ne les voient que, sans encombrer autre chose. <br><br>  Et ici, le plaisir commence.  Nous attachons le script à la caméra: <br><br><pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Camera</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cam</span></span>; //   <span class="hljs-selector-tag"><span class="hljs-selector-tag">RenderTexture</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tex</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Texture2D</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">tex</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Start</span></span> () { //    "". // ,       -   . // Depth   0   -   . tex = new RenderTexture (1, 1, 8); // RenderTexture "" , //   ,    . _tex = new Texture2D (1, 1, TextureFormat.RGB24, false); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Update</span></span> () { //   ""  cam.targetTexture = tex; cam.Render (); //     RenderTexture.active = tex; //   Texture2D _tex.ReadPixels (new Rect (0, 0, 1, 1), 0, 0); _tex.Apply (); Color col = _tex.GetPixel (0, 0); float vis = (col.r + col.g + col.b) / 3; }</code> </pre> <br>  En sortie, nous obtenons un flotteur vis, qui, par essence, est une représentation numérique du niveau d'éclairage incident sur notre objet.  Si la source est proche - l'objet est blanc - vis est 1. S'il est sombre - l'objet est noir - vis est ~ 0. <br><br>  Nous n'avons pas besoin d'effectuer l'opération ci-dessus à chaque image, nous incorporons donc une petite seconde minuterie: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interval</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Update</span></span> () { interval += Time.deltaTime; if (interval &lt; 1) return; interval = 0; //   }</code> </pre> <br>  Ensuite, nous lions l'ensemble de notre système au joueur afin qu'il bouge avec lui.  Et notre variable vis renvoie automatiquement la lumière autour du lecteur! <br><br>  Ce système peut être utilisé non seulement conjointement avec le lecteur.  Vous pouvez le placer n'importe où et comme vous le souhaitez, créant une sorte de capteurs de lumière.  En règle générale, il existe des moyens plus efficaces de les mettre en œuvre, mais est-il toujours agréable d'avoir des alternatives? <br><br>  Les avantages sont évidents, parlons des inconvénients. <br><br><h4>  Inconvénients </h4><br><ul><li>  Chaque «détecteur de lumière» (s'il y en a plusieurs) nécessite une caméra distincte. </li><li>  Texture2D.ReadPixels () - enfin, extrêmement lent.  Même si vous le faites une fois par seconde, et pas à chaque image, même si vous divisez les fonctions d'écriture et de lecture des textures en différentes images, il existe toujours des dispositions à 40-110 ms. </li><li>  Ce système ne prend pas en compte de rares cas.  Par exemple, une lampe de poche brille sur un personnage.  Le personnage est bien éclairé, mais la lumière tombe sur lui et derrière lui, et non vers le bas, respectivement, notre détecteur de lumière montre un faible niveau d'éclairage.  Vous pouvez résoudre le problème, par exemple, en plaçant le détecteur non pas sur le sol, mais au niveau de la poitrine du personnage.  Ensuite, vous devez placer deux caméras sur les côtés opposés pour lire la lumière de chaque côté.  Ce qui va ralentir le système de moitié. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417135/">https://habr.com/ru/post/fr417135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417123/index.html">Intégration de Spark Streaming et Kafka</a></li>
<li><a href="../fr417125/index.html">RTC Meetup .Net: invitez à la première réunion</a></li>
<li><a href="../fr417127/index.html">Tesla signe un accord pour construire Gigafactory 3 en Chine</a></li>
<li><a href="../fr417129/index.html">Univers de l'esprit</a></li>
<li><a href="../fr417131/index.html">Comment ressentir les transactions dans MongoDB maintenant</a></li>
<li><a href="../fr417137/index.html">Angulaire: créer un composant à cases à cocher multiples pouvant être réutilisé</a></li>
<li><a href="../fr417139/index.html">Des preuves qui ont trompé les scientifiques pendant des décennies</a></li>
<li><a href="../fr417141/index.html">Il n'est jamais trop tôt pour penser à la 6G</a></li>
<li><a href="../fr417143/index.html">Des preuves scientifiques? Ils ne sont pas</a></li>
<li><a href="../fr417145/index.html">Application Burger King: taquinez votre vie privée. Sommes-nous en train de corriger?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>