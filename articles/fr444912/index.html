<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚊 🔜 👨🏾‍💻 Contrôle LCD F-51543NFU-LW-ADN / PWB51543C-2-V0 (de la bibliothèque de bandes) ⏯️ 📪 🔎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour encore, Habr! Ayant traduit l' article sur la gestion du module LCD avec un pilote, mais sans ma propre RAM vidéo, j'ai décidé de traduire une...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contrôle LCD F-51543NFU-LW-ADN / PWB51543C-2-V0 (de la bibliothèque de bandes)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444912/"><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  Bonjour encore, Habr!  Ayant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduit l'</a> article sur la gestion du module LCD avec un pilote, mais sans ma propre RAM vidéo, j'ai décidé de traduire une autre publication sur le même sujet.  Ici le module est déjà plus simple, monochrome, mais pour «faire revivre» il n'en est pas moins intéressant. <a name="habracut"></a><br><br><h1>  Contrôle LCD avec pilote, mais sans contrôleur </h1><br>  L'affichage avec lequel l'auteur va travailler provient d'une ancienne bibliothèque de bandes.  Le contrôleur n'a pas survécu, mais une recherche de tout ce qui concerne «263645-001» a montré qu'il y avait un FPGA.  On pense que contrôler directement ces modules LCD depuis Arduino, etc.  impossible, vous avez besoin d'un lien intermédiaire - le contrôleur de la série SEDxxxxx, qui n'est pas «convivial» avec la carte d'expérimentation et qui a plus d'entrées que le module lui-même.  Mais ce n'est pas le cas.  Voici jusqu'à quatre projets similaires: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sur l'ATmega8515</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dessus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En photo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sur ESP32</a> <br><br>  Et certains contrôlent généralement les moniteurs AVR VGA 8 bits ... <br><br>  En général, l'auteur a réussi, le logiciel sous licence MIT est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h1>  Image fixe </h1><br>  Pour vous assurer que tout fonctionne, vous devez d'abord essayer de sortir une image raster à un bit à partir de la mémoire flash du microcontrôleur.  Pour obtenir une tension négative, trois «Crones» ont été prélevés, la tension du diviseur, qui a été utilisée comme résistance d'accord, a été appliquée à la borne V0.  Et ici sur l'écran est Lenna: <br><br><img src="https://habrastorage.org/webt/yb/7-/fg/yb7-fgxw6yf64l_ylhqaccnhq-g.jpeg"><br><br>  L'auteur ne comprend toujours pas comment il a réussi à retourner l'image (regardez de quel côté se trouve le câble).  Dans tous les cas, il y a cet exemple sur la page du projet sur GitHub. <br><br><h1>  Mode texte </h1><br>  Mais la ROM vidéo est de peu d'utilité, et il n'y a pas 9600 octets pour la RAM vidéo dans l'Arduino.  Le mode texte vient à la rescousse, dans lequel la ROM du générateur de caractères et la RAM vidéo combinée sont plus petites que la RAM vidéo en mode graphique.  Les partisans de la République du Kazakhstan et le «spécialiste» peuvent briser les lances sans fin sur ce sujet. <br><br><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  Un petit exemple en langage assembleur AVR: <br><br><pre><code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br><h1>  Matériel requis </h1><br><img src="https://habrastorage.org/webt/85/p_/52/85p_52apzq0nmbzcnde9vaphrxy.jpeg"><br><br>  Pour le module F-51543NFU-LW-ADN / PWB51543C-2-V0, l'auteur a appliqué: <br><br>  Arduino sur AVR avec une fréquence d'horloge de 16 MHz (testé sur Uno, Leonardo et un clone similaire à ProMicro). <br><br>  Source de tension négative.  Pour l'auteur, il s'agit d'un convertisseur DC-DC non stabilisé A0524S-1W avec isolation d'entrée et de sortie.  Les convertisseurs pour le MC34063 conviennent également (cette puce est très facile à trouver - il suffit de démonter le chargeur USB le moins cher pour un allume-cigare) ou le MAX749.  La stabilisation n'est pas requise, la plage de tensions admissibles à cette entrée pour le module utilisé ici est assez large.  La valeur nominale est de moins 24 V, le maximum est de moins 30 par rapport au fil commun et de 35 entre Vdd et Vee.  La consommation de courant est de 6 mA. <br><br>  Deux transistors MOS à canal N avec contrôle de niveau logique.  L'auteur a utilisé IRL530n, le stock, bien sûr, est grand, mais il ne brûlera certainement pas.  Un transistor contrôle le rétro-éclairage, l'autre une source de tension négative. <br><br>  Résistance de coupure de 250 kΩ pour fournir la tension à l'entrée V0.  Réglez de sorte que -16,8 V à une température de +25 ° C sur le contact mobile.  Cela provient d'une fiche technique, et donc, bien sûr, une telle précision n'est pas nécessaire. <br><br>  Plusieurs résistances de 10 kilos pour la descente. <br><br>  Disposition et cavaliers. <br><br>  Que feriez-vous maintenant?  Montre QR?  Demandez à Kote: <br><br><img src="https://habrastorage.org/webt/lw/yv/qp/lwyvqp84jo4uvj5byzropcuzf7k.jpeg"><br><br>  Kote propose d'implémenter une simulation de certains LCD courants avec un contrôleur.  Pour qu'une autre «réflexion» qui fonctionne avec l'écran du HD44780, seulement grand, puisse être connectée à cet Arduino. <br><br><h1>  Police - également en RAM </h1><br>  Nous prenons un exemple avec EGA et VGA - là, lorsque vous travaillez en mode texte, c'est exactement ce que vous avez fait.  Seulement ici, il y avait 64 caractères au total, mais au moins tout est entré dans la RAM, contrairement au mode graphique.  Certes, le cycle principal des événements a ralenti, mais vous pouvez essayer les graphiques en mosaïque: <br><br><img src="https://habrastorage.org/webt/ie/5w/qa/ie5wqaezqkvosxnzrjhvu3bzpaa.jpeg"><br><br><h1>  Mode graphique et demi-teintes </h1><br>  Dans Arduino sur AVR, il n'y a pas tellement de RAM, et c'est le point.  Même en Mega.  320x240 même avec un bit par pixel - c'est déjà 9600 octets.  Seulement quatre demi-teintes exigeront deux fois plus.  Avec la RAM externe, par exemple, 23LC512 en mode SQI, vous pouvez essayer d'implémenter quelque chose de similaire au DMA, mais il est plus simple et plus rentable de tout refaire sur ESP32, où il y a plus de RAM statique et le DMA est plus facile. <br><br>  Si vous souhaitez simplement connecter un tel écran à un PC via USB, vous pouvez essayer d'utiliser ATmega32u4 pour cela - il y aura suffisamment de ressources même pour les gradations de luminosité (en utilisant FRC, ce que cela est décrit dans ma traduction précédente).  Mais pas avec le «méga» utilisé comme convertisseur d'interface, mais avec un PC qui va lui-même scanner l'écran LCD à la volée à une vitesse de 5,4 mégabits par seconde. <br><br>  Lorsque le module était toujours dans la bibliothèque de bandes, il y avait une interface graphique et des gradations de luminosité - tout était là. <br><br>  Les mises à jour seront.  En attendant ... <br><br><img src="https://habrastorage.org/webt/9z/cu/p9/9zcup9llwkpyuzyzxky3wghu_hs.jpeg"><br><br>  Et ce n'est pas un montage photo, mais le résultat d'un contrôle depuis un PC.  Et nous passerons de Hackaday.io à GitHub - il y a encore beaucoup de choses intéressantes dans README.md. <br><br><h1>  Signaux pour contrôler ces modules </h1><br>  FLM - First Line Marker - marqueur de première ligne, peut également être appelé FRAME, VSYNC, etc. <br>  CL1 - Impulsion de verrouillage de ligne - impulsion de chaîne d'écriture, peut également être appelée.  CHARGE, HSYNC, etc. <br>  CL2 - Horloge de décalage de pixel - impulsion de changement de pixel, peut également être appelée.  CP (changement de pixel), etc. <br>  M - signal alternatif, grâce auquel les pixels sont contrôlés par une tension alternative, peut également être appelé BIAS (offset), etc. <br><br>  D0-D3 est un bus de données parallèle à quatre bits. <br><br>  Fils pour fil commun, alimentation du rétroéclairage (par exemple VLED ±), alimentation du module (VEE et V0) <br><br>  Ne négligez pas les fiches techniques.  Le module peut nécessiter une autre tension négative, ou il peut s'avérer positif, ou le convertisseur peut être intégré.  La logique peut différer, par exemple, avec une unité sur CL1, il n'y aura pas de réaction sur CL2.  Il peut y avoir un rétro-éclairage différent (CCFL (attention, l'onduleur est une "morsure") au lieu des LED), ou il n'y a pas de brochage sur la carte, alors vous ne le saurez pas sans fiche technique.  Vous ne pouvez rien connecter au hasard. <br><br><h1>  Que faire </h1><br>  Transmettez la chaîne en morceaux de quatre bits, l'enregistrement s'effectue sur le déclin sur la ligne CL2.  Après avoir passé la ligne, notez la récession sur la ligne CL1 (oui, après tout, un peu de RAM dans le module est sur une seule ligne).  La ligne suivante sera sélectionnée automatiquement.  Après avoir transmis la trame entière, revenez au début en utilisant le signal FLM.  Dans une fiche technique sur LC79401, il y a un exemple.  Enregistrez à une vitesse suffisante, appliquez régulièrement des impulsions à CL1.  Le contrôleur hésita un peu - l'écran cligna moche. <br><br>  Après chaque image, changez le niveau logique à l'entrée M à l'opposé, de sorte que les pixels soient contrôlés par une tension alternative.  Sinon, l'affichage se détériore: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZP0KxZl5N2o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Vous ne pouvez pas confier cette opération au microcontrôleur, mais mettez un déclencheur dénombrable.  L'entrée à FLM, la sortie à M - en général, est compréhensible. <br><br>  Un exemple de sortie d'images à partir de la mémoire flash (voir le début de l'article) est appelé clglcd_simple dans ce référentiel. <br><br>  Comme déjà mentionné, il est impossible de faire de même avec la RAM en Arduino sur AVR - ce ne sera donc pas suffisant ... <br><br><h1>  Et encore - mode texte </h1><br>  Selon la fiche technique, vous pouvez transmettre des données sur un bus à quatre bits et «tirer» CL2 avec une fréquence allant jusqu'à 6 MHz.  Par conséquent, vous pouvez rapidement et rapidement transférer la ligne, puis le microcontrôleur résout un peu les autres tâches, et comme le temporisateur le «dit», il «tire» CL1 et répète le cycle. <br><br>  Lors de la génération de caractères pour une résolution horizontale de 320 pixels, tout cela peut se faire en 20 μs (320 pixels / 4 bits = 80 impulsions, CL2 "pull" avec une fréquence de 4 MHz).  Pour les tâches restantes, il reste 39,5 μs.  CL1 "jerk" toutes les 59,5 μs et obtenez une fréquence d'images de 70 Hz.  Eh bien, il y aura plus de procédures pour gérer les interruptions et ainsi de suite, en général, le microcontrôleur sera occupé à contrôler l'affichage 45% du temps.  «Entier» 45 ou «total» 45?  Probablement la seconde: l'écrasement des données dans la RAM vidéo peut être assez rapide. <br><br>  Voulez-vous que le microcontrôleur passe moins de temps à gérer l'indicateur, et plus sur d'autres tâches?  Vous pouvez réduire la fréquence d'images à 50 Hz, vous pouvez overclocker le microcontrôleur à 20 MHz.  Avec l'une de ces méthodes, davantage de cycles d'horloge auront lieu entre les routines d'interruption. <br><br>  Un temporisateur de comparaison de sortie commute la ligne CL2 toutes les quatre impulsions d'horloge avec un rapport cyclique de 50%.  Dans le même temps, les données vont aux sorties du port PORTB, connectées au bus de données à quatre bits du module de telle manière qu'elles changent au moment où le niveau monte à CL2, et au moment de la baisse elles restent inchangées.  Bien sûr, cela ne peut se faire sans assembleur: <br><br><pre> <code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br>  8 cycles - et quatre grignotages sont transmis.  Et quoi transmettre exactement dépend du symbole qui se trouve dans la cellule RAM vidéo correspondante, des pixels correspondant à ce symbole qui doivent être transférés de la ROM du générateur de caractères et de ce qui est stocké dans les cellules correspondantes de cette ROM. <br><br>  La chose la plus gênante ici est la nécessité d'arrêter la minuterie après exactement 80 impulsions.  Certains temporisateurs, comme Timer4 en 32u4, ne le peuvent pas. <br><br>  Pour obtenir le signal fourni à la ligne CL1, l'auteur a appliqué une sortie différente du microcontrôleur, destinée à la fois au temporisateur et au PWM rapide.  Ce qui est appliqué ici est compréhensible.  Il commute toutes les 952 mesures.  Ou si vous comptez après le diviseur d'horloge par 8 - il se produit toutes les 119 impulsions.  À ce stade, le sous-programme de traitement d'interruption démarre et force le microcontrôleur à soumettre à CL1 de nouvelles données qui seront nécessaires lors de la prochaine impulsion.  Eh bien, le niveau sur la ligne M change avec la moitié de la fréquence.  Et l'écran LCD ne se détériore pas.  Tous les signaux ressemblent à ceci: <br><br><img src="https://habrastorage.org/webt/yt/_0/dh/yt_0dhpk4km7w-yml5spdz5ukl8.png"><br><br>  Le générateur de caractères se compose de 256 caractères - assez pour 866, KOI-8R ou 1251. 40xN caractères sont placés dans la RAM vidéo, où N est le nombre de lignes en fonction de la hauteur du caractère.  La largeur du symbole est toujours de 8 pixels et la hauteur peut être de 6, 8, 10, 12, 15, 16. Plus il est petit, moins il faut de ROM pour le générateur de caractères et plus de RAM vidéo.  Avec une police 8x8 (40 caractères pour 30 lignes), vous avez besoin de 1200 octets de RAM et 2048 octets de ROM.  Avec une police 8x16 (cela semble mieux sur ce module), la RAM a besoin de 600 octets et la ROM 4096. Du traducteur: vous pouvez stocker la police sous la forme 8x8, la redimensionner verticalement deux fois par logiciel et coûter 600 octets de RAM et 2048 ROM.  Pour stocker plusieurs polices dans la ROM, vous devez conserver l'adresse de début de police non pas dans une constante, mais dans une variable, mais cela ne fonctionnera pas pour imprimer le texte dans plusieurs polices à la fois, sauf, bien sûr, si vous modifiez cette adresse à la volée par la procédure de traitement d'interruption directement pendant le transfert des pixels à l'écran. <br><br>  La police est stockée comme ceci: d'abord les premières lignes des 256 caractères, puis une ligne en dessous, etc.  Il existe un script Python dans le dossier misc du référentiel, qui convertit automatiquement la police TTF en fichier d'en-tête clglcd_font.h avec le tableau PROGMEM au format requis.  Les polices pixel classiques pour CC-BY-SA 4.0 peuvent être trouvées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h1>  Et encore - prenez un exemple avec EGA et VGA </h1><br>  Mais cette fois avec des détails.  Le générateur de caractères dans la RAM, comme indiqué ci-dessus, contient un total de 64 caractères, ils peuvent être identifiés par des nombres de 0 à n ou de 255-n à 255. Ils sont stockés de la même manière: les premières lignes de tous les caractères, puis les suivantes, et ainsi de suite.  Seul tout cela est aligné en tenant compte du fait que les caractères ne sont pas 256, mais 64. Pour les caractères de taille 8x16 pixels, 16 * 64 = 1024 octets sont requis.  Le référentiel a un exemple de travail avec le générateur de caractères en RAM. <br><br>  Si les deux générateurs de caractères sont utilisés en même temps - 256 caractères en ROM et 64 caractères en RAM, vous devrez accepter que non seulement il y aura moins de RAM, mais aussi que la vitesse de transfert des données des lignes du module diminuera - au lieu de 8 cycles d'horloge, deux quartets auront besoin de 12, c'est-à-dire, non pas 20 microsecondes, mais 30, et au lieu de 45% du temps pour le contrôle LCD, cela prendra 60. <br><br><h1>  Mode graphique en demi-teintes </h1><br>  Comme indiqué ci-dessus, dans ce cas, le microcontrôleur fonctionne simplement comme un convertisseur d'interface.  Vous aurez besoin d'ATmega32u4, et ce qu'il faut faire est décrit <a href="">ici</a> .  Veuillez noter que le module peut être endommagé en raison du gel du programme sur le PC. <br><br>  Alors, quelle est cette boucle à quatre fils - à partir du capteur résistif, il s'avère. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mMqvBnYOjEQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Où se connecter </h1><br>  Comme indiqué ci-dessus, une tension négative est requise, qui dans les premières expériences peut être retirée de trois «Crones», puis assembler le convertisseur, par exemple, sur le MAX749.  Les signaux de contrôle de puissance, ainsi que le signal DISPOFF (c'est un signal inverse, le module est allumé à un), abaissent les résistances.  Lors du flashage et de la réinitialisation du microcontrôleur, l'apparition d'unités logiques y est inacceptable. <br><br>  Appliquer une tension négative après tension + 5 V et une unité logique à la ligne DISPOFF - lorsque des données sont déjà présentes sur les lignes de contrôle: au moins une unité sur le bus de données, une unité sur CL1.  Sinon, le module peut échouer. <br><br>  Les entrées D0-D3 peuvent être connectées aux sorties du même port du microcontrôleur, par exemple Px4-Px7, tandis que les sorties Px0-Px3 ne peuvent pas être utilisées comme GPIO.  Vous pouvez leur affecter d'autres fonctions, par exemple, les utiliser comme sorties de temporisations, interfaces série, etc.  Si vous les utilisez comme entrées, soyez prudent: les résistances de pull-up intégrées peuvent commuter arbitrairement si elles ne sont pas désactivées (PUD - pull-up disable). <br><br>  Entrée M - à la sortie du temporisateur de comparaison ou PWM. <br><br>  Entrée CL1 - vers une autre sortie du même temporisateur. <br><br>  Entrée CL2 - à la sortie d'un autre temporisateur de comparaison. <br><br>  FLM - vers n'importe quelle sortie numérique. <br><br>  DISPOFF - vers toute autre sortie numérique. <br><br>  Le reste dépend de la façon dont vous allumez le module.  L'auteur préfère contrôler le rétro-éclairage et le Vee séparément. <br><br><h1>  Comment utiliser le firmware </h1><br>  Placez les fichiers clglcd.h et clglcd.cpp dans l'esquisse <br><br>  Faites une copie de sauvegarde du fichier clglcd_config.h et éditez-le en tenant compte de ce qui est connecté, ainsi que des fonctions dont vous avez besoin: un générateur de caractères en RAM, etc.  Attention, le code n'indique pas les noms des broches Arduino, mais les noms des broches du microcontrôleur selon la fiche technique.  Les noms des sorties des dompteurs de comparaison sont déchiffrés comme suit: par exemple, 2, B est OC2B, ce qui sur l'Arduino Uno correspond à PD3.  Les exemples montrent les options de connexion obtenues par l'auteur. <br><br>  Générez le fichier de police clglcd_font.h avec un script Python dans le dossier misc (voir ci-dessus). <br><br>  Voir dans les exemples comment initialiser, allumer et éteindre l'écran.  Mettez dans le tableau d'écran le texte que vous souhaitez afficher pour vérification. <br><br>  Compilez et remplissez l'esquisse.  Vérifiez avec un analyseur logique que les signaux corrects iront à l'écran et avec un voltmètre que toutes les tensions d'alimentation sont normales.  Ensuite, connectez l'écran. <br><br>  Ajoutez un code à l'esquisse qui fera quelque chose, par exemple, recevra du texte sur un port série et l'affichera. <br><br><h1>  Afficher les interruptions </h1><br>  L'affichage doit être constamment mis à jour, ce que font les procédures de gestion des interruptions.  Si les interruptions s'arrêtent pendant plus de 30 microsecondes, l'affichage clignote et si plus de 60 microsecondes pour une unité sur la ligne FLM, il peut échouer.  Si vous devez arrêter les interruptions pendant une longue période, éteignez d'abord l'affichage avec le signal DISPOFF (je le répète, c'est un signal inverse, le module est allumé à un).  Bien sûr, s'il s'éteint pendant deux secondes à chaque fois que vous avez besoin de traiter les données d'un capteur d'humidité et de température, peu de gens l'aimeront, mais c'est mieux que de ruiner le module.  Mieux encore, chargez le reste sur un microcontrôleur séparé.  L'échange d'informations par le même microcontrôleur avec des appareils fonctionnant sur le protocole 1 fil et des LED d'adresse est particulièrement inacceptable.  Les clones Arduino Pro Micro sont assez peu coûteux pour en acheter deux. <br><br><h1>  La communication </h1><br>  Mais les interfaces matériellement implémentées fonctionneront parfaitement: ports série, bus I <sup>2</sup> C, SPI en mode maître.  Dans l'esclave - uniquement si le maître permet un «roll-off» périodique de l'esclave de 25 à 35 μs.  Bien sûr, cela dépend toujours du nombre de «jambes» qui restent inoccupées après avoir connecté l'écran. <br><br>  L'USB sur 32u4 fonctionne très bien si vous n'interrogez pas trop souvent le point de terminaison de gestion (code de routine d'interruption lente).  Le pilote CDC et ses API étaient assez rapides. <br><br>  Ensuite, dans le fichier README.md sur GitHub, la liste des projets similaires est répétée, la même que sur la page du projet sur Hackaday.io <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444912/">https://habr.com/ru/post/fr444912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444902/index.html">Optimisation de la conception par des méthodes de la théorie de la commande automatique</a></li>
<li><a href="../fr444904/index.html">Récupération d'un mot de passe principal à partir d'un gestionnaire de mots de passe verrouillés SafeInCloud</a></li>
<li><a href="../fr444906/index.html">Lire indésirable</a></li>
<li><a href="../fr444908/index.html">Où cultiver les smartphones</a></li>
<li><a href="../fr444910/index.html">La stimulation sonore et lumineuse aide à combattre la maladie d'Alzheimer, chez la souris, mais les résultats sont encourageants</a></li>
<li><a href="../fr444916/index.html">N'a pas acheté de DLC: une fonction qui sauverait le 737 tombé, Boeing vendu en option</a></li>
<li><a href="../fr444918/index.html">Où les smartphones grandissent: une feuille de route pour devenir un ordinateur à part entière</a></li>
<li><a href="../fr444920/index.html">Le nouvel algorithme accélère 200 fois la conception automatique des réseaux de neurones</a></li>
<li><a href="../fr444922/index.html">Comment vous protéger contre l'hypnovirus</a></li>
<li><a href="../fr444924/index.html">Le premier WIAD à Moscou: comment ça s'est passé et ce dont ils ont parlé</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>