<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚽 ♣️ 👩‍👧‍👦 Wie wir mit ManageIQ Freunde in der Bankinfrastruktur gefunden haben 🤽🏻 🔘 🤸🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Jahren waren die Haupttrends Automatisierung, DevOps-Praktiken und die Beschleunigung der Bereitstellung von Werten auf dem Markt. Die Hom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir mit ManageIQ Freunde in der Bankinfrastruktur gefunden haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/homecredit/blog/461891/"><p>  Vor einigen Jahren waren die Haupttrends Automatisierung, DevOps-Praktiken und die Beschleunigung der Bereitstellung von Werten auf dem Markt.  Die Home Credit Bank entschied sich, mit der technologischen Entwicklung Schritt zu halten, zumal das offene Flüstern der Benutzer, die es satt hatten, mehrere Tage auf neue Ressourcen für ihre wichtigen Projekte zu warten, immer lauter wurde. </p><br><p>  Wir haben uns entschlossen, mit der Genehmigung von Anträgen durch Abteilungen zu beginnen, was wie in vielen großen Unternehmen Zeit und Mühe erfordert.  Als erste Aufgabe haben wir den Prozess der Erstellung einer virtuellen Maschine unabhängig von der Virtualisierungsumgebung ausgewählt.  Bei der Erstellung einer Liste von Aufgaben wurde uns klar, dass eine Integration in andere Systeme, die in der Infrastruktur unserer Bank verwendet werden, beispielsweise über eine API erforderlich ist. </p><br><p><img src="https://habrastorage.org/webt/tt/h7/br/tth7br6euodgo1dklwgmaqhdxu4.png" alt="Bild"></p><a name="habracut"></a><br><p> Die am besten geeignete Lösung war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ManageIQ</a> .  Dies ist ein Projekt, das Red Hat 2012 erworben hat und auf dessen Grundlage das kommerzielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat CloudForms-Produkt erstellt wurde</a> .  Gleichzeitig blieb ManageIQ im Status eines Open-Source-Produkts und entwickelt sich parallel zu CloudForms. </p><br><p>  ManageIQ ist in Ruby geschrieben und unterstützt eine Vielzahl verschiedener Anbieter von Virtualisierung, öffentlichen Clouds und Containerisierung.  Im Moment verwenden wir eine Version von Gaprindashvili in der Hochverfügbarkeitskonfiguration in Home. </p><br><h2>  Wie sich der Prozess verändert hat </h2><br><p>  Zuvor benötigte jedes Team separate Einstellungen in seinem Verantwortungsbereich.  Nach der vorläufigen Vorbereitung wurden alle Daten gesammelt und an den Administrator gesendet, der die virtuelle Maschine bereitgestellt und konfiguriert hat.  Dann musste beispielsweise das Überwachungsteam darüber informiert werden, dass ein neuer Host erschienen war, der zur Überwachung hinzugefügt werden musste.  Verzögerungen in der Kommunikation, die Arbeitsbelastung von Spezialisten und Fehler, die durch den menschlichen Faktor verursacht werden, können diesen Prozess auf mehrere Tage ausdehnen. </p><br><p>  Nachdem wir den gesamten Prozess in ManageIQ integriert haben, haben wir die folgenden Ergebnisse erhalten: </p><br><div class="scrollable-table"><table><thead><tr><th>  Typ der virtuellen Ressource </th><th>  Vor der Einführung von ManageIQ </th><th>  Nach der Implementierung von ManageIQ </th></tr></thead><tbody><tr><td>  Virtuelle Linux-Maschine in VMware / oVirt </td><td>  Zu einem </td><td>  ~ 10 Minuten </td></tr><tr><td>  Rancher-Umgebung für virtuelle Maschinen </td><td>  arbeiten </td><td>  ~ 15 Minuten </td></tr><tr><td>  Windows Virtual Machine in VMware </td><td>  Wochen </td><td>  ~ 25 Minuten </td></tr></tbody></table></div><br><p>  Der Zeitunterschied ist darauf zurückzuführen, dass im zweiten Fall zusätzliche Zeit erforderlich ist, um den Host auf die Arbeit mit Docker vorzubereiten, Images für Infrastrukturcontainer von Artifactory herunterzuladen und zu integrieren, da zu diesem Zeitpunkt noch kein Zugriff auf den Docker Hub besteht.  Im Fall von Windows wird der Unterschied dadurch erzielt, dass zum einen die Erstellungszeit einer Linux-VM ohne Anpassung ungefähr 2 Minuten und die einer Windows-VM 6 Minuten beträgt.  Zweitens dauert das Anpassen von Windows selbst etwa 10 Minuten gegenüber 2 Minuten für Linux. </p><br><p>  10 Minuten sind nicht so schnell, da ungefähr 2-3 Minuten direkt für die Erstellung einer VM aufgewendet werden.  Für die verbleibende Zeit schafft ManageIQ Folgendes: </p><br><ol><li>  Das System sammelt die vom Benutzer im Bestellformular angegebenen Parameter und zerlegt sie in Variablen. </li><li>  Im Incident Management System wird eine neue Änderungsanforderung erstellt, die Daten zur neuen Ressource anzeigt. </li><li>  Das ManageIQ-Ressourcennamen-Abfragesystem sendet einen Wert für eine neue Ressource. </li><li>  Das IP-Adressverwaltungssystem gibt basierend auf den eingegebenen Parametern eine neue Adresse aus. </li><li>  Ein neuer DNS-Eintrag wird auf dem lokalen DNS-Server registriert. </li><li>  Basierend auf den Parametern, der Umgebung und der Ressourcenlast werden der Virtualisierungstyp und der Cluster für die Platzierung ausgewählt. </li><li>  Als Nächstes wird eine virtuelle Maschine mit den angegebenen Parametern erstellt. </li><li>  Wenn die virtuelle Maschine über die Vorlage bereitgestellt wird, müssen Sie Skripts ausführen, mit denen die endgültigen Einstellungen vorgenommen werden: <br><ul><li>  Festplattenerweiterung auf eine bestimmte Größe, </li><li>  Generieren eines neuen Root-Passworts, Ändern auf einem Linux-Host und Schreiben in einen Passwort-Manager, </li><li>  Erstellen einer Konfigurations-YAML-Datei für Puppet in GitLab, </li><li>  Führen Sie Runbooks aus, die die erforderlichen Einstellungen und Updates für Windows-VMs oder bringen </li><li>  Starten Sie Puppet, mit dem Linux-Computer aktualisiert und konfiguriert werden. </li></ul></li><li>  Danach wird die in Schritt 2 erstellte Änderungsanforderung geschlossen.  Es werden neue Daten hinzugefügt, z. B. die IP-Adresse und der Hostname. </li><li>  Eine neue Einheit wird in der Compute Resource Management Base (CMDB) registriert. </li><li>  Die virtuelle Maschine wird in Zabbix registriert und zur Überwachung hinzugefügt. </li><li>  Der Kunde und andere Interessenten erhalten eine E-Mail mit Informationen zu der neuen Einheit, die mit ManageIQ erstellt wurde. </li></ol><br><h2 id="chto-vnutri">  Was ist drin? </h2><br><p>  Lassen Sie uns die technischen Details des Produkts untersuchen.  Standardmäßig kann ManageIQ eine virtuelle Maschine aus einer Vorlage erstellen.  Wie unterscheidet sich dies von dem, was wir beispielsweise in vCenter tun?  Die richtige Antwort ist nichts.  ManageIQ verwendet dieselben Methoden wie Virtualisierungssysteme, jedoch von einem einzigen Ort aus.  Darüber hinaus können Sie eigene Skripte hinzufügen, die nicht in die Standardfunktionen passen.  Wenn Sie also über Ressourcen verfügen, z. B. in öffentlichem Azure, in vCenter, das auf Ihrer eigenen Hardware bereitgestellt wird, und der Kubernetes-Cluster sich an einem anderen Ort dreht, kann dies alles bequem über ManageIQ verwaltet werden. </p><br><p>  Neben einer Vielzahl von Anbietern für die Integration verfügt ManageIQ über praktische Tools zur Anpassung.  So erstellen Sie beispielsweise praktische Formulare zur Lösung Ihres Problems: </p><br><p><img src="https://habrastorage.org/webt/ku/7y/l3/ku7yl3xi9trq-9wndv-ad_vlpvu.png"></p><br><p>  Dank dessen war es möglich, eine vollwertige Schnittstelle für die Bestellung einer virtuellen Maschine zu erstellen, in die alle erforderlichen Parameter eingepasst wurden: </p><br><p><img src="https://habrastorage.org/webt/v7/ey/tf/v7eytf_hbcxxjcpw4hvrzuwyzve.png"></p><br><p>  Wir wählen die Menge der Computerressourcen und das Betriebssystem aus und geben alle zusätzlichen Informationen ein, die für die Integration in externe Systeme erforderlich sind.  Darüber hinaus wählt das System mithilfe interner Mechanismen (etwas später) aus, wo neue Ressourcen platziert werden sollen: Das Rechenzentrum, der Cluster, der Host und der Datenspeicher werden abhängig von allen eingegebenen Parametern ausgewählt und die Ressourcen geladen. </p><br><p>  Vergessen Sie nicht, dass die Leute zu viele Ressourcen bestellen können oder gar nicht, was sie wirklich brauchen.  Hier kommt das System der Anfragen und Bestätigungen ins Spiel: </p><br><p><img src="https://habrastorage.org/webt/mj/yv/28/mjyv28hsy0ggf6t68jjdkgc8mwc.png"></p><br><p>  Alle vom Benutzer bestellten Ressourcen müssen von der verantwortlichen Person genehmigt werden.  In Home macht das eine Gruppe von Architekten. </p><br><h2 id="struktura-avtomatizacii">  Automatisierungsstruktur </h2><br><p>  Wenn Sie alle Automatisierungsprozesse in ManageIQ in kleine Teile zerlegen, werden Sie eine bestimmte Struktur bemerken. </p><br><h3 id="automate-domain">  Domain automatisieren </h3><br><img align="right" src="https://habrastorage.org/webt/xy/ea/c_/xyeac_nx3if-e4txuiuriic4h0w.png"><br><p>  Der Datenspeicher hostet alle Domänen von ManageIQ. </p><br><p>  Standardmäßig gibt es eine ManageIQ-Domäne, die gesperrt ist und so etwas wie ein Referenzmodell darstellt.  Wenn Sie Änderungen vornehmen müssen, wird eine andere Domäne erstellt, in die Elemente aus der ManageIQ-Domäne kopiert und für Ihre eigenen Aufgaben geändert werden. </p><br><h3 id="automate-namespace">  Namespace automatisieren </h3><br><img align="right" src="https://habrastorage.org/webt/yf/e1/t3/yfe1t3kjxb4rhvenndkfkwtsad4.png"><br><p>  Innerhalb sind Domänen in Teile unterteilt, die für einzelne Prozesse verantwortlich sind: Dies kann der Abschnitt sein, der für die Verwaltung der Infrastruktur (Infrastruktur) oder für die Arbeit mit Diensten (Dienst) verantwortlich ist.  Wir haben unseren eigenen Namespace, der alles enthält, was mit den Systemen der Bank zu tun hat. </p><br><p>  Betrachten Sie die Struktur am Beispiel des Bereitstellungsprozesses für eine neue virtuelle Maschine genauer.  Es wird in der Automate-Klasse mit dem Namen <em>VMProvision_VM beschrieben</em> . </p><br><h3 id="automate-class">  Klasse automatisieren </h3><br><p>  Die Klasse hat eine Struktur, die <strong>Instanzen</strong> , <strong>Methoden</strong> , <strong>Eigenschaften</strong> und <strong>Schema enthält</strong> .  Aus Sicht der Automatisierung ist Schema von größtem Interesse: <br><img src="https://habrastorage.org/webt/vm/jt/lf/vmjtlfd9qpyrqpdpemtxfw2yczs.png"></p><br><p>  Das Layout ähnelt der Pipeline in CI / CD-Systemen.  Es beschreibt die Schritte, die im Automatisierungsprozess ausgeführt werden. </p><br><h3 id="automate-instance">  Instanz automatisieren </h3><br><img align="right" src="https://habrastorage.org/webt/ie/wj/fj/iewjfjuzq9rplkcszwsh7wemsqu.png"><br><p>  Die oben beschriebene Klasse verfügt über zwei Automate Instance.  Jeder von ihnen erbt von der Schaltung die Stufen, für die der <em>Standardwert</em> eingestellt ist.  Stufen mit Nullwerten werden in der Instanz beschrieben. </p><br><p><img src="https://habrastorage.org/webt/wy/sl/5c/wysl5c2zze_9_sfplsnykplbf_m.png"></p><br><p>  In der Instanz wurden Werte für Schritte angezeigt, die in der Schemabeschreibung leer waren.  Sie können auch sehen, wer und wann die letzte Änderung vorgenommen hat. </p><br><p>  Mal sehen, was einer der Wertwerte darstellt: <br><img src="https://habrastorage.org/webt/rd/j_/v7/rdj_v7hc3wgt7dty2zckjltiacg.png"></p><br><p>  Dies ist eine Automate-Klasse namens Methods mit einer Automate-Instanz.  Das Diagramm beschreibt das Attribut <em>ipam_base_uri</em> und die Methode <em>execute</em> .  Die <em>execute-</em> Methode ruft wiederum die Automate-Methode <em>purchase_ip auf</em> . </p><br><h3 id="automate-method">  Methode automatisieren </h3><br><p>  Dies ist ein Ruby-Skript, mit dem eine virtuelle Maschine über die REST-API mit anderen Systemen kommunizieren kann.  Zum Beispiel wie beim IPAM-Adressraum-Managementsystem.  In IPAM erhalten wir die Adresse, Maske, das Subnetz und das VLAN für die VM.  Die Schwierigkeit besteht darin, dass der Computer in einer Testumgebung oder produktiv für Anwendungen oder Datenbanken bereitgestellt werden kann.  Oder vielleicht hat der Sicherheitsdienst beschlossen, es in die PCI-DSS-Schleife aufzunehmen.  Alle diese Informationen werden beim Erstellen der VM gesammelt oder in den Parametern der aufgerufenen Instanz übertragen (im obigen Screenshot sehen Sie, dass der Parameter die URL enthält, über die die Methode auf IPAM zugreift): </p><br><div class="spoiler">  <b class="spoiler_title">Hier ist ein Ruby-Code</b> <div class="spoiler_text"><pre><code class="ruby hljs">base_uri = $evm.object[<span class="hljs-string"><span class="hljs-string">'ipam_base_uri'</span></span>] prov = $evm.root[<span class="hljs-string"><span class="hljs-string">"miq_provision"</span></span>] site = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:site</span></span>) app = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_dropdown_list_information_system</span></span>) crq = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:crq</span></span>) descr = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_textarea_box_usernotes</span></span>) owner = $evm.root[<span class="hljs-string"><span class="hljs-string">'user'</span></span>].name scope = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_dropdown_scope</span></span>) environment = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:landscape</span></span>)</code> </pre> <br><p>  <em>$ evm.root</em> ist eine Methode, die alles zurückgibt, was in ManageIQ gespeichert werden kann.  Dies können Informationen über den Benutzer, die Umgebung, Variablen, die aktuelle Anforderung ('miq_request') usw. sein.  Wir interessieren uns für den aktuellen Bereitstellungsprozess. <br><img src="https://habrastorage.org/webt/4m/hz/lm/4mhzlmb6p_lvkagsl7apu41mpdm.png"></p><br><p>  Als nächstes können wir die erforderlichen Werte <em>abrufen</em> : <em>get_option (: site)</em> nimmt den Wert auf, der in einer der vorherigen Phasen übertragen wurde, und <em>get_option (: dialog_dropdown_list_information_system) übernimmt</em> beispielsweise das Formular, das der Benutzer beim Bestellen neuer Ressourcen ausfüllt. <br>  Alle empfangenen Werte werden von Variablen im Anforderungshauptteil im JSON-Format übertragen: </p><br><pre> <code class="ruby hljs">options = { <span class="hljs-symbol"><span class="hljs-symbol">verify:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">body:</span></span> { <span class="hljs-string"><span class="hljs-string">"site"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{site}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"env"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{env}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"app"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{app}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"scope"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{scope}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"role"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{role}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"crq"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{crq}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"descr"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{descr}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"owner"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{owner}</span></span></span><span class="hljs-string">"</span></span>, }.to_json, }</code> </pre> <br><p>  Mit diesem Parametersatz bestimmt IPAM eindeutig, in welchem ​​VLAN sich die virtuelle Maschine befinden soll, und gibt die Netzwerkparameter zurück. </p></div></div><br><p>  ManageIQ empfängt nicht nur Daten für die richtige VM-Konfiguration, sondern kann auch zusätzliche Informationen generieren, um einige Einstellungen in der Phase der sogenannten Post-Bereitstellung vorzunehmen (nachdem die virtuelle Maschine bereitgestellt und gestartet wurde).  In Home verwenden wir Puppet, um Linux-Hostkonfigurationen zu verwalten.  Erstellen Sie für jede Recheneinheit eine GAML-Datei in YAML mit einer Reihe von Gruppen: </p><br><div class="spoiler">  <b class="spoiler_title">Noch etwas Ruby-Code</b> <div class="spoiler_text"><pre> <code class="ruby hljs">options = { <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Private-Token"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{api_token}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, } body = { <span class="hljs-string"><span class="hljs-string">"branch"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{branch}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"author_email"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"email@your.domain"</span></span>, <span class="hljs-string"><span class="hljs-string">"author_name"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ManageIQ Bot"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"commit_message"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"New host created by ManageIQ"</span></span>, } descr = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:long_description</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) &amp;&amp; descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - rancher\n - user-devops-UDCR"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - rancher\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$is_id}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Gruppen hängen vom Typ der virtuellen Maschine, der Umgebung, in der sie erstellt wird, und dem Informationssystem ab. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1i/hv/ig/1ihvigmykpbqlihq2l8oturxxk0.png"></div><br><p>  Nach erfolgreichem Abschluss des Vorgangs erhält der Benutzer eine E-Mail mit folgenden Informationen: <br><img src="https://habrastorage.org/webt/qf/j-/br/qfj-brpfqe1ukkcvrw_jdtdpigm.png"></p><br><p>  Der Text des Briefes kann auch durch Hinzufügen der erforderlichen Informationen angepasst werden. <br>  Wenn in einer der kritischen Phasen des Prozesses ein Fehler auftritt, können Sie eine Bedingung hinzufügen, die ausdrücklich angibt, dass der Prozess unterbrochen werden soll.  Wenn der Fehler keine schwerwiegenden Folgen hat, geben Sie auch an, was trotz des Problems fortgesetzt werden kann. </p><br><h2 id="logirovanie">  Protokollierung </h2><br><p>  ManageIQ schreibt Protokolle von allem, was verfolgt werden kann.  Der Automatisierungsprozess ist in automation.log geschrieben.  Darüber hinaus gibt es API-Protokolle, verschiedene Cloud-Anbieter, Sicherheitsprotokolle, sogar die Ausgabe des Befehls top wird protokolliert. </p><br><p>  Für jedes Ereignis in der Schaltung können Sie einen Protokolleintrag für deren Start und Ende konfigurieren: <br><img src="https://habrastorage.org/webt/tv/z0/yy/tvz0yyygspvyltb6d_x4ja00hpg.png"></p><br><p>  Darüber hinaus können Sie Ihre Nachrichten in die Protokolle schreiben: </p><br><pre> <code class="ruby hljs">$evm.log(<span class="hljs-symbol"><span class="hljs-symbol">:info</span></span>, <span class="hljs-string"><span class="hljs-string">"Call job status uri: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{item_uri}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{job_id}</span></span></span><span class="hljs-string">/api/json"</span></span>)</code> </pre> <br><p>  Dies ist sehr nützlich, wenn Sie über eine API auf Systeme zugreifen, um zu verstehen, warum ein Fehler aufgetreten ist.  Oder um den aktuellen Status eines längeren Prozesses zu verfolgen, z. B. das Ausführen eines Jenkins-Jobs oder eines SCCM-Runbooks: </p><br><pre> <code class="ruby hljs">$evm.log(<span class="hljs-symbol"><span class="hljs-symbol">:info</span></span>, <span class="hljs-string"><span class="hljs-string">"acquire_osname --- naming jobStatus: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{jobStatus}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> jobStatus.to_s == <span class="hljs-string"><span class="hljs-string">"Completed"</span></span></code> </pre> <br><p>  Sie können die Standardfunktionen für Ausnahmen verwenden, um in die Protokolle zu schreiben: </p><br><pre> <code class="ruby hljs">raise “VM <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified” <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> vm.<span class="hljs-literal"><span class="hljs-literal">nil</span></span>?</code> </pre> <br><p>  Standardmäßig werden alle Protokolle im Abschnitt / var / log / manageiq / * gespeichert, aber aus eigener Erfahrung kann ich sagen, dass die Suche nach einem Problem über Tail und Grep nicht die bequemste Lösung ist.  Da ManageIQ viele verschiedene Protokolle schreibt, sollten Sie darauf achten, Protokolle beispielsweise auf den ELK-Stapel umzuleiten. </p><br><h2 id="manageiq-api">  ManageIQ API </h2><br><p>  Neben einer benutzerfreundlichen Weboberfläche verfügt ManageIQ über eine funktionale API.  Damit haben wir beispielsweise das Problem gelöst, den Bezeichner der zu spezifizierenden Vorlage dynamisch zu bestimmen </p><br><div class="spoiler">  <b class="spoiler_title">beim Erstellen einer VM:</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vendor, os, ems)</span></span></span></span> user = <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{user}</span></span></span><span class="hljs-string">'</span></span> pass = <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{pass}</span></span></span><span class="hljs-string">'</span></span> options = { <span class="hljs-symbol"><span class="hljs-symbol">verify:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Accept"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"*/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"accept-encoding"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"gzip, deflate"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">basic_auth:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">username:</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{user}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">password:</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{pass}</span></span></span><span class="hljs-string">"</span></span> }, } response = HTTParty.get(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{host}</span></span></span><span class="hljs-string">/api/templates?filter[]=vendor=%27</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{vendor}</span></span></span><span class="hljs-string">%27&amp;filter[]=name=%27%2A</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{os}</span></span></span><span class="hljs-string">%2A%27&amp;filter[]=ems_id=%27</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ems}</span></span></span><span class="hljs-string">%27"</span></span>, options).to_s link = JSON.parse(response) link[<span class="hljs-string"><span class="hljs-string">"resources"</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|r|</span></span> $url = r[<span class="hljs-string"><span class="hljs-string">"href"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> response = HTTParty.get($url,options).to_s template = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{JSON.parse(response)[</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'id'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>+<span class="hljs-string"><span class="hljs-string">", "</span></span>+<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{JSON.parse(response)[</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'name'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> template <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Mit einer POST-Anfrage und der Angabe von Filtern für die Suche erhalten wir die gewünschte Vorlage. <br>  Zusätzlich zur Lösung interner Probleme können Sie neue API-Methoden zur Verwendung durch externe Systeme erstellen.  Zu Beginn des Artikels wurde der Prozess der Bestellung einer neuen virtuellen Maschine über die Weboberfläche gezeigt.  Und so sieht es aus, wenn Sie es tun </p><br><div class="spoiler">  <b class="spoiler_title">POST-Anfrage:</b> <div class="spoiler_text"><pre> <code class="ruby hljs">curl -X POST \ <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/Manageiq.hostname/api</span></span><span class="hljs-regexp"><span class="hljs-regexp">/service_catalogs/</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>/service_templates/<span class="hljs-number"><span class="hljs-number">31</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Authorization: Basic Token-Value'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{ "action": "order", "resource": { "radio_button_vcpu": "a_2", "radio_button_vram": "a_2", "hdd_size": "40", "dropdown_os": "CentOS", "text_box_filter": "dns", "dropdown_list_information_system": "DNS ", "text_box_validator": "OK (DNS )", "textarea_box_usernotes": " ", "dropdown_env": "production", "date_control_retirement_dt": "2022-05-21", "dropdown_scope": "-" } }'</span></span></code> </pre> </div></div><br><h2 id="zaklyuchenie">  Fazit </h2><br><h3 id="plyusy">  Vorteile: </h3><br><ul><li>  Unglaubliche Flexibilität: Mit ManageIQ können Sie nicht nur den Automatisierungsprozess nach Bedarf anpassen, sondern auch seinen visuellen Teil durch Hinzufügen zusätzlicher Schaltflächen, Felder usw. ändern. </li><li>  Eingebauter Code-Editor mit Syntaxhervorhebung und Codeüberprüfung.  Es schien mir eine sehr gute Lösung zu sein, wenn Sie schnell etwas reparieren müssen. </li><li>  Eine große Anzahl von Quellen, mit denen das System arbeiten kann.  Clouds: Amazon EC2, Google Compute Engine, Azure, OpenStack und VMware vCloud.  Infrastruktur: Microsoft SCVMM, OpenStack Platform Director, Red Hat Virtualization und VMware vCenter.  Container: Kubernetes, OpenShift. </li></ul><br><h3 id="minusy">  Nachteile: </h3><br><ul><li>  Die großen Fähigkeiten des Werkzeugs haben auch einen negativen Einfluss.  Nicht alle Dokumentationen sind gut strukturiert, und manchmal ist es schwierig herauszufinden, wo Sie nach dem suchen können, was Sie benötigen.  Es ist jedoch anzumerken, dass sich die Situation zum Besseren ändert, die Dokumentation ergänzt und verbessert wird. </li><li>  Kleine Gemeinde.  Wenn Sie auf ein ganz bestimmtes Problem stoßen, können Sie die Antwort möglicherweise nicht schnell „googeln“.  Oder überhaupt nicht erfolgreich. </li><li>  Ein Absatz, der aus den beiden vorhergehenden folgt.  Einige grundlegende Dinge, Einstellungen und Szenarien finden Sie in der Dokumentation oder im Internet, aber spezifischere und engere Fragen erforderten viel Zeit zum Verstehen und Studieren, einschließlich der Methode des wissenschaftlichen Stocherns: Lächeln :. </li></ul><br><h3 id="kak-u-nas-seychas">  Wie wir jetzt haben: </h3><br><p>  Aufgrund der Tatsache, dass ManageIQ die Ruby-Sprache voll ausnutzen kann, konnten wir sie integrieren, um mit den folgenden APIs zu arbeiten: </p><br><ul><li>  Passwort-Manager  Es generiert ein Root-Kennwort gemäß den Anforderungen des Sicherheitsdienstes, schreibt es in seine Datenbank und ManageIQ verwendet es im Betriebssystem. </li><li>  Service Center Orchestration-Dienste zum Verwalten von DNS-Einträgen und Hostnamen; </li><li>  BMC Abhilfe.  Der gesamte Prozess wird als Kommentar zur Anfrage aufgezeichnet.  Nach erfolgreicher Ausführung wird die Anforderung geschlossen. </li><li>  CMDB  Informationen zu neuen Konfigurationseinheiten werden in der Datenbank mit allen erforderlichen Daten erstellt. </li><li>  Zabbix  Abhängig von der Zugehörigkeit zum Informationssystem und zur Umgebung werden Hosts zu den entsprechenden Überwachungsgruppen hinzugefügt. </li><li>  Rancher.  Implementierung der Erstellung neuer Umgebungen, Installation von Agenten und Registrierung von Hosts in vorhandenen Umgebungen. </li><li>  Jenkins  Jenkins führt Jobs aus, um VMs in oVirt zu konfigurieren. </li><li>  LDAP  Erstellen Sie neue Gruppen, mit denen der Zugriff in Rancher-Umgebungen gesteuert und Richtlinien in Vault konfiguriert werden. </li><li>  Gewölbe  In Home hat die Integration dieses Produkts in Bankprozesse gerade erst begonnen, aber wir haben bereits Methoden zum Erstellen neuer Gruppen, Richtlinien und Abschnitte für die Speicherung entwickelt. </li><li>  Marionette und IPAM wurden bereits erwähnt. </li></ul><br><p>  Die Funktionen und Fähigkeiten des Systems sind sehr umfangreich, und ich habe viele davon kennengelernt und bin weiterhin mit der Implementierung des Systems vertraut. <br>  Ich habe beispielsweise nicht erwähnt, dass das System eigene Dashboards mit Statistiken, Abrechnungseinstellungen oder Schaltflächen erstellen kann, an die Sie einzelne oder ganze Skripte anhängen können.  Sie können eigene Felder hinzufügen, um zusätzliche Informationen zu Diensten und virtuellen Maschinen usw. aufzuzeichnen. </p><br><h3 id="k-chemu-stremitsya-houm">  Was Home anstrebt: </h3><br><ul><li>  Ein Upgrade auf die Hammer-Version, in der Sie im HA-Modus versuchen können, mit dem integrierten Ansible zu arbeiten. </li><li>  Der Übergang von der Koordination für jede Einheit virtueller Ressourcen zum Management.  Teams können neue VMs noch schneller erhalten, wenn das Kontingent nicht ausgeschöpft ist. </li><li>  Entwicklung neuer Methoden zur weiteren Bereitstellung für externe Systeme. </li><li>  Zum Beispiel verschiedene SaaS wie Jenkins, Logstash usw. </li><li>  Implementierung neuer API-Methoden in einem bestehenden Portal für Eigentümer von Informationssystemen.  Benutzer müssen nicht über die Integration in das neue Infrastrukturelement nachdenken, sondern verwenden es lediglich als Service, um neue Ressourcen zu erhalten oder vorhandene zu ändern. </li></ul><br><p>  <em>Ganz am Ende möchte ich Sie daran erinnern, dass Tools großartig sind, aber vergessen Sie nicht, wie wichtig die Interaktion zwischen verschiedenen Teams ist.</em>  <em>Die im Artikel beschriebenen Änderungen wären ohne eine gut etablierte Kommunikation und ständige Interaktion zu aufkommenden Themen aller interessierten Parteien nicht möglich gewesen.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461891/">https://habr.com/ru/post/de461891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461877/index.html">Java vs Kotlin für Android: Meinungen von Entwicklern</a></li>
<li><a href="../de461879/index.html">Das Buch "Linux in Aktion"</a></li>
<li><a href="../de461881/index.html">Node.js Protokollierungshandbuch</a></li>
<li><a href="../de461885/index.html">EDS ist eine andere Art von Betrug</a></li>
<li><a href="../de461887/index.html">Eingabe von Aeronet Episode 2: Homing Drone</a></li>
<li><a href="../de461895/index.html">Lernen Sie während der Reise - wie wir am 1. European Business Analysis Day gefahren sind</a></li>
<li><a href="../de461897/index.html">Wie wir die Stabilität der Lamoda-Anwendung aufrechterhalten</a></li>
<li><a href="../de461899/index.html">Event Generation, CQRS und Laravel</a></li>
<li><a href="../de461901/index.html">Drei Jahre Autotests: Wie man die Geschwindigkeit erhöht und nicht nur</a></li>
<li><a href="../de461903/index.html">Geheimnisvoller Gegner: Fuzzy-Ausleihe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>