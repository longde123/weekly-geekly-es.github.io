<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Protecci贸n sin miedo. Seguridad de memoria en 贸xido   ю</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El a帽o pasado, Mozilla lanz贸 Quantum CSS para Firefox, la culminaci贸n de ocho a帽os de desarrollo de Rust, un lenguaje de programaci贸n de sistemas amig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protecci贸n sin miedo. Seguridad de memoria en 贸xido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438288/"> El a帽o pasado, Mozilla lanz贸 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quantum CSS</a> para Firefox, la culminaci贸n de ocho a帽os de desarrollo de Rust, un lenguaje de programaci贸n de sistemas amigable con la memoria.  Tom贸 m谩s de un a帽o reescribir el componente principal del navegador en Rust. <br><br>  Hasta ahora, todos los principales motores de navegador est谩n escritos en C ++, principalmente por razones de eficiencia.  Pero el gran rendimiento conlleva una gran responsabilidad: los programadores de C ++ deben administrar manualmente la memoria, lo que abre el cuadro de vulnerabilidad de Pandora.  Rust no solo corrige dichos errores, sino que sus m茅todos tambi茅n evitan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las carreras de datos</a> , lo que permite a los programadores implementar de manera m谩s eficiente el c贸digo paralelo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/3c1/378/8bb3c13783ff1502b161e92f5818c2aa.jpg"></div><a name="habracut"></a><br><h1>  驴Qu茅 es la seguridad de la memoria? </h1><br>  Cuando hablamos de crear aplicaciones seguras, a menudo mencionamos la seguridad de la memoria.  Extraoficialmente, queremos decir que en ning煤n estado el programa puede acceder a memoria no v谩lida.  Causas de violaciones de seguridad: <br><br><ul><li>  guardar el puntero despu茅s de liberar memoria (use-after-free); <br></li><li>  desreferenciar un puntero nulo; <br></li><li>  uso de memoria no inicializada; <br></li><li>  intento del programa para liberar la misma celda dos veces (doblemente libre); <br></li><li>  desbordamiento de b煤fer. </li></ul><br>  Para una definici贸n m谩s formal, vea Michael Hicks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">'What is Memory Security'</a> , as铆 como un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art铆culo cient铆fico</a> sobre este tema. <br><br>  Dichas violaciones pueden provocar un bloqueo inesperado o un cambio en el comportamiento esperado del programa.  Consecuencias potenciales: fuga de informaci贸n, ejecuci贸n de c贸digo arbitrario y ejecuci贸n remota de c贸digo. <br><br><h1>  Gesti贸n de la memoria </h1><br>  La gesti贸n de la memoria es cr铆tica para el rendimiento y la seguridad de la aplicaci贸n.  En esta secci贸n, consideramos el modelo b谩sico de memoria.  Uno de los conceptos clave son los <i>punteros</i> .  Estas son variables en las que se almacenan las direcciones de memoria.  Si vamos a esta direcci贸n, veremos algunos datos all铆.  Por lo tanto, decimos que el puntero es una referencia a estos datos (o los se帽ala).  As铆 como la direcci贸n de la casa le dice a las personas d贸nde encontrarlo, la direcci贸n de la memoria muestra al programa d贸nde encontrar los datos. <br><br>  Todo en el programa se encuentra en direcciones de memoria espec铆ficas, incluidas las instrucciones de c贸digo.  El uso incorrecto de los punteros puede generar serias vulnerabilidades, incluida la filtraci贸n de informaci贸n y la ejecuci贸n de c贸digo arbitrario. <br><br><h3>  Asignaci贸n / Liberaci贸n </h3><br>  Cuando creamos una variable, el programa debe asignar suficiente espacio en la memoria para almacenar los datos de esta variable.  Como cada proceso tiene una cantidad limitada de memoria, por supuesto, necesita una forma de <i>liberar</i> recursos.  Cuando se libera la memoria, est谩 disponible para almacenar nuevos datos, pero los datos antiguos permanecen all铆 hasta que se sobrescribe la celda. <br><br><h3>  Tampones </h3><br>  <i>Un b煤fer</i> es un 谩rea de memoria contigua en la que se almacenan varias instancias del mismo tipo de datos.  Por ejemplo, la frase "Mi gato es Batman" se almacenar谩 en un b煤fer de 16 bytes.  Las memorias intermedias est谩n determinadas por la direcci贸n de inicio y la longitud.  Para no da帽ar los datos en la memoria vecina, es importante asegurarse de que no leemos ni escribimos fuera del b煤fer. <br><br><h3>  Flujo de control </h3><br>  Los programas consisten en rutinas que se ejecutan en un orden espec铆fico.  Al final de la subrutina, la computadora va al puntero almacenado a la siguiente parte del c贸digo (llamada <i>direcci贸n de retorno</i> ).  Cuando va a la direcci贸n del remitente, ocurre una de tres cosas: <br><br><ol><li>  El proceso contin煤a normalmente (la direcci贸n del remitente no cambia). <br></li><li>  El proceso se bloquea (la direcci贸n ha sido cambiada y apunta a memoria no ejecutable). <br></li><li>  El proceso contin煤a, pero no como se esperaba (la direcci贸n de retorno ha cambiado y el flujo de control ha cambiado). </li></ol><br><h1>  C贸mo los idiomas proporcionan seguridad de memoria </h1><br>  Todos los lenguajes de programaci贸n pertenecen a diferentes partes del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espectro</a> .  Por un lado del espectro hay lenguajes como C / C ++.  Son efectivos, pero requieren administraci贸n manual de memoria.  Por otro lado, los idiomas interpretados con administraci贸n autom谩tica de memoria (por ejemplo, conteo de referencias y recolecci贸n de basura (GC)), pero dan resultado con el rendimiento.  Incluso los idiomas con recolecci贸n de basura bien optimizada no se pueden comparar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rendimiento</a> con los idiomas sin GC. <br><br><h3>  Gesti贸n manual de memoria </h3><br>  Algunos lenguajes (por ejemplo, C) requieren que los programadores administren manualmente la memoria: cu谩ndo y cu谩nta memoria asignar, cu谩ndo liberarla.  Esto le da al programador un control completo sobre c贸mo el programa usa los recursos, proporcionando un c贸digo r谩pido y eficiente.  Pero este enfoque es propenso a errores, especialmente en bases de c贸digo complejas. <br><br>  Errores que son f谩ciles de cometer: <br><br><ul><li>  olvide que los recursos son gratuitos y trate de usarlos; <br></li><li>  no asigne suficiente espacio para el almacenamiento de datos; <br></li><li>  leer memoria fuera del b煤fer. </li></ul><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/657/0a0/242/6570a02427a2d03632cb41c73aa5a48d.jpg"></a> </div><br>  <i><font color="gray">Instrucciones de seguridad adecuadas para quienes manejan la memoria manualmente</font></i> <br><br><h3>  Punteros inteligentes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los punteros inteligentes</a> proporcionan informaci贸n adicional para evitar la gesti贸n incorrecta de la memoria.  Se utilizan para la gesti贸n autom谩tica de la memoria y la verificaci贸n de bordes.  A diferencia de un puntero normal, un puntero inteligente puede autodestruirse y no esperar谩 a que el programador lo elimine manualmente. <br><br>  Hay varias opciones para tal construcci贸n, que envuelve el puntero original en varias abstracciones 煤tiles.  Algunos punteros inteligentes <i>cuentan referencias</i> a cada objeto, mientras que otros implementan una pol铆tica de alcance para limitar la vida 煤til del puntero a ciertas condiciones. <br><br>  Al contar enlaces, los recursos se liberan cuando se elimina la 煤ltima referencia al objeto.  Las implementaciones b谩sicas de conteo de referencias adolecen de bajo rendimiento, mayor consumo de memoria y son dif铆ciles de usar en entornos de subprocesos m煤ltiples.  Si los objetos se refieren entre s铆 (enlaces circulares), el recuento de referencia para cada objeto nunca llegar谩 a cero, por lo que se requieren m茅todos m谩s complejos. <br><br><h1>  Recolecci贸n de basura </h1><br>  Algunos lenguajes (por ejemplo, Java, Go, Python) implementan la <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recolecci贸n de basura</a></i> .  Una parte del tiempo de ejecuci贸n llamada recolector de basura (GC) monitorea las variables e identifica recursos inaccesibles en el gr谩fico de enlaces entre objetos.  Tan pronto como el objeto no est茅 disponible, el GC libera memoria base para su futura reutilizaci贸n.  Cualquier asignaci贸n y liberaci贸n de memoria ocurre sin un comando expl铆cito del programador. <br><br>  Aunque el GC garantiza que la memoria siempre se use correctamente, no libera la memoria de la manera m谩s eficiente; a veces, el 煤ltimo uso de un objeto ocurre mucho antes de que el recolector de basura libere la memoria.  Los costos de rendimiento son prohibitivos para aplicaciones de misi贸n cr铆tica: a veces es necesario usar 5 veces m谩s memoria para evitar la degradaci贸n del rendimiento. <br><br><h3>  Posesi贸n </h3><br>  Rust utiliza la propiedad para garantizar un alto rendimiento y seguridad de la memoria.  M谩s formalmente, este es un ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mecanograf铆a</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afinidad</a> .  Todo el c贸digo Rust sigue ciertas reglas que permiten al compilador administrar la memoria sin perder tiempo de ejecuci贸n: <br><br><ol><li>  Cada valor tiene una variable llamada propietario. <br></li><li>  Solo un propietario puede ser a la vez. <br></li><li>  Cuando el propietario se mueve fuera del alcance, el valor se elimina. </li></ol><br>  Los valores pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transferirse</a> o tomarse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prestados</a> de una variable a otra.  Estas reglas se aplican a una parte del compilador llamada verificador de pr茅stamos. <br><br>  Cuando una variable queda fuera de alcance, Rust libera esta memoria.  En el siguiente ejemplo, las variables <code>s1</code> y <code>s2</code> van m谩s all谩 del alcance, ambas intentan liberar la misma memoria, lo que conduce a un error de doble liberaci贸n.  Para evitar esto, al transferir un valor de una variable, el propietario anterior se vuelve inv谩lido.  Si el programador intenta utilizar una variable no v谩lida, el compilador rechazar谩 el c贸digo.  Esto se puede evitar creando una copia profunda de los datos o utilizando enlaces. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo 1</a> : Transferencia de propiedad <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s2 = s1; <span class="hljs-comment"><span class="hljs-comment">//won't compile because s1 is now invalid println!("{}, world!", s1);</span></span></code> </pre> <br>  Otro conjunto de reglas de verificaci贸n de pr茅stamos se relaciona con la vida 煤til de las variables.  Rust proh铆be el uso de variables no inicializadas y punteros colgantes a objetos inexistentes.  Si compila el c贸digo del ejemplo a continuaci贸n, <code>r</code> se referir谩 a una memoria que se libera cuando <code>x</code> sale del alcance: se produce un puntero colgante.  El compilador monitorea todas las 谩reas y verifica la validez de todas las transferencias, a veces requiere que el programador indique expl铆citamente la vida 煤til de la variable. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo 2</a> : puntero colgante <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; r = &amp;x; } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"r: {}"</span></span>, r);</code> </pre> <br>  El modelo de propiedad proporciona una base s贸lida para el acceso correcto a la memoria, evitando comportamientos indefinidos. <br><br><h1>  Vulnerabilidades de memoria </h1><br>  Las principales consecuencias de la memoria vulnerable: <br><br><ol><li>  <b>Bloqueo</b> : acceder a memoria no v谩lida puede provocar la finalizaci贸n inesperada de la aplicaci贸n. <br></li><li>  <b>Fuga de informaci贸n</b> : provisi贸n involuntaria de datos privados, incluida informaci贸n confidencial, como contrase帽as. <br></li><li>  <b>Ejecuci贸n de c贸digo arbitrario (ACE)</b> : permite a un atacante ejecutar comandos arbitrarios en la m谩quina de destino.  Si esto sucede a trav茅s de la red, lo llamamos Ejecuci贸n remota de c贸digo (RCE). </li></ol><br>  Otro problema es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una p茅rdida de memoria</a> cuando la memoria asignada no se libera despu茅s de que finaliza el programa.  Por lo tanto, puede usar toda la memoria disponible: las solicitudes de recursos se bloquean, lo que provocar谩 una denegaci贸n de servicio.  Este es un problema de memoria que no se puede resolver a nivel de PL. <br><br>  En el mejor de los casos, con un error de memoria, la aplicaci贸n se bloquear谩.  En el peor de los casos, un atacante obtiene el control de un programa a trav茅s de una vulnerabilidad (que podr铆a conducir a m谩s ataques). <br><br><h3>  Abusos de la memoria liberada (uso libre posterior, doble libre) </h3><br>  Esta subclase de vulnerabilidades se produce cuando se libera un recurso, pero a煤n se conserva un enlace a su direcci贸n.  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">poderoso m茅todo de hackers</a> que puede conducir a un acceso fuera de rango, fuga de informaci贸n, ejecuci贸n de c贸digo y mucho m谩s. <br><br>  Los idiomas con recolecci贸n de basura y conteo de referencias evitan el uso de punteros inv谩lidos, destruyendo solo objetos inaccesibles (que pueden conducir a la degradaci贸n del rendimiento), y los lenguajes controlados manualmente son susceptibles a esta vulnerabilidad (especialmente en bases de c贸digo complejas).  La herramienta de verificaci贸n de pr茅stamos en Rust no permite que los objetos se destruyan mientras se hace referencia, por lo que estos errores se eliminan en la etapa de compilaci贸n. <br><br><h3>  Variables no inicializadas </h3><br>  Si la variable se usa antes de la inicializaci贸n, estos datos pueden contener cualquier dato, incluyendo basura aleatoria o datos previamente descartados, lo que conduce a una fuga de informaci贸n (a veces se los llama <i>punteros no v谩lidos</i> ).  Para evitar estos problemas, los lenguajes de administraci贸n de memoria a menudo usan el procedimiento de inicializaci贸n autom谩tica despu茅s de asignar memoria. <br><br>  Como en C, la mayor铆a de las variables en Rust no se inicializan inicialmente.  Pero a diferencia de C, no puede leerlos antes de la inicializaci贸n.  El siguiente c贸digo no se compila: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo 3</a> : uso de una variable no inicializada <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); }</code> </pre> <br><h3>  Punteros nulos </h3><br>  Cuando una aplicaci贸n desreferencia un puntero que resulta ser nulo, generalmente solo accede a la basura y provoca un bloqueo.  En algunos casos, estas vulnerabilidades pueden conducir a la ejecuci贸n de c贸digo arbitrario ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a> ).  Rust tiene dos tipos de punteros: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlaces</a> y punteros sin formato.  Los enlaces son seguros, pero los punteros sin formato pueden ser un problema. <br><br>  Rust evita la desreferenciaci贸n de un puntero nulo de dos maneras: <br><br><ol><li>  Evite punteros anulables. <br></li><li>  Evite desreferenciar punteros sin formato. </li></ol><br>  Rust evita punteros nulos al reemplazarlos con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code> Option</code></a> especial.  Para cambiar el valor nulo posible en el tipo <code>Option</code> , el lenguaje requiere que el programador maneje expl铆citamente el caso con un valor nulo; de lo contrario, el programa no se compilar谩. <br><br>  驴Qu茅 hacer si no se pueden evitar los punteros que permiten un valor nulo (por ejemplo, al interactuar con el c贸digo en otro idioma)?  Intenta aislar el da帽o.  La desreferenciaci贸n de punteros sin procesar debe ocurrir en un bloque inseguro aislado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Afloja las reglas Rust</a> y resuelve algunas operaciones que pueden causar un comportamiento indefinido (por ejemplo, desreferenciar un puntero sin formato). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e58/bd7/b69/e58bd7b69e8f2f399e431bdb4f6d151f.jpg"></div><br>  <i><font color="gray">"Todo sobre el chekcer prestado ... 驴qu茅 pasa con ese lugar oscuro?"</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray">- Este es un bloque inseguro.</font></i>  <i><font color="gray">Nunca vayas, Simba</font></i> <br><br><h3>  Desbordamiento de b煤fer </h3><br>  Discutimos vulnerabilidades que pueden evitarse restringiendo el acceso a la memoria indefinida.  Pero el problema es que el desbordamiento del b煤fer no accede correctamente a la memoria indefinida, sino legalmente asignada.  Al igual que el error use-after-free, dicho acceso puede ser un problema porque accede a la memoria liberada, que a煤n contiene informaci贸n confidencial que ya no deber铆a existir. <br><br>  Los desbordamientos del b煤fer simplemente significan acceso fuera de los l铆mites.  Debido a la forma en que se almacenan las memorias intermedias en la memoria, a menudo filtran informaci贸n que puede contener datos confidenciales, incluidas contrase帽as.  En casos m谩s graves, las vulnerabilidades ACE / RCE son posibles sobrescribiendo el puntero de instrucci贸n. <br><br>  Ejemplo 4: desbordamiento de b煤fer (c贸digo C) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// print out of bounds printf("Out of bounds: %d\n", buf[10]); // write out of bounds buf[10] = 10; printf("Out of bounds: %d\n", buf[10]); return 0; }</span></span></code> </pre> <br>  La protecci贸n m谩s simple contra los desbordamientos del b煤fer es exigir siempre controles de borde al acceder a los elementos, pero esto conduce a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bajo rendimiento</a> . <br><br>  驴Qu茅 hace el 贸xido?  Los tipos de b煤fer integrados en la biblioteca est谩ndar requieren controles de bordes para cualquier acceso aleatorio, pero tambi茅n proporcionan API de iterador para acelerar las llamadas secuenciales.  Esto asegura que leer y escribir fuera de los l铆mites no sea posible para estos tipos.  Rust promueve patrones que requieren controles de borde solo en lugares donde es casi seguro que tenga que colocarlos manualmente en C / C ++. <br><br><h1>  La seguridad de la memoria es solo la mitad de la batalla </h1><br>  Las infracciones de seguridad conducen a vulnerabilidades como la fuga de datos y la ejecuci贸n remota de c贸digo.  Hay varias formas de proteger la memoria, incluidos punteros inteligentes y recolecci贸n de basura.  Incluso puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">probar formalmente la seguridad de la memoria</a> .  Si bien algunos idiomas han llegado a un acuerdo con la degradaci贸n del rendimiento en aras de la seguridad de la memoria, el concepto de propiedad de Rust proporciona seguridad y minimiza los gastos generales. <br><br>  Desafortunadamente, los errores de memoria son solo una parte de la historia cuando hablamos de escribir c贸digo seguro.  En el pr贸ximo art铆culo, consideraremos la seguridad de subprocesos y los ataques a c贸digo paralelo. <br><br><h1>  Explotaci贸n de vulnerabilidades de memoria: recursos adicionales </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mont贸n de memoria y explotaci贸n</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Destrucci贸n de una pila desde una posici贸n de hacker</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analog铆as de seguridad de la informaci贸n</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci贸n a las vulnerabilidades de uso libre</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438288/">https://habr.com/ru/post/438288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438272/index.html">C贸mo enviamos SMS desde la cueva</a></li>
<li><a href="../438274/index.html">Definici贸n de "personalidad t贸xica" en TI</a></li>
<li><a href="../438278/index.html">Ense帽ar a los ni帽os a programar</a></li>
<li><a href="../438280/index.html">"Eliminar" objetos en Django</a></li>
<li><a href="../438286/index.html">Trabajando con zonas horarias en JavaScript</a></li>
<li><a href="../438290/index.html">Post-mortem con GGJ-2019: c贸mo obtener golpes, pero a煤n as铆 hacer el juego</a></li>
<li><a href="../438292/index.html">Automatizaci贸n de apartamentos con HomePod, Raspberry Pi y Node.js</a></li>
<li><a href="../438294/index.html">Encontrar Twitch Streamers en una partida de PUBG</a></li>
<li><a href="../438296/index.html">OpenSceneGraph: Sistema de complementos</a></li>
<li><a href="../438298/index.html">驴Por qu茅 ense帽ar si el desarrollo es m谩s rentable? Conversaci贸n con GeekBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>