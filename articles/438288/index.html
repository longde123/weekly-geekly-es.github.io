<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛕 🍞 👝 Protección sin miedo. Seguridad de memoria en óxido 👀 🦆 👧🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El año pasado, Mozilla lanzó Quantum CSS para Firefox, la culminación de ocho años de desarrollo de Rust, un lenguaje de programación de sistemas amig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protección sin miedo. Seguridad de memoria en óxido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438288/"> El año pasado, Mozilla lanzó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quantum CSS</a> para Firefox, la culminación de ocho años de desarrollo de Rust, un lenguaje de programación de sistemas amigable con la memoria.  Tomó más de un año reescribir el componente principal del navegador en Rust. <br><br>  Hasta ahora, todos los principales motores de navegador están escritos en C ++, principalmente por razones de eficiencia.  Pero el gran rendimiento conlleva una gran responsabilidad: los programadores de C ++ deben administrar manualmente la memoria, lo que abre el cuadro de vulnerabilidad de Pandora.  Rust no solo corrige dichos errores, sino que sus métodos también evitan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las carreras de datos</a> , lo que permite a los programadores implementar de manera más eficiente el código paralelo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/3c1/378/8bb3c13783ff1502b161e92f5818c2aa.jpg"></div><a name="habracut"></a><br><h1>  ¿Qué es la seguridad de la memoria? </h1><br>  Cuando hablamos de crear aplicaciones seguras, a menudo mencionamos la seguridad de la memoria.  Extraoficialmente, queremos decir que en ningún estado el programa puede acceder a memoria no válida.  Causas de violaciones de seguridad: <br><br><ul><li>  guardar el puntero después de liberar memoria (use-after-free); <br></li><li>  desreferenciar un puntero nulo; <br></li><li>  uso de memoria no inicializada; <br></li><li>  intento del programa para liberar la misma celda dos veces (doblemente libre); <br></li><li>  desbordamiento de búfer. </li></ul><br>  Para una definición más formal, vea Michael Hicks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">'What is Memory Security'</a> , así como un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo científico</a> sobre este tema. <br><br>  Dichas violaciones pueden provocar un bloqueo inesperado o un cambio en el comportamiento esperado del programa.  Consecuencias potenciales: fuga de información, ejecución de código arbitrario y ejecución remota de código. <br><br><h1>  Gestión de la memoria </h1><br>  La gestión de la memoria es crítica para el rendimiento y la seguridad de la aplicación.  En esta sección, consideramos el modelo básico de memoria.  Uno de los conceptos clave son los <i>punteros</i> .  Estas son variables en las que se almacenan las direcciones de memoria.  Si vamos a esta dirección, veremos algunos datos allí.  Por lo tanto, decimos que el puntero es una referencia a estos datos (o los señala).  Así como la dirección de la casa le dice a las personas dónde encontrarlo, la dirección de la memoria muestra al programa dónde encontrar los datos. <br><br>  Todo en el programa se encuentra en direcciones de memoria específicas, incluidas las instrucciones de código.  El uso incorrecto de los punteros puede generar serias vulnerabilidades, incluida la filtración de información y la ejecución de código arbitrario. <br><br><h3>  Asignación / Liberación </h3><br>  Cuando creamos una variable, el programa debe asignar suficiente espacio en la memoria para almacenar los datos de esta variable.  Como cada proceso tiene una cantidad limitada de memoria, por supuesto, necesita una forma de <i>liberar</i> recursos.  Cuando se libera la memoria, está disponible para almacenar nuevos datos, pero los datos antiguos permanecen allí hasta que se sobrescribe la celda. <br><br><h3>  Tampones </h3><br>  <i>Un búfer</i> es un área de memoria contigua en la que se almacenan varias instancias del mismo tipo de datos.  Por ejemplo, la frase "Mi gato es Batman" se almacenará en un búfer de 16 bytes.  Las memorias intermedias están determinadas por la dirección de inicio y la longitud.  Para no dañar los datos en la memoria vecina, es importante asegurarse de que no leemos ni escribimos fuera del búfer. <br><br><h3>  Flujo de control </h3><br>  Los programas consisten en rutinas que se ejecutan en un orden específico.  Al final de la subrutina, la computadora va al puntero almacenado a la siguiente parte del código (llamada <i>dirección de retorno</i> ).  Cuando va a la dirección del remitente, ocurre una de tres cosas: <br><br><ol><li>  El proceso continúa normalmente (la dirección del remitente no cambia). <br></li><li>  El proceso se bloquea (la dirección ha sido cambiada y apunta a memoria no ejecutable). <br></li><li>  El proceso continúa, pero no como se esperaba (la dirección de retorno ha cambiado y el flujo de control ha cambiado). </li></ol><br><h1>  Cómo los idiomas proporcionan seguridad de memoria </h1><br>  Todos los lenguajes de programación pertenecen a diferentes partes del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espectro</a> .  Por un lado del espectro hay lenguajes como C / C ++.  Son efectivos, pero requieren administración manual de memoria.  Por otro lado, los idiomas interpretados con administración automática de memoria (por ejemplo, conteo de referencias y recolección de basura (GC)), pero dan resultado con el rendimiento.  Incluso los idiomas con recolección de basura bien optimizada no se pueden comparar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rendimiento</a> con los idiomas sin GC. <br><br><h3>  Gestión manual de memoria </h3><br>  Algunos lenguajes (por ejemplo, C) requieren que los programadores administren manualmente la memoria: cuándo y cuánta memoria asignar, cuándo liberarla.  Esto le da al programador un control completo sobre cómo el programa usa los recursos, proporcionando un código rápido y eficiente.  Pero este enfoque es propenso a errores, especialmente en bases de código complejas. <br><br>  Errores que son fáciles de cometer: <br><br><ul><li>  olvide que los recursos son gratuitos y trate de usarlos; <br></li><li>  no asigne suficiente espacio para el almacenamiento de datos; <br></li><li>  leer memoria fuera del búfer. </li></ul><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/657/0a0/242/6570a02427a2d03632cb41c73aa5a48d.jpg"></a> </div><br>  <i><font color="gray">Instrucciones de seguridad adecuadas para quienes manejan la memoria manualmente</font></i> <br><br><h3>  Punteros inteligentes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los punteros inteligentes</a> proporcionan información adicional para evitar la gestión incorrecta de la memoria.  Se utilizan para la gestión automática de la memoria y la verificación de bordes.  A diferencia de un puntero normal, un puntero inteligente puede autodestruirse y no esperará a que el programador lo elimine manualmente. <br><br>  Hay varias opciones para tal construcción, que envuelve el puntero original en varias abstracciones útiles.  Algunos punteros inteligentes <i>cuentan referencias</i> a cada objeto, mientras que otros implementan una política de alcance para limitar la vida útil del puntero a ciertas condiciones. <br><br>  Al contar enlaces, los recursos se liberan cuando se elimina la última referencia al objeto.  Las implementaciones básicas de conteo de referencias adolecen de bajo rendimiento, mayor consumo de memoria y son difíciles de usar en entornos de subprocesos múltiples.  Si los objetos se refieren entre sí (enlaces circulares), el recuento de referencia para cada objeto nunca llegará a cero, por lo que se requieren métodos más complejos. <br><br><h1>  Recolección de basura </h1><br>  Algunos lenguajes (por ejemplo, Java, Go, Python) implementan la <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recolección de basura</a></i> .  Una parte del tiempo de ejecución llamada recolector de basura (GC) monitorea las variables e identifica recursos inaccesibles en el gráfico de enlaces entre objetos.  Tan pronto como el objeto no esté disponible, el GC libera memoria base para su futura reutilización.  Cualquier asignación y liberación de memoria ocurre sin un comando explícito del programador. <br><br>  Aunque el GC garantiza que la memoria siempre se use correctamente, no libera la memoria de la manera más eficiente; a veces, el último uso de un objeto ocurre mucho antes de que el recolector de basura libere la memoria.  Los costos de rendimiento son prohibitivos para aplicaciones de misión crítica: a veces es necesario usar 5 veces más memoria para evitar la degradación del rendimiento. <br><br><h3>  Posesión </h3><br>  Rust utiliza la propiedad para garantizar un alto rendimiento y seguridad de la memoria.  Más formalmente, este es un ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mecanografía</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afinidad</a> .  Todo el código Rust sigue ciertas reglas que permiten al compilador administrar la memoria sin perder tiempo de ejecución: <br><br><ol><li>  Cada valor tiene una variable llamada propietario. <br></li><li>  Solo un propietario puede ser a la vez. <br></li><li>  Cuando el propietario se mueve fuera del alcance, el valor se elimina. </li></ol><br>  Los valores pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transferirse</a> o tomarse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prestados</a> de una variable a otra.  Estas reglas se aplican a una parte del compilador llamada verificador de préstamos. <br><br>  Cuando una variable queda fuera de alcance, Rust libera esta memoria.  En el siguiente ejemplo, las variables <code>s1</code> y <code>s2</code> van más allá del alcance, ambas intentan liberar la misma memoria, lo que conduce a un error de doble liberación.  Para evitar esto, al transferir un valor de una variable, el propietario anterior se vuelve inválido.  Si el programador intenta utilizar una variable no válida, el compilador rechazará el código.  Esto se puede evitar creando una copia profunda de los datos o utilizando enlaces. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo 1</a> : Transferencia de propiedad <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s2 = s1; <span class="hljs-comment"><span class="hljs-comment">//won't compile because s1 is now invalid println!("{}, world!", s1);</span></span></code> </pre> <br>  Otro conjunto de reglas de verificación de préstamos se relaciona con la vida útil de las variables.  Rust prohíbe el uso de variables no inicializadas y punteros colgantes a objetos inexistentes.  Si compila el código del ejemplo a continuación, <code>r</code> se referirá a una memoria que se libera cuando <code>x</code> sale del alcance: se produce un puntero colgante.  El compilador monitorea todas las áreas y verifica la validez de todas las transferencias, a veces requiere que el programador indique explícitamente la vida útil de la variable. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo 2</a> : puntero colgante <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; r = &amp;x; } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"r: {}"</span></span>, r);</code> </pre> <br>  El modelo de propiedad proporciona una base sólida para el acceso correcto a la memoria, evitando comportamientos indefinidos. <br><br><h1>  Vulnerabilidades de memoria </h1><br>  Las principales consecuencias de la memoria vulnerable: <br><br><ol><li>  <b>Bloqueo</b> : acceder a memoria no válida puede provocar la finalización inesperada de la aplicación. <br></li><li>  <b>Fuga de información</b> : provisión involuntaria de datos privados, incluida información confidencial, como contraseñas. <br></li><li>  <b>Ejecución de código arbitrario (ACE)</b> : permite a un atacante ejecutar comandos arbitrarios en la máquina de destino.  Si esto sucede a través de la red, lo llamamos Ejecución remota de código (RCE). </li></ol><br>  Otro problema es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una pérdida de memoria</a> cuando la memoria asignada no se libera después de que finaliza el programa.  Por lo tanto, puede usar toda la memoria disponible: las solicitudes de recursos se bloquean, lo que provocará una denegación de servicio.  Este es un problema de memoria que no se puede resolver a nivel de PL. <br><br>  En el mejor de los casos, con un error de memoria, la aplicación se bloqueará.  En el peor de los casos, un atacante obtiene el control de un programa a través de una vulnerabilidad (que podría conducir a más ataques). <br><br><h3>  Abusos de la memoria liberada (uso libre posterior, doble libre) </h3><br>  Esta subclase de vulnerabilidades se produce cuando se libera un recurso, pero aún se conserva un enlace a su dirección.  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">poderoso método de hackers</a> que puede conducir a un acceso fuera de rango, fuga de información, ejecución de código y mucho más. <br><br>  Los idiomas con recolección de basura y conteo de referencias evitan el uso de punteros inválidos, destruyendo solo objetos inaccesibles (que pueden conducir a la degradación del rendimiento), y los lenguajes controlados manualmente son susceptibles a esta vulnerabilidad (especialmente en bases de código complejas).  La herramienta de verificación de préstamos en Rust no permite que los objetos se destruyan mientras se hace referencia, por lo que estos errores se eliminan en la etapa de compilación. <br><br><h3>  Variables no inicializadas </h3><br>  Si la variable se usa antes de la inicialización, estos datos pueden contener cualquier dato, incluyendo basura aleatoria o datos previamente descartados, lo que conduce a una fuga de información (a veces se los llama <i>punteros no válidos</i> ).  Para evitar estos problemas, los lenguajes de administración de memoria a menudo usan el procedimiento de inicialización automática después de asignar memoria. <br><br>  Como en C, la mayoría de las variables en Rust no se inicializan inicialmente.  Pero a diferencia de C, no puede leerlos antes de la inicialización.  El siguiente código no se compila: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo 3</a> : uso de una variable no inicializada <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); }</code> </pre> <br><h3>  Punteros nulos </h3><br>  Cuando una aplicación desreferencia un puntero que resulta ser nulo, generalmente solo accede a la basura y provoca un bloqueo.  En algunos casos, estas vulnerabilidades pueden conducir a la ejecución de código arbitrario ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a> ).  Rust tiene dos tipos de punteros: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlaces</a> y punteros sin formato.  Los enlaces son seguros, pero los punteros sin formato pueden ser un problema. <br><br>  Rust evita la desreferenciación de un puntero nulo de dos maneras: <br><br><ol><li>  Evite punteros anulables. <br></li><li>  Evite desreferenciar punteros sin formato. </li></ol><br>  Rust evita punteros nulos al reemplazarlos con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code> Option</code></a> especial.  Para cambiar el valor nulo posible en el tipo <code>Option</code> , el lenguaje requiere que el programador maneje explícitamente el caso con un valor nulo; de lo contrario, el programa no se compilará. <br><br>  ¿Qué hacer si no se pueden evitar los punteros que permiten un valor nulo (por ejemplo, al interactuar con el código en otro idioma)?  Intenta aislar el daño.  La desreferenciación de punteros sin procesar debe ocurrir en un bloque inseguro aislado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Afloja las reglas Rust</a> y resuelve algunas operaciones que pueden causar un comportamiento indefinido (por ejemplo, desreferenciar un puntero sin formato). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e58/bd7/b69/e58bd7b69e8f2f399e431bdb4f6d151f.jpg"></div><br>  <i><font color="gray">"Todo sobre el chekcer prestado ... ¿qué pasa con ese lugar oscuro?"</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray">- Este es un bloque inseguro.</font></i>  <i><font color="gray">Nunca vayas, Simba</font></i> <br><br><h3>  Desbordamiento de búfer </h3><br>  Discutimos vulnerabilidades que pueden evitarse restringiendo el acceso a la memoria indefinida.  Pero el problema es que el desbordamiento del búfer no accede correctamente a la memoria indefinida, sino legalmente asignada.  Al igual que el error use-after-free, dicho acceso puede ser un problema porque accede a la memoria liberada, que aún contiene información confidencial que ya no debería existir. <br><br>  Los desbordamientos del búfer simplemente significan acceso fuera de los límites.  Debido a la forma en que se almacenan las memorias intermedias en la memoria, a menudo filtran información que puede contener datos confidenciales, incluidas contraseñas.  En casos más graves, las vulnerabilidades ACE / RCE son posibles sobrescribiendo el puntero de instrucción. <br><br>  Ejemplo 4: desbordamiento de búfer (código C) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// print out of bounds printf("Out of bounds: %d\n", buf[10]); // write out of bounds buf[10] = 10; printf("Out of bounds: %d\n", buf[10]); return 0; }</span></span></code> </pre> <br>  La protección más simple contra los desbordamientos del búfer es exigir siempre controles de borde al acceder a los elementos, pero esto conduce a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bajo rendimiento</a> . <br><br>  ¿Qué hace el óxido?  Los tipos de búfer integrados en la biblioteca estándar requieren controles de bordes para cualquier acceso aleatorio, pero también proporcionan API de iterador para acelerar las llamadas secuenciales.  Esto asegura que leer y escribir fuera de los límites no sea posible para estos tipos.  Rust promueve patrones que requieren controles de borde solo en lugares donde es casi seguro que tenga que colocarlos manualmente en C / C ++. <br><br><h1>  La seguridad de la memoria es solo la mitad de la batalla </h1><br>  Las infracciones de seguridad conducen a vulnerabilidades como la fuga de datos y la ejecución remota de código.  Hay varias formas de proteger la memoria, incluidos punteros inteligentes y recolección de basura.  Incluso puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">probar formalmente la seguridad de la memoria</a> .  Si bien algunos idiomas han llegado a un acuerdo con la degradación del rendimiento en aras de la seguridad de la memoria, el concepto de propiedad de Rust proporciona seguridad y minimiza los gastos generales. <br><br>  Desafortunadamente, los errores de memoria son solo una parte de la historia cuando hablamos de escribir código seguro.  En el próximo artículo, consideraremos la seguridad de subprocesos y los ataques a código paralelo. <br><br><h1>  Explotación de vulnerabilidades de memoria: recursos adicionales </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Montón de memoria y explotación</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Destrucción de una pila desde una posición de hacker</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analogías de seguridad de la información</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducción a las vulnerabilidades de uso libre</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438288/">https://habr.com/ru/post/438288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438272/index.html">Cómo enviamos SMS desde la cueva</a></li>
<li><a href="../438274/index.html">Definición de "personalidad tóxica" en TI</a></li>
<li><a href="../438278/index.html">Enseñar a los niños a programar</a></li>
<li><a href="../438280/index.html">"Eliminar" objetos en Django</a></li>
<li><a href="../438286/index.html">Trabajando con zonas horarias en JavaScript</a></li>
<li><a href="../438290/index.html">Post-mortem con GGJ-2019: cómo obtener golpes, pero aún así hacer el juego</a></li>
<li><a href="../438292/index.html">Automatización de apartamentos con HomePod, Raspberry Pi y Node.js</a></li>
<li><a href="../438294/index.html">Encontrar Twitch Streamers en una partida de PUBG</a></li>
<li><a href="../438296/index.html">OpenSceneGraph: Sistema de complementos</a></li>
<li><a href="../438298/index.html">¿Por qué enseñar si el desarrollo es más rentable? Conversación con GeekBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>