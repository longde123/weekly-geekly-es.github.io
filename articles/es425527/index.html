<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçü§ù‚Äçüë®üèª üîà ü¶å Listas en Kotlin. Enfoque de Haskell üîè üë©üèº‚ÄçüöÄ üï¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell es un lenguaje totalmente funcional y extremadamente conciso. Cualquiera que haya intentado escribir c√≥digo en Haskell se da cuenta de lo conc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Listas en Kotlin. Enfoque de Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell es un lenguaje totalmente funcional y extremadamente conciso.  Cualquiera que haya intentado escribir c√≥digo en Haskell se da cuenta de lo conciso y elegante que es escribir lo mismo en un lenguaje imperativo.  Lograr lo mismo en Java, en mi opini√≥n, es imposible, pero Kotlin le permite moverse en esta direcci√≥n y probar un estilo totalmente funcional.  Podemos derivar todas las funciones complejas que podamos necesitar de la base inicial de las 3 funciones m√°s famosas: mapear, filtrar, reducir.  Adem√°s, cre√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> que puedes estudiar y ver las pruebas. <br><a name="habracut"></a><br>  Antes de comenzar, me gustar√≠a llamar la atenci√≥n sobre el hecho de que no vale la pena implementar un enfoque funcional de esta manera, porque el c√≥digo ser√° cr√≠ticamente lento y no debe usarse en aplicaciones de producci√≥n.  Ciertamente, hay opciones para mejorarlo, pero el prop√≥sito del art√≠culo no es revelar estas opciones, sino considerar un enfoque alternativo para escribir c√≥digo.  En cualquier caso, comprender este enfoque lo ayudar√° a trabajar con estructuras de datos recursivas, y puede apreciar la belleza y la elegancia de c√≥mo se lee el c√≥digo y cu√°nto m√°s f√°cil es comprenderlo. <br><br><h3>  Funciones b√°sicas </h3><br>  Las listas juegan un papel muy importante en el lenguaje y se les implementan muchas funciones √∫tiles.  Veamos algunos de ellos y c√≥mo se pueden implementar en Kotlin. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br>  Si hay elementos en la lista, devolveremos el primero, de lo contrario devolveremos un error. <br>  No tenemos la oportunidad de escribir dicho c√≥digo, pero, en general, si se mira de cerca, es muy similar a cuando la plantilla.  Tambi√©n usaremos la funci√≥n de extensi√≥n para luego poder usar este m√©todo en las listas y tener una forma un poco m√°s concisa de obtener el valor, sin los corchetes al final, como una llamada al m√©todo. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br>  Para usar convenientemente la recursividad, tambi√©n nos gustar√≠a dividir la lista en el primer elemento + todos los dem√°s.  Intentemos implementar la funci√≥n de cola para esto. <br><br>  As√≠ es como se ve en Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br>  Desafortunadamente, Kotlin no proporciona un nivel de coincidencia de patrones que los desarrolladores puedan describir con el mismo estilo, as√≠ que aqu√≠ tenemos que escribir un poco sobre cu√°ndo. <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br>  Es un poco deshonesto usar una funci√≥n de la biblioteca de idiomas, pero por otro lado, en cualquier caso, tendr√≠amos que escribir c√≥digo para este m√©todo, por lo que ser√≠a mejor usar m√©todos que ya funcionen. <br><br>  Ahora podemos dividir la lista en el primer elemento + el resto de la lista.  Tambi√©n necesitaremos la funci√≥n de concatenar la lista y un elemento, que luego se utilizar√° activamente para la conversi√≥n y otras operaciones en la lista. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br>  Ahora podemos agregar una lista al elemento al final, y nuestra implementaci√≥n de la funci√≥n de mapa funciona y est√° lista para usar.  Desafortunadamente, de nuevo, no hay forma de agregar un objeto a la lista de una manera m√°s conveniente, por lo que utilizamos el m√©todo <b>add</b> . <br><br>  Por el momento tenemos casi todo lo que necesitamos.  Lo √∫nico que necesitamos ahora es poder describir la condici√≥n l√≠mite para salir de la recursividad.  Para esto, utilizaremos el <b>m√©todo</b> est√°ndar <b>isEmpty ()</b> .  Paremos y veamos lo que tenemos en este momento: <br><br><ul><li>  isEmpty (): ¬øhay elementos en la lista? </li><li>  head - el primer elemento de la lista </li><li>  cola: una lista sin el primer elemento </li><li>  list + element: podemos concatenar la lista con un objeto </li></ul><br>  De hecho, eso es todo lo que necesitamos para obtener todos los m√©todos que necesitamos. <br>  Para mi gusto, ser√≠a m√°s conveniente usar la comparaci√≥n de longitud de lista en las declaraciones <b>when</b> .  Kotlin ya nos proporciona el <b>tama√±o</b> para obtener la longitud de esta lista.  Sin embargo, supongamos que queremos implementarlo nosotros mismos.  Con nuestra funcionalidad, ser√° bastante simple: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3>  Aplicaci√≥n de funciones b√°sicas. </h3><br>  Considere el ejemplo m√°s com√∫n.  Supongamos que tenemos una lista de enteros, y queremos resumirlos, olvidando la existencia de ciclos.  Todo lo que tenemos son los m√©todos que derivamos anteriormente y la recursividad.  Para hacer esto, usaremos el mismo enfoque que al calcular el tama√±o de la lista: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br>  La idea es muy simple: si no hay elementos en la lista, entonces la suma es 0;  de lo contrario, es la suma del primer elemento y una llamada recursiva de la suma de la cola. <br><br>  A pesar del hecho de que no nos importa la velocidad y las optimizaciones en este c√≥digo, no podemos evitar recordar las capacidades del lenguaje para usar la recursividad de cola.  La recursividad de cola es un caso especial de recursi√≥n en el que una llamada recursiva es la √∫ltima operaci√≥n antes de regresar de una funci√≥n.  Este tipo de recursi√≥n es notable porque est√° garantizado para permitirle reconstruir el c√≥digo para la iteraci√≥n.  Como sabe, el principal problema de la recursividad es que durante la ejecuci√≥n de la funci√≥n es necesario almacenar la pila de llamadas para que cuando se alcance la condici√≥n l√≠mite, pueda regresar y volver a calcular el resultado final. <br><br>  Puede parecer que la funci√≥n de la cantidad que describimos es as√≠, porque la √∫ltima llamada es <b>sum (xs.tail)</b> .  Sin embargo, esto no es cierto.  Si describe el c√≥digo un poco diferente, ser√° obvio: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br>  Ahora vemos que, de hecho, la √∫ltima llamada es la suma del primer elemento y la parte restante de la cola. <br><br>  La buena noticia es que si agrega el modificador <b>tailrec</b> a una funci√≥n, el IDE le dir√° que la funci√≥n no lo es.  Sin embargo, arreglar esto es bastante sencillo.  Un truco com√∫n que corrige una funci√≥n es usar una variable auxiliar para almacenar los resultados.  Se ve as√≠: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br>  Para calcular la suma de los elementos, es suficiente pasar 0. como el segundo par√°metro, y para que sea completamente idiom√°tico, volveremos a hacer la funci√≥n un poco m√°s, ocultando los c√°lculos principales en la funci√≥n interna sin que el mundo exterior tenga acceso al par√°metro que No es necesario <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Teniendo este conocimiento, puede ver que la funci√≥n de tama√±o que implementamos anteriormente no satisface las condiciones necesarias para la recursi√≥n de la cola. <br><br>  Ahora estamos listos para implementar el mapa, filtrar y reducir usando Kotlin.  M√°s adelante veremos que fue suficiente para darse cuenta solo de esto √∫ltimo, y el resto, en general, son derivados de √©l.  Pero lo primero es lo primero. <br><br><h3>  Funciones principales </h3><br><h4>  Mapa </h4><br>  Una implementaci√≥n iterativa de esta funci√≥n implica un movimiento secuencial a trav√©s de la lista, utilizando la funci√≥n de conversi√≥n y agregando todos los elementos recibidos a la nueva colecci√≥n.  Usaremos llamadas recursivas donde la condici√≥n de l√≠mite es una lista vac√≠a.  Entonces la implementaci√≥n se ver√° as√≠: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br>  Si no hay elementos en la lista original, entonces devolvemos una lista vac√≠a, de lo contrario, aplicamos la transformaci√≥n al primer elemento y agregamos una llamada recursiva al final para el resto de la lista. <br><br>  Sin embargo, todav√≠a no tenemos una funci√≥n para concatenar un elemento y una lista.  Pero ya podemos darnos cuenta.  Para comenzar, derivamos un caso m√°s general de concatenaci√≥n de un par de listas y luego lo usamos para agregar otra lista al elemento. <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4>  Filtro </h4><br>  La implementaci√≥n ser√° muy similar al mapa.  La √∫nica diferencia es que debe comprender si necesita agregar el elemento actual al resultado.  Para hacer esto, llamaremos a la lambda que recibimos como par√°metro.  La implementaci√≥n se ver√° as√≠: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br>  Si el elemento actual cumple la condici√≥n del filtro, agr√©guelo recursivamente al final de la lista; de lo contrario, continuaremos trabajando solo con el final de la lista. <br><br><h4>  REDUCIR </h4><br>  La funci√≥n m√°s dif√≠cil de entender y, al mismo tiempo, la m√°s poderosa (en el mundo funcional se conoce como <b>pliegue</b> ).  Muy a menudo, se utiliza para contraer una lista en un solo elemento.  Tiene un cierto valor inicial <b>s0</b> , y tambi√©n hay una lista de elementos <b>a []</b> y una funci√≥n <b>f</b> , que devuelve uno nuevo para el valor inicial y el siguiente elemento de la lista.  <b>f (s0, a [0]) = s1</b> .  Y as√≠, pasamos secuencialmente por toda la lista de elementos, obteniendo alg√∫n tipo de valor √∫nico en la salida.  Un ejemplo bastante com√∫n es la suma de elementos de la matriz.  En este caso, el valor inicial es 0 y la funci√≥n devuelve la suma de dos elementos: <b>f (s, a [i]) = s + a [i]</b> .  Considere c√≥mo podemos implementar recursivamente esta funci√≥n. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br>  En principio, la implementaci√≥n es exactamente la misma que revisamos anteriormente.  Si no hay elementos en la lista, devolvemos el valor actual; de lo contrario, calculamos el nuevo primer elemento y nuevamente llamamos a la funci√≥n de reducci√≥n para √©l y al final de la lista. <br><br>  Tenga en cuenta que tambi√©n podemos crear modificaciones a esta funci√≥n.  Por ejemplo, no pase el valor inicial, pero use el primer elemento de la lista para esto.  Para entender que reducir no termina ah√≠, imagine que usamos una lista diferente como valor inicial.  En este caso, cada vez en la iteraci√≥n almacenaremos no un valor, sino una lista, gracias a la cual nuestras capacidades aumentan considerablemente.  Por ejemplo, intentemos aplicar la funci√≥n reducir de tal manera que obtengamos la lista original en la salida: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br>  Ahora, creo que supones que podr√≠amos usar reducir, para una implementaci√≥n alternativa de map, filter.  Como aprendimos a devolver exactamente la misma lista con reduce, necesitamos hacer muy pocos cambios para poder convertir cada elemento.  Para el filtro, todo es muy similar. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br>  Adem√°s, a menudo olvidan que tambi√©n podemos usar reducir no desde el principio de la lista, sino desde el final.  Claro, solo podemos expandir la lista, y despu√©s de eso aplicar reducir, pero esto no es interesante.  Tratemos de escribir y entender c√≥mo reduce funciona para colapsar la lista en el orden inverso. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br>  Si la lista no est√° vac√≠a, aplicamos la funci√≥n f al resultado de plegar la cola de la lista y el encabezado de la lista.  Por lo tanto, el primer elemento se procesar√° en √∫ltimo lugar;  pen√∫ltimo - segundo y as√≠ sucesivamente.  Para esta opci√≥n, tambi√©n puede agregar modificaciones que utilizar√°n el √∫ltimo elemento de la lista como valor inicial, etc. <br><br>  Casi siempre, cuando trabaja con listas, puede usar alguna combinaci√≥n de estas 3 funciones para obtener el resultado que le interesa. <br><br>  Implementemos tambi√©n la funci√≥n <b>zip</b> , que nos permitir√° combinar 2 listas. <br>  En la entrada tenemos 2 listas.  Y queremos devolver una lista de pares cuya longitud es igual al m√≠nimo de las listas originales. <br><br>  Como de costumbre, debe pensar en salir de la recursividad y escribir una funci√≥n. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br>  Puede agregar sus propias modificaciones, lo que le permitir√°, en lugar de devolver un par de elementos, aplicar una determinada funci√≥n a dos elementos.  En Haskell, esta funci√≥n se llama <b>zipWith</b> .  Y se implementa con la funcionalidad que logramos escribir de manera muy simple: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br>  Muy a menudo, cuando se utiliza el enfoque funcional, surgen problemas cuando necesita realizar manipulaciones basadas no en objetos en listas, sino en √≠ndices.  Por ejemplo, necesitamos sumar todos los elementos pares de una lista.  Puede intentar lograr esto con reducci√≥n, manteniendo el valor actual como Pair &lt;Int, Boolean&gt; y agregando el valor if flag == true, y tome la negaci√≥n de flag cada vez para el siguiente paso.  Sin embargo, esto no se ve muy bonito, y el lector tendr√° que descubrir qu√© quiere expresar con este c√≥digo.  Kotlin tiene secuencias infinitas, y son excelentes para resolver este problema.  Si analizamos lo que queremos hacer, resulta que queremos filtrar todos los elementos con √≠ndices impares y sumar los restantes.  Y para poder obtener √≠ndices, es suficiente llamar a <b>zip</b> para la lista y <b>secuencia</b> [0,1,2 ..] <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br>  En la biblioteca est√°ndar de Kotlin, puede encontrar la funci√≥n zip para el par de secuencias. <br><br>  Ahora veamos un rompecabezas simple que me inspir√≥ a escribir esta gu√≠a, y c√≥mo se ve su implementaci√≥n en un lenguaje imperativo en Kotlin y al final en Haskell. <br><br>  Es necesario calcular la cantidad m√°xima entre pares de n√∫meros adyacentes en una matriz de enteros.  La longitud de la matriz es mayor que 1, y no tiene que preocuparse por desbordarse al sumar elementos. <br><br>  Enfoque imperativo de Java: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Un enfoque funcional en Kotlin usando funciones escritas (propongo implementar la funci√≥n max como entrenamiento usted mismo): <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Implementaci√≥n de Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br>  Como podemos ver, lo que implementamos en Kotlin (por cierto, podr√≠amos usar reducir para resolver este problema) es muy similar a lo que se puede escribir en Haskell. <br><br><h3>  Conclusi√≥n </h3><br>  Sin lugar a dudas, esto no debe usarse en el desarrollo, porque todo se implement√≥ de manera no √≥ptima solo para demostrar un enfoque funcional.  Adem√°s, casi todo lo que se escribi√≥ est√° en la biblioteca est√°ndar de Kotlin, por lo que, tal vez en el futuro, en lugar de escribir otro bucle for, usar√° el estilo funcional que Kotlin nos proporciona. <br><br>  Probablemente lo m√°s dif√≠cil en el estilo funcional es que el problema se puede resolver de diferentes maneras.  Lo m√°s obvio puede ser engorroso y dif√≠cil de entender en el futuro, y escribir lo m√°s comprensible puede tomar tiempo y pensar seriamente.  Lo √∫nico que puede ayudar a dominar es la pr√°ctica constante y la capacitaci√≥n. <br><br>  PD: Como se mencion√≥ anteriormente, puede ver el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> con todos los ejemplos que se encuentran en el art√≠culo.  ¬°Ejecute las pruebas y vea c√≥mo funciona! <br><br>  PPS: Tambi√©n puede ver un enfoque alternativo que implementa una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funcionalidad</a> similar. <br><br>  Y aseg√∫rese de ver m√°s adelante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://arrow-kt.io/</a> .  En mi opini√≥n, no deber√≠as mirar all√≠ de inmediato, porque todo parece bastante aterrador, pero m√°s tarde, cuando los funtores y las m√≥nadas no te asusten, aseg√∫rate de estudiarlo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425527/">https://habr.com/ru/post/es425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425511/index.html">Caracter√≠sticas no obvias de la aplicaci√≥n Rotativa para generar PDF en la aplicaci√≥n ASP.NET MVC</a></li>
<li><a href="../es425515/index.html">Apple bloquea la reparaci√≥n independiente de los nuevos modelos de MacBook</a></li>
<li><a href="../es425517/index.html">C√≥mo Yandex cre√≥ un pron√≥stico de precipitaci√≥n global utilizando radares y sat√©lites</a></li>
<li><a href="../es425521/index.html">M√©todos protegidos en JavaScript ES5</a></li>
<li><a href="../es425525/index.html">Tim Berners-Lee sigue el camino de la guerra: "Un peque√±o paso para la web ..."</a></li>
<li><a href="../es425529/index.html">Sans Forgetica: una fuente que te permite memorizar un poco mejor lo que lees</a></li>
<li><a href="../es425531/index.html">Refrigeraci√≥n l√≠quida de freno. Opciones de desarrollo del sistema</a></li>
<li><a href="../es425533/index.html">C√≥mo trabajar en la nube: desde verificar la confiabilidad de un centro de datos hasta administrar una infraestructura virtual</a></li>
<li><a href="../es425537/index.html">C√≥mo combinar Java, Js y gr√°ficos con arte, o la historia de c√≥mo se cre√≥ un teatro interactivo</a></li>
<li><a href="../es425541/index.html">C√≥mo evitar r√°pidamente y sin chips innecesarios la inmutabilidad de la direcci√≥n del sensor HTU21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>