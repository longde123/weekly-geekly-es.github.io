<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏿 🚡 😂 Implementasi malas melintasi pohon anak-anak dari kelas QObject 🙎🏽 🍁 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Artikel ini menjelaskan implementasi malas dari traversal pohon di C ++ menggunakan coroutine dan rentang menggunakan contoh meningkat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi malas melintasi pohon anak-anak dari kelas QObject</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481402/"><h2 id="vvedenie">  Pendahuluan </h2><br><p> Artikel ini menjelaskan implementasi malas dari traversal pohon di C ++ menggunakan coroutine dan rentang menggunakan contoh meningkatkan antarmuka untuk bekerja dengan anak-anak dari kelas <code>QObject</code> dari kerangka Qt.  Penciptaan pandangan khusus untuk bekerja dengan elemen anak dipertimbangkan secara rinci, dan implementasi malas dan klasik diberikan.  Di akhir artikel ada tautan ke repositori dengan kode sumber lengkap. </p><a name="habracut"></a><br><h2 id="ob-avtore">  Tentang penulis </h2><br><p>  Saya bekerja sebagai pengembang senior di kantor The Qt Company di Norwegia.  Saya telah mengembangkan widget dan elemen QtQuick, baru-baru ini Qt Core.  Saya menggunakan C ++ dan sedikit tertarik pada pemrograman fungsional.  Terkadang saya membuat laporan dan menulis artikel. </p><br><h2 id="chto-takoe-qt">  Apa itu Qt </h2><br><p>  <a href="https://wiki.qt.io/About_Qt">Qt</a> adalah kerangka kerja lintas platform untuk membuat antarmuka pengguna grafis (GUI).  Selain modul untuk membuat GUI, Qt berisi banyak modul untuk mengembangkan perangkat lunak aplikasi.  Kerangka kerja ini dirancang terutama dalam bahasa pemrograman C ++, beberapa komponen menggunakan <a href="https://doc.qt.io/qt-5/qmlapplications.html">QML</a> dan <a href="https://doc.qt.io/qt-5/qtqml-javascript-expressions.html">JavaScript</a> . </p><br><h2 id="klass-qobject">  Kelas QObject </h2><br><p>  <a href="https://doc.qt.io/qt-5/qobject.html">QObject</a> adalah kelas di mana model objek Qt dibangun.  Kelas yang diwarisi dari <code>QObject</code> dapat digunakan dalam model sinyal slot dan loop peristiwa.  Selain itu, <code>QObject</code> memungkinkan Anda untuk mengakses informasi kelas meta-objek dan mengatur objek ke dalam struktur pohon. </p><br><h2 id="drevovidnaya-struktura-qobject">  QObject tree structure </h2><br><p>  Menggunakan <a href="https://doc.qt.io/qt-5/objecttrees.html">struktur pohon</a> berarti bahwa setiap objek <code>QObject</code> dapat memiliki satu orangtua dan nol atau lebih anak.  Objek induk mengontrol masa hidup objek anak.  Dalam contoh berikut, dua anak akan dihapus secara otomatis: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> parent = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;QObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> onDestroyed = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> obj){ qDebug(<span class="hljs-string"><span class="hljs-string">"Object %p destroyed."</span></span>, obj); }; QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QObject(parent.get()), &amp;QObject::destroyed, onDestroyed); QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QObject(parent.get()), &amp;QObject::destroyed, onDestroyed); <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre> <br><p>  Sayangnya, sejauh ini sebagian besar API Qt hanya berfungsi dengan pointer mentah.  Kami sedang mengerjakan ini, dan mungkin segera situasi akan berubah menjadi lebih baik setidaknya sebagian. </p><br><p>  <code>QObject</code> kelas <code>QObject</code> memungkinkan Anda untuk mendapatkan daftar semua objek anak dan mencari berdasarkan beberapa kriteria.  Pertimbangkan contoh mendapatkan daftar semua objek anak: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> parent = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;QObject&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  10   for (std::size_t i = 0; i &lt; 10; ++i) { auto obj = new QObject(parent.get()); obj-&gt;setObjectName(QStringLiteral("Object %1").arg(i)); } const auto&amp; children = parent-&gt;children(); qDebug() &lt;&lt; children; // =&gt; (QObject(0x1f7ffa0, name = "Object 0"), ...) qDebug() &lt;&lt; children.count(); // =&gt; 10</span></span></code> </pre> <br><p>  Metode <code>QObject::children</code> mengembalikan daftar semua anak dari objek yang diberikan.  Namun, pencarian sering diperlukan di antara seluruh subtree objek dengan beberapa kriteria: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = parent-&gt;findChildren&lt;QObject&gt;(QRegularExpression(<span class="hljs-string"><span class="hljs-string">"0$"</span></span>)); qDebug() &lt;&lt; children.count();</code> </pre> <br><p>  Contoh di atas menunjukkan cara mendapatkan daftar semua anak dari jenis <code>QObject</code> yang namanya berakhir dengan 0. Tidak seperti metode <code>children</code> - <code>children</code> , metode <code>findChildren</code> melintasi pohon secara rekursif, yaitu, pencarian melalui seluruh hierarki objek.  Perilaku ini dapat diubah dengan melewati <code>Qt::FindDirectChildrenOnly</code> . </p><br><h2 id="nedostatki-interfeysa-raboty-s-dochernimi-elementami">  Kekurangan antarmuka untuk bekerja dengan elemen anak </h2><br><p>  Sekilas, mungkin terlihat bahwa antarmuka untuk bekerja dengan anak-anak dipikirkan dengan baik dan fleksibel.  Namun, dia bukannya tanpa cacat.  Mari kita pertimbangkan beberapa di antaranya: </p><br><ul><li>  Antarmuka redundan <br>  Ada dua metode <code>findChildren</code> berbeda (ada tiga belum lama ini): metode <code>findChild</code> untuk menemukan satu item dan metode anak-anak.  Semuanya sebagian tumpang tindih. </li><li>  Antarmuka sulit diubah <br>  Qt menjamin kompatibilitas dan kompatibilitas biner pada tingkat kode sumber dalam satu rilis utama tunggal.  Oleh karena itu, Anda tidak bisa hanya mengubah tanda tangan suatu metode atau menambahkan metode baru. </li><li>  Antarmuka sulit diperluas <br>  Selain pelanggaran kompatibilitas, tidak mungkin, misalnya, untuk mendapatkan daftar elemen anak sesuai dengan kriteria yang ditentukan.  Untuk menambahkan fungsionalitas ini, Anda harus menunggu rilis berikutnya atau membuat metode lain. </li><li>  Lebih dari menyalin semua item <br>  Seringkali, Anda hanya perlu melihat daftar semua elemen anak yang difilter dengan kriteria tertentu.  Untuk melakukan ini, tidak perlu mengembalikan wadah petunjuk ke semua elemen ini. </li><li>  Kemungkinan pelanggaran <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a> <br>  Ini adalah masalah yang agak kontroversial, namun, kebutuhan untuk mengubah antarmuka kelas untuk berubah, katakanlah, metode untuk melintasi anak-anak terlihat aneh. </li></ul><br><h2 id="ispolzovanie-range-v3-dlya-ustraneniya-nekotoryh-nedostatkov">  Menggunakan range-v3 untuk memperbaiki beberapa kekurangan </h2><br><p>  <a href="https://github.com/ericniebler/range-v3">range-v3</a> adalah perpustakaan yang menyediakan komponen untuk bekerja dengan rentang elemen.  Bahkan, ini adalah lapisan tambahan abstraksi atas iterator klasik, yang memungkinkan Anda untuk menyusun operasi dan memanfaatkan perhitungan malas. </p><br><p>  Pustaka pihak ketiga digunakan karena pada saat penulisan, tidak ada kompiler yang diketahui oleh penulis dengan dukungan bawaan untuk fungsi ini.  Mungkin situasinya akan segera berubah. </p><br><p>  Untuk <code>QObject</code> menggunakan pendekatan ini akan memungkinkan kami untuk memisahkan operasi traversal dari pohon anak-anak dari kelas dan membuat antarmuka yang fleksibel untuk mencari objek sesuai dengan kriteria yang diberikan, yang dapat dengan mudah dimodifikasi. </p><br><h3 id="primer-ispolzovaniya-ranges-v3">  Contoh Ranges-v3 </h3><br><p>  Untuk memulai, pertimbangkan contoh sederhana menggunakan perpustakaan.  Sebelum melanjutkan ke contoh, kami memperkenalkan notasi singkat untuk ruang nama: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> r = ranges; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> v = r::views; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> a = r::actions;</code> </pre> <br><p>  Sekarang perhatikan contoh program yang mencetak kubus dari semua angka ganjil dalam interval [1, 10) dalam urutan terbalik: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_odd = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pow3 = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(n, <span class="hljs-number"><span class="hljs-number">3</span></span>); }; <span class="hljs-comment"><span class="hljs-comment">//  [729,343,125,27,1] std::cout &lt;&lt; (v::ints(1, 10) | v::filter(is_odd) | v::transform(pow3) | v::reverse);</span></span></code> </pre> <br><p>  Perlu dicatat bahwa semua perhitungan terjadi dengan malas, mis.  set data sementara tidak dibuat atau disalin.  Program di atas setara dengan ini, dengan pengecualian memformat output: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  729 343 125 27 1 for (int i = 9; i &gt; 0; --i) { if (i % 2 != 0) { std::cout &lt;&lt; std::pow(i, 3) &lt;&lt; " "; } }</span></span></code> </pre> <br><p>  Seperti yang dapat Anda lihat dari contoh di atas, perpustakaan memungkinkan Anda menyusun berbagai operasi dengan anggun.  Lebih banyak contoh penggunaan dapat ditemukan dalam direktori <code>tests</code> dan <code>examples</code> repositori <a href="https://github.com/ericniebler/range-v3">range-v3</a> . </p><br><h3 id="klass-dlya-predstavleniya-posledovatelnosti-dochernih-elementov">  Kelas untuk mewakili urutan anak-anak </h3><br><p>  Perpustakaan <code>range-v3</code> menyediakan kelas pembantu untuk membuat berbagai kelas bungkus kustom;  di antara mereka adalah kelas dari kategori <code>view</code> .  Kelas-kelas ini dirancang untuk mewakili urutan elemen dengan cara tertentu tanpa mengubah dan menyalin urutan itu sendiri.  Dalam contoh sebelumnya, kelas <code>filter</code> digunakan untuk mempertimbangkan hanya elemen-elemen dari urutan yang cocok dengan kriteria yang ditentukan. </p><br><p>  Untuk membuat kelas seperti itu untuk bekerja dengan elemen anak QObject, itu harus diwarisi dari <code>ranges::view_facade</code> kelas tambahan <code>ranges::view_facade</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt::detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">children_view</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> r::view_facade&lt;children_view&lt;T&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//   friend r::range_access; //   ,       T *obj; //    (  ) Qt::FindChildOptions opts; //  --    cursor begin_cursor() { return cursor(obj, opts); } public: //  }; } // namespace qt::detail</span></span></code> </pre> <br><p>  Perlu dicatat bahwa kelas secara otomatis mendefinisikan metode <code>end_cursor</code> , yang mengembalikan tanda akhir urutan.  Jika perlu, metode ini dapat diganti. </p><br><p>  Selanjutnya, kita mendefinisikan kelas kursor itu sendiri.  Ini bisa dilakukan di dalam kelas <code>children_view</code> dan di luar: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cursor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,      std::shared_ptr&lt;ObjectVector&gt; children; //    std::size_t current_index = 0; //       decltype(auto) read() const { return (*children)[current_index]; } //     void next() { ++current_index; } //     auto equal(ranges::default_sentinel_t) const { return current_index == children-&gt;size(); } //  };</span></span></code> </pre> <br><p>  Kursor yang ditentukan di atas adalah sekali-lewat.  Ini berarti bahwa urutan dibiarkan bergerak hanya dalam satu arah dan hanya sekali.  Untuk implementasi ini, ini tidak perlu, karena  kami menyimpan urutan semua objek anak dan dapat melewatinya ke arah mana pun sebanyak yang Anda suka.  Untuk menunjukkan bahwa Anda dapat melalui urutan beberapa kali, Anda harus menerapkan metode berikut di kelas kursor: </p><br><pre> <code class="plaintext hljs">auto equal(const cursor &amp;that) const { return current_index == that.current_index; }</code> </pre> <br><p>  Sekarang Anda perlu menambahkan untuk memastikan bahwa tampilan yang dibuat dapat dimasukkan dalam komposisi.  Untuk melakukan ini, gunakan <code>ranges::make_pipeable</code> fungsi bantu <code>ranges::make_pipeable</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = r::make_pipeable([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::children_view(o); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_children</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Qt::FindChildOptions opts = Qt::FindChildrenRecursively)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r::make_pipeable([opts](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::children_view(o, opts); }); } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt</span></span></code> </pre> <br><p>  Sekarang Anda dapat menulis kode ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;c : root | qt::children) { <span class="hljs-comment"><span class="hljs-comment">//     () } for (auto &amp;&amp;c : root | qt::find_children(Qt::FindDirectChildrenOnly)) { //     }</span></span></code> </pre> <br><h3 id="realizaciya-suschestvuyuschey-funkcionalnosti-klassa-qobject">  Menerapkan Fungsi Kelas QObject yang Ada </h3><br><p>  Setelah menerapkan kelas presentasi, Anda dapat dengan mudah mengimplementasikan semua fungsi untuk bekerja dengan anak-anak.  Untuk melakukan ini, Anda perlu mengimplementasikan tiga fungsi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with_type</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">:</span></span>:filter([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ObjType = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_cv_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_pointer_t</span></span>&lt;T&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjType::staticMetaObject.cast(o); }) | v::transform([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&gt;(o); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v::filter([name](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj-&gt;objectName() == name; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_re</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QRegularExpression &amp;re)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v::filter([re](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re.match(obj-&gt;objectName()).hasMatch(); }); } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt</span></span></code> </pre> <br><p>  Sebagai contoh penggunaan, pertimbangkan kode berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;c : root | qt::children | qt::with_type&lt;Foo*&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Foo }</span></span></code> </pre> <br><h3 id="promezhutochnye-vyvody">  Kesimpulan menengah </h3><br><p>  Seperti dapat dinilai oleh kode, sekarang cukup mudah untuk memperluas fungsionalitas tanpa mengubah antarmuka kelas.  Selain itu, semua operasi diwakili oleh fungsi yang terpisah dan dapat diatur dalam urutan yang diinginkan.  Ini, antara lain, meningkatkan pembacaan kode dan menghindari penggunaan fungsi dengan beberapa parameter di antarmuka kelas.  Perlu diperhatikan juga pembongkaran antarmuka kelas dan pengurangan jumlah alasan untuk mengubahnya. </p><br><p>  Faktanya, implementasi ini telah menghilangkan hampir semua kelemahan antarmuka yang terdaftar, kecuali bahwa kita masih harus menyalin semua anak ke dalam wadah.  Salah satu cara untuk mengatasi masalah ini adalah dengan menggunakan coroutine. </p><br><h2 id="lenivaya-realizaciya-obhoda-dereva-obektov-s-ispolzovaniem-soprogramm">  Malas implementasi traversal objek pohon menggunakan coroutine </h2><br><p>  <a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutine</a> (coroutine) memungkinkan Anda untuk menjeda fungsi dan melanjutkannya nanti.  Anda dapat mempertimbangkan teknologi ini sebagai semacam mesin negara terbatas. </p><br><p>  Pada saat penulisan, perpustakaan standar tidak memiliki banyak elemen penting yang diperlukan untuk penggunaan coroutine yang nyaman.  Oleh karena itu, diusulkan untuk menggunakan perpustakaan <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> pihak <a href="https://github.com/lewissbaker/cppcoro">ketiga</a> , yang kemungkinan akan memasukkan standar dalam satu atau lain bentuk. </p><br><p>  Untuk memulainya, kami akan menulis fungsi yang akan mengembalikan anak berikutnya sesuai permintaan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt::detail { cppcoro::recursive_generator&lt;QObject*&gt; takeChildRecursivelyImpl( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QObjectList &amp;children, Qt::FindChildOptions opts) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (QObject *c : children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opts == Qt::FindChildrenRecursively) { <span class="hljs-function"><span class="hljs-function">co_yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeChildRecursivelyImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c-&gt;children(), opts)</span></span></span></span>; } co_yield c; } } cppcoro::recursive_generator&lt;QObject*&gt; takeChildRecursively( QObject *root, Qt::FindChildOptions opts = Qt::FindChildrenRecursively) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root) { <span class="hljs-function"><span class="hljs-function">co_yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeChildRecursivelyImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(root-&gt;children(), opts)</span></span></span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt::detail</span></span></code> </pre> <br><p>  Instruksi <code>co_yield</code> mengembalikan nilai ke kode panggilan dan menjeda coroutine. </p><br><p>  Sekarang mengintegrasikan kode ini ke dalam kelas <code>children_view</code> .  Kode berikut hanya menunjukkan elemen yang telah berubah: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   children_view //   Data{obj, takeChildRecursively(obj, opts)} struct Data { T *obj; cppcoro::recursive_generator&lt;QObject*&gt; gen; }; std::shared_ptr&lt;Data&gt; m_data; // ... cursor begin_cursor() { return cursor(m_data-&gt;gen.begin()); }</span></span></code> </pre> <br><p>  Kursor juga harus diubah: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">children_view</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:cursor { cppcoro::recursive_generator&lt;QObject*&gt;::iterator it; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) read() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *it; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++it; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ranges::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default_sentinel_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it == cppcoro::recursive_generator&lt;QObject*&gt;::iterator(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cppcoro::recursive_generator&lt;QObject*&gt;::iterator it)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">it</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(it)</span></span></span><span class="hljs-function"> </span></span>{} cursor() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br><p>  Kursor di sini hanya bertindak sebagai pembungkus di sekitar iterator biasa.  Sisa kode dapat digunakan apa adanya, tanpa perubahan tambahan. </p><br><h3 id="opasnosti-lenivogo-obhoda-dereva">  Bahaya malas berjalan di pohon </h3><br><p>  Perlu dicatat bahwa traversal malas pohon anak-anak tidak selalu aman.  Ini terutama berkaitan dengan memintas hierarki elemen grafis yang kompleks, misalnya widget.  Faktanya adalah bahwa dalam proses traversal hierarki dapat dibangun kembali, dan beberapa elemen dihapus sepenuhnya.  Jika Anda menggunakan solusi malas dalam hal ini, Anda bisa mendapatkan hasil program yang sangat menarik dan tidak dapat diprediksi. </p><br><p>  Ini berarti bahwa dalam beberapa kasus, berguna untuk menyalin semua elemen ke dalam wadah.  Untuk melakukan ini, Anda dapat menggunakan fungsi pembantu berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = ranges::to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&gt;(root | qt::children);</code> </pre> <br><p>  Sebenarnya, dalam hal ini tidak perlu menggunakan coroutine dan Anda dapat menggunakan tampilan dari iterasi pertama. </p><br><h2 id="budet-li-eto-v-qt">  Apakah akan di Qt </h2><br><p>  Mungkin, tetapi tidak di rilis berikutnya.  Ada beberapa alasan untuk ini: </p><br><ul><li>  Rilis besar berikutnya, Qt 6, secara resmi akan membutuhkan dan mendukung C ++ 17, tetapi tidak lebih tinggi. </li><li>  Tidak ada cara untuk mengimplementasikannya tanpa perpustakaan pihak ketiga. </li><li>  Akan relatif sulit untuk mengadaptasi basis kode yang ada. <br>  Kemungkinan besar, mereka akan kembali ke masalah ini sebagai bagian dari rilis Qt 7. </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Usulan implementasi melintasi elemen pohon anak membuatnya mudah untuk menambahkan fungsionalitas baru.  Karena pemisahan operasi, penulisan kode pembersih dan penghapusan elemen yang tidak perlu dari antarmuka kelas tercapai. </p><br><p>  Perlu dicatat bahwa kedua perpustakaan yang digunakan (range-v3 dan cpp-coro) disediakan sebagai file header, yang menyederhanakan proses pembuatan.  Di masa depan, itu akan mungkin dilakukan tanpa perpustakaan pihak ketiga sama sekali. </p><br><p>  Namun, pendekatan yang dijelaskan memiliki beberapa kelemahan.  Di antara mereka, satu dapat mencatat sintaks yang tidak biasa bagi banyak pengembang, kompleksitas relatif implementasi dan kemalasan, yang dapat berbahaya dalam beberapa kasus. </p><br><h2 id="dopolnitelno">  Opsional </h2><br><p>  <a href="https://github.com/vt4a2h/qobject-with-ranges-mirror">Kode sumber</a> </p><br><p>  Terima kasih khusus kepada Misha Svetkin ( <a href="https://habr.com/ru/users/trilla/" class="user_link">Trilla</a> ) untuk kontribusinya dalam implementasi dan diskusi proyek. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481402/">https://habr.com/ru/post/id481402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481388/index.html">Bagaimana pertukaran cryptocurrency membangun blockchains mereka melawan DeFi</a></li>
<li><a href="../id481390/index.html">Berita dari dunia OpenStreetMap No. 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../id481392/index.html">Saat saya menulis cryptocurrency terpusat di PHP. (Bagian 1 - Ringkasan dasar + Mulai cepat)</a></li>
<li><a href="../id481394/index.html">Menciptakan dalam permainan baru apa yang kita sukai untuk yang lama</a></li>
<li><a href="../id481398/index.html">Perintah Linux dasar untuk penguji dan banyak lagi</a></li>
<li><a href="../id481406/index.html">Pencelupan mendalam dalam investasi Masker Ilona</a></li>
<li><a href="../id481416/index.html">Pengumuman Pertemuan AWS kedua di Minsk (13/02/2020)</a></li>
<li><a href="../id481418/index.html">Cara kerja codec video. Bagian 1. Dasar-dasar</a></li>
<li><a href="../id481420/index.html">15 perpustakaan ikon terbaik dan terbesar</a></li>
<li><a href="../id481424/index.html">Kontrol Kustom di Sudut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>