<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 🏞️ 👩‍✈️ ActivityLifecycleCallbacks-公共API中的盲点 ♌️ ⁉️ 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="从小开始，我喜欢阅读说明。 我长大了，但仍然令我惊讶的是，成年人对指令的粗心大意：他们中的许多人认为每个人都知道，并且同时使用一两个功能，而其中有很多功能！ 你们中有多少人用来保持微波炉的温度？ 她几乎在每个人中。 

 一旦我决定阅读有关Android框架各个类的文档。 我浏览了以下主要类：Vie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ActivityLifecycleCallbacks-公共API中的盲点</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/482476/"><img src="https://habrastorage.org/webt/h5/7s/op/h57sopubtnsjbnkfclj9sapsho4.png"><br><br> 从小开始，我喜欢阅读说明。 我长大了，但仍然令我惊讶的是，成年人对指令的粗心大意：他们中的许多人认为每个人都知道，并且同时使用一两个功能，而其中有很多功能！ 你们中有多少人用来保持微波炉的温度？ 她几乎在每个人中。 <br><br> 一旦我决定阅读有关Android框架各个类的文档。 我浏览了以下主要类：View，Activity，Fragment，Application，并且我对<a href="https://developer.android.com/reference/android/app/Application.html">Application.registerActivityLifecycleCallbacks（）</a>方法和<a href="https://developer.android.com/reference/android/app/Application.ActivityLifecycleCallbacks.html">ActivityLifecycleCallbacks</a>接口非常感兴趣。 在Internet上使用它的示例中，没有什么比记录Activity生命周期更好。 然后我开始自己进行实验，现在进入Yandex.Money，Money在从外部解决与Activity对象的影响相关的所有任务时都积极使用它。 <br><a name="habracut"></a><br><h1> 什么是ActivityLifecycleCallbacks？ </h1><br> 看一下这个接口，它出现在API 14中的样子： <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityLifecycleCallbacks</span></span></span><span class="hljs-class"> </span></span>{    void onActivityCreated(Activity activity, Bundle savedInstanceState);    void onActivityStarted(Activity activity);    void onActivityResumed(Activity activity);    void onActivityPaused(Activity activity);    void onActivityStopped(Activity activity);    void onActivitySaveInstanceState(Activity activity, Bundle outState);    void onActivityDestroyed(Activity activity); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">从API 29开始，已添加了几个新方法。</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityLifecycleCallbacks</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState) { }   void onActivityCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPrePaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityPaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostPaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreSaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState) { }   void onActivitySaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostSaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { } }</code> </pre> <br></div></div><br> 也许这个接口很少受到关注，因为它仅出现在Android 4.0 ICS中。 但是徒劳无功，因为它允许您本机执行一件非常有趣的事情：从外部影响所有Activity对象。 但是稍后会更多，首先请仔细研究这些方法。 <br><br> 每种方法都显示与Activity生命周期类似的方法，并且在应用程序中的任何Activity上触发该方法时即会被调用。 也就是说，如果使用MainActivity启动该应用程序，则第一个应用程序将收到对ActivityLifecycleCallback.onActivityCreated（MainActivity，null）的调用。 <br><br> 很好，但是如何运作？ 这里没有魔术：活动本身报告他们处于何种状况。 这是来自Activity.onCreate（）的一段代码： <br><br><pre> <code class="java hljs"> mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>           ? mLastNonConfigurationInstances.fragments : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mVoiceInteractor != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {</code> </pre><br> 看来我们自己做了BaseActivity。 只有Android的同事为我们做到了这一点，并且还迫使每个人都必须使用它。 这非常好！ <br><br> 在API 29中，这些方法的工作原理几乎相同，但是在特定方法之前和之后，会诚实地调用它们的Pre和Post副本。 现在可能是由ActivityManager控制的，但这只是我的猜测，因为我没有深入了解源代码。 <br><br><h2> 如何使ActivityLifecycleCallbacks工作？ </h2><br> 像所有回调一样，您必须首先注册它们。 我们在Application.onCreate（）中注册了所有ActivityLifecycleCallbacks，因此我们可以获得有关所有Activity及其管理能力的信息。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() {   <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() registerActivityLifecycleCallbacks(MyCallbacks()) } }</code> </pre> <br> 一个小小的题外话：从API 29开始，ActivityLifecycleCallbacks也可以从Activity内注册。 这将是仅适用于此活动的<a href="https://developer.android.com/reference/android/app/Activity.html">本地回调</a> 。 <br><br> 仅此而已。 但您只需在搜索框中输入名称ActivityLifecycleCallbacks即可找到它。 有许多记录“活动”生命周期的示例，但这很有趣吗？ 活动有许多公共方法（大约有400种），所有这些都可以用来做很多有趣和有用的事情。 <br><br><h2> 该怎么办？ </h2><br> 你要什么 是否要在应用程序的所有Activity中动态更改主题？ 请：setTheme（）方法是公共的，这意味着您可以从ActivityLifecycleCallback调用它： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThemeCallback</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@StyleRes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTheme: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { activity.setTheme(myTheme) } }</code> </pre> <br>  <b>仅在家中重复此技巧</b> <br> 连接的库中的某些活动可以使用其自定义主题。 因此，请检查软件包或任何其他可以确定可以安全更改此Activity主题的症状。 例如，我们检查这样的软件包（在Kotlinovsky =中）： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThemeCallback</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@StyleRes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTheme: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myPackage = <span class="hljs-string"><span class="hljs-string">"my.cool.application"</span></span> activity .takeIf { it.javaClass.name.startsWith(myPackage) } ?.setTheme(myTheme) } }</code> </pre> <br> 这个例子行不通吗？ 您可能忘记了在应用程序或AndroidManifest中的应用程序中注册ThemeCallback。 <br><br> 想要另一个有趣的例子吗？ 您可以在应用程序中的任何活动上显示对话框。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DialogCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dialogFragment: DialogFragment ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag = dialogFragment.javaClass.name (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? AppCompatActivity) ?.supportFragmentManager ?.also { fragmentManager -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragmentManager.findFragmentByTag(tag) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { dialogFragment.show(fragmentManager, tag) } } } } }</code> </pre> <br>  <b>仅在家中重复此技巧</b> <br> 当然，您不应在每个屏幕上都显示对话-我们的用户不会为此而爱我们。 但是有时在某些特定屏幕上显示类似内容可能会很有用。 <br><br> 这是另一种情况：如果我们需要启动Activity该怎么办呢，这里的一切都很简单：Activity.startActivity（）-并将其驱动。 但是，如果我们需要在调用Activity.startActivityForResult（）之后等待结果呢？ 我有一个食谱： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartingActivityCallback</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application.ActivityLifecycleCallbacks { override fun onActivityCreated</span></span></span></span>( activity: Activity, savedInstanceState: Bundle? ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? AppCompatActivity) ?.supportFragmentManager ?.also { fragmentManager -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startingFragment = findOrCreateFragment(fragmentManager) startingFragment.listener = { resultCode, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt; <span class="hljs-comment"><span class="hljs-comment">// handle response here } // start Activity inside StartingFragment } } } private fun findOrCreateFragment( fragmentManager: FragmentManager ): StartingFragment { val tag = StartingFragment::class.java.name return fragmentManager .findFragmentByTag(tag) as StartingFragment? ?: StartingFragment().apply { fragmentManager .beginTransaction() .add(this, tag) .commit() } } }</span></span></code> </pre> <br> 在该示例中，我们只是放下Fragment，这将启动Activity并获取结果，然后将其处理委托给我们。 注意：在这里，我们检查我们的Activity是否为AppCompatActivity，这会导致无限循环。 使用其他条件。 <br><br> 让我们使例子复杂化。 在那之前，我们仅使用了Activity中已经存在的那些方法。 如何添加自己的？ 假设我们要发送有关打开屏幕的分析。 同时，我们的屏幕具有自己的名称。 如何解决这个问题？ 很简单 创建一个可以提供屏幕名称的屏幕界面： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String }</code> </pre> <br> 现在，我们在所需的Activity中实现它： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), Screen { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String = <span class="hljs-string"><span class="hljs-string">"First screen"</span></span> }</code> </pre> <br> 之后，我们为此类活动设置特殊的ActivityLifecycleCallbacks： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyticsActivityCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sendAnalytics: (String) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Screen)?.screenName?.let(sendAnalytics) } } }</code> </pre> <br> 看吗 我们只检查界面，如果实施了，就发送分析数据。 <br><br> 重复进行固定。 如果您需要抛出更多参数怎么办？ 扩展接口： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScreenWithParameters</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Screen { val parameters: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String, String</span></span></span><span class="hljs-class">&gt; }</span></span></code> </pre> <br> 我们实施： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), ScreenWithParameters { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String = <span class="hljs-string"><span class="hljs-string">"First screen"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parameters: Map&lt;String, String&gt; = mapOf(<span class="hljs-string"><span class="hljs-string">"key"</span></span> to <span class="hljs-string"><span class="hljs-string">"value"</span></span>) }</code> </pre> <br> 我们运送： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyticsActivityCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sendAnalytics: (String, Map&lt;String, String&gt;?) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Screen)?.screenName?.let { name -&gt; sendAnalytics( name, (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? ScreenWithParameters)?.parameters ) } } } }</code> </pre> <br> 但这仍然很容易。 所有这些只是将您带入一个非常有趣的主题：本机依赖项注入。 是的，我们有Dagger，Koin，Guice，Kodein等。 但是在小型项目中，它们是多余的。 但是我有一个解决方案...猜猜哪一个？ <br><br> 假设我们有一些这样的工具： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> extraInfo = <span class="hljs-string"><span class="hljs-string">"i am dependency"</span></span> }</code> </pre> <br> 使用界面将其关闭，就像成人程序员一样： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolTool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> extraInfo: String } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CoolTool { override val extraInfo = "i am dependency" }</span></span></span></span></code> </pre> <br> 现在，从ActivityLifecycleCallbacks获得一些街头魔术：我们将创建一个接口来实现此依赖关系，在所需的Activity中实现它，并使用ActivityLifecycleCallbacks找到并实现CoolToolImpl实现。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequireCoolTool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coolTool: CoolTool } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), RequireCoolTool { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coolTool: CoolTool } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectingLifecycleCallbacks</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ActivityLifecycleCallbacks { override fun onActivityCreated</span></span></span></span>( activity: Activity, savedInstanceState: Bundle? ) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? RequireCoolTool)?.coolTool = CoolToolImpl() } }</code> </pre> <br> 记住要在您的应用程序中注册InjectingLifecycleCallbacks，运行它，然后它才能工作。 <br><br> 并且不要忘记测试： <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith(AndroidJUnit4::class)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DIActivityTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `should access extraInfo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">when</span></span></span><span class="hljs-function"> created`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// prepare val mockTool: CoolTool = mock() val application = getApplicationContext&lt;android.app.Application&gt;() application.registerActivityLifecycleCallbacks( object : Application.ActivityLifecycleCallbacks { override fun onActivityCreated( activity: Activity, savedInstanceState: Bundle? ) { (activity as? RequireCoolTool)?.coolTool = mockTool } }) // invoke launch&lt;DIActivity&gt;(Intent(application, DIActivity::class.java)) // assert verify(mockTool).extraInfo } }</span></span></code> </pre> <br> 但是在大型项目中，这种方法无法很好地扩展，因此我不会从任何人手中夺走任何DI框架。 更好地结合努力并实现协同增效的地方。 我将向您展示Dagger2的示例。 如果项目中有一些基本的Activity执行类似AndroidInjection.inject（this）的操作，那么该丢掉它了。 而是，请执行以下操作： <br><ol><li> 根据说明，我们在Application中实现DispatchingAndroidInjector； </li><li> 创建一个ActivityLifecycleCallbacks，以在每个Activity上调用DispatchingAndroidInjector.maybeInject（）； </li><li> 在Application中注册ActivityLifecycleCallbacks。 </li></ol><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Any&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() DaggerYourApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); registerActivityLifecycleCallbacks( InjectingLifecycleCallbacks( dispatchingAndroidInjector ) ) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectingLifecycleCallbacks</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Any&gt; ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> {       dispatchingAndroidInjector.maybeInject(activity) } }</code> </pre> <br> 使用其他DI框架也可以达到相同的效果。 尝试在评论中写下发生的事情。 <br><br><h2> 总结一下 </h2><br>  ActivityLifecycleCallbacks是一个被低估的功能强大的工具。 请尝试<a href="https://github.com/yandex-money/android-activitylifecyclecallbacks-example">以下示例之一</a> ，让它们以与Yandex.Money帮助改善我们的应用程序相同的方式为您的项目提供帮助。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482476/">https://habr.com/ru/post/zh-CN482476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482466/index.html">您可以为Vue 3.0做准备的5件事</a></li>
<li><a href="../zh-CN482468/index.html">VS Code的5个扩展和主题可以改变前端开发人员的生活</a></li>
<li><a href="../zh-CN482470/index.html">在最简单的廉价手机上快速加载页面</a></li>
<li><a href="../zh-CN482472/index.html">JavaScript是由什么制成的？</a></li>
<li><a href="../zh-CN482474/index.html">我如何度过夏天</a></li>
<li><a href="../zh-CN482478/index.html">Iteraptor：用于深层透明地图重做的库</a></li>
<li><a href="../zh-CN482480/index.html">即将到来的一年的宇宙感</a></li>
<li><a href="../zh-CN482482/index.html">角色扮演</a></li>
<li><a href="../zh-CN482484/index.html">如何使用约束理论提高开发效率</a></li>
<li><a href="../zh-CN482486/index.html">什么是米斯拉以及如何烹饪</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>