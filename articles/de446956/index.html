<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè´ üë®‚Äçüåæ üë®‚Äçüë©‚Äçüëß Es ist sch√§dlich f√ºr Licht oder wie man die Ladung einer Autobatterie h√§lt üìâ üßöüèº üßëüèø‚Äçü§ù‚Äçüßëüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich setze die Artikelserie zum Fahrradbau im Bereich des Niederspannungs-Stromkreismanagements fort. Dieses Mal werde ich √ºber ein Ger√§t sprechen, das...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Es ist sch√§dlich f√ºr Licht oder wie man die Ladung einer Autobatterie h√§lt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446956/">  Ich setze die Artikelserie zum Fahrradbau im Bereich des Niederspannungs-Stromkreismanagements fort.  Dieses Mal werde ich √ºber ein Ger√§t sprechen, das die tiefe Entladung einer Autobatterie durch verschiedene sekund√§re Verbraucher verhindert. <br><br><img src="https://habrastorage.org/webt/_p/pt/zv/_pptzvndfwivnln2xsqz7aae224.jpeg"><br>  <i>Eine der m√∂glichen Folgen einer unkontrollierten Entladung.</i> <br><a name="habracut"></a><br>  Der Kauf des ersten Autos oder Motorrads ist ein wichtiger Meilenstein im Leben eines jeden Menschen, insbesondere eines Ingenieurs.  Denn wer au√üer den offensichtlichen Vorteilen seines neuen Eisenpferdes achtet sofort auf seine nicht offensichtlichen Nachteile?  Wer denkt sofort √ºber Verbesserungen und Erg√§nzungen des Standards nach?  Wenn es sich um ein Auto aus dem oberen Segment und sogar um eine "modische" Marke handelt, scheint es nat√ºrlich zun√§chst so, als h√§tte es absolut alles.  Aber wie die Praxis zeigt, widerlegt die Zeit in diesem Fall die ersten Eindr√ºcke.  Wenn Sie ein Auto der Economy-Klasse kaufen, jucken Ihre H√§nde schon am ersten Tag buchst√§blich! <br><br>  Der Wunsch, Ihr Auto mit verschiedenen elektronischen Hilfsger√§ten zu "stopfen", ist ganz nat√ºrlich.  Bald nach der Umsetzung all dieser Pl√§ne konfrontiert das Leben den Autobesitzer jedoch mit einer harten Realit√§t.  Es stellt sich heraus, dass selbst die modernsten Ger√§te, die auf der neuesten elementaren Basis gebaut wurden, immer noch sehr auf Elektrizit√§t bedacht sind.  Und eine Autobatterie, die so riesig erscheint, ist √ºberhaupt kein Kernreaktor und kann sich innerhalb weniger Tage leicht unter dem Gewicht all dieser scheinbar harmlosen Verbraucher ‚Äûhinsetzen‚Äú. <br><br>  Um nicht weiter in abstrakte und hypothetische Situationen zu flie√üen, gehe ich direkt zu meiner Geschichte.  Nach dem Kauf eines Autos war das erste der Wunsch, einen Registrar darin zu setzen.  Dies geschah innerhalb k√ºrzester Zeit, fast vollst√§ndig abh√§ngig von der Geschwindigkeit der Zustellung des Pakets von AliExpress.  Es ist klar, dass die regelm√§√üige Stromversorgung √ºber den Zigarettenanz√ºnder √§u√üerst unpraktisch war und der Rekorder √ºber einen 12/5-V-Impulswandler schnell eine station√§re Verbindung zur n√§chsten Leitung des Bordnetzes herstellte.  Und seitdem  Um es milde auszudr√ºcken, nicht gestern, dieser Konverter war nicht einmal modern, f√ºr seine eigenen Bed√ºrfnisse, wie sich sp√§ter herausstellte, a√ü er bis zu 21 mA Strom.  Lassen Sie uns nun absch√§tzen, wie viel dieser Konverter nur eine neue und voll aufgeladene Batterie mit einer Kapazit√§t von 60 Ah versorgen kann.  Arithmetik ist extrem einfach und entt√§uschend. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/kz/tb/ljkztbra63ol-bs6xwdpdxd4xjg.png"></div><br>  In weniger als vier Monaten landet ein Konverter, der nicht mit irgendetwas beladen ist, die Batterie buchst√§blich auf Null.  Wenn wir ber√ºcksichtigen, dass sich eine Batterie, die nicht ganz frisch ist, leicht als weniger verwitwet herausstellen kann und die Ladung nach der Stadt Pokatushki bei weitem nicht 100% betr√§gt, beginnt ein regnerischer Tag leicht innerhalb eines Monats mit einem Haken. <br><br>  Und das ist alles, wiederhole ich, nur ein Spannungswandler.  Ja, heute k√∂nnen Sie einen Konverter kaufen, der nur einen halben Milliampere f√ºr seinen eigenen Bedarf ben√∂tigt, aber ich habe dieses Beispiel gegeben, um zu zeigen, wie langsam und sicher das <s>Wasser einen Stein sch√§rft,</s> selbst wenn es geringf√ºgig ist, aber st√§ndig wirkt, zieht der Verbraucher Energie aus dem, was so riesig zu sein scheint Batterie. <br><br>  Wir gehen noch weiter, der Rekorder im FHD @ 30fps-Aufnahmemodus verbraucht fast 300 mA von der + 5V-Quelle, die nach der Konvertierung unter Ber√ºcksichtigung des Wirkungsgrads etwa 150 mA Strom aus dem integrierten Netzwerk liefert.  Angenommen, der Wandler wird durch einen modernen ersetzt, und wir berechnen die Entladezeit nur mit diesem Strom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/p8/fl/ufp8fldn4t5bfzpl8u8udb6fd3o.png"></div><br>  Etwas mehr als zwei Wochen, aber in der Praxis - zehn Tage.  Jetzt droht nach dem n√§chsten Urlaub oder der n√§chsten Gesch√§ftsreise die Aussicht auf Beleuchtung (und m√∂glicherweise auf Batteriewechsel). <br><br>  Und so passierte es mir: Als ich einen kurzen Zwangsurlaub machte, dachte ich nicht, dass in einer Woche oder so sogar ein Zentralschloss die T√ºr f√ºr mich nicht √∂ffnen k√∂nnte. <br><br>  Viele werden sagen, dass es ihre eigene Schuld ist, dass alles stromlos sein muss oder zumindest die Aufnahme beenden muss, und sie werden Recht haben.  Aber das Leben ist das Leben, und die Erinnerung ist nicht dieselbe, und wie lange der kleine Krankenstand dauert, ist nicht immer im Voraus bekannt.  Daher entstand sofort die Idee eines Leistungsschalters. <br><br>  Es gibt nat√ºrlich eine Option, den Rekorder √ºber den Z√ºndschalter mit Strom zu versorgen, so dass er nur unterwegs funktioniert, aber diese Option ist auch nicht sehr, weil  Wenn das Auto auf dem Parkplatz st√∂√üt, m√∂chte ich die Chance haben, den T√§ter zu sehen.  Kurz nach der Installation des Rekorders war das Auto mit mehreren weiteren Ger√§ten unterbesetzt, darunter ein versteckter GPS-Tracker, der funktionieren sollte, wenn nicht bis zum Ende, dann zumindest bis ‚Äûfast alles‚Äú bereits vorhanden ist. <br><br>  Im Allgemeinen ist f√ºr mehrere Wochen der passiven Reflexion die Idee eines Ger√§ts, das die Spannung des Bordnetzes steuern und auf diesen Daten basieren soll, um die Stromversorgung f√ºr zwei Verbrauchergruppen zu steuern: sekund√§r (Rekorder, USB-Buchse) und einfach (GPS-Tracker und einige wenige) was). <br><br><h3>  Wie k√∂nnte das gemacht werden? </h3><br>  Die ersten virtuellen Prototypen des Ger√§ts wurden auf Basis der analogen Komparatoren LM393N ‚Äûgebaut‚Äú und konnten alles, was urspr√ºnglich geplant war, vom Ger√§t empfangen.  Das abstrakte Schema war ungef√§hr so. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/la/yb/cflaybsmn6m3e6o7mshcfb_1j20.png"></div><br>  Hier werden zwei Komparatoren zum Schalten von Lasten verwendet.  Ein gemeinsamer Referenzspannungsgenerator, zwei Teiler, die die Schwellenwerte f√ºr den Betrieb bestimmen, Umreifungskomparatoren, zwei Leistungsschalter.  Die externe Bindung des fertigen Ger√§ts ist wie folgt geplant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0m/77/ew/0m77ewzvozy52h6zr-fg7uaivg0.png"></div><br>  Der Prim√§rschl√ºssel bleibt l√§nger eingeschaltet als der Sekund√§rschl√ºssel, sodass der Abw√§rtswandler selbst √ºber ihn mit Strom versorgt wird.  Prim√§rlasten werden direkt an den Umrichter angeschlossen.  Der Sekund√§rschalter pendelt die Sekund√§rlasten, die sich bereits im + 5V-Stromkreis am Wechselrichterausgang befinden. <br><br><h3>  Was am Ende herauskam </h3><br>  Es scheint alles zu sein, was ben√∂tigt wird, aber wie so oft tauchten beim Gedanken an die Details Ideen f√ºr alternative Implementierungen auf.  Erstens enthielt die analoge Schaltung einen anst√§ndigen Berg diskreter Elemente, die Komparatorbetriebsmodi bereitstellen, und zweitens sollten die Ausl√∂seschwellen mithilfe von Trimmwiderst√§nden eingestellt werden, was die Einrichtung erschwert und die Wahrscheinlichkeit schafft, von Ruckeln und Zeit wegzukommen.  Am Ende wurde daher beschlossen, sich mit einer digitalen Implementierung zu befassen, die sich sowohl schematisch als auch im Setup als viel einfacher herausstellte und gleichzeitig enorme M√∂glichkeiten zur Verbesserung des Steuerungsalgorithmus er√∂ffnete. In diesem Zusammenhang erwies sie sich vor allem als um eine Gr√∂√üenordnung wirtschaftlicher im Hinblick auf den Stromverbrauch. <br><br>  Der ATtiny13A-Controller hat lediglich nach dem Herzen des Ger√§ts gefragt, das neben Benutzerfreundlichkeit und Billigkeit immer noch in einem warmen, warmen R√∂hren-DIP-Geh√§use f√ºr Oldfag erh√§ltlich ist.  Anfangs schienen die F√§higkeiten selbst eines so kleinen Controllers an allen Fronten √ºberfl√ºssig zu sein, von der Anzahl der Ein- / Ausg√§nge bis zur Menge an Programm und RAM. Wie Sie wissen, kommt der Appetit jedoch mit einer Mahlzeit.  Mit Blick auf die Zukunft m√∂chte ich daher sagen, dass die endg√ºltige Version des Falls alle Schlussfolgerungen des Mikroschaltkreises enthielt und nicht mehr als zwei Dutzend Bytes freien Programmspeicher vorhanden waren. <br><br>  Um die Spannung des Bordnetzes zu messen, ben√∂tigte der Mikrocontroller nur einen Eingang, der mit dem ADC verbunden ist.  Zwei weitere logische Ergebnisse waren die Verwaltung der Verbraucher.  Zun√§chst bestand nach dem endg√ºltigen mentalen √úbergang zum ‚ÄûDigitalen‚Äú der Wunsch, zwei kostenlose GPIOs an das Unternehmen anzupassen, und die Entscheidung lie√ü nicht lange auf sich warten.  Als der Anlasser erneut in der K√§lte den Motor mit einem schlecht verdeckten Riss drehte, schien das Vorhandensein eines Temperatursensors in der Schaltung und im Algorithmus sehr n√ºtzlich zu sein.  Als Ergebnis wurde der zweite ADC zur Messung der Temperatur verwendet.  Damit der Thermistor nur dann Strom verbraucht, wenn er ben√∂tigt wird, wurde beschlossen, ihn vom letzten verbleibenden logischen Ausgang mit Strom zu versorgen. <br><br>  Infolgedessen hat das Ger√§tediagramm eine solche endg√ºltige Form erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ct/dt/jhctdt_pol1pk6xum1wwn_n7jzo.png"></div><br>  Hier sehen wir das Minimum an Details, und unter ihnen unterliegt nichts irgendeiner Art von "Verdrehung".  Lassen Sie uns kurz auf die wichtigsten Punkte eingehen. <br><br>  F√ºr die Stromversorgung ben√∂tigt der Controller eine stabile Spannung von 1,8 bis 5,5 V, was bedeutet, dass sich im Stromkreis ein Stabilisator befinden muss, der die Spannung des Bordnetzes auf das erforderliche Niveau senkt.  Unter dem Gesichtspunkt der Energieeinsparung scheint es einen Platz f√ºr einen ausschlie√ülich gepulsten Abw√§rtswandler zu geben, dies ist jedoch nur auf den ersten Blick m√∂glich.  Tatsache ist, dass ATtiny13A selbst im energieintensivsten Betriebsmodus (Frequenz 8 MHz, aktive Codeausf√ºhrung) nicht mehr als 6 mA verbraucht.  In diesem Schema befindet sich der Controller 99% der Zeit im Tiefschlafmodus und arbeitet auch mit einer Frequenz von 1,2 MHz, was zu einem durchschnittlichen Verbrauch von ungef√§hr weniger als 15 uA f√ºhrt.  Plus ca. 80 ¬µA zu den Basisstr√∂men der Steuertransistoren (wenn beide Lasten eingeschaltet sind).  Nun, f√ºr einen kleinen Bruchteil einer Sekunde wird die Leistung des Thermistors aktiviert, wodurch der durchschnittliche Strom um etwa 25 Mikroampere erh√∂ht wird.  Und hier ist die Antwort auf die Frage: "Lohnt es sich, einen Impulswandler f√ºr eine Last mit einem Verbrauch von nicht mehr als 120 ¬µA zu laden?"  Es scheint nicht so einfach.  Und wenn wir bedenken, dass es sich um analoge Messungen handelt, dann lohnt es sich definitiv nicht.  Daher wurde der Linearstabilisator LP2950 verwendet, ein Funktionsanalogon des beliebten 78L05, der jedoch wesentlich wirtschaftlicher ist.  Dieser Wandler kann bis zu 100 mA Strom am Ausgang abgeben und verbraucht f√ºr den geliebten Menschen nicht mehr als 75 ¬µA. <br><br>  Mit dem durch eine Zenerdiode und einen Kondensator gesch√ºtzten Spannungsteiler des Bordnetzes k√∂nnen Sie Spannungen bis 15 V messen. <br><br><blockquote>  Ich wei√ü, dass mich jetzt eine Welle der Kritik f√ºr eine solche Entscheidung treffen wird, aber wir werden objektiv sein.  Erstens entwickle ich keinen Satelliten, und zweitens gibt es keinen solchen Faktor, der zu einer Katastrophe f√ºhren w√ºrde.  Der Schulterwiderstand ist hoch, die Zenerdiode kann viel mehr Strom umleiten als derjenige, der durch den Teiler flie√üen kann, selbst im pessimistischsten Szenario.  Wenn die Zenerdiode nicht gen√ºgend Drehzahl hat, sch√ºtzt der Kondensator C2 vor Hochfrequenzimpulsen (mit einem Widerstand R7 wird ein Tiefpassfilter mit einer Grenzfrequenz von nur 7 Hz erzeugt).  D1 und R6 versichern in gewissem Ma√üe, dass das Schema voneinander abf√§llt.  Und man sollte die Linearit√§t nicht vergessen, jede Methode der galvanischen Isolierung an einem solchen Ort wird die theoretische Berechnung von Gr√∂√üen v√∂llig unrealistisch machen, wir m√ºssen zumindest den Prototyp kalibrieren, aber wir brauchen ihn nicht. </blockquote><br>  Der Ausgangswiderstand des Teilers ist zehnmal h√∂her als die empfohlenen 10 kOhm f√ºr die ADC-Signalquelle, aber dank des Kondensators C2 treten keine Messprobleme auf. <br><br><blockquote>  Im Allgemeinen wird die Eingangsimpedanz der ADC-Schaltungen der AVR-Controller gem√§√ü Datenblatt mit mindestens 100 Megaohm angegeben.  In demselben Datenblatt wird jedoch empfohlen, Quellen mit einem Innenwiderstand von bis zu 10 kOhm zu verwenden.  Warum so?  Der Punkt ist das Funktionsprinzip dieses ADC selbst.  Der Wandler arbeitet nach dem Prinzip der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sequentiellen Approximation</a> und seine Eingangsschaltung ist ein Tiefpassfilter aus einem Widerstand und einem Kondensator.  Das Erhalten eines 10-Bit-Abtastwerts ist iterativ, und es ist erforderlich, dass der Kondensator w√§hrend der gesamten Messzeit auf die volle gemessene Spannung aufgeladen wird.  Wenn die Ausgangsimpedanz der Quelle zu gro√ü ist, wird der Kondensator w√§hrend des Umwandlungsprozesses weiterhin direkt aufgeladen und das Ergebnis ist ungenau.  In unserem Fall betr√§gt die Kapazit√§t C2 mehr als das Siebentausendfache der Kapazit√§t des ADC-Filters. Wenn die Ladung beim Einschalten zum Zeitpunkt der Messung zwischen diesen Kondensatoren umverteilt wird, verringert sich die Eingangsspannung um nicht mehr als das 1/7000, was dem Siebenfachen entspricht weniger als die ultimative Genauigkeit eines 10-Bit-ADC.  Sie m√ºssen jedoch ber√ºcksichtigen, dass dieser Trick nur f√ºr einzelne Messungen mit signifikanten Pausen zwischen ihnen funktioniert. Sie sollten das Steuerungsprogramm also nicht "verbessern", indem Sie einen Zyklus f√ºr mehrere aufeinanderfolgende Messungen hinzuf√ºgen und das Ergebnis mitteln. </blockquote><br>  Der Teiler mit einem Thermistor aufgrund des Vorhandenseins einer gesteuerten Stromquelle wird unter Verwendung der empfohlenen Nennwerte gebaut.  NTCLE100E3 wird als Sensor verwendet, es gibt jedoch keine Einschr√§nkungen. Sie k√∂nnen jeden Thermistor mit ungef√§hr derselben Nennleistung verwenden. Die Hauptsache besteht darin, Korrekturen vorzunehmen, die seiner Charakteristik in den Quellcodekonstanten entsprechen, damit die Spannung des Teilers in den richtigen Temperaturwert umgewandelt wird. <br><br>  Als Steuertasten werden Leistungs-P-Kanal-MOSFETs jeglicher Art mit einem akzeptablen Open-Channel-Widerstand und einer maximalen Drain-Source-Spannung von mindestens 30 Volt verwendet.  Die obige Schaltung verwendet verschiedene Transistoren.  Dies geschieht, weil sie unterschiedliche Spannungen schalten m√ºssen und der Typ von jeder f√ºr bestimmte Arbeitsbedingungen ausgew√§hlt wurde.  Der obere Transistor sollte eine h√∂here Spannung aufweisen und der untere sollte nach M√∂glichkeit einen minimalen offenen Kanalwiderstand aufweisen.  Ich wiederhole jedoch, dass diese Entscheidung von der Ger√§teschaltschaltung (siehe oben) vorgegeben wird. Mit einer weiteren Einbeziehung k√∂nnen die Anforderungen an den unteren Transistor unterschiedlich sein. <br><br>  Zur Steuerung von Leistungsschaltern wird ein Paar identischer Bipolartransistoren verwendet.  Auf den ersten Blick scheinen diese Transistoren √ºberfl√ºssig zu sein, aber hier ist es nicht so einfach.  Feldeffekttransistoren mit einem isolierten Gate beginnen sich nicht ab einer Spannung der erforderlichen Polarit√§t am Gate zu √∂ffnen, sondern erst nach Erreichen eines bestimmten Schwellenwerts, der in den Datenbl√§ttern unter dem Namen ‚ÄûGate-Source-Schwellenspannung‚Äú aufgef√ºhrt ist und normalerweise 2..4 V betr√§gt z√§hle einfach.  Die Ausgangsschaltung der Steuerung kann zwei logische Ebenen bilden: logische "0" mit einer Spannung gegen Null;  und logische "1" mit Spannung, die zur Versorgung neigt.  Bei einer Spannung von 5 Volt sind dies Spannungen von etwa 0 bzw. 5 V.  Infolgedessen erzeugt beim Schalten einer 12-Volt-Quelle eine logische ‚Äû0‚Äú am Gate eine Spannungsdifferenz von Source-Gate 12 - 0 = 12 Volt. Der Leistungstransistor ist offen.  Alles scheint normal zu sein, aber eine logische ‚Äû1‚Äú mit einer Spannung von 5 V erzeugt eine Spannung zwischen 12 - 5 = 7 Volt zwischen der Quelle und dem Gate, und der Leistungstransistor bleibt weiterhin offen.  Somit kann das F√ºnf-Volt-Steuersignal den Schl√ºssel nicht steuern, der die Spannung √ºber 7,9 Volt umwandelt.  Daher arbeiten die Steuerbipolartransistoren weniger mit Signalschl√ºsseln als vielmehr mit Verst√§rkern, die die Steuerspannung von 5 Volt auf die Spannung des Bordnetzes erh√∂hen. <br><br>  Der Widerstand in der Basisschaltung jedes der Steuertransistoren begrenzt einfach den Strom der Reglerausg√§nge auf einen Pegel, der ausreicht, um ihn zu steuern.  Ihre Nennwerte k√∂nnen zwei- bis dreimal reduziert werden, ohne dass dies Auswirkungen auf den Betrieb der Schaltung hat. <br><br><blockquote>  Es ist leicht zu erkennen, dass sich die Steuertransistoren nicht in der auf dem LM393N basierenden analogen Schaltung befanden.  Die Sache ist, dass die Ausgangsstufe des ausgew√§hlten Komparators gem√§√ü der offenen Kollektorschaltung aufgebaut ist, dh ihr Ausgang ist einfach der Ausgang des Klemmen-Transistorkollektors.  Dieses Konstruktionsprinzip erfordert, dass zus√§tzliche Teile an den Chip geh√§ngt werden, um die Last der Ausgangsstufe zu erzeugen, macht den Chip jedoch andererseits sehr flexibel.  Ein offener Kollektor erm√∂glicht es dem Komparator, jede akzeptable Stromquelle zu steuern, und ist nicht nur mit der kompatibel, die den Komparator selbst mit Strom versorgt. </blockquote><br>  Ich muss sagen, dass die Begrenzung der Schwellenspannung eines Leistungs-MOSFET nicht nur auf hohe Spannungen wirkt, wie oben erw√§hnt, sondern auch auf niedrige.  Wenn die minimale √ñffnungsspannung des Transistors beispielsweise 4 Volt betr√§gt, wird beim Schalten der 3,3-V-Quelle selbst beim Verbinden des Gates mit Masse nicht die gew√ºnschte Spannungsdifferenz zwischen der Source und dem Gate erzeugt, und der Transistor bleibt geschlossen.  5 Volt sind also m√∂glicherweise die minimale Spannung, die von den ausgew√§hlten Transistoren zuverl√§ssig geschaltet werden kann. <br><br><h3>  Anpassung </h3><br>  Das Einrichten eines Ger√§ts ist eine separate Konversation.  Einerseits gibt es kein einziges Abstimmelement in der Schaltung, andererseits handelt es sich um Messspannungen mit einer Genauigkeit von nicht schlechter als 0,1 V. Wie kann man all dies verbinden?  Es gibt zwei M√∂glichkeiten.  Der erste besteht darin, die Widerst√§nde R6, R7 und R8 mit einer Toleranz von mindestens 1% (oder besser 0,1%) zu verwenden.  Die zweite beinhaltet die Verwendung herk√∂mmlicher Widerst√§nde mit Messung ihrer realen Widerst√§nde und Korrektur von Koeffizienten im Quellcode des Programms. <br><br>  Die erste Methode ist gut f√ºr die Massenproduktion, aber es ist viel attraktiver f√ºr uns, uns nicht mit der Suche nach den erforderlichen hochpr√§zisen Werten zu besch√§ftigen. Gehen wir also den zweiten Weg.  Der Widerstand kann mit einem gew√∂hnlichen Multimeter gemessen werden, seine Genauigkeit ist hier v√∂llig ausreichend.  Ein weiteres Messobjekt ist die Spannung des Stabilisators, der die Schaltung versorgt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der ADC der Steuerung kann in verschiedenen Modi arbeiten, aber aus mehreren Gr√ºnden ist es f√ºr uns bequemer, einen zu verwenden, bei dem das Ergebnis der digitalen Umwandlung relativ zur Versorgungsspannung gez√§hlt wird. Deshalb ist es wichtig, es so genau wie m√∂glich zu kennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Berechnung ist √§u√üerst einfach und besteht aus der Berechnung des Teilungskoeffizienten des Widerstandsteilers und des Anteils der √úbersetzung des Ergebnisses in LSB w√§hrend der Analog-Digital-Wandlung.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s-/-q/vf/s--qvfm_z0imo_xg5r7tnskhze0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ux ist die Eingangsspannung des Teilers; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ru ist der Widerstand des Oberarms des Teilers (dem Ux zugef√ºhrt wird); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rd ist der Widerstand des Unterarms des Teilers (der mit der Erde verbunden ist); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uref - Referenzspannung des ADC (d. H. Controller-Versorgungsspannung); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024 - die Anzahl der diskreten Werte am Ausgang eines 10-Bit-ADC; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSB ist der numerische Wert, den das Programm vom ADC erh√§lt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem Spannungsteiler R6-R7. Zum Beispiel nehmen wir reale Widerst√§nde, die den im Diagramm angegebenen vollst√§ndig entsprechen. Wir nehmen auch genau 5,0 V Leistung. Ein Beispiel f√ºr die Berechnung der Ergebnisse der Umwandlung einer Spannung von 13,5 Volt:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/ic/a2/nrica2q5vtygw-ck3mstvspkm4y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der richtigen Genauigkeit bei der Messung der Anfangswerte ist das Ergebnis genau genug, um es nicht in den Feldtests anzupassen, sondern so zu verwenden, wie es ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Formel zur Berechnung des Temperaturteilers ist im Prinzip nicht anders, nur Ru ist eine Variable, und Ux kann gleich Uref genommen werden. </font><font style="vertical-align: inherit;">Das Ergebnis sieht folgenderma√üen aus:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/t7/qi/zvt7qi05g21ecwvaquqnjdbhjli.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nehmen wir zum Beispiel den Wert von R8 aus der Schaltung und R9 aus dem Datenblatt auf NTCLE100E3 bei einer Temperatur von 0 ¬∞ C: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j5/gp/_k/j5gp_kzjcx3buv0ayejxoazlwcu.png"></div><br><blockquote>   ,        R8  R9      ,  , ,  . .       ,    R9   ,        0.5 m,       .   ,            ,   0.01 . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Widerstand des Thermistors bei verschiedenen Temperaturen ist im Datenblatt angegeben, aber es ist nat√ºrlich besser, ihn selbst zu messen. Letzteres kann ein Problem darstellen, daher schlage ich als Kompromiss vor, den tats√§chlichen Widerstand bei einer Temperatur zu messen und so den Korrekturkoeffizienten f√ºr die Widerst√§nde bei allen anderen Temperaturen aus dem Datenblatt zu ermitteln. Die meisten Thermistoren haben eine mehr oder weniger lineare Abh√§ngigkeit des Widerstands von der Temperatur, so dass diese Methode als ziemlich zuverl√§ssig angesehen werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich werden alle Konstanten im Programm unter der Annahme berechnet, dass die realen Werte vollst√§ndig dem Schema entsprechen, falls Teile mit kleinen Toleranzen verwendet werden.</font></font><br><br><h3>  Firmware </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das vollst√§ndige Projektarchiv f√ºr AtmelStudio (gcc-avr 5.4.0 Compiler) kann hier heruntergeladen </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , auch das bereits zusammengestellte </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und unter der Katzenliste der Quelldatei, um nicht weit zu gehen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode</font></font></b> <div class="spoiler_text"><pre><code class="cpp">//#define F_CPU 1200000UL //    <font></font>
<font></font>
#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/wdt.h&gt;<font></font>
#include &lt;avr/sleep.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt; <font></font>
#include &lt;util/delay.h&gt;<font></font>
<font></font>
//#define DBG<font></font>
<font></font>
#define TEMPERATURE_OVERHEAT 753 // LSB-  +50‚Å∞C<font></font>
#define TEMPERATURE_GIST     8   //    ( LSB)     <font></font>
#define VOLTAGE_GIST         3   //    ( LSB)     <font></font>
<font></font>
#define INTERVAL             WDTO_1S //     (1 )<font></font>
#ifndef DBG<font></font>
#define CELL_CHANGE_TIMEOUT  90  //      (  INTERVAL,   254)<font></font>
#define OVERHEAT_TIMEOUT     300 //      "" (  INTERVAL)<font></font>
#else<font></font>
#define CELL_CHANGE_TIMEOUT  2<font></font>
#define OVERHEAT_TIMEOUT     3<font></font>
#endif<font></font>
<font></font>
typedef unsigned char bool; //    <font></font>
#define true  0 == 0        //     <font></font>
#define false 0 != 0        //      <font></font>
<font></font>
typedef enum {st_none = 0b00, st_primary = 0b01, st_secondary = 0b10, st_both = 0b11} t_states; //    <font></font>
                                                                                                //       ,      <font></font>
typedef enum {adc_temperature, adc_voltage} t_measure;                                          //   <font></font>
typedef enum {move_null, move_up, move_down} t_movement;                                        //      <font></font>
<font></font>
//    <font></font>
struct t_coordidates {<font></font>
  signed char row, col;<font></font>
};<font></font>
<font></font>
//       <font></font>
struct t_correction {<font></font>
  t_movement voltage, temperature;<font></font>
};<font></font>
<font></font>
#define CELLS_ROWS 3 //      ( )<font></font>
#define CELLS_COLS 5 //      ( )<font></font>
<font></font>
//  <font></font>
const t_states CELLS[CELLS_ROWS][CELLS_COLS] = {<font></font>
  {st_both, st_both,    st_both,    st_primary, st_none},<font></font>
  {st_both, st_both,    st_primary, st_none,    st_none},<font></font>
  {st_both, st_primary, st_none,    st_none,    st_none}<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int ROWS_EDGES[CELLS_ROWS - 1] = {<font></font>
  241, // 0‚Å∞C<font></font>
  157  // -10‚Å∞C<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int COLS_EDGES[CELLS_COLS - 1] = {<font></font>
  864, // 13.5V<font></font>
  800, // 12.5V<font></font>
  787, // 12.3V<font></font>
  768  // 12.0V<font></font>
};<font></font>
<font></font>
unsigned int overheat_rest_time = 0; //       ""<font></font>
unsigned char cell_change_time  = 0; //      <font></font>
unsigned char no_cur_cell_time  = 0; //  ,            <font></font>
<font></font>
#define NULL_CELL (struct t_coordidates){.col = -1, .row = -1} // ,   <font></font>
#define NULL_CORRECTION (struct t_correction){.voltage = move_null, .temperature = move_null} // ,   <font></font>
<font></font>
struct t_correction moved_from = NULL_CORRECTION; //       <font></font>
struct t_coordidates cur_cell  = NULL_CELL,       //      <font></font>
                     next_cell = NULL_CELL;       //  -   <font></font>
<font></font>
//  <font></font>
static void init_pins() {<font></font>
  DDRB |= (1 &lt;&lt; PB0) | (1 &lt;&lt; PB1) | (1 &lt;&lt; PB3);     //   2 (PB3), 5 (PB0)  6 (PB1)  <font></font>
  PORTB &amp;= ~(1 &lt;&lt; PB0) &amp; ~(1 &lt;&lt; PB1) &amp; ~(1 &lt;&lt; PB3); //      2 (PB3), 5 (PB0)  6 (PB1)<font></font>
}<font></font>
<font></font>
// /    <font></font>
static void toggle_thermal_sensor(bool state) {<font></font>
  if(state) {<font></font>
    PORTB |= (1 &lt;&lt; PB1);  //  state ,      6 (PB1)<font></font>
<font></font>
    _delay_ms(5); //    <font></font>
  } else {<font></font>
    PORTB &amp;= ~(1 &lt;&lt; PB1); //  state  ,      6 (PB1)<font></font>
  }<font></font>
}<font></font>
<font></font>
//   <font></font>
static unsigned int measure_adc(t_measure measure) {<font></font>
  if(measure == adc_temperature) {<font></font>
    toggle_thermal_sensor(true); //    ,    <font></font>
<font></font>
    ADMUX = 0b10; //      -   3 (PB4)<font></font>
  } else {<font></font>
    ADMUX = 0b01; //      -   7 (PB2)<font></font>
  }<font></font>
<font></font>
  ADCSRA = (1 &lt;&lt; ADPS2) | //       = 16 (75 )<font></font>
           (1 &lt;&lt; ADIE) |  //    <font></font>
           (1 &lt;&lt; ADEN);   //  <font></font>
<font></font>
  set_sleep_mode(SLEEP_MODE_ADC); //   "" <font></font>
  do {<font></font>
    sleep_cpu(); //      ,      ,   <font></font>
  } while(ADCSRA &amp; (1 &lt;&lt; ADSC)); //        ,  <font></font>
<font></font>
  ADCSRA = 0; //  <font></font>
<font></font>
  toggle_thermal_sensor(false); //     <font></font>
<font></font>
  return ADC; //  10-  <font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
static void init_interrupts(void) {<font></font>
  sleep_enable(); //   <font></font>
<font></font>
  WDTCR = (1 &lt;&lt; WDCE) | (1 &lt;&lt; WDE); //  watchdog<font></font>
  WDTCR = (1 &lt;&lt; WDTIE) | INTERVAL; // watchdog      ,  1 <font></font>
<font></font>
  sei(); //  <font></font>
}<font></font>
<font></font>
//          <font></font>
static void toggle_loads(t_states states) {<font></font>
  unsigned char port = PORTB &amp; ~((1 &lt;&lt; PB3) | (1 &lt;&lt; PB0)),     //           ,   <font></font>
                bits = (((states &amp; st_primary) &gt;&gt; 0) &lt;&lt; PB3) | //        <font></font>
                       (((states &amp; st_secondary) &gt;&gt; 1) &lt;&lt; PB0);<font></font>
<font></font>
  PORTB = port | bits; //    <font></font>
}<font></font>
<font></font>
//     t_coordidates<font></font>
static bool cells_equal(struct t_coordidates cell1, struct t_coordidates cell2) {<font></font>
  return cell1.row == cell2.row &amp;&amp; cell1.col == cell2.col;<font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_row(unsigned int temperature) {<font></font>
  signed char row = 0;<font></font>
<font></font>
  while(row &lt; CELLS_ROWS - 1) {          //          <font></font>
    if(temperature &gt;= ROWS_EDGES[row]) { //  temperature     ,    <font></font>
      return row;<font></font>
    } else {<font></font>
      ++row;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_ROWS - 1; //  temperature         ,       <font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_col(unsigned int voltage) {<font></font>
  signed char col = 0;<font></font>
<font></font>
  while(col &lt; CELLS_COLS - 1) {      //          <font></font>
    if(voltage &gt;= COLS_EDGES[col]) { //  voltage     ,    <font></font>
      return col;<font></font>
    } else {<font></font>
      ++col;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_COLS - 1; //  voltage         ,       <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_row_edges(signed char row, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = row &gt; 0 ? ROWS_EDGES[row - 1] : 0xffff - TEMPERATURE_GIST; //       ,    <font></font>
  *lower = row &lt; CELLS_ROWS - 1 ? ROWS_EDGES[row] : TEMPERATURE_GIST; //       ,    <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_col_edges(signed char col, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = col &gt; 0 ? COLS_EDGES[col - 1] : 0xffff - VOLTAGE_GIST; //      (  )  ,    <font></font>
  *lower = col &lt; CELLS_COLS - 1 ? COLS_EDGES[col] : VOLTAGE_GIST; //      (  )  ,    <font></font>
}<font></font>
<font></font>
//    -              <font></font>
static void gisteresis_correction(struct t_coordidates* new_cell, unsigned int temperature, unsigned int voltage) {<font></font>
  unsigned int upper_edge, lower_edge;<font></font>
<font></font>
  get_row_edges(cur_cell.row, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;row &gt; cur_cell.row &amp;&amp; moved_from.temperature == move_up &amp;&amp; temperature &gt;= lower_edge - TEMPERATURE_GIST) {<font></font>
    --new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;row &lt; cur_cell.row &amp;&amp; moved_from.temperature == move_down &amp;&amp; temperature &lt;= upper_edge + TEMPERATURE_GIST) {<font></font>
    ++new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  get_col_edges(cur_cell.col, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;col &gt; cur_cell.col &amp;&amp; moved_from.voltage == move_up &amp;&amp; voltage &gt;= lower_edge - VOLTAGE_GIST) {<font></font>
    --new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;col &lt; cur_cell.col &amp;&amp; moved_from.voltage == move_down &amp;&amp; voltage &lt;= upper_edge + VOLTAGE_GIST) {<font></font>
    ++new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
}<font></font>
<font></font>
//       stdlib::abs()<font></font>
 static unsigned char absolute(signed char value) {<font></font>
  return value &gt;= 0 ? value : -value;<font></font>
}<font></font>
<font></font>
//      -<font></font>
static void calc_movement(struct t_coordidates new_cell) {<font></font>
  moved_from = NULL_CORRECTION;                                                   // -   <font></font>
  if(!cells_equal(new_cell, NULL_CELL) &amp;&amp; !cells_equal(cur_cell, NULL_CELL)) {    //         ,  -<font></font>
    if(absolute(new_cell.row - cur_cell.row) == 1) {                              //      <font></font>
      moved_from.temperature = new_cell.row &lt; cur_cell.row ? move_up : move_down; //   <font></font>
    }<font></font>
<font></font>
    if(absolute(new_cell.col - cur_cell.col) == 1) {                              //      <font></font>
      moved_from.voltage = new_cell.col &lt; cur_cell.col ? move_up : move_down;     //   <font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//   -<font></font>
static void set_next_cell(struct t_coordidates cell) {<font></font>
  next_cell = cell;<font></font>
  cell_change_time = 0; //    <font></font>
}<font></font>
<font></font>
//    <font></font>
static void set_cur_cell(struct t_coordidates cell) {<font></font>
  cur_cell = cell;<font></font>
  no_cur_cell_time = 0; //        <font></font>
  set_next_cell(NULL_CELL); //  -<font></font>
}<font></font>
<font></font>
// ,      <font></font>
static void change_cell(struct t_coordidates new_cell) {<font></font>
  if(cells_equal(new_cell, NULL_CELL)) { //         <font></font>
    toggle_loads(st_none);<font></font>
  } else {<font></font>
    toggle_loads(CELLS[new_cell.row][new_cell.col]); //         <font></font>
  }<font></font>
<font></font>
  calc_movement(new_cell); //     <font></font>
  set_cur_cell(new_cell);  //   <font></font>
}<font></font>
<font></font>
//  <font></font>
static void main_proc(void) {<font></font>
  unsigned int temperature, voltage; // 10- LSB-    <font></font>
  struct t_coordidates cell;         //      -<font></font>
<font></font>
  if(overheat_rest_time) { //      ""  ,          <font></font>
    --overheat_rest_time;<font></font>
  } else {<font></font>
    temperature = measure_adc(adc_temperature); //  <font></font>
    if(temperature &gt;= TEMPERATURE_OVERHEAT) {   //      +50C,  :<font></font>
      change_cell(NULL_CELL);                   //      (   )<font></font>
      overheat_rest_time = OVERHEAT_TIMEOUT;    //        <font></font>
    } else {<font></font>
      voltage = measure_adc(adc_voltage);   //  <font></font>
<font></font>
      cell.col = get_cell_col(voltage);     //    -  <font></font>
      cell.row = get_cell_row(temperature); //    -  <font></font>
<font></font>
      if(cells_equal(cur_cell, NULL_CELL)) { //        ,         <font></font>
        change_cell(cell);<font></font>
      } else {<font></font>
        gisteresis_correction(&amp;cell, temperature, voltage); //              <font></font>
<font></font>
        if(cells_equal(cell, cur_cell)) { //   -   ,      <font></font>
          set_next_cell(NULL_CELL);<font></font>
          no_cur_cell_time = 0; //    ,  <font></font>
        } else {<font></font>
          if(no_cur_cell_time++ &gt; CELL_CHANGE_TIMEOUT) { //    CELL_CHANGE_TIMEOUT+1        cur_cell,      <font></font>
            change_cell(cell); //    ,     <font></font>
          } else {<font></font>
            if(cells_equal(next_cell, NULL_CELL) || !cells_equal(next_cell, cell)) { //  -       ,   <font></font>
              set_next_cell(cell);<font></font>
            } else {<font></font>
              if(++cell_change_time &gt;= CELL_CHANGE_TIMEOUT) { //   ,       , ,    <font></font>
                change_cell(cell);<font></font>
              }<font></font>
            }<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
ISR(WDT_vect) {<font></font>
  WDTCR |= (1 &lt;&lt; WDTIE); //    watchdog   ""    <font></font>
}<font></font>
<font></font>
//    ,        ADSC  measure_adc()<font></font>
EMPTY_INTERRUPT(ADC_vect);<font></font>
<font></font>
//  <font></font>
int main(void) {<font></font>
  init_pins();       //  <font></font>
  init_interrupts(); //    watchdog<font></font>
	<font></font>
  while(true) {                          //  ,       <font></font>
    set_sleep_mode(SLEEP_MODE_PWR_DOWN); //        <font></font>
    sleep_cpu();                         //        watchdog <font></font>
<font></font>
    main_proc();                         //          <font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<br>
    : L:0x6A, H:0xFF.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip des Programms ist wie folgt. </font><font style="vertical-align: inherit;">Es gibt eine Tabelle mit Ausgangszust√§nden, in der die horizontale Achse die Spannung des elektrischen Systems und die vertikale Achse die Temperatur ist. </font><font style="vertical-align: inherit;">Das Programm misst die Spannung und Temperatur und findet in der Tabelle eine Zelle, die den Zustand der Last bestimmt. </font><font style="vertical-align: inherit;">Die Tabelle selbst hat die folgende Form:</font></font><br>
<br>
<a href=""><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/wx/ez/0jwxezo197qadbln8crg05zwlhq.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die oberste Zeile der Tabelle definiert den √úberhitzungsmodus und wird von einem separaten einfachen Zweig verarbeitet, sodass er nicht im Quellcode enthalten ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr den normalen Betrieb reicht es jedoch nicht aus, nur die Werte zu messen und die Zellen zu z√§hlen. Die Spannung des elektrischen Systems kann sowohl von selbst als auch unter dem Einfluss von Schaltlasten durch unser Ger√§t schwanken. Die zweite ist besonders gef√§hrlich, da sie tats√§chlich eine Kette positiver R√ºckkopplungen erzeugt, die zum Auftreten periodischer Schwankungen im Zustand f√ºhrt.</font></font><br>
<br>
<blockquote>,  -      ,       .                ,    ,      . , - ,  ,    ,   ,                .  ..  -   ,           ,      .    .         .      ,      ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Schwingungsprozess zu unterdr√ºcken, wurde ein Hysteresemechanismus in das Programm eingef√ºhrt, der nach dem √úberschreiten der Zustandsgrenze die gerade gekreuzte Linie ein wenig gegen die Bewegung des Arbeitspunkts nach hinten verschiebt. Wenn Sie beispielsweise die Grenze von 12,5 V von unten nach oben √ºberschreiten, um in die entgegengesetzte Richtung zu √ºberqueren, m√ºssen Sie auf 12,4 V absteigen. Dieses Prinzip verhindert das Umschalten des Zustands auch unter dem Einfluss von ADC-Rauschen und Interferenzen erheblich. Konstanten, die die Breite der Hysterese vertikal und horizontal bestimmen, k√∂nnen ebenfalls leicht ge√§ndert werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_o/d5/9e/_od59e61ylpgaqhsrwwlwsro3dw.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/bu/uu/lobuuuqhkbahdsyinpg5hhokeyw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zur Hysterese werden dem Programm auch Zustandsschaltverz√∂gerungen hinzugef√ºgt, haupts√§chlich f√ºr F√§lle von kurzfristigen Spannungs√§nderungen, beispielsweise beim Starten des Motors. Es macht drei Sekunden lang keinen Sinn, die Last von einem halben Ampere zu trennen, wenn der Anlasser verwendet wird und mehrere hundert Ampere verbraucht. Selbst wenn die Spannung des elektrischen Systems in diesem Moment auf vollst√§ndig "Notfall" 8-9 Volt abf√§llt.</font></font><br>
<br>
<blockquote>         ,     .        ¬´¬ª    ,          .   ,      ,    ¬´¬ª ,     -    (,   ,   ,    ,  ,     -  ).</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obere Reihe der Tabelle weist weder eine Hysterese noch eine √úbergangsverz√∂gerung auf. Wenn die Temperatur von unten nach oben + 50 ¬∞ C √ºberschreitet, werden die Lasten sofort und bedingungslos abgeschaltet. Au√üerdem wurde f√ºr diesen Modus ein separates Exit-Timeout eingef√ºhrt, das erheblich gr√∂√üer ist als dasjenige, das beim √úberschreiten der verbleibenden Zellgrenzen verwendet wird. Eine R√ºckkehr aus diesem Modus ist nur m√∂glich, wenn die Temperaturanzeigen w√§hrend des gesamten Timeouts stabil unter dem Schwellenwert liegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Watchdog wird als ‚ÄûHerz‚Äú verwendet, das den Messzyklus festlegt. Es ist so konfiguriert, dass anstelle eines erzwungenen Neustarts ein Interrupt generiert wird, und weckt den Controller einfach regelm√§√üig aus dem Tiefschlaf f√ºr den n√§chsten Arbeitszyklus.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass eine solche L√∂sung uns die Hauptfunktion des Watchdog-Timers vorenth√§lt - das Einfrieren zu verhindern. </font><font style="vertical-align: inherit;">In Wirklichkeit ist dies jedoch nicht der Fall. </font><font style="vertical-align: inherit;">Watchdog ist so konzipiert, dass ein Flag, das die Erzeugung eines Interrupts anstelle eines Neustarts enth√§lt, bei jedem Ausl√∂sen von der Hardware zur√ºckgesetzt wird. </font><font style="vertical-align: inherit;">Wenn der Controller einfriert, wird nicht nur die Hauptprogrammschleife, sondern auch der Watchdog-Interrupt-Handler nicht ausgef√ºhrt. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der erste Vorgang das Interrupt-Flag l√∂scht und der n√§chste bereits einen vollst√§ndigen Neustart initiiert.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest des Programmcodes ist vollst√§ndig kommentiert und bedarf keiner detaillierten Analyse. </font><font style="vertical-align: inherit;">Die Gr√∂√üe der endg√ºltigen Firmware betrug 1006 Byte, so dass eine kleine Reserve f√ºr ein oder zwei kleinere Korrekturen √ºbrig bleibt.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gr√∂√üe der endg√ºltigen Bin√§rdatei h√§ngt √ºbrigens von den Optimierungsoptionen ab, was logisch ist. </font><font style="vertical-align: inherit;">Wie sich jedoch herausstellte, gab die O2-Option in meinem Fall die Mindestl√§nge an, w√§hrend die Os-Option zur Minimierung der Gr√∂√üe einen Code erzeugte, der kaum in die zugewiesenen 1024 Bytes passte. </font><font style="vertical-align: inherit;">Wenn das Programm also an der Grenze der Funktionen des Controllers liegt und nicht gut passt, ist es immer sinnvoll, mit diesem Parameter zu spielen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code leuchtet tats√§chlich nicht optimal in Bezug auf die Gr√∂√üe und kann, falls gew√ºnscht, um weitere hundert Bytes verkleinert werden, ohne die Funktionalit√§t zu verlieren.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platinenschema und Verdrahtungsdateien</font></font></b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/gg/nv/1bggnvmw6h-x7nab-h9ljuag1lq.png"></div><br>
     Eagle  <a href=""></a>.<br>
</div></div></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446956/">https://habr.com/ru/post/de446956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446942/index.html">Server, kannst du mich h√∂ren? BROP-Angriff am Beispiel der Aufgabe NeoQUEST-2019</a></li>
<li><a href="../de446944/index.html">Warum in unrentable Unternehmen investieren?</a></li>
<li><a href="../de446948/index.html">Wie der Android Gustuff-Trojaner Sahne (Fiat und Krypto) von Ihren Konten entfernt</a></li>
<li><a href="../de446950/index.html">76% der Hersteller haben keine Erfahrung mit der Implementierung von Additiven - warum ist es gut?</a></li>
<li><a href="../de446952/index.html">Erstellen Sie animierte Histogramme mit R.</a></li>
<li><a href="../de446958/index.html">Tricky Perl Quine</a></li>
<li><a href="../de446960/index.html">Das Haus, das Jack gebaut hat</a></li>
<li><a href="../de446962/index.html">Phishing und keine Chemie</a></li>
<li><a href="../de446964/index.html">Integration mit SAP ERP. Implementierung eines mobilen Preispr√ºfers in einem Gesch√§ft</a></li>
<li><a href="../de446966/index.html">Nachrichten der Woche: Hauptereignisse in IT und Wissenschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>