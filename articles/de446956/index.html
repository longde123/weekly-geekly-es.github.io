<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🏫 👨‍🌾 👨‍👩‍👧 Es ist schädlich für Licht oder wie man die Ladung einer Autobatterie hält 📉 🧚🏼 🧑🏿‍🤝‍🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich setze die Artikelserie zum Fahrradbau im Bereich des Niederspannungs-Stromkreismanagements fort. Dieses Mal werde ich über ein Gerät sprechen, das...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Es ist schädlich für Licht oder wie man die Ladung einer Autobatterie hält</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446956/">  Ich setze die Artikelserie zum Fahrradbau im Bereich des Niederspannungs-Stromkreismanagements fort.  Dieses Mal werde ich über ein Gerät sprechen, das die tiefe Entladung einer Autobatterie durch verschiedene sekundäre Verbraucher verhindert. <br><br><img src="https://habrastorage.org/webt/_p/pt/zv/_pptzvndfwivnln2xsqz7aae224.jpeg"><br>  <i>Eine der möglichen Folgen einer unkontrollierten Entladung.</i> <br><a name="habracut"></a><br>  Der Kauf des ersten Autos oder Motorrads ist ein wichtiger Meilenstein im Leben eines jeden Menschen, insbesondere eines Ingenieurs.  Denn wer außer den offensichtlichen Vorteilen seines neuen Eisenpferdes achtet sofort auf seine nicht offensichtlichen Nachteile?  Wer denkt sofort über Verbesserungen und Ergänzungen des Standards nach?  Wenn es sich um ein Auto aus dem oberen Segment und sogar um eine "modische" Marke handelt, scheint es natürlich zunächst so, als hätte es absolut alles.  Aber wie die Praxis zeigt, widerlegt die Zeit in diesem Fall die ersten Eindrücke.  Wenn Sie ein Auto der Economy-Klasse kaufen, jucken Ihre Hände schon am ersten Tag buchstäblich! <br><br>  Der Wunsch, Ihr Auto mit verschiedenen elektronischen Hilfsgeräten zu "stopfen", ist ganz natürlich.  Bald nach der Umsetzung all dieser Pläne konfrontiert das Leben den Autobesitzer jedoch mit einer harten Realität.  Es stellt sich heraus, dass selbst die modernsten Geräte, die auf der neuesten elementaren Basis gebaut wurden, immer noch sehr auf Elektrizität bedacht sind.  Und eine Autobatterie, die so riesig erscheint, ist überhaupt kein Kernreaktor und kann sich innerhalb weniger Tage leicht unter dem Gewicht all dieser scheinbar harmlosen Verbraucher „hinsetzen“. <br><br>  Um nicht weiter in abstrakte und hypothetische Situationen zu fließen, gehe ich direkt zu meiner Geschichte.  Nach dem Kauf eines Autos war das erste der Wunsch, einen Registrar darin zu setzen.  Dies geschah innerhalb kürzester Zeit, fast vollständig abhängig von der Geschwindigkeit der Zustellung des Pakets von AliExpress.  Es ist klar, dass die regelmäßige Stromversorgung über den Zigarettenanzünder äußerst unpraktisch war und der Rekorder über einen 12/5-V-Impulswandler schnell eine stationäre Verbindung zur nächsten Leitung des Bordnetzes herstellte.  Und seitdem  Um es milde auszudrücken, nicht gestern, dieser Konverter war nicht einmal modern, für seine eigenen Bedürfnisse, wie sich später herausstellte, aß er bis zu 21 mA Strom.  Lassen Sie uns nun abschätzen, wie viel dieser Konverter nur eine neue und voll aufgeladene Batterie mit einer Kapazität von 60 Ah versorgen kann.  Arithmetik ist extrem einfach und enttäuschend. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/kz/tb/ljkztbra63ol-bs6xwdpdxd4xjg.png"></div><br>  In weniger als vier Monaten landet ein Konverter, der nicht mit irgendetwas beladen ist, die Batterie buchstäblich auf Null.  Wenn wir berücksichtigen, dass sich eine Batterie, die nicht ganz frisch ist, leicht als weniger verwitwet herausstellen kann und die Ladung nach der Stadt Pokatushki bei weitem nicht 100% beträgt, beginnt ein regnerischer Tag leicht innerhalb eines Monats mit einem Haken. <br><br>  Und das ist alles, wiederhole ich, nur ein Spannungswandler.  Ja, heute können Sie einen Konverter kaufen, der nur einen halben Milliampere für seinen eigenen Bedarf benötigt, aber ich habe dieses Beispiel gegeben, um zu zeigen, wie langsam und sicher das <s>Wasser einen Stein schärft,</s> selbst wenn es geringfügig ist, aber ständig wirkt, zieht der Verbraucher Energie aus dem, was so riesig zu sein scheint Batterie. <br><br>  Wir gehen noch weiter, der Rekorder im FHD @ 30fps-Aufnahmemodus verbraucht fast 300 mA von der + 5V-Quelle, die nach der Konvertierung unter Berücksichtigung des Wirkungsgrads etwa 150 mA Strom aus dem integrierten Netzwerk liefert.  Angenommen, der Wandler wird durch einen modernen ersetzt, und wir berechnen die Entladezeit nur mit diesem Strom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/p8/fl/ufp8fldn4t5bfzpl8u8udb6fd3o.png"></div><br>  Etwas mehr als zwei Wochen, aber in der Praxis - zehn Tage.  Jetzt droht nach dem nächsten Urlaub oder der nächsten Geschäftsreise die Aussicht auf Beleuchtung (und möglicherweise auf Batteriewechsel). <br><br>  Und so passierte es mir: Als ich einen kurzen Zwangsurlaub machte, dachte ich nicht, dass in einer Woche oder so sogar ein Zentralschloss die Tür für mich nicht öffnen könnte. <br><br>  Viele werden sagen, dass es ihre eigene Schuld ist, dass alles stromlos sein muss oder zumindest die Aufnahme beenden muss, und sie werden Recht haben.  Aber das Leben ist das Leben, und die Erinnerung ist nicht dieselbe, und wie lange der kleine Krankenstand dauert, ist nicht immer im Voraus bekannt.  Daher entstand sofort die Idee eines Leistungsschalters. <br><br>  Es gibt natürlich eine Option, den Rekorder über den Zündschalter mit Strom zu versorgen, so dass er nur unterwegs funktioniert, aber diese Option ist auch nicht sehr, weil  Wenn das Auto auf dem Parkplatz stößt, möchte ich die Chance haben, den Täter zu sehen.  Kurz nach der Installation des Rekorders war das Auto mit mehreren weiteren Geräten unterbesetzt, darunter ein versteckter GPS-Tracker, der funktionieren sollte, wenn nicht bis zum Ende, dann zumindest bis „fast alles“ bereits vorhanden ist. <br><br>  Im Allgemeinen ist für mehrere Wochen der passiven Reflexion die Idee eines Geräts, das die Spannung des Bordnetzes steuern und auf diesen Daten basieren soll, um die Stromversorgung für zwei Verbrauchergruppen zu steuern: sekundär (Rekorder, USB-Buchse) und einfach (GPS-Tracker und einige wenige) was). <br><br><h3>  Wie könnte das gemacht werden? </h3><br>  Die ersten virtuellen Prototypen des Geräts wurden auf Basis der analogen Komparatoren LM393N „gebaut“ und konnten alles, was ursprünglich geplant war, vom Gerät empfangen.  Das abstrakte Schema war ungefähr so. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/la/yb/cflaybsmn6m3e6o7mshcfb_1j20.png"></div><br>  Hier werden zwei Komparatoren zum Schalten von Lasten verwendet.  Ein gemeinsamer Referenzspannungsgenerator, zwei Teiler, die die Schwellenwerte für den Betrieb bestimmen, Umreifungskomparatoren, zwei Leistungsschalter.  Die externe Bindung des fertigen Geräts ist wie folgt geplant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0m/77/ew/0m77ewzvozy52h6zr-fg7uaivg0.png"></div><br>  Der Primärschlüssel bleibt länger eingeschaltet als der Sekundärschlüssel, sodass der Abwärtswandler selbst über ihn mit Strom versorgt wird.  Primärlasten werden direkt an den Umrichter angeschlossen.  Der Sekundärschalter pendelt die Sekundärlasten, die sich bereits im + 5V-Stromkreis am Wechselrichterausgang befinden. <br><br><h3>  Was am Ende herauskam </h3><br>  Es scheint alles zu sein, was benötigt wird, aber wie so oft tauchten beim Gedanken an die Details Ideen für alternative Implementierungen auf.  Erstens enthielt die analoge Schaltung einen anständigen Berg diskreter Elemente, die Komparatorbetriebsmodi bereitstellen, und zweitens sollten die Auslöseschwellen mithilfe von Trimmwiderständen eingestellt werden, was die Einrichtung erschwert und die Wahrscheinlichkeit schafft, von Ruckeln und Zeit wegzukommen.  Am Ende wurde daher beschlossen, sich mit einer digitalen Implementierung zu befassen, die sich sowohl schematisch als auch im Setup als viel einfacher herausstellte und gleichzeitig enorme Möglichkeiten zur Verbesserung des Steuerungsalgorithmus eröffnete. In diesem Zusammenhang erwies sie sich vor allem als um eine Größenordnung wirtschaftlicher im Hinblick auf den Stromverbrauch. <br><br>  Der ATtiny13A-Controller hat lediglich nach dem Herzen des Geräts gefragt, das neben Benutzerfreundlichkeit und Billigkeit immer noch in einem warmen, warmen Röhren-DIP-Gehäuse für Oldfag erhältlich ist.  Anfangs schienen die Fähigkeiten selbst eines so kleinen Controllers an allen Fronten überflüssig zu sein, von der Anzahl der Ein- / Ausgänge bis zur Menge an Programm und RAM. Wie Sie wissen, kommt der Appetit jedoch mit einer Mahlzeit.  Mit Blick auf die Zukunft möchte ich daher sagen, dass die endgültige Version des Falls alle Schlussfolgerungen des Mikroschaltkreises enthielt und nicht mehr als zwei Dutzend Bytes freien Programmspeicher vorhanden waren. <br><br>  Um die Spannung des Bordnetzes zu messen, benötigte der Mikrocontroller nur einen Eingang, der mit dem ADC verbunden ist.  Zwei weitere logische Ergebnisse waren die Verwaltung der Verbraucher.  Zunächst bestand nach dem endgültigen mentalen Übergang zum „Digitalen“ der Wunsch, zwei kostenlose GPIOs an das Unternehmen anzupassen, und die Entscheidung ließ nicht lange auf sich warten.  Als der Anlasser erneut in der Kälte den Motor mit einem schlecht verdeckten Riss drehte, schien das Vorhandensein eines Temperatursensors in der Schaltung und im Algorithmus sehr nützlich zu sein.  Als Ergebnis wurde der zweite ADC zur Messung der Temperatur verwendet.  Damit der Thermistor nur dann Strom verbraucht, wenn er benötigt wird, wurde beschlossen, ihn vom letzten verbleibenden logischen Ausgang mit Strom zu versorgen. <br><br>  Infolgedessen hat das Gerätediagramm eine solche endgültige Form erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ct/dt/jhctdt_pol1pk6xum1wwn_n7jzo.png"></div><br>  Hier sehen wir das Minimum an Details, und unter ihnen unterliegt nichts irgendeiner Art von "Verdrehung".  Lassen Sie uns kurz auf die wichtigsten Punkte eingehen. <br><br>  Für die Stromversorgung benötigt der Controller eine stabile Spannung von 1,8 bis 5,5 V, was bedeutet, dass sich im Stromkreis ein Stabilisator befinden muss, der die Spannung des Bordnetzes auf das erforderliche Niveau senkt.  Unter dem Gesichtspunkt der Energieeinsparung scheint es einen Platz für einen ausschließlich gepulsten Abwärtswandler zu geben, dies ist jedoch nur auf den ersten Blick möglich.  Tatsache ist, dass ATtiny13A selbst im energieintensivsten Betriebsmodus (Frequenz 8 MHz, aktive Codeausführung) nicht mehr als 6 mA verbraucht.  In diesem Schema befindet sich der Controller 99% der Zeit im Tiefschlafmodus und arbeitet auch mit einer Frequenz von 1,2 MHz, was zu einem durchschnittlichen Verbrauch von ungefähr weniger als 15 uA führt.  Plus ca. 80 µA zu den Basisströmen der Steuertransistoren (wenn beide Lasten eingeschaltet sind).  Nun, für einen kleinen Bruchteil einer Sekunde wird die Leistung des Thermistors aktiviert, wodurch der durchschnittliche Strom um etwa 25 Mikroampere erhöht wird.  Und hier ist die Antwort auf die Frage: "Lohnt es sich, einen Impulswandler für eine Last mit einem Verbrauch von nicht mehr als 120 µA zu laden?"  Es scheint nicht so einfach.  Und wenn wir bedenken, dass es sich um analoge Messungen handelt, dann lohnt es sich definitiv nicht.  Daher wurde der Linearstabilisator LP2950 verwendet, ein Funktionsanalogon des beliebten 78L05, der jedoch wesentlich wirtschaftlicher ist.  Dieser Wandler kann bis zu 100 mA Strom am Ausgang abgeben und verbraucht für den geliebten Menschen nicht mehr als 75 µA. <br><br>  Mit dem durch eine Zenerdiode und einen Kondensator geschützten Spannungsteiler des Bordnetzes können Sie Spannungen bis 15 V messen. <br><br><blockquote>  Ich weiß, dass mich jetzt eine Welle der Kritik für eine solche Entscheidung treffen wird, aber wir werden objektiv sein.  Erstens entwickle ich keinen Satelliten, und zweitens gibt es keinen solchen Faktor, der zu einer Katastrophe führen würde.  Der Schulterwiderstand ist hoch, die Zenerdiode kann viel mehr Strom umleiten als derjenige, der durch den Teiler fließen kann, selbst im pessimistischsten Szenario.  Wenn die Zenerdiode nicht genügend Drehzahl hat, schützt der Kondensator C2 vor Hochfrequenzimpulsen (mit einem Widerstand R7 wird ein Tiefpassfilter mit einer Grenzfrequenz von nur 7 Hz erzeugt).  D1 und R6 versichern in gewissem Maße, dass das Schema voneinander abfällt.  Und man sollte die Linearität nicht vergessen, jede Methode der galvanischen Isolierung an einem solchen Ort wird die theoretische Berechnung von Größen völlig unrealistisch machen, wir müssen zumindest den Prototyp kalibrieren, aber wir brauchen ihn nicht. </blockquote><br>  Der Ausgangswiderstand des Teilers ist zehnmal höher als die empfohlenen 10 kOhm für die ADC-Signalquelle, aber dank des Kondensators C2 treten keine Messprobleme auf. <br><br><blockquote>  Im Allgemeinen wird die Eingangsimpedanz der ADC-Schaltungen der AVR-Controller gemäß Datenblatt mit mindestens 100 Megaohm angegeben.  In demselben Datenblatt wird jedoch empfohlen, Quellen mit einem Innenwiderstand von bis zu 10 kOhm zu verwenden.  Warum so?  Der Punkt ist das Funktionsprinzip dieses ADC selbst.  Der Wandler arbeitet nach dem Prinzip der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sequentiellen Approximation</a> und seine Eingangsschaltung ist ein Tiefpassfilter aus einem Widerstand und einem Kondensator.  Das Erhalten eines 10-Bit-Abtastwerts ist iterativ, und es ist erforderlich, dass der Kondensator während der gesamten Messzeit auf die volle gemessene Spannung aufgeladen wird.  Wenn die Ausgangsimpedanz der Quelle zu groß ist, wird der Kondensator während des Umwandlungsprozesses weiterhin direkt aufgeladen und das Ergebnis ist ungenau.  In unserem Fall beträgt die Kapazität C2 mehr als das Siebentausendfache der Kapazität des ADC-Filters. Wenn die Ladung beim Einschalten zum Zeitpunkt der Messung zwischen diesen Kondensatoren umverteilt wird, verringert sich die Eingangsspannung um nicht mehr als das 1/7000, was dem Siebenfachen entspricht weniger als die ultimative Genauigkeit eines 10-Bit-ADC.  Sie müssen jedoch berücksichtigen, dass dieser Trick nur für einzelne Messungen mit signifikanten Pausen zwischen ihnen funktioniert. Sie sollten das Steuerungsprogramm also nicht "verbessern", indem Sie einen Zyklus für mehrere aufeinanderfolgende Messungen hinzufügen und das Ergebnis mitteln. </blockquote><br>  Der Teiler mit einem Thermistor aufgrund des Vorhandenseins einer gesteuerten Stromquelle wird unter Verwendung der empfohlenen Nennwerte gebaut.  NTCLE100E3 wird als Sensor verwendet, es gibt jedoch keine Einschränkungen. Sie können jeden Thermistor mit ungefähr derselben Nennleistung verwenden. Die Hauptsache besteht darin, Korrekturen vorzunehmen, die seiner Charakteristik in den Quellcodekonstanten entsprechen, damit die Spannung des Teilers in den richtigen Temperaturwert umgewandelt wird. <br><br>  Als Steuertasten werden Leistungs-P-Kanal-MOSFETs jeglicher Art mit einem akzeptablen Open-Channel-Widerstand und einer maximalen Drain-Source-Spannung von mindestens 30 Volt verwendet.  Die obige Schaltung verwendet verschiedene Transistoren.  Dies geschieht, weil sie unterschiedliche Spannungen schalten müssen und der Typ von jeder für bestimmte Arbeitsbedingungen ausgewählt wurde.  Der obere Transistor sollte eine höhere Spannung aufweisen und der untere sollte nach Möglichkeit einen minimalen offenen Kanalwiderstand aufweisen.  Ich wiederhole jedoch, dass diese Entscheidung von der Geräteschaltschaltung (siehe oben) vorgegeben wird. Mit einer weiteren Einbeziehung können die Anforderungen an den unteren Transistor unterschiedlich sein. <br><br>  Zur Steuerung von Leistungsschaltern wird ein Paar identischer Bipolartransistoren verwendet.  Auf den ersten Blick scheinen diese Transistoren überflüssig zu sein, aber hier ist es nicht so einfach.  Feldeffekttransistoren mit einem isolierten Gate beginnen sich nicht ab einer Spannung der erforderlichen Polarität am Gate zu öffnen, sondern erst nach Erreichen eines bestimmten Schwellenwerts, der in den Datenblättern unter dem Namen „Gate-Source-Schwellenspannung“ aufgeführt ist und normalerweise 2..4 V beträgt zähle einfach.  Die Ausgangsschaltung der Steuerung kann zwei logische Ebenen bilden: logische "0" mit einer Spannung gegen Null;  und logische "1" mit Spannung, die zur Versorgung neigt.  Bei einer Spannung von 5 Volt sind dies Spannungen von etwa 0 bzw. 5 V.  Infolgedessen erzeugt beim Schalten einer 12-Volt-Quelle eine logische „0“ am Gate eine Spannungsdifferenz von Source-Gate 12 - 0 = 12 Volt. Der Leistungstransistor ist offen.  Alles scheint normal zu sein, aber eine logische „1“ mit einer Spannung von 5 V erzeugt eine Spannung zwischen 12 - 5 = 7 Volt zwischen der Quelle und dem Gate, und der Leistungstransistor bleibt weiterhin offen.  Somit kann das Fünf-Volt-Steuersignal den Schlüssel nicht steuern, der die Spannung über 7,9 Volt umwandelt.  Daher arbeiten die Steuerbipolartransistoren weniger mit Signalschlüsseln als vielmehr mit Verstärkern, die die Steuerspannung von 5 Volt auf die Spannung des Bordnetzes erhöhen. <br><br>  Der Widerstand in der Basisschaltung jedes der Steuertransistoren begrenzt einfach den Strom der Reglerausgänge auf einen Pegel, der ausreicht, um ihn zu steuern.  Ihre Nennwerte können zwei- bis dreimal reduziert werden, ohne dass dies Auswirkungen auf den Betrieb der Schaltung hat. <br><br><blockquote>  Es ist leicht zu erkennen, dass sich die Steuertransistoren nicht in der auf dem LM393N basierenden analogen Schaltung befanden.  Die Sache ist, dass die Ausgangsstufe des ausgewählten Komparators gemäß der offenen Kollektorschaltung aufgebaut ist, dh ihr Ausgang ist einfach der Ausgang des Klemmen-Transistorkollektors.  Dieses Konstruktionsprinzip erfordert, dass zusätzliche Teile an den Chip gehängt werden, um die Last der Ausgangsstufe zu erzeugen, macht den Chip jedoch andererseits sehr flexibel.  Ein offener Kollektor ermöglicht es dem Komparator, jede akzeptable Stromquelle zu steuern, und ist nicht nur mit der kompatibel, die den Komparator selbst mit Strom versorgt. </blockquote><br>  Ich muss sagen, dass die Begrenzung der Schwellenspannung eines Leistungs-MOSFET nicht nur auf hohe Spannungen wirkt, wie oben erwähnt, sondern auch auf niedrige.  Wenn die minimale Öffnungsspannung des Transistors beispielsweise 4 Volt beträgt, wird beim Schalten der 3,3-V-Quelle selbst beim Verbinden des Gates mit Masse nicht die gewünschte Spannungsdifferenz zwischen der Source und dem Gate erzeugt, und der Transistor bleibt geschlossen.  5 Volt sind also möglicherweise die minimale Spannung, die von den ausgewählten Transistoren zuverlässig geschaltet werden kann. <br><br><h3>  Anpassung </h3><br>  Das Einrichten eines Geräts ist eine separate Konversation.  Einerseits gibt es kein einziges Abstimmelement in der Schaltung, andererseits handelt es sich um Messspannungen mit einer Genauigkeit von nicht schlechter als 0,1 V. Wie kann man all dies verbinden?  Es gibt zwei Möglichkeiten.  Der erste besteht darin, die Widerstände R6, R7 und R8 mit einer Toleranz von mindestens 1% (oder besser 0,1%) zu verwenden.  Die zweite beinhaltet die Verwendung herkömmlicher Widerstände mit Messung ihrer realen Widerstände und Korrektur von Koeffizienten im Quellcode des Programms. <br><br>  Die erste Methode ist gut für die Massenproduktion, aber es ist viel attraktiver für uns, uns nicht mit der Suche nach den erforderlichen hochpräzisen Werten zu beschäftigen. Gehen wir also den zweiten Weg.  Der Widerstand kann mit einem gewöhnlichen Multimeter gemessen werden, seine Genauigkeit ist hier völlig ausreichend.  Ein weiteres Messobjekt ist die Spannung des Stabilisators, der die Schaltung versorgt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der ADC der Steuerung kann in verschiedenen Modi arbeiten, aber aus mehreren Gründen ist es für uns bequemer, einen zu verwenden, bei dem das Ergebnis der digitalen Umwandlung relativ zur Versorgungsspannung gezählt wird. Deshalb ist es wichtig, es so genau wie möglich zu kennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Berechnung ist äußerst einfach und besteht aus der Berechnung des Teilungskoeffizienten des Widerstandsteilers und des Anteils der Übersetzung des Ergebnisses in LSB während der Analog-Digital-Wandlung.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s-/-q/vf/s--qvfm_z0imo_xg5r7tnskhze0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ux ist die Eingangsspannung des Teilers; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ru ist der Widerstand des Oberarms des Teilers (dem Ux zugeführt wird); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rd ist der Widerstand des Unterarms des Teilers (der mit der Erde verbunden ist); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uref - Referenzspannung des ADC (d. H. Controller-Versorgungsspannung); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024 - die Anzahl der diskreten Werte am Ausgang eines 10-Bit-ADC; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSB ist der numerische Wert, den das Programm vom ADC erhält. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem Spannungsteiler R6-R7. Zum Beispiel nehmen wir reale Widerstände, die den im Diagramm angegebenen vollständig entsprechen. Wir nehmen auch genau 5,0 V Leistung. Ein Beispiel für die Berechnung der Ergebnisse der Umwandlung einer Spannung von 13,5 Volt:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/ic/a2/nrica2q5vtygw-ck3mstvspkm4y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der richtigen Genauigkeit bei der Messung der Anfangswerte ist das Ergebnis genau genug, um es nicht in den Feldtests anzupassen, sondern so zu verwenden, wie es ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Formel zur Berechnung des Temperaturteilers ist im Prinzip nicht anders, nur Ru ist eine Variable, und Ux kann gleich Uref genommen werden. </font><font style="vertical-align: inherit;">Das Ergebnis sieht folgendermaßen aus:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/t7/qi/zvt7qi05g21ecwvaquqnjdbhjli.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nehmen wir zum Beispiel den Wert von R8 aus der Schaltung und R9 aus dem Datenblatt auf NTCLE100E3 bei einer Temperatur von 0 ° C: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j5/gp/_k/j5gp_kzjcx3buv0ayejxoazlwcu.png"></div><br><blockquote>   ,        R8  R9      ,  , ,  . .       ,    R9   ,        0.5 m,       .   ,            ,   0.01 . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Widerstand des Thermistors bei verschiedenen Temperaturen ist im Datenblatt angegeben, aber es ist natürlich besser, ihn selbst zu messen. Letzteres kann ein Problem darstellen, daher schlage ich als Kompromiss vor, den tatsächlichen Widerstand bei einer Temperatur zu messen und so den Korrekturkoeffizienten für die Widerstände bei allen anderen Temperaturen aus dem Datenblatt zu ermitteln. Die meisten Thermistoren haben eine mehr oder weniger lineare Abhängigkeit des Widerstands von der Temperatur, so dass diese Methode als ziemlich zuverlässig angesehen werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich werden alle Konstanten im Programm unter der Annahme berechnet, dass die realen Werte vollständig dem Schema entsprechen, falls Teile mit kleinen Toleranzen verwendet werden.</font></font><br><br><h3>  Firmware </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das vollständige Projektarchiv für AtmelStudio (gcc-avr 5.4.0 Compiler) kann hier heruntergeladen </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , auch das bereits zusammengestellte </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und unter der Katzenliste der Quelldatei, um nicht weit zu gehen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode</font></font></b> <div class="spoiler_text"><pre><code class="cpp">//#define F_CPU 1200000UL //    <font></font>
<font></font>
#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/wdt.h&gt;<font></font>
#include &lt;avr/sleep.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt; <font></font>
#include &lt;util/delay.h&gt;<font></font>
<font></font>
//#define DBG<font></font>
<font></font>
#define TEMPERATURE_OVERHEAT 753 // LSB-  +50⁰C<font></font>
#define TEMPERATURE_GIST     8   //    ( LSB)     <font></font>
#define VOLTAGE_GIST         3   //    ( LSB)     <font></font>
<font></font>
#define INTERVAL             WDTO_1S //     (1 )<font></font>
#ifndef DBG<font></font>
#define CELL_CHANGE_TIMEOUT  90  //      (  INTERVAL,   254)<font></font>
#define OVERHEAT_TIMEOUT     300 //      "" (  INTERVAL)<font></font>
#else<font></font>
#define CELL_CHANGE_TIMEOUT  2<font></font>
#define OVERHEAT_TIMEOUT     3<font></font>
#endif<font></font>
<font></font>
typedef unsigned char bool; //    <font></font>
#define true  0 == 0        //     <font></font>
#define false 0 != 0        //      <font></font>
<font></font>
typedef enum {st_none = 0b00, st_primary = 0b01, st_secondary = 0b10, st_both = 0b11} t_states; //    <font></font>
                                                                                                //       ,      <font></font>
typedef enum {adc_temperature, adc_voltage} t_measure;                                          //   <font></font>
typedef enum {move_null, move_up, move_down} t_movement;                                        //      <font></font>
<font></font>
//    <font></font>
struct t_coordidates {<font></font>
  signed char row, col;<font></font>
};<font></font>
<font></font>
//       <font></font>
struct t_correction {<font></font>
  t_movement voltage, temperature;<font></font>
};<font></font>
<font></font>
#define CELLS_ROWS 3 //      ( )<font></font>
#define CELLS_COLS 5 //      ( )<font></font>
<font></font>
//  <font></font>
const t_states CELLS[CELLS_ROWS][CELLS_COLS] = {<font></font>
  {st_both, st_both,    st_both,    st_primary, st_none},<font></font>
  {st_both, st_both,    st_primary, st_none,    st_none},<font></font>
  {st_both, st_primary, st_none,    st_none,    st_none}<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int ROWS_EDGES[CELLS_ROWS - 1] = {<font></font>
  241, // 0⁰C<font></font>
  157  // -10⁰C<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int COLS_EDGES[CELLS_COLS - 1] = {<font></font>
  864, // 13.5V<font></font>
  800, // 12.5V<font></font>
  787, // 12.3V<font></font>
  768  // 12.0V<font></font>
};<font></font>
<font></font>
unsigned int overheat_rest_time = 0; //       ""<font></font>
unsigned char cell_change_time  = 0; //      <font></font>
unsigned char no_cur_cell_time  = 0; //  ,            <font></font>
<font></font>
#define NULL_CELL (struct t_coordidates){.col = -1, .row = -1} // ,   <font></font>
#define NULL_CORRECTION (struct t_correction){.voltage = move_null, .temperature = move_null} // ,   <font></font>
<font></font>
struct t_correction moved_from = NULL_CORRECTION; //       <font></font>
struct t_coordidates cur_cell  = NULL_CELL,       //      <font></font>
                     next_cell = NULL_CELL;       //  -   <font></font>
<font></font>
//  <font></font>
static void init_pins() {<font></font>
  DDRB |= (1 &lt;&lt; PB0) | (1 &lt;&lt; PB1) | (1 &lt;&lt; PB3);     //   2 (PB3), 5 (PB0)  6 (PB1)  <font></font>
  PORTB &amp;= ~(1 &lt;&lt; PB0) &amp; ~(1 &lt;&lt; PB1) &amp; ~(1 &lt;&lt; PB3); //      2 (PB3), 5 (PB0)  6 (PB1)<font></font>
}<font></font>
<font></font>
// /    <font></font>
static void toggle_thermal_sensor(bool state) {<font></font>
  if(state) {<font></font>
    PORTB |= (1 &lt;&lt; PB1);  //  state ,      6 (PB1)<font></font>
<font></font>
    _delay_ms(5); //    <font></font>
  } else {<font></font>
    PORTB &amp;= ~(1 &lt;&lt; PB1); //  state  ,      6 (PB1)<font></font>
  }<font></font>
}<font></font>
<font></font>
//   <font></font>
static unsigned int measure_adc(t_measure measure) {<font></font>
  if(measure == adc_temperature) {<font></font>
    toggle_thermal_sensor(true); //    ,    <font></font>
<font></font>
    ADMUX = 0b10; //      -   3 (PB4)<font></font>
  } else {<font></font>
    ADMUX = 0b01; //      -   7 (PB2)<font></font>
  }<font></font>
<font></font>
  ADCSRA = (1 &lt;&lt; ADPS2) | //       = 16 (75 )<font></font>
           (1 &lt;&lt; ADIE) |  //    <font></font>
           (1 &lt;&lt; ADEN);   //  <font></font>
<font></font>
  set_sleep_mode(SLEEP_MODE_ADC); //   "" <font></font>
  do {<font></font>
    sleep_cpu(); //      ,      ,   <font></font>
  } while(ADCSRA &amp; (1 &lt;&lt; ADSC)); //        ,  <font></font>
<font></font>
  ADCSRA = 0; //  <font></font>
<font></font>
  toggle_thermal_sensor(false); //     <font></font>
<font></font>
  return ADC; //  10-  <font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
static void init_interrupts(void) {<font></font>
  sleep_enable(); //   <font></font>
<font></font>
  WDTCR = (1 &lt;&lt; WDCE) | (1 &lt;&lt; WDE); //  watchdog<font></font>
  WDTCR = (1 &lt;&lt; WDTIE) | INTERVAL; // watchdog      ,  1 <font></font>
<font></font>
  sei(); //  <font></font>
}<font></font>
<font></font>
//          <font></font>
static void toggle_loads(t_states states) {<font></font>
  unsigned char port = PORTB &amp; ~((1 &lt;&lt; PB3) | (1 &lt;&lt; PB0)),     //           ,   <font></font>
                bits = (((states &amp; st_primary) &gt;&gt; 0) &lt;&lt; PB3) | //        <font></font>
                       (((states &amp; st_secondary) &gt;&gt; 1) &lt;&lt; PB0);<font></font>
<font></font>
  PORTB = port | bits; //    <font></font>
}<font></font>
<font></font>
//     t_coordidates<font></font>
static bool cells_equal(struct t_coordidates cell1, struct t_coordidates cell2) {<font></font>
  return cell1.row == cell2.row &amp;&amp; cell1.col == cell2.col;<font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_row(unsigned int temperature) {<font></font>
  signed char row = 0;<font></font>
<font></font>
  while(row &lt; CELLS_ROWS - 1) {          //          <font></font>
    if(temperature &gt;= ROWS_EDGES[row]) { //  temperature     ,    <font></font>
      return row;<font></font>
    } else {<font></font>
      ++row;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_ROWS - 1; //  temperature         ,       <font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_col(unsigned int voltage) {<font></font>
  signed char col = 0;<font></font>
<font></font>
  while(col &lt; CELLS_COLS - 1) {      //          <font></font>
    if(voltage &gt;= COLS_EDGES[col]) { //  voltage     ,    <font></font>
      return col;<font></font>
    } else {<font></font>
      ++col;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_COLS - 1; //  voltage         ,       <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_row_edges(signed char row, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = row &gt; 0 ? ROWS_EDGES[row - 1] : 0xffff - TEMPERATURE_GIST; //       ,    <font></font>
  *lower = row &lt; CELLS_ROWS - 1 ? ROWS_EDGES[row] : TEMPERATURE_GIST; //       ,    <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_col_edges(signed char col, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = col &gt; 0 ? COLS_EDGES[col - 1] : 0xffff - VOLTAGE_GIST; //      (  )  ,    <font></font>
  *lower = col &lt; CELLS_COLS - 1 ? COLS_EDGES[col] : VOLTAGE_GIST; //      (  )  ,    <font></font>
}<font></font>
<font></font>
//    -              <font></font>
static void gisteresis_correction(struct t_coordidates* new_cell, unsigned int temperature, unsigned int voltage) {<font></font>
  unsigned int upper_edge, lower_edge;<font></font>
<font></font>
  get_row_edges(cur_cell.row, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;row &gt; cur_cell.row &amp;&amp; moved_from.temperature == move_up &amp;&amp; temperature &gt;= lower_edge - TEMPERATURE_GIST) {<font></font>
    --new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;row &lt; cur_cell.row &amp;&amp; moved_from.temperature == move_down &amp;&amp; temperature &lt;= upper_edge + TEMPERATURE_GIST) {<font></font>
    ++new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  get_col_edges(cur_cell.col, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;col &gt; cur_cell.col &amp;&amp; moved_from.voltage == move_up &amp;&amp; voltage &gt;= lower_edge - VOLTAGE_GIST) {<font></font>
    --new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;col &lt; cur_cell.col &amp;&amp; moved_from.voltage == move_down &amp;&amp; voltage &lt;= upper_edge + VOLTAGE_GIST) {<font></font>
    ++new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
}<font></font>
<font></font>
//       stdlib::abs()<font></font>
 static unsigned char absolute(signed char value) {<font></font>
  return value &gt;= 0 ? value : -value;<font></font>
}<font></font>
<font></font>
//      -<font></font>
static void calc_movement(struct t_coordidates new_cell) {<font></font>
  moved_from = NULL_CORRECTION;                                                   // -   <font></font>
  if(!cells_equal(new_cell, NULL_CELL) &amp;&amp; !cells_equal(cur_cell, NULL_CELL)) {    //         ,  -<font></font>
    if(absolute(new_cell.row - cur_cell.row) == 1) {                              //      <font></font>
      moved_from.temperature = new_cell.row &lt; cur_cell.row ? move_up : move_down; //   <font></font>
    }<font></font>
<font></font>
    if(absolute(new_cell.col - cur_cell.col) == 1) {                              //      <font></font>
      moved_from.voltage = new_cell.col &lt; cur_cell.col ? move_up : move_down;     //   <font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//   -<font></font>
static void set_next_cell(struct t_coordidates cell) {<font></font>
  next_cell = cell;<font></font>
  cell_change_time = 0; //    <font></font>
}<font></font>
<font></font>
//    <font></font>
static void set_cur_cell(struct t_coordidates cell) {<font></font>
  cur_cell = cell;<font></font>
  no_cur_cell_time = 0; //        <font></font>
  set_next_cell(NULL_CELL); //  -<font></font>
}<font></font>
<font></font>
// ,      <font></font>
static void change_cell(struct t_coordidates new_cell) {<font></font>
  if(cells_equal(new_cell, NULL_CELL)) { //         <font></font>
    toggle_loads(st_none);<font></font>
  } else {<font></font>
    toggle_loads(CELLS[new_cell.row][new_cell.col]); //         <font></font>
  }<font></font>
<font></font>
  calc_movement(new_cell); //     <font></font>
  set_cur_cell(new_cell);  //   <font></font>
}<font></font>
<font></font>
//  <font></font>
static void main_proc(void) {<font></font>
  unsigned int temperature, voltage; // 10- LSB-    <font></font>
  struct t_coordidates cell;         //      -<font></font>
<font></font>
  if(overheat_rest_time) { //      ""  ,          <font></font>
    --overheat_rest_time;<font></font>
  } else {<font></font>
    temperature = measure_adc(adc_temperature); //  <font></font>
    if(temperature &gt;= TEMPERATURE_OVERHEAT) {   //      +50C,  :<font></font>
      change_cell(NULL_CELL);                   //      (   )<font></font>
      overheat_rest_time = OVERHEAT_TIMEOUT;    //        <font></font>
    } else {<font></font>
      voltage = measure_adc(adc_voltage);   //  <font></font>
<font></font>
      cell.col = get_cell_col(voltage);     //    -  <font></font>
      cell.row = get_cell_row(temperature); //    -  <font></font>
<font></font>
      if(cells_equal(cur_cell, NULL_CELL)) { //        ,         <font></font>
        change_cell(cell);<font></font>
      } else {<font></font>
        gisteresis_correction(&amp;cell, temperature, voltage); //              <font></font>
<font></font>
        if(cells_equal(cell, cur_cell)) { //   -   ,      <font></font>
          set_next_cell(NULL_CELL);<font></font>
          no_cur_cell_time = 0; //    ,  <font></font>
        } else {<font></font>
          if(no_cur_cell_time++ &gt; CELL_CHANGE_TIMEOUT) { //    CELL_CHANGE_TIMEOUT+1        cur_cell,      <font></font>
            change_cell(cell); //    ,     <font></font>
          } else {<font></font>
            if(cells_equal(next_cell, NULL_CELL) || !cells_equal(next_cell, cell)) { //  -       ,   <font></font>
              set_next_cell(cell);<font></font>
            } else {<font></font>
              if(++cell_change_time &gt;= CELL_CHANGE_TIMEOUT) { //   ,       , ,    <font></font>
                change_cell(cell);<font></font>
              }<font></font>
            }<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
ISR(WDT_vect) {<font></font>
  WDTCR |= (1 &lt;&lt; WDTIE); //    watchdog   ""    <font></font>
}<font></font>
<font></font>
//    ,        ADSC  measure_adc()<font></font>
EMPTY_INTERRUPT(ADC_vect);<font></font>
<font></font>
//  <font></font>
int main(void) {<font></font>
  init_pins();       //  <font></font>
  init_interrupts(); //    watchdog<font></font>
	<font></font>
  while(true) {                          //  ,       <font></font>
    set_sleep_mode(SLEEP_MODE_PWR_DOWN); //        <font></font>
    sleep_cpu();                         //        watchdog <font></font>
<font></font>
    main_proc();                         //          <font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<br>
    : L:0x6A, H:0xFF.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip des Programms ist wie folgt. </font><font style="vertical-align: inherit;">Es gibt eine Tabelle mit Ausgangszuständen, in der die horizontale Achse die Spannung des elektrischen Systems und die vertikale Achse die Temperatur ist. </font><font style="vertical-align: inherit;">Das Programm misst die Spannung und Temperatur und findet in der Tabelle eine Zelle, die den Zustand der Last bestimmt. </font><font style="vertical-align: inherit;">Die Tabelle selbst hat die folgende Form:</font></font><br>
<br>
<a href=""><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/wx/ez/0jwxezo197qadbln8crg05zwlhq.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die oberste Zeile der Tabelle definiert den Überhitzungsmodus und wird von einem separaten einfachen Zweig verarbeitet, sodass er nicht im Quellcode enthalten ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den normalen Betrieb reicht es jedoch nicht aus, nur die Werte zu messen und die Zellen zu zählen. Die Spannung des elektrischen Systems kann sowohl von selbst als auch unter dem Einfluss von Schaltlasten durch unser Gerät schwanken. Die zweite ist besonders gefährlich, da sie tatsächlich eine Kette positiver Rückkopplungen erzeugt, die zum Auftreten periodischer Schwankungen im Zustand führt.</font></font><br>
<br>
<blockquote>,  -      ,       .                ,    ,      . , - ,  ,    ,   ,                .  ..  -   ,           ,      .    .         .      ,      ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Schwingungsprozess zu unterdrücken, wurde ein Hysteresemechanismus in das Programm eingeführt, der nach dem Überschreiten der Zustandsgrenze die gerade gekreuzte Linie ein wenig gegen die Bewegung des Arbeitspunkts nach hinten verschiebt. Wenn Sie beispielsweise die Grenze von 12,5 V von unten nach oben überschreiten, um in die entgegengesetzte Richtung zu überqueren, müssen Sie auf 12,4 V absteigen. Dieses Prinzip verhindert das Umschalten des Zustands auch unter dem Einfluss von ADC-Rauschen und Interferenzen erheblich. Konstanten, die die Breite der Hysterese vertikal und horizontal bestimmen, können ebenfalls leicht geändert werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_o/d5/9e/_od59e61ylpgaqhsrwwlwsro3dw.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/bu/uu/lobuuuqhkbahdsyinpg5hhokeyw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zur Hysterese werden dem Programm auch Zustandsschaltverzögerungen hinzugefügt, hauptsächlich für Fälle von kurzfristigen Spannungsänderungen, beispielsweise beim Starten des Motors. Es macht drei Sekunden lang keinen Sinn, die Last von einem halben Ampere zu trennen, wenn der Anlasser verwendet wird und mehrere hundert Ampere verbraucht. Selbst wenn die Spannung des elektrischen Systems in diesem Moment auf vollständig "Notfall" 8-9 Volt abfällt.</font></font><br>
<br>
<blockquote>         ,     .        «»    ,          .   ,      ,    «» ,     -    (,   ,   ,    ,  ,     -  ).</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obere Reihe der Tabelle weist weder eine Hysterese noch eine Übergangsverzögerung auf. Wenn die Temperatur von unten nach oben + 50 ° C überschreitet, werden die Lasten sofort und bedingungslos abgeschaltet. Außerdem wurde für diesen Modus ein separates Exit-Timeout eingeführt, das erheblich größer ist als dasjenige, das beim Überschreiten der verbleibenden Zellgrenzen verwendet wird. Eine Rückkehr aus diesem Modus ist nur möglich, wenn die Temperaturanzeigen während des gesamten Timeouts stabil unter dem Schwellenwert liegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Watchdog wird als „Herz“ verwendet, das den Messzyklus festlegt. Es ist so konfiguriert, dass anstelle eines erzwungenen Neustarts ein Interrupt generiert wird, und weckt den Controller einfach regelmäßig aus dem Tiefschlaf für den nächsten Arbeitszyklus.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass eine solche Lösung uns die Hauptfunktion des Watchdog-Timers vorenthält - das Einfrieren zu verhindern. </font><font style="vertical-align: inherit;">In Wirklichkeit ist dies jedoch nicht der Fall. </font><font style="vertical-align: inherit;">Watchdog ist so konzipiert, dass ein Flag, das die Erzeugung eines Interrupts anstelle eines Neustarts enthält, bei jedem Auslösen von der Hardware zurückgesetzt wird. </font><font style="vertical-align: inherit;">Wenn der Controller einfriert, wird nicht nur die Hauptprogrammschleife, sondern auch der Watchdog-Interrupt-Handler nicht ausgeführt. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der erste Vorgang das Interrupt-Flag löscht und der nächste bereits einen vollständigen Neustart initiiert.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest des Programmcodes ist vollständig kommentiert und bedarf keiner detaillierten Analyse. </font><font style="vertical-align: inherit;">Die Größe der endgültigen Firmware betrug 1006 Byte, so dass eine kleine Reserve für ein oder zwei kleinere Korrekturen übrig bleibt.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Größe der endgültigen Binärdatei hängt übrigens von den Optimierungsoptionen ab, was logisch ist. </font><font style="vertical-align: inherit;">Wie sich jedoch herausstellte, gab die O2-Option in meinem Fall die Mindestlänge an, während die Os-Option zur Minimierung der Größe einen Code erzeugte, der kaum in die zugewiesenen 1024 Bytes passte. </font><font style="vertical-align: inherit;">Wenn das Programm also an der Grenze der Funktionen des Controllers liegt und nicht gut passt, ist es immer sinnvoll, mit diesem Parameter zu spielen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code leuchtet tatsächlich nicht optimal in Bezug auf die Größe und kann, falls gewünscht, um weitere hundert Bytes verkleinert werden, ohne die Funktionalität zu verlieren.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platinenschema und Verdrahtungsdateien</font></font></b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/gg/nv/1bggnvmw6h-x7nab-h9ljuag1lq.png"></div><br>
     Eagle  <a href=""></a>.<br>
</div></div></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446956/">https://habr.com/ru/post/de446956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446942/index.html">Server, kannst du mich hören? BROP-Angriff am Beispiel der Aufgabe NeoQUEST-2019</a></li>
<li><a href="../de446944/index.html">Warum in unrentable Unternehmen investieren?</a></li>
<li><a href="../de446948/index.html">Wie der Android Gustuff-Trojaner Sahne (Fiat und Krypto) von Ihren Konten entfernt</a></li>
<li><a href="../de446950/index.html">76% der Hersteller haben keine Erfahrung mit der Implementierung von Additiven - warum ist es gut?</a></li>
<li><a href="../de446952/index.html">Erstellen Sie animierte Histogramme mit R.</a></li>
<li><a href="../de446958/index.html">Tricky Perl Quine</a></li>
<li><a href="../de446960/index.html">Das Haus, das Jack gebaut hat</a></li>
<li><a href="../de446962/index.html">Phishing und keine Chemie</a></li>
<li><a href="../de446964/index.html">Integration mit SAP ERP. Implementierung eines mobilen Preisprüfers in einem Geschäft</a></li>
<li><a href="../de446966/index.html">Nachrichten der Woche: Hauptereignisse in IT und Wissenschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>