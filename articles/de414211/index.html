<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôâ üåñ ü§™ Entwicklung eines TELNET-Servers auf Basis von W5500 und ATMEGA8 ‚öΩÔ∏è üóÇÔ∏è üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In letzter Zeit ist der Arduino-Software- und Hardwarekomplex sehr beliebt geworden, mit dem verschiedene interessante elektronische Designs entwickel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines TELNET-Servers auf Basis von W5500 und ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414211/">  In letzter Zeit ist der Arduino-Software- und Hardwarekomplex sehr beliebt geworden, mit dem verschiedene interessante elektronische Designs entwickelt werden sollen.  Entw√ºrfe werden erstellt, indem das Arduino-Baseboard mit zus√§tzlichen erforderlichen Modulen verbunden wird.  Auf dem Arduino-Baseboard befindet sich ein Mikrocontroller, dessen Firmware in einer speziellen Entwicklungsumgebung f√ºr Arduino geschrieben wurde und in der Regel vorgefertigte Bibliotheken f√ºr das eine oder andere Modul verwendet. <br><br>  Eines der Module - W5500 - ist f√ºr die Herstellung elektronischer Strukturen vorgesehen, die mit dem Internet verbunden werden.  In diesem Fall bedeutet dies meistens eine Fernsteuerung seiner Struktur.  Zum Beispiel kann es ein ‚ÄûSmart Home‚Äú, ein Roboter und dergleichen sein.  Das trivialste Projekt (mit Ausnahme von Hello World) ist die Ferneinbindung von LEDs √ºber einen Webbrowser (Abb. 1).  Wenn anstelle von LEDs Transistorschalter und Relais angeschlossen sind, k√∂nnen st√§rkere Lasten geschaltet werden.  Somit ist das Programm (Firmware) dieses Entwurfs im Wesentlichen ein Webserver, der http-Anforderungen von einem entfernten Benutzer verarbeitet. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qj/xj/w5/qjxjw5zozlcgxty2zaxpld3tfow.jpeg"></div>  <i>Abb.</i>  <i>1. Verwaltung von LEDs √ºber einen Browser.</i> <br><br>  Das W5500-Modul basiert auf dem W5500-Chip selbst mit seinem Bodykit sowie dem BLS-Anschluss f√ºr MK √ºber SPI, dem RJ-45-Anschluss f√ºr den Anschluss an ein Computernetzwerk und einem linearen Spannungsregler f√ºr 3,3 V (Abb. 2). <br><br><img src="https://habrastorage.org/webt/ta/sd/nz/tasdnz169igf5gzmdd6geetdsc4.jpeg" width="375" height="375"><br><br>  <i>Abb.</i>  <i>2. Das W5500-Modul.</i> <br><br>  Der W5500-Chip ist ein vollwertiger Controller mit integrierter Verarbeitung eines ganzen Stapels von Netzwerkprotokollen von Ethernet bis TCP (Abb. 3).  Bei der Implementierung eines auf diesem Chip basierenden Entwurfs muss der Programmierer den TCP / IP-Protokollverarbeitungscode nicht schreiben. Es reicht aus, nur das Protokoll der Anwendungsschicht zu implementieren, das in TCP eingebettet wird.  Im obigen Beispiel (auf Arduino) wird http als Anwendungsprotokoll verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5n/a0/dx/5na0dx-_xgs06can1rxipmlul7y.jpeg"></div>  <i>Abb.</i>  <i>3. Die Struktur des W5500-Chips.</i> <br><br>  Ohne Arduino zu machen, habe ich mich entschlossen, die Dokumentation f√ºr den W5500-Chip im Detail zu studieren und das auf dem Atmega8-Mikrocontroller basierende Programm unabh√§ngig zu implementieren.  Dieses Programm enth√§lt keinen http-Handler.  Es ist erforderlich, den einfachsten (RAW) Datenaustausch √ºber das TCP-Protokoll unter Verwendung eines Remote-Terminals zu implementieren.  Es ist nicht ganz richtig, √ºber das Telnet-Protokoll zu sprechen, wie der Titel dieses Artikels besagt.  Es hat seine eigenen spezifischen Merkmale, die auf dem Austausch zus√§tzlicher Informationen √ºber die Parameter der Terminals beruhen.  Die meisten Telnet-Clients unterst√ºtzen jedoch RAW und ben√∂tigen die oben genannten nicht.  Daher enth√§lt das Atmega8 MK-Programm keinen Protokollhandler auf Anwendungsebene.  Sie wird sich nur mit der Initialisierung des W5500, der Socket-Verwaltung, dem Datenempfang und der √úbertragung befassen. <br><br>  Die Hauptanwendung dieses Entwurfs ist die Ger√§teverwaltung √ºber ein Remote-Terminal.  In diesem Fall wird das Design √ºber die UART-Schnittstelle (drei Dr√§hte GND, TxD, RxD) mit dem verwalteten Ger√§t verbunden.  Die Verwaltung √ºber das Terminal ist ein klassischer professioneller Ansatz in einem bestimmten Bereich, wenn keine grafische Oberfl√§che vorhanden ist.  Zum Beispiel eine Windows- oder Linux-Befehlszeile oder eine M√∂glichkeit, einen Router √ºber ein Terminal mithilfe des Telnet-Protokolls zu konfigurieren.  Das letzte Beispiel entspricht tats√§chlich der in diesem Artikel diskutierten Idee. <br><br>  Wenn ich dieses oder jenes Ger√§t entwickle, stelle ich mir vor, es bei Bedarf mit Textbefehlen √ºber ein Terminal zu steuern, das √ºber die UART-Schnittstelle verbunden ist.  Dies kann eine Verbindung zu einem normalen PC mit dem RS-232-COM-Anschluss √ºber den MAX232-Adapterchip oder mit USB (virtueller COM-Anschluss) √ºber den PL2303-Chip sein.  Sie k√∂nnen das Standardprogramm HyperTerminal als Terminal verwenden.  Mit der Verbreitung von Android-Smartphones wurde es bequem, eine Verbindung √ºber Bluetooth herzustellen: Ein Bluetooth-Modul (z. B. HC-06) ist mit der UART-Schnittstelle des Ger√§ts verbunden, und ein Smartphone ist drahtlos mit dem Modul verbunden.  Es gibt viele Anwendungen im Internet, die das Terminal √ºber Bluetooth implementieren.  So k√∂nnen Sie das Ger√§t √ºber das Terminal von einem Mobiltelefon aus √ºber Bluetooth in kurzer Reichweite steuern.  Mit dem in diesem Artikel beschriebenen Design k√∂nnen Sie die Steuerung √ºber das Terminal √ºber das Internet implementieren.  Das Terminal kann das Standard-HyperTerminal sein, das mit Windows XP geliefert wird, oder Sie k√∂nnen das Telnet-Dienstprogramm √ºber die Windows-Befehlszeile ausf√ºhren und darin arbeiten.  Wenn es sich um ein Smartphone handelt, k√∂nnen Sie eine der Anwendungen auf Android ausw√§hlen (es gibt auch eine gro√üe Anzahl davon) (Abb. 4). <br><br><img src="https://habrastorage.org/webt/4g/ia/x7/4giax7dezsah7q-pjb5eso6tftm.jpeg" width="400" height="640"><br><br>  <i>Abb.</i>  <i>4. Anwendungen f√ºr "TCP-Terminal" bei Google Play.</i> <br><br>  Der W5500-Chip verf√ºgt √ºber 8 unabh√§ngige Sockel, von denen jeder √ºber einen Speicher zum Empfangen und Senden von Informationen √ºber 2 KB verf√ºgt.  Insgesamt betr√§gt der Gesamtspeicher 16 KB zum Empfangen und 16 KB zum Senden von Informationen.  Diese Parameter werden standardm√§√üig verwendet, aber bei Bedarf kann der Speicher in der Phase der Chipinitialisierung √ºber Sockets neu zugewiesen werden.  Die hier beschriebene Anwendung verwendet die Standardspeichereinstellungen und alle 8 Sockets sind beteiligt.  Jedem Socket in der Phase seiner Initialisierung werden viele Parameter zugewiesen, von denen die wichtigsten der Betriebsmodus und der TCP-Port sind.  Der Betriebsmodus aller acht Sockets, die wir ben√∂tigen, ist der TCP-Servermodus.  Sie m√ºssen jedem Socket unterschiedliche Ports zuweisen.  Ich habe acht aufeinanderfolgende Ports verwendet, beispielsweise ab 4000. In der Initialisierungsphase des W5500-Moduls werden Netzwerkparameter zugewiesen, die mit dem Atmega8 MK-Programm verbunden sind: IP-Adresse, Subnetzmaske, IP-Adresse des Gateways und sogar die physische MAC-Adresse.  Die Netzwerkeinstellungen des W5500 m√ºssen mit den Einstellungen des Heimnetzwerks √ºbereinstimmen, mit dem er verbunden ist.  Bei einer Remoteverbindung mit unserem beschriebenen Ger√§t geben die Terminaleinstellungen die Hostadresse (IP-Adresse oder Dom√§nenname) und den Port an.  Die Hostadresse bezieht sich auf das W5500-Ger√§t, und der Port bezieht sich auf den Socket im Ger√§t.  Ein Socket kann mit nur einer Verbindung arbeiten.  Daher ist es m√∂glich, acht unabh√§ngige gleichzeitige Verbindungen herzustellen.  Abbildung 5 zeigt die Verbindungsparameter im Standardprogramm HyperTerminal zum W5500 mit der IP-Adresse 192.168.0.111 an Socket 0 (Port 4000).  Um eine Verbindung zum globalen Internet (von au√üen) herzustellen, m√ºssen Sie Ihren Heimrouter ordnungsgem√§√ü konfigurieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gl/xf/dt/glxfdtxvfstq3pbj0_bguqpusm8.jpeg"></div>  <i>Abb.</i>  <i>5. Verbindung √ºber TCP / IP in HyperTerminal.</i> <br><br>  Ich habe viele verschiedene TCP-Terminalanwendungen ausprobiert, jede hat ihre eigenen Vor- und Nachteile.  Zun√§chst k√∂nnen durch das Verfahren zum Packen eines TCP-Pakets zwei F√§lle unterschieden werden.  Im ersten Fall wird ein TCP-Paket generiert und sofort an den Server gesendet, wenn ein Zeichen in das Terminal eingegeben wird.  Somit ben√∂tigt das Datenfeld jedes Pakets 1 Byte und enth√§lt das vom Benutzer eingegebene Zeichen.  Das HyperTerminal-Programm funktioniert nur in diesem Modus.  Im zweiten Fall wird der Zeichensatz (Befehl) in ein separates Textfeld eingegeben. Wenn Sie auf die Schaltfl√§che "Senden" klicken, wird nur ein Paket mit einem Datenfeld gebildet, dessen Inhalt ein vom Benutzer eingegebener Zeichensatz ist.  Die Gr√∂√üe des Datenfeldes eines solchen Pakets in Bytes stimmt mit der Anzahl der eingegebenen Zeichen √ºberein.  Der zweite Fall ist der am meisten bevorzugte und bequemste sowie wirtschaftlich im Verkehr.  Unser Design funktioniert in beiden F√§llen und √ºbertr√§gt alle vom Remote-Benutzer eingegebenen Zeichen aus einem beliebigen Socket auf den Ausgang (TxD) des UART MK Atmega8. <br><br>  Auch hier haben die Organisation der Informations√ºbertragung vom Server zum Client ihre eigenen Merkmale.  Es ist m√∂glich, dass das MK-Programm auch direkt ein Einzelbyte-TCP-Paket generiert, wenn ein Byte (Zeichen) auf dem RxD UART MK-Zweig empfangen wird.  Sie k√∂nnen ein TCP-Paket aus einem Satz eingehender Bytes zum MK erstellen, indem ein spezielles zus√§tzliches Signal vorhanden ist, das nur w√§hrend der √úbertragung der Sequenz vom angeschlossenen Ger√§t vorhanden ist (Packungssignal).  Dieses Signal wird √ºbrigens verwendet, um den MAX485 auf √úbertragung umzuschalten, wenn RS-232 in eine Halbduplex-RS-485-Schnittstelle umgewandelt wird.  Wie ich jedoch √ºberzeugt war, ist es am bequemsten, einen Timer zu verwenden, d.h.  eine kleine Verz√∂gerung, w√§hrend der der Empfang von Zeichen und die Bildung des TCP-Pakets durchgef√ºhrt werden.  Dies ist die Methode, die ich in der beschriebenen Konstruktion implementiert habe.  Es funktioniert wie folgt.  Der Timer (die Zeit wird auf ungef√§hr 0,3 Sekunden eingestellt) startet, wenn das erste Zeichen eintrifft, und wird zur√ºckgesetzt, wenn jedes n√§chste Zeichen auf dem UART MK eintrifft.  Wenn innerhalb einer bestimmten Zeit keine Zeichen eintreffen, wird ein Paket mit den empfangenen Zeichen gebildet und an den Client gesendet, und der Timer stoppt.  In meinem speziellen Fall gibt es ein Massenmailing an allen Sockets, mit denen Clients verbunden sind. <br><br>  Jetzt geht es um Privatsph√§re.  Das beschriebene Remote-Terminal ist mit Verkehrsanalysatoren nicht vor Abh√∂ren gesch√ºtzt.  Selbst das Telnet-Protokoll selbst bietet keine Kennwortauthentifizierung und -verschl√ºsselung.  Hierf√ºr gibt es andere moderne Remote-Terminal-Protokolle.  Und sowohl bei Telnet als auch bei RAW (ohne Anwendungsprotokoll) k√∂nnen Sie eine indirekte Methode zur Kennwortauthentifizierung implementieren, die nur bei absichtlichem Eingriff unwirksam ist.  Diese Autorisierungsmethode sch√ºtzt jedoch vor unkontrolliertem "Linksverkehr".  Es kann von Spyware stammen, die beim Durchsuchen des IP-Adressbereichs bekannter Anbieter und des Portbereichs pl√∂tzlich eine Verbindung zu unserem Ger√§t herstellen kann (wenn sie Verbindungen aus dem Internet "abh√∂rt").  In meiner Firmware habe ich eine Client-Begr√º√üungsseite implementiert, wenn diese mit dem Server verbunden ist, d. H.  zum Design basierend auf dem W5500-Modul. <br><br>  Die Begr√º√üungsseite enth√§lt Informationen zur IP-Adresse des Clients, zur Socket-Nummer (zur √úberwachung) und zur Aufforderung zur Eingabe eines Kennworts (Abb. 6). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ea/nw/2q/eanw2qiq7wtm974w7brndgscqja.jpeg"></div>  <i>Abb.</i>  <i>6. Begr√º√üungsseite f√ºr den W5500-Server.</i> <br><br>  Nach dem Verbinden innerhalb des MK-Programms startet ein Timer (f√ºr ca. 18 Sekunden), w√§hrend dessen der Benutzer Zeit haben muss, ein bestimmtes Passwort einzugeben (das gleiche gilt f√ºr alle Sockets).  Wenn das Passwort nach Ablauf der eingestellten Zeit falsch eingegeben wird, informiert der Benutzer die entsprechende Meldung und der Server trennt die Verbindung (Abb. 7). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/i5/rh/qii5rh4vsutckz8oyinxlurdsv8.jpeg"></div>  <i>Abb.</i>  <i>7. Ein falsches Passwort melden.</i> <br><br>  Bei einem korrekt eingegebenen Passwort wird dem Benutzer auch die entsprechende Meldung angezeigt (Abb. 8).  Danach wird eine ‚Äûtransparente‚Äú Br√ºcke zwischen dem Remote-Terminal und der UART-Schnittstelle des MK hergestellt, an die das W5500-Modul √ºber SPI angeschlossen ist.  Der Betrieb einer solchen Br√ºcke wurde nur auf der Ebene der Benutzerteams getestet.  Ein vollwertiger Hochgeschwindigkeitsdatenaustausch kann m√∂glicherweise nicht garantiert werden, wenn in einigen F√§llen die Clientanwendung kein Benutzerterminal, sondern ein anderes Programm ist.  Dar√ºber hinaus garantiert das beschriebene Design keinen Vollduplex-Datenaustausch (genauer gesagt ist dies nicht vorgesehen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9j/lx/4c/9jlx4c2o2sjavhkdq2gut43oo7m.jpeg"></div>  <i>Abb.</i>  <i>8. Nachricht √ºber das richtige Passwort.</i> <br><br>  Wenn ein Passwort eingegeben wird, gibt der Benutzer die eingegebenen Zeichen nicht an das Terminal zur√ºck, und auch die R√ºcktaste funktioniert nicht (Rollback mit einem falsch eingegebenen Zeichen).  Die Passwortl√§nge betr√§gt 8 Zeichen.  Das MK-Programm scannt die ersten 8 vom Client empfangenen Zeichen, unabh√§ngig von ihrer Verteilung √ºber TCP-Pakete.  Ein Paket sollte jedoch 10 Byte nicht √ºberschreiten.  √úbrigens funktioniert die Funktion ‚ÄûTextdatei senden‚Äú in HyperTerminal sehr interessant.  Da diese Funktion mit einem Verkehrsanalysator √ºberpr√ºft wurde, werden bei Ausf√ºhrung dieser Funktion zwei TCP-Pakete gebildet: Das erste Paket mit Daten von 1 Byte enth√§lt das erste Zeichen der √ºbertragenen Textdatei und das zweite Paket enth√§lt den Rest des Inhalts. <br><br>  Der Server stellt zwei verschiedene Passw√∂rter zur Verf√ºgung.  Ein Kennwort wird verwendet, um die TCP-UART-Br√ºcke (normale Verwendung) wie oben beschrieben einzurichten, und das zweite Kennwort wird zur Steuerung des W5500-Moduls oder anderer Entwurfsparameter verwendet.  Wenn dieses Passwort eingegeben wird, wird dem Benutzer eine weitere Begr√º√üungsseite angezeigt und er wechselt in den Steuermodus.  Ich habe absichtlich vorgesehen, dass dieser Modus nur an einer der freien Steckdosen m√∂glich ist.  Wenn ein Socket mit diesem Modus belegt ist und versucht wird, sich an einem anderen Socket in diesem Modus anzumelden, wird die Verbindung vom Server sofort getrennt.  Vor der Pause wird eine Meldung √ºber die Socket-Nummer angezeigt, die bereits im Steuermodus arbeitet (besetzt) ‚Äã‚Äã(Abb. 9). <br><br>  Der Steuermodus bietet die von mir definierten Befehle, von denen eine Liste durch Eingabe des Hilfebefehls angezeigt wird.  Der Befehl sollte mit einem Zeilenumbruchzeichen (Eingabetaste) enden.  Wenn der Steuermodus aktiv ist, sendet der W5500-Server au√üerdem Servicemeldungen an das Terminal, z. B. √ºber das Verbinden von Clients mit anderen Sockets mit ihren IP-Adressen oder √ºber einen freien Socket.  Abbildung 10 zeigt das Obige.  Die Liste der Teams ist noch nicht vollst√§ndig, sie wird im Laufe der Zeit wieder aufgef√ºllt. <br><br><img src="https://habrastorage.org/webt/mb/bu/v_/mbbuv_bfry1kuj83z8wgwzxwbqm.jpeg" width="400" height="340"><br><br>  <i>Abb.</i>  <i>9. Eine Meldung √ºber eine besetzte Steckdose bei der Eingabe des Kennworts f√ºr den Steuermodus.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/es/dk/sn/esdksn_il5ajj_btzatrxlaxeb4.jpeg"></div>  <i>Abb.</i>  <i>10. W5500-Steuermodus.</i> <br><br>  Der Echo-Befehl deaktiviert oder aktiviert die R√ºckgabe des gedruckten Zeichens an das Terminal (Selbst√ºberwachung).  Die folgenden zwei Befehle dienen zum Lesen und Schreiben des Adressregisters des W5500-Chips.  Die Werte der Register f√ºr die Adressen sind in der Dokumentation zum W5500-Chip angegeben.  Ich habe diese universellen Befehle haupts√§chlich zum Debuggen eingef√ºhrt.  Der Befehl rl startet sofort die nachstehende Socket-Nummer neu.  In √§hnlicher Weise liest der Befehl sr den Status des Sockets und gibt seinen Wert als HEX-Nummer an.  Der Befehl "ens" gibt eine Tabelle mit Status f√ºr jeden Socket an: Status "0" - der Socket ist frei und wartet auf den Client, Status "1" - der Socket im normalen Gebrauch, Status "2" - der Socket im Steuermodus.  Sie k√∂nnen eine viel gr√∂√üere Anzahl von Befehlen eingeben.  Es ist n√ºtzlich, die Parameter, die in der Initialisierungsphase beim Einschalten des Ger√§ts in den Chip passen (z. B. Netzwerkparameter), zu √§ndern und im nichtfl√ºchtigen Speicher des MK zu speichern.  Es kann auch n√ºtzlich sein, spezielle Befehle einzugeben, die zus√§tzliche freie MK-Pins steuern.  Zum Beispiel "PC0 = 1", "PC2 = 0" usw.  Stellen Sie sicher, dass Sie den Konfigurationsbefehl UART-Schnittstelle MK ben√∂tigen. <br><br>  Betrachten Sie die subtileren Details der Arbeit des MK-Programms.  Zus√§tzlich zu den oben genannten Timern wird ein Timer aktiviert, wodurch alle etwa eine halbe Minute ein sogenannter Timer aktiviert wird  TCP-Steuerpakete "Keep-Alive".  Dies ist erforderlich, um die Verbindung zu √ºberpr√ºfen, wenn kein Benutzerdatenaustausch stattfindet.  Wenn aus irgendeinem Grund innerhalb einer bestimmten im W5500 festgelegten Zeit keine Best√§tigung vom Kunden erfolgt, wird der sogenannte  Timeout und der Socket wird neu gestartet.  Die Verbindung kann pl√∂tzlich unterbrochen werden, z. B. aufgrund einer Unterbrechung der Datenverbindung oder der physischen Schicht: Sie haben ein Ethernet-Kabel herausgezogen, das Internet getrennt oder eine Wi-Fi-Verbindung verloren usw. <br><br>  Basierend auf der Dokumentation zum W5500-Chip (Datenblatt) sind die folgenden Funktionen im Programmcode implementiert.  Erstens registrieren sich die Grundfunktionen des Schreibens und Lesens von W5500 an Adressen.  Funktionen der obersten Ebene - Hardware-Reset, Chip-Initialisierung, Socket-Initialisierung, √ñffnen eines Sockets, Abh√∂ren des Sockets, Trennen und Schlie√üen des Sockets, Senden des Befehls "keep_alive" und Neustarten des Sockets.  Die letzte Funktion ist eine Komposition der oben genannten Funktionen: Schlie√üen, √ñffnen, H√∂ren.  Die meisten Funktionen geben nach ihrer Ausf√ºhrung einen Socket-Statuswert zur√ºck.  Schlie√ülich sind die grundlegendsten Funktionen das Verarbeiten der empfangenen Informationen (Lesen aus dem Empfangspuffer) und das Verarbeiten der gesendeten Informationen (Schreiben in den TX-Puffer).  Empfehlungen zur Implementierung dieser Funktionen habe ich auf der offiziellen Website des Chipherstellers W5500 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ) √ºbernommen.  Die Empfangsfunktion √ºberschreibt die vom Empfangspuffer empfangenen Daten in ihren eigenen 128-Byte-Nicht-Ringpuffer.  Diese Gr√∂√üe reicht f√ºr einfache Anwendungen aus, und Sie k√∂nnen mit dem Atmega8-Mikrocontroller nicht viel erreichen.  Der TX-Puffer des W5500 √ºbertr√§gt auch Daten aus dem ebenfalls kleinen Zwischenpuffer.  Und wiederum gelangen Daten aus dem UART-Ringpuffer hinein.  Letzteres wird in der CVAVR-Entwicklungsumgebung mithilfe des Dienstprogramms CodeWizardAVR in der Phase der Projekterstellung automatisch implementiert. <br><br>  Der W5500 ist mit der MKI SPI-Schnittstelle (MOSI, MISO, SCK, SCLK) verbunden.  Zus√§tzlich ist der RST-Pin (Hardware-Reset) mit einem bestimmten MK-Ausgang verbunden, und der entsprechende INT-Pin ist mit dem externen Interrupt-Eingang INT0 verbunden.  Letzteres wird f√ºr den vorgesehenen Zweck verwendet: Wenn ein Ereignis im W5500-Modul auftritt, erzeugt es einen Impuls am INT-Pin, der von der Steuerung im K√∂rper des externen Interrupts verarbeitet wird.  MK erf√§hrt, an welchen Sockets das Ereignis aufgetreten ist, und schreibt dann die Ereigniscodes f√ºr jeden Socket in ein bestimmtes Array.  Die weitere Verarbeitung des Interrupts erfolgt innerhalb der Hauptprogrammschleife.  Insgesamt wurden f√ºnf Ereignisse dokumentiert: Der Client war verbunden, der Client wurde getrennt (genauer gesagt, eine Trennungsanforderung wurde eingereicht), Daten wurden vom Client empfangen, eine Zeit√ºberschreitung wurde behoben, die Daten wurden erfolgreich gesendet.  In der Hauptschleife werden alle Ereignisse au√üer dem letzten verarbeitet.  Die switch-case-Anweisung wird in diese Verarbeitung eingef√ºgt.  Der gr√∂√üte Teil des C-Codes befindet sich im Verarbeitungsabschnitt des dritten Ereignisses (Datenempfang).  Darin wird nach der Funktion der Verarbeitung der empfangenen Informationen auch der Schalterfalloperator platziert, aber in diesem Fall ist dieser "Schalter" einer Variablen zugeordnet, die f√ºr den Zustand des oben erw√§hnten Sockets verantwortlich ist (Werte 0, 1, 2).  Der erste Abschnitt ist f√ºr die Passworterkennung verantwortlich.  Empfangene Zeichen werden in einem separaten Passwortpuffer √ºberschrieben.  Unter bestimmten Bedingungen funktionieren die Funktionen zum Vergleichen der empfangenen Zeichenfolge mit konstanten Zeichenfolgen, die Kennw√∂rter enthalten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Falle eines Zufalls wird der entsprechende Status zugewiesen. Der zweite Abschnitt ist der einfachste - der Inhalt seines eigenen Puffers empfangener Informationen wird an den UART des Mikrocontrollers umgeleitet. Dies ist ein normaler Verwendungsmodus. Der dritte Abschnitt (der gr√∂√üte) ist f√ºr die Verarbeitung von Befehlen verantwortlich - Ger√§testeuerungsmodus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich zur Fortsetzung des Interrupt-Handlers enth√§lt die Hauptschleife des Programms virtuelle Timer-Handler - eine Zeit√ºberschreitung, um die Verbindung zu trennen, wenn das Kennwort nicht erfolgreich ist. Senden Sie regelm√§√üig "Keep-Alive" und senden Sie ein vom TCP-Timer gebildetes Paket an den Client. Die Funktion des Lesens von UART befindet sich auch im Hauptteil der Hauptschleife, in der die von der Steuerung empfangenen Zeichen in ihren eigenen (Zwischen-) √úbertragungspuffer √ºbertragen werden und der Zeitgeber zur√ºckgesetzt wird, der f√ºr die Bildung des TCP-Pakets verantwortlich ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Socket-Prozeduren werden in einem Zyklus von 0 bis 7 platziert, dessen Iterator an die Socket-Nummer gebunden ist. Somit erfolgt eine sequentielle Verarbeitung aller Sockets. Anfangs meinte ich, wenn Sie jedem der acht Sockets dieselbe Portnummer zuweisen, k√∂nnen Sie bis zu acht Benutzer am selben Port verbinden. Diese Konfiguration funktionierte jedoch nicht und dieses Problem wurde f√ºr die Zukunft verschoben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Entwurf des Leiterplattendesigns habe ich eine Echtzeituhr (RTC) auf dem DS1307-Chip bereitgestellt. Der Atmega8 MK, Quarz f√ºr die Frequenz 11,0592 MHz (Frequenz ausgew√§hlt f√ºr UART-Genauigkeit), ein Anschluss f√ºr das W5500-Modul, MK-Anschlussanschl√ºsse (einschlie√ülich SPI f√ºr Firmware, UART), RTC mit eigenem Quarz und CR2032-Batteriefach befinden sich auf einer zweiseitigen Leiterplatte , 5 V Linearregler (7805), Stromanschluss und mehr. Die Skizze der Leiterplatte im Sprint Layout-Programm ist in Abbildung 11 dargestellt. Das einzige rot dargestellte Element ist auf der R√ºckseite verl√∂tet, aber ich habe es auf die Vorderseite gel√∂tet.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/po/fd/zapofdoavvxgcamlagyghd_zkae.jpeg"></div>  <i>Abb.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Skizze der Leiterplatte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fotos der fertigen Konstruktion sind in Abbildung 12 dargestellt. Eine Uhr in dieser Konstruktion wird verwendet, um die Zeit w√§hrend verschiedener Ereignisse der W5500-Buchsen zu markieren, und diese Zeit wird dem Benutzer im Terminal neben der Nachricht zugewiesen, wenn der Benutzer im Steuermodus verbunden ist. Au√üerdem wird die Uhr f√ºr die Zukunft f√ºr Experimente mit dem NTP-Zeitprotokoll oder f√ºr andere Zwecke n√ºtzlich sein.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/fv/_r/hffv_rfjm1svqdgzmvmauahrmw0.jpeg"></div>  <i>Abb.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Fotos der fertigen Struktur.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfassend ist anzumerken, dass das interne Design zum gr√∂√üten Teil √§hnliche Ger√§te auf industrieller Ebene rechtfertigt. Der Hauptvorteil ist der Preis. Es stellte sich heraus, dass die Herstellung viel billiger war als der Preis eines fertigen √§hnlichen Ger√§ts. Und ein solcher Nachteil wie eine eingeschr√§nkte Funktionalit√§t ist unvermeidlich. In diesem Fall wurde ein vereinfachter Atmega8-Controller verwendet, da das entsprechende vereinfachte Ziel festgelegt wurde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hy/ko/fx/hykofxdictcvxijma6idea8hczq.jpeg"></div>  <i>Abb.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Industriekonverter TCP / IP - RS-232.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abbildung 13 zeigt ein Beispiel eines industriellen TCP / IP-zu-RS-232-Wandlers auf Basis des W5100-Chips, der dem W5500 sehr √§hnlich ist. Neben der flexiblen Verwaltungsoberfl√§che bietet es einen weiteren Vorteil. Zus√§tzlich zur Arbeit mit einem TCP / IP-Terminal kann ein spezieller Treiber, der mit dem Ger√§t geliefert wird, verwendet werden, um einen virtuellen COM-Port auf der Clientseite zu installieren. √úber diese k√∂nnen Sie eine Verbindung √ºber ein normales Terminal herstellen, das keinen TCP / IP-Verbindungsmodus hat. Dar√ºber hinaus kann das Ger√§t einen vollwertigen RS-232-Datenaustausch unterst√ºtzen, wenn ein Programm anstelle des Terminals √ºber einen virtuellen COM-Port angeschlossen ist. Das hei√üt, das in Abbildung 13 dargestellte Ger√§t ist eine vollwertige RS-232-Br√ºcke durch die Netzwerkinfrastruktur.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414211/">https://habr.com/ru/post/de414211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414199/index.html">Skynet, hi: K√ºnstliche Intelligenz hat gelernt, Menschen durch W√§nde zu sehen</a></li>
<li><a href="../de414201/index.html">G√∂ttlicher Code (GOTTES Code)</a></li>
<li><a href="../de414203/index.html">Betrug oder nicht Betrug? Wir √ºberpr√ºfen ICO mit f√ºnf Methoden</a></li>
<li><a href="../de414207/index.html">Das Problem des Innovators oder warum Sie sich an die Erfahrungen anderer wenden m√ºssen</a></li>
<li><a href="../de414209/index.html">IGNG - Inkrementeller neuronaler Gas-Inkremental-Algorithmus</a></li>
<li><a href="../de414213/index.html">Eins zwei drei! Chatbot von Google Sheets am Beispiel eines PvP-Spiels f√ºr Alice</a></li>
<li><a href="../de414215/index.html">Benutzerdefinierte Bl√∂cke in Chips (Silicon IP): So funktioniert es</a></li>
<li><a href="../de414217/index.html">Lokale Vertex-Smartphones: zuerst in der Qualit√§t, zuerst in den Chips, zuerst im Design</a></li>
<li><a href="../de414219/index.html">Die Erfahrung mit der Nutzung von Solarenergie in der Region Moskau: f√ºr, gegen und wer sie braucht</a></li>
<li><a href="../de414221/index.html">Analysieren und Arbeiten mit Codable in Swift 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>