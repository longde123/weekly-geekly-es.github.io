<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âœˆï¸ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ½ ğŸŒ² Game 3D di three.js, nw.js ğŸ’© ğŸ‘¨ğŸ»â€ğŸ’» ğŸ–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya memutuskan untuk merilis versi baru dari gim browser lama saya, yang selama beberapa tahun telah berhasil sebagai aplikasi di jejaring sosial. Ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Game 3D di three.js, nw.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450926/"> Saya memutuskan untuk merilis versi baru dari gim browser lama saya, yang selama beberapa tahun telah berhasil sebagai aplikasi di jejaring sosial.  Kali ini saya mulai mendesainnya juga sebagai aplikasi untuk Windows (7-8-10) dan menempatkannya di berbagai toko.  Tentu saja, di masa depan Anda dapat membuat rakitan untuk MacOS dan Linux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1c/tj/vi/1ctjvijgbjodkdjhwszw4atwgvm.jpeg"></div><br>  Kode permainan ditulis seluruhnya dalam javascript murni.  Untuk menampilkan grafik 3D, pustaka three.js digunakan sebagai tautan antara skrip dan WebGL.  Namun, ini adalah kasus di versi browser lama.  Yang paling penting dalam proyek ini bagi saya adalah alasannya, bersamaan dengan permainan, untuk menambah perpustakaan saya sendiri, yang dirancang untuk melengkapi three.js dengan alat untuk pekerjaan yang mudah dengan objek adegan, animasi mereka dan banyak fitur lainnya.  Saya kemudian meninggalkannya untuk waktu yang lama.  Sudah waktunya untuk kembali padanya. <br><a name="habracut"></a><br><br>  Pustaka saya berisi alat yang mudah digunakan untuk menambah dan menghapus objek dari adegan, mengubah properti masing-masing objek (jerat), animasi frame-independent dari objek 3D, shader langit dengan tekstur langit berbintang di malam hari, dan banyak lagi.  Saya akan memberi tahu Anda tentang beberapa di antaranya.  Mengenai langit, saya mengimplementasikan penciptaannya dengan satu fungsi yang mengambil sejumlah parameter input, menginisialisasi shader, memuat tekstur cloud (jika perlu) dan mulai memperbarui langit dengan iterasi yang diberikan. <br><br>  Namun, semuanya sedikit lebih rumit di sana - untuk secara berkala, tetapi jarang disebut fungsi, konstruksi lain benar-benar berfungsi, menggunakan setInterval (), di mana peristiwa dapat dilemparkan pada interval yang berbeda, dan itu akan mengurangi semua ini menjadi penyebut yang sama dan menyelesaikannya di sebelah kanan. waktu yang dibutuhkan peristiwa dalam daftar.  Di sana Anda juga dapat membuang interval pembaruan langit.  Tetapi pergerakan objek game 3D untuk kelancaran yang lebih besar telah dilaksanakan melalui requestAnimationFrame () ... <br><br>  Jadi, karena kita berbicara tentang langit, kita akan mulai dengan itu. <br><br><h3>  Langit </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/xw/da/gexwday-od32dav2p4gb48p1nme.jpeg"></div><br>  Menambahkan cakrawala ke adegan adalah sebagai berikut. <br><br>  Pertama, Anda perlu menambahkan lampu standar three.js ke adegan dengan nilai kecerahan (awal) maksimum.  Seluruh adegan dengan objeknya, cahaya dan atribut lainnya, agar tidak mengacaukan ruang global, akan disimpan di ruang nama apscene. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  (AmbLight)   apscene.AmbLight=new THREE.AmbientLight(0xFFFFFF); apscene.scene.add(apscene.AmbLight); //  (AmbLightBk)   (      ) apscene.AmbLightBk=new THREE.AmbientLight(0xFFFFFF); apscene.sceneb.add(apscene.AmbLightBk); // (, )   var SFog=new THREE.FogExp2(0xaaaaaa, 0.0007); apscene.scene.fog=SFog; // (, )   var SFogBk=new THREE.FogExp2(0xa2a2aC, 0.0006); apscene.sceneb.fog=SFogBk; //  apscene.hemiLight=new THREE.HemisphereLight(0xFFFFFF, 0x999999, 1); apscene.scene.add(apscene.hemiLight); //        .       .        three.js   ,   ,     ,  ,   ... apscene.dirLight=new THREE.DirectionalLight(...) apscene.dirLightBk=new THREE.DirectionalLight(...)</span></span></code> </pre> <br>  Setelah itu, Anda sudah dapat menjalankan animasi langit dengan shader, tekstur (blackjack dan ... yah, oke) melalui salah satu fungsi saya: <br><br><pre> <code class="javascript hljs">m3d.graph.skydom.initWorld( <span class="hljs-comment"><span class="hljs-comment">//  ,  ,         {saveStart:false}, { //ltamb (light ambient,    ) -       ltamb:{a1:-2, a2:8, k1:0.2, k2:0.75, obj:[ {obj:apscene.AmbLight.color, key:['r','g','b']} ]}, //a1  a2 -      (altitude,      ),     ,   obj,     (k1..k2),   k1  k2 -         // ,    ltamb :     -2  8 (    ),    (apscene.AmbLight.color),    r, g  b,    0.2  0.75     ( ,    ,    0xFFFFFF). //key -    ,        three.js //        (apscene.AmbLightBk.color).    (  altitude)  -4  12          0.3 ... 0.99    .  -4 , ,    0.3  ,   12   0.99   ltambb:{a1:-4, a2:12, k1:0.3, k2:0.99, obj:[ {obj:apscene.AmbLightBk.color, key:['r','g','b']} ]}, //      : ltdir:{a1:-2, a2:8, k1:0.0, k2:1, obj:[ {obj:apscene.dirLight, key:['intensity']}, {obj:apscene.dirLightBk, key:['intensity']} ]}, //       (apscene.dirLightBk)   ,    ,       . // ,      three.js    - inensity ( , apscene.dirLight.intensity).  ,  ,       three.js    . //  .   ,     ( 0.15  )     12  8 (, ,    8  12), : lthem:{a1:8, a2:12, k1:0.15, k2:0.3, obj:[ {obj:apscene.hemiLight, key:['intensity']} ]}, //         .       . //    ()   : ltambfog:{a1:-2, a2:8, k1:0.4, k2:1, obj:[ {obj:apscene.scene.fog.color, key:['r','g','b']} ]}, //  : ltambbfog:{a1:-2, a2:12, k1:0.25, k2:1, obj:[ {obj:apscene.sceneb.fog.color, key:['r','g','b']} ]}, //     .  ,         ,  . ltambfogd:{a1:8, a2:12, k1:0.2, k2:0.35, obj:[ {obj:apscene.scene.fog, key:['density']} ]}, //  ltambbfogd:{a1:6, a2:12, k1:0.2, k2:0.28, obj:[ {obj:apscene.sceneb.fog, key:['density']} ]}, //  ,      ( ,   ),   ,     ,   , -Â«Â»     ,      skyplane1..6: planeAmb:{a1:-5, a2:12, k1:0.5, k2:1.0, obj:[ {obj:apscene.user.skyplane1.material.color, key:['r','g','b']}, {obj:apscene.user.skyplane2.material.color, key:['r','g','b']}, {obj:apscene.user.skyplane3.material.color, key:['r','g','b']}, {obj:apscene.user.skyplane4.material.color, key:['r','g','b']}, {obj:apscene.user.skyplane5.material.color, key:['r','g','b']}, {obj:apscene.user.skyplane6.material.color, key:['r','g','b']} ]} //,     ,     ,  . };</span></span></code> </pre> <br>  Akibatnya, langit yang dinamis muncul di tempat kejadian dengan perubahan halus pada ketinggian matahari dan, karenanya, perubahan waktu. <br><br>  Tidak perlu menggunakan semua jenis pencahayaan di atas panggung.  Dan tidak perlu mengubah semua parameter tergantung pada waktu hari.  Namun, bermain dengan kecerahannya, Anda dapat membuat gambar yang cukup realistis tentang perubahan siang dan malam.  Anda dapat memberi nama parameter yang Anda inginkan, hal utama adalah mengamati kunci objek di dalamnya seperti yang ditentukan dalam three.js. <br><br>  Bagaimana tampilannya, Anda dapat melihat video dari adegan demo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PoAPy3ByPRU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ini adalah permainan yang berbeda.  Hanya saja cakrawala tidak berantakan dengan berbagai objek, dan karena itu karya skrip ini paling jelas terlihat.  Namun dalam game yang sedang didiskusikan cerita tersebut, pendekatan yang persis sama digunakan.  Kecepatan tinggi dari perjalanan waktu di sini ditetapkan hanya untuk tujuan demonstrasi, dan sehingga waktu mengalir, tentu saja, lebih lambat, dengan langkah yang sama dari iterasi memperbarui cakrawala.  Dalam demo ini, omong-omong, shader air terlibat, juga dengan parameter variabel, tergantung pada ketinggian matahari ... Tapi saya belum menyelesaikannya. <br><br><h3>  Performa </h3><br>  Semua ini sangat sedikit menuntut zat besi.  Bekerja di browser Chrome, ia memuat Xeon E5440 di bawah LGA775 (dan dengan 4 gigs RAM) sebesar 20%, dan inti dari kartu grafis GT730 sebesar 45%.  Tapi ini murni karena animasi air.  Jika kita berbicara tentang permainan di mana tidak ada air, tetapi ada kota, yang ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0i/_k/se/0i_ksepjxwtge9qffnonerlnkes.jpeg"></div><br>  kemudian pada saat mobil bergerak di sekitar kota - persen 45%, kartu video 50%.  Pada prinsipnya, dengan beberapa penarikan fps (hingga sekitar 30 frame per detik), ia bekerja dengan cukup baik bahkan pada Pentium4 3GHz (RAM 1Gb) dan pada tablet pada Intel Atom 1.3GHz (RAM 2Gb). <br><br>  Semua perangkat keras ini sangat lemah dan permainan serupa lainnya di WebGL dan HTML5, bahkan beberapa 2D, melambat pada saya tanpa dewa, sampai-sampai tidak mungkin untuk memainkannya.  Seperti kata mereka, tulis sendiri gimnya, sesuai kebutuhan, dan mainkan. <br><br><h3>  Adegan </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/zo/y1/jbzoy1gm1aomyfdgyp7udkziole.jpeg"></div><br>  Adegan 3D di three.js adalah objek adegan dan array anak-anaknya, pada kenyataannya, semua model 3D dimuat ke dalam adegan.  Agar tidak mendaftarkan panggilan bootloader untuk setiap model, saya memutuskan bahwa seluruh adegan game akan ditetapkan dalam bentuk konfigurasi tertentu, dengan satu locd array asosiatif besar: {} (seperti data lokasi), yang akan berisi semua pengaturan - lampu, jalur tekstur yang dimuat sebelumnya dan gambar untuk antarmuka, jalur ke semua model yang harus dimuat ke atas panggung, dan banyak lagi.  Secara umum, ini adalah konfigurasi penuh adegan.  Sudah diatur sekali dalam file js game dan diumpankan ke pemuat adegan saya. <br><br>  Dan objek locd: {} ini, khususnya, berisi jalur ke masing-masing model 3D yang perlu dimuat.  Jalur nol adalah jalur umum, dan kemudian jalur relatif untuk setiap objek, seperti: <br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">'path/myObj'</span></span>, scale, y, x,z, r*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>], <span class="hljs-string"><span class="hljs-string">'scene'</span></span>]</code> </pre> <br>  Dapat dipahami bahwa semua model diekspor dari editor 3D ke format json, yaitu mereka memiliki jalur seperti jalur / myObj.json.  Ini diikuti oleh skala (karena editor dapat disimpan dengan skala yang tidak cocok untuk permainan), posisi objek dengan tinggi (y), sepanjang sumbu (x) dan (z), kemudian sudut rotasi Â® model di (y), sejumlah parameter opsional nama adegan tempat memuat model - di adegan utama (adegan) atau di latar belakang (sceneb). <br><br>  Ya, itu perlu untuk mengimplementasikan ini bukan dalam bentuk yang sederhana, tetapi dalam bentuk array asosiatif.  Jadi urutan parameter tidak dapat dipahami bahkan tanpa dokumentasi, atau setidaknya tanpa jenis fungsi yang mengambil parameter ini, Anda tidak akan mengerti.  Saya pikir di masa depan saya akan membuat ulang garis-garis ini dalam array asosiatif.  Sementara itu, tampilannya seperti ini: <br><pre> <code class="javascript hljs">landobj: [ [<span class="hljs-string"><span class="hljs-string">'gamePath/'</span></span>], [ [<span class="hljs-string"><span class="hljs-string">'landscape/ground'</span></span>, <span class="hljs-number"><span class="hljs-number">9.455</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>], <span class="hljs-string"><span class="hljs-string">'scene'</span></span>], [<span class="hljs-string"><span class="hljs-string">'landscape/plants'</span></span>, <span class="hljs-number"><span class="hljs-number">9.455</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>], <span class="hljs-string"><span class="hljs-string">'scene'</span></span>], [<span class="hljs-string"><span class="hljs-string">'landscape/buildings/house01'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-420</span></span>,<span class="hljs-number"><span class="hljs-number">420</span></span>, <span class="hljs-number"><span class="hljs-number">-0.75</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>], <span class="hljs-string"><span class="hljs-string">'scene'</span></span>], ... ] ],</code> </pre> <br>  Model-model ini dimuat ke atas panggung dan ditempatkan di koordinat yang diberikan di sini dalam ruang.  Pada prinsipnya, semua model dapat dimuat sebagai objek tunggal, yaitu, diekspor dari editor sebagai adegan permainan keseluruhan dan dimuat ke dalam koordinat (0; 0; 0).  Maka hanya akan ada satu baris: landscape / ground - I have ground.json - ini adalah bagian utama dari dunia game.  Tetapi dalam kasus ini akan sulit untuk memanipulasi objek individual dari adegan tersebut, karena Anda harus terlebih dahulu melihat di konsol browser dan ingat anak-anak mana dari tanah besar ini.  Dan kemudian hubungi mereka dengan nomor.  Oleh karena itu, model permainan roaming paling baik dimuat dengan objek yang terpisah.  Kemudian mereka dapat diakses dengan nama dari array asosiatif, yang akan secara otomatis dibuat khusus untuk tujuan ini. <br><br>  Konfigurasi penuh gim ini mungkin terlihat, misalnya, seperti ini: <br><pre> <code class="javascript hljs">locd:{ <span class="hljs-comment"><span class="hljs-comment">// name: 'SeaBattle', type: 'game', menulabel: '', //    x:-420, y:70, z:-420, rot: -0.5, //    intsdistance: 200, // ambLtColor: 0xFFFFFF, ambLtColorBk: 0xFFFFFF, lightD: [0xDDDDDD,0.3,1000, 200000,0.3,-0.0003, -190,200000,-140,0,0,0, 200,-200,200,-200], lightDBk: [0xFFFFFF,0.3,10000, 40000,0.3,-0.0035, -190,1200,-140,0,0,0, 50000,-50000,50000,-50000], lightH: [0xFFFFFF,0x999999,1, 0,500,0], //      lightsP: [], //     lightsPDynamicAr: [ [0xffffff, 4, [0, -2000, 0], [50, 1.5] ] //[[distance], [decay]] ], //         (x,y,z) userPointLights: [ [0, -2000, 0] ], //   lightsS: [ [0xffffbb, 1.0, [0, 250, 180], [0, 0, 180], 0.5, 600,600,600, -0.0005] ], //  shadowMapCullFace:0, shadowsMode: 'all', //all,list,flag //  imagePaths: [ 'game/img/', 'interface.png', 'interface2.png' ], // 3D  landobj: [ ['game/models/'], [ ['landscape/land',1, 0, 0,0, 0.0*Math.PI,1,'','','',1,['','','',''],'scene'], ['landscape/sbp',1, 0, 0,180, 1.0*Math.PI,1,'','','',1,['','','',''],'scene'], ['landscape/sbu',1, 0, 0,1120, 1.0*Math.PI,1,'','','',1,['','','',''],'scene'] ] ], //        staffobj: [ ['game/models2/'], [ ] ], //  progobj: [ [ ] ] },</span></span></code> </pre> <br>  Ya, lebih baik untuk mengulang semua sub-array ini ke dalam array asosiatif, jika tidak urutan parameter di dalamnya tidak jelas ... <br><br><h3>  Model 3D </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/fm/ql/fzfmqlr4yfw3_tkm79xjwlb_ccw.jpeg"></div><br>  Hal lain yang menarik.  Memuat model.  Pustaka saya menerima model 3D dengan tekstur dan secara otomatis menetapkan beberapa parameter untuk masing-masing elemen (jerat), tergantung pada namanya.  Faktanya adalah bahwa jika, misalnya, model diatur untuk memberikan bayangan, maka itu akan dilemparkan oleh setiap jaring yang termasuk dalam komposisinya.  Tidak selalu diperlukan bahwa seluruh model membuat bayangan sepenuhnya atau memperoleh properti lain yang sangat memengaruhi kinerja.  Oleh karena itu, jika Anda menyalakan bendera tertentu yang menandakan bahwa perlu untuk mempertimbangkan setiap mesh secara terpisah, maka ketika memuat dimungkinkan untuk menentukan mesh mana yang memiliki properti ini atau itu dan mana yang tidak.  Sebagai contoh, sama sekali tidak perlu bayangan dilemparkan oleh atap datar datar rumah atau oleh banyak detail kecil yang tidak relevan dari model dengan latar belakang yang besar.  Semua sama, pemain tidak akan dapat melihat bayangan ini, dan kekuatan prosesor video akan digunakan untuk memprosesnya. <br><br>  Untuk melakukan ini, di editor grafis (Blender, Max, dll.), Anda dapat segera menentukan nama jerat (di bidang nama objek) sesuai dengan aturan tertentu.  Harus ada garis bawah (_).  Karakter kontrol bersyarat harus berada di sisi kiri, misalnya: d - doubleside (mesh dua arah, sebaliknya - satu arah), c (bayangan bayangan) - melemparkan bayangan, r (menerima bayangan) - mengambil bayangan.  Misalnya, nama mesh pipa di rumah mungkin cr_tube.  Banyak surat lain juga digunakan.  Sebagai contoh, "l" adalah collider, yaitu dinding rumah, yang memiliki nama crl_wall01, tidak akan membiarkan pemain melewati dirinya sendiri, dan juga akan melemparkan dan mengambil bayangan.  Tidak perlu membuat colliders, seperti atap atau pegangan pintu, dan dengan demikian menurunkan kinerja.  Seperti yang sudah Anda pahami, saat memuat model, perpustakaan saya mem-parsing nama-nama jerat dan memberi mereka properti yang sesuai di tempat kejadian.  Tetapi untuk ini, perlu menyebutkan semua jerat dengan benar sebelum mengekspor model dari editor 3D.  Ini secara signifikan akan menghemat kinerja. <br><br>  Semua flag kontrol untuk jerat di dalam objek: <br><blockquote>  col_ ... adalah collider.  Jala seperti itu akan ditampilkan hanya sebagai collider transparan dan tidak terlihat.  Di editor, dia bisa terlihat seperti apa saja, hanya bentuknya yang penting.  Sebagai contoh, itu bisa menjadi paralelepiped sekitar seluruh model jika perlu bagi pemain untuk tidak dapat melewati model ini (bangunan, batu besar, dll.). <br><br>  l_ ... adalah objek yang dapat dikoleksi.  Memberi mesh apapun sifat collider. <br><br>  i_ ... - persimpangan.  Mesh akan ditambahkan ke daftar persimpangan, yang dapat digunakan, misalnya, untuk mengkliknya, yaitu, untuk memberikan interaktivitas ke permainan. <br><br>  j_ ... juga persimpangan.  Sama seperti di atas, hanya versi yang lebih baru - dengan algoritma yang ditingkatkan untuk menemukan persimpangan dalam permainan dan konsumsi sumber daya yang lebih sedikit. <br><br>  e_ ... - persimpangan untuk pintu rumah (masuk / keluar).  Tidak termasuk persimpangan di atas objek jala lainnya.  Ini digunakan jika diperlukan di rumah pada suatu saat untuk membuat hanya pintu interaktif, tidak termasuk semua elemen interaktif lainnya.  Dengan imajinasi, Anda dapat menemukan ini dan banyak kegunaan lain. <br><br>  c_ ... - melemparkan bayangan.  Jala melemparkan bayangan. <br><br>  r_ ... - menerima bayangan.  Jala menerima bayangan dari semua jala lain yang melemparkannya. <br><br>  d_ ... - bilateral (dua sisi).  Terlihat di kedua sisi, teksturnya ditumpangkan di kedua sisi. <br><br>  t_ ... - transparan (transparan), jika seluruh objek diatur ke alphatest dalam three.js. <br><br>  u_ ... - transparan (transparan), dengan kerapatan tetap (0,4), jika seluruh objek tidak menentukan alphatest dalam three.js. <br><br>  g_ ... - gelas.  Transparansi tetap diatur (0,2). <br><br>  h_ ... - tidak terlihat (tersembunyi).  Untuk bagian-bagian dari objek (jerat) yang harus disembunyikan saat menambahkan objek ke adegan.  Dimasukkan dalam daftar tersembunyi. <br><br>  v_ ... terlihat.  Semua objek kecuali yang ditandai dengan "h" sudah terlihat, tetapi dengan bendera "v" mereka dimasukkan dalam daftar terpisah yang terlihat untuk penyembunyian lebih lanjut atau manipulasi lainnya. </blockquote><br>  Akibatnya, nama mesh mungkin menjadi sesuatu seperti ini: crltj_box1 (gips, menerima bayangan, collider, transparan, interaktif).  Dan jala lain sebagai bagian dari model yang sama: cr_box2 (hanya menampilkan dan mengambil bayangan), Secara alami, karakter kontrol dapat diatur dalam urutan apa pun.  Dengan demikian, dari editor Anda dapat mengontrol tampilan bagian objek di game di masa depan, atau lebih tepatnya, beberapa propertinya, menghemat, pada saat yang sama, daya komputasi. <br><br><h3>  Inti dari permainan </h3><br>  Artinya, sebenarnya, dari permainan tentang mana cerita itu, adalah untuk bergerak di sekeliling lapangan persegi dan membeli perusahaan.  Lapangan dibuat dalam bentuk jalan-jalan 3D.  Model ekonomi gim ini sangat berbeda dari modelnya.  Dalam permainan saya, ketika seseorang memulai bisnis, keuntungan yang Anda harapkan turun.  Dan sebaliknya, ketika Anda menemukan sesuatu, itu meningkat.  Semua perhitungan untung dan rugi dilakukan di Inspektorat Pajak di bidang Awal.  Anda juga dapat mengambil pinjaman dari bank, perdagangan sekuritas dan melakukan sejumlah hal lainnya.  Saya telah meningkatkan perilaku AI dibandingkan dengan versi lama.  Redid hampir semua model 3D dan tekstur permainan dan kinerja yang dioptimalkan.  Membuat lebih banyak pengaturan dan banyak lagi. <br><br><h3>  Animasi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lw/7u/m_/lw7um_phbrcpp-yx78ec5ihw9jy.jpeg"></div><br>  Untuk menggerakkan pergerakan objek-objek game, mesin paling sederhana digunakan, yang dengan frame rate yang diberikan (terbatas pada ke-60) mengubah parameter numerik apa pun untuk interval waktu tertentu, membagikan nilai-nilai antara ke pawang.  Dan di pawang, misalnya, model ditampilkan. <br><br>  Sebagai contoh.  Kita perlu memindahkan objek objek di ruang angkasa dari posisi (10; 10; 50) ke titik (100; 300; 60).  Kami menetapkan 3 parameter dengan menunjukkan nilai awal dan akhir.  Koordinat x akan bervariasi dari 10 hingga 100, y - dari 10 hingga 300 dan z - dari 50 hingga 60. Dan semua ini akan terjadi, katakanlah, dalam 4 detik. <br><pre> <code class="javascript hljs">m3d.lib.anim.add( <span class="hljs-string"><span class="hljs-string">'moveobj'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>, <span class="hljs-string"><span class="hljs-string">'and'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">userpar1</span></span>:<span class="hljs-number"><span class="hljs-number">111</span></span>, <span class="hljs-attr"><span class="hljs-attr">obj</span></span>:my3DObject}, [ {<span class="hljs-attr"><span class="hljs-attr">lim1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">lim2</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">sstart</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">sfin</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">t</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">lim1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">lim2</span></span>:<span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">sstart</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">sfin</span></span>:<span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">t</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">lim1</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">lim2</span></span>:<span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">sstart</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">sfin</span></span>:<span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">t</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>} ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ myPeriodicFun(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ myFinishFun(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } ); m3d.lib.anim.play();</code> </pre> <br>  Baris pertama dari 5 parameter: moveobj - nama animasi (apa saja), nomor 1-stream (Anda dapat menghidupkan objek secara paralel dalam jumlah stream yang tidak terbatas), 4000 - waktu animasi 4 detik, dan - hingga parameter yang tidak digunakan, yang di masa depan akan bertanggung jawab atas logika transisi antara animasi dalam aliran yang sama, userpar adalah sembarang array asosiatif yang akan diteruskan ke pawang sebagai parameter, misalnya, dengan jari-jari yang dihitung, sinus, cosinus, dan umumnya nilai apa pun yang dihitung untuk animasi ini, sehingga tidak akan dihitung dalam  tentang waktu setiap iterasi.  Atau dengan merujuk ke objek 3D, yang, pada kenyataannya, akan hidup. <br><br>  Berikutnya adalah array dengan parameter yang bisa berubah.  Kami menemukan bahwa parameter pertama adalah perubahan dalam koordinat x, yang kedua adalah y, yang ketiga adalah z.  Kami menulis untuk masing-masing dalam lim1 dan lim2, dari apa dan untuk ukuran apa itu akan berubah.  Di sstart dan sfin kami menentukan nilai yang sama.  Di sini Anda dapat menentukan awal, misalnya, dari beberapa nilai lain, maka parameter akan "gulir" dalam lingkaran dari itu ke sana, melewati lim2 dan memulai "revolusi" baru dengan lim1.  Sebagai contoh, ini diperlukan jika animasi kita dilingkarkan di antara beberapa nilai (lim1 dan lim2), tetapi kita harus memulainya bukan dari awal (yaitu, bukan dari lim1), tetapi dari beberapa nilai menengah. <br><br>  t: 0 hanya menetapkan bahwa animasi untuk parameter ini dilakukan 1 kali, sesuai dengan total waktu (4000), seolah-olah membentang ke sana.  Jika kita menetapkan angka lain, kurang dari waktu utama, maka parameter ini akan diulang dan akan diulang sampai waktu animasi utama (4000).  Ini nyaman, misalnya, untuk mengatur rotasi objek ketika sudut harus berulang kali melewati garis 360 derajat dan mengatur ulang ke 0. <br><br>  Berikutnya datang 2 panggilan balik - yang akan dieksekusi dengan setiap iterasi dan yang akan dieksekusi sekali setelah menyelesaikan seluruh animasi (titik keluar). <br><br>  MyPeriodicFun callback pertama (ini), misalnya, bisa seperti ini: <br><pre> <code class="javascript hljs">myPeriodicFun:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">self</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state=self.par[<span class="hljs-number"><span class="hljs-number">0</span></span>].state, state_old=self.par[<span class="hljs-number"><span class="hljs-number">0</span></span>].state_old; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state2=self.par[<span class="hljs-number"><span class="hljs-number">1</span></span>].state, state_old2=self.par[<span class="hljs-number"><span class="hljs-number">1</span></span>].state_old; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state3=self.par[<span class="hljs-number"><span class="hljs-number">2</span></span>].state, state_old3=self.par[<span class="hljs-number"><span class="hljs-number">2</span></span>].state_old; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((state!=state_old)||(state2!=state_old2)||(state3!=state_old3)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj=self.userpar.obj; obj.position.x=state; obj.position.y=state2; obj.position.z=state3; ap.cameraFollowObj(obj); }; },</code> </pre> <br>  Yaitu, pada setiap iterasi gerakan, parameter (diri) dilemparkan ke fungsi ini yang berisi nilai-nilai perantara yang dihitung untuk semua parameter animasi yang diberikan: self.par [0] .state, self.par [1] .state, self.par [2] .state.  Ini adalah x, y, dan z kami saat ini.  Misalnya, jika animasi berlangsung 4 detik, setelah 2 detik x akan sama dengan (100-10) / 2 = 45. Dan untuk semua koordinat.  Dengan demikian, dalam myPeriodicFun kita cukup menampilkan objek kita di koordinat ini.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika browser mulai berjalan lambat atau hanya berjalan lambat pada perangkat keras ini, itu tidak menakutkan: total waktu animasi tidak akan berubah, hanya frame rate akan turun dan gambar akan berubah menjadi peragaan slide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa memeriksa f ((status! = Status_old) ..., yaitu, apakah nilai yang baru dihitung sama dengan nilai lama (status_old mengingat yang dihitung dalam iterasi sebelumnya), yah, misalnya, sehingga jika beberapa parameter berubah kurang dari satu, maka jangan menggambar ulang seluruh objek dan tidak menghabiskan daya sistem di atasnya, dan mesin animasi menghasilkan bilangan bulat dalam keadaan dan state_old, yang, katakanlah, dapat diartikan sebagai langkah yang sama dengan piksel. Dan jika objek tidak bergerak relatif terhadap posisi sebelumnya bahkan dengan 1 pixel, maka tidak perlu menggambar ulang, karena e Posisi di layar tidak berubah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, animasi dipahami sebagai perubahan sederhana dalam sejumlah parameter dalam waktu tertentu dengan pengiriman nilai-nilai perantara ke fungsi panggilan balik. Misalnya, Anda dapat menambahkan parameter ke-4 lainnya, yang akan bertanggung jawab atas sudut rotasi objek. Dan Anda biasanya dapat menjejalkan parameter banyak objek menjadi satu animasi jika bergerak entah bagaimana seragam. Anda dapat menempatkan animasi di aliran yang berbeda, kemudian animasi akan diproses secara paralel. Anda dapat menambahkan (m3d.lib.anim.add ()) ke satu utas seluruh urutan animasi, dan mereka akan dieksekusi satu demi satu. Selain itu, setiap utas akan memiliki urutan independennya sendiri. Yang utama adalah bahwa sistem memiliki kekuatan yang cukup dan semuanya tidak berubah menjadi tampilan slide.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NB. Aliran di sini direalisasikan hanya dengan enumerasi berurutan pada setiap iterasi dari semua animasi paralel dan perhitungan untuk masing-masing dari mereka nilai-nilai menengah dari semua parameter mereka. </font><font style="vertical-align: inherit;">Artinya, tidak ada multithreading nyata dalam javascript. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Mesin" yang sama juga dapat digunakan untuk menghidupkan elemen elemen antarmuka dengan mengaturnya untuk mengubah 2 koordinat pada bidang layar dan menampilkan elemen-elemen ini dalam fungsi panggilan balik sesuai dengan nilai perantara yang diperoleh. </font><font style="vertical-align: inherit;">Yang sebenarnya dilakukan dalam gim saya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bayangan dinamis </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/4c/1-/fd4c1-dofkcz8fsysds0pbi_-eo.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menampilkan bayang-bayang di seluruh adegan ternyata sangat sia-sia sehingga ketika diaktifkan, fps turun beberapa kali. </font><font style="vertical-align: inherit;">Ini tidak baik. </font><font style="vertical-align: inherit;">Kami akan menampilkan bayangan dari objek di kotak kecil tertentu di sekitar pemain. </font><font style="vertical-align: inherit;">Saya akan segera mengatakan bahwa teknik seperti itu secara signifikan meningkatkan kecepatan frame</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada yang rumit di sini. Bayangan three.js dilemparkan ke dalam kamera bayangan tertentu yang ditentukan oleh kotak (shadowCameraLeft, shadowCameraRight, shadowCameraTop, shadowCameraBottom). Itu dapat diregangkan ke seluruh adegan, atau dapat dibuat sehingga mengikuti kamera utama dan bayangan hanya dilemparkan ke sekitarnya. Satu-satunya hal yang saya tambahkan ke sistem ini adalah langkah melalui mana bayangan akan diperbarui. Sama sekali tidak perlu melakukan pembaruan ini setiap kali pemain berkedut, karena ini memuat sistem dengan perhitungan. Biarkan dia mengatasi jarak minimum tertentu di sepanjang salah satu dari ketiga sumbu sehingga bayangan diperbarui.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di perpustakaan saya, ketika menginisialisasi dunia 3D, objek contr dibuat, yang setiap saat berisi koordinat kamera. Di sana Anda juga dapat mengatur parameter pengguna contr.cameraForShadowStep, yang berisi langkah posisi kamera di mana posisi kamera bayangan berubah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika, misalnya, paralelepiped dari kamera bayangan memiliki dimensi 700x700x700, maka contr.cameraForShadowStep dapat diatur ke, misalnya, 20. Dan ketika pemain bergerak 20 pada salah satu sumbu, posisi awal akan diingat lagi dan bayangan di sekitar pemain akan diperbarui. Skala dunia 3D dapat berupa apa saja, tergantung pada skala di mana semua model dibuat dalam editor 3D. Dan sepertinya bukan 700x700x700 dan 20, Anda harus menggunakan 7000x7000x7000 dan 200. Tetapi ini tidak mengubah esensi dengan cara apa pun.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, ketika matahari bergerak di langit, bayangan diperbarui secara independen dari sistem ini, karena arah bayangan harus berubah di sana. </font><font style="vertical-align: inherit;">Artinya, mereka akan diperbarui bahkan jika pemain berdiri tanpa gerakan. </font><font style="vertical-align: inherit;">Di sana, fungsi memperbarui bayangan sesuai dengan periode memperbarui langit disebut dengan bodoh.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistem Titik Cahaya </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/fa/be/kgfabepvwgn_zxwfctnyh2rce7g.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehadiran lebih dari selusin sumber cahaya di panggung sama kuatnya dengan bayangan dinamis. Dan bahkan membuatnya tidak mungkin untuk memainkan "Rami" yang lama. Selain itu, tidak masalah apakah sumber-sumber ini ada di bidang tampilan pemain (rentang render dunia dapat diatur) atau pada jarak yang cukup jauh. Jika mereka secara bodoh hadir di atas panggung, maka semuanya berjalan lambat. Oleh karena itu, saya telah menyediakan di menu pengaturan permainan, yang dapat dipanggil sebelum memuat dunia 3D, opsi untuk sejumlah sumber tersebut (2, 4 atau 8) yang disebut "Light of Lanterns".</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/-g/sr/mr-gsrw4vfm6qjobtc5a36p432s.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, pada malam hari, menyalakan semua lampu yang ditempatkan di atas panggung pada saat yang sama tidak akan berhasil. Di atas, dalam uraian skema inisialisasi dunia, saya menyajikan array tentang userPointLights dan lightsPDynamicAr. Di userPointLights, koordinat semua lampu lampu di atas panggung diatur dalam sebuah array. Dan lightsPDynamicAr berisi pengaturan cahaya untuk semua 8 instance. Bergantung pada pengaturan jumlah lampu, perpustakaan akan mengambil yang pertama dan menambahkan adegan di bidang tampilan pemain.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan, saat pemain bergerak, pencarian dilakukan untuk 2-8 lentera yang paling dekat dengan pemain dengan susunan koordinat dari lentera userPointLights. </font><font style="vertical-align: inherit;">Dan titik sumber cahaya bergerak di bawahnya. </font><font style="vertical-align: inherit;">Dengan kata lain, 2-8 lampu penerangan mengikuti pemain, mengelilinginya. </font><font style="vertical-align: inherit;">Selain itu, ini juga dilakukan tidak dengan setiap frame fps, tetapi dengan langkah yang diberikan. </font><font style="vertical-align: inherit;">Sama sekali tidak perlu memulai fungsi pencarian 60 kali per detik, terutama jika pemain tidak bergerak - maka biarkan lampu yang ada di sekelilingnya menyala. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begini tampilannya (Xeon E5440, GeForce GT730):</font></font><br><iframe width="560" height="315" src="https://www.youtube.com/embed/IPuJrH8EJ_E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membangun distribusi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena saya tidak menggunakan lingkungan pengembangan yang canggih (kecuali untuk notepad canggih), saya menulis file bat di mana Google Closure Compiler dipanggil untuk mengaburkan kode setiap file * .js. </font><font style="vertical-align: inherit;">Dan kemudian nwjc.exe dari bundel nw.js dipanggil ke sana untuk mengkompilasi js ke dalam binari (* .bin). </font><font style="vertical-align: inherit;">Saya akan memberikan contoh untuk salah satu file:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java -jar D: \ webservers \ Penutupan \ compiler.jar --js D: \ webservers \ proj \ m3d \ www \ game \ bus \ bus.js --js_output_file D: \ webservers \ proj \ nwProjects \ bus \ game \ bus \ bus.js </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cd D: \ "Program Files" \ Web2Exe \ down \ nwjs-sdk-v0.35.5-menang-ia32 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D: \ "Program Files" \ Web2Exe \ down \ nwjs-sdk-v0.35.5-win -ia32 \ nwjc.exe D: \ webservers \ proj \ nwProjects \ bus \ game \ bus \ bus.js D: \ webservers \ proj \ nwProjects \ bus \ game \ bus \ bus \ bus.bin </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del D: \ webservers \ proj \ nwProjects \ bus \ game \ bus \ bus.js</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, saya menggunakan utilitas Web2Executable sederhana untuk membuat file exe dengan perakitan di bawah Windows. Saya memilih nw.js versi 0.35.5, walaupun versi yang lebih baru juga tersedia. Saya tidak melihat adanya efek dari mereka, kecuali untuk meningkatkan ukuran perakitan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/_2/ed/hk_2ed5imb6en8ffx6vtfx_7t-o.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilitas ini mampu mengunduh versi nw.js yang dipilih ke folder yang ditentukan itu sendiri. </font><font style="vertical-align: inherit;">Outputnya adalah perakitan. </font><font style="vertical-align: inherit;">File eksekusi 35 megabyte sebenarnya berisi game itu sendiri. </font><font style="vertical-align: inherit;">Yang lainnya adalah node-webkit. </font><font style="vertical-align: inherit;">Folder locales berisi file, tentu saja, dengan beberapa sumber daya dalam bahasa yang berbeda. </font><font style="vertical-align: inherit;">Saya menghapusnya dan hanya menyisakan yang terkait dengan Bahasa Inggris. </font><font style="vertical-align: inherit;">Ngomong-ngomong, ini tidak mencegah peluncuran versi game berbahasa Rusia (dalam game itu bahasa berganti antara Rusia dan Inggris). </font><font style="vertical-align: inherit;">Mengapa semua file ini, saya tidak tahu. </font><font style="vertical-align: inherit;">Tetapi tanpa bahasa Inggris, tidak ada yang dimulai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seluruh perakitan akhirnya mengambil 167 MB.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jp/ev/qq/jpevqq5deupdq0zkm7naffok4fa.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemudian saya mengemas semuanya menjadi satu file distribusi yang dapat dieksekusi menggunakan salah satu utilitas gratis yang dirancang untuk tujuan ini, dan hasilnya adalah 70,2 MB Businessman3DSetup.exe. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sf/xd/nn/sfxdnnsvu3fpp9ukkzsius2vqsm.jpeg"></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posting </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengirim perakitan ke berbagai toko aplikasi. Sebagian besar dari mereka masih dalam proses memoderasi permainan saya. Saat ini, hanya gatal yang telah menerbitkannya sejauh ini. Saya memperingatkan Anda segera, permainan dibayar, harganya $ 3. Belum ada pembelian, tapi saya belum terlibat dalam promosinya. GOG menolak untuk menerbitkan, mengutip fakta bahwa permainannya cukup sederhana dan niche. Saya, pada prinsipnya, setuju. Epic Store, saya pikir, akan melakukan hal yang sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi permainan yang diterbitkan adalah pengguna tunggal, dengan jumlah bot dari 1 hingga 5. Bahasa - Rusia dan Inggris. Saya bermaksud untuk menyelesaikan versi jaringan. Tetapi masih dalam pemikiran - untuk merilisnya dalam bentuk aplikasi yang sama atau dalam bentuk versi browser web, tersedia segera di Windows, Linux, iOs dan MacOs, dan umumnya di mana pun browser mendukung WebGL. Memang, pada kenyataannya, webkit adalah browser dan permainan berfungsi dengan baik di dalamnya, di Firefox, di Edge dan bahkan di IE11 di bawah Windows, meskipun pada yang terakhir ini sangat lambat.</font></font><br><br><h3>  Kesimpulan </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kw/cf/wm/kwcfwmtwbwugbnnsb3gol4bshkk.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya kira saya belum siap untuk mengeluarkan mesin saya untuk penggunaan umum, karena belum selesai. Saya pertama-tama akan menulis di atasnya game lain, hanya itu, dari video demo, tentang kapal, karena pada game itu Anda dapat "menjalankan" bekerja dengan shader air. Selain itu, saya berencana untuk mengimplementasikan mesin fisika sederhana di sana. Ya, dan Anda masih harus menyelesaikan semua fitur lainnya, perbaiki semua kekurangannya. Dan lebih baik melakukan ini pada dua game daripada pada satu, karena beberapa nuansa mungkin terjadi. Sementara itu, mesin saya, menurut saya, masih terlalu tajam untuk satu game.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, saya sama sekali tidak yakin bahwa ada yang membutuhkan semua ini. </font><font style="vertical-align: inherit;">Jika Anda terlihat serius, tidak ada yang menulis game dalam javascript murni. </font><font style="vertical-align: inherit;">Tapi saya suka karena gimnya cukup mudah dan cepat untuk peramban. </font><font style="vertical-align: inherit;">Mereka memuat dengan cepat, tidak memerlukan banyak RAM dan bekerja cukup cepat dibandingkan dengan pesaing di HTML5, bahkan jika dibandingkan dengan 2D. </font><font style="vertical-align: inherit;">Saya pikir saya akan merilis lebih dari satu permainan browser (dan tidak hanya) pada semua perkembangan ini.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450926/">https://habr.com/ru/post/id450926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450914/index.html">Negosiasi gagal: bagaimana Oracle membunuh Java EE</a></li>
<li><a href="../id450916/index.html">Perbandingan kualitas foto yang diambil pada ponsel dengan konfigurasi sensor yang berbeda</a></li>
<li><a href="../id450918/index.html">Manajemen Pengetahuan TI: Konferensi Pertama dan Gambaran Besar</a></li>
<li><a href="../id450922/index.html">Kantor berjalan</a></li>
<li><a href="../id450924/index.html">Semua Tentang Animasi SVG</a></li>
<li><a href="../id450928/index.html">Bagaimana pusat data menghemat hari libur</a></li>
<li><a href="../id450930/index.html">Bagaimana kami mengembangkan # bigdataX5 dan siapa yang dibutuhkan di Big Data</a></li>
<li><a href="../id450938/index.html">Linux Instal Fest 05.19 di Nizhny Novgorod 18 Mei 2019</a></li>
<li><a href="../id450942/index.html">Sespan untuk pemecahan kode</a></li>
<li><a href="../id450946/index.html">Disk Cell Phone di LPC810</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>