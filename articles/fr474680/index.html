<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üâë üí† üîΩ AI et 2048. Partie 2: √©cr√™tage Minimax + alpha beta ‚ÜîÔ∏è üÜî üë©üèæ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons examin√© la m√©thode de Monte Carlo , nous verrons aujourd'hui comment l'esprit de l'ordinateur joue en 2048 en utilisant le bon vieux minima...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI et 2048. Partie 2: √©cr√™tage Minimax + alpha beta</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474680/"><div style="text-align:center;"><img width="690" height="314" src="https://habrastorage.org/webt/9t/ym/10/9tym105d327kylbfpejz4inkdxu.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous avons examin√© la m√©thode de Monte Carlo</a> , nous verrons aujourd'hui comment l'esprit de l'ordinateur joue en 2048 en utilisant le bon vieux minimax avec √©cr√™tage alpha-b√™ta. <a name="habracut"></a><br><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Logiciel EDISON - d√©veloppement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - d√©veloppement web"></a> <br clear="right">  L'article a √©t√© √©crit avec le soutien d'EDISON, une entreprise qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©veloppe des applications mobiles</a> et fournit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des services de test de logiciels</a> . </blockquote><br>  Solution espionn√©e par le stackoverflow de l'utilisateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="14" height="14" src="https://habrastorage.org/webt/7c/q2/x_/7cq2x_1w7otpr1ksh4yryg83h4c.jpeg"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ovolve</a> , qui a not√© dans la discussion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment enseigner l'IA au jeu 2048</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Traduction des commentaires de ovolve</b> <div class="spoiler_text">  Je suis l'auteur du programme mentionn√© dans ce fil.  Vous pouvez voir l'IA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en action</a> ou voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le code</a> . <br><br>  Actuellement, le programme gagne dans environ 90% des cas en ex√©cutant des scripts java dans un navigateur sur mon ordinateur portable, d√©pensant 100 millisecondes pour r√©fl√©chir au cours, fonctionnant, bien que pas parfaitement, mais assez bien. <br><br>  Comme le jeu est un espace d'√©tat discret avec des informations compl√®tes, √©tant en fait un jeu au tour par tour comme les √©checs et les dames, j'ai utilis√© les m√™mes m√©thodes qui ont montr√© leurs performances dans ces jeux, √† savoir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche minimax</a> avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©cr√™tage alpha-b√™ta</a> .  √âtant donn√© que les liens fournissent de nombreuses informations sur cet algorithme, je vais simplement parler des deux principales heuristiques que j'ai utilis√©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fonction d'estimation statique</a> et formaliser de nombreuses hypoth√®ses intuitives faites par d'autres personnes ici. <br><br><img align="right" width="344" height="343" src="https://habrastorage.org/webt/hm/s0/cu/hms0cuvsvpeyvyvozxm-3f88xui.png"><br clear="left"><h3>  Monotonie </h3><br>  Cette heuristique tente de garantir que toutes les valeurs de tuiles augmentent ou diminuent √† la fois √† gauche / √† droite et en haut / en bas.  Cette heuristique √† elle seule refl√®te la conjecture que beaucoup d'autres ont mentionn√© que des tuiles plus pr√©cieuses devraient √™tre regroup√©es dans un coin.  En r√®gle g√©n√©rale, cela emp√™che l'accumulation de tuiles de moindre valeur et maintient le plateau organis√©, car les petites tuiles se transforment en plus grandes. <br><br>  Voici une capture d'√©cran d'une grille compl√®tement monotone.  J'ai eu cette situation en ex√©cutant un algorithme avec la fonction eval install√©e afin d'ignorer les autres heuristiques et de ne prendre en compte que la monotonie. <br><br><img align="right" width="342" height="343" src="https://habrastorage.org/webt/iq/wp/4p/iqwp4pn8rsoynb1u6eknm99gmt8.png"><br clear="left"><h3>  Douceur (douceur, r√©gularit√©) </h3><br>  L'heuristique ci-dessus en soi a tendance √† cr√©er des structures dans lesquelles les cellules voisines sont r√©duites en valeur, cependant, bien s√ªr, les voisins devraient avoir la m√™me signification √† combiner.  Par cons√©quent, l'heuristique de lissage mesure simplement la diff√©rence de valeurs entre les tuiles adjacentes, en essayant de minimiser leur nombre. <br><br>  Un commentateur de Hacker News a fourni une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">formalisation int√©ressante de</a> cette id√©e en termes de th√©orie des graphes. <br><br><div class="spoiler">  <b class="spoiler_title">Traduction de formalisation avec Hacker News</b> <div class="spoiler_text"><blockquote>  Hier, j'ai montr√© ce jeu √† un coll√®gue, un amoureux de la th√©orie des graphes, et nous avons √©galement d√©cid√© de r√©fl√©chir √† la fa√ßon de r√©soudre ce jeu en utilisant l'IA. <br><br>  La solution la plus simple est minimax, qui, √† mon avis, est assez bien impl√©ment√©e.  Si quelqu'un ici ne conna√Æt pas minimax, OP a √©crit un code tr√®s √©l√©gant et bien comment√© qui serait un excellent tutoriel. <br><br>  L'approche la moins intensive en calcul que nous avons propos√©e √©tait de mod√©liser l'√©tat du jeu sous la forme d'un graphique <b>G (V, E)</b> , o√π <b>V</b> est un ensemble de tuiles actives et <b>E</b> est un ensemble d'ar√™tes reliant des tuiles adjacentes pond√©r√©es par la fonction <b>c (v1, v2)</b> , qui renvoie la valeur absolue de la diff√©rence entre les deux tuiles.  Pour chaque solution, l'IA choisit un coup qui minimise la somme des poids de tous les bords dans le nouvel √©tat de jeu. <br><br>  La raison en est que la seule fa√ßon de progresser dans le jeu est d'avoir des tuiles avec les m√™mes valeurs c√¥te √† c√¥te, pour lesquelles le poids en <b>G</b> sera 0. Ainsi, l'IA devrait essayer de minimiser le poids total.  √Ä la fin, il y aura un grand nombre sur les planches avec un grand poids de bords aux tuiles adjacentes, donc l'IA essaiera de garder ces tuiles √† c√¥t√© d'autres grandes tuiles pour minimiser la diff√©rence. <br><br>  √âtant donn√© que le jeu est stochastique, l'approche que j'ai d√©crite peut ne pas fonctionner dans le pire des cas, mais elle peut √©galement √™tre appliqu√©e √† la solution minimax existante en tant que fonction de pond√©ration pour chaque n≈ìud de l'arbre. </blockquote></div></div><br><br>  Voici une capture d'√©cran d'un maillage parfaitement lisse, gracieusement fourni par cette excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20140315093348/">fausse fourche</a> .  <i>(lien vers l'archive Web, tandis que les scripts Java sur la page fonctionnent et que vous pouvez utiliser le clavier pour vous d√©placer dans n'importe quelle direction - note du traducteur).</i> <br><br><h3>  Tuiles en vrac </h3><br>  Et enfin, il y a une p√©nalit√© pour avoir trop peu de tuiles gratuites, car les options peuvent rapidement se terminer lorsque le terrain de jeu devient trop √©troit. <br><br>  Et c'est tout!  La recherche de l'espace de jeu tout en optimisant ces crit√®res donne des performances √©tonnamment bonnes.  L'un des avantages de l'utilisation d'une approche g√©n√©rique comme celle-ci plut√¥t que d'une strat√©gie de d√©placement explicitement cod√©e est que l'algorithme peut souvent trouver des solutions int√©ressantes et inattendues.  Si vous observez sa progression, il fait souvent des mouvements √©tonnants mais efficaces, comme le changement soudain de murs ou de coins, pr√®s desquels il construit son jeu. <br><br><img align="right" width="345" height="499" src="https://habrastorage.org/webt/tc/oi/hz/tcoihzahmdqlw9cxthywpapiwsa.png"><br clear="left"><h3>  Petit changement </h3><br>  La capture d'√©cran montre la puissance de cette approche.  J'ai supprim√© la limite de tuiles (afin qu'elles continuent de cro√Ætre apr√®s avoir atteint 2048), et voici le meilleur r√©sultat apr√®s huit tests. <br><br>  Oui, c'est 4096 avec 2048. =) Cela signifie qu'il a atteint la tuile 2048 insaisissable sur un plateau. </div></div><br><hr><hr><hr><hr><hr><br>  Le code Java-Script pour minimax avec √©cr√™tage alpha-b√™ta et fonction d'√©valuation statique de l'utilisateur ovover de stackoverflow est donn√© ci-dessous dans l'article. <br><br>  La m√©thode minimax est consacr√©e √† plusieurs excellents articles habr, donc nous omettons l'explication d√©taill√©e acad√©mique de ce qu'elle consiste.  Pour ceux qui ont <strike>rejoint la communaut√© informatique, j'ai r√©cemment</strike> entendu les beaux termes ¬´minimax¬ª et ¬´√©cr√™tage alpha-b√™ta¬ª, mais je ne sais pas ce que cela signifie, essayons, litt√©ralement en quelques paragraphes, d'expliquer la signification la plus g√©n√©rale. <br><br><h2>  Minimax </h2><br>  Dans certains jeux, le processus d'un jeu entre deux joueurs (qui se d√©placent √† leur tour) peut √™tre repr√©sent√© comme un soi-disant arbre d'options.  Dans chaque position sp√©cifique, chaque joueur a g√©n√©ralement le choix entre diff√©rentes options pour son mouvement.  Et en r√©ponse √† chacune de ces options, un adversaire peut aussi ressembler √† bien des √©gards. <br><br><div style="text-align:center;"><img width="690" height="525" src="https://habrastorage.org/webt/xi/ye/j2/xiyej2z5e4n-kigoscjrgfpf2i8.png"></div><br>  <sup><em>Fragment d'un arbre d'options</em></sup> <br><br>  √âtant donn√© qu'√† tout moment du jeu, il existe des informations compl√®tes sur l'√©tat du terrain de jeu, l'√©tat actuel de la position peut toujours √™tre estim√© avec pr√©cision.  Une telle fonction est appel√©e <strong>fonction d'√©valuation statique</strong> ou <strong>SFO</strong> abr√©g√©.  De plus, plus cette fonction est importante lors de l'√©valuation d'une position sp√©cifique, plus la position est avantageuse pour un joueur (appelons-la le <strong>joueur maximisant</strong> ).  Plus la valeur num√©rique de cette fonction est petite lors de l'√©valuation d'une position, plus la position du deuxi√®me joueur est avantageuse (appelons-la le <strong>joueur minimisant</strong> ). <br><br>  Apr√®s chaque mouvement, la position change et donc son score change.  Lors de l'examen de l'arbre des options, chaque joueur doit non seulement pr√©f√©rer les branches dans lesquelles le classement lui est le plus favorable.  Vous devez √©galement √©viter les branches dans lesquelles l'√©valuation de la position est favorable √† l'adversaire. <br><br>  On suppose que l'adversaire est √©galement guid√© par le rationalisme et √©vite √©galement les options qui pourraient le conduire √† perdre.  Autrement dit, chaque joueur, lors du choix d'une option, proc√®de de la maximisation de son propre avantage et en m√™me temps de la minimisation du profit de l'adversaire. <br><br>  C'est minimax. <br><br><h2>  D√©tourage alpha b√™ta </h2><br>  C'est assez √©vident: qui calcule un arbre d'une position donn√©e √† une plus grande profondeur, il a plus de chances de gagner.  Mais il y a une nuisance - l'arbre des options dans les jeux a la mauvaise habitude de se ramifier et de cro√Ætre de fa√ßon exponentielle √† chaque niveau d'imbrication.  Les capacit√©s de comptage des programmes, et d'autant plus que les gens sont limit√©s, compter "jusqu'au tapis" est loin d'√™tre toujours possible.  Il peut facilement s'av√©rer que le joueur a compt√© jusqu'√† une position o√π il a une bonne √©valuation du terrain de jeu, mais litt√©ralement au niveau suivant (illisible), l'adversaire a la possibilit√© de faire un tel mouvement qui change radicalement l'estimation de la position en sens inverse. <br><br>  Qui est √† bl√¢mer et que faire?  La complexit√© de calcul est √† bl√¢mer pour la travers√©e compl√®te de l'arbre; il est propos√© de lutter en coupant les branches inutiles.  Si le joueur qui √©value la position voit qu'une branche de l'arborescence d'options: <br><br>  ou moins rentable pour elle que d'autres branches qui ont d√©j√† √©t√© analys√©es, <br>  ou plus avantageux pour l'adversaire que d'autres branches qui ont d√©j√† √©t√© analys√©es, <br><br>  alors le joueur d√©fausse cette branche, ne perd pas de temps et de ressources √† consid√©rer les sous-options de cette branche √©videmment pire pour lui. <br><br>  Cela vous permet d'allouer plus de ressources informatiques pour calculer des branches plus favorables √† une plus grande profondeur de rendu dans l'arborescence des options.  Dans le processus d'√©valuation du terrain de jeu √† diff√©rents niveaux de l'arborescence des options, le joueur fonctionne avec deux coefficients changeant dynamiquement - <strong>alpha</strong> (la valeur du SFD qui est rencontr√©e de mani√®re minimale dans la branche - c'est-√†-dire plus favorable pour le joueur minimisant) et <strong>beta</strong> (la valeur de la SFD la plus rencontr√©e dans la branche - c'est-√†-dire plus favorable pour le joueur maximisant).  √Ä chaque niveau, la comparaison du SFD de la position actuelle avec <em>les</em> coefficients <em>alpha</em> et <em>b√™ta</em> permet de balayer (sans les calculer compl√®tement) des branches <em>moins favorables</em> pour le joueur √©valuant la position et / ou <em>plus avantageuses</em> pour son adversaire. <br><br>  Il s'agit d'un d√©coupage alpha b√™ta. <br><br><h3>  Fonction minimax r√©cursive avec √©cr√™tage alpha b√™ta </h3><br><div class="spoiler">  <b class="spoiler_title">2048 avec AI est impl√©ment√© en tant qu'application Excel avec des macros VBA, c'est ainsi que l'algorithme minimax avec √©cr√™tage alpha beta ressemble √† un √©l√©mentaire visuel m√©prisable.</b> <div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''( - )''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '       -- 'Position -  4  4     'Depth - ,    'Alpha, Beta -         'MaximisingPlayer -      ? Private Function MiniMaxAlpaBeta_Evaluation(Position As Variant, Depth As Long, _ Alpha As Double, Beta As Double, _ MaximisingPlayer As Boolean, _ Optional MainLevel As Boolean = False) As Double Dim MaxEval As Double '  Dim MinEval As Double '  Dim PositionNext As Variant '     Dim PositionTemp As Variant '     Dim Eval As Double '   Dim Way As Long '   -      Dim Row As Long '     Dim Col As Long '     Dim TileNew As Long '      '   (  ,  '     ) If GameOverPosition(Position) Then '    ? '     MiniMaxAlpaBeta_Evaluation = -1000000 + TileMax(Position) '         ElseIf Depth = 0 Then '     MiniMaxAlpaBeta_Evaluation = StaticEvaluation(Position) '  ,    '     () ElseIf MaximisingPlayer Then MaxEval = -1000000 '      For Way = 1 To 4 ' 4   - (, , , ) ChangeCount = 0 ' ,      ',       PositionNext = StepHuman(Position, Way) If ChangeCount &gt; 0 Then '     '      , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, False) If Eval &gt; MaxEval Then MaxEval = Eval '  '     If Eval &gt; Alpha Then Alpha = Eval '    ,   '   -    If Beta &gt; Alpha Then Exit For End If Next '          MiniMaxAlpaBeta_Evaluation = MaxEval '  ,    '     () Else 'Not MaximisingPlayer MinEval = 1000000 '      For Row = 1 To 4 '     For Col = 1 To 4 '     If Position(Row, Col) = 0 Then '   For TileNew = 2 To 4 Step 2 '    2  4 ',       '    PositionNext = StepComp(Position, Row, Col, TileNew) '     , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, True) If Eval &lt; MinEval Then MinEval = Eval '  '     If Eval &lt; Beta Then Beta = Eval '    ,   '   -    If Alpha &lt; Beta Then Exit For Next End If Next Next '          MiniMaxAlpaBeta_Evaluation = MinEval End If End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ovolve code dans java-script</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grid</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid = grid; } <span class="hljs-comment"><span class="hljs-comment">//   () AI.prototype.eval = function() { var emptyCells = this.grid.availableCells().length; var smoothWeight = 0.1, //monoWeight = 0.0, //islandWeight = 0.0, mono2Weight = 1.0, emptyWeight = 2.7, maxWeight = 1.0; return this.grid.smoothness() * smoothWeight //+ this.grid.monotonicity() * monoWeight //- this.grid.islands() * islandWeight + this.grid.monotonicity2() * mono2Weight + Math.log(emptyCells) * emptyWeight + this.grid.maxValue() * maxWeight; }; // alpha-beta depth first search AI.prototype.search = function(depth, alpha, beta, positions, cutoffs) { var bestScore; var bestMove = -1; var result; // the maxing player if (this.grid.playerTurn) { bestScore = alpha; for (var direction in [0, 1, 2, 3]) { var newGrid = this.grid.clone(); if (newGrid.move(direction).moved) { positions++; if (newGrid.isWin()) { return { move: direction, score: 10000, positions: positions, cutoffs: cutoffs }; } var newAI = new AI(newGrid); if (depth == 0) { result = { move: direction, score: newAI.eval() }; } else { result = newAI.search(depth-1, bestScore, beta, positions, cutoffs); if (result.score &gt; 9900) { // win result.score--; // to slightly penalize higher depth from win } positions = result.positions; cutoffs = result.cutoffs; } if (result.score &gt; bestScore) { bestScore = result.score; bestMove = direction; } if (bestScore &gt; beta) { cutoffs++ return { move: bestMove, score: beta, positions: positions, cutoffs: cutoffs }; } } } } else { // computer's turn, we'll do heavy pruning to keep the branching factor low bestScore = beta; // try a 2 and 4 in each cell and measure how annoying it is // with metrics from eval var candidates = []; var cells = this.grid.availableCells(); var scores = { 2: [], 4: [] }; for (var value in scores) { for (var i in cells) { scores[value].push(null); var cell = cells[i]; var tile = new Tile(cell, parseInt(value, 10)); this.grid.insertTile(tile); scores[value][i] = -this.grid.smoothness() + this.grid.islands(); this.grid.removeTile(cell); } } // now just pick out the most annoying moves var maxScore = Math.max(Math.max.apply(null, scores[2]), Math.max.apply(null, scores[4])); for (var value in scores) { // 2 and 4 for (var i=0; i&lt;scores[value].length; i++) { if (scores[value][i] == maxScore) { candidates.push( { position: cells[i], value: parseInt(value, 10) } ); } } } // search on each candidate for (var i=0; i&lt;candidates.length; i++) { var position = candidates[i].position; var value = candidates[i].value; var newGrid = this.grid.clone(); var tile = new Tile(position, value); newGrid.insertTile(tile); newGrid.playerTurn = true; positions++; newAI = new AI(newGrid); result = newAI.search(depth, alpha, bestScore, positions, cutoffs); positions = result.positions; cutoffs = result.cutoffs; if (result.score &lt; bestScore) { bestScore = result.score; } if (bestScore &lt; alpha) { cutoffs++; return { move: null, score: alpha, positions: positions, cutoffs: cutoffs }; } } } return { move: bestMove, score: bestScore, positions: positions, cutoffs: cutoffs }; } // performs a search and returns the best move AI.prototype.getBest = function() { return this.iterativeDeep(); } // performs iterative deepening over the alpha-beta search AI.prototype.iterativeDeep = function() { var start = (new Date()).getTime(); var depth = 0; var best; do { var newBest = this.search(depth, -10000, 10000, 0 ,0); if (newBest.move == -1) { break; } else { best = newBest; } depth++; } while ( (new Date()).getTime() - start &lt; minSearchTime); return best } AI.prototype.translate = function(move) { return { 0: 'up', 1: 'right', 2: 'down', 3: 'left' }[move]; }</span></span></code> </pre> </div></div><br><h2>  Fonction d'√©valuation statique </h2><br>  √âtant donn√© qu'√† chaque niveau de l'arborescence des options, vous devez √©valuer le terrain de jeu (afin de d√©cider pour lequel des joueurs, la position estim√©e est en fait plus avantageuse), vous devez d√©cider selon quels crit√®res pour distinguer une bonne position d'une mauvaise position. <br><br>  Nous supposons que le joueur maximisant est la personne (ou l'IA) qui d√©cide dans laquelle des 4 directions (haut, gauche, droite, bas) d√©placer toutes les tuiles.  Un joueur minimisant est ce sous-programme insidieux qui g√©n√®re au hasard 2 ou 4 dans les endroits les plus inappropri√©s. <br><br>  L'OFS est compil√© du point de vue d'un acteur maximisant.  Plus la note SFD est √©lev√©e pour le terrain de jeu, meilleure est la position du ¬´maximaliste¬ª.  Le plus bas - plus la position sur la planche est agr√©able pour le "minimaliste". <br><br>  Dans le cas de 2048 - quels facteurs sont consid√©r√©s comme favorables √† celui qui d√©place les tuiles? <br><br><h3>  Monotonie </h3><img align="right" width="388" height="189" src="https://habrastorage.org/webt/r8/jc/qt/r8jcqtbvrsyvrfwwsmeedgfrzrg.png"><br clear="left">  Tout d'abord, il est souhaitable que les carreaux soient dispos√©s dans l'ordre croissant / d√©croissant dans certaines directions.  Si cela n'est pas fait, lorsque de nouvelles tuiles sont g√©n√©r√©es, le terrain de jeu sera rapidement obstru√© par des tuiles dispos√©es au hasard de diff√©rentes tailles, qui ne peuvent pas √™tre imm√©diatement connect√©es normalement les unes aux autres. <br><br>  Dans le district f√©d√©ral de Sib√©rie, vous devez regarder dans les 4 directions (de haut en bas, de gauche √† droite, de droite √† gauche, de bas en haut) et calculer o√π les tuiles sont une progression d√©croissante ou croissante.  Si en progression il y a des tuiles qui ne rentrent pas dans la s√©rie g√©n√©rale, cela r√©duit le coefficient num√©rique de monotonie.  Ensuite, parmi les 4 coefficients pour toutes les directions, le meilleur est s√©lectionn√©, qui est pris en compte dans la valeur totale du district f√©d√©ral sib√©rien. <br><br><h3>  Douceur </h3><img align="right" width="387" height="189" src="https://habrastorage.org/webt/uw/mq/wh/uwmqwht6dm82fc_zptwwdqdar2c.png"><br clear="left">  De plus, il serait plus pr√©f√©rable que la progression de la position debout dans une rang√©e de tuiles ne soit pas seulement croissante, mais non d√©croissante (ou au lieu de diminuer la ligne, il est pr√©f√©rable de ne pas augmenter), c'est-√†-dire que c'est bien lorsque les m√™mes tuiles sont √† proximit√©, ce qui leur permet de s'effondrer en une seule, de gagner des points et augmenter l'espace libre sur le terrain de jeu. <br><br>  Par cons√©quent, le district f√©d√©ral de Sib√©rie recherche les m√™mes tuiles adjacentes sur le terrain de jeu et prend en compte le nombre de ces paires dans un coefficient sp√©cial. <br><br><h3>  Cellules vides </h3><img align="right" width="387" height="193" src="https://habrastorage.org/webt/qj/as/ay/qjasayisfgowdqcciifm0igt3ru.png"><br clear="left">  √âvidemment, plus il y a d'espace libre, plus il y a de marge de man≈ìuvre et moins il y a de chances de perdre rapidement. <br><br>  SFO consid√®re les cellules vides sur le terrain et plus celles-ci, la position est consid√©r√©e comme plus rentable pour le joueur maximisant. <br><br><h3>  Tuile maximum </h3><br>  √âtant donn√© que la principale chose dans ce jeu est d'obtenir une grande tuile sur le terrain, plus c'est mieux - 2048, 4096, 8192 (ou tout ce pour quoi vous avez la force et la patience), les options o√π la valeur maximale de la tuile est la plus √©lev√©e doivent √™tre consid√©r√©es comme le SFD le plus rentable. <br><br><h3>  District f√©d√©ral sib√©rien pour 2048 </h3><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation du District f√©d√©ral sib√©rien en tant que macro VBA</b> <div class="spoiler_text"><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''  '''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '     'Position -  4  4     Private Function StaticEvaluation(Position As Variant) As Double Dim Smoothness As Double ' Dim Monotonicity As Double ' Dim EmptyCount As Double '  Dim MaxValue As Long '  '   Const SmoothWeight = 0.1 Const MonoWeight = 1 Const EmptyWeight = 2.7 Const MaxWeight = 1 Dim k As Long '   Dim i As Long '  Dim j As Long '  Dim x As Long '  Dim y As Long '  ' Dim Value As Double '       '         Dim TargetValue As Double Smoothness = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) &gt; 0 Then '   Value = Log(Position(i, j)) / Log(2) If i &lt; 4 Then '       For x = i + 1 To 4 '    If Position(x, j) &gt; 0 Then '    '    TargetValue = Log(Position(x, j)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '       Exit For End If Next End If If j &lt; 4 Then '       For y = j + 1 To 4 '    If Position(i, y) &gt; 0 Then '    '    TargetValue = Log(Position(i, y)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '        Exit For End If Next End If End If Next Next ' Dim arrTotals(1 To 4) As Double '     Dim Current As Long '   Dim Next_ As Long '      Dim CurrentValue As Double '      Dim NextValue As Double '        Monotonicity = 0 '    '      For k = 1 To 4 arrTotals(k) = 0 Next ' -  - For x = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(x, Next_) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(x, Current) &gt; 0 Then CurrentValue = Log(Position(x, Current)) / Log(2) Else CurrentValue = 0 End If ' MsgBox "Position[" &amp; x &amp; ", " &amp; Next_ &amp; "]=" &amp; Position(x, Next_) If Position(x, Next_) &gt; 0 Then NextValue = Log(Position(x, Next_)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Up) = arrTotals(Up) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Down) = arrTotals(Down) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Up) &gt;= arrTotals(Down), _ Monotonicity + arrTotals(Up), _ Monotonicity + arrTotals(Down)) ' -  - For y = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(Next_, y) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(Current, y) &gt; 0 Then CurrentValue = Log(Position(Current, y)) / Log(2) Else CurrentValue = 0 End If If Position(Next_, y) &gt; 0 Then NextValue = Log(Position(Next_, y)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Left) = arrTotals(Left) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Right) = arrTotals(Right) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Left) &gt;= arrTotals(Right), _ Monotonicity + arrTotals(Left), _ Monotonicity + arrTotals(Right)) '     EmptyCount = 0 '      MaxValue = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) = 0 Then '  ... '...     EmptyCount = EmptyCount + 1 '     ... ElseIf Position(i, j) &gt; MaxValue Then MaxValue = Position(i, j) '...    End If Next Next '   StaticEvaluation = Smoothness * SmoothWeight + _ Monotonicity * MonoWeight + _ Log_Base_Arg(EmptyCount) * EmptyWeight + _ MaxValue * MaxWeight End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ovolve code dans java-script</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTiles = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.build(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerTurn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// pre-allocate these objects (for speed) Grid.prototype.indexes = []; for (var x=0; x&lt;4; x++) { Grid.prototype.indexes.push([]); for (var y=0; y&lt;4; y++) { Grid.prototype.indexes[x].push( {x:x, y:y} ); } } // Build a grid of the specified size Grid.prototype.build = function () { for (var x = 0; x &lt; this.size; x++) { var row = this.cells[x] = []; for (var y = 0; y &lt; this.size; y++) { row.push(null); } } }; // Find the first available random position Grid.prototype.randomAvailableCell = function () { var cells = this.availableCells(); if (cells.length) { return cells[Math.floor(Math.random() * cells.length)]; } }; Grid.prototype.availableCells = function () { var cells = []; var self = this; this.eachCell(function (x, y, tile) { if (!tile) { //cells.push(self.indexes[x][y]); cells.push( {x:x, y:y} ); } }); return cells; }; // Call callback for every cell Grid.prototype.eachCell = function (callback) { for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { callback(x, y, this.cells[x][y]); } } }; // Check if there are any cells available Grid.prototype.cellsAvailable = function () { return !!this.availableCells().length; }; // Check if the specified cell is taken Grid.prototype.cellAvailable = function (cell) { return !this.cellOccupied(cell); }; Grid.prototype.cellOccupied = function (cell) { return !!this.cellContent(cell); }; Grid.prototype.cellContent = function (cell) { if (this.withinBounds(cell)) { return this.cells[cell.x][cell.y]; } else { return null; } }; // Inserts a tile at its position Grid.prototype.insertTile = function (tile) { this.cells[tile.x][tile.y] = tile; }; Grid.prototype.removeTile = function (tile) { this.cells[tile.x][tile.y] = null; }; Grid.prototype.withinBounds = function (position) { return position.x &gt;= 0 &amp;&amp; position.x &lt; this.size &amp;&amp; position.y &gt;= 0 &amp;&amp; position.y &lt; this.size; }; Grid.prototype.clone = function() { newGrid = new Grid(this.size); newGrid.playerTurn = this.playerTurn; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { if (this.cells[x][y]) { newGrid.insertTile(this.cells[x][y].clone()); } } } return newGrid; }; // Set up the initial tiles to start the game with Grid.prototype.addStartTiles = function () { for (var i=0; i&lt;this.startTiles; i++) { this.addRandomTile(); } }; // Adds a tile in a random position Grid.prototype.addRandomTile = function () { if (this.cellsAvailable()) { var value = Math.random() &lt; 0.9 ? 2 : 4; //var value = Math.random() &lt; 0.9 ? 256 : 512; var tile = new Tile(this.randomAvailableCell(), value); this.insertTile(tile); } }; // Save all tile positions and remove merger info Grid.prototype.prepareTiles = function () { this.eachCell(function (x, y, tile) { if (tile) { tile.mergedFrom = null; tile.savePosition(); } }); }; // Move a tile and its representation Grid.prototype.moveTile = function (tile, cell) { this.cells[tile.x][tile.y] = null; this.cells[cell.x][cell.y] = tile; tile.updatePosition(cell); }; Grid.prototype.vectors = { 0: { x: 0, y: -1 }, // up 1: { x: 1, y: 0 }, // right 2: { x: 0, y: 1 }, // down 3: { x: -1, y: 0 } // left } // Get the vector representing the chosen direction Grid.prototype.getVector = function (direction) { // Vectors representing tile movement return this.vectors[direction]; }; // Move tiles on the grid in the specified direction // returns true if move was successful Grid.prototype.move = function (direction) { // 0: up, 1: right, 2:down, 3: left var self = this; var cell, tile; var vector = this.getVector(direction); var traversals = this.buildTraversals(vector); var moved = false; var score = 0; var won = false; // Save the current tile positions and remove merger information this.prepareTiles(); // Traverse the grid in the right direction and move tiles traversals.x.forEach(function (x) { traversals.y.forEach(function (y) { cell = self.indexes[x][y]; tile = self.cellContent(cell); if (tile) { //if (debug) { //console.log('tile @', x, y); //} var positions = self.findFarthestPosition(cell, vector); var next = self.cellContent(positions.next); // Only one merger per row traversal? if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.mergedFrom) { var merged = new Tile(positions.next, tile.value * 2); merged.mergedFrom = [tile, next]; self.insertTile(merged); self.removeTile(tile); // Converge the two tiles' positions tile.updatePosition(positions.next); // Update the score score += merged.value; // The mighty 2048 tile if (merged.value === 2048) { won = true; } } else { //if (debug) { //console.log(cell); //console.log(tile); //} self.moveTile(tile, positions.farthest); } if (!self.positionsEqual(cell, tile)) { self.playerTurn = false; //console.log('setting player turn to ', self.playerTurn); moved = true; // The tile moved from its original cell! } } }); }); //console.log('returning, playerturn is', self.playerTurn); //if (!moved) { //console.log('cell', cell); //console.log('tile', tile); //console.log('direction', direction); //console.log(this.toString()); //} return {moved: moved, score: score, won: won}; }; Grid.prototype.computerMove = function() { this.addRandomTile(); this.playerTurn = true; } // Build a list of positions to traverse in the right order Grid.prototype.buildTraversals = function (vector) { var traversals = { x: [], y: [] }; for (var pos = 0; pos &lt; this.size; pos++) { traversals.x.push(pos); traversals.y.push(pos); } // Always traverse from the farthest cell in the chosen direction if (vector.x === 1) traversals.x = traversals.x.reverse(); if (vector.y === 1) traversals.y = traversals.y.reverse(); return traversals; }; Grid.prototype.findFarthestPosition = function (cell, vector) { var previous; // Progress towards the vector direction until an obstacle is found do { previous = cell; cell = { x: previous.x + vector.x, y: previous.y + vector.y }; } while (this.withinBounds(cell) &amp;&amp; this.cellAvailable(cell)); return { farthest: previous, next: cell // Used to check if a merge is required }; }; Grid.prototype.movesAvailable = function () { return this.cellsAvailable() || this.tileMatchesAvailable(); }; // Check for available matches between tiles (more expensive check) // returns the number of matches Grid.prototype.tileMatchesAvailable = function () { var self = this; //var matches = 0; var tile; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { tile = this.cellContent({ x: x, y: y }); if (tile) { for (var direction = 0; direction &lt; 4; direction++) { var vector = self.getVector(direction); var cell = { x: x + vector.x, y: y + vector.y }; var other = self.cellContent(cell); if (other &amp;&amp; other.value === tile.value) { return true; //matches++; // These two tiles can be merged } } } } } //console.log(matches); return false; //matches; }; Grid.prototype.positionsEqual = function (first, second) { return first.x === second.x &amp;&amp; first.y === second.y; }; Grid.prototype.toString = function() { string = ''; for (var i=0; i&lt;4; i++) { for (var j=0; j&lt;4; j++) { if (this.cells[j][i]) { string += this.cells[j][i].value + ' '; } else { string += '_ '; } } string += '\n'; } return string; } // counts the number of isolated groups. Grid.prototype.islands = function() { var self = this; var mark = function(x, y, value) { if (x &gt;= 0 &amp;&amp; x &lt;= 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 3 &amp;&amp; self.cells[x][y] &amp;&amp; self.cells[x][y].value == value &amp;&amp; !self.cells[x][y].marked ) { self.cells[x][y].marked = true; for (direction in [0,1,2,3]) { var vector = self.getVector(direction); mark(x + vector.x, y + vector.y, value); } } } var islands = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y]) { this.cells[x][y].marked = false } } } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y] &amp;&amp; !this.cells[x][y].marked) { islands++; mark(x, y , this.cells[x][y].value); } } } return islands; } // measures how smooth the grid is (as if the values of the pieces // were interpreted as elevations). Sums of the pairwise difference // between neighboring tiles (in log space, so it represents the // number of merges that need to happen before they can merge). // Note that the pieces can be distant Grid.prototype.smoothness = function() { var smoothness = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if ( this.cellOccupied( this.indexes[x][y] )) { var value = Math.log(this.cellContent( this.indexes[x][y] ).value) / Math.log(2); for (var direction=1; direction&lt;=2; direction++) { var vector = this.getVector(direction); var targetCell = this.findFarthestPosition(this.indexes[x][y], vector).next; if (this.cellOccupied(targetCell)) { var target = this.cellContent(targetCell); var targetValue = Math.log(target.value) / Math.log(2); smoothness -= Math.abs(value - targetValue); } } } } } return smoothness; } Grid.prototype.monotonicity = function() { var self = this; var marked = []; var queued = []; var highestValue = 0; var highestCell = {x:0, y:0}; for (var x=0; x&lt;4; x++) { marked.push([]); queued.push([]); for (var y=0; y&lt;4; y++) { marked[x].push(false); queued[x].push(false); if (this.cells[x][y] &amp;&amp; this.cells[x][y].value &gt; highestValue) { highestValue = this.cells[x][y].value; highestCell.x = x; highestCell.y = y; } } } increases = 0; cellQueue = [highestCell]; queued[highestCell.x][highestCell.y] = true; markList = [highestCell]; markAfter = 1; // only mark after all queued moves are done, as if searching in parallel var markAndScore = function(cell) { markList.push(cell); var value; if (self.cellOccupied(cell)) { value = Math.log(self.cellContent(cell).value) / Math.log(2); } else { value = 0; } for (direction in [0,1,2,3]) { var vector = self.getVector(direction); var target = { x: cell.x + vector.x, y: cell.y+vector.y } if (self.withinBounds(target) &amp;&amp; !marked[target.x][target.y]) { if ( self.cellOccupied(target) ) { targetValue = Math.log(self.cellContent(target).value ) / Math.log(2); if ( targetValue &gt; value ) { //console.log(cell, value, target, targetValue); increases += targetValue - value; } } if (!queued[target.x][target.y]) { cellQueue.push(target); queued[target.x][target.y] = true; } } } if (markAfter == 0) { while (markList.length &gt; 0) { var cel = markList.pop(); marked[cel.x][cel.y] = true; } markAfter = cellQueue.length; } } while (cellQueue.length &gt; 0) { markAfter--; markAndScore(cellQueue.shift()) } return -increases; } // measures how monotonic the grid is. This means the values of the tiles are strictly increasing // or decreasing in both the left/right and up/down directions Grid.prototype.monotonicity2 = function() { // scores for all four directions var totals = [0, 0, 0, 0]; // up/down direction for (var x=0; x&lt;4; x++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[x][next] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:x, y:current}) ? Math.log(this.cellContent( this.indexes[x][current] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:x, y:next}) ? Math.log(this.cellContent( this.indexes[x][next] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[0] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[1] += currentValue - nextValue; } current = next; next++; } } // left/right direction for (var y=0; y&lt;4; y++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[next][y] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:current, y:y}) ? Math.log(this.cellContent( this.indexes[current][y] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:next, y:y}) ? Math.log(this.cellContent( this.indexes[next][y] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[2] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[3] += currentValue - nextValue; } current = next; next++; } } return Math.max(totals[0], totals[1]) + Math.max(totals[2], totals[3]); } Grid.prototype.maxValue = function() { var max = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { var value = this.cellContent(this.indexes[x][y]).value; if (value &gt; max) { max = value; } } } } return Math.log(max) / Math.log(2); } // WIP. trying to favor top-heavy distributions (force consolidation of higher value tiles) /* Grid.prototype.valueSum = function() { var valueCount = []; for (var i=0; i&lt;11; i++) { valueCount.push(0); } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { valueCount[Math.log(this.cellContent(this.indexes[x][y]).value) / Math.log(2)]++; } } } var sum = 0; for (var i=1; i&lt;11; i++) { sum += valueCount[i] * Math.pow(2, i) + i; } return sum; } */ // check for win Grid.prototype.isWin = function() { var self = this; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (self.cellOccupied(this.indexes[x][y])) { if (self.cellContent(this.indexes[x][y]).value == 2048) { return true; } } } } return false; } //Grid.prototype.zobristTable = {} //for //Grid.prototype.hash = function() { //}</span></span></code> </pre> </div></div><br><h2>  2048.xlsm </h2><br>  L'application Excel elle-m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut √™tre t√©l√©charg√©e depuis Google</a> . <br><br>  La fonctionnalit√© de l'application est d√©crite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article pr√©c√©dent, o√π l'IA joue en utilisant la m√©thode Monte Carlo</a> .  La solution d'aujourd'hui a √©t√© ajout√©e au Monte Carlo existant. <br><br><h3>  Tous les articles des s√©ries AI et 2048 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monte Carlo</a> </li><li>  <strong>√âcr√™tage Minimax + alpha beta</strong> </li><li>  En attente du maximum </li><li>  R√©seau de neurones </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474680/">https://habr.com/ru/post/fr474680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474668/index.html">Actions GitHub en tant que CI / CD pour un site sur un g√©n√©rateur statique et des pages GitHub</a></li>
<li><a href="../fr474672/index.html">React, JSX, importation de modules ES (y compris dynamiques) dans un navigateur sans Webpack</a></li>
<li><a href="../fr474674/index.html">Vision industrielle et m√©decine</a></li>
<li><a href="../fr474676/index.html">L'algorithme d'interaction de centaines de milliers de particules uniques sur le GPU, dans GLES3 et WebGL2</a></li>
<li><a href="../fr474678/index.html">Khronos Group a cr√©√© un r√©f√©rentiel unifi√© avec des exemples Vulkan</a></li>
<li><a href="../fr474686/index.html">Histoire fantastique "Salut" (10 min.)</a></li>
<li><a href="../fr474690/index.html">Cr√©ation d'une console √† hauteur variable pour un travail plus pratique sur un ordinateur</a></li>
<li><a href="../fr474692/index.html">Revue Skaffold pour le d√©veloppement de Kubernetes</a></li>
<li><a href="../fr474694/index.html">Comment nous avons s√©lectionn√© et modifi√© le cadre pour les tests de performances</a></li>
<li><a href="../fr474696/index.html">Billet de p√©trole ou billet Rosneft pour Seismic Challenge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>