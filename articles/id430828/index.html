<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏽 🎙️ 👾 Pengalaman dalam menggunakan layar LCD berdasarkan produk MELT 👪 🚛 👩‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini dikhususkan untuk petualangan petualangan menarik yang harus saya lalui dalam proses membuat sensor eksternal yang diperbarui untuk stasiu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman dalam menggunakan layar LCD berdasarkan produk MELT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430828/"> Artikel ini dikhususkan untuk petualangan petualangan menarik yang harus saya lalui dalam proses membuat sensor eksternal yang diperbarui untuk stasiun cuaca yang dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini dalam artikel ini</a> satu setengah tahun yang lalu.  Menurut pengalaman operasi dari versi sebelumnya, saya benar-benar ingin membuat sensor dengan tampilan kontrol sehingga akan mungkin untuk secara berkala memeriksa (dan memverifikasi) komponen stasiun yang paling berubah-ubah - sensor kecepatan angin.  Petualangan dimulai ketika saya mulai memilih tampilan untuk tujuan ini dan, untuk sejumlah alasan, tentang yang lebih lanjut, saya memilih produk MELT asli saya.  Tetapi sebelum saya menjelaskan <s>teknik</s> cara-cara <s>seks non-tradisional</s> untuk mengatasi produk-produk dari perusahaan ini yang saya pilih, ada baiknya untuk membahas secara singkat alasan utama semua modernisasi muluk yang saya mulai. <br><a name="habracut"></a><br>  Dalam komentar pada artikel itu, saya benar menunjukkan tentang desain sensor bahwa sumbu perangkat seperti itu harus memiliki ujung yang solid dan bertumpu pada alas yang sama-sama solid (ingat jam tangan “pada banyak batu”).  Tentu saja, saya tahu ini, tapi kemudian saya tidak bisa memikirkan cara untuk memberikan sumbu cahaya dengan titik tajam kekerasan yang cukup, jadi, sebaliknya, saya mengambil jalan meminimalkan gesekan dengan merendam ujung kuningan (untuk baling-baling cuaca) atau dural (untuk sensor kecepatan) di PTFE yang lembut (lihat . Pengrajin dalam artikel yang ditentukan).  Dalam pemahaman penuh, bahwa keputusan ini bersifat sementara dan berumur pendek dan dalam waktu dekat akan diperlukan untuk menghasilkan sesuatu yang lebih substantif. <br><br>  Hasil dari dua musim operasi terakhir menunjukkan bahwa solusi semacam itu sangat cocok untuk baling-baling cuaca, yang, tentu saja, menggergaji dasar fluoroplastik ke logam dengan sumbu kuningan, tetapi itu tidak menyakitinya sama sekali - gesekan minimal tidak diperlukan di sana, bahkan sebagian sebaliknya.  Itu lebih buruk dengan sensor kecepatan, di mana tidak hanya fluoroplastic digergaji di pangkalan, tetapi juga ujung itu sendiri dari duralumin lunak terhapus panjangnya dua milimeter.  Sebagai hasilnya, pertama-tama, ambang untuk memulai tidak dapat diterima meningkat dan sensor harus dimodernisasi.  Anemometer itu sendiri juga mengalami modernisasi, karena laser compact disc atas dasar yang dibuat bertingkat dari matahari dan memperoleh penampilan yang tidak rapi (saya juga tidak tahu sebelumnya bahwa compact disc terdiri dari dua lapisan). <br><br>  Saya berharap untuk memberi tahu Anda lebih banyak tentang sensor baru nanti, setelah itu setidaknya sedikit beroperasi dan Anda dapat memastikan bahwa Anda tidak perlu mengubah apa pun sekaligus (yaitu, tidak lebih awal dari awal musim panas).  Dan sekarang hanya beberapa detail tentang perubahan pada rangkaian pengukuran, karena mereka terkait dengan topik utama artikel ini. <br><br><h2>  Tentang rangkaian pengukuran sensor </h2><br>  Sehubungan dengan penurunan ambang awal, muncul pertanyaan tentang waktu yang diperlukan untuk mengukur frekuensi rendah yang berasal dari sensor kecepatan (untuk detail, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi ini</a> tentang metode untuk mengukur frekuensi rendah).  Agar tidak membatasi ambang memulai artifisial, dalam hal ini kita harus mengukur frekuensi mulai dari 1-2 hertz: mengingat sensor memiliki 16 lubang dalam lingkaran (lihat foto sensor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada artikel asli</a> ), ini sesuai dengan kira-kira satu revolusi dalam 8-16 detik, yang jelas lebih rendah dari ambang batas untuk memulai.  Artinya, batas waktu untuk menunggu kedatangan pulsa frekuensi berikutnya harus setidaknya 1 detik (lihat artikel yang ditunjukkan pada metode pengukuran), yang membuat masuk akal dari kisah hemat energi: untuk mendapatkan waktu pembaruan yang dapat diterima dan pada saat yang sama mengelola untuk meratakan data untuk menghindari obrolan di layar, kita harus bangun controller setiap dua detik.  Dan jika setengah dari mereka akan meluangkan waktu untuk menunggu pulsa, maka tidak akan ada penghematan energi - dengan mempertimbangkan fakta bahwa LED yang memancarkan sensor telah bekerja selama ini, menghabiskan sekitar 20 mA. <br><br><div class="spoiler">  <b class="spoiler_title">Beberapa detail dalam tanda kurung</b> <div class="spoiler_text">  Saya perhatikan dalam tanda kurung bahwa sehubungan dengan masalah ini, saya langsung ingat meter saat ini yang dirancang di biro desain kami di awal tahun delapan puluhan, bahkan sebelum munculnya semua jenis pengendali.  Rata-rata vektor sejati diterapkan di dalamnya: yaitu, rekaman semua bacaan dihitung oleh sinyal dari meja putar sensor kecepatan itu sendiri - sebuah analog perkiraan dari bangun interupsi eksternal.  Dengan kata lain, jika tidak ada arus, maka tidak ada rekaman yang dibuat, dan sirkuit tidak mengkonsumsi apa pun - hanya jam waktu nyata yang bekerja.  Ambang untuk memulai meja putar itu, dibuat dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">impeller</a> dengan daya apung nol, adalah, sejujurnya, 2-3 cm / detik, dan meter menunjukkan arah dengan memutar seluruh tubuh.  Jadi ada di dalam air, yang 700 kali lebih padat dari udara!  Selama waktu rata-rata, yang berjumlah berjam-jam, roda gila akan terbalik setidaknya sekali, karena hampir tidak ada pengukuran kosong di sana.  Dan untuk stasiun cuaca, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti yang telah disebutkan</a> , metode rata-rata yang benar secara matematis tidak cocok, karena dengan tidak adanya angin seharusnya menunjukkan sesuatu yang nyata.  Oleh karena itu, di sini kita tidak dapat melakukan tanpa batas waktu artifisial terbatas untuk menunggu pulsa dari sensor. <br></div></div><br>  Dimungkinkan untuk melengkapi kontrol yang kompleks dari kebangkitan pengontrol dari dua sumber: biasanya dari gangguan eksternal dari sensor kecepatan (yaitu, sambil menunggu pulsa dari sensor, pengontrol juga masuk ke mode hemat daya), dan jika tidak ada angin, ia dipaksa dari Watchdog.  Ini akan masuk akal hanya ketika mengubah prinsip membaca sensor kecepatan dari optik ke sirkuit yang lebih hemat energi (yang masih perlu dicari - sensor Hall, misalnya, mengkonsumsi 5-10 mA, yang secara fundamental kurang dari desain optik).  Tapi semuanya disederhanakan karena fakta bahwa sensor saya sekarang didukung oleh baterai surya, yang memungkinkan saya untuk hanya meninggalkan mode hemat daya. <br><br>  Untuk pembacaan jam, saya tidak repot-repot dengan timer atau menghitung Arduino millis (), tetapi cukup mengatur generator frekuensi eksternal primitif dengan periode sekitar 1,5 detik pada timer 555: <br><br><img src="https://habrastorage.org/webt/hn/o0/ig/hno0igehcu7spf5ge0q4fx9jynu.png" width="400"><br>  Seperti yang kita ingat, rangkaian sensor menggunakan Atmega328 controller "telanjang" dalam paket DIP, diprogram melalui Uno dan dipasang pada soket, Arduino sendiri digunakan hanya untuk prototyping.  Output generator dihubungkan ke pin interupsi INT0, pin 4 dari rangkaian mikro (pin D2 dari papan Uno).  Interupsi perbedaan positif (RISING) menetapkan bendera tertentu, yang menurutnya bacaan berikutnya diambil dalam siklus utama.  Frekuensi dari sensor juga diukur dengan metode interupsi (output sensor terhubung ke input interupsi INT1, pin 4 (D3), lihat metode terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel yang sama</a> ), karena total waktu tunggu maksimum adalah dua kali periode frekuensi yang diukur.  Dengan batas waktu 1 detik, maka, frekuensi minimum yang diukur adalah 2 Hz (satu putaran anemometer dalam 8 detik).  Dalam setiap siklus keempat, rata-rata terjadi dan data yang sudah selesai dikirim ke modul utama, yaitu, bacaan diperbarui kira-kira setiap 6 detik. <br><br>  Keseluruhan cerita dengan sensor yang diperbarui harus dikalibrasi dan diperiksa secara berkala untuk melihat apakah gesekan telah meningkat, membandingkan bacaan dengan anemometer manual.  Oleh karena itu, sangat merepotkan ketika bacaan ditampilkan di satu tempat (di rumah), dan sensor eksternal dipasang di tempat yang sama sekali berbeda - di gazebo taman.  Muncul pertanyaan tentang memasang LCD kontrol di rumah sensor.  Karena keindahan tidak diperlukan di sini, persyaratan informasi untuknya minimal: tampilan 10 karakter satu baris sudah cukup.  Tetapi persyaratan geometriknya cukup ketat: layar harus pas dengan lebar case yang ada, yaitu 70 mm.  Saya harus mengatakan bahwa karena ketidaksukaan organik saya terhadap tampilan LCD (redup, kontras rendah, dengan huruf kecil, kualitas cahaya latar yang menjijikkan, dan juga banyak mengonsumsi, lebih banyak tentang itu nanti), saya hampir tidak mengetahui kisaran yang tersedia di ritel.  Dan dengan segera menjadi jelas bahwa tampilan yang saya butuhkan harus sangat dicari untuk dijual: layar LCD 16x2 standar, yang dominan di toko-toko, memiliki panjang papan 80 mm dan tidak dapat masuk ke sensor saya, dan semua jenis lainnya bahkan lebih besar ukurannya, terlepas dari dari perusahaan.  Di alam, tentu saja, ada varietas yang lebih kecil, tetapi kemudian di alam, dan bukan di ritel domestik. <br><br><h2>  Solusi: oh MELT! </h2><br>  Pada akhirnya, saya menemukan dua MELT sekaligus yang sangat sesuai dengan tugas saya.  Yang pertama adalah 10-karakter MT-10S1 single-line dengan controller, yang, menurut produsen, " <i>mirip dengan HD44780 dari HITACHI dan KS0066 dari SAMSUNG</i> ."  Ini memiliki karakter yang agak besar: tingginya lebih dari 8 mm, yang sebenarnya merupakan ciri khas pajangan Tiongkok dengan ukuran yang jauh lebih besar.  Lebar papan adalah 66 mm, dimensi layar yang menonjol (eksternal) adalah 62x19,5.  Konsumsi dalam hal ini tidak terlalu mengganggu saya (karena sensor eksternal ditenagai oleh baterai tenaga surya jelas lebih besar dari yang diperlukan), tetapi karena kebiasaan, melihat garis dalam lembar data, saya menemukan bahwa itu juga lebih kecil dari biasanya - 0,7 mA (semua LCD biasa ditampilkan pada analog HD44780 mengkonsumsi dari 1,2 mA dan lebih tinggi).  Masih ada lampu latar ke tumpukan, seperti biasa untuk semua jenis ini - agak miskin dan pada saat yang sama menghabiskan banyak energi. <br><br><img src="https://habrastorage.org/webt/6h/j2/wp/6hj2wpcmpeo_32v2pui7fxdbqwm.png" width="400"><br><br>  Tampilan kedua MT-10T7 bahkan lebih menakjubkan: tepatnya dalam dimensi yang sama muat 10 digit tujuh segmen dengan ketinggian sebanyak 13 mm.  Beberapa kecurigaan disebabkan oleh non-standar, dan, tampaknya, antarmuka buatan sendiri (yang contoh pemrograman dalam pseudocode verbal bahkan diberikan dalam lembar data).  Layar tidak mengandung pengontrol nyata: ada satu set pemicu kait statis yang dikendalikan oleh logika kombinasional.  Namun berkat kesederhanaan ini, seluruh desain ini hanya mengkonsumsi 30 μA, yaitu, sangat cocok untuk perangkat yang beroperasi dengan daya baterai sepanjang waktu (konsumsi 1,4 mA di layar konvensional dan bahkan 0,7 mA di MT-10S1 jauh lebih tinggi daripada yang diizinkan untuk seperti itu). penerapan nilai - hitung sendiri berapa lama tampilan seperti itu akan bekerja, bahkan tanpa memperhitungkan komponen perangkat yang tersisa, misalnya, dari baterai AAA dengan kapasitas sekitar 1500 mAh). <br><br><img src="https://habrastorage.org/webt/4c/dv/ki/4cdvkitbls9tkoihtq7swvmauly.png" width="400"><br><br>  Singkatnya, berikan dua! <br><br><h2>  MT-10T7 </h2><br>  Upaya untuk secara independen mereproduksi algoritma untuk MT-10T7, yang dijelaskan dalam lembar data (baik pada Arduino dan pada assembler murni), tidak mengarah pada kesuksesan.  Apa yang dilakukan salah, saya tidak mengerti, karena saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi ini</a> , di mana penulis (eshkinkot) memberikan contoh penanganan MT-10T7 yang ditulis dengan sangat baik dan benar-benar dieksekusi, setelah itu semuanya langsung bekerja.  Jika ada yang tertarik, maka di <a href="">sini terdapat</a> contoh eshkinkot yang dimodifikasi, dilengkapi dengan semua simbol bermakna yang valid pada indikator tujuh digit, termasuk huruf yang tidak cocok dengan angka: <br><br><img src="https://habrastorage.org/webt/hz/1u/4_/hz1u4_8n0uolveo40f-osvuitua.jpeg" width="400"><br><img src="https://habrastorage.org/webt/lk/wo/4g/lkwo4gmlxuqqfkmntzs13krvitc.jpeg" width="400"><br><img src="https://habrastorage.org/webt/n6/dd/pj/n6ddpjvxujkqk82ballqqvmua3w.jpeg" width="400"><br><img src="https://habrastorage.org/webt/gm/qq/x0/gmqqx0kwdiutig9tfvwrtuq2mtq.jpeg" width="400"><br><br>  Dalam gambar-gambar ini, kontras layar sedikit terdistorsi dengan mengatur pembagi ke output Vo - 18 kOhm (berkuasa): 10 kOhm (ke ground), meskipun tanpa itu kontras "default" cukup dapat diterima. <br><br>  Saya kemudian menambahkan ke contoh yang ditunjukkan fungsi yang mereproduksi angka acak pada tampilan dalam tiga hingga empat tempat desimal - positif atau negatif, bilangan bulat atau titik mengambang, yaitu, jumlah total karakter dapat mencapai lima: "-12,7", misalnya.  Karena titik dalam kode tujuh-segmen tidak menempati keakraban terpisah, jumlah bit maksimum yang akan ditampilkan adalah 4. Parameter input untuk fungsi ini adalah: a) array (char buf [5]) yang berisi representasi ACSII dari angka, b) jumlah karakter aktual di dalamnya (ii dari 1 hingga 5) dan c) posisi (pos dari 0 hingga 9) tempat meletakkan tanda pertama (kiri) nomor (untuk fungsi dan notasi yang digunakan sepanjang jalan, lihat publikasi yang ditunjukkan oleh eshkinkot atau dalam contoh dengan referensi): <br><br><div class="spoiler">  <b class="spoiler_title">Kode fungsi</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeASCIIdig_serial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buf[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">], byte ii, byte pos)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//      { boolean dot; //     //  ,   pos: pos=pos+(4-ii); //  ,    : for (byte i=0; i &lt;= ii; i++) if (buf[i]=='.') pos++; // : for (byte i=0; i &lt;= ii; i++){ // .  ,    : if (buf[i+1]=='.') dot=true; else dot=false; switch (buf[i]) { //decoder ASCII -&gt; 7-  case '0': writeSymbol(pos, DIGIT_ZERO, dot); break; case '1': writeSymbol(pos, DIGIT_ONE, dot); break; case '2': writeSymbol(pos, DIGIT_TWO, dot); break; case '3': writeSymbol(pos, DIGIT_THREE, dot); break; case '4': writeSymbol(pos, DIGIT_FOUR, dot); break; case '5': writeSymbol(pos, DIGIT_FIVE, dot); break; case '6': writeSymbol(pos, DIGIT_SIX, dot); break; case '7': writeSymbol(pos, DIGIT_SEVEN, dot); break; case '8': writeSymbol(pos, DIGIT_EIGHT, dot); break; case '9': writeSymbol(pos, DIGIT_NINE, dot); break; case '-': writeSymbol(pos, SYMBOL_MINUS, dot); break; } //end decoder if (buf[i]!='.') pos++; //  ,  +1  }//end for i }</span></span></span></span></code> </pre> <br></div></div><br>  Modul MT-10T7 untuk kontrol output nilai numerik lebih nyaman daripada tampilan garis-matriks biasa: ia memiliki angka besar, dan titik desimal tidak menempati keakraban yang terpisah dan, oleh karena itu, seseorang dapat memasukkan satu karakter lagi di posisi yang sama.  Tetapi untuk tujuan saya, akan lebih mudah jika ada kemungkinan menghasilkan huruf (jika tidak arah harus ditampilkan dalam derajat kompas, yang agak tidak biasa).  Oleh karena itu, untuk kasus ini, saya memalingkan mata saya ke matriks single-line MT-10S1 ukuran identik yang sama, yang, terlepas dari sejumlah kekurangan, dan bermigrasi ke desain yang sudah jadi.  Pada saat yang sama, ia sudah memiliki lampu latar, yang tidak dimiliki MT-10T7 (untuk ini perlu segera membeli MT-10T8), dan saya memutuskan bahwa dalam hal ini kehadirannya tidak akan sakit. <br><br><h2>  MT-10S1 </h2><br>  Layar MT-10S1 memiliki ukuran huruf satu-setengah kali lebih kecil, tetapi juga ukuran yang cukup baik.  Selain itu, layarnya dikemas secara ekonomis dalam dimensi keseluruhan: tidak ada mitra impor 10 digit, tetapi di Winstar WH1601L (di mana karakternya sedikit lebih pendek), milimeter keseluruhan lebih dari satu tanda dari panjang papan dan layar.  Nah, konsumsi pengontrol hampir setengahnya (dibandingkan dengan WH1601L yang sama).  Sebenarnya, keuntungan berakhir di sana, kemudian "fitur" dimulai. <br><br>  Modul ini membanggakan bahwa, sebagaimana telah disebutkan, ia memiliki controller yang kompatibel dengan HD44780 HITACHI.  Artinya, dia harus bekerja dengan Liquid Crystal kesayangannya tanpa tekanan yang tidak semestinya.  Selain itu, halaman pengkodean "default" bertepatan dengan halaman English-Cyrillic HD44780 dan banyak analoginya, yaitu, MT-10S1 harus bekerja dengan Liquid Crystal Rus tanpa masalah, tidak ada halaman kode yang diperlukan untuk ini untuk diaktifkan.  Dan dia benar-benar melakukan semua ini, tetapi dengan nuansa. <br><br>  Peringatan pertama - dalam versi single-line, pengembang tampaknya menghemat register, dan hanya 8 karakter string (alamat 00h - 07h) ada dalam memori per register (dan dua karakter yang tersisa sudah ada di register lain (40h-41j).  Artinya, tampilan de facto adalah dua garis, hanya kedua garis secara fisik terletak di satu garis.  Setelah pemeriksaan lebih dekat, ternyata hal yang sama berlaku untuk WH1601 (hanya di sana register kedua mengambil delapan digit penuh).  Mengapa hal ini dilakukan dengan sangat tidak nyaman sama sekali tidak jelas, dalam tampilan display 16x2 biasa adalah enam belas-bit, dan pemotongan seperti itu hampir tidak membuat produk lebih murah, sebaliknya, karena kebutuhan untuk menghasilkan versi yang berbeda dari pengontrol (jika mereka berbeda, yang saya tidak yakin sama sekali).  Saya pikir itu terkait dengan konsumsi MT-10S1 yang kurang dari biasanya, tetapi WH1601 yang sama mengkonsumsi 1,2-1,4 mA, artinya, tidak ada bedanya dengan rekan-rekan tingkat lanjutnya. <br><br>  Tampaknya, oke - dalam Liquid Crystal Rus, fungsi setDRAMModel () dan konstanta LCD_DRAM_WH1601 yang sesuai ditemukan.  Untuk mode ini, perpustakaan memiliki terjemahan alamat yang jelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ac&gt;<span class="hljs-number"><span class="hljs-number">7</span></span> &amp;&amp; ac&lt;<span class="hljs-number"><span class="hljs-number">0x14</span></span>) command(LCD_SETDDRAMADDR | (<span class="hljs-number"><span class="hljs-number">0x40</span></span>+ac<span class="hljs-number"><span class="hljs-number">-8</span></span>));</code> </pre> <br>  Tapi saya tidak tahu cara kerjanya pada tampilan satu baris lainnya, dan MT-10S1 sepenuhnya menolak untuk bekerja dalam mode ini - layar tetap kosong.  Karena kita berbicara tentang mengatasi, Anda tidak akan dapat memperbaikinya dengan fungsi sederhana yang ditulis sendiri di atas perpustakaan, tetapi saya tidak melihat-lihat di perpustakaan dan mencari tahu apa masalahnya - Saya sudah memiliki lebih dari setengah lusin opsi terkoreksi Kristal cair, saya tidak ingin memproduksinya dan selanjutnya. <br><br>  Tampilan MT-10S1 harus dinyatakan sebagai dua baris: lcd.begin (16, 2);  (alih-alih 16 Anda dapat mengganti 10 atau 12, tidak ada yang akan berubah, karena jumlah karakter sebenarnya dalam satu baris masih 8).  Upaya untuk menginisialisasi sebagai baris tunggal (nomor 1 di posisi kedua) akan menyebabkan kegagalan - latar belakang akan menjadi gelap.  Dan angka multi-digit hanya dapat ditampilkan dalam 8 karakter, untuk garis yang lebih panjang, karakter ekstrem di atas 8 akan hilang begitu saja.  Oleh karena itu, karakter 9 dan 10 hanya cocok untuk menampilkan jumlah tambahan (unit ukuran, misalnya), atau Anda perlu memecah nomor baris menjadi digit yang terpisah, dan ketika melampaui karakter 8, ubah posisi kursor ke karakter pertama dari baris kedua. <br><br>  Untuk penderita <a href="">, di sini</a> Anda dapat mengunduh sketsa percobaan untuk tampilan ini (koneksi lead - dalam teks sketsa atau dalam diagram di bawah).  By the way, kontras (tentang yang tidak ada kata dalam dataset pabrik, dan output Vo ditetapkan sebagai NC) disesuaikan dengan cara yang biasa di sini, tetapi Anda benar-benar tidak perlu melakukan ini: dengan tidak adanya cahaya latar, latar belakang tampak agak gelap, tetapi ketika Anda mencoba mencerahkannya dengan menghubungkan pembagi ke output Vo Kontras hilang secara nyata ketika lampu latar dihidupkan. <br><br><h2>  Antarmuka dengan pengontrol </h2><br>  Setelah memeriksa bahwa semuanya berfungsi sebagaimana mestinya, muncul pertanyaan tentang bagaimana menghubungkan semua ini ke pengontrol sensor.  Tentu saja, tidak ada kesimpulan gratis yang cukup untuk pengontrol sensor untuk memberikan kontrol darinya, tetapi saya tidak benar-benar ingin memagari kota dengan pengontrol besar - lebih nyaman ketika sistemnya modular dan output ke tampilan tidak mengganggu pengoperasian algoritma dasar yang sudah dibajak sebelumnya.  Tetap menggunakan antarmuka serial. <br><br>  Ini memunculkan solusi I <sup>2</sup> C berdasarkan PCF8574 (atau banyak analognya), terutama karena chip ini sendiri hanya merupakan register geser yang diperdaya, dan karena itu mengkonsumsi beberapa puluh mikroampere di tempat kerja dan kurang dari 10 mikroamper saat istirahat.  Bersama dengan MT-10T7 mereka membentuk pasangan yang sangat baik untuk membuat perangkat berdaya rendah dengan indikator, dan MELT bahkan memiliki opsi yang siap pakai untuk kasus ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MT-10T11</a> dengan total konsumsi 30 μA. <br><br>  Tetapi untuk MT-10S1 tidak ada solusi yang mudah - untuk beberapa alasan, hanya versi dengan konfigurasi 20x4 yang disertakan dengan tambahan dalam bentuk analog PCF8574 di antara tampilan garis MELT ( <b>UPD:</b> dalam komentar mereka menyarankan ada juga konfigurasi MT-16S2H 16x4 dengan antarmuka yang sama, meskipun , dimensinya melebihi dimensi yang saya butuhkan).  Modul selesai dari tipe yang dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel ini</a> tidak nyaman digunakan dalam kasus ini, karena fitur kedua yang tidak menyenangkan dari tampilan MT-10S1 adalah pinout non-standarnya.  Kesimpulannya sama (HD44780, namun, lebih tepatnya, pasangan domestiknya, KB1013VG6), tetapi semuanya berada dalam urutan yang sama sekali tidak standar.  Demi kepentingan, saya memeriksa baik impor 16x1 dan MELT dua baris / empat baris - mereka semua memiliki urutan keluaran standar, dan MT-10S1 menonjol di latar belakang ini karena beberapa alasan.  Jadi, Anda harus membuat keputusan sendiri. <br><br>  Sebagai hasilnya, saya dengan sepele menempatkan pengontrol ATmega328 yang sama ke layar, diprogram dengan cara yang sama - melalui UNO, dan kemudian dimasukkan ke dalam soket pada papan terpisah, hanya dilengkapi dengan aksesori yang diperlukan untuk memulai: kuarsa dengan konduktor, catu daya dan rangkaian-RC. Reset output (lihat sirkuit sensor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di artikel asli</a> , di mana controller terhubung dengan cara yang sama). <br><br><div class="spoiler">  <b class="spoiler_title">Berbicara tentang Reset Chaining</b> <div class="spoiler_text">  By the way, tentang rangkaian Reset: Saya memiliki kapasitor sekecil 1 μF pada resistor beberapa kOhms, yaitu, waktu tunda saat menyalakan daya adalah beberapa milidetik.  Berapa banyak?  Manual ini mengajarkan kita bahwa, seperti untuk seluruh keluarga Mega, rantai eksternal tidak diperlukan sama sekali di sini, awal yang benar seharusnya dilakukan oleh sirkuit internal, dan jauh lebih cepat.  Tetapi kebiasaan meletakkan rantai RC eksternal pada pin 1 dari controller untuk start-up yang tertunda ketika saya dihidupkan tetap bersama saya dari waktu keluarga AVR Classic yang sudah terlupakan, di mana controller mungkin tidak memulai dengan benar jika tegangan suplai tidak cukup cepat.  Dan dalam keluarga Mega Brown-out Detector, ini mungkin tidak berfungsi dengan baik.  Dalam kasus-kasus kritis, masih bermanfaat untuk memasang monitor daya eksternal, well, tapi di sini rantai RC tidak melukai apa pun, tetapi dapat membantu dalam kasus dengan sumber daya yang buruk.  Omong-omong, pengembang papan Arduino sangat menyadari hal ini, karena di papan Uno, misalnya, ada rantai yang sama 10 kOhm / 100 nF. <br></div></div><br>  Dan Tuhan sendiri memerintahkan dua pengontrol AVR yang identik untuk di-dock melalui Serial-interface yang biasa, yang bagaimanapun, kecuali untuk proses pemrograman, tidak digunakan di tempat lain dalam proyek ini, dan untuk penggunaan yang semuanya sudah ada di tangan.  Omong-omong, solusi semacam itu tidak berbeda harga dari komponen-komponen berbasis PCF8574 dan dapat bersaing dengannya dalam hal penghematan energi dalam varian dengan MT-10T7 - jika MT-10T11 yang disebutkan di atas tidak tersedia. <br><br>  Secara total, rangkaian modul MT-10S1 dengan pengontrol adalah sebagai berikut (dalam diagram, penunjukan kesimpulan ATmega328 diberikan dalam tanda kurung setelah kesimpulan dari papan Arduino): <br><br><img src="https://habrastorage.org/webt/zu/4h/sg/zu4hsgop0jxa8ufsqopzlr4xqro.png" width="880"><br><br>  Di controller, saya menerapkan mode hemat daya (well, ya, itu tidak benar-benar diperlukan di sini, tapi mengapa menyimpan chip di sepanjang jalan yang tidak perlu?).  Selain itu, wake-up terjadi sesuai dengan sinyal dari generator gelombang persegi yang sama pada chip 555 sebagai jam dari pengontrol utama, hanya kali ini di sepanjang tepi jatuh (FALLING) untuk sedikit memisahkan fungsi pengukuran dan transfer data. <br><br><div class="spoiler">  <b class="spoiler_title">Misteri alam</b> <div class="spoiler_text">  Satu misteri alam terkait dengan ini, yang tidak bisa saya pecahkan.  Diketahui bahwa Mega hanya dapat dikeluarkan dari tidur nyenyak oleh interupsi asinkron eksternal, karena jam dimatikan dan interupsi sinkron tidak dapat terjadi.  Dan seluruh keluarga pengontrol AVR 28-pin, memimpin pohon keluarga mereka dari ATmega8 (48/88/168/328), hanya memiliki interupsi tingkat rendah seperti INT0 dan INT1 (dan interupsi PCINT, tetapi tidak digunakan dalam Arduino).  Semua rekomendasi resmi terkait dengan ini baik dalam materi Atmel dan di situs Arduino.  Contoh di situs web arduino.cc secara eksplisit mengatakan: " <i>Dalam semua mode tidur IDLE, hanya RENDAH yang dapat digunakan</i> ."  Dan ini, seolah-olah, tidak diragukan, misalnya, Biksu mengulangi hal yang sama secara lebih rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam bukunya</a> : “ <i>Perhatikan bahwa tipe interupsi RENDAH dipilih.</i>  <i>Ini adalah satu-satunya jenis interupsi yang dapat digunakan dalam contoh ini.</i>  <i>Jenis RISING, FALLING, dan CHANGE tidak akan berfungsi</i> . " <br><br>  Gangguan pada level rendah sangat tidak nyaman untuk digunakan, karena begitu terjadi, dengan level terendah pada output, ini akan terjadi berulang-ulang, dan langkah-langkah khusus harus diambil untuk menghilangkan pemicu yang tidak perlu.  Jadi, mencari-cari di berbagai forum untuk mencari berbagai solusi untuk masalah ini, saya tiba-tiba menemukan beberapa contoh kode di mana INT0 dari tipe RISING atau FALLING secara eksplisit digunakan untuk keluar dari tidur.  Tentu saja, saya menghubungkan ini dengan buta huruf dari penulis.  Tetapi ketika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya</a> tersandung frasa: " <i>Meskipun Anda dapat menggunakan jenis interupsi (RISING, FALLING, CHANGE) lainnya - mereka semua akan mengeluarkan prosesor dari tidur</i> ", saya memutuskan, terlepas dari musuh, untuk melakukan percobaan langsung - itu baik untuk itu dengan tangan. <br><br>  Dan, yang mengejutkan saya, semuanya bekerja dengan sempurna.  Mode Hemat Daya - SLEEP_MODE_PWR_DOWN;  karena kesia-siaan, di sini saya tidak mengambil langkah-langkah untuk mengurangi konsumsi dengan menonaktifkan semua fungsi lainnya, tetapi generator clock tetap mati.  Namun demikian, pengontrol bangun secara teratur di tepi jatuh, meminta data, menampilkannya di layar dan tertidur lagi.  Demi kemurnian percobaan, saya melepas MK dari papan UNO dan memasukkannya ke dalam soket saya dengan kuarsa yang terhubung, dan semuanya masih berfungsi.  Ini dapat dilihat dari konsumsi: hampir 17 mA dalam mode normal dan 0,9-1 mA dengan penghematan daya dihidupkan (yang 0,7 mA harus dikaitkan dengan tampilan). <br><br>  Tanpa keluar dari keterkejutan saya, saya membaca lembar data dari Atmel, melihat ke buku Evstifeev (dengan terjemahannya), bahkan melihat manual Atmel lama tentang keluarga Klasik, kemudian menghabiskan setengah hari mencari setidaknya beberapa penjelasan tentang apa yang terjadi (baik dalam bahasa Rusia dan Rusia). dalam bahasa Inggris) di dua mesin pencari terkenal, tetapi tidak ada petunjuk sama sekali.  Kecuali itu berguna dalam Atmel's Application Notes, karena diragukan bahwa sesuatu yang bertentangan dengan lembar data diterbitkan di sana. Saya akan senang jika seseorang yang tahu tahu apa yang saya salah pahami. <br>  <b>UPD:</b> live assembler check (ATmega8) menunjukkan kepatuhan penuh dengan lembar data, yaitu, hanya gangguan level yang berfungsi.  Satu-satunya penjelasan yang muncul dalam pikiran adalah bahwa Arduino entah bagaimana menghubungkan interupsi PCINT ke interupsi biasa.  Upaya untuk memperjelas situasi dengan mempelajari teks perpustakaan sistem Arduino tidak menghasilkan apa-apa - di sana iblis akan mematahkan kakinya. <br></div></div><br>  Transfer data dari pengontrol sensor ke pengontrol tampilan melalui UART diatur dalam bentuk dialog.  Bangun, setiap gangguan ke-4, pengontrol tampilan meminta data pada gilirannya: <br><br><pre> <code class="cpp hljs">. . . . . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag==<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   4-  ~6  Serial.print('T'); //   while(!Serial.available()); //  T iit = Serial.readBytes(buft,5); //  5  , //  ii    Serial.print('H'); //   while(!Serial.available()); //  iihh=Serial.readBytes(bufhh,5); //  5  , //  ii    Serial.print('S'); //   while(!Serial.available()); //  iiss=Serial.readBytes(bufss,5); //  5  , //  ii    Serial.print('D'); //   while(!Serial.available()); //  iid=Serial.readBytes(bufd,5); //  5  , //  ii    flag=0; //   } . . . . .</span></span></code> </pre><br>  Berikut buft, bufhh, bufss dan bufd adalah array (bukan string!) Dari lima byte, yang berisi data tentang suhu, kelembaban, kecepatan dan arah dalam bentuk dekomposisi ASCII dari angka-angka yang sesuai.  Agar tidak menerima terlalu banyak, setup'e menetapkan batas waktu penerimaan yang disingkat: <br><br><pre> <code class="cpp hljs">. . . . . Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); Serial.setTimeout(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   10  . . . . .</span></span></code> </pre><br>  Lebih nyaman untuk ditampilkan: pertama, Anda segera memiliki panjang nomor yang diterima, dan kedua, fungsi Serial.print () mengirimkan string ASCII dari sisi pengontrol sensor, dengan jeda yang ditetapkan hanya dalam 10 ms yang sama antara pengiriman : <br><br><pre> <code class="cpp hljs">. . . . . <span class="hljs-comment"><span class="hljs-comment">//     : if (Serial.available()&gt;0) //  { char ch=Serial.read(); if (ch=='T') { Serial.print(temperature,1); delay(10);} if (ch=='H') { Serial.print(humidity,0); delay(10);} if (ch=='S') { float wFrq=(3+0.8*f)/10; //   / if (wFrq&gt;0.3) Serial.print(wFrq,1); else Serial.print(0.0,1); delay(10);} if (ch=='D') { // Serial.println(wind_G); Serial.println(wind_Avr); delay(10); }//end ch }//end serial . . . . .</span></span></code> </pre><br>  Perhitungan kecepatan dalam m / s di sini identik dengan yang dilakukan dalam modul utama stasiun (ambang awal diatur secara acak menjadi 0,3 m / s) dan juga harus diubah sesuai dengan hasil kalibrasi. <br><br>  Jika Anda mencoba menerima data dengan Serial.read biasa (), dan kemudian menampilkan hasil penerimaan pada tampilan dengan fungsi seperti lcd.print (t, 1), di mana t adalah suhu dalam derajat, sama, misalnya, ke 12,7, maka MT-10S1 sebagai respons terhadap ini perintah akan menampilkan "49.5".  Ditebak, atau disarankan?  Ini adalah tiga karakter pertama dalam urutan "49 50 46 55", yaitu, dalam ekspansi ASCII dari angka "12,7".  Oleh karena itu, lebih mudah untuk langsung menerima array karakter dan langsung menampilkan sebanyak karakter yang dikirim (hitungan adalah penghitung yang bertambah satu setiap interupsi): <br><br><pre> <code class="cpp hljs">. . . . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count%<span class="hljs-number"><span class="hljs-number">8</span></span>==<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// 8   lcd.clear(); if (buft[0]!='-') lcd.print("+"); for (byte i = 0; i &lt; iit; i++) lcd.print(buft[i]); //  lcd.setCursor(6, 0); for (byte i = 0; i &lt; iihh; i++) lcd.print(bufhh[i]); //  lcd.setCursor(0, 1); lcd.print("%"); } if ((count+4)%8==0){ //  4  lcd.clear(); lcd.setCursor(0, 0); for (byte i = 0; i &lt; iiss; i++) lcd.print(bufss[i]); //  lcd.setCursor(5, 0); dir_dd(bufd); //  } . . . . .</span></span></code> </pre><br>  Baris terakhir perlu didekripsi.  Faktanya adalah bahwa data arah dikirim dalam kode 0-15 (yang mana mereka masih ditransfer dari kode Gray ketika menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rata-rata vektor</a> ).  Dalam hal tampilan tujuh segmen MT-10T7, mereka diterjemahkan ke dalam derajat kompas: <br><br><pre> <code class="cpp hljs">. . . . . dd=atoi(bufd); <span class="hljs-comment"><span class="hljs-comment">//   dd=dd*22.5; //   itoa(dd,bufd,10); //    . . . . .</span></span></code> </pre><br>  Dan di sini kita dapat menulis secara langsung dalam huruf Rusia, dengan cara yang sama seperti pada modul utama stasiun cuaca (karena itulah tampilan ini, pada kenyataannya, dipilih): <br><br><pre> <code class="cpp hljs">. . . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dir_dd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dd[])</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(atoi(dd)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} }<span class="hljs-comment"><span class="hljs-comment">//end switch }//end dir . . . . .</span></span></code> </pre><br><h2>  Penampilan </h2><br>  Foto menunjukkan tampilan layar dengan pengontrol yang terhubung dalam kondisi kerja: <br><br><img src="https://habrastorage.org/webt/wo/dg/fk/wodgfkuefea3shdafmubstmlmke.jpeg" width="400"><br><br>  Beginilah tampilan unit sensor yang dimodifikasi: <br><br><img src="https://habrastorage.org/webt/ww/v4/p_/wwv4p_duhu45imp1gwppoz0ydzo.jpeg" width="400"><br><br>  Parameter lampu latar adalah yang ditunjukkan dalam diagram di atas.  Karena penurunan tegangan pada lampu latar dalam modul MELT adalah 4,5 V, dengan catu daya 12 V, arus lampu latar adalah 50 mA (maksimum untuk modul ini 60 mA). <br><br>  Rumah ini disegel secara maksimal untuk menghindari masuknya udara lembab (bingkai hitam layar tampilan berasal dari selubung karet kabel tipis).  Pelat putih di sebelah kanan adalah penutup sensor suhu-kelembaban SHT-75, yang dikeluarkan dari kasing (sensor itu sendiri terletak di belakangnya).  Kabel kuning di atas adalah antena pemancar 433 MHz.  Di sebelah kiri adalah konektor di mana sensor kecepatan dan arah terhubung. <br><br>  Jadi bacaan pada tampilan modul utama stasiun cuaca terlihat seperti (modul hitam dengan antena putih di sebelah kanan adalah penerima 433 MHz): <br><br><img src="https://habrastorage.org/webt/53/kd/kg/53kdkgcw_aqjwuzrjw4ev1k7uby.jpeg" width="400"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430828/">https://habr.com/ru/post/id430828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430818/index.html">Akselerasi SQLAlchemy untuk Astronot Arsitektur</a></li>
<li><a href="../id430820/index.html">Black Friday 2018 - VDS di Moskow dan Amsterdam</a></li>
<li><a href="../id430822/index.html">Keamanan informasi Internet tentang hal-hal: siapa itu barangnya dan siapa tuannya?</a></li>
<li><a href="../id430824/index.html">Cari objek yang rusak dengan nomor halaman yang rusak di MS SQL Server 2005</a></li>
<li><a href="../id430826/index.html">Bagaimana cara mengembangkan manajer pengembangan</a></li>
<li><a href="../id430830/index.html">Black Friday, tradisi dan idiom bahasa Inggris tentang berbelanja</a></li>
<li><a href="../id430832/index.html">Harga Black Friday Manusia</a></li>
<li><a href="../id430834/index.html">10 Dosa Mematikan Pembicara</a></li>
<li><a href="../id430836/index.html">Kotlin: statis itu tidak ada</a></li>
<li><a href="../id430838/index.html">Keajaiban pemasaran orang banyak, atau bagaimana mempromosikan bisnis dengan ulasan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>