<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüöí üñ§ üë®üèª‚Äçüåæ √Årboles de b√∫squeda binaria equilibrada: implementaci√≥n en Julia üôáüèø üßëüèæ‚Äçü§ù‚Äçüßëüèº ü§£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ilustraci√≥n del trabajo de G.M. Adelson-Welsky y E.M. Landis 1962 


 Los √°rboles de b√∫squeda son estructuras de datos para el almacenamiento ordenado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Årboles de b√∫squeda binaria equilibrada: implementaci√≥n en Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455172/"><p><img src="https://habrastorage.org/webt/5q/ek/4n/5qek4nssuu4dsjepoaa2g9tgmw0.png"><br>  <em>Ilustraci√≥n del trabajo de G.M.</em>  <em>Adelson-Welsky y E.M.</em>  <em>Landis 1962</em> </p><br><p>  Los √°rboles de b√∫squeda son estructuras de datos para el almacenamiento ordenado y la b√∫squeda simple de art√≠culos.  <em>Los</em> √°rboles de b√∫squeda <em>binarios</em> son ampliamente utilizados, en los que cada nodo tiene solo dos hijos.  En este art√≠culo, consideramos dos m√©todos para organizar los √°rboles de b√∫squeda binarios: los algoritmos de Adelson-Welsky y Landis (√°rboles AVL) y los √°rboles AVL debilitados (√°rboles WAVL). </p><a name="habracut"></a><br><p>  Comencemos con las definiciones.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El √°rbol binario</a> consta de <em>nodos</em> , cada nodo almacena un <em>registro</em> en forma de pares <em>clave-valor</em> (o, en el caso simple, solo valores) y no tiene m√°s de dos <em>hijos</em> .  Los nodos descendientes se distinguen por <em>derecha</em> e <em>izquierda</em> , y se cumple la condici√≥n para el orden de las claves: la clave del descendiente izquierdo ya no existe, y la derecha no es menor que la clave del nodo primario.  Adem√°s, la informaci√≥n de servicio se puede almacenar (y generalmente se almacena) en nodos, por ejemplo, un enlace al nodo principal u otros datos.  Los casos especiales son el <em>nodo ra√≠z</em> desde el que entra el √°rbol y <em>un nodo vac√≠o</em> que no almacena ninguna informaci√≥n.  Los nodos en los que ambos descendientes est√°n vac√≠os se llaman <em>hojas de</em> √°rbol.  Un nodo con todos los descendientes forma un <em>sub√°rbol</em> .  Por lo tanto, cada nodo es la ra√≠z de un sub√°rbol o una hoja. </p><br><p> Esta definici√≥n le permite construir una estructura simple para almacenar nodos y el √°rbol en s√≠.  Suponemos que un nodo vac√≠o tiene el valor especial <code>nothing</code> tipo <code>Nothing</code> .  Luego, en el nodo, es suficiente almacenar referencias a la descendencia derecha e izquierda y al padre.  La estructura para almacenar el √°rbol contiene solo un enlace al nodo ra√≠z. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># K -   # V -    mutable struct BSTNode{K, V} key::K value::V left::Union{Nothing, BSTNode{K,V}} right::Union{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} end mutable struct BST{K, V} root::BSTNode{K,V} end</span></span></code> </pre> <br><p>  En este caso, surge la pregunta de c√≥mo representar un √°rbol vac√≠o.  Para hacer esto, utilizamos el enfoque del libro "Algorithms: Construction and Analysis" e insertamos como punto de entrada en el √°rbol, no una ra√≠z, sino un nodo ficticio, que ser√° su propio padre.  Para crear dicho nodo, agregue constructores a la descripci√≥n de la estructura BSTNode: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> BSTNode{K, V} key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function BSTNode{K,V}() where {K,V} node = new{K,V}() node.parent = node node.left = node.right = nothing return node end #    - function BSTNode{K,V}(key, value) where {K, V} node = new{K,V}() node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end BSTNode() = BSTNode{Any, Any}() #     ! struct BST{K, V} entry::BSTNode{K,V} BST{K,V}() where {K,V} = new{K,V}(BSTNode{K,V}()) end BST() = BST{Any, Any}() Base.isempty(bst::BST) = bst.entry.left == nothing</span></span></code> </pre> <br><p>  En este caso, la estructura <code>BST</code> se puede hacer sin cambios, porque  ya no ser√° necesario cambiar el enlace al punto de entrada.  Adem√°s, suponemos que el nodo ra√≠z del √°rbol es inmediatamente el descendiente derecho e izquierdo del nodo de entrada. </p><br><p>  La operaci√≥n principal para la que se necesitan √°rboles de b√∫squeda es, naturalmente, la b√∫squeda de elementos.  Como la clave del elemento secundario izquierdo ya no existe, y la clave correcta no es menor que la clave principal, el procedimiento de b√∫squeda de elementos se escribe de manera muy simple: a partir de la ra√≠z del √°rbol, compare la clave de entrada con la clave del nodo actual;  si las teclas coinciden, devolvemos el valor; de lo contrario, vaya al sub√°rbol izquierdo o derecho, seg√∫n el orden de las teclas.  Si al mismo tiempo llegaron a un nodo vac√≠o, no hay una clave en el √°rbol, arroje una excepci√≥n. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.getindex()    #      tree[key] function Base.getindex(bst::BST{K,V}, key) where {K,V} key = convert(K, key) node = bst.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><p>  La b√∫squeda de un elemento por clave, obviamente, toma tiempo <em>O</em> ( <em>h</em> ), donde <em>h</em> es la altura del √°rbol, es decir  distancia m√°xima desde la ra√≠z hasta la hoja.  Es f√°cil calcular que un √°rbol binario de altura <em>h</em> puede contener como m√°ximo 2 <sup>h + 1</sup> -1 nodos si est√° <em>densamente poblado</em> , es decir  Todos los nodos, excepto, quiz√°s, la capa muy extrema, tienen ambos descendientes.  Adem√°s, est√° claro que cualquier secuencia de teclas por adelantado puede conducir a un √°rbol tan denso.  Esto proporciona un comportamiento asint√≥tico muy optimista de la b√∫squeda de un elemento en un √°rbol con su construcci√≥n √≥ptima en el tiempo <em>O</em> (log <sub>2</sub> <em>N</em> ), donde <em>N</em> es el n√∫mero de elementos. </p><br><p>  Naturalmente, el algoritmo para agregar un elemento al √°rbol de b√∫squeda debe construirse de tal manera que se cumpla la condici√≥n del orden de las claves.  Escribamos una implementaci√≥n ingenua de insertar un elemento por clave: </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.setindex!()    #       tree[key] = value function Base.setindex!(bst::BST{K,V}, val::SV, key::SK) where {K, V} key, value = convert(K, key), convert(V, val) parent = bst.entry.left #   -     if parent == nothing newnode.parent = bst.entry bst.entry.left = bst.entry.right = newnode return val end key_found = false while !key_found if key &lt; parent.key if parent.left == nothing parent.left = BSTNode{K,V}(key, value) parent.left.parent = parent key_found = true else parent = parent.left end elseif key &gt; parent.key if parent.right == nothing parent.right = BSTNode{K,V}(key, value) newnode.parent = parent key_found = true else parent = parent.right end else key_found = true parent.value = value end end return val end</span></span></code> </pre> <br><p>  Desafortunadamente, la construcci√≥n ingenua del √°rbol dar√° la estructura deseada solo en datos de entrada aleatorios, pero en realidad a menudo est√°n bastante estructurados.  En el peor de los casos, si las claves entrantes est√°n estrictamente ordenadas (al menos en orden ascendente, al menos en orden descendente), la construcci√≥n de √°rboles ingenuos enviar√° nuevos elementos todo el tiempo en una direcci√≥n, recogiendo, de hecho, una lista lineal.  Es f√°cil adivinar que la inserci√≥n de elementos, que la b√∫squeda ocurrir√° con dicha estructura durante <em>O</em> ( <em>N</em> ), lo que niega todos los esfuerzos para construir una estructura de datos compleja. </p><br><p>  Conclusi√≥n: el √°rbol de b√∫squeda debe estar <em>equilibrado</em> durante la construcci√≥n, es decir  alinee la altura del sub√°rbol derecho e izquierdo en cada nodo.  Hay varios enfoques para el equilibrio.  Lo m√°s simple es especificar un cierto n√∫mero de operaciones de inserci√≥n o eliminaci√≥n, despu√©s de lo cual se reequilibrar√° el √°rbol.  En este caso, el √°rbol estar√° en un estado m√°s bien "en ejecuci√≥n" antes del balanceo, debido a que el balanceo tomar√° aproximadamente <em>O</em> ( <em>N</em> ) en el peor de los casos, pero las operaciones posteriores hasta cierto umbral de inserci√≥n / eliminaci√≥n se realizar√°n en tiempo logar√≠tmico.  Otra opci√≥n es construir los algoritmos de inserci√≥n y eliminaci√≥n de forma inmediata para que el √°rbol siempre permanezca equilibrado, lo que proporciona la complejidad de tiempo <em>garantizada</em> <em>O</em> (log <sub>2</sub> <em>N</em> ) para cualquier operaci√≥n. </p><br><p>  Debido al hecho de que hay algoritmos en los que se permite que el √°rbol se "vuelva loco", pero despu√©s de eso, las operaciones se pueden llevar a cabo durante un tiempo bastante largo en un tiempo logar√≠tmico, antes de que el √°rbol tenga que volver a un estado equilibrado durante mucho tiempo, se distingue el tiempo <em>garantizado</em> y <em>amortizado</em> de inserci√≥n / eliminaci√≥n de un elemento.  Para algunas implementaciones de operaciones con √°rboles de b√∫squeda binarios, la complejidad de insertar y eliminar <em>O</em> (log <sub>2</sub> <em>N</em> ) est√° garantizada, para algunos se amortiza, con deterioro a <em>O</em> ( <em>N</em> ). </p><br><h3 id="algoritm-adelson-velskogo-i-landisa-avl">  Algoritmo de Adelson-Welsky y Landis (AVL) </h3><br><p>  La primera implementaci√≥n de un √°rbol de b√∫squeda binaria de equilibrio autom√°tico fue propuesta en 1962 por Adelson-Welsky y Landis.  En la literatura moderna sobre las letras iniciales de los apellidos, esta estructura se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rboles AVL</a> .  La estructura se describe mediante las siguientes propiedades: </p><br><ol><li>  Orden: para cualquier nodo, la clave en la parte superior del sub√°rbol izquierdo es menor que la clave en la parte superior del sub√°rbol derecho (si los descendientes no son nodos vac√≠os). </li><li>  Aumento de altura: la altura del nodo padre es uno m√°s que la altura m√°xima de sus descendientes.  La altura de los nodos vac√≠os puede considerarse igual a cero. </li><li>  Balance AVL: para cualquier nodo, las alturas de los sub√°rboles derecho e izquierdo difieren en no m√°s de 1. </li></ol><br><p>  De estas propiedades se deduce que la altura de todo el √°rbol es <em>O</em> (log <sub>2</sub> <em>N</em> ), donde <em>N</em> es el n√∫mero de registros almacenados en el √°rbol, lo que significa que el registro se busca en tiempo logar√≠tmico.  Para que la condici√≥n del equilibrio ABL permanezca despu√©s de cada inserci√≥n, cada inserci√≥n va acompa√±ada de una operaci√≥n de <em>equilibrio</em> .  Para la implementaci√≥n efectiva de esta operaci√≥n, cada nodo necesita almacenar informaci√≥n de servicio.  Para simplificar, simplemente mantenga la altura del nodo all√≠. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> AVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment"># ,       255 # (  10^38 ) height::UInt8 key::K value::V left::Union{Nothing, AVLNode{K,V}} right::Union{Nothing, AVLNode{K,V}} parent::AVLNode{K,V} #   function AVLNode{K,V}() where {K,V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing return node end #    - function AVLNode{K,V}(key::SK, value::SV) where {K, V, SK&lt;:K, SV&lt;:V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end avlheight(node::Union{Nothing,AVLNode}) = node == nothing ? 0 : Int(node.height)</span></span></code> </pre> <br><h4 id="vstavka-zapisi">  Insertar registro </h4><br><p>  La inserci√≥n b√°sica se realiza de acuerdo con el algoritmo est√°ndar: baje el √°rbol hacia abajo, busque d√≥nde puede insertar un nuevo nodo e insertar.  Vamos a escribir contenedores para obtener y reemplazar nodos secundarios utilizando los √≠ndices -1 y 1 en lugar de izquierda y derecha: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> child(root::AVLNode, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 to get the left child or side=1 to get the right child"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> insert_child!(root::AVLNode{K,V}, newnode::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,AVLNode{K,V}}, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} newnode == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> || (newnode.parent = root) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left = newnode <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right = newnode <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 for inserting node to the left or side=1 for inserting to the right"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  A continuaci√≥n, subimos al √°rbol y buscamos violaciones de las condiciones 2 y 3. A continuaci√≥n, consideramos las opciones que pueden aparecer (en las figuras, el verde indica el nodo que cambi√≥ la altura, el nodo que se est√° procesando es su padre). </p><br><p>  <strong>Caso 0</strong> <br>  Despu√©s de la inserci√≥n, la altura del nodo se convirti√≥ en la misma que la de la hermana, y 1 menor que la altura (antigua) del nodo padre. </p><br><p><img src="https://habrastorage.org/webt/uf/9_/iq/uf9_iqcs1ydiwszzfl8ub8dbxj8.png"></p><br><p>  El mejor de los casos, no necesita tocar nada m√°s.  Arriba, tambi√©n, ya no puedes mirar, porque  nada cambiar√° all√≠. </p><br><p>  <strong>Caso 1</strong> <br>  Antes de la inserci√≥n, la altura del nodo era igual a la altura del nodo hermano.  La inserci√≥n levanta la ra√≠z del sub√°rbol, y la altura del nodo se compara con la altura del padre. </p><br><p><img src="https://habrastorage.org/webt/s4/nv/t4/s4nvt4y-m1znfln4g4ajf2346d0.png"></p><br><p>  En este caso, es suficiente "elevar" el nodo primario, aumentando su altura en 1. Al mismo tiempo, debe continuar movi√©ndose a la ra√≠z del √°rbol, ya que cambiar la altura del nodo primario podr√≠a conducir a la violaci√≥n de la condici√≥n 2 un nivel m√°s alto. </p><br><p><img src="https://habrastorage.org/webt/v-/j9/0s/v-j90s0nar7w4mgas4oujggl3h8.png"></p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="julia hljs">fucntion promote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height += by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fucntion demote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height -= by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  <strong>Caso 2</strong> </p><br><p>  Despu√©s de la inserci√≥n, la diferencia de altura con el sub√°rbol hermano se convirti√≥ en 2, y el sub√°rbol izquierdo "empuj√≥" hacia arriba: </p><br><p><img src="https://habrastorage.org/webt/la/bl/aj/lablajxlzp2lgvbhm4nlh5j-3ks.png"></p><br><p>  El problema se trata con una operaci√≥n llamada "rotaci√≥n simple" que transforma el √°rbol de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/8j/zc/yt/8jzcytyqgke3xpcikei8zrbvbrq.png"></p><br><p>  Un giro simple requiere 6 cambios de puntero. </p><br><p>  Tenga en cuenta que en la proyecci√≥n sobre el eje horizontal, el orden de los v√©rtices <em>n</em> , <em>p</em> y los √°rboles <em>T</em> <sub>1</sub> - <em>T</em> <sub>3</sub> antes y despu√©s de la rotaci√≥n sigue siendo el mismo.  Este es el cumplimiento de la condici√≥n de pedido.  Como puede ver, despu√©s de subir el √°rbol, ya no es necesario equilibrar. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  <strong>Caso 3</strong> <br>  Despu√©s de la inserci√≥n, la diferencia de altura con el sub√°rbol hermano se convirti√≥ en 2, y el sub√°rbol derecho "empuj√≥" hacia arriba: </p><br><p><img src="https://habrastorage.org/webt/cs/el/1u/csel1u39enlepfhdrc4bdw_legq.png"></p><br><p>  En este caso, un solo giro simple ya no ayudar√°, pero puede hacer un simple giro a la izquierda alrededor del descendiente derecho, lo que conducir√° al caso 2, que ya est√° siendo tratado con un simple giro a la derecha. </p><br><p>  Para reducir el n√∫mero de "pesas" de nodos, se pueden combinar dos turnos en una sola operaci√≥n, llamada turno grande o doble.  Luego, en lugar de 12 cambios de punteros, solo se necesitar√°n 10. Como resultado de una doble rotaci√≥n, el √°rbol toma la siguiente forma: </p><br><p><img src="https://habrastorage.org/webt/ub/ds/7i/ubds7iawqzg9uqgned3mxiqs_8m.png"></p><br><p>  Como puede ver, despu√©s de un doble giro, tampoco es necesario equilibrar m√°s el √°rbol. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       funtion double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  Entonces, cuando inserta un registro en el √°rbol AVL, necesita <em>O</em> (log <sub>2</sub> <em>N</em> ) cambios en la informaci√≥n sobre la altura de los nodos y no m√°s de dos operaciones de rotaci√≥n.  Combina todo en una funci√≥n de inserci√≥n.  Diferir√° de la inserci√≥n b√°sica solo en que despu√©s de la inserci√≥n de un nuevo nodo, se <code>fix_insertion!()</code> la funci√≥n <code>fix_insertion!()</code> , Que pasa del nodo reci√©n insertado a la ra√≠z, comprueba y, si es necesario, corrige el equilibrio. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.setindex!(avlt::AVLTree{K,V}, val, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left <span class="hljs-comment"><span class="hljs-comment">#   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 # true == 1, false == 0 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> <br><p>  La funci√≥n <code>fix_insertion!()</code> Verifica la diferencia de altura entre dos nodos secundarios, comenzando desde el nodo principal desde el insertado.  Si es igual a 1, estamos en el caso 1, debe elevar la altura del nodo e ir m√°s alto.  Si es cero, el √°rbol est√° equilibrado.  Si es igual a 2, este es el caso 2 o 3, debe aplicar la rotaci√≥n adecuada y el √°rbol llega a un estado equilibrado. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#     -  , #   -  imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) #      0 - ..        while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 #       , # ..   dir = -skew √∑ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end</span></span></code> </pre> <br><h4 id="udalenie-zapisi">  Eliminar registro </h4><br><p>  Quitarlo es un poco m√°s dif√≠cil que insertarlo. </p><br><p>  Para comenzar, considere la eliminaci√≥n habitual de una entrada de un √°rbol de b√∫squeda binario. </p><br><ol><li>  Si el registro eliminado est√° en la hoja, entonces el registro simplemente se elimina, aqu√≠ todo es simple. </li><li>  Si el registro eliminado est√° en un nodo que tiene un solo descendiente, este descendiente, junto con todo su sub√°rbol, se coloca en el lugar del nodo remoto. </li><li>  Si hay dos descendientes, entonces el elemento m√°ximo se busca en el sub√°rbol izquierdo, o el m√≠nimo en el derecho, se extrae del √°rbol (por la propiedad del √°rbol de b√∫squeda, se garantiza que el nodo con el elemento m√°ximo no tendr√° un descendiente derecho y con un elemento m√≠nimo a la izquierda, por lo que esta eliminaci√≥n es f√°cil) y poner en lugar del registro eliminado. </li></ol><br><p>  Pero despu√©s de eso, el equilibrio del √°rbol puede verse alterado, por lo que debe subir desde el padre del nodo remoto y restaurarlo.  Tenga en cuenta que al principio se garantiza que uno de los descendientes del padre en cuesti√≥n redujo la altura en 1. Teniendo esto en cuenta, debe tener en cuenta las opciones (los nodos que cambiaron la altura se muestran en rojo, el nodo procesado es el padre del rojo): </p><br><p>  <strong>Caso 1</strong> <br>  Cero desequilibrio.  Entonces, antes de la eliminaci√≥n, era 1 m√≥dulo, y ahora los nodos hijos son 2 m√°s bajos que el padre. </p><br><p><img src="https://habrastorage.org/webt/mo/cm/a_/mocma_jzetjrizjwiesbdtx1rtu.png"></p><br><p>  Debe bajar el nodo principal en 1 y continuar subiendo. </p><br><p><img src="https://habrastorage.org/webt/j8/6y/yi/j86yyi7cxkzasggld6pzo9fldwu.png"></p><br><p>  <strong>Caso 2</strong> <br>  Desequilibrio 1 m√≥dulo. </p><br><p><img src="https://habrastorage.org/webt/hn/8v/cx/hn8vcxpvolbjnafm9h3u08kpnoo.png"></p><br><p>  La condici√≥n AVL est√° satisfecha, puede detenerse. </p><br><p>  <strong>Caso 3</strong> <br>  El desequilibrio 2 es m√≥dulo, el nodo hermano del descendente tiene un desequilibrio distinto de cero. </p><br><p><img src="https://habrastorage.org/webt/vr/_f/jc/vr_fjcvwl3zxc6ocy622l2sszrw.png"></p><br><p>  Restauramos el equilibrio por simple (si T <sub>1 es</sub> menor que T <sub>2</sub> ) o por doble rotaci√≥n (de lo contrario), como se hizo durante la inserci√≥n.  La altura del sub√°rbol disminuye, es decir  Una violaci√≥n puede ocurrir sobre el √°rbol. </p><br><p><img src="https://habrastorage.org/webt/h9/5f/qx/h95fqxdbbqukr_eyjbhbjyyoju4.png"></p><br><p>  <strong>Caso 4</strong> <br>  M√≥dulo de desequilibrio 2, el nodo hermano tiene un desequilibrio cero. </p><br><p><img src="https://habrastorage.org/webt/o6/rl/mq/o6rlmq62rxnxxyh6knsz3xne4te.png"></p><br><p>  Una simple rotaci√≥n restaura la condici√≥n de equilibrio, mientras que la altura del sub√°rbol no cambia; dejamos de subir. </p><br><p><img src="https://habrastorage.org/webt/sw/c-/d5/swc-d56rswsunltv7_3g60tvufq.png"></p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de eliminaci√≥n de clave</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::AVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::AVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::AVLNode) node = start skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) &amp;&amp; (abs(skew) != <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">2</span></span> dir = -skew √∑ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew = imbalance(n) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(prev_skew) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_skew == dir node = double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node = rotate!(n, dir) prev_skew != <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.height -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="vzlyot-i-padenie-avl-derevev">  Ascenso y ca√≠da de √°rboles AVL </h3><br><p>  Una caracter√≠stica no muy agradable de los √°rboles AVL cl√°sicos es la dificultad de eliminar un registro:  una rotaci√≥n puede "restablecer" todo el sub√°rbol un nivel hacia abajo, luego, en el peor de los casos, la eliminaci√≥n requiere rotaciones de √°rbol <em>O</em> (log <sub>2</sub> <em>N</em> ), ¬°cada vez que sube un nivel en <code>fix_deletion!()</code> . </p><br><p>  Debido a este comportamiento asint√≥tico no tan bueno, los √°rboles AVL dieron paso a los √°rboles rojo-negros que aparecieron en la d√©cada de 1970 y tienen una condici√≥n de equilibrio m√°s d√©bil: el camino desde la ra√≠z hasta la hoja m√°s alejada no es m√°s del doble del camino desde la ra√≠z hasta la hoja m√°s cercana.  Debido a esto, la altura de los √°rboles rojo-negros es, en el peor de los casos, 2log <sub>2</sub> <em>N</em> versus 1.44log <sub>2</sub> <em>N</em> para √°rboles AVL, pero eliminar un registro no requiere m√°s de tres rotaciones simples.  Por lo tanto, la b√∫squeda y la inserci√≥n debido a una mayor altura de √°rbol potencialmente pierden rendimiento, pero existe una ganancia potencial si las inserciones a menudo se intercalan con eliminaciones. </p><br><h3 id="avl-nanosyat-otvetnyy-udar">  AVL contraataca </h3><br><p>  Resulta que el algoritmo "ideal" para construir √°rboles de b√∫squeda binarios debe garantizar una altura peque√±a (al nivel del √°rbol AVL cl√°sico) y un n√∫mero constante de vueltas tanto al agregar o eliminar un registro.  Esto a√∫n no se ha inventado, pero en 2015 se public√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo</a> que propon√≠a una estructura que mejora las propiedades de los √°rboles AVL y rojo-negro.  La idea se encuentra m√°s cerca de los √°rboles AVL, pero la condici√≥n de equilibrio se relaja para permitir una eliminaci√≥n m√°s eficiente de los registros.  Las propiedades de una estructura llamada ‚Äú√°rbol AVL d√©bil‚Äù (√°rbol AVL W (eak)) se formulan de la siguiente manera: </p><br><ol><li>  Orden: para cualquier nodo, la clave en la parte superior del sub√°rbol izquierdo es m√°s grande que en la parte superior del sub√°rbol derecho que la clave del nodo en s√≠ (si los descendientes no son nodos vac√≠os). </li><li>  Rango ascendente.  A cada nodo se le asigna un rango.  El rango de todos los nodos vac√≠os es cero, el rango de las hojas es 1. El rango del nodo padre es estrictamente mayor que el rango del hijo. </li><li>  Equilibrio ABL d√©bil: el rango de un nodo difiere del rango de los nodos secundarios en no m√°s de 2. </li></ol><br><p>  Resulta que dicha estructura incluye las propiedades de los √°rboles AVL cl√°sicos y los √°rboles rojo-negros.  En particular, si introducimos la condici√≥n de que <em>ambos</em> nodos hijos no pueden diferir del padre en rango en 2, obtenemos un √°rbol AVL regular, y el rango coincidir√° exactamente con la altura del sub√°rbol. </p><br><p>  ¬°La belleza de los √°rboles SAVL es que un ligero debilitamiento de la condici√≥n AVL permite que el √°rbol se equilibre al eliminar un registro en no m√°s de dos turnos!  La estimaci√≥n de la altura del √°rbol es h &lt;min (1.44log <sub>2</sub> <em>M</em> , 2log <sub>2</sub> <em>N</em> ), donde <em>N</em> es el n√∫mero de entradas en el √°rbol, <em>M</em> es el n√∫mero de insertos, en comparaci√≥n con h &lt;2log <sub>2</sub> <em>N</em> para √°rboles rojo-negros.  ,  -   ,       ,      . </p><br><p>  -             ,          .  -        . </p><br><h4 id="struktura-hraneniya">  . </h4><br><p>     -,  ""    "".  ,   : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> WAVLNode rank::<span class="hljs-built_in"><span class="hljs-built_in">UInt8</span></span> key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} parent::WAVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function WAVLNode{K,V}() where {K,V} node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing return node end #    - function WAVLNode{K,V}(key, value) where {K,V} key, value = convert(K, key), convert(V, value) node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end struct WAVLTree{K, V} entry::WAVLNode{K,V} WAVLTree{K,V}() where {K,V} = new{K,V}(WAVLNode{K,V}()) end function child(root::WAVLNode, side::Signed) if side == -1 root.left elseif side == 1 root.right else throw(ArgumentError("Expecting side=-1 to get the left child or side=1 to get the right child")) end end function Base.getindex(avlt::WAVLTree{K,V}, key) where {K,V} key = convert(K, key) node = avlt.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><h4 id="vstavka-zapisi-1">   </h4><br><p>    ,     -.  :      1    ,      ‚Äî      ,          0 (  )  1 (    ).      <code>imbalance()</code> ,     ,  . </p><br><pre> <code class="julia hljs">wavlrank(node::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,WAVLNode}) = node == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(node.rank) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> imbalance(node::WAVLNode) rr, lr = wavlrank(node.right), wavlrank(node.left) skew = rr - lr diff = node.rank - max(rr, lr) skew, diff <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>    ,           .  ,  ,    ,    ,    -,   - . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end # pivot       function double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 dir = -skew √∑ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end function Base.setindex!(avlt::AVLTree{K,V}, val, key) where {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left #   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> </div></div><br><h4 id="udalenie-zapisi-1">   </h4><br><p>    ,     ‚Äî    -.        . </p><br><p> <strong> 0</strong> <br>       , ..: </p><br><ol><li>  1,     1   </li><li>  0,    2  ,     . <br>    . </li></ol><br><p> <strong> 1</strong> <br>     2 ( 0,   2   ). <br>    1   . </p><br><p> <strong> 2</strong> <br>  1,     2. </p><br><p><img src="https://habrastorage.org/webt/q0/gq/3h/q0gq3hi6g7k8modechdmavys-to.png"></p><br><p>      1,  . </p><br><p><img src="https://habrastorage.org/webt/28/ss/oc/28ssoc1ki3flzroiinnigcsguhg.png"></p><br><p> <strong> 3</strong> <br>  2 (     1, ..          ),         2  . </p><br><p><img src="https://habrastorage.org/webt/oi/tl/qd/oitlqdhhc83lttdsw6s0az_kr5y.png"></p><br><p>       ,    .  . </p><br><p><img src="https://habrastorage.org/webt/st/pn/se/stpnsenr-ygtamabscwra_yd2dy.png"></p><br><p> <strong> 4</strong> <br><img src="https://habrastorage.org/webt/fp/l-/h1/fpl-h1yg-9gl3wrucoiq-lhefwq.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/s3/qy/0u/s3qy0uwfz87t5uroqynp4rvchwi.png"></p><br><p>  ,          ,      , ..      . </p><br><p>   ‚Äî   T <sub>1</sub>  T <sub>2</sub>  ,  <em>p</em>     2,    <em>p</em>     1. </p><br><p> <strong> 5</strong> <br><img src="https://habrastorage.org/webt/5m/pn/sb/5mpnsb8edlrtcazgox852h6rrsm.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/im/vt/7c/imvt7cnylf5_dja5jc6xx9km-xo.png"></p><br><p> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::WAVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::WAVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::WAVLNode) node = start skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> node.rank = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> diff == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dir = -skew √∑ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew, prev_diff = imbalance(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_diff == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> prev_skew == <span class="hljs-number"><span class="hljs-number">0</span></span> n.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> prev_skew == dir double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rotate!(n, dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>      -. </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wavl = WAVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avl = AVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dd = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; x = trues(<span class="hljs-number"><span class="hljs-number">1_000_000</span></span>) <span class="hljs-comment"><span class="hljs-comment">#       ~  julia&gt; for i = 1:1_000_000; dd[i] = avl[i] = wavl[i] = i * i; end julia&gt; for i=1:500_000 k = rand(1:1_000_000) x[k] = false delete!(avl, k) delete!(wavl, k) delete!(dd, k) end # ,     julia&gt; const y = Int[] julia&gt; for i in eachindex(x); if x[i] push!(y, i); end; end julia&gt; @btime let s = 0.0; for idx in y; s += dd[idx]; end; s; end 57.626 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += wavl[idx]; end; s; end 57.796 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += avl[idx]; end; s; end 53.884 ms (0 allocations: 0 bytes) 2.0238199367708794e17</span></span></code> </pre> <br><p> ,        ,    . , ,   -    ,   -,    . </p><br><h3 id="primenenie-derevev-poiska">    </h3><br><p>    ‚Äî   ? <br>   ‚Äî   ,   . ,   ,  . </p><br><p>           . </p><br><h4 id="uporyadochennoe-mnozhestvo">   </h4><br><p>    ‚Äî   ,           .      <em>n</em> -   . ,     , ..  ,       . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th>   </th></tr></thead><tbody><tr><td>    </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td> <em>n</em> -  </td><td> <em>O</em> (log <em>N</em> )* </td><td> <em>O</em> (1) </td></tr></tbody></table></div><br><p> *         </p><br><h4 id="associativnyy-massiv">   </h4><br><p>   ‚Äî   ,      "   ", "    ", "  -", " ".    ,      ,        -.      .   ,          . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th> - </th><th>  </th><th>   </th></tr></thead><tbody><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> )** </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>    </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr></tbody></table></div><br><p> *    <br> **     <em>O</em> (1),     ... </p><br><h4 id="ochered-s-prioritetami">    </h4><br><p>    ,       " ‚Äî ".      ,    .   ‚Äî     ( ) ,       ,  ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>   </th><th>   </th><th>  </th><th>  / </th></tr></thead><tbody><tr><td>   </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1)** </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr></tbody></table></div><br><p> *        <br> **  ,       </p><br><h3 id="vyvod">  Conclusi√≥n </h3><br><p> ()    ‚Äî       ,   , ,   , ,    .      ‚Äî     , ..  ,         ,   . </p><br><h2 id="ssylki">  Referencias </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"-"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">nickme</a> </li><li> Rank-Balanced Trees by Bernhard Haeupler, Siddhartha Sen, Robert E. Tarjan // ACM Transactions on Algorithms | June 2015, Vol 11(4) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pdf</a> </li><li> Goodrich MT, Tamassia R. Algorithm Design and Applications </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455172/">https://habr.com/ru/post/455172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455160/index.html">Entity Framework 6 con b√∫squeda de texto completo a trav√©s de LINQ</a></li>
<li><a href="../455164/index.html">Elena Balashova: "Los activistas plantearon la pregunta de que los datos de nuestro portal SIG deber√≠an estar abiertos a OpenStreetMap"</a></li>
<li><a href="../455166/index.html">VPN en el enrutador Beeline para evitar bloqueos</a></li>
<li><a href="../455168/index.html">Demostraci√≥n de 492 bytes en ATtiny5</a></li>
<li><a href="../455170/index.html">Nueva arquitectura para el acceso de bytes a SSD: c√≥mo funciona</a></li>
<li><a href="../455176/index.html">¬øEs posible sin Redux?</a></li>
<li><a href="../455178/index.html">Atr√°pame si puedes. Versi√≥n Director</a></li>
<li><a href="../455184/index.html">Impresora 3D de $ 250 de tama√±o de habitaci√≥n</a></li>
<li><a href="../455190/index.html">Impresi√≥n 3D de c√©lulas del m√∫sculo card√≠aco.</a></li>
<li><a href="../455194/index.html">Amazon lanza entrega de drones. Como va a funcionar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>