<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏾 🚶🏿 ✊🏾 Sperren in PostgreSQL: 4. Sperren im Speicher 👂🏼 🕞 🎅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich möchte Sie daran erinnern, dass wir bereits über Beziehungssperren, Sperren auf Zeilenebene , über Sperren anderer Objekte (einschließlich Prädika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sperren in PostgreSQL: 4. Sperren im Speicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/466199/">  Ich möchte Sie daran erinnern, dass wir bereits über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beziehungssperren,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren auf Zeilenebene</a> , über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren anderer Objekte</a> (einschließlich Prädikatsperren) und über die Beziehung zwischen verschiedenen Arten von Sperren gesprochen haben. <br><br>  Heute beende ich diese Serie mit einem Artikel über <strong>Speichersperren</strong> .  Wir werden über Spinlocks, leichte Schlösser und Puffersperren sowie Tools zur Überwachung der Erwartungen und zur Probenahme sprechen. <br><br><img src="https://habrastorage.org/webt/2y/vt/2g/2yvt2gpimbdqmnibpzaiuf8qu0q.png"><br><a name="habracut"></a><br><h1>  Drehverschluss </h1><br>  Im Gegensatz zu normalen „schweren“ Sperren werden leichtere und billigere (in Bezug auf Overhead) Sperren verwendet, um Strukturen im gemeinsam genutzten RAM zu schützen. <br><br>  Die einfachsten davon sind <em>Spin-Locks</em> oder <em>Spinlocks</em> .  Sie sind so konzipiert, dass sie für eine sehr kurze Zeit (mehrere Prozessoranweisungen) erfassen und einzelne Speicherbereiche vor gleichzeitigen Änderungen schützen. <br><br>  Spin-Locks werden basierend auf atomaren Anweisungen des Prozessors implementiert, z. B. Compare-and-Swap.  Sie unterstützen einen einzelnen exklusiven Modus.  Wenn die Sperre besetzt ist, führt der Wartevorgang eine aktive Wartezeit durch - der Befehl wird wiederholt („dreht sich“ in der Schleife, daher der Name), bis er erfolgreich ausgeführt wird.  Dies ist sinnvoll, da Spin-Locks verwendet werden, wenn die Konfliktwahrscheinlichkeit als sehr gering eingeschätzt wird. <br><br>  Spin Locks bieten keine Erkennung von Deadlocks (PostgreSQL-Entwickler überwachen dies) und bieten keine Überwachungstools.  Im Großen und Ganzen können wir mit Spin Locks nur wissen, ob sie existieren. <br><br><h1>  Lichtschlösser </h1><br>  Als nächstes kommen die sogenannten <em>leichten Schlösser</em> (leichte Schlösser, Schlösser). <br><br>  Sie werden für die kurze Zeit erfasst, die für die Arbeit mit der Datenstruktur erforderlich ist (z. B. eine Hash-Tabelle oder eine Liste von Zeigern).  In der Regel wird eine Lichtverriegelung nicht lange gehalten, aber in einigen Fällen schützt eine Lichtverriegelung die E / A-Vorgänge, sodass sich die Zeit im Prinzip als erheblich herausstellen kann. <br><br>  Es werden zwei Modi unterstützt: exklusiv (zum Ändern von Daten) und gemeinsam genutzt (schreibgeschützt).  Daher gibt es keine Warteschlange: Wenn mehrere Prozesse darauf warten, dass die Sperre aufgehoben wird, erhält einer von ihnen mehr oder weniger zufällig Zugriff.  In Systemen mit einem hohen Grad an Parallelität und hoher Last kann dies zu unangenehmen Effekten führen (siehe z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion</a> ). <br><br>  Ein Mechanismus zum Überprüfen von Deadlocks ist nicht vorgesehen, dies liegt jedoch im Gewissen der Kernelentwickler.  Lichtschlösser verfügen jedoch über Überwachungswerkzeuge, daher können sie im Gegensatz zu Drehschlössern "gesehen" werden (etwas später werde ich zeigen, wie). <br><br><h1>  Clip-Puffer </h1><br>  Eine andere Art von Sperre, die wir bereits im Artikel über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puffercache</a> besprochen haben, ist das <em>Puffer-Pinning</em> . <br><br>  Mit einem festen Puffer können Sie verschiedene Aktionen ausführen, einschließlich des Änderns von Daten, jedoch unter der Bedingung, dass diese Änderungen aufgrund der Mehrfachversionierung für andere Prozesse nicht sichtbar sind.  Das heißt, Sie können der Seite eine neue Zeile hinzufügen, aber Sie können die Seite im Puffer nicht durch eine andere ersetzen. <br><br>  Wenn der Prozess durch die Bindung behindert wird, überspringt er normalerweise nur einen solchen Puffer und wählt einen anderen aus.  In einigen Fällen, in denen dieser bestimmte Puffer benötigt wird, wird der Prozess in die Warteschlange gestellt und schläft ein. Das System aktiviert ihn, wenn die Befestigung entfernt wird. <br><br>  Konsolidierungserwartungen stehen zur Überwachung zur Verfügung. <br><br><h1>  Beispiel: Puffercache </h1><br><img src="https://habrastorage.org/webt/gt/z8/gy/gtz8gylhroqbvj7jmwemqbd4jys.png"><br><br>  Um einen (unvollständigen!) Einblick zu erhalten, wie und wo Sperren verwendet werden, betrachten Sie ein Beispiel für einen Puffercache. <br><br>  Um auf eine Hash-Tabelle zuzugreifen, die Verweise auf Puffer enthält, muss der Prozess im gemeinsam genutzten Modus eine Lichtpuffer-Zuordnungssperre erfassen. Wenn die Tabelle geändert werden muss, dann im Ausnahmemodus.  Um die Granularität zu verringern, ist dieses Schloss als <em>Tranche</em> angeordnet und besteht aus 128 separaten Schlössern, von denen jedes seinen eigenen Teil der Hash-Tabelle schützt. <br><br>  Der Prozess erhält über Spin-Lock Zugriff auf den Header des Puffers.  Einzelne Operationen (wie das Inkrementieren des Zählers) können auch ohne explizite Sperren unter Verwendung atomarer Anweisungen des Prozessors ausgeführt werden. <br><br>  Um den Inhalt eines Puffers zu lesen, ist eine Sperre des Pufferinhalts erforderlich.  Normalerweise wird es nur für die Zeit erfasst, die zum Lesen der Zeiger auf die Version der Zeilen erforderlich ist, und dann ist der durch den Pufferclip bereitgestellte Schutz ausreichend.  Um den Inhalt des Puffers zu ändern, muss diese Sperre im Ausnahmemodus erfasst werden. <br><br>  Beim Lesen eines Puffers von der Festplatte (oder beim Schreiben auf die Festplatte) wird auch die Sperre für laufende E / A erfasst, die anderen Prozessen signalisiert, dass die Seite gelesen (oder geschrieben) wird. Sie können in die Warteschlange gestellt werden, wenn sie auch etwas mit dieser Seite tun müssen. <br><br>  Zeiger auf freie Puffer und auf das nächste Opfer werden durch eine Spin-Sperre mit einer einzelnen Pufferstrategie geschützt. <br><br><h1>  Beispiel: Protokollpuffer </h1><br><img src="https://habrastorage.org/webt/_f/mu/ub/_fmuubhon3hualbtorx4rmjgur4.png"><br>  Ein weiteres Beispiel: Protokollpuffer. <br><br>  Für den Journalcache wird auch eine Hash-Tabelle verwendet, die die Zuordnung von Seiten zu Puffern enthält.  Im Gegensatz zum Puffercache ist diese Hash-Tabelle durch die einzige leichte Sperre von WALBufMappingLock geschützt, da der Journalcache kleiner ist (normalerweise 1/32 des Puffercaches) und der Zugriff auf Puffer effizienter ist. <br><br>  Das Schreiben von Seiten auf die Festplatte ist durch eine einfache WALWriteLock-Sperre geschützt, sodass jeweils nur ein Prozess diesen Vorgang ausführen kann. <br><br>  Um einen Journaleintrag zu erstellen, muss der Prozess zunächst einen Platz auf der WAL-Seite reservieren.  Zu diesem Zweck wird die Positionssperre für den Spin-Lock-Einsatz erfasst.  Nachdem ein Platz reserviert wurde, kopiert der Prozess den Inhalt seines Datensatzes an den angegebenen Ort.  Das Kopieren kann von mehreren Prozessen gleichzeitig durchgeführt werden, für die der Datensatz durch eine Tranche von 8 einfachen Sperren zum Einfügen von Sperren geschützt ist (der Prozess muss <em>eine</em> davon erfassen). <br><br>  Die Abbildung zeigt nicht alle Sperren, die sich auf das Voraufzeichnungsprotokoll beziehen. Dieses und das vorherige Beispiel sollten jedoch einen Eindruck von der Verwendung von Sperren im RAM vermitteln. <br><br><h1>  Erwartungsüberwachung </h1><br>  Ab PostgreSQL 9.6 sind Warteüberwachungstools in die Ansicht pg_stat_activity integriert.  Wenn ein Prozess (System oder Wartung) seine Arbeit nicht ausführen kann und auf etwas wartet, wird diese Erwartung in der Ansicht angezeigt: Die Spalte wait_event_type gibt den Typ der Erwartung an und die Spalte wait_event gibt den Namen einer bestimmten Erwartung an. <br><br>  Beachten Sie, dass in einer Ansicht nur die Erwartungen angezeigt werden, die im Quellcode angemessen behandelt werden.  Wenn die Ansicht die Erwartung nicht anzeigt, bedeutet dies im Allgemeinen nicht mit einer 100-prozentigen Wahrscheinlichkeit, dass der Prozess wirklich nichts erwartet. <br><br>  Leider sind nur <em>aktuelle</em> Informationen zu den Erwartungen verfügbar.  Es werden keine Statistiken geführt.  Die einzige Möglichkeit, sich ein Bild von den Erwartungen im Zeitverlauf zu machen, besteht darin, <em>den</em> Status der Ansicht in einem bestimmten Intervall abzutasten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hierfür</a> gibt es keine integrierten Mittel, aber Sie können Erweiterungen verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_wait_sampling</a> . <br><br>  Es ist notwendig, den probabilistischen Charakter der Probenahme zu berücksichtigen.  Um ein mehr oder weniger zuverlässiges Bild zu erhalten, muss die Anzahl der Messungen groß genug sein.  Das Abtasten mit einer niedrigen Frequenz liefert möglicherweise kein zuverlässiges Bild, und eine Erhöhung der Frequenz führt zu einer Erhöhung des Overheads.  Aus dem gleichen Grund ist die Stichprobe für die Analyse kurzlebiger Sitzungen unbrauchbar. <br><br>  Alle Erwartungen können in verschiedene Typen unterteilt werden. <br><br>  Die Erwartungen an die betrachteten Schlösser bilden eine große Kategorie: <br><br><ul><li>  Warten auf Objektsperren (Sperrwert in der Spalte wait_event_type); </li><li>  Warten auf Lichtschlösser (LWLock); </li><li>  Warten auf einen angehefteten Puffer (BufferPin). </li></ul><br>  Prozesse können jedoch andere Ereignisse erwarten: <br><br><ul><li>  E / A-Erwartungen (I / O) treten auf, wenn ein Prozess Daten schreiben oder lesen muss. </li><li>  Der Prozess kann auf die für die Arbeit erforderlichen Daten vom Client (Client) oder von einem anderen Prozess (IPC) warten. </li><li>  Erweiterungen können ihre spezifischen Erwartungen registrieren (Erweiterung). </li></ul><br>  Es gibt Situationen, in denen ein Prozess einfach keine nützliche Arbeit leistet.  Diese Kategorie umfasst: <br><br><ul><li>  Warten auf Hintergrundprozesse in der Hauptschleife (Aktivität); </li><li>  Warten auf einen Timer (Timeout). </li></ul><br>  Solche Erwartungen sind in der Regel „normal“ und sprechen nicht von Problemen. <br><br>  Auf die Art der Erwartung folgt der Name der jeweiligen Erwartung.  Die vollständige Tabelle finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> . <br><br>  Wenn kein Warte-Name angegeben wird, befindet sich der Prozess nicht in einem Wartezustand.  Eine solche Zeit sollte als <em>nicht</em> berücksichtigt betrachtet werden, da tatsächlich nicht bekannt ist, was genau in diesem Moment geschieht. <br><br>  Es ist jedoch Zeit zu schauen. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, backend_type, wait_event_type, wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <pre> <code class="plaintext hljs"> pid | backend_type | wait_event_type | wait_event -------+------------------------------+-----------------+--------------------- 28739 | logical replication launcher | Activity | LogicalLauncherMain 28736 | autovacuum launcher | Activity | AutoVacuumMain 28963 | client backend | | 28734 | background writer | Activity | BgWriterMain 28733 | checkpointer | Activity | CheckpointerMain 28735 | walwriter | Activity | WalWriterMain (6 rows)</code> </pre><br>  Es ist zu sehen, dass alle Hintergrund-Service-Prozesse „herumspielen“. Leere Werte in wait_event_type und wait_event zeigen an, dass der Prozess nichts erwartet - in unserem Fall ist der Serving-Prozess damit beschäftigt, die Anforderung auszuführen. <br><br><h2>  Probenahme </h2><br>  Um mithilfe von Sampling ein mehr oder weniger vollständiges Bild der Erwartungen zu erhalten, verwenden wir die Erweiterung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_wait_sampling</a> .  Es muss aus dem Quellcode kompiliert werden.  Ich werde diesen Teil weglassen.  Dann registrieren wir die Bibliothek im Parameter <em>shared_preload_libraries</em> und starten den Server neu. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_wait_sampling'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Installieren Sie nun die Erweiterung in der Datenbank. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_wait_sampling;</code> </pre><br>  Mit der Erweiterung können Sie den Erwartungsverlauf anzeigen, der in einem Ringpuffer gespeichert ist.  Am interessantesten ist es jedoch, das Profil der Erwartungen zu sehen - die gesammelten Statistiken für die gesamte Arbeitszeit. <br><br>  Folgendes werden wir in wenigen Sekunden sehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile;</code> </pre><pre> <code class="plaintext hljs"> pid | event_type | event | queryid | count -------+------------+---------------------+---------+------- 29074 | Activity | LogicalLauncherMain | 0 | 220 29070 | Activity | WalWriterMain | 0 | 220 29071 | Activity | AutoVacuumMain | 0 | 219 29069 | Activity | BgWriterMain | 0 | 220 29111 | Client | ClientRead | 0 | 3 29068 | Activity | CheckpointerMain | 0 | 220 (6 rows)</code> </pre><br>  Da seit dem Start des Servers nichts passiert ist, sind die Haupterwartungen vom Typ Aktivität (Serviceprozesse warten, bis die Arbeit angezeigt wird) und vom Client (psql wartet darauf, dass der Benutzer eine Anfrage sendet). <br><br>  Mit den Standardeinstellungen (Parameter <em>pg_wait_sampling.profile_period</em> ) beträgt die Abtastperiode 10 Millisekunden, <em>dh</em> die Werte werden 100 Mal pro Sekunde gespeichert.  Um die Wartezeit in Sekunden abzuschätzen, muss der Zählwert daher durch 100 geteilt werden. <br><br>  Um zu verstehen, zu welchen Prozesserwartungen gehören, fügen wir der Anforderung die Ansicht pg_stat_activity hinzu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+------------------------------+------+------------+----------------------+------- 29068 | checkpointer | | Activity | CheckpointerMain | 222 29069 | background writer | | Activity | BgWriterMain | 222 29070 | walwriter | | Activity | WalWriterMain | 222 29071 | autovacuum launcher | | Activity | AutoVacuumMain | 221 29074 | logical replication launcher | | Activity | LogicalLauncherMain | 222 29111 | client backend | psql | Client | ClientRead | 4 29111 | client backend | psql | IPC | MessageQueueInternal | 1 (7 rows)</code> </pre><br>  Laden wir mit pgbench und sehen, wie sich das Bild ändert. <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><br>  Wir setzen das gesammelte Profil auf Null zurück und führen den Test 30 Sekunden lang in einem separaten Prozess aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br>  Die Anforderung muss abgeschlossen sein, bevor der pgbench-Prozess abgeschlossen ist: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+------------+------- 29148 | client backend | pgbench | IO | WALWrite | 8 29148 | client backend | pgbench | Client | ClientRead | 1 (2 rows)</code> </pre><br>  Natürlich werden sich die Erwartungen an den pgbench-Prozess je nach System geringfügig unterscheiden.  In unserem Fall ist es sehr wahrscheinlich, dass das Warten auf einen Protokolleintrag (IO / WALWrite) angezeigt wird, aber die meiste Zeit wurde der Prozess nicht gestoppt, sondern es wurde vermutlich etwas Nützliches getan. <br><br><h2>  Lichtschlösser </h2><br>  Sie sollten immer daran denken, dass das Fehlen jeglicher Erwartung bei der Probenahme nicht bedeutet, dass keine Erwartung bestand.  Wenn es kürzer als die Abtastperiode war (in unserem Beispiel die Hundertstelsekunde), konnte es einfach nicht in die Probe fallen. <br><br>  Daher wurden im Profil keine leichten Sperren angezeigt. Sie werden jedoch angezeigt, wenn Sie Daten über einen längeren Zeitraum erfassen.  Um einen Blick darauf zu werfen, können Sie das Dateisystem künstlich verlangsamen. Verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> beispielsweise das Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">slowfs</a> , das auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FUSE-</a> Dateisystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basiert</a> . <br><br>  Dies können wir im selben Test sehen, wenn eine E / A-Operation 1/10 Sekunde dauert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+----------------+------- 29240 | client backend | pgbench | IO | WALWrite | 1445 29240 | client backend | pgbench | LWLock | WALWriteLock | 803 29240 | client backend | pgbench | IO | DataFileExtend | 20 (3 rows)</code> </pre><br>  Die Haupterwartung des pgbench-Prozesses bezieht sich nun auf E / A bzw. einen Protokolleintrag, der bei jedem Commit im synchronen Modus ausgeführt wird.  Da (wie im obigen Beispiel gezeigt) das Schreiben eines Protokolls auf die Festplatte durch die WALWriteLock-Lichtsperre geschützt ist, ist diese Sperre auch im Profil vorhanden - wir wollten sie uns ansehen. <br><br><h2>  Clip-Puffer </h2><br>  Um das Fixieren des Puffers zu sehen, nutzen wir die Tatsache, dass offene Cursor den Pin halten, so dass das Lesen der nächsten Zeile schneller ist. <br><br>  Wir starten die Transaktion, öffnen den Cursor und wählen eine Zeile aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgbench_history; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> tid | bid | aid | delta | mtime | filler -----+-----+-------+-------+----------------------------+-------- 9 | 1 | 35092 | 477 | 2019-09-04 16:16:18.596564 | (1 row)</code> </pre><br>  Überprüfen Sie, ob der Puffer fixiert ist (pinning_backends): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relforknumber = <span class="hljs-number"><span class="hljs-number">0</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------ bufferid | 190 relfilenode | 47050 reltablespace | 1663 reldatabase | 16386 relforknumber | 0 relblocknumber | 0 isdirty | t usagecount | 1 pinning_backends | 1 &lt;--   1 </code> </pre><br>  Jetzt werden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Tisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abräumen</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 29367 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><pre> <code class="plaintext hljs">| INFO: vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 0 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 1 page due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. | VACUUM</code> </pre><br>  Wie wir sehen können, wurde die Seite übersprungen (1 Seite wegen Pufferstiften übersprungen).  In der Tat kann die Bereinigung nicht damit umgehen, da es verboten ist, Zeilenversionen physisch von einer Seite in einem angehefteten Puffer zu löschen.  Die Reinigung wartet jedoch nicht - die Seite wird beim nächsten Mal verarbeitet. <br><br>  Und jetzt werden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reinigung mit Gefrieren durchführen</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><br>  Mit einem eindeutig angeforderten Einfrieren können Sie keine einzelne Seite überspringen, die nicht in der Einfrierkarte markiert ist. Andernfalls kann das maximale Alter nicht eingefrorener Transaktionen in pg_class.relfrozenxid nicht verringert werden.  Daher bleibt die Bereinigung hängen, bis sich der Cursor schließt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 27 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre><br><pre> <code class="plaintext hljs">| INFO: aggressively vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 26 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 0 pages due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 3.01 s. | VACUUM</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 0 (1 row)</code> </pre><br>  Schauen wir uns das Erwartungsprofil der zweiten psql-Sitzung an, in der die VACUUM-Befehle ausgeführt wurden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.pid = <span class="hljs-number"><span class="hljs-number">29367</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+------+------------+------------+------- 29367 | client backend | psql | BufferPin | BufferPin | 294 29367 | client backend | psql | Client | ClientRead | 10 (2 rows)</code> </pre><br>  Der Wartetyp BufferPin gibt an, dass der Flush darauf gewartet hat, dass der Puffer freigegeben wird. <br><br>  Hierbei gehen wir davon aus, dass wir die Sperren abgeschlossen haben.  Vielen Dank für Ihre Aufmerksamkeit und Kommentare! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466199/">https://habr.com/ru/post/de466199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466187/index.html">Visual Logic Editor für Unity3d. Teil 2</a></li>
<li><a href="../de466191/index.html">Die Hauptsache im Kampf um die Netzneutralität in den USA ist die Chronologie der Ereignisse und der aktuelle Stand der Dinge</a></li>
<li><a href="../de466193/index.html">Benutzerdefinierter MailChimp-Auto-Feed aus RSS-Feed</a></li>
<li><a href="../de466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../de466197/index.html">PVS-Studio 7.04</a></li>
<li><a href="../de466201/index.html">Wie man die Wissenschaft in der IT verlässt und Tester wird: die Geschichte einer Karriere</a></li>
<li><a href="../de466203/index.html">Techdir-Tag in St. Petersburg. Bier, Pizza, zwei Mikrofone</a></li>
<li><a href="../de466211/index.html">Projekt Mainline in Android 10</a></li>
<li><a href="../de466213/index.html">4 Schritte zum Erstellen eines Kandidatenprofils</a></li>
<li><a href="../de466215/index.html">Modellorientiertes Design. Erstellung eines zuverlässigen Modells am Beispiel eines Luftfahrtwärmetauschers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>