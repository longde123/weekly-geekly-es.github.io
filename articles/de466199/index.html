<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèæ üö∂üèø ‚úäüèæ Sperren in PostgreSQL: 4. Sperren im Speicher üëÇüèº üïû üéÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich m√∂chte Sie daran erinnern, dass wir bereits √ºber Beziehungssperren, Sperren auf Zeilenebene , √ºber Sperren anderer Objekte (einschlie√ülich Pr√§dika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sperren in PostgreSQL: 4. Sperren im Speicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/466199/">  Ich m√∂chte Sie daran erinnern, dass wir bereits √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beziehungssperren,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren auf Zeilenebene</a> , √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren anderer Objekte</a> (einschlie√ülich Pr√§dikatsperren) und √ºber die Beziehung zwischen verschiedenen Arten von Sperren gesprochen haben. <br><br>  Heute beende ich diese Serie mit einem Artikel √ºber <strong>Speichersperren</strong> .  Wir werden √ºber Spinlocks, leichte Schl√∂sser und Puffersperren sowie Tools zur √úberwachung der Erwartungen und zur Probenahme sprechen. <br><br><img src="https://habrastorage.org/webt/2y/vt/2g/2yvt2gpimbdqmnibpzaiuf8qu0q.png"><br><a name="habracut"></a><br><h1>  Drehverschluss </h1><br>  Im Gegensatz zu normalen ‚Äûschweren‚Äú Sperren werden leichtere und billigere (in Bezug auf Overhead) Sperren verwendet, um Strukturen im gemeinsam genutzten RAM zu sch√ºtzen. <br><br>  Die einfachsten davon sind <em>Spin-Locks</em> oder <em>Spinlocks</em> .  Sie sind so konzipiert, dass sie f√ºr eine sehr kurze Zeit (mehrere Prozessoranweisungen) erfassen und einzelne Speicherbereiche vor gleichzeitigen √Ñnderungen sch√ºtzen. <br><br>  Spin-Locks werden basierend auf atomaren Anweisungen des Prozessors implementiert, z. B. Compare-and-Swap.  Sie unterst√ºtzen einen einzelnen exklusiven Modus.  Wenn die Sperre besetzt ist, f√ºhrt der Wartevorgang eine aktive Wartezeit durch - der Befehl wird wiederholt (‚Äûdreht sich‚Äú in der Schleife, daher der Name), bis er erfolgreich ausgef√ºhrt wird.  Dies ist sinnvoll, da Spin-Locks verwendet werden, wenn die Konfliktwahrscheinlichkeit als sehr gering eingesch√§tzt wird. <br><br>  Spin Locks bieten keine Erkennung von Deadlocks (PostgreSQL-Entwickler √ºberwachen dies) und bieten keine √úberwachungstools.  Im Gro√üen und Ganzen k√∂nnen wir mit Spin Locks nur wissen, ob sie existieren. <br><br><h1>  Lichtschl√∂sser </h1><br>  Als n√§chstes kommen die sogenannten <em>leichten Schl√∂sser</em> (leichte Schl√∂sser, Schl√∂sser). <br><br>  Sie werden f√ºr die kurze Zeit erfasst, die f√ºr die Arbeit mit der Datenstruktur erforderlich ist (z. B. eine Hash-Tabelle oder eine Liste von Zeigern).  In der Regel wird eine Lichtverriegelung nicht lange gehalten, aber in einigen F√§llen sch√ºtzt eine Lichtverriegelung die E / A-Vorg√§nge, sodass sich die Zeit im Prinzip als erheblich herausstellen kann. <br><br>  Es werden zwei Modi unterst√ºtzt: exklusiv (zum √Ñndern von Daten) und gemeinsam genutzt (schreibgesch√ºtzt).  Daher gibt es keine Warteschlange: Wenn mehrere Prozesse darauf warten, dass die Sperre aufgehoben wird, erh√§lt einer von ihnen mehr oder weniger zuf√§llig Zugriff.  In Systemen mit einem hohen Grad an Parallelit√§t und hoher Last kann dies zu unangenehmen Effekten f√ºhren (siehe z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion</a> ). <br><br>  Ein Mechanismus zum √úberpr√ºfen von Deadlocks ist nicht vorgesehen, dies liegt jedoch im Gewissen der Kernelentwickler.  Lichtschl√∂sser verf√ºgen jedoch √ºber √úberwachungswerkzeuge, daher k√∂nnen sie im Gegensatz zu Drehschl√∂ssern "gesehen" werden (etwas sp√§ter werde ich zeigen, wie). <br><br><h1>  Clip-Puffer </h1><br>  Eine andere Art von Sperre, die wir bereits im Artikel √ºber den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puffercache</a> besprochen haben, ist das <em>Puffer-Pinning</em> . <br><br>  Mit einem festen Puffer k√∂nnen Sie verschiedene Aktionen ausf√ºhren, einschlie√ülich des √Ñnderns von Daten, jedoch unter der Bedingung, dass diese √Ñnderungen aufgrund der Mehrfachversionierung f√ºr andere Prozesse nicht sichtbar sind.  Das hei√üt, Sie k√∂nnen der Seite eine neue Zeile hinzuf√ºgen, aber Sie k√∂nnen die Seite im Puffer nicht durch eine andere ersetzen. <br><br>  Wenn der Prozess durch die Bindung behindert wird, √ºberspringt er normalerweise nur einen solchen Puffer und w√§hlt einen anderen aus.  In einigen F√§llen, in denen dieser bestimmte Puffer ben√∂tigt wird, wird der Prozess in die Warteschlange gestellt und schl√§ft ein. Das System aktiviert ihn, wenn die Befestigung entfernt wird. <br><br>  Konsolidierungserwartungen stehen zur √úberwachung zur Verf√ºgung. <br><br><h1>  Beispiel: Puffercache </h1><br><img src="https://habrastorage.org/webt/gt/z8/gy/gtz8gylhroqbvj7jmwemqbd4jys.png"><br><br>  Um einen (unvollst√§ndigen!) Einblick zu erhalten, wie und wo Sperren verwendet werden, betrachten Sie ein Beispiel f√ºr einen Puffercache. <br><br>  Um auf eine Hash-Tabelle zuzugreifen, die Verweise auf Puffer enth√§lt, muss der Prozess im gemeinsam genutzten Modus eine Lichtpuffer-Zuordnungssperre erfassen. Wenn die Tabelle ge√§ndert werden muss, dann im Ausnahmemodus.  Um die Granularit√§t zu verringern, ist dieses Schloss als <em>Tranche</em> angeordnet und besteht aus 128 separaten Schl√∂ssern, von denen jedes seinen eigenen Teil der Hash-Tabelle sch√ºtzt. <br><br>  Der Prozess erh√§lt √ºber Spin-Lock Zugriff auf den Header des Puffers.  Einzelne Operationen (wie das Inkrementieren des Z√§hlers) k√∂nnen auch ohne explizite Sperren unter Verwendung atomarer Anweisungen des Prozessors ausgef√ºhrt werden. <br><br>  Um den Inhalt eines Puffers zu lesen, ist eine Sperre des Pufferinhalts erforderlich.  Normalerweise wird es nur f√ºr die Zeit erfasst, die zum Lesen der Zeiger auf die Version der Zeilen erforderlich ist, und dann ist der durch den Pufferclip bereitgestellte Schutz ausreichend.  Um den Inhalt des Puffers zu √§ndern, muss diese Sperre im Ausnahmemodus erfasst werden. <br><br>  Beim Lesen eines Puffers von der Festplatte (oder beim Schreiben auf die Festplatte) wird auch die Sperre f√ºr laufende E / A erfasst, die anderen Prozessen signalisiert, dass die Seite gelesen (oder geschrieben) wird. Sie k√∂nnen in die Warteschlange gestellt werden, wenn sie auch etwas mit dieser Seite tun m√ºssen. <br><br>  Zeiger auf freie Puffer und auf das n√§chste Opfer werden durch eine Spin-Sperre mit einer einzelnen Pufferstrategie gesch√ºtzt. <br><br><h1>  Beispiel: Protokollpuffer </h1><br><img src="https://habrastorage.org/webt/_f/mu/ub/_fmuubhon3hualbtorx4rmjgur4.png"><br>  Ein weiteres Beispiel: Protokollpuffer. <br><br>  F√ºr den Journalcache wird auch eine Hash-Tabelle verwendet, die die Zuordnung von Seiten zu Puffern enth√§lt.  Im Gegensatz zum Puffercache ist diese Hash-Tabelle durch die einzige leichte Sperre von WALBufMappingLock gesch√ºtzt, da der Journalcache kleiner ist (normalerweise 1/32 des Puffercaches) und der Zugriff auf Puffer effizienter ist. <br><br>  Das Schreiben von Seiten auf die Festplatte ist durch eine einfache WALWriteLock-Sperre gesch√ºtzt, sodass jeweils nur ein Prozess diesen Vorgang ausf√ºhren kann. <br><br>  Um einen Journaleintrag zu erstellen, muss der Prozess zun√§chst einen Platz auf der WAL-Seite reservieren.  Zu diesem Zweck wird die Positionssperre f√ºr den Spin-Lock-Einsatz erfasst.  Nachdem ein Platz reserviert wurde, kopiert der Prozess den Inhalt seines Datensatzes an den angegebenen Ort.  Das Kopieren kann von mehreren Prozessen gleichzeitig durchgef√ºhrt werden, f√ºr die der Datensatz durch eine Tranche von 8 einfachen Sperren zum Einf√ºgen von Sperren gesch√ºtzt ist (der Prozess muss <em>eine</em> davon erfassen). <br><br>  Die Abbildung zeigt nicht alle Sperren, die sich auf das Voraufzeichnungsprotokoll beziehen. Dieses und das vorherige Beispiel sollten jedoch einen Eindruck von der Verwendung von Sperren im RAM vermitteln. <br><br><h1>  Erwartungs√ºberwachung </h1><br>  Ab PostgreSQL 9.6 sind Warte√ºberwachungstools in die Ansicht pg_stat_activity integriert.  Wenn ein Prozess (System oder Wartung) seine Arbeit nicht ausf√ºhren kann und auf etwas wartet, wird diese Erwartung in der Ansicht angezeigt: Die Spalte wait_event_type gibt den Typ der Erwartung an und die Spalte wait_event gibt den Namen einer bestimmten Erwartung an. <br><br>  Beachten Sie, dass in einer Ansicht nur die Erwartungen angezeigt werden, die im Quellcode angemessen behandelt werden.  Wenn die Ansicht die Erwartung nicht anzeigt, bedeutet dies im Allgemeinen nicht mit einer 100-prozentigen Wahrscheinlichkeit, dass der Prozess wirklich nichts erwartet. <br><br>  Leider sind nur <em>aktuelle</em> Informationen zu den Erwartungen verf√ºgbar.  Es werden keine Statistiken gef√ºhrt.  Die einzige M√∂glichkeit, sich ein Bild von den Erwartungen im Zeitverlauf zu machen, besteht darin, <em>den</em> Status der Ansicht in einem bestimmten Intervall abzutasten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hierf√ºr</a> gibt es keine integrierten Mittel, aber Sie k√∂nnen Erweiterungen verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_wait_sampling</a> . <br><br>  Es ist notwendig, den probabilistischen Charakter der Probenahme zu ber√ºcksichtigen.  Um ein mehr oder weniger zuverl√§ssiges Bild zu erhalten, muss die Anzahl der Messungen gro√ü genug sein.  Das Abtasten mit einer niedrigen Frequenz liefert m√∂glicherweise kein zuverl√§ssiges Bild, und eine Erh√∂hung der Frequenz f√ºhrt zu einer Erh√∂hung des Overheads.  Aus dem gleichen Grund ist die Stichprobe f√ºr die Analyse kurzlebiger Sitzungen unbrauchbar. <br><br>  Alle Erwartungen k√∂nnen in verschiedene Typen unterteilt werden. <br><br>  Die Erwartungen an die betrachteten Schl√∂sser bilden eine gro√üe Kategorie: <br><br><ul><li>  Warten auf Objektsperren (Sperrwert in der Spalte wait_event_type); </li><li>  Warten auf Lichtschl√∂sser (LWLock); </li><li>  Warten auf einen angehefteten Puffer (BufferPin). </li></ul><br>  Prozesse k√∂nnen jedoch andere Ereignisse erwarten: <br><br><ul><li>  E / A-Erwartungen (I / O) treten auf, wenn ein Prozess Daten schreiben oder lesen muss. </li><li>  Der Prozess kann auf die f√ºr die Arbeit erforderlichen Daten vom Client (Client) oder von einem anderen Prozess (IPC) warten. </li><li>  Erweiterungen k√∂nnen ihre spezifischen Erwartungen registrieren (Erweiterung). </li></ul><br>  Es gibt Situationen, in denen ein Prozess einfach keine n√ºtzliche Arbeit leistet.  Diese Kategorie umfasst: <br><br><ul><li>  Warten auf Hintergrundprozesse in der Hauptschleife (Aktivit√§t); </li><li>  Warten auf einen Timer (Timeout). </li></ul><br>  Solche Erwartungen sind in der Regel ‚Äûnormal‚Äú und sprechen nicht von Problemen. <br><br>  Auf die Art der Erwartung folgt der Name der jeweiligen Erwartung.  Die vollst√§ndige Tabelle finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> . <br><br>  Wenn kein Warte-Name angegeben wird, befindet sich der Prozess nicht in einem Wartezustand.  Eine solche Zeit sollte als <em>nicht</em> ber√ºcksichtigt betrachtet werden, da tats√§chlich nicht bekannt ist, was genau in diesem Moment geschieht. <br><br>  Es ist jedoch Zeit zu schauen. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, backend_type, wait_event_type, wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <pre> <code class="plaintext hljs"> pid | backend_type | wait_event_type | wait_event -------+------------------------------+-----------------+--------------------- 28739 | logical replication launcher | Activity | LogicalLauncherMain 28736 | autovacuum launcher | Activity | AutoVacuumMain 28963 | client backend | | 28734 | background writer | Activity | BgWriterMain 28733 | checkpointer | Activity | CheckpointerMain 28735 | walwriter | Activity | WalWriterMain (6 rows)</code> </pre><br>  Es ist zu sehen, dass alle Hintergrund-Service-Prozesse ‚Äûherumspielen‚Äú. Leere Werte in wait_event_type und wait_event zeigen an, dass der Prozess nichts erwartet - in unserem Fall ist der Serving-Prozess damit besch√§ftigt, die Anforderung auszuf√ºhren. <br><br><h2>  Probenahme </h2><br>  Um mithilfe von Sampling ein mehr oder weniger vollst√§ndiges Bild der Erwartungen zu erhalten, verwenden wir die Erweiterung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_wait_sampling</a> .  Es muss aus dem Quellcode kompiliert werden.  Ich werde diesen Teil weglassen.  Dann registrieren wir die Bibliothek im Parameter <em>shared_preload_libraries</em> und starten den Server neu. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_wait_sampling'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Installieren Sie nun die Erweiterung in der Datenbank. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_wait_sampling;</code> </pre><br>  Mit der Erweiterung k√∂nnen Sie den Erwartungsverlauf anzeigen, der in einem Ringpuffer gespeichert ist.  Am interessantesten ist es jedoch, das Profil der Erwartungen zu sehen - die gesammelten Statistiken f√ºr die gesamte Arbeitszeit. <br><br>  Folgendes werden wir in wenigen Sekunden sehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile;</code> </pre><pre> <code class="plaintext hljs"> pid | event_type | event | queryid | count -------+------------+---------------------+---------+------- 29074 | Activity | LogicalLauncherMain | 0 | 220 29070 | Activity | WalWriterMain | 0 | 220 29071 | Activity | AutoVacuumMain | 0 | 219 29069 | Activity | BgWriterMain | 0 | 220 29111 | Client | ClientRead | 0 | 3 29068 | Activity | CheckpointerMain | 0 | 220 (6 rows)</code> </pre><br>  Da seit dem Start des Servers nichts passiert ist, sind die Haupterwartungen vom Typ Aktivit√§t (Serviceprozesse warten, bis die Arbeit angezeigt wird) und vom Client (psql wartet darauf, dass der Benutzer eine Anfrage sendet). <br><br>  Mit den Standardeinstellungen (Parameter <em>pg_wait_sampling.profile_period</em> ) betr√§gt die Abtastperiode 10 Millisekunden, <em>dh</em> die Werte werden 100 Mal pro Sekunde gespeichert.  Um die Wartezeit in Sekunden abzusch√§tzen, muss der Z√§hlwert daher durch 100 geteilt werden. <br><br>  Um zu verstehen, zu welchen Prozesserwartungen geh√∂ren, f√ºgen wir der Anforderung die Ansicht pg_stat_activity hinzu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+------------------------------+------+------------+----------------------+------- 29068 | checkpointer | | Activity | CheckpointerMain | 222 29069 | background writer | | Activity | BgWriterMain | 222 29070 | walwriter | | Activity | WalWriterMain | 222 29071 | autovacuum launcher | | Activity | AutoVacuumMain | 221 29074 | logical replication launcher | | Activity | LogicalLauncherMain | 222 29111 | client backend | psql | Client | ClientRead | 4 29111 | client backend | psql | IPC | MessageQueueInternal | 1 (7 rows)</code> </pre><br>  Laden wir mit pgbench und sehen, wie sich das Bild √§ndert. <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><br>  Wir setzen das gesammelte Profil auf Null zur√ºck und f√ºhren den Test 30 Sekunden lang in einem separaten Prozess aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br>  Die Anforderung muss abgeschlossen sein, bevor der pgbench-Prozess abgeschlossen ist: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+------------+------- 29148 | client backend | pgbench | IO | WALWrite | 8 29148 | client backend | pgbench | Client | ClientRead | 1 (2 rows)</code> </pre><br>  Nat√ºrlich werden sich die Erwartungen an den pgbench-Prozess je nach System geringf√ºgig unterscheiden.  In unserem Fall ist es sehr wahrscheinlich, dass das Warten auf einen Protokolleintrag (IO / WALWrite) angezeigt wird, aber die meiste Zeit wurde der Prozess nicht gestoppt, sondern es wurde vermutlich etwas N√ºtzliches getan. <br><br><h2>  Lichtschl√∂sser </h2><br>  Sie sollten immer daran denken, dass das Fehlen jeglicher Erwartung bei der Probenahme nicht bedeutet, dass keine Erwartung bestand.  Wenn es k√ºrzer als die Abtastperiode war (in unserem Beispiel die Hundertstelsekunde), konnte es einfach nicht in die Probe fallen. <br><br>  Daher wurden im Profil keine leichten Sperren angezeigt. Sie werden jedoch angezeigt, wenn Sie Daten √ºber einen l√§ngeren Zeitraum erfassen.  Um einen Blick darauf zu werfen, k√∂nnen Sie das Dateisystem k√ºnstlich verlangsamen. Verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> beispielsweise das Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">slowfs</a> , das auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FUSE-</a> Dateisystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basiert</a> . <br><br>  Dies k√∂nnen wir im selben Test sehen, wenn eine E / A-Operation 1/10 Sekunde dauert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+----------------+------- 29240 | client backend | pgbench | IO | WALWrite | 1445 29240 | client backend | pgbench | LWLock | WALWriteLock | 803 29240 | client backend | pgbench | IO | DataFileExtend | 20 (3 rows)</code> </pre><br>  Die Haupterwartung des pgbench-Prozesses bezieht sich nun auf E / A bzw. einen Protokolleintrag, der bei jedem Commit im synchronen Modus ausgef√ºhrt wird.  Da (wie im obigen Beispiel gezeigt) das Schreiben eines Protokolls auf die Festplatte durch die WALWriteLock-Lichtsperre gesch√ºtzt ist, ist diese Sperre auch im Profil vorhanden - wir wollten sie uns ansehen. <br><br><h2>  Clip-Puffer </h2><br>  Um das Fixieren des Puffers zu sehen, nutzen wir die Tatsache, dass offene Cursor den Pin halten, so dass das Lesen der n√§chsten Zeile schneller ist. <br><br>  Wir starten die Transaktion, √∂ffnen den Cursor und w√§hlen eine Zeile aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgbench_history; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> tid | bid | aid | delta | mtime | filler -----+-----+-------+-------+----------------------------+-------- 9 | 1 | 35092 | 477 | 2019-09-04 16:16:18.596564 | (1 row)</code> </pre><br>  √úberpr√ºfen Sie, ob der Puffer fixiert ist (pinning_backends): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relforknumber = <span class="hljs-number"><span class="hljs-number">0</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------ bufferid | 190 relfilenode | 47050 reltablespace | 1663 reldatabase | 16386 relforknumber | 0 relblocknumber | 0 isdirty | t usagecount | 1 pinning_backends | 1 &lt;--   1 </code> </pre><br>  Jetzt werden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Tisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abr√§umen</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 29367 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><pre> <code class="plaintext hljs">| INFO: vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 0 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 1 page due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. | VACUUM</code> </pre><br>  Wie wir sehen k√∂nnen, wurde die Seite √ºbersprungen (1 Seite wegen Pufferstiften √ºbersprungen).  In der Tat kann die Bereinigung nicht damit umgehen, da es verboten ist, Zeilenversionen physisch von einer Seite in einem angehefteten Puffer zu l√∂schen.  Die Reinigung wartet jedoch nicht - die Seite wird beim n√§chsten Mal verarbeitet. <br><br>  Und jetzt werden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reinigung mit Gefrieren durchf√ºhren</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><br>  Mit einem eindeutig angeforderten Einfrieren k√∂nnen Sie keine einzelne Seite √ºberspringen, die nicht in der Einfrierkarte markiert ist. Andernfalls kann das maximale Alter nicht eingefrorener Transaktionen in pg_class.relfrozenxid nicht verringert werden.  Daher bleibt die Bereinigung h√§ngen, bis sich der Cursor schlie√üt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 27 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre><br><pre> <code class="plaintext hljs">| INFO: aggressively vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 26 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 0 pages due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 3.01 s. | VACUUM</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 0 (1 row)</code> </pre><br>  Schauen wir uns das Erwartungsprofil der zweiten psql-Sitzung an, in der die VACUUM-Befehle ausgef√ºhrt wurden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.pid = <span class="hljs-number"><span class="hljs-number">29367</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+------+------------+------------+------- 29367 | client backend | psql | BufferPin | BufferPin | 294 29367 | client backend | psql | Client | ClientRead | 10 (2 rows)</code> </pre><br>  Der Wartetyp BufferPin gibt an, dass der Flush darauf gewartet hat, dass der Puffer freigegeben wird. <br><br>  Hierbei gehen wir davon aus, dass wir die Sperren abgeschlossen haben.  Vielen Dank f√ºr Ihre Aufmerksamkeit und Kommentare! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466199/">https://habr.com/ru/post/de466199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466187/index.html">Visual Logic Editor f√ºr Unity3d. Teil 2</a></li>
<li><a href="../de466191/index.html">Die Hauptsache im Kampf um die Netzneutralit√§t in den USA ist die Chronologie der Ereignisse und der aktuelle Stand der Dinge</a></li>
<li><a href="../de466193/index.html">Benutzerdefinierter MailChimp-Auto-Feed aus RSS-Feed</a></li>
<li><a href="../de466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../de466197/index.html">PVS-Studio 7.04</a></li>
<li><a href="../de466201/index.html">Wie man die Wissenschaft in der IT verl√§sst und Tester wird: die Geschichte einer Karriere</a></li>
<li><a href="../de466203/index.html">Techdir-Tag in St. Petersburg. Bier, Pizza, zwei Mikrofone</a></li>
<li><a href="../de466211/index.html">Projekt Mainline in Android 10</a></li>
<li><a href="../de466213/index.html">4 Schritte zum Erstellen eines Kandidatenprofils</a></li>
<li><a href="../de466215/index.html">Modellorientiertes Design. Erstellung eines zuverl√§ssigen Modells am Beispiel eines Luftfahrtw√§rmetauschers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>