<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèø üóÇÔ∏è ‚òÑÔ∏è Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 2 üôÜüèª üë®‚Äçüíª ‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jenis SafeHandle / CriticalHandle / SafeBuffer / turunan 


 Saya merasa saya akan membuka kotak Pandora untuk Anda. Mari kita bicara tentang tipe khu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443960/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="safehandle--criticalhandle--safebuffer--derived-types">  Jenis SafeHandle / CriticalHandle / SafeBuffer / turunan </h2><br><p>  Saya merasa saya akan membuka kotak Pandora untuk Anda.  Mari kita bicara tentang tipe khusus: SafeHandle, CriticalHandle dan tipe turunannya. </p><br><p>  Ini adalah hal terakhir tentang pola tipe yang memberikan akses ke sumber daya yang tidak dikelola.  Tapi pertama-tama, mari daftarkan semua yang <em>biasanya</em> kita dapatkan dari dunia yang tidak dikelola: </p><br><p>  Yang pertama dan jelas adalah pegangan.  Ini mungkin kata yang tidak berarti untuk pengembang .NET, tetapi ini adalah komponen yang sangat penting dari dunia sistem operasi.  Pegangan pada dasarnya adalah nomor 32 atau 64-bit.  Ini menunjuk sesi interaksi terbuka dengan sistem operasi.  Misalnya, ketika Anda membuka file Anda mendapatkan pegangan dari fungsi WinApi.  Kemudian Anda dapat bekerja dengannya dan melakukan pencarian, <em>baca</em> atau tulis operasi.  Atau, Anda dapat membuka soket untuk akses jaringan.  Sekali lagi sistem operasi akan memberi Anda pegangan.  Dalam .NET handle disimpan sebagai tipe <em>IntPtr</em> ; </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><ul><li>  Yang kedua adalah array data.  Anda dapat bekerja dengan array yang tidak dikelola baik melalui kode yang tidak aman (tidak aman adalah kata kunci di sini) atau menggunakan SafeBuffer yang akan membungkus buffer data ke dalam kelas .NET yang sesuai.  Perhatikan bahwa cara pertama lebih cepat (misalnya Anda dapat mengoptimalkan lilitan sangat), tetapi yang kedua jauh lebih aman, karena didasarkan pada SafeHandle; </li><li>  Lalu pergi string.  String itu sederhana karena kita perlu menentukan format dan pengkodean dari string yang kita tangkap.  Ini kemudian disalin untuk kita (string adalah kelas yang tidak dapat diubah) dan kita tidak khawatir lagi. </li><li>  Yang terakhir adalah ValueTypes yang baru saja disalin sehingga kita tidak perlu memikirkannya sama sekali. </li></ul><br><p>  SafeHandle adalah kelas .NET CLR khusus yang mewarisi CriticalFinalizerObject dan harus membungkus pegangan sistem operasi dengan cara yang paling aman dan paling nyaman. </p><br><pre><code class="plaintext hljs">[SecurityCritical, SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode=true)] public abstract class SafeHandle : CriticalFinalizerObject, IDisposable { protected IntPtr handle; // The handle from OS private int _state; // State (validity, the reference counter) private bool _ownsHandle; // The flag for the possibility to release the handle. // It may happen that we wrap somebody else's handle // have no right to release. private bool _fullyInitialized; // The initialized instance [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle) { } // The finalizer calls Dispose(false) with a pattern [SecuritySafeCritical] ~SafeHandle() { Dispose(false); } // You can set a handle manually or automatically with p/invoke Marshal [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected void SetHandle(IntPtr handle) { this.handle = handle; } // This method is necessary to work with IntPtr directly. It is used to // determine if a handle was created by comparing it with one of the previously // determined known values. Pay attention that this method is dangerous because: // // ‚Äì if a handle is marked as invalid by SetHandleasInvalid, DangerousGetHandle // it will anyway return the original value of the handle. // ‚Äì you can reuse the returned handle at any place. This can at least // mean, that it will stop work without a feedback. In the worst case if // IntPtr is passed directly to another place, it can go to an unsafe code and become // a vector for application attack by resource substitution in one IntPtr [ResourceExposure(ResourceScope.None), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public IntPtr DangerousGetHandle() { return handle; } // The resource is closed (no more available for work) public bool IsClosed { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get { return (_state &amp; 1) == 1; } } // The resource is not available for work. You can override the property by changing the logic. public abstract bool IsInvalid { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get; } // Closing the resource through Close() pattern [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Close() { Dispose(true); } // Closing the resource through Dispose() pattern [SecuritySafeCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Dispose() { Dispose(true); } [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected virtual void Dispose(bool disposing) { // ... } // You should call this method every time when you understand that a handle is not operational anymore. // If you don't do it, you can get a leak. [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void SetHandleAsInvalid(); // Override this method to point how to release // the resource. You should code carefully, as you cannot // call uncompiled methods, create new objects or produce exceptions from it. // A returned value shows if the resource was releases successfully. // If a returned value = false, SafeHandleCriticalFailure will occur // that will enter a breakpoint if SafeHandleCriticalFailure // Managed Debugger Assistant is activated. [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected abstract bool ReleaseHandle(); // Working with the reference counter. To be explained further. [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void DangerousAddRef(ref bool success); public extern void DangerousRelease(); }</code> </pre> <br><p>  Untuk memahami kegunaan kelas-kelas yang berasal dari SafeHandle, Anda perlu mengingat mengapa tipe .NET sangat bagus: GC dapat mengumpulkan instance mereka secara otomatis.  Ketika SafeHandle dikelola, sumber daya yang tidak dikelola yang dibungkusnya mewarisi semua karakteristik dunia yang dikelola.  Ini juga mengandung penghitung internal referensi eksternal yang tidak tersedia untuk CLR.  Maksud saya referensi dari kode yang tidak aman.  Anda tidak perlu menambah atau mengurangi penghitung secara manual sama sekali.  Saat Anda mendeklarasikan tipe yang berasal dari SafeHandle sebagai parameter metode yang tidak aman, penghitung akan bertambah saat memasukkan metode tersebut atau dikurangi setelah keluar.  Alasannya adalah bahwa ketika Anda pergi ke kode yang tidak aman dengan melewati pegangan di sana, Anda mungkin mengumpulkan SafeHandle ini oleh GC, dengan mengatur ulang referensi ke pegangan ini di utas lain (jika Anda berurusan dengan satu pegangan dari beberapa utas).  Hal-hal bekerja lebih mudah dengan penghitung referensi: SafeHandle tidak akan dibuat sampai penghitung nol.  Itu sebabnya Anda tidak perlu mengubah penghitung secara manual.  Atau, Anda harus melakukannya dengan sangat hati-hati dengan mengembalikannya jika memungkinkan. </p><br><p>  Tujuan kedua dari penghitung referensi adalah untuk mengatur urutan finalisasi <code>CriticalFinalizerObject</code> yang saling referensi.  Jika salah satu tipe berbasis SafeHandle merujuk yang lain, maka Anda perlu menambah penghitung referensi di konstruktor dari tipe referensi dan mengurangi penghitung dalam metode ReleaseHandle.  Dengan demikian, objek Anda akan ada sampai objek yang referensi objek Anda tidak dihancurkan.  Namun, lebih baik untuk menghindari kebingungan seperti itu.  Mari kita gunakan pengetahuan tentang SafeHandlers dan tulis varian terakhir dari kelas kami: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { SafeFileHandle _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; _handle.Dispose(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern SafeFileHandle CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); /// other methods }</code> </pre> <br><p>  Apa bedanya?  Jika Anda menetapkan tipe berbasis SafeHandle (termasuk milik Anda) sebagai nilai balik dalam metode DllImport, maka Marshal akan membuat dan menginisialisasi tipe ini dengan benar dan menetapkan penghitung ke 1. Mengetahui hal ini, kami menetapkan jenis SafeFileHandle sebagai tipe pengembalian untuk fungsi CreateFile kernel.  Ketika kami mendapatkannya, kami akan menggunakannya tepat untuk memanggil ReadFile dan WriteFile (sebagai kenaikan nilai counter saat memanggil dan mengurangi ketika keluar akan memastikan bahwa pegangan masih ada selama membaca dari dan menulis ke file).  Ini adalah tipe yang dirancang dengan benar dan akan dapat dipercaya menangani file jika utas dibatalkan.  Ini berarti kita tidak perlu mengimplementasikan finalizer kita sendiri dan segala sesuatu yang berhubungan dengannya.  Seluruh tipe disederhanakan. </p><br><h3 id="the-execution-of-a-finalizer-when-instance-methods-work">  Eksekusi finalizer ketika metode instance bekerja </h3><br><p>  Ada satu teknik optimasi yang digunakan selama pengumpulan sampah yang dirancang untuk mengumpulkan lebih banyak objek dalam waktu yang lebih singkat.  Mari kita lihat kode berikut: </p><br><pre> <code class="plaintext hljs">public void SampleMethod() { var obj = new object(); obj.ToString(); // ... // If GC runs at this point, it may collect obj // as it is not used anymore // ... Console.ReadLine(); }</code> </pre> <br><p>  Di satu sisi, kodenya terlihat aman, dan tidak jelas mengapa kita harus peduli.  Namun, jika Anda ingat bahwa ada kelas yang membungkus sumber daya yang tidak dikelola, Anda akan memahami bahwa kelas yang dirancang secara tidak benar dapat menyebabkan pengecualian dari dunia yang tidak dikelola.  Pengecualian ini akan melaporkan bahwa pegangan yang diperoleh sebelumnya tidak aktif: </p><br><pre> <code class="plaintext hljs">// The example of an absolutely incorrect implementation void Main() { var inst = new SampleClass(); inst.ReadData(); // inst is not used further } public sealed class SampleClass : CriticalFinalizerObject, IDisposable { private IntPtr _handle; public SampleClass() { _handle = CreateFile("test.txt", 0, 0, IntPtr.Zero, 0, 0, IntPtr.Zero); } public void Dispose() { if (_handle != IntPtr.Zero) { CloseHandle(_handle); _handle = IntPtr.Zero; } } ~SampleClass() { Console.WriteLine("Finalizing instance."); Dispose(); } public unsafe void ReadData() { Console.WriteLine("Calling GC.Collect..."); // I redirected it to the local variable not to // use this after GC.Collect(); var handle = _handle; // The imitation of full GC.Collect GC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect(); Console.WriteLine("Finished doing something."); var overlapped = new NativeOverlapped(); // it is not important what we do ReadFileEx(handle, new byte[] { }, 0, ref overlapped, (a, b, c) =&gt; {;}); } [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto, BestFitMapping = false)] static extern IntPtr CreateFile(String lpFileName, int dwDesiredAccess, int dwShareMode, IntPtr securityAttrs, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError = true)] static extern bool ReadFileEx(IntPtr hFile, [Out] byte[] lpBuffer, uint nNumberOfBytesToRead, [In] ref NativeOverlapped lpOverlapped, IOCompletionCallback lpCompletionRoutine); [DllImport("kernel32.dll", SetLastError = true)] static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  Akui bahwa kode ini terlihat layak atau kurang layak.  Bagaimanapun, sepertinya tidak ada masalah.  Padahal, ada masalah serius.  Finalizer kelas dapat mencoba untuk menutup file saat membacanya, yang hampir pasti mengarah pada kesalahan.  Karena dalam kasus ini kesalahan dikembalikan secara eksplisit ( <code>IntPtr == -1</code> ) kita tidak akan melihat ini.  <code>_handle</code> akan ditetapkan ke nol, <code>Dispose</code> berikut akan gagal untuk menutup file dan sumber daya akan bocor.  Untuk mengatasi masalah ini, Anda harus menggunakan <code>SafeHandle</code> , <code>CriticalHandle</code> , <code>SafeBuffer</code> dan kelas turunannya.  Selain bahwa kelas-kelas ini memiliki penghitung penggunaan dalam kode yang tidak dikelola, penghitung ini juga secara otomatis bertambah ketika meneruskan dengan parameter metode ke dunia yang tidak dikelola dan penurunan ketika meninggalkannya. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Charper ini diterjemahkan dari bahasa Rusia sebagai bahasa pengarang oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami membuat versi terjemahan teks ini ke bahasa lain termasuk Cina atau Jerman menggunakan versi Rusia dan Inggris teks sebagai sumber. <br><br>  Juga, jika Anda ingin mengucapkan "terima kasih", cara terbaik yang dapat Anda pilih adalah memberi kami bintang di github atau repositori forking <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443960/">https://habr.com/ru/post/id443960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443950/index.html">Percaya, Sarankan, Sarankan - berburu untuk ulasan perangkat lunak nyata</a></li>
<li><a href="../id443952/index.html">Internet Berdaulat - untuk uang kita</a></li>
<li><a href="../id443954/index.html">Singularitas teknologi: mitos modern tentang akhir dunia dengan kedok hipotesis kemajuan</a></li>
<li><a href="../id443956/index.html">Jejaring sosial pada 2019: Yandex meluncurkan Aura</a></li>
<li><a href="../id443958/index.html">Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 1</a></li>
<li><a href="../id443962/index.html">Pola sekali pakai (Prinsip Desain Sekali Pakai) hal 3</a></li>
<li><a href="../id443964/index.html">Kolesa Conf adalah konferensi IT terbesar di Kazakhstan. Pengumuman laporan</a></li>
<li><a href="../id443966/index.html">Google Documents - obrolan favorit di antara para siswa</a></li>
<li><a href="../id443968/index.html">Bagaimana kami membeli rumah dengan panel surya, dan apa yang terjadi</a></li>
<li><a href="../id443972/index.html">Yandex akan mencari bajak laut menggunakan robot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>