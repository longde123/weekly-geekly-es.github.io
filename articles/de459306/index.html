<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕌 💇🏽 🔉 Server-Rendering in einer Umgebung ohne Server ◾️ 🍷 🏴󠁧󠁢󠁷󠁬󠁳󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen Übersetzung wir veröffentlichen, ist einer der Gründer des Webiny- Projekts - eines serverlosen CMS, das auf React, Gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Server-Rendering in einer Umgebung ohne Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459306/">  Der Autor des Materials, dessen Übersetzung wir veröffentlichen, ist einer der Gründer des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webiny-</a> Projekts - eines serverlosen CMS, das auf React, GraphQL und Node.js basiert.  Er sagt, dass die Unterstützung einer Cloud-Plattform ohne Server mit mehreren Mandanten ein Unternehmen ist, das bestimmte Aufgaben hat.  Es wurden bereits viele Artikel verfasst, in denen Standardtechnologien zur Optimierung von Webprojekten diskutiert werden.  Dazu gehören Server-Rendering, die Verwendung fortschrittlicher Technologien zur Entwicklung von Webanwendungen, verschiedene Möglichkeiten zur Verbesserung der Anwendungserstellung und vieles mehr.  Dieser Artikel ähnelt einerseits den anderen und unterscheidet sich andererseits von ihnen.  Tatsache ist, dass es sich der Optimierung von Projekten widmet, die in einer Umgebung ohne Server ausgeführt werden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/45/ve/ub/45veubaub6xbivpsjj3_1r7zmx0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vorbereitung</font> </h2><br>  Um Messungen durchzuführen, mit denen die Probleme des Projekts identifiziert werden können, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webpagetest.org</a> .  Mit Hilfe dieser Ressource werden wir Anfragen erfüllen und Informationen über die Ausführungszeit verschiedener Operationen sammeln.  Auf diese Weise können wir besser verstehen, was Benutzer bei der Arbeit mit dem Projekt sehen und fühlen. <br><br>  Wir sind besonders an der Anzeige „Erste Ansicht“ interessiert, dh wie lange es dauert, eine Website von einem Benutzer zu laden, der ihn zum ersten Mal besucht.  Dies ist ein sehr wichtiger Indikator.  Tatsache ist, dass der Browser-Cache viele Engpässe bei Webprojekten verbergen kann. <br><br><h2>  <font color="#3AC1EF">Indikatoren, die die Merkmale der Standortbelastung widerspiegeln - Identifizierung von Problemen</font> </h2><br>  Schauen Sie sich die folgende Tabelle an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc9/8a5/669/cc98a56691adf056e19086280e24cd11.png"></div><br>  <i><font color="#999999">Analyse alter und neuer Indikatoren eines Webprojekts</font></i> <br><br>  Hier kann der wichtigste Indikator als „Zeit zum Starten des Renderns“ erkannt werden - die Zeit vor dem Start des Renderns.  Wenn Sie sich diesen Indikator genau ansehen, sehen Sie, dass es in der alten Version des Projekts fast 2 Sekunden gedauert hat, um mit dem Rendern der Seite zu beginnen.  Der Grund dafür liegt im Wesen der Single Page Application (SPA).  Um die Seite einer solchen Anwendung auf dem Bildschirm anzuzeigen, müssen Sie zuerst das umfangreiche JS-Bundle laden (diese Phase des Seitenladens ist in der folgenden Abbildung als 1 markiert).  Dann muss dieses Bundle im Haupt-Thread (2) verarbeitet werden.  Und erst danach kann etwas im Browserfenster erscheinen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/025/675/6b2/0256756b2e402f3ffbc06a426e8e03c1.png"></div><br>  <i><font color="#999999">(1) Laden Sie das JS-Bundle herunter.</font></i>  <i><font color="#999999">(2) Warten auf die Bündelverarbeitung im Hauptthread</font></i> <br><br>  Dies ist jedoch nur ein Teil des Bildes.  Nachdem der Hauptthread das JS-Bundle verarbeitet hat, stellt er mehrere Anforderungen an die Gateway-API.  In dieser Phase der Seitenverarbeitung sieht der Benutzer eine rotierende Ladeanzeige.  Der Anblick ist nicht der angenehmste.  Der Benutzer hat jedoch noch keinen Seiteninhalt gesehen.  Hier ist ein Storyboard des Ladevorgangs der Seite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/a62/b12/f27a62b12f800e4f3622583ca9f078a1.png"></div><br>  <i><font color="#999999">Laden der Seite</font></i> <br><br>  All dies deutet darauf hin, dass der Benutzer, der eine solche Website besucht hat, bei der Arbeit mit ihm keine besonders angenehmen Empfindungen verspürt.  Er ist nämlich gezwungen, 2 Sekunden lang auf eine leere Seite und dann noch eine Sekunde lang auf die Download-Anzeige zu schauen.  Diese Sekunde wird zur Zeit der Seitenvorbereitung hinzugefügt, da nach dem Laden und Verarbeiten die JS-Bundle-API-Anforderungen ausgeführt werden.  Diese Abfragen sind erforderlich, um die Daten zu laden und als Ergebnis die fertige Seite anzuzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/c77/350/bf6c77350326268fbc01ff092a831549.png"></div><br>  <i><font color="#999999">Laden der Seite</font></i> <br><br>  Wenn das Projekt auf einem regulären VPS gehostet würde, wäre die zum Abschließen dieser API-Anforderungen erforderliche Zeit größtenteils vorhersehbar.  Projekte, die in einer Umgebung ohne Server ausgeführt werden, sind jedoch vom berüchtigten Kaltstartproblem betroffen.  Bei der Webiny-Cloud-Plattform ist die Situation noch schlimmer.  AWS Lambda-Funktionen sind Teil von VPC (Virtual Private Cloud).  Dies bedeutet, dass Sie für jede neue Instanz einer solchen Funktion ENI (Elastic Network Interface, Elastic Network Interface) initialisieren müssen.  Dies erhöht die Kaltstartzeit von Funktionen erheblich. <br><br>  Hier sind einige Zeitpläne zum Laden von AWS Lambda-Funktionen innerhalb von VPCs und außerhalb von VPCs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/1e5/30b/6421e530b2330c5c4bf63d473fa93cfb.png"></div><br>  <i><font color="#999999">AWS Lambda-Funktionslastanalyse innerhalb und außerhalb der VPC (Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> )</font></i> <br><br>  Daraus können wir schließen, dass in dem Fall, in dem die Funktion innerhalb der VPC gestartet wird, die Kaltstartzeit um das Zehnfache erhöht wird. <br><br>  Darüber hinaus muss hier ein weiterer Faktor berücksichtigt werden - Verzögerungen bei der Übertragung von Netzwerkdaten.  Ihre Dauer ist bereits zum Zeitpunkt der Ausführung von API-Anforderungen enthalten.  Anfragen werden vom Browser initiiert.  Daher stellt sich heraus, dass zu dem Zeitpunkt, an dem die API auf diese Anforderungen antwortet, die Zeit hinzugefügt wird, die erforderlich ist, um die Anforderung vom Browser an die API zu senden, und die Zeit, die benötigt wird, um die Antwort von der API an den Browser zu senden.  Diese Verzögerungen treten bei jeder Anforderung auf. <br><br><h2>  <font color="#3AC1EF">Optimierungsaufgaben</font> </h2><br>  Basierend auf der obigen Analyse haben wir mehrere Aufgaben formuliert, die wir lösen mussten, um das Projekt zu optimieren.  Hier sind sie: <br><br><ul><li>  Verbessern der Geschwindigkeit beim Ausführen von API-Anforderungen oder Reduzieren der Anzahl von API-Anforderungen, die das Rendern blockieren. </li><li>  Reduzieren der Größe des JS-Bundles oder Konvertieren dieses Bundles in Ressourcen, die für die Ausgabe der Seite nicht erforderlich sind. </li><li>  Hauptfaden entsperren. </li></ul><br><h2>  <font color="#3AC1EF">Problemansätze</font> </h2><br>  Hier sind einige Ansätze zur Lösung der Probleme, die wir in Betracht gezogen haben: <br><br><ol><li>  Codeoptimierung im Hinblick auf eine schnellere Ausführung.  Dieser Ansatz erfordert viel Aufwand und hohe Kosten.  Die Vorteile, die sich aus einer solchen Optimierung ergeben, sind zweifelhaft. </li><li>  Erhöhen Sie die für AWS Lambda-Funktionen verfügbare RAM-Größe.  Es ist einfach, die Kosten für eine solche Lösung liegen irgendwo zwischen mittel und hoch.  Von der Anwendung dieser Lösung sind nur geringe positive Effekte zu erwarten. </li><li>  Die Verwendung eines anderen Weges, um das Problem zu lösen.  Zwar wussten wir in diesem Moment noch nicht, was diese Methode war. </li></ol><br>  Am Ende haben wir den dritten Punkt auf dieser Liste ausgewählt.  Wir haben folgendes argumentiert: „Was ist, wenn wir absolut keine API-Aufrufe benötigen?  Was ist, wenn wir überhaupt auf das JS-Bundle verzichten können?  Dies würde es uns ermöglichen, alle Probleme des Projekts zu lösen. “ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/476/84a/f6947684a7a537bba4b9dfeb24f524e6.jpg"></div><br>  Die erste Idee, die wir interessant fanden, war, einen HTML-Snapshot der gerenderten Seite zu erstellen und den Snapshot für Benutzer freizugeben. <br><br><h2>  <font color="#3AC1EF">Erfolgloser Versuch</font> </h2><br>  Webiny Cloud ist eine AWS Lambda-basierte serverlose Infrastruktur, die Webiny-Sites unterstützt.  Unser System kann Bots erkennen.  Wenn sich herausstellt, dass die Anforderung vom Bot abgeschlossen wurde, wird diese Anforderung an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puppeteer-</a> Instanz umgeleitet, die die Seite mit Chrome ohne Benutzeroberfläche rendert.  Der vorgefertigte HTML-Code der Seite wird an den Bot gesendet.  Dies geschah hauptsächlich aus SEO-Gründen, da viele Bots nicht wissen, wie man JavaScript ausführt.  Wir haben uns für den gleichen Ansatz für die Erstellung von Seiten entschieden, die für normale Benutzer bestimmt sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/698/219/8bd698219b68cccfa5db9f9f81611111.png"></div><br>  Dieser Ansatz funktioniert gut in Umgebungen, in denen JavaScript nicht unterstützt wird.  Wenn Sie jedoch versuchen, einem Client, dessen Browser JS unterstützt, vorgerenderte Seiten zuzuweisen, wird die Seite angezeigt. Nach dem Herunterladen der JS-Dateien wissen die React-Komponenten jedoch einfach nicht, wo sie bereitgestellt werden sollen.  Dies führt zu einer ganzen Reihe von Fehlermeldungen in der Konsole.  Infolgedessen passte eine solche Entscheidung nicht zu uns. <br><br><h2>  <font color="#3AC1EF">Einführung in SSR</font> </h2><br>  Die starke Seite von Server Side Rendering (SSR) ist, dass alle API-Anforderungen innerhalb des lokalen Netzwerks ausgeführt werden.  Da sie von einem bestimmten System oder einer bestimmten Funktion verarbeitet werden, die in der VPC ausgeführt wird, sind Verzögerungen, die beim Ausführen von Anforderungen vom Browser an das Ressourcen-Backend auftreten, untypisch.  Obwohl in diesem Szenario das Problem eines „Kaltstarts“ bestehen bleibt. <br><br>  Ein zusätzlicher Vorteil der Verwendung von SSR besteht darin, dass wir dem Client eine solche HTML-Version der Seite zur Verfügung stellen, mit der die React-Komponenten nach dem Laden der JS-Dateien keine Probleme beim Mounten haben. <br><br>  Und schließlich brauchen wir kein sehr großes JS-Bundle.  Außerdem können wir auf API-Aufrufe verzichten, um die Seite anzuzeigen.  Ein Bundle kann asynchron geladen werden, wodurch der Hauptthread nicht blockiert wird. <br><br>  Im Allgemeinen können wir sagen, dass das Server-Rendering anscheinend die meisten unserer Probleme hätte lösen müssen. <br><br>  So sieht die Site-Analyse nach dem Anwenden von serverseitigem Rendering aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/5df/38e/3705df38e8b3a2c697f04bed1d0d577e.png"></div><br>  <i><font color="#999999">Site-Metriken nach dem Anwenden des Server-Renderings</font></i> <br><br>  Jetzt werden API-Anforderungen nicht ausgeführt, und die Seite wird angezeigt, bevor das große JS-Bundle geladen wird.  Wenn Sie sich jedoch die erste Anforderung genau ansehen, können Sie feststellen, dass es fast 2 Sekunden dauert, bis ein Dokument vom Server abgerufen wird.  Reden wir darüber. <br><br><h2>  <font color="#3AC1EF">Problem mit TTFB</font> </h2><br>  Hier diskutieren wir die TTFB-Metrik (Zeit bis zum ersten Byte, Zeit bis zum ersten Byte).  Hier sind die Details der ersten Anfrage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/19e/9ec/8d319e9eca081b8cba644d7829ccf56e.png"></div><br>  <i><font color="#999999">Erste Anfrage Details</font></i> <br><br>  Um diese erste Anforderung zu verarbeiten, müssen Sie folgende Schritte ausführen: Starten Sie den Node.js-Server, führen Sie das Server-Rendering durch, stellen Sie API-Anforderungen und führen Sie JS-Code aus, und geben Sie das Endergebnis an den Client zurück.  Das Problem hierbei ist, dass dies alles im Durchschnitt 1-2 Sekunden dauert. <br><br>  Unser Server, der das Server-Rendering durchführt, muss all diese Arbeiten ausführen und kann erst danach das erste Byte der Antwort an den Client übertragen.  Dies führt dazu, dass der Browser sehr lange auf den Beginn der Antwort auf die Anfrage warten muss.  Infolgedessen stellt sich heraus, dass Sie jetzt für die Ausgabe der Seite fast den gleichen Arbeitsaufwand wie zuvor produzieren müssen.  Der einzige Unterschied besteht darin, dass diese Arbeit nicht auf der Clientseite, sondern auf dem Server beim Rendern des Servers ausgeführt wird. <br><br>  Hier haben Sie möglicherweise eine Frage zum Wort "Server".  Wir haben die ganze Zeit über das serverlose System gesprochen.  Woher kommt dieser "Server"?  Wir haben natürlich versucht, das Server-Rendering in AWS Lambda-Funktionen zu rendern.  Es stellte sich jedoch heraus, dass dies ein sehr ressourcenintensiver Prozess ist (insbesondere musste der Speicher sehr stark erhöht werden, um mehr Prozessorressourcen zu erhalten).  Darüber hinaus wird hier das bereits erwähnte Problem des „Kaltstarts“ hinzugefügt.  Daher bestand die ideale Lösung darin, einen Node.js-Server zu verwenden, der die Site-Materialien lädt und sie serverseitig rendert. <br><br>  Kehren wir zu den Konsequenzen der Verwendung von serverseitigem Rendering zurück.  Schauen Sie sich das folgende Storyboard an.  Es ist leicht zu erkennen, dass es sich nicht besonders von dem unterscheidet, das bei der Untersuchung des Projekts erhalten wurde, das beim Kunden durchgeführt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/ed3/8c4/fc5ed38c4250cfe6592af448b7f0fd30.png"></div><br>  <i><font color="#999999">Laden von Seiten bei Verwendung von serverseitigem Rendering</font></i> <br><br>  Der Benutzer muss 2,5 Sekunden lang auf eine leere Seite schauen.  Es ist traurig. <br><br>  Wenn man sich diese Ergebnisse ansieht, könnte man denken, dass wir absolut nichts erreicht haben, das ist eigentlich nicht so.  Wir hatten einen HTML-Schnappschuss der Seite, der alles enthielt, was wir brauchten.  Diese Aufnahme war bereit, mit React zu arbeiten.  Gleichzeitig war es während der Verarbeitung der Seite auf dem Client nicht erforderlich, API-Anforderungen auszuführen.  Alle notwendigen Daten wurden bereits in HTML eingebettet. <br><br>  Das einzige Problem war, dass das Erstellen dieses HTML-Snapshots zu lange dauerte.  Zu diesem Zeitpunkt könnten wir entweder mehr Zeit in die Optimierung des Server-Renderings investieren oder einfach die Ergebnisse zwischenspeichern und den Clients einen Schnappschuss der Seite aus einem Redis-Cache geben.  Wir haben genau das getan. <br><br><h2>  <font color="#3AC1EF">Caching Server Rendering Ergebnisse</font> </h2><br>  Nachdem ein Benutzer die Webiny-Website besucht hat, überprüfen wir zunächst den zentralen Redis-Cache, um festzustellen, ob ein HTML-Snapshot der Seite vorhanden ist.  In diesem Fall geben wir dem Benutzer eine Seite aus dem Cache.  Im Durchschnitt senkte dies den TTFB auf 200-400 ms.  Nach der Einführung des Caches stellten wir signifikante Verbesserungen der Projektleistung fest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01e/28d/37e/01e28d37ec4b2586d8a9d8d5187716c9.png"></div><br>  <i><font color="#999999">Laden von Seiten bei Verwendung von serverseitigem Rendering und Cache</font></i> <br><br>  Selbst der Benutzer, der die Site zum ersten Mal besucht, sieht den Inhalt der Seite in weniger als einer Sekunde. <br><br>  Schauen wir uns an, wie das Wasserfalldiagramm jetzt aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/40f/f4c/62940ff4c6f1136c2534c3c299b343c9.png"></div><br>  <i><font color="#999999">Site-Metriken nach dem Anwenden von serverseitigem Rendering und Caching</font></i> <br><br>  Die rote Linie zeigt einen Zeitstempel von 800 ms an.  Hier wird der Inhalt der Seite vollständig geladen.  Außerdem können Sie hier sehen, dass die JS-Bundles nach ca. 1,3 s geladen sind.  Dies hat jedoch keinen Einfluss auf die Zeit, die der Benutzer benötigt, um die Seite zu sehen.  Gleichzeitig müssen Sie keine API-Aufrufe durchführen und den Hauptthread laden, um die Seite anzuzeigen. <br><br>  Beachten Sie, dass temporäre Indikatoren zum Laden des JS-Bundles, Ausführen von API-Anforderungen und Ausführen von Vorgängen im Hauptthread weiterhin eine wichtige Rolle bei der Vorbereitung der Seite für die Arbeit spielen.  Diese Investition von Zeit und Ressourcen ist erforderlich, damit die Seite „interaktiv“ wird.  Dies spielt jedoch erstens keine Rolle für Suchmaschinen-Bots und zweitens für das Gefühl des „schnellen Ladens von Seiten“ bei Benutzern. <br><br>  Angenommen, eine Seite ist "dynamisch".  Beispielsweise wird in der Kopfzeile ein Link angezeigt, über den auf das Benutzerkonto zugegriffen werden kann, falls der Benutzer, der die Seite anzeigt, angemeldet ist.  Nach dem serverseitigen Rendern wird die Allzweck-Seite an den Browser gesendet.  Das heißt - eine, die Benutzern angezeigt wird, die nicht angemeldet sind.  Der Titel dieser Seite ändert sich und spiegelt die Tatsache wider, dass sich der Benutzer erst angemeldet hat, nachdem das JS-Bundle geladen und die API-Aufrufe ausgeführt wurden.  Hier handelt es sich um den <a href="">TTI-</a> Indikator (Time To Interactive, Zeit bis zur ersten Interaktivität). <br><br>  Einige Wochen später stellten wir fest, dass unser Proxyserver die Verbindung zum Client nicht dort schließt, wo sie benötigt wird, falls das Server-Rendering als Hintergrundprozess gestartet wurde.  Die Korrektur von buchstäblich einer Codezeile führte dazu, dass der TTFB-Indikator auf das Niveau von 50-90 ms reduziert wurde.  Infolgedessen wurde die Site nun nach etwa 600 ms im Browser angezeigt. <br><br>  Wir hatten jedoch ein anderes Problem ... <br><br><h2>  <font color="#3AC1EF">Problem mit der Cache-Ungültigmachung</font> </h2><br>  <i><font color="#999999">"In der Informatik gibt es nur zwei komplexe Dinge: Cache-Ungültigmachung und Benennung von Entitäten."</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Phil Carleton</font></i> <br><br>  Die Ungültigmachung des Caches ist in der Tat eine sehr schwierige Aufgabe.  Wie kann man es lösen?  Erstens können Sie den Cache häufig aktualisieren, indem Sie eine sehr kurze Speicherzeit für zwischengespeicherte Objekte festlegen (TTL, Time To Live, Lebensdauer).  Dies führt manchmal dazu, dass Seiten langsamer als gewöhnlich geladen werden.  Zweitens können Sie einen Cache-Ungültigmachungsmechanismus basierend auf bestimmten Ereignissen erstellen. <br><br>  In unserem Fall wurde dieses Problem mit einer sehr kleinen TTL von 30 Sekunden gelöst.  Wir haben aber auch die Möglichkeit erkannt, Clients veraltete Daten aus dem Cache bereitzustellen.  Zu einem Zeitpunkt, an dem Clients solche Daten empfangen, wird der Cache im Hintergrund aktualisiert.  Dank dessen konnten wir Probleme wie Verzögerungen und "Kaltstart" beseitigen, die für AWS Lambda-Funktionen typisch sind. <br><br>  So funktioniert es  Ein Benutzer besucht die Webiny-Website.  Wir überprüfen den HTML-Cache.  Wenn es einen Screenshot der Seite gibt, geben wir ihn dem Benutzer.  Das Alter eines Bildes kann sogar einige Tage betragen.  Indem wir diesen alten Snapshot in wenigen hundert Millisekunden an den Benutzer übergeben, starten wir gleichzeitig die Aufgabe, einen neuen Snapshot zu erstellen und den Cache zu aktualisieren.  Normalerweise dauert es einige Sekunden, um diese Aufgabe abzuschließen, da wir einen Mechanismus erstellt haben, dank dessen wir immer eine bestimmte Anzahl von AWS Lambda-Funktionen haben, die bereits ausgeführt werden und betriebsbereit sind.  Daher müssen wir während der Erstellung neuer Bilder keine Zeit für den Kaltstart von Funktionen aufwenden. <br><br>  Infolgedessen geben wir immer Seiten aus dem Cache an Clients zurück. Wenn das Alter der zwischengespeicherten Daten 30 Sekunden erreicht, wird der Inhalt des Caches aktualisiert. <br><br>  Caching ist definitiv ein Bereich, in dem wir noch etwas verbessern können.  Beispielsweise erwägen wir die Möglichkeit, den Cache automatisch zu aktualisieren, wenn der Benutzer eine Seite veröffentlicht.  Ein solcher Cache-Aktualisierungsmechanismus ist jedoch auch nicht ideal. <br><br>  Angenommen, auf der Homepage einer Ressource werden die drei neuesten Blog-Beiträge angezeigt.  Wenn der Cache beim Veröffentlichen einer neuen Seite aktualisiert wird, wird aus technischer Sicht nach der Veröffentlichung nur der Cache für diese neue Seite generiert.  Der Cache für die Homepage ist veraltet. <br><br>  Wir suchen immer noch nach Möglichkeiten, das Caching-System unseres Projekts zu verbessern.  Bisher lag der Schwerpunkt jedoch auf der Behebung bestehender Leistungsprobleme.  Wir glauben, dass wir bei der Lösung dieser Probleme gute Arbeit geleistet haben. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Zuerst haben wir clientseitiges Rendering verwendet.  Dann konnte der Benutzer die Seite im Durchschnitt in 3,3 Sekunden sehen.  Jetzt ist diese Zahl auf ungefähr 600 ms gefallen.  Es ist auch wichtig, dass wir jetzt auf die Download-Anzeige verzichten. <br><br>  Um dieses Ergebnis zu erzielen, durften wir hauptsächlich Server-Rendering verwenden.  Ohne ein gutes Caching-System stellt sich jedoch heraus, dass die Berechnungen einfach vom Client auf den Server übertragen werden.  Dies führt dazu, dass sich die Zeit, die der Benutzer benötigt, um die Seite zu sehen, nicht wesentlich ändert. <br><br>  Die Verwendung von Server-Rendering hat eine andere positive Qualität, die zuvor nicht erwähnt wurde.  Wir sprechen über die Tatsache, dass es einfacher ist, Seiten auf schwachen Mobilgeräten anzuzeigen.  Die Geschwindigkeit, mit der eine Seite für die Anzeige auf solchen Geräten vorbereitet wird, hängt von den bescheidenen Fähigkeiten ihrer Prozessoren ab.  Mit dem Server-Rendering können Sie einen Teil der Last von ihnen entfernen.  Es sollte beachtet werden, dass wir keine spezielle Studie zu diesem Thema durchgeführt haben, aber das System, über das wir verfügen, sollte dazu beitragen, die Anzeige der Website auf Telefonen und Tablets zu verbessern. <br><br>  Im Allgemeinen können wir sagen, dass die Implementierung des Server-Renderings keine leichte Aufgabe ist.  Und die Tatsache, dass wir eine Umgebung ohne Server verwenden, erschwert diese Aufgabe nur.  Die Lösung unserer Probleme erforderte Codeänderungen und zusätzliche Infrastruktur.  Wir mussten einen gut gestalteten Caching-Mechanismus erstellen.  Aber im Gegenzug haben wir viel Gutes bekommen.  Das Wichtigste ist, dass die Seiten unserer Website jetzt viel schneller als zuvor geladen werden und sich auf die Arbeit vorbereiten.  Wir glauben, dass es unseren Nutzern gefallen wird. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie Caching- und Server-Rendering-Technologien, um Ihre Projekte zu optimieren? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459306/">https://habr.com/ru/post/de459306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459296/index.html">JavaScript Preis 2019</a></li>
<li><a href="../de459298/index.html">Winkel: Status im Jahr 2019</a></li>
<li><a href="../de459300/index.html">Quasar 1.0: Ein neues nützliches Tool für Vue-Entwickler und nicht nur für sie</a></li>
<li><a href="../de459302/index.html">Wiederholen fehlgeschlagener HTTP-Anforderungen in Angular</a></li>
<li><a href="../de459304/index.html">Angular Pitfall Bypass und Zeitersparnis</a></li>
<li><a href="../de459308/index.html">SEO funktioniert 2019 nicht?</a></li>
<li><a href="../de459310/index.html">Testautomatisierungstools oder mobiler Steroidtester</a></li>
<li><a href="../de459312/index.html">Lieber Agile, ich habe es satt, so zu tun</a></li>
<li><a href="../de459314/index.html">Visualisieren und behandeln Sie Hash Match Join</a></li>
<li><a href="../de459316/index.html">Hydra 2019: kostenlose Übertragung der ersten Halle und ein wenig darüber, was auf der Konferenz sein wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>