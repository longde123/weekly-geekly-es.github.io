<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïå üíáüèΩ üîâ Server-Rendering in einer Umgebung ohne Server ‚óæÔ∏è üç∑ üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen √úbersetzung wir ver√∂ffentlichen, ist einer der Gr√ºnder des Webiny- Projekts - eines serverlosen CMS, das auf React, Gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Server-Rendering in einer Umgebung ohne Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459306/">  Der Autor des Materials, dessen √úbersetzung wir ver√∂ffentlichen, ist einer der Gr√ºnder des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webiny-</a> Projekts - eines serverlosen CMS, das auf React, GraphQL und Node.js basiert.  Er sagt, dass die Unterst√ºtzung einer Cloud-Plattform ohne Server mit mehreren Mandanten ein Unternehmen ist, das bestimmte Aufgaben hat.  Es wurden bereits viele Artikel verfasst, in denen Standardtechnologien zur Optimierung von Webprojekten diskutiert werden.  Dazu geh√∂ren Server-Rendering, die Verwendung fortschrittlicher Technologien zur Entwicklung von Webanwendungen, verschiedene M√∂glichkeiten zur Verbesserung der Anwendungserstellung und vieles mehr.  Dieser Artikel √§hnelt einerseits den anderen und unterscheidet sich andererseits von ihnen.  Tatsache ist, dass es sich der Optimierung von Projekten widmet, die in einer Umgebung ohne Server ausgef√ºhrt werden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/45/ve/ub/45veubaub6xbivpsjj3_1r7zmx0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vorbereitung</font> </h2><br>  Um Messungen durchzuf√ºhren, mit denen die Probleme des Projekts identifiziert werden k√∂nnen, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webpagetest.org</a> .  Mit Hilfe dieser Ressource werden wir Anfragen erf√ºllen und Informationen √ºber die Ausf√ºhrungszeit verschiedener Operationen sammeln.  Auf diese Weise k√∂nnen wir besser verstehen, was Benutzer bei der Arbeit mit dem Projekt sehen und f√ºhlen. <br><br>  Wir sind besonders an der Anzeige ‚ÄûErste Ansicht‚Äú interessiert, dh wie lange es dauert, eine Website von einem Benutzer zu laden, der ihn zum ersten Mal besucht.  Dies ist ein sehr wichtiger Indikator.  Tatsache ist, dass der Browser-Cache viele Engp√§sse bei Webprojekten verbergen kann. <br><br><h2>  <font color="#3AC1EF">Indikatoren, die die Merkmale der Standortbelastung widerspiegeln - Identifizierung von Problemen</font> </h2><br>  Schauen Sie sich die folgende Tabelle an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc9/8a5/669/cc98a56691adf056e19086280e24cd11.png"></div><br>  <i><font color="#999999">Analyse alter und neuer Indikatoren eines Webprojekts</font></i> <br><br>  Hier kann der wichtigste Indikator als ‚ÄûZeit zum Starten des Renderns‚Äú erkannt werden - die Zeit vor dem Start des Renderns.  Wenn Sie sich diesen Indikator genau ansehen, sehen Sie, dass es in der alten Version des Projekts fast 2 Sekunden gedauert hat, um mit dem Rendern der Seite zu beginnen.  Der Grund daf√ºr liegt im Wesen der Single Page Application (SPA).  Um die Seite einer solchen Anwendung auf dem Bildschirm anzuzeigen, m√ºssen Sie zuerst das umfangreiche JS-Bundle laden (diese Phase des Seitenladens ist in der folgenden Abbildung als 1 markiert).  Dann muss dieses Bundle im Haupt-Thread (2) verarbeitet werden.  Und erst danach kann etwas im Browserfenster erscheinen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/025/675/6b2/0256756b2e402f3ffbc06a426e8e03c1.png"></div><br>  <i><font color="#999999">(1) Laden Sie das JS-Bundle herunter.</font></i>  <i><font color="#999999">(2) Warten auf die B√ºndelverarbeitung im Hauptthread</font></i> <br><br>  Dies ist jedoch nur ein Teil des Bildes.  Nachdem der Hauptthread das JS-Bundle verarbeitet hat, stellt er mehrere Anforderungen an die Gateway-API.  In dieser Phase der Seitenverarbeitung sieht der Benutzer eine rotierende Ladeanzeige.  Der Anblick ist nicht der angenehmste.  Der Benutzer hat jedoch noch keinen Seiteninhalt gesehen.  Hier ist ein Storyboard des Ladevorgangs der Seite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/a62/b12/f27a62b12f800e4f3622583ca9f078a1.png"></div><br>  <i><font color="#999999">Laden der Seite</font></i> <br><br>  All dies deutet darauf hin, dass der Benutzer, der eine solche Website besucht hat, bei der Arbeit mit ihm keine besonders angenehmen Empfindungen versp√ºrt.  Er ist n√§mlich gezwungen, 2 Sekunden lang auf eine leere Seite und dann noch eine Sekunde lang auf die Download-Anzeige zu schauen.  Diese Sekunde wird zur Zeit der Seitenvorbereitung hinzugef√ºgt, da nach dem Laden und Verarbeiten die JS-Bundle-API-Anforderungen ausgef√ºhrt werden.  Diese Abfragen sind erforderlich, um die Daten zu laden und als Ergebnis die fertige Seite anzuzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/c77/350/bf6c77350326268fbc01ff092a831549.png"></div><br>  <i><font color="#999999">Laden der Seite</font></i> <br><br>  Wenn das Projekt auf einem regul√§ren VPS gehostet w√ºrde, w√§re die zum Abschlie√üen dieser API-Anforderungen erforderliche Zeit gr√∂√ütenteils vorhersehbar.  Projekte, die in einer Umgebung ohne Server ausgef√ºhrt werden, sind jedoch vom ber√ºchtigten Kaltstartproblem betroffen.  Bei der Webiny-Cloud-Plattform ist die Situation noch schlimmer.  AWS Lambda-Funktionen sind Teil von VPC (Virtual Private Cloud).  Dies bedeutet, dass Sie f√ºr jede neue Instanz einer solchen Funktion ENI (Elastic Network Interface, Elastic Network Interface) initialisieren m√ºssen.  Dies erh√∂ht die Kaltstartzeit von Funktionen erheblich. <br><br>  Hier sind einige Zeitpl√§ne zum Laden von AWS Lambda-Funktionen innerhalb von VPCs und au√üerhalb von VPCs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/1e5/30b/6421e530b2330c5c4bf63d473fa93cfb.png"></div><br>  <i><font color="#999999">AWS Lambda-Funktionslastanalyse innerhalb und au√üerhalb der VPC (Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> )</font></i> <br><br>  Daraus k√∂nnen wir schlie√üen, dass in dem Fall, in dem die Funktion innerhalb der VPC gestartet wird, die Kaltstartzeit um das Zehnfache erh√∂ht wird. <br><br>  Dar√ºber hinaus muss hier ein weiterer Faktor ber√ºcksichtigt werden - Verz√∂gerungen bei der √úbertragung von Netzwerkdaten.  Ihre Dauer ist bereits zum Zeitpunkt der Ausf√ºhrung von API-Anforderungen enthalten.  Anfragen werden vom Browser initiiert.  Daher stellt sich heraus, dass zu dem Zeitpunkt, an dem die API auf diese Anforderungen antwortet, die Zeit hinzugef√ºgt wird, die erforderlich ist, um die Anforderung vom Browser an die API zu senden, und die Zeit, die ben√∂tigt wird, um die Antwort von der API an den Browser zu senden.  Diese Verz√∂gerungen treten bei jeder Anforderung auf. <br><br><h2>  <font color="#3AC1EF">Optimierungsaufgaben</font> </h2><br>  Basierend auf der obigen Analyse haben wir mehrere Aufgaben formuliert, die wir l√∂sen mussten, um das Projekt zu optimieren.  Hier sind sie: <br><br><ul><li>  Verbessern der Geschwindigkeit beim Ausf√ºhren von API-Anforderungen oder Reduzieren der Anzahl von API-Anforderungen, die das Rendern blockieren. </li><li>  Reduzieren der Gr√∂√üe des JS-Bundles oder Konvertieren dieses Bundles in Ressourcen, die f√ºr die Ausgabe der Seite nicht erforderlich sind. </li><li>  Hauptfaden entsperren. </li></ul><br><h2>  <font color="#3AC1EF">Problemans√§tze</font> </h2><br>  Hier sind einige Ans√§tze zur L√∂sung der Probleme, die wir in Betracht gezogen haben: <br><br><ol><li>  Codeoptimierung im Hinblick auf eine schnellere Ausf√ºhrung.  Dieser Ansatz erfordert viel Aufwand und hohe Kosten.  Die Vorteile, die sich aus einer solchen Optimierung ergeben, sind zweifelhaft. </li><li>  Erh√∂hen Sie die f√ºr AWS Lambda-Funktionen verf√ºgbare RAM-Gr√∂√üe.  Es ist einfach, die Kosten f√ºr eine solche L√∂sung liegen irgendwo zwischen mittel und hoch.  Von der Anwendung dieser L√∂sung sind nur geringe positive Effekte zu erwarten. </li><li>  Die Verwendung eines anderen Weges, um das Problem zu l√∂sen.  Zwar wussten wir in diesem Moment noch nicht, was diese Methode war. </li></ol><br>  Am Ende haben wir den dritten Punkt auf dieser Liste ausgew√§hlt.  Wir haben folgendes argumentiert: ‚ÄûWas ist, wenn wir absolut keine API-Aufrufe ben√∂tigen?  Was ist, wenn wir √ºberhaupt auf das JS-Bundle verzichten k√∂nnen?  Dies w√ºrde es uns erm√∂glichen, alle Probleme des Projekts zu l√∂sen. ‚Äú <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/476/84a/f6947684a7a537bba4b9dfeb24f524e6.jpg"></div><br>  Die erste Idee, die wir interessant fanden, war, einen HTML-Snapshot der gerenderten Seite zu erstellen und den Snapshot f√ºr Benutzer freizugeben. <br><br><h2>  <font color="#3AC1EF">Erfolgloser Versuch</font> </h2><br>  Webiny Cloud ist eine AWS Lambda-basierte serverlose Infrastruktur, die Webiny-Sites unterst√ºtzt.  Unser System kann Bots erkennen.  Wenn sich herausstellt, dass die Anforderung vom Bot abgeschlossen wurde, wird diese Anforderung an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puppeteer-</a> Instanz umgeleitet, die die Seite mit Chrome ohne Benutzeroberfl√§che rendert.  Der vorgefertigte HTML-Code der Seite wird an den Bot gesendet.  Dies geschah haupts√§chlich aus SEO-Gr√ºnden, da viele Bots nicht wissen, wie man JavaScript ausf√ºhrt.  Wir haben uns f√ºr den gleichen Ansatz f√ºr die Erstellung von Seiten entschieden, die f√ºr normale Benutzer bestimmt sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/698/219/8bd698219b68cccfa5db9f9f81611111.png"></div><br>  Dieser Ansatz funktioniert gut in Umgebungen, in denen JavaScript nicht unterst√ºtzt wird.  Wenn Sie jedoch versuchen, einem Client, dessen Browser JS unterst√ºtzt, vorgerenderte Seiten zuzuweisen, wird die Seite angezeigt. Nach dem Herunterladen der JS-Dateien wissen die React-Komponenten jedoch einfach nicht, wo sie bereitgestellt werden sollen.  Dies f√ºhrt zu einer ganzen Reihe von Fehlermeldungen in der Konsole.  Infolgedessen passte eine solche Entscheidung nicht zu uns. <br><br><h2>  <font color="#3AC1EF">Einf√ºhrung in SSR</font> </h2><br>  Die starke Seite von Server Side Rendering (SSR) ist, dass alle API-Anforderungen innerhalb des lokalen Netzwerks ausgef√ºhrt werden.  Da sie von einem bestimmten System oder einer bestimmten Funktion verarbeitet werden, die in der VPC ausgef√ºhrt wird, sind Verz√∂gerungen, die beim Ausf√ºhren von Anforderungen vom Browser an das Ressourcen-Backend auftreten, untypisch.  Obwohl in diesem Szenario das Problem eines ‚ÄûKaltstarts‚Äú bestehen bleibt. <br><br>  Ein zus√§tzlicher Vorteil der Verwendung von SSR besteht darin, dass wir dem Client eine solche HTML-Version der Seite zur Verf√ºgung stellen, mit der die React-Komponenten nach dem Laden der JS-Dateien keine Probleme beim Mounten haben. <br><br>  Und schlie√ülich brauchen wir kein sehr gro√ües JS-Bundle.  Au√üerdem k√∂nnen wir auf API-Aufrufe verzichten, um die Seite anzuzeigen.  Ein Bundle kann asynchron geladen werden, wodurch der Hauptthread nicht blockiert wird. <br><br>  Im Allgemeinen k√∂nnen wir sagen, dass das Server-Rendering anscheinend die meisten unserer Probleme h√§tte l√∂sen m√ºssen. <br><br>  So sieht die Site-Analyse nach dem Anwenden von serverseitigem Rendering aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/5df/38e/3705df38e8b3a2c697f04bed1d0d577e.png"></div><br>  <i><font color="#999999">Site-Metriken nach dem Anwenden des Server-Renderings</font></i> <br><br>  Jetzt werden API-Anforderungen nicht ausgef√ºhrt, und die Seite wird angezeigt, bevor das gro√üe JS-Bundle geladen wird.  Wenn Sie sich jedoch die erste Anforderung genau ansehen, k√∂nnen Sie feststellen, dass es fast 2 Sekunden dauert, bis ein Dokument vom Server abgerufen wird.  Reden wir dar√ºber. <br><br><h2>  <font color="#3AC1EF">Problem mit TTFB</font> </h2><br>  Hier diskutieren wir die TTFB-Metrik (Zeit bis zum ersten Byte, Zeit bis zum ersten Byte).  Hier sind die Details der ersten Anfrage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/19e/9ec/8d319e9eca081b8cba644d7829ccf56e.png"></div><br>  <i><font color="#999999">Erste Anfrage Details</font></i> <br><br>  Um diese erste Anforderung zu verarbeiten, m√ºssen Sie folgende Schritte ausf√ºhren: Starten Sie den Node.js-Server, f√ºhren Sie das Server-Rendering durch, stellen Sie API-Anforderungen und f√ºhren Sie JS-Code aus, und geben Sie das Endergebnis an den Client zur√ºck.  Das Problem hierbei ist, dass dies alles im Durchschnitt 1-2 Sekunden dauert. <br><br>  Unser Server, der das Server-Rendering durchf√ºhrt, muss all diese Arbeiten ausf√ºhren und kann erst danach das erste Byte der Antwort an den Client √ºbertragen.  Dies f√ºhrt dazu, dass der Browser sehr lange auf den Beginn der Antwort auf die Anfrage warten muss.  Infolgedessen stellt sich heraus, dass Sie jetzt f√ºr die Ausgabe der Seite fast den gleichen Arbeitsaufwand wie zuvor produzieren m√ºssen.  Der einzige Unterschied besteht darin, dass diese Arbeit nicht auf der Clientseite, sondern auf dem Server beim Rendern des Servers ausgef√ºhrt wird. <br><br>  Hier haben Sie m√∂glicherweise eine Frage zum Wort "Server".  Wir haben die ganze Zeit √ºber das serverlose System gesprochen.  Woher kommt dieser "Server"?  Wir haben nat√ºrlich versucht, das Server-Rendering in AWS Lambda-Funktionen zu rendern.  Es stellte sich jedoch heraus, dass dies ein sehr ressourcenintensiver Prozess ist (insbesondere musste der Speicher sehr stark erh√∂ht werden, um mehr Prozessorressourcen zu erhalten).  Dar√ºber hinaus wird hier das bereits erw√§hnte Problem des ‚ÄûKaltstarts‚Äú hinzugef√ºgt.  Daher bestand die ideale L√∂sung darin, einen Node.js-Server zu verwenden, der die Site-Materialien l√§dt und sie serverseitig rendert. <br><br>  Kehren wir zu den Konsequenzen der Verwendung von serverseitigem Rendering zur√ºck.  Schauen Sie sich das folgende Storyboard an.  Es ist leicht zu erkennen, dass es sich nicht besonders von dem unterscheidet, das bei der Untersuchung des Projekts erhalten wurde, das beim Kunden durchgef√ºhrt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/ed3/8c4/fc5ed38c4250cfe6592af448b7f0fd30.png"></div><br>  <i><font color="#999999">Laden von Seiten bei Verwendung von serverseitigem Rendering</font></i> <br><br>  Der Benutzer muss 2,5 Sekunden lang auf eine leere Seite schauen.  Es ist traurig. <br><br>  Wenn man sich diese Ergebnisse ansieht, k√∂nnte man denken, dass wir absolut nichts erreicht haben, das ist eigentlich nicht so.  Wir hatten einen HTML-Schnappschuss der Seite, der alles enthielt, was wir brauchten.  Diese Aufnahme war bereit, mit React zu arbeiten.  Gleichzeitig war es w√§hrend der Verarbeitung der Seite auf dem Client nicht erforderlich, API-Anforderungen auszuf√ºhren.  Alle notwendigen Daten wurden bereits in HTML eingebettet. <br><br>  Das einzige Problem war, dass das Erstellen dieses HTML-Snapshots zu lange dauerte.  Zu diesem Zeitpunkt k√∂nnten wir entweder mehr Zeit in die Optimierung des Server-Renderings investieren oder einfach die Ergebnisse zwischenspeichern und den Clients einen Schnappschuss der Seite aus einem Redis-Cache geben.  Wir haben genau das getan. <br><br><h2>  <font color="#3AC1EF">Caching Server Rendering Ergebnisse</font> </h2><br>  Nachdem ein Benutzer die Webiny-Website besucht hat, √ºberpr√ºfen wir zun√§chst den zentralen Redis-Cache, um festzustellen, ob ein HTML-Snapshot der Seite vorhanden ist.  In diesem Fall geben wir dem Benutzer eine Seite aus dem Cache.  Im Durchschnitt senkte dies den TTFB auf 200-400 ms.  Nach der Einf√ºhrung des Caches stellten wir signifikante Verbesserungen der Projektleistung fest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01e/28d/37e/01e28d37ec4b2586d8a9d8d5187716c9.png"></div><br>  <i><font color="#999999">Laden von Seiten bei Verwendung von serverseitigem Rendering und Cache</font></i> <br><br>  Selbst der Benutzer, der die Site zum ersten Mal besucht, sieht den Inhalt der Seite in weniger als einer Sekunde. <br><br>  Schauen wir uns an, wie das Wasserfalldiagramm jetzt aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/40f/f4c/62940ff4c6f1136c2534c3c299b343c9.png"></div><br>  <i><font color="#999999">Site-Metriken nach dem Anwenden von serverseitigem Rendering und Caching</font></i> <br><br>  Die rote Linie zeigt einen Zeitstempel von 800 ms an.  Hier wird der Inhalt der Seite vollst√§ndig geladen.  Au√üerdem k√∂nnen Sie hier sehen, dass die JS-Bundles nach ca. 1,3 s geladen sind.  Dies hat jedoch keinen Einfluss auf die Zeit, die der Benutzer ben√∂tigt, um die Seite zu sehen.  Gleichzeitig m√ºssen Sie keine API-Aufrufe durchf√ºhren und den Hauptthread laden, um die Seite anzuzeigen. <br><br>  Beachten Sie, dass tempor√§re Indikatoren zum Laden des JS-Bundles, Ausf√ºhren von API-Anforderungen und Ausf√ºhren von Vorg√§ngen im Hauptthread weiterhin eine wichtige Rolle bei der Vorbereitung der Seite f√ºr die Arbeit spielen.  Diese Investition von Zeit und Ressourcen ist erforderlich, damit die Seite ‚Äûinteraktiv‚Äú wird.  Dies spielt jedoch erstens keine Rolle f√ºr Suchmaschinen-Bots und zweitens f√ºr das Gef√ºhl des ‚Äûschnellen Ladens von Seiten‚Äú bei Benutzern. <br><br>  Angenommen, eine Seite ist "dynamisch".  Beispielsweise wird in der Kopfzeile ein Link angezeigt, √ºber den auf das Benutzerkonto zugegriffen werden kann, falls der Benutzer, der die Seite anzeigt, angemeldet ist.  Nach dem serverseitigen Rendern wird die Allzweck-Seite an den Browser gesendet.  Das hei√üt - eine, die Benutzern angezeigt wird, die nicht angemeldet sind.  Der Titel dieser Seite √§ndert sich und spiegelt die Tatsache wider, dass sich der Benutzer erst angemeldet hat, nachdem das JS-Bundle geladen und die API-Aufrufe ausgef√ºhrt wurden.  Hier handelt es sich um den <a href="">TTI-</a> Indikator (Time To Interactive, Zeit bis zur ersten Interaktivit√§t). <br><br>  Einige Wochen sp√§ter stellten wir fest, dass unser Proxyserver die Verbindung zum Client nicht dort schlie√üt, wo sie ben√∂tigt wird, falls das Server-Rendering als Hintergrundprozess gestartet wurde.  Die Korrektur von buchst√§blich einer Codezeile f√ºhrte dazu, dass der TTFB-Indikator auf das Niveau von 50-90 ms reduziert wurde.  Infolgedessen wurde die Site nun nach etwa 600 ms im Browser angezeigt. <br><br>  Wir hatten jedoch ein anderes Problem ... <br><br><h2>  <font color="#3AC1EF">Problem mit der Cache-Ung√ºltigmachung</font> </h2><br>  <i><font color="#999999">"In der Informatik gibt es nur zwei komplexe Dinge: Cache-Ung√ºltigmachung und Benennung von Entit√§ten."</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Phil Carleton</font></i> <br><br>  Die Ung√ºltigmachung des Caches ist in der Tat eine sehr schwierige Aufgabe.  Wie kann man es l√∂sen?  Erstens k√∂nnen Sie den Cache h√§ufig aktualisieren, indem Sie eine sehr kurze Speicherzeit f√ºr zwischengespeicherte Objekte festlegen (TTL, Time To Live, Lebensdauer).  Dies f√ºhrt manchmal dazu, dass Seiten langsamer als gew√∂hnlich geladen werden.  Zweitens k√∂nnen Sie einen Cache-Ung√ºltigmachungsmechanismus basierend auf bestimmten Ereignissen erstellen. <br><br>  In unserem Fall wurde dieses Problem mit einer sehr kleinen TTL von 30 Sekunden gel√∂st.  Wir haben aber auch die M√∂glichkeit erkannt, Clients veraltete Daten aus dem Cache bereitzustellen.  Zu einem Zeitpunkt, an dem Clients solche Daten empfangen, wird der Cache im Hintergrund aktualisiert.  Dank dessen konnten wir Probleme wie Verz√∂gerungen und "Kaltstart" beseitigen, die f√ºr AWS Lambda-Funktionen typisch sind. <br><br>  So funktioniert es  Ein Benutzer besucht die Webiny-Website.  Wir √ºberpr√ºfen den HTML-Cache.  Wenn es einen Screenshot der Seite gibt, geben wir ihn dem Benutzer.  Das Alter eines Bildes kann sogar einige Tage betragen.  Indem wir diesen alten Snapshot in wenigen hundert Millisekunden an den Benutzer √ºbergeben, starten wir gleichzeitig die Aufgabe, einen neuen Snapshot zu erstellen und den Cache zu aktualisieren.  Normalerweise dauert es einige Sekunden, um diese Aufgabe abzuschlie√üen, da wir einen Mechanismus erstellt haben, dank dessen wir immer eine bestimmte Anzahl von AWS Lambda-Funktionen haben, die bereits ausgef√ºhrt werden und betriebsbereit sind.  Daher m√ºssen wir w√§hrend der Erstellung neuer Bilder keine Zeit f√ºr den Kaltstart von Funktionen aufwenden. <br><br>  Infolgedessen geben wir immer Seiten aus dem Cache an Clients zur√ºck. Wenn das Alter der zwischengespeicherten Daten 30 Sekunden erreicht, wird der Inhalt des Caches aktualisiert. <br><br>  Caching ist definitiv ein Bereich, in dem wir noch etwas verbessern k√∂nnen.  Beispielsweise erw√§gen wir die M√∂glichkeit, den Cache automatisch zu aktualisieren, wenn der Benutzer eine Seite ver√∂ffentlicht.  Ein solcher Cache-Aktualisierungsmechanismus ist jedoch auch nicht ideal. <br><br>  Angenommen, auf der Homepage einer Ressource werden die drei neuesten Blog-Beitr√§ge angezeigt.  Wenn der Cache beim Ver√∂ffentlichen einer neuen Seite aktualisiert wird, wird aus technischer Sicht nach der Ver√∂ffentlichung nur der Cache f√ºr diese neue Seite generiert.  Der Cache f√ºr die Homepage ist veraltet. <br><br>  Wir suchen immer noch nach M√∂glichkeiten, das Caching-System unseres Projekts zu verbessern.  Bisher lag der Schwerpunkt jedoch auf der Behebung bestehender Leistungsprobleme.  Wir glauben, dass wir bei der L√∂sung dieser Probleme gute Arbeit geleistet haben. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Zuerst haben wir clientseitiges Rendering verwendet.  Dann konnte der Benutzer die Seite im Durchschnitt in 3,3 Sekunden sehen.  Jetzt ist diese Zahl auf ungef√§hr 600 ms gefallen.  Es ist auch wichtig, dass wir jetzt auf die Download-Anzeige verzichten. <br><br>  Um dieses Ergebnis zu erzielen, durften wir haupts√§chlich Server-Rendering verwenden.  Ohne ein gutes Caching-System stellt sich jedoch heraus, dass die Berechnungen einfach vom Client auf den Server √ºbertragen werden.  Dies f√ºhrt dazu, dass sich die Zeit, die der Benutzer ben√∂tigt, um die Seite zu sehen, nicht wesentlich √§ndert. <br><br>  Die Verwendung von Server-Rendering hat eine andere positive Qualit√§t, die zuvor nicht erw√§hnt wurde.  Wir sprechen √ºber die Tatsache, dass es einfacher ist, Seiten auf schwachen Mobilger√§ten anzuzeigen.  Die Geschwindigkeit, mit der eine Seite f√ºr die Anzeige auf solchen Ger√§ten vorbereitet wird, h√§ngt von den bescheidenen F√§higkeiten ihrer Prozessoren ab.  Mit dem Server-Rendering k√∂nnen Sie einen Teil der Last von ihnen entfernen.  Es sollte beachtet werden, dass wir keine spezielle Studie zu diesem Thema durchgef√ºhrt haben, aber das System, √ºber das wir verf√ºgen, sollte dazu beitragen, die Anzeige der Website auf Telefonen und Tablets zu verbessern. <br><br>  Im Allgemeinen k√∂nnen wir sagen, dass die Implementierung des Server-Renderings keine leichte Aufgabe ist.  Und die Tatsache, dass wir eine Umgebung ohne Server verwenden, erschwert diese Aufgabe nur.  Die L√∂sung unserer Probleme erforderte Code√§nderungen und zus√§tzliche Infrastruktur.  Wir mussten einen gut gestalteten Caching-Mechanismus erstellen.  Aber im Gegenzug haben wir viel Gutes bekommen.  Das Wichtigste ist, dass die Seiten unserer Website jetzt viel schneller als zuvor geladen werden und sich auf die Arbeit vorbereiten.  Wir glauben, dass es unseren Nutzern gefallen wird. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie Caching- und Server-Rendering-Technologien, um Ihre Projekte zu optimieren? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459306/">https://habr.com/ru/post/de459306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459296/index.html">JavaScript Preis 2019</a></li>
<li><a href="../de459298/index.html">Winkel: Status im Jahr 2019</a></li>
<li><a href="../de459300/index.html">Quasar 1.0: Ein neues n√ºtzliches Tool f√ºr Vue-Entwickler und nicht nur f√ºr sie</a></li>
<li><a href="../de459302/index.html">Wiederholen fehlgeschlagener HTTP-Anforderungen in Angular</a></li>
<li><a href="../de459304/index.html">Angular Pitfall Bypass und Zeitersparnis</a></li>
<li><a href="../de459308/index.html">SEO funktioniert 2019 nicht?</a></li>
<li><a href="../de459310/index.html">Testautomatisierungstools oder mobiler Steroidtester</a></li>
<li><a href="../de459312/index.html">Lieber Agile, ich habe es satt, so zu tun</a></li>
<li><a href="../de459314/index.html">Visualisieren und behandeln Sie Hash Match Join</a></li>
<li><a href="../de459316/index.html">Hydra 2019: kostenlose √úbertragung der ersten Halle und ein wenig dar√ºber, was auf der Konferenz sein wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>