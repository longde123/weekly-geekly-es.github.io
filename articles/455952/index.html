<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦 🏇 🍇 Generación de código con Roslyn 😍 🔲 🥜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De vez en cuando, cuando leía sobre Roslyn y sus analizadores, pensaba constantemente: "Pero puedes hacer nuget con esta cosa, que dará la vuelta al c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generación de código con Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455952/"><p> De vez en cuando, cuando leía sobre Roslyn y sus analizadores, pensaba constantemente: "Pero puedes hacer nuget con esta cosa, que dará la vuelta al código y generará código".  Una búsqueda rápida no mostró nada interesante, por lo que se decidió cavar.  Qué gratamente me sorprendió cuando descubrí que mi idea no solo era factible, sino que todo esto funcionaría casi sin muletas. </p><br><p>  Entonces, ¿quién está interesado en ver cómo puede hacer un "pequeño reflejo" y empaquetarlo en nuget, por favor, debajo de cat. </p><a name="habracut"></a><br><h1 id="vvedenie">  Introduccion </h1><br><p> Creo que lo primero que hay que aclarar es qué se entiende por "poca reflexión".  Sugiero implementar para todos los tipos el método <code>Dictionary&lt;string, Type&gt; GetBakedType()</code> , que devolverá los nombres de las propiedades y sus tipos.  Como esto debería funcionar con todos los tipos, la opción más fácil sería generar un método de extensión para cada tipo.  Su implementación manual tendrá la siguiente forma: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">testSimpleReflectionUserExtentions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Type&gt; properties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Type&gt; { { <span class="hljs-string"><span class="hljs-string">"Id"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(System.Guid)}, { <span class="hljs-string"><span class="hljs-string">"FirstName"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)}, { <span class="hljs-string"><span class="hljs-string">"LastName"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)}, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Dictionary&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">, Type&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBakedType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">global</span></span></span></span><span class="hljs-function"><span class="hljs-params">::testSimpleReflection.User </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> properties; } }</code> </pre><br><p>  Aquí no hay nada sobrenatural, pero realizarlo para todos los tipos es un asunto triste y no interesante que, además, amenaza los errores tipográficos.  ¿Por qué no le pedimos ayuda al compilador?  Aquí es donde Roslyn y sus analizadores entran en la arena.  Brindan la oportunidad de analizar el código y cambiarlo.  Entonces, enseñemos al compilador un nuevo truco.  Deje que <code>GetBakedType</code> el código y vea dónde usamos, pero aún no hemos implementado nuestro <code>GetBakedType</code> y lo implementa. </p><br><p>  Para "habilitar" esta funcionalidad, solo necesitamos instalar un paquete nuget y todo funcionará de inmediato.  Luego, solo llame a <code>GetBakedType</code> cuando sea necesario, obtenemos un error de compilación que dice que la reflexión para este tipo aún no está lista, llame a codefix y ya está.  Tenemos un método de extensión que nos devolverá todas las propiedades públicas. </p><br><p>  Creo que en el movimiento será más fácil entender cómo funciona en general, aquí hay una breve visualización: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/C9O1413fHac" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Si está interesado en probar esto localmente, puede instalar el paquete nuget bajo el nombre SimpleReflection: </p><br><pre> <code class="plaintext hljs">Install-Package SimpleReflection</code> </pre> <br><p>  A quién le importa la fuente, están <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Quiero advertir que esta implementación no está diseñada para un uso real.  Solo quiero mostrar una forma de organizar la generación de código con Roslyn. </p><br><h1 id="predvaritelnaya-podgotovka">  Preparación preliminar </h1><br><p>  Antes de comenzar a hacer sus analizadores, debe instalar el componente 'Desarrollo de extensión de Visual Studio' en el instalador del estudio.  Para VS 2019, debe recordar seleccionar ".NET Compiler Platform SDK" como componente opcional. </p><br><h1 id="realizaciya-analizatora">  Implementación de analizador </h1><br><p>  No describiré por etapas cómo implementar el analizador, ya que es muy simple, pero solo repase los puntos clave. </p><br><p>  Y el primer punto clave será que si tenemos un error de compilación real, entonces los analizadores no comienzan en absoluto.  Como resultado, si intentamos llamar a nuestro <code>GetBakedType()</code> en el contexto del tipo para el que no está implementado, obtendremos un error de compilación y todos nuestros esfuerzos no tendrán sentido.  Pero aquí seremos ayudados por el conocimiento de la prioridad con la que el compilador llama a los métodos de extensión.  El punto es que las implementaciones específicas tienen prioridad sobre los métodos genéricos.  Es decir, en el siguiente ejemplo, se llamará al segundo método, no al primero: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeExtentions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Save&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> User user</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); user.Save(); } }</code> </pre> <br><p>  Esta característica es muy útil.  Simplemente definimos el <code>GetBakedType</code> genérico de la siguiente manera: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StubExtention</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Type&gt; GetBakedType&lt;TValue&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> TValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Type&gt;(); } }</code> </pre> <br><p>  Esto nos permitirá evitar un error de compilación al principio y generar nuestro propio "error" de compilación. </p><br><p>  Considere el analizador en sí.  Ofrecerá dos diagnósticos.  El primero es responsable del caso en que la generación del código no comenzó en absoluto, y el segundo cuando necesitamos actualizar un código existente.  Tendrán los siguientes nombres <code>SimpleReflectionIsNotReady</code> y <code>SimpleReflectionUpdate</code> respectivamente.  El primer diagnóstico generará un "error de compilación", y el segundo solo informa que aquí puede volver a ejecutar la generación de código. </p><br><p>  La descripción del diagnóstico es la siguiente: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SimpleReflectionIsNotReady = <span class="hljs-string"><span class="hljs-string">"SimpleReflectionIsNotReady"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SimpleReflectionUpdate = <span class="hljs-string"><span class="hljs-string">"SimpleReflectionUpdate"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DiagnosticDescriptor SimpleReflectionIsNotReadyDescriptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagnosticDescriptor( SimpleReflectionIsNotReady, <span class="hljs-string"><span class="hljs-string">"Simple reflection is not ready."</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection is not ready."</span></span>, <span class="hljs-string"><span class="hljs-string">"Codegen"</span></span>, DiagnosticSeverity.Error, isEnabledByDefault: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection is not ready."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DiagnosticDescriptor SimpleReflectionUpdateDescriptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagnosticDescriptor( SimpleReflectionUpdate, <span class="hljs-string"><span class="hljs-string">"Simple reflection update."</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection update."</span></span>, <span class="hljs-string"><span class="hljs-string">"Codegen"</span></span>, DiagnosticSeverity.Info, isEnabledByDefault: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection update."</span></span>);</code> </pre> <br><p>  A continuación, es necesario determinar qué buscaremos, en este caso será una llamada al método: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnalysisContext context</span></span></span><span class="hljs-function">)</span></span> { context.RegisterOperationAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HandelBuilder, OperationKind.Invocation); }</code> </pre> <br><p>  Entonces ya en <code>HandelBuilder</code> un análisis de árbol de sintaxis.  En la entrada, recibiremos todas las llamadas encontradas, por lo que debe eliminar todo excepto nuestro <code>GetBakedType</code> .  Esto se puede hacer con lo habitual <code>if</code> en el que verificamos el nombre del método.  Luego obtenemos el tipo de variable sobre la cual se llama a nuestro método e informamos al compilador sobre los resultados de nuestro análisis.  Esto puede ser un error de compilación si la generación del código aún no se ha iniciado o la capacidad de reiniciarlo. </p><br><p>  Todo se ve así: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandelBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OperationAnalysisContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Operation.Syntax <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> InvocationExpressionSyntax invocation &amp;&amp; invocation.Expression <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MemberAccessExpressionSyntax memberAccess &amp;&amp; memberAccess.Name <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IdentifierNameSyntax methodName &amp;&amp; methodName.Identifier.ValueText == <span class="hljs-string"><span class="hljs-string">"GetBakedType"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticModel = context.Compilation .GetSemanticModel(invocation.SyntaxTree); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeInfo = semanticModel .GetSpeculativeTypeInfo(memberAccess.Expression.SpanStart, memberAccess.Expression, SpeculativeBindingOption.BindAsExpression); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnosticProperties = ImmutableDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;.Empty.Add(<span class="hljs-string"><span class="hljs-string">"type"</span></span>, typeInfo.Type.ToDisplayString()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Compilation.GetTypeByMetadataName(typeInfo.Type.GetSimpleReflectionExtentionTypeName()) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> INamedTypeSymbol extention) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updateDiagnostic = Diagnostic.Create(SimpleReflectionUpdateDescriptor, methodName.GetLocation(), diagnosticProperties); context.ReportDiagnostic(updateDiagnostic); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnostic = Diagnostic.Create(SimpleReflectionIsNotReadyDescriptor, methodName.GetLocation(), diagnosticProperties); context.ReportDiagnostic(diagnostic); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Código analizador completo</b> <div class="spoiler_text"><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DiagnosticAnalyzer(LanguageNames.CSharp)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleReflectionAnalyzer</span></span> : <span class="hljs-title"><span class="hljs-title">DiagnosticAnalyzer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SimpleReflectionIsNotReady = <span class="hljs-string"><span class="hljs-string">"SimpleReflectionIsNotReady"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SimpleReflectionUpdate = <span class="hljs-string"><span class="hljs-string">"SimpleReflectionUpdate"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DiagnosticDescriptor SimpleReflectionIsNotReadyDescriptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagnosticDescriptor( SimpleReflectionIsNotReady, <span class="hljs-string"><span class="hljs-string">"Simple reflection is not ready."</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection is not ready."</span></span>, <span class="hljs-string"><span class="hljs-string">"Codegen"</span></span>, DiagnosticSeverity.Error, isEnabledByDefault: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection is not ready."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DiagnosticDescriptor SimpleReflectionUpdateDescriptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagnosticDescriptor( SimpleReflectionUpdate, <span class="hljs-string"><span class="hljs-string">"Simple reflection update."</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection update."</span></span>, <span class="hljs-string"><span class="hljs-string">"Codegen"</span></span>, DiagnosticSeverity.Info, isEnabledByDefault: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"Simple reflection update."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics =&gt; ImmutableArray.Create(SimpleReflectionIsNotReadyDescriptor, SimpleReflectionUpdateDescriptor); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnalysisContext context</span></span></span><span class="hljs-function">)</span></span> { context.RegisterOperationAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HandelBuilder, OperationKind.Invocation); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandelBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OperationAnalysisContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Operation.Syntax <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> InvocationExpressionSyntax invocation &amp;&amp; invocation.Expression <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MemberAccessExpressionSyntax memberAccess &amp;&amp; memberAccess.Name <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IdentifierNameSyntax methodName &amp;&amp; methodName.Identifier.ValueText == <span class="hljs-string"><span class="hljs-string">"GetBakedType"</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticModel = context.Compilation .GetSemanticModel(invocation.SyntaxTree); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeInfo = semanticModel .GetSpeculativeTypeInfo(memberAccess.Expression.SpanStart, memberAccess.Expression, SpeculativeBindingOption.BindAsExpression); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnosticProperties = ImmutableDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;.Empty.Add(<span class="hljs-string"><span class="hljs-string">"type"</span></span>, typeInfo.Type.ToDisplayString()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Compilation.GetTypeByMetadataName(typeInfo.Type.GetSimpleReflectionExtentionTypeName()) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> INamedTypeSymbol extention) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updateDiagnostic = Diagnostic.Create(SimpleReflectionUpdateDescriptor, methodName.GetLocation(), diagnosticProperties); context.ReportDiagnostic(updateDiagnostic); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnostic = Diagnostic.Create(SimpleReflectionIsNotReadyDescriptor, methodName.GetLocation(), diagnosticProperties); context.ReportDiagnostic(diagnostic); } } }</code> </pre> </div></div><br><h1 id="realizaciya-kodogeneratora">  Implementación de generador de código </h1><br><p>  <code>CodeFixProvider</code> través de <code>CodeFixProvider</code> , que está suscrito a nuestro analizador.  En primer lugar, debemos verificar qué sucedió para encontrar nuestro analizador. </p><br><p>  Se ve así: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sealed</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterCodeFixesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CodeFixContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnostic = context.Diagnostics.First(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title = diagnostic.Severity == DiagnosticSeverity.Error ? <span class="hljs-string"><span class="hljs-string">"Generate simple reflection"</span></span> : <span class="hljs-string"><span class="hljs-string">"Recreate simple reflection"</span></span>; context.RegisterCodeFix( CodeAction.Create( title, createChangedDocument: token =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateFormatterAsync(context, diagnostic, token), equivalenceKey: title), diagnostic); }</code> </pre> <br><p>  Toda la magia ocurre dentro de <code>CreateFormatterAsync</code> .  En él obtenemos una descripción completa del tipo.  Luego comenzamos la generación de código y agregamos un nuevo archivo al proyecto. </p><br><p>  Obteniendo información y agregando un archivo: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Document&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFormatterAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CodeFixContext context, Diagnostic diagnostic, CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeName = diagnostic.Properties[<span class="hljs-string"><span class="hljs-string">"type"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentDocument = context.Document; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Document.GetSemanticModelAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> symbol = model.Compilation.GetTypeByMetadataName(typeName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawSource = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BuildSimpleReflection(symbol); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = Formatter.Format(SyntaxFactory.ParseSyntaxTree(rawSource).GetRoot(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AdhocWorkspace()).ToFullString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileName = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.GetSimpleReflectionExtentionTypeName()}</span></span></span><span class="hljs-string">.cs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Document.Project.Documents.FirstOrDefault(o =&gt; o.Name == fileName) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Document document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> document.WithText(SourceText.From(source)); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> folders = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"SimpeReflection"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentDocument.Project .AddDocument(fileName, source) .WithFolders(folders); }</code> </pre> <br><p>  Generación de código propio (sospecho que el hub romperá toda la subred): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildSimpleReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">INamedTypeSymbol symbol</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">$@" using System; using System.Collections.Generic; // Simple reflection for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.ToDisplayString()}</span></span></span><span class="hljs-string"> public static class </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.GetSimpleReflectionExtentionTypeName()}</span></span></span><span class="hljs-string"> {{ private static Dictionary&lt;string, Type&gt; properties = new Dictionary&lt;string, Type&gt; {{ </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ symbol .GetAllMembers() .OfType&lt;IPropertySymbol&gt;() .Where(o =&gt; (o.DeclaredAccessibility &amp; Accessibility.Public) &gt; </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) .Select(o =&gt; </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">$@" {{ ""</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Name}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"", typeof(</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Type.ToDisplayString()}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">)}},"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) .JoinWithNewLine() }</span></span></span><span class="hljs-string"> }}; public static Dictionary&lt;string, Type&gt; GetBakedType(this global::</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.ToDisplayString()}</span></span></span><span class="hljs-string"> value) {{ return properties; }} }} "</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Generador de código completo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.CodeActions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.CodeFixes; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.CSharp; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.Formatting; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SimpleReflection.Utils; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Immutable; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Composition; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">SimpleReflection</span></span> { [ExportCodeFixProvider(LanguageNames.CSharp, Name = <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(SimpleReflectionCodeFixProvider)), Shared] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleReflectionCodeFixProvider</span></span> : <span class="hljs-title"><span class="hljs-title">CodeFixProvider</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> ImmutableArray&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; FixableDiagnosticIds =&gt; ImmutableArray.Create(SimpleReflectionAnalyzer.SimpleReflectionIsNotReady, SimpleReflectionAnalyzer.SimpleReflectionUpdate); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sealed</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> FixAllProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFixAllProvider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WellKnownFixAllProviders.BatchFixer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sealed</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterCodeFixesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CodeFixContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnostic = context.Diagnostics.First(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title = diagnostic.Severity == DiagnosticSeverity.Error ? <span class="hljs-string"><span class="hljs-string">"Generate simple reflection"</span></span> : <span class="hljs-string"><span class="hljs-string">"Recreate simple reflection"</span></span>; context.RegisterCodeFix( CodeAction.Create( title, createChangedDocument: token =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateFormatterAsync(context, diagnostic, token), equivalenceKey: title), diagnostic); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Document&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFormatterAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CodeFixContext context, Diagnostic diagnostic, CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeName = diagnostic.Properties[<span class="hljs-string"><span class="hljs-string">"type"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentDocument = context.Document; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Document.GetSemanticModelAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> symbol = model.Compilation.GetTypeByMetadataName(typeName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> symbolName = symbol.ToDisplayString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawSource = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BuildSimpleReflection(symbol); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = Formatter.Format(SyntaxFactory.ParseSyntaxTree(rawSource).GetRoot(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AdhocWorkspace()).ToFullString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileName = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.GetSimpleReflectionExtentionTypeName()}</span></span></span><span class="hljs-string">.cs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Document.Project.Documents.FirstOrDefault(o =&gt; o.Name == fileName) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Document document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> document.WithText(SourceText.From(source)); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> folders = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"SimpeReflection"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentDocument.Project .AddDocument(fileName, source) .WithFolders(folders); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildSimpleReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">INamedTypeSymbol symbol</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">$@" using System; using System.Collections.Generic; // Simple reflection for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.ToDisplayString()}</span></span></span><span class="hljs-string"> public static class </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.GetSimpleReflectionExtentionTypeName()}</span></span></span><span class="hljs-string"> {{ private static Dictionary&lt;string, Type&gt; properties = new Dictionary&lt;string, Type&gt; {{ </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ symbol .GetAllMembers() .OfType&lt;IPropertySymbol&gt;() .Where(o =&gt; (o.DeclaredAccessibility &amp; Accessibility.Public) &gt; </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) .Select(o =&gt; </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">$@" {{ ""</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Name}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"", typeof(</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Type.ToDisplayString()}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">)}},"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) .JoinWithNewLine() }</span></span></span><span class="hljs-string"> }}; public static Dictionary&lt;string, Type&gt; GetBakedType(this global::</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{symbol.ToDisplayString()}</span></span></span><span class="hljs-string"> value) {{ return properties; }} }} "</span></span>; } }</code> </pre> </div></div><br><h1 id="itogi">  Resumen </h1><br><p>  Como resultado, tenemos un generador de código de analizador Roslyn con la ayuda del cual se implementa una reflexión "pequeña" mediante la generación de código.  Será difícil encontrar una aplicación real para la biblioteca actual, pero será un gran ejemplo para implementar generadores de código fácilmente accesibles.  Este enfoque puede ser, como cualquier generación de código, útil para escribir serializadores.  Mi implementación de prueba de MessagePack funcionó ~ 20% más rápido que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">neuecc / MessagePack-CSharp</a> , y todavía no he visto un serializador más rápido.  Además, este enfoque no requiere <code>Roslyn.Emit</code> , que es perfecto para los escenarios Unity y AOT. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455952/">https://habr.com/ru/post/455952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455942/index.html">Protocolo para la comunicación entre el iframe y la ventana principal del navegador</a></li>
<li><a href="../455944/index.html">Rastrillo en el trabajo con autónomos. Aprendiendo a moverse</a></li>
<li><a href="../455946/index.html">Contenido prohibido en Google Play - búsqueda de supervivencia</a></li>
<li><a href="../455948/index.html">RAMBleed: recupera una clave RSA en 34 horas</a></li>
<li><a href="../455950/index.html">Los lenguajes de programación más raros y caros. Parte II</a></li>
<li><a href="../455954/index.html">Uso y protección del legado en el mundo moderno.</a></li>
<li><a href="../455956/index.html">Chromium no es solo un navegador, sino también un buen marco</a></li>
<li><a href="../455958/index.html">Autómatas celulares en evolución</a></li>
<li><a href="../455962/index.html">Conferencia de ciencia de datos y trópicos</a></li>
<li><a href="../455968/index.html">Hago un medio engranaje grande en paneles solares por 250,000 rublos (1 parte)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>