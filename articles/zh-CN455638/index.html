<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐒 🛀🏽 🏂🏼 艾伦·凯（Alan Kay）没有发明物体 👨🏻‍🌾 🎳 🐂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="人们继续争辩说，现代面向对象的语言实际上“不是完全面向对象的”，因为它们不符合OOP Alan Kay的定义。 我认为这是有道理的，尽管我不同意结论。 最近，我遇到一些人，说是凯发明了这些物体。 这实际上是不正确的。 


 艾伦·凯（Alan Kay）没有发明物体。 他们在Simula中 ，这导致...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>艾伦·凯（Alan Kay）没有发明物体</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455638/"><p> 人们继续争辩说，现代面向对象的语言实际上“不是完全面向对象的”，因为它们不符合OOP Alan Kay的定义。 我认为这是有道理的，尽管我不同意结论。 最近，我遇到一些人，说是凯发明了这些物体。 这实际上是不正确的。 </p><br><p> 艾伦·凯（Alan Kay）没有发明物体。 他们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Simula中</a> ，这导致<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Smalltalk-72</a>成为主要的灵感来源（第117页）。  1981年发行的Byte杂志，普及了Smalltalk和OOP的流行杂志<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说</a> ：“对象，消息和类的基本思想来自SIMULA。” 它说Simula允许用户创建“面向对象的系统”，这可能太多了，但是仍然如此。  Smalltalk团队非常了解Simula对象系统，并从中汲取了灵感。 </p><br><p> 这样的神话仍然存在的原因之一是凯本人在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1998年</a>所说的话： </p><br><blockquote> 我只是想提醒您，在上一个OOPSLA中，我试图向所有人传达，Smalltalk不仅不是语法或类库，甚至也不是类。 非常抱歉，我之前为该主题创造了“对象”一词，因为它使许多人专注于一个较小的主意。 </blockquote><a name="habracut"></a><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这次采访中，</a>他继续说道： </p><br><blockquote> 我的意思是，我发明了“对象”一词。 由于我们首先制造了物体，因此没有其他物体可以使之激化。 </blockquote><p> 后来他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不再说了</a> ，但人们仍然继续使用该报价作为事实。 </p><br><h1 id="alan-key-izobrel-termin-obektno-orientirovannoe-programmirovanie">  Alan Kay发明了术语“面向对象的编程” </h1><br><p> 这是绝对正确的。 </p><br><h1 id="oop-bylo-v-klassah-i-obektah">  OOP在类和对象中 </h1><br><p> 最近，许多人继续争论OOP实际上不在类和对象中，而实际上，最重要的消息却在其中。 在1998年的一篇文章中，凯说他对“对象”感到后悔之后，他还说“一个好主意是消息传递”。 他进一步<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">写道</a> ： </p><br><blockquote> 对我而言，OOP只是消息，本地保留和保护，隐藏状态并在以后绑定所有内容。 这可以在Smalltalk和LISP中完成。 可能还有其他系统可以实现，但我不知道它们。 </blockquote><p> 在早期的OOP中，主要将消息视为重要的，主要是对于服务设施。 这是Don Ingalls在他对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Smalltalk-76的</a>介绍中对OOP的解释： </p><br><blockquote> Smalltalk更加面向对象，而不是面向功能，这经常使具有计算机科学经验的人感到困惑。 例如， <code>&lt;someobject&gt;+4</code>意味着将<code>+4</code>作为消息发送<code>+4</code>对象。 主要区别在于，所有事物都是由对象而不是<code>+</code> 。 如果<code>&lt;someobject&gt;</code>是3的整数，则结果是7的整数。但是，如果<code>&lt;someobject&gt;</code>是字符串<code>'Meta'</code> ，则结果可能是<code>Meta4</code> 。 因此，语义负载与系统对象一起出现，并且代码仍然是抽象形式，仅指导消息流。 </blockquote><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微电子学和个人计算机中，</a> Kay讨论了一个“消息到行动”系统，其中“每个动作都属于一个家庭”，并谈到了在对象关系的“观点”（作为未来的前沿）中扩展活动。 他在Smalltalk-72手册中写道（第18页）： </p><br><blockquote> 编写Small Talk程序时，主要思想是定义用于处理所创建环境中对象之间关系的类。 </blockquote><p> 在查看早期资源时，可以看到OOP由三个主要思想组成：定义协议和实现的类，作为类实例的对象和作为通信手段的消息。 类和对象是消息的第二要件的想法来得很晚。 </p><br><h1 id="smalltalk-byl-pervym-nastoyaschim-obektno-orientirovannym-yazykom">  Smalltalk是第一种真正的面向对象语言 </h1><br><p>  ACM向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图尔</a>和Nyugor展示了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图灵首映式</a> ，并称他们为“ PLO合著者”。  Byte还写道Simula是面向对象的，并且在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“计算机革命尚未发生”一文中，</a> Kay称Sketchpad为“非常面向对象的”。 我认为，这并没有充分承认Smalltalk的优点。 与其他系统不同，在Smalltalk中： </p><br><ul><li> 没有没有对象的原语：数字是对象，错误是对象，类是对象，消息是对象。 </li><li> 您可以将消息传递给任何对象，包括其他消息。 </li><li> 方法和实现与对象关联，而不与会话关联。 </li></ul><br><p> 最后一点是最棘手的，也可能是最重要的，尽管没有人真正解释它的特殊之处。 在Simula中，调用缺少的方法会导致错误。 这是Simula规范的一部分。 在Smalltalk-80中，如果没有方法与该消息匹配，则默认对象将返回<code>doesNotUnderstand</code>消息。 呼叫者可以对其进行响应，或者传递消息，或者发出错误信号。 类还可以覆盖默认操作，并执行除返回<code>doesNotUnderstand</code>其他<code>doesNotUnderstand</code> 。 </p><br><p> 这也意味着消息传递系统不依赖于对象的内部结构。 他们甚至不必成为一个项目的一部分。 因此，您可以执行以下操作：向以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不同语言</a>编写的对象发送消息，通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮件</a>发送对象定义，通过SMS发送消息等。 我认为，这恰恰是“消息传递”的力量，但同时，它也是研究最少的方面之一。 </p><br><h1 id="u-smalltalk-byl-okruzhayuschiy-kontekst">  Smalltalk具有周围环境 </h1><br><p> 人们不会自发地发明工具。 他们有特定的情况和任务，并且正在尝试找到这些问题的解决方案。  Smalltalk和OOP的创新也不例外。 </p><br><p> 艾伦·凯（Alan Kay）对个人计算机感兴趣。 他在FLEX，Dynabook和Smalltalk上的工作就是以此为基础的。 在他看来，PC应该已经完全在用户的控制之下了。 从系统核心逻辑到图形渲染的所有内容都可以在操作期间进行设置和探索。 消息传递和后期绑定解决了许多问题。 如果孩子安装了新游戏，我是否需要重新编译整个操作系统才能使用新程序？ 否：可以向任意对象发送任意消息，并在工作过程中依靠协议处理来完成任务（*）如果有人违反了声音系统的逻辑，整个操作系统是否应该掉下来？ 当然不是，所以让对象决定如何自行处理消息。 对象在这里表现良好。 </p><br><p>  Ole Dahl和Kirsten Nyugor试图解决一个完全不同的问题。 他们对<em>模拟</em>感兴趣。  Simula指南中的一项研究是对感染在固定人群中的传播进行建模。 系统是完全封闭的：您有一组固定的代码，可以运行模拟并获得结果。 对于他们来说，消息传递是没有用的。 但是根据其他模拟定义模拟，将实体和模型时间专门化为第一类对象的能力非常有用。 对象在这里<em>也</em>表现良好。 </p><br><p> 那么，谁正确地使用了这些物体？ 这是一个不合理的问题。 他们做了不同的事情，因为他们有不同的任务。 我们现代的OOP思想是他们所有思想以及Adele Goldberg，Barbara Liskov，David Parnassus，Bertrand Meyer，Gul Ag等许多思想的综合。 但是他们谁也说不出“ OOP”是什么。 概念和任务在不断发展。 </p><br><h1 id="tldr">  tl;博士 </h1><br><p> 三十多年前的采访不是很好的消息来源。 </p><br><hr><br><p>  *也许这使Powershell成为Smalltalk的精神继任者。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455638/">https://habr.com/ru/post/zh-CN455638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455626/index.html">Wallarm Offzone2019 HackQuest</a></li>
<li><a href="../zh-CN455630/index.html">6月11日至16日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN455632/index.html">注意！ C ++实现std ::映射:: merge :: std :: set :: Visual Studio 2017中的合并::危险错误</a></li>
<li><a href="../zh-CN455634/index.html">数学和游戏“ Set”</a></li>
<li><a href="../zh-CN455636/index.html">第一波受Exim漏洞影响。 治疗脚本</a></li>
<li><a href="../zh-CN455640/index.html">马文·明斯基（Marvin Minsky）的“情感机器”：第4章。“我们如何认识意识”</a></li>
<li><a href="../zh-CN455642/index.html">Yandex.Cloud中的分布式消息队列服务的体系结构</a></li>
<li><a href="../zh-CN455644/index.html">我们在实践中使用数据</a></li>
<li><a href="../zh-CN455646/index.html">安全周24：Android智能手机上的工厂后门</a></li>
<li><a href="../zh-CN455648/index.html">生命周期ML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>