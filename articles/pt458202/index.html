<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèΩ üë®üèø‚Äçü§ù‚Äçüë®üèæ ü•ã Basta dar uma olhada no SObjectizer se voc√™ quiser usar atores ou CSP no seu projeto C ++ ü§¥üèº üôåüèº üòå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algumas palavras sobre o SObjectizer e sua hist√≥ria 


 O SObjectizer √© uma estrutura C ++ bastante pequena que simplifica o desenvolvimento de aplica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Basta dar uma olhada no SObjectizer se voc√™ quiser usar atores ou CSP no seu projeto C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458202/"><p><img src="https://habrastorage.org/webt/qq/0_/at/qq0_atvjcf2gb0uklnpqjbl31hw.jpeg"></p><br><h1 id="a-few-words-about-sobjectizer-and-its-history">  Algumas palavras sobre o SObjectizer e sua hist√≥ria </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">O SObjectizer</a> √© uma estrutura C ++ bastante pequena que simplifica o desenvolvimento de aplicativos multithread.  O SObjectizer permite que um desenvolvedor use abordagens dos modelos Actor, Publish-Subscribe e Communicating Sequential Processes (CSP).  √â um projeto OpenSource que √© distribu√≠do sob a licen√ßa BSD-3-CLAUSE. </p><br><p>  O SObjectizer tem uma longa hist√≥ria.  O SObjectizer nasceu em 2002 como projeto SObjectizer-4.  Mas foi baseado em id√©ias do SCADA Objectizer anterior, desenvolvido entre 1995 e 2000. O SObjectizer-4 foi de c√≥digo aberto em 2006, mas sua evolu√ß√£o foi interrompida logo depois.  Uma nova vers√£o do SObjectizer com o nome SObjectizer-5 foi iniciada em 2010 e de c√≥digo aberto em 2013. A evolu√ß√£o do SObjectizer-5 ainda est√° em andamento e o SObjectizer-5 incorporou muitos novos recursos desde 2013. </p><br><p>  O SObjectizer √© mais ou menos conhecido no segmento russo da Internet, mas quase desconhecido fora do exUSSR.  √â porque o SObjectizer foi usado principalmente para projetos locais nos pa√≠ses exUSSR e muitos artigos, apresenta√ß√µes e palestras sobre o SObjectizer est√£o em russo. </p><br><h1 id="a-niche-for-sobjectizer-and-similar-tools">  Um nicho para SObjectizer e ferramentas similares </h1><br><p>  O multithreading √© usado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">computa√ß√£o paralela</a> e na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">computa√ß√£o simult√¢nea</a> .  Mas h√° uma grande diferen√ßa entre computa√ß√£o paralela e simult√¢nea.  E, como conseq√º√™ncia, existem ferramentas direcionadas √† computa√ß√£o paralela, e existem ferramentas para computa√ß√£o simult√¢nea, e elas s√£o diferentes. </p><a name="habracut"></a><br><p>  Grosso modo, a computa√ß√£o paralela √© sobre o uso de v√°rios n√∫cleos para reduzir o tempo de c√°lculo.  Por exemplo, a transcodifica√ß√£o de um arquivo de v√≠deo de um formato para outro pode levar uma hora em um n√∫cleo da CPU, mas apenas 15 minutos em quatro n√∫cleos da CPU.  Ferramentas como OpenMP, Intel TBB, HPX ou cpp-taskflow foram projetadas para serem usadas na computa√ß√£o paralela.  E essas ferramentas oferecem suporte apropriado para abordagens dessa √°rea, como programa√ß√£o baseada em tarefas ou fluxo de dados. </p><br><p>  A computa√ß√£o simult√¢nea trata de lidar com muitas tarefas (provavelmente diferentes) ao mesmo tempo.  O servidor de banco de dados ou o MQ-broker podem ser bons exemplos: um servidor precisa aceitar uma conex√£o, ler e analisar dados de conex√µes aceitas, manipular solicita√ß√µes recebidas (executando v√°rias a√ß√µes para cada solicita√ß√£o), enviando respostas e assim por diante.  A rigor, n√£o h√° necessidade de usar multithreading na computa√ß√£o simult√¢nea: todas essas tarefas podem ser executadas em apenas um thread de trabalho.  Mas o uso de multithreading e v√°rios n√∫cleos de CPU pode tornar seu aplicativo mais eficiente, escal√°vel e responsivo. </p><br><p>  Abordagens como o modelo do ator ou o CSP destinam-se a lidar com a computa√ß√£o simult√¢nea.  Bons exemplos de uso Os atores na √°rea de computa√ß√£o simult√¢nea s√£o o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">projeto InfineSQL</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Yandex Message-Queue</a> .  Ambos os projetos usam atores internos. </p><br><p>  Portanto, ferramentas como SObjectizer, QP / C ++ ou CAF, que suportam o Actor Model, s√£o √∫teis na resolu√ß√£o de tarefas da √°rea de computa√ß√£o simult√¢nea.  Isso significa que o uso do SObjectizer provavelmente n√£o fornecer√° nada em tarefas como a convers√£o de fluxos de v√≠deo.  Mas voc√™ pode obter um resultado muito diferente implementando um intermedi√°rio de mensagens no SObjectizer. </p><br><h2 id="disclaimer">  Isen√ß√£o de responsabilidade </h2><br><p>  O uso de modelos de ator ou CSP pode oferecer enormes benef√≠cios em algumas tarefas, mas n√£o h√° garantias de que esses modelos sejam apropriados para o seu problema espec√≠fico.  A discuss√£o sobre a aplicabilidade dos modelos de ator ou CSP est√° al√©m do escopo desse artigo.  Vamos supor que o modelo de ator ou / e CSP seja aplic√°vel √†s suas tarefas e voc√™ saiba como us√°-las com efici√™ncia. </p><br><h1 id="what-sobjectizer-can-give-to-a-user">  O SObjectizer pode dar a um usu√°rio? </h1><br><h2 id="shared-nothing-and-fire-and-forget-principles-just-out-of-box">  Princ√≠pios de nada compartilhado e de ignorar apenas fora da caixa </h2><br><p>  O uso de atores pressup√µe a aus√™ncia de quaisquer dados compartilhados.  Todo ator possui seus dados e esses dados n√£o s√£o vis√≠veis para mais ningu√©m.  Esse √© <em>um princ√≠pio de nada compartilhado</em> que √© bem conhecido no desenvolvimento de aplicativos distribu√≠dos, por exemplo.  No aplicativo multithread, o princ√≠pio de compartilhamento de nada tem um benef√≠cio importante: permite evitar problemas perigosos para trabalhar com dados compartilhados, como deadlocks e data-races. </p><br><p>  A intera√ß√£o entre atores (agentes) no SObjectizer √© realizada apenas atrav√©s de mensagens ass√≠ncronas.  Um agente envia uma mensagem para outro agente e essa opera√ß√£o n√£o bloqueia o remetente (em um caso comum). </p><br><p>  A intera√ß√£o ass√≠ncrona permite usar outro princ√≠pio √∫til: <em>disparar e esquecer</em> .  Quando um agente precisa de alguma opera√ß√£o, ele envia (dispara) uma mensagem e continua seu trabalho.  Na maioria dos casos, a mensagem ser√° recebida e processada. </p><br><p>  Por exemplo, pode haver um agente que l√™ as conex√µes aceitas e analisa os dados recebidos.  Se toda a PDU for lida e analisada, o agente envia a PDU para outro agente-processador e volta a ler / analisar novos dados recebidos. </p><br><h2 id="dispatchers">  Despachantes </h2><br><p>  Os expedidores s√£o uma das pedras angulares do SObjectizer.  Os expedidores fornecem um contexto de trabalho (tamb√©m conhecido como thread de trabalho) no qual um agente manipula as mensagens recebidas.  Em vez de criar threads de trabalho (ou conjuntos de threads) manualmente, um usu√°rio cria expedidores e vincula agentes a eles.  Um usu√°rio pode criar quantos expedidores em um aplicativo quiser. </p><br><p>  A melhor coisa com despachantes e agentes no SObjectizer √© a separa√ß√£o de conceitos: despachantes s√£o respons√°veis ‚Äã‚Äãpor gerenciar o contexto de trabalho e as pr√≥prias filas de mensagens, os agentes executam a l√≥gica do aplicativo e n√£o se preocupam com o contexto do trabalhador.  Permite mover um agente de um despachante para outro literalmente com um clique.  Ontem, um agente trabalhou no despachante one_thread, hoje podemos reconect√°-lo ao despachante active_obj e amanh√£ podemos reconfigur√°-lo ao despachante thread_pool.  Sem alterar uma linha na implementa√ß√£o do agente. </p><br><p>  Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">oito tipos de despachantes no SObjectizer-5.6.0</a> (e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">outro</a> pode ser encontrado no projeto complementar so5extra): come√ßando de muito simples (one_thread ou thread_pool) a sofisticados (como adv_thread_pool ou prio_dedicated_threads :: one_per_prio).  E um usu√°rio pode escrever seu pr√≥prio despachante para condi√ß√µes espec√≠ficas. </p><br><h2 id="hierarchical-state-machines-are-built-in-functionality">  M√°quinas de estado hier√°rquicas s√£o funcionalidade incorporada </h2><br><p>  Os agentes (atores) no SObjectizer s√£o m√°quinas de estado: a rea√ß√£o em uma mensagem recebida depende do estado atual do agente.  O SObjectizer suporta a maioria dos recursos de m√°quinas de estado hier√°rquico (HSM): estados aninhados, hist√≥rico profundo e raso de um estado, manipuladores on_enter / on_exit, limites de tempo para permanecer em um estado.  Somente estados ortogonais n√£o s√£o suportados no SObjectizer agora (n√£o vimos a necessidade desse recurso em nossos projetos e ningu√©m nos pediu para adicionar suporte a esse recurso). </p><br><h2 id="csp-like-channels-just-out-of-box">  Canais do tipo CSP prontos para uso </h2><br><p> N√£o h√° necessidade de usar agentes do SObjectizer (tamb√©m conhecidos como atores).  Todo o aplicativo pode ser desenvolvido usando apenas objetos <code>std::thread</code> e mchains do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">SObjectizer (tamb√©m conhecidos como canais CSP)</a> .  Nesse caso, o desenvolvimento de aplicativos com o SObjectizer ser√° um pouco semelhante ao desenvolvimento na linguagem Go (incluindo um anal√≥gico da constru√ß√£o de <code>select</code> Go que permite aguardar mensagens de v√°rios canais). </p><br><p>  As mchains do SObjectizer podem ter uma caracter√≠stica muito importante: mecanismo incorporado de contrapress√£o.  Se um usu√°rio criar um mchain com tamanho limitado e tentar enviar uma mensagem para o mchain completo, a opera√ß√£o de envio poder√° bloquear o remetente por algum tempo.  Permite resolver um problema famoso com um produtor r√°pido e um consumidor lento. </p><br><p>  Os mchains do SObjectizer t√™m outra caracter√≠stica interessante: um mchain pode ser usado como uma ferramenta de distribui√ß√£o de carga muito simples.  V√°rios threads podem esperar o <em>recebimento</em> do mesmo mchain ao mesmo tempo.  Se uma nova mensagem for enviada para esse mchain, apenas um thread ler√° e manipular√° essa mensagem. </p><br><h2 id="only-a-part-of-an-application-can-use-sobjectizer">  Somente uma parte de um aplicativo pode usar o SObjectizer </h2><br><p>  N√£o h√° necessidade de usar o SObjectizer em todas as partes de um aplicativo.  Apenas uma parte de um aplicativo pode ser desenvolvida usando o SObjectizer.  Portanto, se voc√™ j√° usa Qt ou wxWidgets ou Boost.Asio como a estrutura principal do seu aplicativo, √© poss√≠vel usar o SObjectize em apenas um subm√≥dulo do seu aplicativo. </p><br><p>  Tivemos experi√™ncia no uso do SObjectizer para desenvolvimento de bibliotecas que ocultam o uso do SObjectizer como um detalhe de implementa√ß√£o.  A API p√∫blica dessas bibliotecas n√£o exp√¥s a presen√ßa de SObjectizer.  O SObjectizer estava totalmente sob o controle de uma biblioteca: a biblioteca iniciou e parou o SObjectizer conforme necess√°rio.  Essas bibliotecas foram usadas em aplicativos que desconheciam completamente a presen√ßa do SObjectizer. </p><br><p>  Se o SObjectizer for usado apenas em uma parte de um aplicativo, haver√° uma tarefa de comunica√ß√£o entre as partes do SObjectizer e n√£o-SObjectizer do aplicativo.  Esta tarefa √© facilmente resolvida: as mensagens de uma parte que n√£o seja do SObjectizer para a parte do SObjectizer podem ser enviadas atrav√©s do mecanismo comum do SObjectizer de entrega de mensagens.  Mensagens na dire√ß√£o oposta podem ser entregues via mchains. </p><br><h2 id="you-can-run-several-instances-of-sobjectizer-at-the-same-time">  Voc√™ pode executar v√°rias inst√¢ncias do SObjectizer ao mesmo tempo </h2><br><p>  O SObjectizer permite executar v√°rias inst√¢ncias do SObjectizer (chamado SObjectizer Environment) em um aplicativo ao mesmo tempo.  Todo ambiente SObjectizer ser√° independente de outros ambientes. </p><br><p>  Esse recurso √© inestim√°vel em situa√ß√µes em que voc√™ precisa criar um aplicativo a partir de v√°rios m√≥dulos independentes.  Alguns m√≥dulos podem usar o SObjectizer, outros n√£o.  Os m√≥dulos que requerem o SObjectizer podem executar sua c√≥pia do SObjectizer Environment e n√£o ter√£o influ√™ncia em outros m√≥dulos no aplicativo. </p><br><h2 id="timers-are-part-of-sobjectizer">  Os temporizadores fazem parte do SObjectizer </h2><br><p>  O suporte de cron√¥metros na forma de mensagens atrasadas e peri√≥dicas √© outro dos pilares do SObjectizer.  O SObjectizer possui v√°rias implementa√ß√µes de mecanismos de timer (timer_wheel, timer_heap e timer_list) e pode lidar com dezenas, centenas e milhares de milh√µes de timers em um aplicativo.  Um usu√°rio pode escolher o mecanismo de timer mais apropriado para um aplicativo.  Al√©m disso, um usu√°rio pode fornecer sua pr√≥pria implementa√ß√£o de timer_thread / timer_manager se nenhum dos padr√µes for apropriado para as condi√ß√µes do usu√°rio. </p><br><h2 id="sobjectizer-has-various-customization-points-and-tuning-options">  O SObjectizer possui v√°rios pontos de personaliza√ß√£o e op√ß√µes de ajuste </h2><br><p>  O SObjectizer permite a personaliza√ß√£o de v√°rios mecanismos importantes.  Por exemplo, um usu√°rio pode selecionar uma das implementa√ß√µes padr√£o de timer_thread (ou timer_manager).  Ou pode fornecer sua pr√≥pria implementa√ß√£o.  Um usu√°rio pode selecionar uma implementa√ß√£o de objetos de bloqueio usados ‚Äã‚Äãpor filas de mensagens nos despachantes do SObjectizer.  Ou pode fornecer sua pr√≥pria implementa√ß√£o. </p><br><p>  Um usu√°rio pode implementar seu pr√≥prio despachante.  Um usu√°rio pode implementar sua pr√≥pria caixa de mensagem.  Um usu√°rio pode implementar seu pr√≥prio envelope de mensagem.  Um usu√°rio pode implementar seu pr√≥prio event_queue_hook.  E assim por diante </p><br><h1 id="where-sobjectizer-can-or-cant-be-used">  Onde o SObjectizer pode ou n√£o pode ser usado? </h1><br><p>  √â muito mais f√°cil dizer onde o SObjectizer n√£o pode ser usado por raz√µes objetivas.  Ent√£o, come√ßamos a discuss√£o enumerando essas √°reas e, em seguida, daremos alguns exemplos do uso do SObjectizer no passado (e n√£o apenas no passado). </p><br><h2 id="where-sobjectizer-cant-be-used">  Onde o SObjectizer n√£o pode ser usado? </h2><br><h3 id="tasks-related-to-parallel-computing">  Tarefas relacionadas √† computa√ß√£o paralela </h3><br><p>  Como j√° foi dito acima, os modelos de ator e CSP n√£o s√£o uma boa op√ß√£o para computa√ß√£o de alto desempenho e outras √°reas da computa√ß√£o paralela.  Portanto, se voc√™ precisar fazer v√°rias matrizes ou transcodificar fluxos de v√≠deo, ferramentas como OpenMP, Intel TBB, cpp-taskflow, HPX ou MPI ser√£o mais adequadas. </p><br><h3 id="hard-real-time-systems">  Sistemas r√≠gidos em tempo real </h3><br><p>  Apesar do SObjectizer ter suas ra√≠zes nos sistemas SCADA, a implementa√ß√£o atual do SObjectizer (tamb√©m conhecida como SObjectizer-5) n√£o pode ser usada em sistemas r√≠gidos em tempo real.  Isso ocorre principalmente devido ao uso de mem√≥ria din√¢mica na implementa√ß√£o do SObjectizer: as mensagens s√£o objetos alocados dinamicamente (no entanto, o SObjectizer pode usar objetos pr√©-alocados como mensagens), os despachantes usam a mem√≥ria din√¢mica nas filas de mensagens, e os prazos dos estados dos agentes usam objetos alocados dinamicamente. para verificar o tempo. </p><br><p>  Infelizmente, o termo "tempo real" √© muito usado no mundo moderno.  Costuma-se dizer sobre servi√ßos da web em tempo real, como "aplicativo da web em tempo real" ou "an√°lise da web em tempo real" e assim por diante.  O termo "on-line" ou "ao vivo" √© mais apropriado para esses aplicativos do que o termo "em tempo real", mesmo na forma "soft-real-time".  Portanto, se falamos de algo como "aplicativo da web em tempo real", o SObjectizer pode ser facilmente usado nesses sistemas "em tempo real". </p><br><h3 id="constrained-embedded-systems">  Sistemas embarcados restritos </h3><br><p>  O SObjectizer conta com a biblioteca padr√£o C ++: <code>std::thread</code> √© usado para gerenciamento de threads, <code>std::atomic</code> , <code>std::mutex</code> , <code>std::condition_variable</code> s√£o usados ‚Äã‚Äãpara sincroniza√ß√£o de dados, RTTI e <code>dynamic_cast</code> s√£o usados ‚Äã‚Äãno SObjectizer de tamanho (por exemplo , <code>std::type_index</code> s√£o usados ‚Äã‚Äãpara identifica√ß√£o do tipo de mensagem), exce√ß√µes C ++ s√£o usadas para relat√≥rio de erros. </p><br><p>  Isso significa que o SObjectizer n√£o pode ser usado em ambientes onde esses recursos da biblioteca padr√£o n√£o est√£o dispon√≠veis.  Por exemplo, no desenvolvimento de sistemas embarcados restritos, onde apenas uma parte do C ++ e C ++ stdlib pode ser usada. </p><br><h2 id="where-sobjectizer-was-used-in-the-past">  Onde o SObjectizer foi usado no passado? </h2><br><p>  Agora tentamos falar brevemente sobre alguns casos de uso do SObjectizer no passado (e n√£o apenas no passado).  Infelizmente, n√£o h√° informa√ß√µes completas porque existem alguns problemas. </p><br><p>  Primeiro de tudo, n√£o sabemos sobre todos os usos do SObjectizer.  O SObjectizer √© um software livre que pode ser usado mesmo em projetos propriet√°rios.  Ent√£o, algumas pessoas simplesmente obt√™m o SObjectizer e o usam sem fornecer nenhum feedback para n√≥s.  √Äs vezes, adquirimos algumas informa√ß√µes sobre o uso do SObjectizer (mas sem detalhes), √†s vezes n√£o sabemos nada. </p><br><p>  O segundo problema √© a permiss√£o para compartilhar informa√ß√µes sobre o uso do SObjectizer em um projeto espec√≠fico.  Recebemos essa permiss√£o muito raramente; na maioria dos casos, os usu√°rios do SObjectizer n√£o desejam abrir detalhes de implementa√ß√£o de seus projetos (√†s vezes entendemos os motivos, √†s vezes n√£o). </p><br><p>  Pedimos desculpas pelo fato de as informa√ß√µes fornecidas parecerem t√£o escassas e n√£o conterem detalhes.  No entanto, existem alguns exemplos de uso do SObjectizer: </p><br><ul><li>  Gateway de agrega√ß√£o SMS / USSD que lida com mais de 500 milh√µes de mensagens por m√™s; </li><li>  parte do sistema que atende pagamentos on-line via caixas eletr√¥nicos de um dos maiores bancos russos; </li><li>  modelagem de simula√ß√£o de processos econ√¥micos (como parte da pesquisa de doutorado); </li><li>  aquisi√ß√£o de dados distribu√≠dos e sistema anal√≠tico.  Dados coletados em pontos distribu√≠dos mundialmente pelos comandos do n√≥ central.  O MQTT foi usado como transporte para controle e distribui√ß√£o de dados adquiridos; </li><li>  ambiente de teste para verifica√ß√£o do sistema de controle em tempo real de equipamentos ferrovi√°rios; </li><li>  sistema de controle autom√°tico para cen√°rio de teatro.  Mais detalhes podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ; </li><li>  componentes da plataforma de gerenciamento de dados em um sistema de publicidade on-line. </li></ul><br><h1 id="a-taste-of-sobjectizer">  Uma amostra do SObjectizer </h1><br><p>  Vamos ver v√°rios exemplos simples para provar o SObjectizer.  Esses s√£o exemplos muito simples que, esperamos, n√£o exigem explica√ß√µes adicionais, excluindo os coment√°rios no c√≥digo. </p><br><h2 id="the-traditional-hello-world-example-in-actor-models-style">  O exemplo tradicional "Ol√°, Mundo" no estilo do modelo de ator </h2><br><p>  O exemplo mais simples, com apenas um agente que reage √† mensagem <code>hello</code> e termina seu trabalho: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'hello' message. so_subscribe_self().event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register an instance of demo agent. auto mbox = env.introduce_coop([](so_5::coop_t &amp; coop) { auto * a = coop.make_agent&lt;demo&gt;(); return a-&gt;so_direct_mbox(); }); // Send hello message to registered agent. so_5::send&lt;hello&gt;(mbox, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><h2 id="another-version-of-hello-world-with-agents-and-publishsubscribe-model">  Outra vers√£o do "Hello, World" com agentes e modelo de publica√ß√£o / assinatura </h2><br><p>  O exemplo mais simples com v√°rios agentes, todos eles reagem √† mesma inst√¢ncia da mensagem <code>hello</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::string_literals; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { const std::string name_; void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; name_ &lt;&lt; ": greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: demo(context_t ctx, std::string name, so_5::mbox_t board) : agent_t{std::move(ctx)} , name_{std::move(name)} { // Create a subscription for hello message from board. so_subscribe(board).event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Mbox to be used for speading hello message. auto board = env.create_mbox(); // Create several agents in separate coops. for(const auto &amp; n : {"Alice"s, "Bob"s, "Mike"s}) env.register_agent_as_coop(env.make_agent&lt;demo&gt;(n, board)); // Spread hello message to all subscribers. so_5::send&lt;hello&gt;(board, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><p>  Se executarmos esse exemplo, podemos receber algo assim: </p><br><pre> <code class="plaintext hljs">Alice: greeting received: Hello, World! Bob: greeting received: Hello, World! Mike: greeting received: Hello, World!</code> </pre> <br><h2 id="hello-world-example-in-csp-style">  Exemplo "Ol√°, Mundo" no estilo CSP </h2><br><p>  Vejamos um exemplo de SObjectizer sem nenhum ator, apenas <code>std::thread</code> e canais do tipo CSP. </p><br><h3 id="very-simple-version">  Vers√£o muito simples </h3><br><p>  Esta √© uma vers√£o muito simples que n√£o √© exce√ß√£o segura: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Channel to be used. auto ch = so_5::create_mchain(sobj); std::thread demo_thread{demo_thread_func, ch}; // Send a greeting. so_5::send&lt;hello&gt;(ch, "Hello, World!"); // Wait for demo thread. demo_thread.join(); }</span></span></span></span></code> </pre> <br><h3 id="more-robust-but-still-simple-version">  Vers√£o mais robusta, mas ainda simples </h3><br><p>  Esta √© uma vers√£o modificada do exemplo mostrado acima com a adi√ß√£o da exce√ß√£o de seguran√ßa: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Demo thread. We need object now, but thread will be started later. std::thread demo_thread; // Auto-joiner for the demo thread. auto demo_joiner = so_5::auto_join(demo_thread); // Channel to be used. This channel will be automatically closed // in the case of an exception. so_5::mchain_master_handle_t ch_handle{ so_5::create_mchain(sobj), so_5::mchain_props::close_mode_t::retain_content }; // Now we can run demo thread. demo_thread = std::thread{demo_thread_func, *ch_handle}; // Send a greeting. so_5::send&lt;hello&gt;(*ch_handle, "Hello, World!"); // There is no need to wait for something explicitly. }</span></span></span></span></code> </pre> <br><h2 id="a-rather-simple-hsm-example-blinking_led">  Um exemplo bastante simples do HSM: blinking_led </h2><br><p>  Este √© um exemplo padr√£o da distribui√ß√£o do SObjectizer.  O agente principal deste exemplo √© um HSM que pode ser descrito pelo seguinte gr√°fico de estados: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eca/679/59d/eca67959d472d154ce57878d4ffe0120.png" alt="gr√°fico de status blinking_led"></p><br><p>  O c√≥digo fonte do exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;so_5/all.hpp&gt; class blinking_led final : public so_5::agent_t { state_t off{ this }, blinking{ this }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; public : struct turn_on_off final : public so_5::signal_t {}; blinking_led( context_t ctx ) : so_5::agent_t{ ctx } { this &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ std::cout &lt;&lt; "ON" &lt;&lt; std::endl; } ) .on_exit( []{ std::cout &lt;&lt; "off" &lt;&lt; std::endl; } ) .time_limit( std::chrono::milliseconds{1500}, blink_off ); blink_off .time_limit( std::chrono::milliseconds{750}, blink_on ); } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { auto m = env.introduce_coop( []( so_5::coop_t &amp; coop ) { auto led = coop.make_agent&lt; blinking_led &gt;(); return led-&gt;so_direct_mbox(); } ); auto pause = []( unsigned int v ) { std::this_thread::sleep_for( std::chrono::seconds{v} ); }; std::cout &lt;&lt; "Turn blinking on for 10s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 10 ); std::cout &lt;&lt; "Turn blinking off for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Turn blinking on for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Stopping..." &lt;&lt; std::endl; env.stop(); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre> <br><h2 id="timers-overload-control-for-an-agent-and-active_obj-dispatcher">  Temporizadores, controle de sobrecarga para um agente e despachante active_obj </h2><br><p>  O controle de sobrecarga √© um dos principais problemas para os atores: as filas de mensagens para os atores geralmente s√£o ilimitadas e isso pode levar a um crescimento descontrolado de filas se um produtor de mensagens r√°pidas enviar mensagens mais rapidamente, em seguida, o destinat√°rio poder√° lidar com elas.  O exemplo a seguir mostra os recursos do SObjectizer como <em>limites de mensagens</em> .  Permite limitar a contagem de mensagens na fila do agente e defender o destinat√°rio de mensagens redundantes. </p><br><p>  Este exemplo tamb√©m mostra o uso do timer na forma de uma mensagem peri√≥dica.  A liga√ß√£o de agentes ao dispatcher active_obj tamb√©m √© mostrada l√°.  A liga√ß√£o a esse despachante significa que todo agente da cooperativa funcionar√° no pr√≥prio segmento de trabalho (por exemplo, um agente se torna um objeto ativo). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::chrono_literals; // Message to be sent to the consumer. struct task { int task_id_; }; // An agent for utilization of unhandled tasks. class trash_can final : public so_5::agent_t { public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'task' message. // Event-handler is specified in the form of a lambda-function. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "unhandled task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; }); } }; // The consumer of 'task' messages. class consumer final : public so_5::agent_t { public: // We need the constructor. consumer(context_t ctx, so_5::mbox_t trash_mbox) : so_5::agent_t{ctx + // Only three 'task' messages can wait in the queue. limit_then_redirect&lt;task&gt;(3, // All other messages will go to that mbox. [trash_mbox]{ return trash_mbox; })} { // Define a reaction to incoming 'task' message. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "handling task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; std::this_thread::sleep_for(75ms); }); } }; // The producer of 'test' messages. class producer final : public so_5::agent_t { const so_5::mbox_t dest_; so_5::timer_id_t task_timer_; int id_counter_{}; // Type of periodic signal to produce new 'test' message. struct generate_next final : public so_5::signal_t {}; void on_next(mhood_t&lt;generate_next&gt;) { // Produce a new 'task' message. so_5::send&lt;task&gt;(dest_, id_counter_); ++id_counter_; // Should the work be stopped? if(id_counter_ &gt;= 10) so_deregister_agent_coop_normally(); } public: producer(context_t ctx, so_5::mbox_t dest) : so_5::agent_t{std::move(ctx)} , dest_{std::move(dest)} {} void so_define_agent() override { so_subscribe_self().event(&amp;producer::on_next); } // This method will be automatically called by SObjectizer // when agent starts its work inside SObjectizer Environment. void so_evt_start() override { // Initiate a periodic message with no initial delay // and repetition every 25ms. task_timer_ = so_5::send_periodic&lt;generate_next&gt;(*this, 0ms, 25ms); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register coop with agents. // All agents will be bound to active_obj dispatcher and will // work on separate threads. env.introduce_coop( so_5::disp::active_obj::make_dispatcher(env).binder(), [](so_5::coop_t &amp; coop) { auto * trash = coop.make_agent&lt;trash_can&gt;(); auto * handler = coop.make_agent&lt;consumer&gt;(trash-&gt;so_direct_mbox()); coop.make_agent&lt;producer&gt;(handler-&gt;so_direct_mbox()); }); }); }</span></span></span></span></code> </pre> <br><p>  Se executarmos esse exemplo, podemos ver a seguinte sa√≠da: </p><br><pre> <code class="plaintext hljs">handling task: 0 handling task: 1 unhandled task: 5 unhandled task: 6 handling task: 2 unhandled task: 8 unhandled task: 9 handling task: 3 handling task: 4 handling task: 7</code> </pre> <br><p>  Esta sa√≠da mostra que v√°rias mensagens que n√£o cabem no limite definido s√£o rejeitadas e redirecionadas para outro receptor. </p><br><h2 id="more-examples">  Mais exemplos </h2><br><p>  Um exemplo mais ou menos semelhante ao c√≥digo de aplicativos da vida real pode ser encontrado em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">projeto de demonstra√ß√£o do Shrimp</a> .  Outro conjunto de exemplos interessantes pode ser encontrado nesta miniss√©rie sobre o cl√°ssico "problema dos fil√≥sofos gastron√¥micos": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">parte 1</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">parte 2</a> .  E, √© claro, existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">muitos exemplos no pr√≥prio SObjectizer</a> . </p><br><h1 id="what-about-the-performance">  E o desempenho? </h1><br><p>  H√° uma resposta muito simples: √© mais do que suficiente para n√≥s.  O SObjectizer pode distribuir milh√µes de mensagens por segundo e a velocidade real depende dos tipos de expedidores usados, tipos de mensagens, perfil de carga, hardware / OS / compilador usado e assim por diante.  Em uma aplica√ß√£o real, geralmente usamos apenas uma fra√ß√£o da velocidade do SObjectizer. </p><br><p>  O desempenho do SObjectizer para sua tarefa espec√≠fica depende muito da sua tarefa, da solu√ß√£o espec√≠fica dessa tarefa, do seu hardware ou ambiente virtual, da vers√£o do seu compilador e do seu sistema operacional.  Portanto, a melhor maneira de encontrar uma resposta para essa pergunta √© criar um benchmark espec√≠fico para sua tarefa e fazer experi√™ncias com ela. </p><br><p>  Se voc√™ deseja n√∫meros de alguns benchmarks sint√©ticos, existem alguns programas na pasta test / so_5 / bench da distribui√ß√£o do SObjectizer. </p><br><h2 id="a-note-about-comparison-with-different-tools">  Uma observa√ß√£o sobre a compara√ß√£o com diferentes ferramentas </h2><br><p>  Pensamos que um jogo de benchmarking comparando a velocidade de diferentes ferramentas √© um jogo de marketing.  Fizemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">uma tentativa</a> no passado, mas rapidamente percebemos que √© apenas uma perda de tempo.  Portanto, n√£o jogamos esse jogo agora.  N√≥s gastamos nosso tempo e nossos recursos apenas em benchmarks que permitem verificar a aus√™ncia de degrada√ß√£o do desempenho, resolver alguns casos extremos (como o desempenho de mboxes MPMC com grande quantidade de assinantes ou o desempenho de um agente com centenas de milhares de assinaturas), para acelerar algumas opera√ß√µes espec√≠ficas do SObjectizer (como registro / cancelamento de registro de uma cooperativa). </p><br><p>  Ent√£o deixamos a compara√ß√£o de velocidade para quem gosta desse jogo e tem tempo para jog√°-lo. </p><br><h1 id="why-sobjectizer-does-look-exactly-as-it-is">  Por que o SObjectizer parece exatamente como √©? </h1><br><p>  Existem v√°rias "estruturas de ator" para C ++, e todas elas parecem diferentes.  Parece que tem algumas raz√µes objetivas: toda estrutura possui caracter√≠sticas √∫nicas e tem objetivos diferentes.  Al√©m disso, os atores em C ++ podem ser implementados de maneira muito diferente.  Portanto, a quest√£o principal n√£o √© "por que o framework X n√£o se parece com o framework Y?", Mas "por que o framework X parece com o que √©?" </p><br><p>  Agora, tentaremos descrever brevemente alguns motivos por tr√°s dos principais recursos do SObjectizer.  Esperamos que isso permita uma melhor compreens√£o das habilidades do SObjectizer.  Mas antes de come√ßarmos, √© necess√°rio mencionar uma coisa muito importante: o SObjectizer nunca foi um experimento.  Foi criado para resolver o trabalho da vida real e tem evolu√≠do com base na experi√™ncia da vida real. </p><br><h2 id="agents-are-objects-of-classes-derived-from-agent_t">  Agentes s√£o objetos de classes derivadas de agent_t </h2><br><p>  Agentes (tamb√©m conhecidos como atores) no SObjectzer s√£o objetos de classes definidas pelo usu√°rio que devem ser derivadas de uma classe especial <code>agent_t</code> .  Pode parecer redundante em pequenos exemplos de brinquedos, mas nossa experi√™ncia mostra que essa abordagem simplifica muito o desenvolvimento de software real, em que os agentes geralmente t√™m o tamanho em v√°rias centenas de linhas (voc√™ pode ver um dos exemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">aqui</a> , mas esta postagem no blog est√° em Russo).  √Äs vezes at√© em v√°rios milhares de linhas. </p><br><p>  A experi√™ncia mostra que um agente simples com a primeira vers√£o em cem linhas se torna muito mais gordo e complexo nos pr√≥ximos anos de evolu√ß√£o.  Ent√£o, depois de cinco anos, voc√™ poder√° encontrar um monstro em mil linhas com dezenas de m√©todos. </p><br><p>  O uso de classes nos permite gerenciar a complexidade dos agentes.  N√≥s podemos usar heran√ßa de classes.  E tamb√©m podemos usar classes de modelo.  Essas s√£o t√©cnicas muito √∫teis que simplificam bastante o desenvolvimento de fam√≠lias de agentes com l√≥gica semelhante por dentro. </p><br><h2 id="messages-as-objects-of-user-structsclasses">  Mensagens como objetos de estruturas / classes de usu√°rios </h2><br><p>  Mensagens no SObjectizer s√£o objetos de estruturas ou classes definidas pelo usu√°rio.  H√° pelo menos duas raz√µes para isso: </p><br><ul><li>  o desenvolvimento do SObjectizer-5 come√ßou em 2010 quando o C ++ 11 ainda n√£o havia sido padronizado.  Portanto, no in√≠cio, n√£o pod√≠amos usar recursos do C ++ 11 como modelos variados e classe <code>std::tuple</code> .  A √∫nica op√ß√£o que tivemos foi o uso de um objeto de uma classe herdada de uma classe especial <code>message_t</code> .  Agora n√£o h√° necessidade de derivar o tipo de mensagem de <code>message_t</code> , mas o SObjectizer agrupa um objeto de usu√°rio em um objeto derivado de <code>message_t</code> qualquer maneira, sob o cap√¥; </li><li>  o conte√∫do de uma mensagem pode ser facilmente alterado sem modifica√ß√£o das assinaturas dos manipuladores de eventos.  E existe um controle de um compilador: se voc√™ remover algum campo de uma mensagem ou alterar seu tipo, o compilador informar√° sobre o acesso incorreto a esse campo. </li></ul><br><p>  O uso de mensagens como objetos tamb√©m permite trabalhar com mensagens pr√©-alocadas e armazenar uma mensagem recebida em algum cont√™iner e reenvi√°-la mais tarde. </p><br><h2 id="coops-of-agents">  Cooperativas de agentes </h2><br><p>  Uma cooperativa de agentes √© provavelmente um dos recursos exclusivos do SObjectizer.  Uma cooperativa √© um grupo de agentes que devem ser adicionados e removidos do SObjectizer de maneira transacional.  Isso significa que se uma cooperativa contiver tr√™s agentes, todos esses agentes dever√£o ser adicionados ao SObjectizer com √™xito ou nenhum deles dever√° ser adicionado.  Da mesma forma, todos os tr√™s agentes devem ser removidos do SObjectizer ou os tr√™s agentes devem continuar seu trabalho. </p><br><p>  A necessidade de cooperativas foi descoberta logo ap√≥s o in√≠cio da vida √∫til do SObjectizer.  Tornou-se √≥bvio que os agentes seriam criados por grupos, n√£o por inst√¢ncias √∫nicas.  As cooperativas foram inventadas para simplificar a vida de um desenvolvedor: n√£o h√° necessidade de controlar a cria√ß√£o do pr√≥ximo agente e remover agentes criados anteriormente se a cria√ß√£o de um novo agente falhar. </p><br><p>  Uma cooperativa tamb√©m pode ser vista como um supervisor no modo tudo por um: se um agente da cooperativa falhar, a cooperativa inteira ser√° removida do SObjectizer Environment e destru√≠da (um usu√°rio pode reagir a isso e recriar a cooperativa novamente). </p><br><h2 id="message-boxes">  Caixas de mensagem </h2><br><p>  As caixas de mensagens s√£o outro recurso exclusivo do SObjectizer.  As mensagens no SObjectizer s√£o enviadas para uma caixa de mensagens (mbox), n√£o para um agente diretamente.  Pode haver um receptor atr√°s da mbox, ou pode haver um milh√£o de assinantes ou n√£o pode haver ningu√©m. </p><br><p>  Mboxes nos permite suportar a funcionalidade b√°sica do modelo Publicar-Assinar.  Uma mbox pode ser vista como MQ-broker e o tipo de mensagem pode ser visto como um t√≥pico. </p><br><p>  Mboxes nos permite tamb√©m implementar v√°rias formas interessantes de entrega de mensagens.  Por exemplo, h√° uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">mbox round-robin</a> que espalha mensagens entre assinantes de maneira round-robin.  H√° tamb√©m uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">mbox retida</a> que ret√©m a √∫ltima mensagem enviada e a reenvia automaticamente para cada novo assinante.  H√° tamb√©m um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">wrapper simples em torno do libmosquitto</a> que permite usar o MQTT como um transporte para um aplicativo distribu√≠do. </p><br><h2 id="agents-as-hsm">  Agentes como HSM </h2><br><p>  Os agentes no SObjectizer s√£o m√°quinas de estado.  Foi desde o in√≠cio, simplesmente porque o SObjectizer tem ra√≠zes no campo SCADA, onde as m√°quinas de estado s√£o usadas ativamente.  Mas rapidamente ficou √≥bvio que os agentes na forma de uma m√°quina de estado podem ser √∫teis mesmo em diferentes nichos (como aplicativos de telecomunica√ß√µes e finan√ßas). </p><br><p>  O suporte de m√°quinas de estado hier√°rquico (por exemplo, manipuladores on_enter / on_exit, estados aninhados, prazos e assim por diante) foi adicionado ap√≥s algum tempo de uso do SObjectizer na produ√ß√£o.  E esse recurso tornou o SObjectizer ainda mais poderoso e conveniente. </p><br><h2 id="usage-of-c-exceptions">  Uso de exce√ß√µes em C ++ </h2><br><p>  As exce√ß√µes de C ++ s√£o usadas no SObjectizer como o principal mecanismo de relat√≥rio de erros.  Apesar do fato de que o uso da exce√ß√£o C ++ √†s vezes pode ser caro, decidimos usar exce√ß√µes em vez de c√≥digos de erro. </p><br><p>  Tivemos uma experi√™ncia negativa com c√≥digos de erro no SObjectizer-4, onde as exce√ß√µes n√£o foram usadas.  Isso levou √† ignor√¢ncia de erros no c√≥digo do aplicativo e, algumas vezes, a√ß√µes importantes n√£o foram executadas porque ocorreu um erro ao criar um novo cooperativo ou ao enviar uma mensagem.  Mas esse erro foi ignorado e esse fato foi descoberto muito mais tarde. </p><br><p>  O uso de exce√ß√µes de C ++ no SObjectizer-5 permite escrever c√≥digo mais correto e robusto.  Em casos comuns, as exce√ß√µes s√£o lan√ßadas pelo SObjectizer muito raramente, portanto, o uso da exce√ß√£o n√£o tem impacto negativo no desempenho do SObjectizer ou no desempenho de aplicativos escritos na parte superior do SObjectizer. </p><br><h2 id="no-support-for-distributed-applications-out-of-box">  N√£o h√° suporte para aplicativos distribu√≠dos "prontos para uso" </h2><br><p>  O SObjectzer-5 n√£o possui suporte interno para aplicativos distribu√≠dos.  Isso significa que o SObjectizer distribui mensagens apenas dentro de um processo.  Se voc√™ precisar organizar a distribui√ß√£o de mensagens entre processos ou entre notas, precisar√° integrar algum tipo de IPC em seu aplicativo. </p><br><p>  Isso n√£o ocorre porque n√£o podemos implementar alguma forma de IPC no SObjectizer.  J√° t√≠nhamos isso no SObjectizer-4.  E como temos essa experi√™ncia, decidimos n√£o fazer isso no SObjectizer-5.  Aprendemos que n√£o existe um tipo de IPC que se encaixe perfeitamente para diferentes condi√ß√µes. </p><br><p>  Se voc√™ deseja ter uma boa comunica√ß√£o entre n√≥s em seu aplicativo, √© necess√°rio selecionar os protocolos subjacentes apropriados.  Por exemplo, se voc√™ precisar espalhar milh√µes de pacotes pequenos com alguns dados de vida curta (como a distribui√ß√£o de medidas das condi√ß√µes clim√°ticas atuais), precisar√° usar um IPC.  Mas se voc√™ precisar transferir BLOBs enormes (como fluxos de v√≠deo 4K / 8K ou arquivos com dados financeiros internos), precisar√° usar outro tipo de IPC. </p><br><p>  E n√£o falamos de introperabilidade com software escrito em diferentes idiomas ... </p><br><p>  Voc√™ pode acreditar que alguma "estrutura de ator" universal pode fornecer um IPC que ser√° bom para diferentes condi√ß√µes.  Mas sabemos que √© apenas besteira de marketing.  Nossa experi√™ncia nos mostra que √© muito mais simples e seguro adicionar o IPC necess√°rio em seu aplicativo e depois confiar em id√©ias, necessidades e conhecimentos de autores de uma "estrutura de ator" de terceiros. </p><br><p>  O SObjectizer permite incorporar v√°rios tipos de IPC na forma de mboxes personalizadas.  Portanto, permite ocultar o fato da distribui√ß√£o de mensagens em uma rede dos usu√°rios de um SObjectizer. </p><br><h1 id="instead-of-the-conclusion">  Em vez da conclus√£o </h1><br><p>  A estrutura do SObjectizer n√£o √© grande, mas n√£o √© pequena.  Portanto, √© imposs√≠vel dar ao leitor uma impress√£o bastante profunda sobre o SObjectizer em apenas uma vis√£o geral.  Por isso, convidamos voc√™ a dar uma olhada no projeto SObjectizer. </p><br><p>  O SObjectizer em si vive no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">GitHub</a> .  Existe o Wiki do projeto no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">GitHub</a> e recomendamos iniciar no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">SObjectizer 5.6 No√ß√µes b√°sicas</a> e depois ir para artigos da s√©rie In-depth.  Para aqueles que querem ir mais fundo, podemos recomendar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Vamos dar uma olhada na se√ß√£o de capas do SObjectizer</a> . </p><br><p>  Se voc√™ tiver alguma d√∫vida, pode nos fazer uma pergunta no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">grupo SObjectizer nos grupos</a> do Google. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458202/">https://habr.com/ru/post/pt458202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458176/index.html">A barreira dos exaflops ser√° superada em 2021</a></li>
<li><a href="../pt458180/index.html">Servidor DHCP de failover baseado em Kea</a></li>
<li><a href="../pt458182/index.html">Lemos o VKontakte atrav√©s do RSS</a></li>
<li><a href="../pt458186/index.html">WAL no PostgreSQL: 1. Cache do buffer</a></li>
<li><a href="../pt458188/index.html">Como eu fiz uma rede social em 2019</a></li>
<li><a href="../pt458204/index.html">Como avaliar o desempenho do armazenamento no Linux: benchmarking usando ferramentas abertas</a></li>
<li><a href="../pt458206/index.html">Texto sublime 3 para o layout do site. Personalize a apar√™ncia e instale plugins. Guia do Iniciante</a></li>
<li><a href="../pt458208/index.html">Eventos digitais em Moscou de 01 a 07 de julho</a></li>
<li><a href="../pt458214/index.html">Laborat√≥rio Pentest "Laborat√≥rio Pentestit Test 12" - passagem completa</a></li>
<li><a href="../pt458218/index.html">Cirurgia maxilofacial ou n√£o? Essa √© a quest√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>