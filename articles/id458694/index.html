<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏿 🎅🏾 👫 Apakah Python GIL Benar-Benar Mati? ✌🏾 🍆 🚑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Senin depan, kelas akan dimulai pada grup baru kursus Pengembang Python , yang berarti bahwa kita punya waktu untuk menerbitkan materi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah Python GIL Benar-Benar Mati?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/458694/">  Halo semuanya!  Senin depan, kelas akan dimulai pada grup baru kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembang Python</a> , yang berarti bahwa kita punya waktu untuk menerbitkan materi menarik lainnya, yang akan kita lakukan sekarang.  Selamat membaca. <br><br><img src="https://habrastorage.org/webt/jb/cq/wj/jbcqwjrmctxos6x_uzhptngfd9y.png"><br><br>  Kembali pada tahun 2003, Intel merilis prosesor Pentium 4 "HT" baru.  Prosesor ini di-overclock ke 3GHz dan didukung teknologi hyper-threading. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/9d/z1/es/9dz1esccmgms80liftaeolcqiui.jpeg"><br><br>  Pada tahun-tahun berikutnya, Intel dan AMD berjuang untuk mencapai kinerja desktop terbaik dengan meningkatkan kecepatan bus, ukuran cache L2 dan mengurangi ukuran matriks untuk meminimalkan latensi.  Pada tahun 2004, model HT dengan frekuensi 3 GHz digantikan oleh model Pres80 580 dengan overclocking ke 4 GHz. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AmwzUrL3vMc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Tampaknya untuk maju, hanya perlu meningkatkan frekuensi clock, bagaimanapun, prosesor baru menderita konsumsi daya tinggi dan pembuangan panas. <br><br>  Apakah prosesor desktop Anda menghasilkan 4 GHz hari ini?  Tidak mungkin, karena jalur untuk meningkatkan kinerja pada akhirnya terletak melalui peningkatan kecepatan bus dan peningkatan jumlah core.  Pada tahun 2006, Intel Core 2 menggantikan Pentium 4 dan memiliki kecepatan clock yang jauh lebih rendah. <br><br>  Selain merilis prosesor multi-core untuk audiens pengguna yang luas, sesuatu yang lain terjadi pada tahun 2006.  Python 2.5 akhirnya melihat cahaya!  Itu sudah datang dengan versi beta dari kata kunci, yang Anda semua tahu dan cinta. <br><br>  Python 2.5 memiliki satu batasan utama ketika menggunakan Intel Core 2 atau AMD Athlon X2. <br>  Itu GIL. <br><br><h2>  Apa itu GIL? </h2><br>  GIL (Global Interpreter Lock) adalah nilai boolean dalam interpreter Python yang dilindungi oleh mutex.  Kunci tersebut digunakan dalam loop perhitungan bytecode CPython utama untuk menentukan utas mana yang sedang menjalankan instruksi. <br><br>  CPython mendukung penggunaan beberapa utas dalam satu juru bahasa, tetapi utas harus meminta akses ke GIL untuk melakukan operasi tingkat rendah.  Pada gilirannya, ini berarti bahwa pengembang Python dapat menggunakan kode asinkron, multithreading dan tidak perlu lagi khawatir memblokir variabel atau crash di tingkat prosesor selama kebuntuan. <br><br>  GIL menyederhanakan pemrograman Python multithreaded. <br><br><img src="https://habrastorage.org/webt/lg/yz/3h/lgyz3hoq07fkumzp4axuuiqxplk.gif"><br><br>  GIL juga memberi tahu kita bahwa walaupun CPython dapat multi-utas, hanya satu utas sekaligus yang dapat dieksekusi.  Ini berarti bahwa prosesor quad-core Anda melakukan sesuatu seperti ini (dengan pengecualian layar biru, semoga). <br><br>  Versi GIL saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini ditulis pada tahun 2009</a> untuk mendukung fungsi asinkron dan tetap tidak tersentuh bahkan setelah banyak upaya untuk menghapusnya pada prinsipnya atau mengubah persyaratan untuk itu. <br><br>  Setiap saran untuk menghapus GIL dibenarkan oleh fakta bahwa penguncian global dari juru bahasa tidak boleh menurunkan kinerja kode single-threaded.  Siapa pun yang mencoba mengaktifkan hyperthreading pada tahun 2003 akan mengerti apa yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya bicarakan</a> . <br><br><h2>  Gil ditinggalkan dalam CPython </h2><br>  Jika Anda ingin benar-benar memparalelkan kode dalam CPython, Anda harus menggunakan beberapa proses. <br><br>  Dalam CPython 2.6, modul <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multiprosesor</a></i> ditambahkan ke pustaka standar.  Multiprocessing menutupi proses generasi dalam CPython (setiap proses dengan GIL sendiri). <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Process <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, name <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: p = Process(target=f, args=(<span class="hljs-string"><span class="hljs-string">'bob'</span></span>,)) p.start() p.join()</code> </pre> <br><br>  Proses dibuat, perintah dikirim kepada mereka menggunakan modul yang dikompilasi dan fungsi Python, dan kemudian mereka bergabung kembali ke proses utama. <br><br>  Multiprocessing juga mendukung penggunaan variabel melalui antrian atau saluran.  Dia memiliki objek kunci, yang digunakan untuk mengunci objek dalam proses utama dan menulis dari proses lain. <br><br>  Multiprocessing memiliki satu kelemahan utama.  Ini membawa beban komputasi yang signifikan, yang memengaruhi waktu pemrosesan dan penggunaan memori.  Waktu startup CPython bahkan tanpa situs adalah 100-200 ms (periksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b</a> untuk mempelajari lebih lanjut). <br><br>  Akibatnya, Anda mungkin memiliki kode paralel dalam CPython, tetapi Anda masih perlu merencanakan pekerjaan proses jangka panjang yang berbagi beberapa objek secara hati-hati. <br><br>  Alternatif lain mungkin menggunakan paket pihak ketiga seperti Twisted. <br><br><h2>  PEP554 dan kematian GIL? </h2><br>  Jadi, izinkan saya mengingatkan Anda bahwa multithreading di CPython sederhana, tetapi dalam kenyataannya itu bukan paralelisasi, tetapi multiprosesing paralel, tetapi memerlukan overhead yang signifikan. <br><br>  <i>Bagaimana jika ada cara yang lebih baik?</i> <br>  Kunci untuk melewati GIL terletak pada namanya, penguncian global dari interpreter adalah bagian dari keadaan global interpreter.  Proses CPython dapat memiliki beberapa penerjemah dan, oleh karena itu, beberapa kunci, bagaimanapun, fungsi ini jarang digunakan, karena akses ke sana hanya melalui C-API. <br><br>  Salah satu fitur dari CPython 3.8 adalah PEP554, sebuah implementasi dari sub-interpreter dan API dengan modul <code>interpreters</code> baru di perpustakaan standar. <br><br>  Ini memungkinkan Anda untuk membuat banyak interpreter dari Python dalam satu proses tunggal.  Inovasi Python 3.8 lainnya adalah bahwa semua penerjemah akan memiliki GIL sendiri. <br><br><img src="https://habrastorage.org/webt/bq/nc/m2/bqncm29jhm-ytakgrlkasbfe_6y.png"><br><br>  Karena status interpreter berisi wilayah yang dialokasikan dalam memori, kumpulan semua pointer ke objek Python (lokal dan global), sub-penerjemah dalam PEP554 tidak dapat mengakses variabel global dari juru bahasa lain. <br><br>  Seperti multiprocessing, interpreter berbagi objek terdiri dalam serialisasi dan menggunakan bentuk IPC (jaringan, disk, atau memori bersama).  Ada banyak cara untuk membuat serial objek dalam Python, misalnya, modul <code>marshal</code> , modul <code>pickle</code> , atau metode yang lebih standar seperti <code>json</code> atau <code>simplexml</code> .  Masing-masing dari mereka memiliki pro dan kontra, dan semuanya memberikan beban komputasi. <br><br>  Akan lebih baik untuk memiliki ruang memori bersama yang dapat diubah dan dikendalikan oleh proses tertentu.  Dengan demikian, objek dapat dikirim oleh penerjemah utama dan diterima oleh penerjemah lain.  Ini akan menjadi ruang memori yang dikelola untuk mencari pointer PyObject, yang dapat diakses oleh setiap penerjemah, sementara proses utama akan mengelola kunci. <br><br><img src="https://habrastorage.org/webt/be/ww/d8/bewwd8ju-3akmyhs7ujq7xmyliy.png"><br><br>  API untuk ini masih sedang dikembangkan, tetapi mungkin akan terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _xxsubinterpreters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> interpreters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> textwrap <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> marshal <span class="hljs-comment"><span class="hljs-comment"># Create a sub-interpreter interpid = interpreters.create() # If you had a function that generated some data arry = list(range(0,100)) # Create a channel channel_id = interpreters.channel_create() # Pre-populate the interpreter with a module interpreters.run_string(interpid, "import marshal; import _xxsubinterpreters as interpreters") # Define a def run(interpid, channel_id): interpreters.run_string(interpid, tw.dedent(""" arry_raw = interpreters.channel_recv(channel_id) arry = marshal.loads(arry_raw) result = [1,2,3,4,5] # where you would do some calculating result_raw = marshal.dumps(result) interpreters.channel_send(channel_id, result_raw) """), shared=dict( channel_id=channel_id ), ) inp = marshal.dumps(arry) interpreters.channel_send(channel_id, inp) # Run inside a thread t = threading.Thread(target=run, args=(interpid, channel_id)) t.start() # Sub interpreter will process. Feel free to do anything else now. output = interpreters.channel_recv(channel_id) interpreters.channel_release(channel_id) output_arry = marshal.loads(output) print(output_arry)</span></span></code> </pre> <br><br>  Contoh ini menggunakan NumPy.  Array numpy dikirim melalui saluran, serial dengan menggunakan modul <code>marshal</code> , kemudian subinterpreter memproses data (pada GIL terpisah), sehingga mungkin ada masalah paralelisasi yang terkait dengan CPU, yang ideal untuk subinterpreter. <br><br><h4>  <b>Terlihat tidak efisien</b> </h4><br>  Modul <code>marshal</code> bekerja sangat cepat, tetapi tidak secepat berbagi objek langsung dari memori. <br><br>  PEP574 memperkenalkan protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">acar</a> baru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(v5)</a> yang mendukung kemampuan untuk memproses buffer memori secara terpisah dari sisa aliran acar.  Untuk objek data besar, membuat serial semuanya dalam satu go dan deserializing dari subinterpreter akan menambah banyak overhead. <br><br>  API baru dapat diimplementasikan (murni hipotetis) sebagai berikut - <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _xxsubinterpreters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> interpreters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> textwrap <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-comment"><span class="hljs-comment"># Create a sub-interpreter interpid = interpreters.create() # If you had a function that generated a numpy array arry = [5,4,3,2,1] # Create a channel channel_id = interpreters.channel_create() # Pre-populate the interpreter with a module interpreters.run_string(interpid, "import pickle; import _xxsubinterpreters as interpreters") buffers=[] # Define a def run(interpid, channel_id): interpreters.run_string(interpid, tw.dedent(""" arry_raw = interpreters.channel_recv(channel_id) arry = pickle.loads(arry_raw) print(f"Got: {arry}") result = arry[::-1] result_raw = pickle.dumps(result, protocol=5) interpreters.channel_send(channel_id, result_raw) """), shared=dict( channel_id=channel_id, ), ) input = pickle.dumps(arry, protocol=5, buffer_callback=buffers.append) interpreters.channel_send(channel_id, input) # Run inside a thread t = threading.Thread(target=run, args=(interpid, channel_id)) t.start() # Sub interpreter will process. Feel free to do anything else now. output = interpreters.channel_recv(channel_id) interpreters.channel_release(channel_id) output_arry = pickle.loads(output) print(f"Got back: {output_arry}")</span></span></code> </pre> <br><h4>  <b>Itu terlihat berpola</b> </h4><br>  Intinya, contoh ini dibangun berdasarkan penggunaan API dari sub-penerjemah tingkat rendah.  Jika Anda belum menggunakan pustaka <code>multiprocessing</code> , beberapa masalah akan terasa familier bagi Anda.  Ini tidak sesederhana pemrosesan aliran, Anda tidak bisa, katakan saja, menjalankan fungsi ini dengan daftar data input sedemikian dalam interpreter terpisah (untuk saat ini). <br><br>  Begitu PEP ini bergabung dengan yang lain, saya pikir kita akan melihat beberapa API baru di PyPi. <br><br><h3>  Berapa overhead yang dimiliki subinterpreter? </h3><br>  <b>Jawaban singkat:</b> Lebih dari sekadar streaming, kurang dari proses. <br>  <b>Jawaban panjang:</b> Penerjemah memiliki statusnya sendiri, sehingga perlu mengkloning dan menginisialisasi yang berikut, meskipun fakta bahwa PEP554 menyederhanakan pembuatan sub-penerjemah: <br><br><ul><li>  Modul di <code>__main__</code> dan <code>importlib</code> ; </li><li>  Isi kamus <code>sys</code> ; </li><li>  Fungsi <code>print()</code> , <code>assert</code> , dll.); </li><li>  Stream; </li><li>  Konfigurasi kernel. </li></ul><br><br>  Konfigurasi kernel dapat dengan mudah dikloning dari memori, tetapi mengimpor modul tidak begitu sederhana.  Mengimpor modul dengan Python lambat, jadi jika membuat subinterpreter berarti mengimpor modul ke ruang nama yang berbeda setiap kali, manfaatnya berkurang. <br><br><h3>  Bagaimana dengan asyncio? </h3><br>  Implementasi yang ada dari <code>asyncio</code> peristiwa <code>asyncio</code> di pustaka standar menciptakan bingkai tumpukan untuk evaluasi, dan juga <code>asyncio</code> status dalam juru bahasa utama (dan karenanya berbagi GIL). <br><br>  Setelah menggabungkan PEP554, mungkin sudah di Python 3.9, implementasi alternatif dari loop acara dapat digunakan (meskipun belum ada yang melakukannya), yang menjalankan metode asinkron dalam subinterpreters secara paralel. <br><br><h3>  Kedengarannya keren, bungkus aku juga! </h3><br>  Yah, tidak juga. <br>  Karena CPython telah berjalan pada juru bahasa yang sama untuk waktu yang lama, banyak bagian basis kode menggunakan "Runtime State" alih-alih "Negara Penerjemah," jadi jika PEP554 diperkenalkan sekarang, masih akan ada banyak masalah. <br><br>  Misalnya, keadaan pengumpul sampah (dalam versi 3.7 &lt;) milik runtime. <br><br>  Dalam perubahan selama sprint PyCon, keadaan pengumpul sampah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai pindah</a> ke penerjemah, sehingga setiap subinterpreter akan memiliki pengumpul sampah sendiri (sebagaimana mestinya). <br><br>  Masalah lain adalah bahwa ada beberapa variabel "global" yang bertahan di basis kode CPython bersama dengan banyak ekstensi dalam C. Oleh karena itu, ketika orang tiba-tiba mulai memparalelkan kode mereka dengan benar, kami melihat beberapa masalah. <br><br>  Masalah lain adalah bahwa deskriptor file termasuk dalam proses, jadi jika Anda memiliki file yang terbuka untuk ditulis dalam satu penerjemah, subinterpreter tidak akan dapat mengakses file ini (tanpa perubahan lebih lanjut ke CPython). <br><br>  Singkatnya, masih banyak masalah yang perlu diatasi. <br><br><h2>  Kesimpulan: Apakah GIL benar lagi? </h2><br>  GIL akan terus digunakan untuk aplikasi single-threaded.  Karena itu, bahkan ketika mengikuti PEP554, kode single-threaded Anda tiba-tiba tidak akan menjadi paralel. <br>  Jika Anda ingin menulis kode paralel dengan Python 3.8, Anda akan memiliki masalah paralelisasi yang terkait dengan prosesor, tetapi ini juga merupakan tiket ke masa depan! <br><br><h2>  Kapan? </h2><br>  Pickle v5 dan berbagi memori untuk multiprosesing kemungkinan besar akan berada di Python 3.8 (Oktober 2019), dan sub-penerjemah akan muncul di antara versi 3.8 dan 3.9. <br>  Jika Anda memiliki keinginan untuk bermain-main dengan contoh-contoh yang disajikan, maka saya membuat cabang terpisah dengan semua kode yang diperlukan: <a href="">https://github.com/tonybaloney/cpython/tree/subinterpreters.</a> <br><br>  Apa yang Anda pikirkan tentang ini?  Tulis komentar Anda dan sampai jumpa di kursus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458694/">https://habr.com/ru/post/id458694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458684/index.html">ICANN menghapus ambang harga untuk domain .org - mengapa komunitas TI menentang dan apa yang akan terjadi selanjutnya</a></li>
<li><a href="../id458686/index.html">@Pythonetc Juni 2019</a></li>
<li><a href="../id458688/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, Juni 2019</a></li>
<li><a href="../id458690/index.html">Otomatiskan itu! Bagaimana kami meningkatkan pengujian integrasi</a></li>
<li><a href="../id458692/index.html">"Mungkin" monad melalui async / tunggu di C # (Tanpa Tugas!)</a></li>
<li><a href="../id458696/index.html">Tekstur, atau apa yang perlu Anda ketahui untuk menjadi Artis Permukaan. Bagian 3. PBR dan bahan-bahan</a></li>
<li><a href="../id458698/index.html">Jalur perdamaian dan jalur perang dalam proyek-proyek TI</a></li>
<li><a href="../id458702/index.html">Kereta luncur anjing: apa yang perlu Anda ketahui tentang mereka, dan bagaimana mereka dibawa</a></li>
<li><a href="../id458704/index.html">Implementasi sistem DLP pada contoh ritel</a></li>
<li><a href="../id458706/index.html">Gopnik sekarang ada di pasar luar negeri, atau "Mengapa begitu sulit menemukan programmer yang normal?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>