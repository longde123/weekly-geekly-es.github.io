<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèª üíâ üòª Golang: spezifische Leistungsprobleme üåÆ ü•´ ‚ùóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Go-Sprache wird immer beliebter. So zuversichtlich, dass es immer mehr Konferenzen gibt, zum Beispiel GolangConf , und die Sprache zu den zehn am ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang: spezifische Leistungsprobleme</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461291/">  Die Go-Sprache wird immer beliebter.  So zuversichtlich, dass es immer mehr Konferenzen gibt, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GolangConf</a> , und die Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu den zehn</a> am h√∂chsten bezahlten Technologien geh√∂rt.  Daher ist es bereits sinnvoll, √ºber die spezifischen Probleme, beispielsweise die Leistung, zu sprechen.  Zus√§tzlich zu den allgemeinen Problemen f√ºr alle kompilierten Sprachen hat Go seine eigenen.  Sie sind dem Optimierer, dem Stapel, dem Typsystem und dem Multitasking-Modell zugeordnet.  L√∂sungswege und Problemumgehungen sind manchmal sehr spezifisch. <br><br>  <strong>Daniel Podolsky</strong> , obwohl der Evangelist von Go, trifft in ihm auch auf viele seltsame Dinge.  Alles Seltsame und vor allem Interessante sammelt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">testet</a> und spricht dann in HighLoad ++ dar√ºber.  Das Protokoll des Berichts enth√§lt Zahlen, Grafiken, Codebeispiele, Profilerergebnisse, einen Vergleich der Leistung derselben Algorithmen in verschiedenen Sprachen - und alles andere, wof√ºr wir das Wort "Optimierung" so hassen.  Das Transkript wird keine Enth√ºllungen enthalten - woher kamen sie in einer so einfachen Sprache - und alles, wor√ºber in den Zeitungen gelesen werden kann. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>√úber die Lautsprecher.</strong>  <b>Daniil Podolsky</b> : 26 Jahre Erfahrung, 20 Jahre in Betrieb, einschlie√ülich des Gruppenleiters, 5 Jahre Programmierung auf Go.  <b>Kirill Danshin</b> : Sch√∂pfer von Gramework, Maintainer, Fast HTTP, Black Go-Magier. <br><br>  <em>Der Bericht wurde gemeinsam von Daniel Podolsky und Kirill Danshin erstellt, aber Daniel machte einen Bericht, und Kirill half mental.</em> <br><br><h2>  Sprachkonstruktionen </h2><br>  Wir haben einen Leistungsstandard - <code>direct</code> .  Dies ist eine Funktion, die eine Variable inkrementiert und nichts mehr tut. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  Das Ergebnis der Funktion ist <b>1,46 ns pro Operation</b> .  Dies ist die Mindestoption.  Schneller als 1,5 ns pro Operation, wird wahrscheinlich nicht funktionieren. <br><br><h3>  Verschiebe, wie wir ihn lieben </h3><br>  Viele kennen und lieben es, das verz√∂gerte Sprachkonstrukt zu verwenden.  Sehr oft benutzen wir es so. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br>  Aber so kann man es nicht benutzen!  Jeder Aufschub frisst 40 ns pro Operation. <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br>  Ich dachte, vielleicht liegt das an Inline?  Vielleicht ist Inline so schnell? <br><br>  Direkt ist inline und die Verz√∂gerungsfunktion kann nicht inline sein.  Daher wurde eine separate Testfunktion ohne Inline kompiliert. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br>  Nichts hat sich ge√§ndert, der Aufschub dauerte die gleichen 40 ns.  Lieber, aber nicht katastrophal. <br><br><blockquote>  Wenn eine Funktion weniger als 100 ns ben√∂tigt, k√∂nnen Sie auf eine Verz√∂gerung verzichten. </blockquote><br>  Wenn die Funktion jedoch l√§nger als eine Mikrosekunde dauert, ist sie alle gleich - Sie k√∂nnen die Verz√∂gerung verwenden. <br><br><h3>  √úbergabe eines Parameters als Referenz </h3><br>  Betrachten Sie einen popul√§ren Mythos. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br>  Nichts hat sich ge√§ndert - nichts ist es wert. <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br>  Mit Ausnahme von 3 ns pro Aufschub wird dieser jedoch f√ºr Schwankungen abgeschrieben. <br><br><h3>  Anonyme Funktionen </h3><br>  Manchmal fragen Neulinge: "Ist eine anonyme Funktion teuer?" <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote>  Eine anonyme Funktion ist nicht teuer, sie dauert 40,4 ns. </blockquote><br><h3>  Schnittstellen </h3><br>  Es gibt eine Schnittstelle und Struktur, die dies implementiert. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br>  Es gibt drei Optionen f√ºr die Verwendung der Inkrementierungsmethode.  Direkt von Struct: <code>var testStruct = testTypeStruct{}</code> . <br><br>  √úber die entsprechende konkrete Schnittstelle: <code>var testInterface testTypeInterface = &amp;testStruct</code> . <br><br>  Bei der Konvertierung der Laufzeitschnittstelle: <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> . <br><br>  Im Folgenden finden Sie die Konvertierung und Verwendung der Laufzeitschnittstelle direkt. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote>  Die Schnittstelle als solche kostet nichts. </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br>  Kosten f√ºr die Konvertierung der Laufzeitschnittstelle, aber nicht teuer - Sie m√ºssen dies nicht ausdr√ºcklich ablehnen.  Aber versuchen Sie, wo immer m√∂glich darauf zu verzichten. <br><br>  <b>Mythen:</b> <br><br><ul><li>  Dereferenzierung - Dereferenzierungszeiger - frei. </li><li>  Anonyme Funktionen sind kostenlos. </li><li>  Schnittstellen sind kostenlos. </li><li>  Konvertierung der Laufzeitschnittstelle - NICHT KOSTENLOS. </li></ul><br><h3>  Wechseln, zuordnen und schneiden </h3><br>  Jeder Neuling fragt, was passiert, wenn Sie den Schalter durch eine Karte ersetzen.  Wird es schneller sein? <br><br>  Schalter gibt es in verschiedenen Gr√∂√üen.  Ich habe drei Gr√∂√üen getestet: klein f√ºr 10 F√§lle, mittel f√ºr 100 und gro√ü f√ºr 1000 F√§lle.  Schalter f√ºr 1000 F√§lle finden Sie im realen Produktionscode.  Nat√ºrlich schreibt niemand sie mit seinen H√§nden.  Dies ist automatisch generierter Code, normalerweise ein Typschalter.  Getestet an zwei Typen: int und string.  Es schien, als w√ºrde es klarer werden. <br><br>  <strong>Kleiner Schalter.</strong>  Die schnellste Option ist der eigentliche Schalter.  Es folgt sofort ein Slice, in dem der entsprechende Integer-Index einen Verweis auf die Funktion enth√§lt.  Map ist weder in int noch in string ein Leader. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  500000000 </td><td>  3,26 ns / op </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  100.000.000 </td><td>  11,70 ns / op </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  500000000 </td><td>  3,85 ns / op </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  100.000.000 </td><td>  12,70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  100.000.000 </td><td>  15,60 ns / op </td></tr></tbody></table></div><br>  Das Einschalten von Strings ist erheblich langsamer als bei int.  Wenn Sie nicht zu string, sondern zu int wechseln k√∂nnen, tun Sie dies. <br><br>  <strong>Mittlerer Schalter.</strong>  Switch selbst regiert immer noch int, aber Slice hat es ein bisschen √ºberholt.  Karte ist immer noch schlecht.  Bei einem String-Schl√ºssel ist die Map jedoch schneller als der Switch - wie erwartet. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  300000000 </td><td>  4,55 ns / op </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  100.000.000 </td><td>  17,10 ns / op </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  300000000 </td><td>  3,76 ns / op </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50.000.000 </td><td>  28,50 ns / op </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  100.000.000 </td><td>  20.30 ns / op </td></tr></tbody></table></div><br>  <strong>Gro√üer Schalter.</strong>  Tausend F√§lle zeigen den bedingungslosen Sieg der Karte in der Nominierung ‚ÄûSwitch by String‚Äú.  Theoretisch hat Slice gewonnen, aber in der Praxis empfehle ich, hier denselben Schalter zu verwenden.  Die Karte ist immer noch langsam, selbst wenn man bedenkt, dass die Karte Ganzzahlschl√ºssel mit einer speziellen Hash-Funktion hat.  Im Allgemeinen macht diese Funktion nichts.  Das int selbst hat einen Hash f√ºr int. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  100.000.000 </td><td>  13,6 ns / op </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50.000.000 </td><td>  34,3 ns / op </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  100.000.000 </td><td>  12,8 ns / op </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20.000.000 </td><td>  100,0 ns / op </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37,4 ns / op </td></tr></tbody></table></div><br>  <strong>Schlussfolgerungen</strong>  Die Karte ist nur bei gro√üen Mengen besser und nicht bei einer ganzzahligen Bedingung.  Ich bin sicher, dass es sich unter allen Bedingungen au√üer int genauso verh√§lt wie auf string.  Slice lenkt immer, wenn die Bedingungen ganzzahlig sind.  Verwenden Sie diese Option, wenn Sie Ihr Programm um 2 ns beschleunigen m√∂chten. <br><br><h2>  Interroutine Interaktion </h2><br>  Das Thema ist komplex, ich habe viele Tests durchgef√ºhrt und werde die aufschlussreichsten vorstellen.  Wir kennen die folgenden <strong>Mittel zur Interaktion zwischen Agenturen</strong> . <br><br><ul><li>  Atomic  Dies sind Mittel mit eingeschr√§nkter Anwendbarkeit - Sie k√∂nnen den Zeiger ersetzen oder int verwenden. </li><li>  Mutex ist seit Java weit verbreitet. </li><li>  Der Kanal ist einzigartig f√ºr GO. </li><li>  Gepufferter Kanal - gepufferte Kan√§le. </li></ul><br>  Nat√ºrlich habe ich an einer deutlich gr√∂√üeren Anzahl von Goroutinen getestet, die um eine Ressource konkurrieren.  Aber er w√§hlte drei als Indikator: ein wenig - 100, ein mittleres - 1000 und viel - 10000. <br><br>  <strong>Das Lastprofil ist unterschiedlich</strong> .  Manchmal m√∂chten alle Gorutins in eine Variable schreiben, aber das ist selten.  Normalerweise schreiben schlie√ülich einige, andere lesen.  Von den meisten Lesern - 90% lesen, von denen, die schreiben - schreiben 90%. <br><br>  Dies ist der Code, der verwendet wird, damit die Goroutine, die den Kanal bedient, sowohl das Lesen als auch das Schreiben in eine Variable erm√∂glicht. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br>  Wenn eine Nachricht √ºber den Kanal, √ºber den wir schreiben, bei uns eintrifft, f√ºhren wir sie aus.  Wenn der Kanal geschlossen ist, beenden wir Goroutin.  Wir sind jederzeit bereit, in den Kanal zu schreiben, der von anderen Goroutinen zum Lesen verwendet wird. <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  100.000.000 </td><td>  16.30 ns / op </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6,72 ns / op </td></tr><tr><td>  Benchmarkcan-4 </td><td>  5.000.000 </td><td>  239,00 ns / op </td></tr></tbody></table></div><br>  Dies sind Daten f√ºr eine Goroutine.  Der Kanaltest wird an zwei Goroutinen durchgef√ºhrt: Eine verarbeitet den Kanal, die andere schreibt in diesen Kanal.  Und diese Optionen wurden an einem getestet. <br><br><ul><li>  Direktes Schreiben in eine Variable. </li><li>  Mutex nimmt ein Protokoll, schreibt in eine Variable und gibt ein Protokoll frei. </li><li>  Atomic schreibt √ºber Atomic in eine Variable.  Es ist nicht kostenlos, aber immer noch deutlich billiger als Mutex auf einem Garutin. </li></ul><br>  Mit einer kleinen Menge Goroutine ist der Atomic eine effektive und schnelle M√∂glichkeit zur Synchronisierung, was nicht √ºberraschend ist.  Direkt ist nicht hier, weil wir eine Synchronisation brauchen, die es nicht bietet.  Aber Atomic hat nat√ºrlich M√§ngel. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns / op </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100.000 </td><td>  14585 ns / op </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1.000.000 </td><td>  2094 ns / op </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449.666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442.708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100.000 </td><td>  13358 ns / op </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449.556 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445423 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns / op </td></tr></tbody></table></div><br>  Als n√§chstes kommt Mutex.  Ich habe erwartet, dass Channel ungef√§hr so ‚Äã‚Äãschnell ist wie Mutex, aber nein. <br><br><blockquote>  Channel ist eine Gr√∂√üenordnung teurer als Mutex. </blockquote><br>  Dar√ºber hinaus werden Channel und gepufferter Channel ungef√§hr zum gleichen Preis angeboten.  Und es gibt einen Kanal, in dem der Puffer niemals √ºberl√§uft.  Es ist eine Gr√∂√üenordnung billiger als dasjenige, dessen Puffer √ºberl√§uft.  Nur wenn der Puffer im Kanal nicht voll ist, kostet er ungef√§hr die gleichen Gr√∂√üenordnungen wie Mutex.  Das habe ich vom Test erwartet. <br><br>  Dieses Bild mit der Verteilung der Kosten wird in jedem Lastprofil wiederholt - sowohl in MostlyRead als auch in MostlyWrite.  Dar√ºber hinaus kostet der vollst√§ndige MostlyRead-Kanal das gleiche wie der unvollst√§ndige.  Und der gepufferte Kanal von MostlyWrite, in dem der Puffer nicht voll ist, kostet das gleiche wie der Rest.  Ich kann nicht sagen, warum dies so ist - ich habe dieses Problem noch nicht untersucht. <br><br><h2>  Parameter √ºbergeben </h2><br>  <strong>Wie kann man Parameter schneller √ºbergeben - als Referenz oder nach Wert?</strong>  Lass es uns √ºberpr√ºfen. <br><br>  Ich habe Folgendes √ºberpr√ºft - verschachtelte Typen von 1 bis 10 erstellt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br>  Der zehnte verschachtelte Typ hat 10 int64-Felder, und die verschachtelten Typen der vorherigen Verschachtelung sind ebenfalls 10. <br><br>  Dann schrieb er Funktionen, die eine Art Verschachtelung erzeugen. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br>  Zum Testen habe ich drei Optionen des Typs verwendet: klein mit Verschachtelung 2, mittel mit Verschachtelung 3, gro√ü mit Verschachtelung 5. Ich musste nachts einen sehr gro√üen Test mit Verschachtelung 10 durchf√ºhren, aber dort ist das Bild genau das gleiche wie f√ºr 5. <br><br>  <b>In Funktionen ist das √úbergeben von Werten mindestens doppelt so schnell wie das √úbergeben von Referenzen</b> .  Dies liegt an der Tatsache, dass durch √úbergeben eines Werts die Escape-Analyse nicht geladen wird.  Dementsprechend befinden sich die Variablen, die wir zuweisen, auf dem Stapel.  Es ist wesentlich billiger f√ºr die Laufzeit, f√ºr Garbage Collector.  Obwohl er m√∂glicherweise keine Zeit hat, sich zu verbinden.  Diese Tests dauerten einige Sekunden - der M√ºllsammler schlief wahrscheinlich noch. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200.000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100.000 </td><td>  15985 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  30 </td><td>  47398456 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2>  Schwarze Magie </h2><br>  Wissen Sie, was dieses Programm ausgeben wird? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br>  Das Ergebnis des Programms h√§ngt von der Architektur ab, auf der es ausgef√ºhrt wird.  Auf Little Endian, z. B. AMD64, wird das Programm angezeigt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhh9SOQhj3ZFfGluQET-vu28Fnu5DQ#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhh9SOQhj3ZFfGluQET-vu28Fnu5DQ#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhh9SOQhj3ZFfGluQET-vu28Fnu5DQ#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  .  Auf Big Endian, einer.  Das Ergebnis ist anders, da diese Einheit bei Little Endian in der Mitte der Zahl und bei Big Endian am Ende erscheint. <br><br>  Es gibt immer noch Prozessoren auf der Welt, auf denen Endian-Switches verwendet werden, z. B. Power PC.  Sie m√ºssen herausfinden, welches Endian beim Start auf Ihrem Computer konfiguriert ist, bevor Sie R√ºckschl√ºsse darauf ziehen, was unsichere Tricks bewirken.  Wenn Sie beispielsweise einen Go-Code schreiben, der auf einem IBM Multiprozessorserver ausgef√ºhrt wird. <br><br>  Ich habe diesen Code zitiert, um zu erkl√§ren, warum ich alle unsichere schwarze Magie betrachte.  Sie m√ºssen es nicht verwenden.  Aber Cyril glaubt, dass es notwendig ist.  Und hier ist warum. <br><br>  Es gibt eine Funktion, die dasselbe tut wie GOB - Go Binary Marshaller.  Dies ist Encoder, aber auf unsicher. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  Tats√§chlich ben√∂tigt es ein St√ºck Speicher und zieht ein Array von Bytes daraus. <br><br>  Dies ist nicht einmal eine Bestellung - dies sind zwei Bestellungen.  Daher z√∂gert Cyril Danshin, wenn er einen Hochleistungscode schreibt, nicht, sich auf die Eingeweide seines Programms einzulassen und es unsicher zu machen. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Benchmark Gob-4 </td><td>  200.000 </td><td>  8466 ns / op </td><td>  120,94 MB / s </td></tr><tr><td>  BenchmarkUnsafeMut-4 </td><td>  50.000.000 </td><td>  37 ns / op </td><td>  27691,06 MB / s </td></tr></tbody></table></div><blockquote>  Wir werden am 7. Oktober auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GolangConf</a> spezifischere Funktionen von Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diskutieren</a> - eine Konferenz f√ºr diejenigen, die Go in der beruflichen Entwicklung einsetzen, und f√ºr diejenigen, die diese Sprache als Alternative betrachten.  Daniil Podolsky ist nur ein Mitglied des Programmausschusses. Wenn Sie mit diesem Artikel streiten oder verwandte Themen aufdecken m√∂chten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reichen Sie einen Antrag</a> f√ºr einen Bericht ein. <br><br>  F√ºr alles andere, was die hohe Leistung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">betrifft</a> , nat√ºrlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> .  Wir akzeptieren dort auch Bewerbungen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Melden Sie sich</a> f√ºr den Newsletter an und bleiben Sie √ºber die Neuigkeiten aller unserer Konferenzen f√ºr Webentwickler auf dem Laufenden. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461291/">https://habr.com/ru/post/de461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461281/index.html">Exemplarische Vorgehensweise zum Einrichten eines BIND-DNS-Servers in einer Chroot-Umgebung f√ºr Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../de461283/index.html">Softwarearchitektur und Systemdesign: Das Big Picture and Resource Guide</a></li>
<li><a href="../de461285/index.html">5 Haupt-Sampling-Algorithmen</a></li>
<li><a href="../de461287/index.html">Entwicklung einer listigen KI in einem taktischen Spiel, das auf Heuristiken und Mutationen basiert</a></li>
<li><a href="../de461289/index.html">CLion 2019.2 ver√∂ffentlicht: Unterst√ºtzung f√ºr eingebettete Entwicklung, Debugger f√ºr MSVC, Suche nach nicht verwendeten Header-Dateien</a></li>
<li><a href="../de461297/index.html">Wie moderne gezielte Angriffe aussehen</a></li>
<li><a href="../de461299/index.html">Wie der PC die Medienbranche mit erfolgreicher Software eroberte: Er√∂rterung von Pro Tools und Media Composer</a></li>
<li><a href="../de461303/index.html">Verwendung der Troika-Karte als obligatorische Krankenversicherung</a></li>
<li><a href="../de461305/index.html">Firmennetzwerk und MitM. Teil 2</a></li>
<li><a href="../de461307/index.html">Wir laden Sie zum VK Hackathon 2019 ein. Der diesj√§hrige Preispool betr√§gt zwei Millionen Rubel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>