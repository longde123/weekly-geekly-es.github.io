<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗻 🎹 💅🏾 Usamos um switch sem fio de 433 MHz para controlar o PC 🈯️ 🙇🏿 🚓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, Geektimes Habr. 

 Na minha casa, vários comutadores sem fio de 433 MHz acumulados em casa, tornou-se interessante se eles podem ser usados ​​par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usamos um switch sem fio de 433 MHz para controlar o PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414285/">  Olá, <s>Geektimes</s> Habr. <br><br>  Na minha casa, vários comutadores sem fio de 433 MHz acumulados em casa, tornou-se interessante se eles podem ser usados ​​para qualquer tarefa, por exemplo, controlar um computador ou integrar uma “casa inteligente” ao sistema. <br><br>  Esses comutadores são convenientes por seu baixo custo e operação estável, eles se parecem com isso: <br><br><img src="https://habrastorage.org/webt/up/tt/p4/upttp4hzw_us_v2bb0kdliszify.jpeg"><br><br>  Como funciona e o que pode ser feito com eles (os hussardos ficam calados :), detalhes sob o corte. <a name="habracut"></a><br><br><h2>  Teoria </h2><br>  Eu tenho que dizer imediatamente como essa opção funciona, eu não sei, embora eu pense sobre isso.  Então você precisará fazer um pouco de engenharia reversa. <br><br>  Primeiro de tudo, o sinal deve ser recebido, para o qual usamos o já conhecido receptor RTL-SDR, geralmente chamado simplesmente de "apito" para radioamadores.  Este dispositivo, ao preço de apenas US $ 10, permite receber sinais de rádio na faixa de 50 a 1250 MHz, para nós o que precisamos.  O tópico é antigo, mas se alguém não o leu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">leia-o</a> . <br><br>  Damos o primeiro passo da análise - analisamos cuidadosamente o interruptor.  Nós achamos que no verso do case diz “Made in China” (quem teria pensado?) E, mais importante, a frequência 433 MHz é indicada.  Agora você pode conectar o receptor SDR, iniciar o SDR # e garantir que os dados sejam realmente transmitidos. <br><br><img src="https://habrastorage.org/webt/qd/wd/hd/qdwdhdd9acsjgl1rp5cbobpb-qg.jpeg"><br><br>  A simetria do sinal no espectro sugere a presença de modulação AM.  A propósito, um sinal "alienígena" mais fraco é visível à direita - eles também podem ser recebidos e decodificados, serão discutidos em mais detalhes separadamente.  No entanto, de volta ao sinal.  Gravamos no formato WAV usual e pressionamos os botões no controle remoto - por exemplo, pressionei os botões ON e OFF no canal “1”. <br><br>  Abra o arquivo de som em qualquer editor de áudio e use outra ferramenta de análise profissional, o Paint, para comparar sinais.  Colocamos 2 sinais de botões diferentes, um acima do outro, para ver a diferença: <br><br><img src="https://habrastorage.org/webt/hy/s5/8c/hys58cp3y1f0dujky-3kzjxxb1y.png"><br><br>  É fácil ver que temos a sequência de bits usual, cuja diferença é de apenas um bit, correspondente ao botão ON ou OFF.  Enquanto o botão é pressionado, o interruptor repete ciclicamente essa sequência no ar a uma velocidade de 20 vezes por segundo.  Barato e fácil, mesmo que uma sequência seja distorcida durante a transmissão, a outra será aceita. <br><br>  A partir disso, a propósito, uma conclusão importante pode ser feita - os sinais de tais comutadores (estamos falando de modelos baratos) são transmitidos "no estado em que se encontram" sem autenticação, proteção ou criptografia.  Esse comutador ou uma tomada sem fio com esse comutador não deve ser usado para algumas funções importantes, por exemplo, para ligar aquecedores potentes ou mais ainda para abrir a porta da frente ou a garagem.  Não é apenas uma questão de hackers (a chance de alguém invadir minha casa sem fio, eu estimo menos do que a chance de cair na minha casa da ISS), mas um vizinho pode comprar acidentalmente o mesmo switch e os códigos podem corresponder ( no entanto, no switch, há uma escolha entre 4 canais).  Na minha experiência de usá-lo, 2-3 vezes por ano, o disjuntor se ligava "em si", um obstáculo ou um sinal distante do mesmo modelo era realmente recebido. <br><br>  Obviamente, isso não se aplica a sistemas mais complexos, como Lora ou Philips Hue, tudo está bem com a criptografia. <br><br>  No entanto, voltemos à nossa tarefa.  Você mesmo pode escrever um decodificador desses sinais, mas, felizmente, isso já foi feito antes de nós, em um projeto chamado "rtl_433".  O programa foi originalmente criado para Linux, a versão do Windows pode ser baixada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na</a> versão do Linux pode ser baixada do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br>  Iniciamos o programa na linha de comando: "rtl_433.exe -F json" <br><br><img src="https://habrastorage.org/webt/op/en/qn/openqnlud5suc071yu4_ja_ro-a.png"><br><br>  Temos os dados, resta escrever um programa para o processamento deles. <br><br><h2>  Raspberry pi </h2><br>  A primeira coisa que é interessante considerar é o Raspberry Pi.  Para instalar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rtl_433</a> no Raspbian, descompacte o <a href="">arquivo</a> e execute os seguintes comandos. <br><br><pre><code class="bash hljs">sudo apt-get install libtool libusb-1.0.0-dev librtlsdr-dev rtl-sdr build-essential autoconf cmake pkg-config <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rtl_433/ autoreconf --install ./configure make make install</code> </pre> <br>  O segundo passo é escrever um programa que receba esses dados e, dependendo deles, execute as ações necessárias.  O código Python é bem direto: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os, sys, io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess print(<span class="hljs-string"><span class="hljs-string">"RTLSDR listening started"</span></span>) transmitter_name = <span class="hljs-string"><span class="hljs-string">"Waveman Switch Transmitter"</span></span> transmitter_channel = <span class="hljs-number"><span class="hljs-number">1</span></span> proc = subprocess.Popen([<span class="hljs-string"><span class="hljs-string">"rtl_433 -F json"</span></span>], stdout=subprocess.PIPE, shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: line = proc.stdout.readline().encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>,<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>) proc.poll() data = json.loads(line) print(data) m,st,ch,btn= data[<span class="hljs-string"><span class="hljs-string">'model'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'state'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'channel'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'button'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m==transmitter_name <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ch==transmitter_channel <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> btn==<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> st==<span class="hljs-string"><span class="hljs-string">'on'</span></span>: print(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> m==transmitter_name <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ch==transmitter_channel <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> btn==<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> st==<span class="hljs-string"><span class="hljs-string">'off'</span></span>: print(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> print(<span class="hljs-string"><span class="hljs-string">"RTLSDR listening done"</span></span>)</code> </pre> <br>  Para executar o código, você precisa salvá-lo em um arquivo (por exemplo, rtl_listen.py) e executar o comando “python rtl_listen.py”. <br><br>  Como você pode ver, o programa inicia o processo usando subprocess.Popen e lê os dados a partir dele.  Então tudo é simples, o código é bastante legível e não será difícil fazer alterações.  Neste exemplo, quando o botão "1" é pressionado, a mensagem de impressão ("ON") é exibida. Em vez disso, você pode fazer outra coisa, por exemplo, ativar o pino GPIO, ligar o relé, enviar dados para o servidor, etc. Antes de usá-lo, será necessário alterá-lo ao mesmo tempo nome transmitter_name no nome do modelo do console que será usado. <br><br>  A propósito, o próprio receptor RTL-SDR, em comparação com o Raspberry Pi, fica assim: <br><br><img src="https://habrastorage.org/webt/ju/yp/eo/juypeoflpdtecvmhvtjpc4hrx2y.jpeg"><br><br><h2>  Windows </h2><br>  Infelizmente, no Windows 10, o código acima não funcionou.  Mas, como sugeriu uma pesquisa no github, a leitura assíncrona de dados de um fluxo separado funciona.  Por que foi tão preguiçoso para descobrir, vou colocar o código de trabalho embaixo do spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Código fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os, sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Queue <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsynchronousFileReader</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(threading.Thread)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Helper class to implement asynchronous reading def __init__(self, fd, queue): assert isinstance(queue, Queue.Queue) assert callable(fd.readline) threading.Thread.__init__(self) self._fd = fd self._queue = queue def run(self): # The body of the tread: read lines and put them on the queue. for line in iter(self._fd.readline, ''): self._queue.put(line) def eof(self): # Check whether there is no more content to expect return not self.is_alive() and self._queue.empty() def replace(string): while ' ' in string: string = string.replace(' ', ' ') return string def read_rtl_data(): process = subprocess.Popen(["rtl_433.exe", "-F", "json"], stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Launch the asynchronous readers of stdout and stderr. stdout_queue = Queue.Queue() stdout_reader = AsynchronousFileReader(process.stdout, stdout_queue) stdout_reader.start() stderr_queue = Queue.Queue() stderr_reader = AsynchronousFileReader(process.stderr, stderr_queue) stderr_reader.start() transmitter_name = "Waveman Switch Transmitter" transmitter_channel = 1 # Check the queues if we received some output while not stdout_reader.eof() or not stderr_reader.eof(): # Show what we received from standard output. while not stdout_queue.empty(): line = stdout_queue.get() print("Line1:", repr(line)) data = json.loads(line) # print("Data:", repr(line)) m,st,ch,btn= data['model'],data['state'],data['channel'],data['button'] if m==transmitter_name and ch==transmitter_channel and btn==1 and st=='on': print("ON") elif m==transmitter_name and ch==transmitter_channel and btn==1 and st=='off': print("OFF") # Show what we received from standard error. while not stderr_queue.empty(): line = replace(stderr_queue.get()) print("Line2:", line) # Sleep a bit before asking the readers again. time.sleep(0.1) stdout_reader.join() stderr_reader.join() # Close subprocess' file descriptors. process.stdout.close() process.stderr.close() if __name__ == '__main__': print("RTLSDR listening started") read_rtl_data() print("RTLSDR listening done")</span></span></code> </pre><br></div></div><br>  Com esse código, podemos usar qualquer ação no manipulador, a lógica é a mesma do código no Raspberry Pi. <br><br>  <b>Exemplo</b> : suponha que tenhamos um computador dedicado a um home theater e queremos desligá-lo pressionando o botão no controle remoto.  Substitua o código 'print ("OFF")' por <br><br><pre> <code class="python hljs"> os.system(<span class="hljs-string"><span class="hljs-string">'shutdown -s'</span></span>) sys.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Depois disso, o computador será desligado pressionando o botão apropriado.  Obviamente, além de “shutdown -s”, você pode usar qualquer outro comando do Windows, basta considerar que os comandos serão enviados repetidamente, enquanto o botão do controle remoto for pressionado, para evitar essa duplicação, é necessário melhorar o código. <br><br><h2>  Conclusão </h2><br>  Como você pode ver, tudo é bem simples e há espaço para experimentação.  Finalmente, um pequeno bônus para quem leu até aqui.  Em 433 MHz, há um grande número de dispositivos diferentes que o rtl_433 pode decodificar, basta deixar o programa para trabalhar por várias horas e ver o que "captura".  Sob o spoiler, um exemplo desse registro, registrado anteriormente: <br><br><div class="spoiler">  <b class="spoiler_title">Log</b> <div class="spoiler_text"> <code>2018-01-10 21:15:17 : Prologue sensor : 5 : 15 <br> Channel: 1 <br> Battery: OK <br> Button: 0 <br> Temperature: 6.00 C <br> Humidity: 11 % <br> <br> 2018-01-10 21:15:28 : inFactory sensor <br> ID: 71 <br> Temperature: 6.67 °C <br> Humidity: 99 % <br> <br> 2018-01-10 21:16:07 : Toyota : TPMS : 61511475 : 60e5006b : CRC <br> <br> 2018-01-10 21:20:33 : Prologue sensor : 5 : 15 <br> Channel: 1 <br> Battery: OK <br> Button: 0 <br> Temperature: 6.00 C <br> Humidity: 11 % <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> <br> 2018-01-10 21:21:21 : Akhan 100F14 remote keyless entry <br> ID (20bit): 0x41 <br> Data (4bit): 0x4 (Mute) <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: off <br> <br> 2018-01-10 21:32:31 : Ford : TPMS : 00268b1f : a34a0e : CHECKSUM <br> 2018-01-10 21:32:32 : Ford : TPMS : 00268a5c : 9c440e : CHECKSUM <br> 2018-01-10 21:32:37 : Ford : TPMS : 016dbfce : 99430e : CHECKSUM <br> 2018-01-10 21:32:39 : Ford : TPMS : 002671a0 : 9c4a0e : CHECKSUM</code> <br> </div></div><br>  Existem dados interessantes, por exemplo, a pressão dos pneus do carro de um vizinho (TPMS, sistema de monitoramento de pressão dos pneus) ou a temperatura externa +6 do sensor de outra pessoa.  Isso permite, por exemplo, exibir a temperatura externa se os vizinhos tiverem acidentalmente uma estação meteorológica compatível com este protocolo. <br><br>  Todas as experiências bem sucedidas. <br><br>  <b>Exoneração de responsabilidade</b> : Obviamente, o uso de SDR e processamento digital para ler sinais de modulação OOK é essencialmente uma arma disparada contra pardais.  Talvez no aliexpress existam receptores de prateleira por US $ 1 a 2 que fazem a mesma coisa, com menor custo e menor consumo de energia.  Se alguém conhece esses modelos, escreva nos comentários. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414285/">https://habr.com/ru/post/pt414285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414273/index.html">O que você precisa saber antes de desenvolver um backtester para uma estratégia de negociação: problemas típicos, tipos de sistemas e seus parâmetros</a></li>
<li><a href="../pt414277/index.html">Homem, seu ambiente e a Internet das coisas</a></li>
<li><a href="../pt414279/index.html">Votação de relatórios na oitava reunião DIY no Mail.Ru Group (07.07.2018)</a></li>
<li><a href="../pt414281/index.html">Desenvolvimento de um velocímetro de bicicleta baseado em uma tela do Nokia 3310</a></li>
<li><a href="../pt414283/index.html">Como distinguir criptomoeda de não criptomoeda</a></li>
<li><a href="../pt414289/index.html">A SpaceX abriu um trabalho como engenheiro de foguetes para criar um BFR</a></li>
<li><a href="../pt414293/index.html">O terceiro ReactOS Hackfest anual será realizado de 14 a 21 de agosto de 2018 em Berlim</a></li>
<li><a href="../pt414295/index.html">“Era possível”: maneiras incomuns, mas eficazes, de usar tecnologias de “áudio”</a></li>
<li><a href="../pt414299/index.html">Upgrade roomba 780</a></li>
<li><a href="../pt414303/index.html">Reino Unido gasta £ 6 milhões em cientistas de dados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>