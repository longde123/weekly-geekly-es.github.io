<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêøÔ∏è ü¶Ñ üëáüèª Wireshark 3.x: analyse de code sous macOS et revue des erreurs üÜé üëµüèª ‚Ü©Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wireshark Foundation a publi√© la version stable finale de l'analyseur de trafic r√©seau populaire - Wireshark 3.0.0. La nouvelle version corrige plusie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wireshark 3.x: analyse de code sous macOS et revue des erreurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/447156/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/b08/9a1/e5db089a18a6e0f13aaf26e7f0c5fb91.png" alt="Image 1"></div><br>  Wireshark Foundation a publi√© la version stable finale de l'analyseur de trafic r√©seau populaire - Wireshark 3.0.0.  La nouvelle version corrige plusieurs bugs, il est d√©sormais possible d'analyser les nouveaux protocoles, √† part que le pilote sur Npcap WinPcap est remplac√©.  C'est ici que se termine la citation de l'annonce et que commence notre note sur les bogues du projet.  Les auteurs des projets n'ont certainement pas fait de leur mieux pour corriger les bogues avant la sortie. <br><br>  Collectons les correctifs d√®s maintenant pour donner un motif de faire une nouvelle version :). <br><br><h2>  Pr√©sentation </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wireshark</a> est un outil bien connu pour capturer et analyser le trafic r√©seau.  Le programme fonctionne avec la grande majorit√© des protocoles connus, poss√®de une interface graphique intuitive et logique, un syst√®me de filtres tout-puissant.  Wireshark est multiplateforme, fonctionne dans des syst√®mes d'exploitation tels que: Windows, Linux, macOS, Solaris, FreeBSD, NetBSD et bien d'autres. <br><br>  Pour faire l'analyse du code source, nous avons utilis√© l'analyseur de code statique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> .  Pour analyser le code source, nous avons d'abord d√ª compiler le projet dans un OS.  Le choix √©tait large non seulement en raison de la nature multiplateforme du projet, mais aussi en raison de celle de l'analyseur.  J'ai choisi macOS pour l'analyse.  Vous pouvez √©galement ex√©cuter l'analyseur sous Windows et Linux. <br><a name="habracut"></a><br>  Je voudrais attirer une attention particuli√®re sur la qualit√© du code.  Malheureusement, je ne peux pas lui donner de gros points.  C'est une √©valuation subjective, mais comme nous v√©rifions r√©guli√®rement de nombreux projets, j'ai un cadre de r√©f√©rence.  Ce qui ressort dans ce cas, c'est un grand nombre d'avertissements PVS-Studio pour une petite quantit√© de code.  Au total, plus de 3500 avertissements de tous niveaux d√©clench√©s pour ce projet.  C'est typique des projets, qui n'utilisent g√©n√©ralement pas d'outils d'analyse statique, m√™me gratuits.  Un autre facteur indiquant la qualit√© du projet est les erreurs r√©p√©t√©es d√©tect√©es par l'analyseur.  Je ne citerai pas d'exemples de code de m√™me type, alors que des erreurs similaires se produisent dans des centaines d'endroits. <br><br>  Ces insertions ne donnent pas non plus un coup de pouce √† la qualit√© du code: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Input file: packet-acse-template.c */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta"> 1 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./asn1/acse/packet-acse-template.c"</span></span></span></span></code> </pre> <br>  Il y en a plus de 1000 dans l'ensemble du projet.  De telles insertions rendent plus difficile pour l'analyseur de faire correspondre les avertissements √©mis avec les fichiers appropri√©s.  Eh bien, je pense que les d√©veloppeurs moyens ne profiteront pas du maintien d'un tel code. <br><br><h2>  Typos </h2><br>  <b>Avertissement 1</b> <br><br>  V641 La taille de la m√©moire tampon allou√©e n'est pas un multiple de la taille de l'√©l√©ment.  mate_setup.c 100 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> mate_cfg_gog* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gogcfg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mate_config* mc, gchar* name)</span></span></span><span class="hljs-function"> </span></span>{ mate_cfg_gog* cfg = (mate_cfg_gog *)g_malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mate_cfg_gop)); .... }</code> </pre> <br>  Il existe des structures de deux types: <i>mate_cfg_gog</i> et <i>mate_cfg_gop,</i> elles sont tr√®s similaires, mais pas √©gales.  Tr√®s probablement, dans ce fragment de code, les fonctions sont m√©lang√©es, ce qui est lourd d'erreurs potentielles dans le programme lors de l'acc√®s √† la m√©moire par un pointeur. <br><br>  Voici les fragments de structures de donn√©es m√©lang√©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gog</span></span></span><span class="hljs-class"> {</span></span> gchar* name; GHashTable* items; guint last_id; GPtrArray* transforms; LoAL* keys; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">gop_tree_mode_t</span></span> gop_tree_mode; gboolean show_times; .... } mate_cfg_gog; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gop</span></span></span><span class="hljs-class"> {</span></span> gchar* name; guint last_id; GHashTable* items; GPtrArray* transforms; gchar* on_pdu; AVPL* key; AVPL* start; AVPL* stop; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> idle_timeout; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lifetime; gboolean drop_unassigned; <span class="hljs-keyword"><span class="hljs-keyword">gop_pdu_tree_t</span></span> pdu_tree_mode; gboolean show_times; .... } mate_cfg_gop;</code> </pre> <br>  <b>Avertissement 2</b> <br><br>  V519 La variable 'HDR_TCP.dest_port' re√ßoit des valeurs successives deux fois.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 495, 496. text_import.c 496 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_current_packet</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... HDR_TCP.source_port =isOutbound ? g_htons(hdr_dest_port):g_htons(hdr_src_port); HDR_TCP.dest_port = isOutbound ? g_htons(hdr_src_port) :g_htons(hdr_dest_port); HDR_TCP.dest_port = g_htons(hdr_dest_port); .... }</code> </pre> <br>  Dans la derni√®re ligne, la valeur (qui vient d'√™tre √©valu√©e) de la variable <i>HDR_TCP.dest_port</i> est r√©√©crite. <br><br><h2>  Erreurs logiques </h2><br>  Dans cette section, je citerai plusieurs exemples d'erreurs dans les op√©rateurs conditionnels, et tous seront compl√®tement diff√©rents les uns des autres. <br><br>  <b>Avertissement 1</b> <br><br>  V547 L'expression 'direction == 0' est toujours fausse.  packet-adb.c 291 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_RECV 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_SENT 0 static void save_command(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( service_data &amp;&amp; service_data-&gt;remote_id == 0 &amp;&amp; direction == P2P_DIR_RECV) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (direction == P2P_DIR_SENT) { service_data-&gt;remote_id = arg1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// unreachable code } else { service_data-&gt;remote_id = arg0; } .... } .... }</span></span></span></span></code> </pre> <br>  Dans la condition externe, la variable de <i>direction</i> est compar√©e √† la constante <i>P2P_DIR_RECV.</i>  Selon les expressions √©crites avec l'op√©rateur AND, en arrivant √† la condition int√©rieure, la valeur de la <i>direction</i> variable sera certainement diff√©rente d'une autre constante <i>P2P_DIR_SENT</i> . <br><br>  <b>Avertissement 2</b> <br><br>  V590 Envisagez d'inspecter le '(type == 0x1) ||  (tapez! = 0x4) '.  L'expression est excessive ou contient une erreur d'impression.  packet-fcsb3.c 686 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_fc_sbccs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((type == FC_SBCCS_IU_CMD_HDR) || (type != FC_SBCCS_IU_CMD_DATA)) { .... }</code> </pre> <br>  L'erreur de ce fragment de code est que le r√©sultat de la condition ne d√©pend que d'une seule expression: <br><br><pre> <code class="cpp hljs">(type != FC_SBCCS_IU_CMD_DATA)</code> </pre> <br>  <b>Avertissement 3</b> <br><br>  V590 Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  snort-config.c 40 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhiteSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *accumulated_offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Skip any leading whitespace */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (source[offset] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; source[offset] == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { offset++; } *accumulated_offset += offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source + offset; }</code> </pre> <br>  Le r√©sultat de l'op√©rateur conditionnel ne d√©pendra que de cette partie de l'expression <i>(source [offset] == ‚Äã‚Äã'')</i> .  La v√©rification <i>(source [offset]! = '\ 0')</i> est redondante et peut √™tre supprim√©e en toute s√©curit√©.  Ce n'est pas l'erreur r√©elle, mais le code redondant rend la lecture et la compr√©hension du programme plus difficiles, il est donc pr√©f√©rable de le simplifier. <br><br>  <b>Avertissement 4</b> <br><br>  V547 L'expression 'eras_pos! = NULL' est toujours vraie.  reedsolomon.c 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eras_dec_rs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dtype data[NN], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eras_pos[NN-KK], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> no_eras)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;count;i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos!= <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) eras_pos[i] = INDEX_TO_POS(loc[i]); } } .... }</code> </pre> <br>  Peut-√™tre, nous avons affaire √† un contr√¥le redondant, probablement avec une faute de frappe, et une autre chose doit √™tre v√©rifi√©e dans l'une des conditions du bloc <i>if</i> . <br><br><h2>  Affirmations √©tranges </h2><br>  <b>Avertissement 1</b> <br><br>  V547 L'expression 'sub_dissectors! = NULL' est toujours vraie.  capture_dissectors.c 129 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capture_dissector_add_uint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... sub_dissectors = (struct capture_dissector_table*)g_hash_table_lookup(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sub_dissectors == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"OOPS: Subdissector \"%s\" not found ... \n"</span></span>, name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getenv(<span class="hljs-string"><span class="hljs-string">"WIRESHARK_ABORT_ON_DISSECTOR_BUG"</span></span>) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } g_assert(sub_dissectors != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  La v√©rification du pointeur <i>g_assert</i> est redondante ici, car le pointeur a d√©j√† √©t√© v√©rifi√© auparavant.  Peut-√™tre que seul <i>g_assert</i> √©tait dans cette fonction et qu'un d√©veloppeur a oubli√© de la supprimer, mais peut-√™tre qu'un champ de structure aurait d√ª √™tre v√©rifi√© ici. <br><br>  <b>Avertissement 2</b> <br><br>  V547 L'expression 'i &lt;count' est toujours vraie.  packet-netflow.c 10363 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_v9_v10_template_fields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... count = tmplt_p-&gt;field_count[fields_type]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;count; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmplt_p-&gt;fields_p[fields_type] != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { DISSECTOR_ASSERT (i &lt; count); <span class="hljs-comment"><span class="hljs-comment">// &lt;= tmplt_p-&gt;fields_p[fields_type][i].type = type; tmplt_p-&gt;fields_p[fields_type][i].length = length; tmplt_p-&gt;fields_p[fields_type][i].pen = pen; tmplt_p-&gt;fields_p[fields_type][i].pen_str = pen_str; if (length != VARIABLE_LENGTH) {/ tmplt_p-&gt;length += length; } } .... } .... }</span></span></code> </pre> <br>  On ne sait pas tr√®s bien pourquoi <i>assert</i> , qui duplique la condition de la boucle, a lieu dans la fonction.  Le compteur de boucles ne changera pas dans le corps. <br><br><h2>  Erreurs avec des pointeurs </h2><br>  <b>Avertissement 1</b> <br><br>  V595 Le pointeur 'si-&gt; conv' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 2135, 2144. packet-smb2.c 2135 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_smb2_fid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... g_hash_table_insert(si-&gt;conv-&gt;fids, sfi, sfi); <span class="hljs-comment"><span class="hljs-comment">// &lt;= si-&gt;file = sfi; if (si-&gt;saved) { si-&gt;saved-&gt;file = sfi; si-&gt;saved-&gt;policy_hnd = policy_hnd; } if (si-&gt;conv) { // &lt;= eo_file_info = (.... *)g_hash_table_lookup(si-&gt;conv-&gt;files,&amp;policy_hnd); .... } .... }</span></span></code> </pre> <br>  Le pointeur <i>si-&gt; conv</i> est d√©r√©f√©renc√© quelques lignes avant sa v√©rification de null. <br><br>  <b>Avertissement 2</b> <br><br>  V774 Le pointeur ¬´protos¬ª a √©t√© utilis√© apr√®s la lib√©ration de la m√©moire.  packet-k12.c 311 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k12_update_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** err)</span></span></span><span class="hljs-function"> </span></span>{ gchar** protos; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_protos; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ! (h-&gt;handles[i] = find_dissector(protos[i])) ) { h-&gt;handles[i] = data_handle; h-&gt;handles[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; g_strfreev(protos); *err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } } .... }</code> </pre> <br>  <i>protos</i> est un tableau de cha√Ænes.  Lors de la gestion d'un cas sp√©cial dans le programme, ce tableau est d'abord effac√© par la fonction <i>g_strfreev</i> , puis une cha√Æne de ce tableau est utilis√©e dans le message d'erreur.  Tr√®s probablement, ces lignes devraient √™tre √©chang√©es: <br><br><pre> <code class="cpp hljs">*err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); g_strfreev(protos);</code> </pre> <br><h2>  Fuites de m√©moire </h2><br>  V773 Le pointeur 'ptmpstr' a re√ßu des valeurs deux fois sans lib√©rer la m√©moire.  Une fuite de m√©moire est possible.  idl2wrs.c 2436 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parsetypedefunion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmpstr[BASE_BUFFER_SIZE], *ptmpstr; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(num_pointers--){ g_snprintf(tmpstr, BASE_BUFFER_SIZE, <span class="hljs-string"><span class="hljs-string">"%s_%s"</span></span>, ptmpstr, <span class="hljs-string"><span class="hljs-string">"unique"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"static int\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"...."</span></span>, tmpstr); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"{\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" ...."</span></span>, ptmpstr, ti-&gt;str); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" return offset;\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); ptmpstr=g_strdup(tmpstr); } .... }</code> </pre> <br>  Apr√®s la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>g_strdup</i></a> , nous devons appeler la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>g_free</i></a> √† un moment donn√©.  Cela n'est pas fait dans l'extrait de code donn√© et une nouvelle partie de la m√©moire est allou√©e dans la boucle √† chaque it√©ration.  Voici venir plusieurs fuites de m√©moire. <br><br>  Quelques autres avertissements pour des fragments de code similaires: <br><br><ul><li>  V773 Le pointeur 'ptmpstr' a re√ßu des valeurs deux fois sans lib√©rer la m√©moire.  Une fuite de m√©moire est possible.  idl2wrs.c 2447 </li><li>  V773 Le pointeur 'ptmpstr' a re√ßu des valeurs deux fois sans lib√©rer la m√©moire.  Une fuite de m√©moire est possible.  idl2wrs.c 2713 </li><li>  V773 Le pointeur 'ptmpstr' a re√ßu des valeurs deux fois sans lib√©rer la m√©moire.  Une fuite de m√©moire est possible.  idl2wrs.c 2728 </li><li>  V773 Le pointeur 'ptmpstr' a re√ßu des valeurs deux fois sans lib√©rer la m√©moire.  Une fuite de m√©moire est possible.  idl2wrs.c 2732 </li><li>  V773 Le pointeur 'ptmpstr' a re√ßu des valeurs deux fois sans lib√©rer la m√©moire.  Une fuite de m√©moire est possible.  idl2wrs.c 2745 </li></ul><br>  Malheureusement, dans le code, il existe de nombreux autres cas similaires, o√π la m√©moire est lib√©r√©e. <br><br><h2>  Divers </h2><br>  <b>Avertissement 1</b> <br><br>  V535 La variable 'i' est utilis√©e pour cette boucle et pour la boucle externe.  V√©rifiez les lignes: 7716, 7798. packet-opa-mad.c 7798 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Parse GetVFInfo MAD from the Performance Admin class. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_GetVFInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; records; i++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= line 7716 .... for (i = 0; i &lt; PM_UTIL_BUCKETS; i++) { // &lt;= line 7748 GetVFInfo_Util_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; } .... for (i = 0; i &lt; PM_ERR_BUCKETS; i++) { // &lt;= line 7798 GetVFInfo_Error_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; .... } .... } .... }</span></span></code> </pre> <br>  Dans une fonction tr√®s longue, les d√©veloppeurs modifient audacieusement la valeur du compteur de boucles, m√™me en le faisant plusieurs fois.  Nous ne pouvons pas dire avec certitude s'il s'agit d'une erreur ou non, cependant, il y a environ 10 boucles de ce type dans le projet. <br><br>  <b>Avertissement 2</b> <br><br>  V763 Le param√®tre 'item' est toujours r√©√©crit dans le corps de la fonction avant d'√™tre utilis√©.  packet-cdma2k.c 1324 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cdma2k_message_ORDER_IND</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(proto_item *item, ....)</span></span></span><span class="hljs-function"> </span></span>{ guint16 addRecLen = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordq = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rejectedtype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; guint16 l_offset = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rsc_mode_ind = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordertype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; proto_tree *subtree = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, *subtree1 = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; item = proto_tree_add_item(tree,hf_cdma2k_OrderIndMsg, tvb, ....); <span class="hljs-comment"><span class="hljs-comment">// &lt;= subtree = proto_item_add_subtree(item, ett_cdma2k_subtree1); .... }</span></span></code> </pre> <br>  Le pointeur d' <i>√©l√©ment</i> , pris par la fonction, est imm√©diatement modifi√© avec une autre valeur.  C'est tr√®s suspect.  De plus, le code contient plusieurs dizaines de ces emplacements, il est donc difficile de d√©cider s'il s'agit d'une erreur ou non.  Je suis tomb√© sur un code similaire dans un autre grand projet, ce code √©tait correct l√†-bas, personne n'a simplement os√© changer l'interface de la fonction. <br><br>  <b>Avertissement 3</b> <br><br>  V762 Il est possible qu'une fonction virtuelle n'ait pas √©t√© remplac√©e correctement.  Voir le troisi√®me argument de la fonction 'headerData' dans la classe d√©riv√©e 'PacketListModel' et la classe de base 'QAbstractItemModel'.  packet_list_model.h 48 <br><br><pre> <code class="cpp hljs">QVariant QAbstractItemModel::headerData(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> section, Qt::Orientation orientation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role = Qt::DisplayRole) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= class PacketListModel : public QAbstractItemModel { Q_OBJECT public: .... QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole | Qt::ToolTipRole) const; // &lt;= .... };</span></span></code> </pre> <br>  L'analyseur a d√©tect√© une surcharge non valide de la fonction <i>headerData</i> .  Les fonctions ont diff√©rentes valeurs par d√©faut du param√®tre de <i>r√¥le</i> .  Cela peut provoquer le mauvais comportement, pas celui attendu par un programmeur. <br><br>  <b>Avertissement 4</b> <br><br>  V610 Comportement ind√©fini.  V√©rifiez l'op√©rateur de d√©calage '&gt;&gt;'.  L'op√©rande droit ('bitshift' = [0..64]) est sup√©rieur ou √©gal √† la longueur en bits de l'op√©rande gauche promu.  proto.c 10941 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto_item_add_bitmask_tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || len &gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) g_assert_not_reached(); bitshift = (<span class="hljs-number"><span class="hljs-number">8</span></span> - (guint)len)*<span class="hljs-number"><span class="hljs-number">8</span></span>; available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift; .... }</code> </pre> <br>  Un d√©calage de 64 bits entra√Ænera un comportement ind√©fini selon la norme de langue. <br><br>  Tr√®s probablement, le code correct devrait √™tre comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bitshift == <span class="hljs-number"><span class="hljs-number">64</span></span>) available_bits = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift;</code> </pre> <br><h2>  Conclusion </h2><br>  Il peut sembler que cet examen montre peu d'erreurs, mais dans le rapport complet, les cas consid√©r√©s se r√©p√®tent des dizaines et des centaines de fois.  De plus, les r√©visions des avertissements PVS-Studio sont de nature d√©monstrative.  Ils repr√©sentent une contribution √† la qualit√© des projets open source, mais les contr√¥les ponctuels sont les plus inefficaces en termes de m√©thodologie d'analyse statique. <br><br>  Vous pouvez obtenir et analyser le rapport complet vous-m√™me.  Pour ce faire, il vous suffit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©charger</a> et d'ex√©cuter l'analyseur PVS-Studio. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447156/">https://habr.com/ru/post/fr447156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447146/index.html">Commutateurs industriels non g√©r√©s EKI</a></li>
<li><a href="../fr447148/index.html">L'application Habr (non) officielle - HabrApp 2.0: acc√®s</a></li>
<li><a href="../fr447150/index.html">Chat sur le site et dans l'√©mission de Yandex</a></li>
<li><a href="../fr447152/index.html">Bo√Æte √† outils multiplateforme .NET UI version AvaloniaUI 0.8</a></li>
<li><a href="../fr447154/index.html">Dette technique entra√Ænant une crise de l'entreprise</a></li>
<li><a href="../fr447158/index.html">Wireshark 3.x: analyse de code macOS et r√©vision de bogues</a></li>
<li><a href="../fr447160/index.html">Espace pour les enfants. Quelques id√©es pour la Journ√©e de la cosmonautique</a></li>
<li><a href="../fr447162/index.html">N'achetez pas ERP</a></li>
<li><a href="../fr447164/index.html">Comment combiner les avantages d'un ordinateur portable et d'un ordinateur de bureau? Analyse des probl√®mes et des solutions (partie 2)</a></li>
<li><a href="../fr447166/index.html">Help Desk en 3 heures. Automatisez des processus m√©tier simples dans PowerApps, Flow et Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>