<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚀 ⤴️ 👨‍👩‍👦 Comment charger OpenStreetMap dans Hive? 💱 ⚔️ 🛀🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article précédent, j'ai examiné le géocodage inversé à l'aide de Spark. Imaginez maintenant que nous avons été confrontés au défi du géocodage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment charger OpenStreetMap dans Hive?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438374/">  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent,</a> j'ai examiné le géocodage inversé à l'aide de Spark.  Imaginez maintenant que nous avons été confrontés au défi du géocodage direct des adresses e-mail.  Autrement dit, recevoir pour l'adresse enregistrée par le texte de certaines coordonnées géographiques. <br><br>  Les adresses pour la précision sont russes, et plus important encore - elles sont souvent écrites de manière tordue, c'est-à-dire avec des erreurs, des ambiguïtés et d'autres délices.  Et ces adresses se trouvent dans la base de données Hive, sur le cluster Hadoop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/8n/_s/vc8n_sp2pkut9qvilbnt6u2whqs.png"></div><br>  Eh bien, il semblerait - nous prenons l'API Google Maps Geocoding (ou, si vous êtes partisan de la substitution des importations, alors l'API Yandex Maps), et nous travaillons.  Mais ici, comme pour le géocodage inversé, nous attendons une petite embuscade. <br><a name="habracut"></a><br>  Ou gros, c'est comme un regard.  Le fait est que cette fois, nous devons traiter environ 5 millions d'adresses.  Et peut-être 50 - ce n'était pas immédiatement clair.  Comme vous le savez, Google bannira votre IP après environ 10 000 adresses, Yandex fera de même avec vous, bien que ce soit possible un peu plus tard (25 000 demandes par jour, par exemple).  Et d'ailleurs, les deux API sont REST, ce qui signifie qu'il est relativement lent.  Et même si vous achetez un abonnement payant, sa vitesse n'augmentera pas d'un sou. <br><br>  Et pourtant - nous avons manqué d'anecdote de munitions. <br><br>  J'ai oublié la chose la plus importante - notre cluster Hadoop est situé sur l'intranet, et Google Maps, pour l'entreprise avec Yandex Maps et tout le monde, nous sont généralement inaccessibles depuis le cluster.  Autrement dit, nous avions besoin d'une solution autonome. <br><br>  Je dirai tout de suite - vous ne trouverez pas de solution toute faite ici.  Je ne décrirai que l'approche que nous prévoyons d'appliquer, et de manière un peu plus détaillée - l'une des étapes d'un long chemin vers une solution. <br><br>  Bien sûr, nous avions quelque chose en réserve.  Il y avait un serveur ArcGIS interne que j'ai déjà mentionné.  Nous n'étions pas autorisés à les diriger, mais nous étions autorisés à utiliser ses services REST. <br><br>  La première chose que nous avons faite a été de le visser à la tâche.  Il ne nous a pas bannis, mais a simplement parfois désactivé pour l'entretien.  Et ce qui est bien - il y avait un mode de géocodage par lots, lorsque vous soumettez un paquet d'adresses à l'entrée (après avoir configuré le serveur, la taille du paquet était de 1000 pièces, par défaut, il semble que quelque chose soit un ordre de grandeur ou deux de moins).  Tout cela n'a pas été facile non plus, et nous, et le support d'ArcGIS, avons été engagés dans une lutte de sumo avec le serveur pendant longtemps, mais c'est une autre histoire. <br><br>  Après toutes les astuces et rebondissements, nous avons pu traiter nos cinq millions en une journée environ.  Il fallait avancer et essayer encore d'accélérer. <br><br>  Dans le même temps, il est devenu clair que tout géocodeur avec REST ne nous convient probablement pas.  De plus, nous avons examiné Nominatim, Pelias, Photon et gisgraphy, et en général nous n'en étions pas satisfaits.  La qualité et les performances (ou les deux) étaient loin d'être idéales. <br><br>  Par exemple, personne ne sait géocoder les packages (et cela accélère considérablement le travail avec ArcGIS). <br><br>  Ou qualité - rendez-vous sur le serveur de démonstration gisgraphy.com et essayez de trouver Moscou.  Vous recevrez une douzaine de réponses, notamment: Moscou (une ville de la Fédération de Russie), Kansas City (une ville des États-Unis), Khimki, Kaluga, Vykhino-Zhulebino et bien d'autres objets que je ne voudrais pas voir dans la réponse du géocodeur quand recherchez Moscou. <br><br>  Eh bien, le dernier problème (mais pas important pour nous) est que loin de tous les géocodeurs, l'API est aussi bien pensée que, disons, Google Maps.  Disons que l'API ArcGIS est déjà beaucoup plus gênant, et le reste est pour la plupart encore pire.  Si vous géocodez des adresses pour l'interface utilisateur, en règle générale, une personne s'engage à choisir la meilleure option.  Et il le fait mieux que le programme.  Et dans le cas du géocodage de masse, comme nous l'avons fait, l'évaluation de la qualité du résultat pour une adresse particulière est l'un des éléments importants du succès. <br><br>  Par conséquent, des options comme «Développez votre propre Nominatim», par exemple, ont également disparu. <br><br><h2>  Que faire? </h2><br>  Une solution assez évidente était la suivante: étant donné que les adresses ne proviennent de nulle part et ne disparaissent nulle part, les maisons ne sont pas construites tous les jours et les rues ne sont pas construites, il vous suffit d'ajouter une base de données d'adresses officiellement existantes à notre processus.  Mieux immédiatement avec les coordonnées, et si cela ne se produit pas, géocodez-le une fois.  Dans ce cas, il nous suffira de mettre à jour notre base avec la même fréquence d'apparition de nouvelles maisons ou rues, c'est-à-dire pas souvent. <br><br>  Le premier et principal candidat pour la base d'adresses existantes est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FIAS</a> .  Attendez une minute, dites-vous, mais la FIAS n'a que quelques millions d'adresses - et vous en avez jusqu'à 50 millions?  Oui, il n'y a vraiment que quelques millions de <b>foyers</b> .  Et nos 50, c'est 50 millions d'adresses de nos utilisateurs, c'est-à-dire, ce sont les adresses de personnes, et ils ont soudainement un appartement à l'adresse.  Cinq millions de maisons de 1 à 100 appartements, plusieurs personnes vivent dans chaque appartement ... enfin, vous comprenez tout.  Et la deuxième option est l'adresse des bureaux, où un centre de bureaux dispose également de centaines de locaux, parfois loués. <br><br>  Dans le même temps, nous n'avons évidemment pas besoin d'une adresse avec le numéro de l'appartement (ou du bureau) - d'une part, ce sont des données personnelles avec toutes les conséquences, et d'autre part, nous ne sommes toujours pas intéressés par la façon dont les appartements sont situés dans une maison particulière, et quelles sont leurs coordonnées .  Seule une maison est nécessaire.  Pour les bureaux, ce n'est pas tout à fait vrai, mais l'emplacement des bureaux dans un immeuble par étages n'est toujours pas déterminé par les coordonnées. <br><br>  En fin de compte, ayant une base de, disons, 5 millions de maisons (conditionnellement) existantes, nous pouvons résoudre le problème de géocodage de 50 ou 100 millions d'adresses en jetant simplement l'appartement ou le bureau hors de l'adresse et en l'associant à la base. <br><br>  Et où trouver les coordonnées des maisons?  Il n'y a qu'une seule source ouverte évidente - OpenStreetMap, il y a des maisons là-bas, avec des géométries, et toutes sortes d'autres attributs comme le nombre d'étages ou même la couleur du toit. <br><br>  Après toutes les discussions, nous avions un plan napoléonien.  En voici un: <br><br><ul><li>  chargement des données cartographiques d'OSM dans Hadoop </li><li>  télécharger des données FIAS avec des adresses </li><li>  construire une liste d'adresses complètes uniques avec des numéros de maison </li><li>  nous le géocodons en recherchant des adresses dans OSM, et ce que nous n'avons pas trouvé est via ArcGIS </li></ul><br><br>  Nous obtenons la base de maisons avec latitude et longitude.  Profitez-en.  Profiter des avantages.  Boissons bonus (blague). <br><br>  Dans cet article, je vais vous expliquer comment nous avons mis en œuvre le premier point de ce plan. <br><br><h2>  Qu'est-ce qu'OpenStreetMap </h2><br>  Si vous regardez OSM du point de vue des données, vous pouvez imaginer les cartes sous la forme de trois tableaux: <br><br><ul><li>  des points </li><li>  lignes (voies) </li><li>  les relations </li></ul><br><br>  Les schémas réels de ces données seront donnés ci-dessous. <br><br>  Seuls les points ont des coordonnées (latitude et longitude, en degrés).  Les lignes sont une séquence ordonnée de points.  Les relations sont un ensemble de points et de lignes, chacun ayant un <i>rôle</i> . <br><br>  Tout le reste, ce sont les soi-disant balises.  C'est, par exemple, un guichet automatique, ou un magasin, ou une entrée du métro - il peut s'agir d'un point équipé de la balise amenity = atm, ou shop = vend quelque chose, ou autre chose.  Il existe un répertoire de balises officiellement recommandées (pour chaque langue et pays applicable, elles peuvent être partiellement les leurs), et la pratique d'inventer des balises non standard. <br><br>  En plus des balises, chaque élément de la carte a un identifiant numérique unique, ainsi que certains attributs liés à l'historique - qui a modifié quand, modifier le numéro, etc. <br><br>  La base de données avec la carte se présente sous plusieurs formats: <br>  - pbf est Google Protobuf, un format de sérialisation de données portable. <br>  - xml est évidemment XML.  Beaucoup plus en volume. <br><br>  Vous devez comprendre que la base de données est mise à jour quotidiennement.  Par conséquent, les déchargements sont complets et incrémentiels. <br><br>  Nous avons choisi le PBF comme plus compact. <br><br>  Pour le lire dans Hadoop, il existe une API Java spécialement conçue pour OSM appelée ce projet d'osmose.  En principe, travailler avec est simple: vous téléchargez un fichier et parcourez les éléments de la carte.  Ajoutez les points à un endroit, les lignes à un autre, la relation au troisième.  En principe, l'osmose et par exemple Spark suffisent déjà pour télécharger toutes les données. <br><br>  Heureusement, dans le processus de mise en œuvre de mon vélo, il m'est apparu en quelque sorte de rechercher sur Internet pour convertir OSM dans les formats acceptés dans Hadoop - Parquet (parquet) et Avro.  Dans un sens, les deux sont des analogues du PBF, il y avait donc une chance de trouver un convertisseur.  Et il a été retrouvé, mais pas un. <br><br><h2>  Rencontrez OSM Parquetizer </h2><br>  Voyez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce que j'ai trouvé!</a> <br><br>  Pour les paresseux - en plein dans le readme du projet dans la première ligne, il est dit: Telenav publie des téléchargements hebdomadaires de la planète <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à l'adresse</a> . <br><br>  Pour les gens très paresseux: préparez-vous à expédier environ 700 gigaoctets;) Eh bien, si vous avez certainement besoin d'une planète.  Vous pouvez généralement vous débrouiller avec, disons, l'Europe. <br><br>  Si vous ne voulez pas charger, le processus ressemble à ceci: téléchargez une carte au format PBF, par exemple à partir d'une <a href="">géofactory</a> .  C'est 2,5 gigaoctets si vous avez besoin de la Russie et 19 si l'Europe.  Pas un peu non plus, mais vous pouvez trouver des échantillons plus finement hachés.  Ensuite, placez le fichier sur le disque et exécutez le programme: <br><br><pre><code class="plaintext hljs">java -jar ./osm-parquetizer.jar russia-latest.osm.pbf</code> </pre> <br>  Après quelques minutes voire quelques secondes, selon les performances de votre machine, vous obtenez trois fichiers au format parquet.  Voici à quoi ressemble l'auteur (il est de Roumanie): <br><br><pre> <code class="plaintext hljs">-rw-r--r-- 1 adrianbona adrianbona 145M Apr 3 19:57 romania-latest.osm.pbf -rw-r--r-- 1 adrianbona adrianbona 372M Apr 3 19:58 romania-latest.osm.pbf.node.parquet -rw-r--r-- 1 adrianbona adrianbona 1.1M Apr 3 19:58 romania-latest.osm.pbf.relation.parquet -rw-r--r-- 1 adrianbona adrianbona 123M Apr 3 19:58 romania-latest.osm.pbf.way.parquet</code> </pre> <br>  Schémas des fichiers .parquet reçus: <br><br> <code>node <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- latitude: double <br> |-- longitude: double <br> <br> way <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- nodes: array <br> | |-- element: struct <br> | | |-- index: integer <br> | | |-- nodeId: long <br> <br> relation <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- members: array <br> | |-- element: struct <br> | | |-- id: long <br> | | |-- role: string <br> | | |-- type: string <br></code> <br><br>  Comme vous pouvez le voir, tout est simple ici.  Ensuite, nous faisons ce qui suit: <br><br><ul><li>  nous mettons des fichiers sur le cluster Hadoop avec la commande hdfs dfs -put </li><li>  allons dire dans Hue et créons un schéma / base, et trois tables pour cela, sur la base des données ci-dessus </li><li>  exécutez select * dans osm.nodes et profitez du résultat. </li></ul><br>  Une petite nuance: dans notre version de Hive (et peut-être aussi la vôtre), il n'est pas en mesure de créer des tables basées sur le schéma de Parquet.  Vous devez soit convertir ce qui précède en CREATE TABLE (ce qui, en général, n'est pas difficile, et je laisserai cela comme un exercice à domicile pour les lecteurs), soit faire un peu plus compliqué: Spark peut lire le diagramme et les données à partir du sol, et créer des tables temporaires sur leur base .  Nous pouvons donc lire les données dans Spark Shell comme ceci: <br><br><pre> <code class="plaintext hljs">val nodeDF = sqlContext.read.parquet("file:/tmp/osm/romania-latest.osm.pbf.node.parquet") nodeDF.createOrReplaceTempView("nodes")</code> </pre><br>  Ensuite, vous pouvez déjà créer des tables dans Hive en utilisant des nœuds LIKE. <br><br>  Une autre remarque pour les paresseux: l'auteur a un si bel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> , à partir duquel en général tout devient clair (enfin, si vous possédez Spark).  Ce n'est bien sûr pas Spark Shell, mais le Databricks Notebook, mais il m'a fallu environ 15 minutes pour appuyer sur un clavier pour le traduire en un autre.  Et en 30 à 40 minutes, il a été possible de tout convertir en requêtes pour Hive en utilisant des analogues légèrement différents de l'étincelle. <br><br><h3>  Exemple de demande réelle </h3><br>  Que pouvons-nous obtenir de cette base de données dans sa forme actuelle?  En général, beaucoup.  Si vous avez une ruche ou une étincelle, un cadre spatial, une API de géométrie ou l'une des alternatives, qui sont GeoSpark ou par exemple GeoMesa, vous pouvez résoudre de nombreux problèmes différents sur cette base. <br><br>  Voyons un exemple.  La façon la plus simple de travailler avec des points.  Par exemple, une requête pour obtenir une liste de distributeurs automatiques de billets avec leurs coordonnées ressemble à ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'amenity'</span></span>]=<span class="hljs-string"><span class="hljs-string">'atm'</span></span></code> </pre><br>  Comment construire une telle requête, vous pouvez le deviner en lisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page sur le wiki</a> .  Vous y trouverez ce que sont d'autres balises, et certaines d'entre elles peuvent être incluses dans votre demande au lieu de *, sous la forme de balises ['opérateur'], par exemple, pour afficher le nom de la banque. <br><br>  De la même page, il s'ensuit que le balisage ATM est possible sous la forme de balises amenity = bank et atm = yes.  Hélas, de telles ambiguïtés sont omniprésentes dans OSM. <br><br>  Si vous êtes un débutant et que vous vous familiarisez avec OSM, je recommande fortement de maîtriser (par de bons exemples sur le wiki) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">overpass-turbo</a> .  Il s'agit d'un outil qui vous permet d'effectuer différents types de recherches sur les données cartographiques, à la fois avec des conditions géométriques et avec des conditions pour les balises. <br><br><h3>  Et où sont les adresses? </h3><br>  Bonne question.  Les adresses dans OSM sont des éléments de carte fournis avec des balises addr: *, c'est-à-dire  commençant par addr.  Description que vous trouverez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  En principe, sachant tout ce que j'ai dit ci-dessus, vous pouvez déjà rédiger une demande de travail: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'addr:housenumber'</span></span>]!=<span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Quels problèmes nous attendent ici?  Premièrement, les adresses sont placées à la fois sur des points (par exemple, des entrées de bâtiments) et sur des polygones, c'est-à-dire  sur les voies.  Nous devons donc au moins dupliquer la demande.  Et deuxièmement, sur la page mentionnée ci-dessus, le wiki est écrit en texte clair qu'il n'est pas recommandé de mettre des balises indiquant la ville, la région, la région et le pays, mais cela doit être calculé géométriquement.  Comment faire  En général, c'est pratiquement la tâche du géocodage inversé, avec de légères modifications, et cela a été décrit dans un post précédent. <br><br>  C'est-à-dire, en général, vous devez trouver des limites administratives, et pour toutes les adresses qui s'y trouvent, ajoutez l'adresse à la zone et à tout ce qui précède.  La façon dont les limites des entités administratives sont organisées est décrite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En général, cette tâche n'est pas trop simple, mais tout à fait résoluble, et elle n'est pas résolue par le géocodage, mais en téléchargeant les mises à jour OSM dans notre base de données, dans une atmosphère détendue. <br><br><h3>  Que faut-il faire ensuite </h3><br>  En principe, vous pouvez déjà travailler avec les nœuds, les chemins et les tables de relations que nous avons, mais il vaut mieux changer un peu le schéma, le rendant plus adapté à Hive et Spark.  Le fait est que le schéma OSM est complètement normalisé, les voies et les relations ne contiennent pas du tout de coordonnées.  Pour construire un polygone pour le chemin, vous devez vous joindre à des nœuds.  Je recommanderais de faire cette opération tout de suite, en enregistrant les polygones soit comme un tableau de structures (Hive peut fonctionner avec un tableau de types composites, une carte et une structure), soit immédiatement comme une représentation sérialisée de la classe Geometry, par exemple.  Comment faire cela est dans l'exemple du parqueteur auteur. <br><br>  Vous pouvez répéter une opération similaire au niveau des relations, si vous le souhaitez, mais cela ne vaut pas la peine.  Premièrement, vous n'aurez pas toujours besoin de tous les éléments d'une relation, et deuxièmement, les relations elles-mêmes dans OSM sont beaucoup plus petites. <br><br><h2>  Convertisseur en Avro </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> un autre convertisseur, cette fois au format Avro.  Et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici, il est</a> décrit où obtenir les fichiers finis.  Je n'ai pas mesuré les tailles, mais je pense qu'environ 15-20 fichiers par planète devraient être comparables à PBF.  Autrement dit, ce sont des gigaoctets, et beaucoup. <br><br><h2>  Quelques conclusions </h2><br>  Et où est le géocodage, demandez-vous?  Oui, le téléchargement de cartes et l'extraction d'adresses ne sont qu'une partie de la tâche globale.  J'espère qu'il en sera ainsi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438374/">https://habr.com/ru/post/fr438374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438364/index.html">Réplication du premier brouilleur vocal numérique au monde</a></li>
<li><a href="../fr438366/index.html">Encore un autre examen de la fonctionnalité des jetons matériels OATH dans Azure Cloud MFA</a></li>
<li><a href="../fr438368/index.html">Les ampoules intelligentes jetées à la poubelle sont une précieuse source d'informations personnelles.</a></li>
<li><a href="../fr438370/index.html">La cybercriminalité en tant que service: services et tarifs</a></li>
<li><a href="../fr438372/index.html">La NASA poursuit ses tentatives pour contacter l'opportunité</a></li>
<li><a href="../fr438376/index.html">Rétro-ingénierie. L'histoire. Le mien</a></li>
<li><a href="../fr438380/index.html">Homme, pause sur les exceptions capturées</a></li>
<li><a href="../fr438382/index.html">Organisation d'une recherche sur une page web en JavaScript (sans jQuery)</a></li>
<li><a href="../fr438384/index.html">Leçon de chimie: comment exposer le cristal d'une puce électronique pour la photographie</a></li>
<li><a href="../fr438386/index.html">En route vers les principes physiques de l'évolution biologique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>