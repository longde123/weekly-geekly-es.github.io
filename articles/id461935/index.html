<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍋 🤣 🎳 Cara bekerja dengan Postgres in Go: praktik, fitur, nuansa 🔨 🚣🏾 👸🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perilaku aplikasi yang tidak terduga dalam kaitannya dengan bekerja dengan database menyebabkan perang antara DBA dan pengembang: DBA berteriak: "Apli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara bekerja dengan Postgres in Go: praktik, fitur, nuansa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461935/"><p><img src="https://habrastorage.org/webt/yg/8e/hm/yg8ehmpmicsm7ye6fwju6kwog14.png"></p><br><p>  Perilaku aplikasi yang tidak terduga dalam kaitannya dengan bekerja dengan database menyebabkan perang antara DBA dan pengembang: DBA berteriak: "Aplikasi Anda menjatuhkan basis data", pengembang - "Tapi semuanya bekerja sebelumnya!"  Yang paling parah, DBA dan pengembang tidak dapat saling membantu: beberapa tidak tahu tentang nuansa aplikasi dan driver, yang lain tidak tahu tentang fitur yang terkait dengan infrastruktur.  Akan lebih baik untuk menghindari situasi seperti itu. </p><br><p>  Anda harus mengerti, seringkali tidak cukup hanya dengan melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-database-sql.org</a> .  Lebih baik mempersenjatai diri dengan pengalaman orang lain.  Bahkan lebih baik jika itu adalah pengalaman yang diperoleh dengan darah dan kehilangan uang. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Uojy57I-xP0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Nama saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ryabinkov Artemy</a> dan artikel ini adalah interpretasi gratis dari laporan saya dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saints HighLoad 2019</a> . </p><br><h1 id="instrumenty">  Alat-alatnya </h1><br><p>  Anda dapat menemukan informasi minimum yang diperlukan tentang cara bekerja dengan Go dengan database seperti SQL di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-database-sql.org</a> .  Jika Anda belum membacanya, bacalah. </p><br><h2 id="sqlx">  sqlx </h2><br><p>  Menurut pendapat saya, kekuatan Go adalah kesederhanaan.  Dan ini diungkapkan, misalnya, karena sudah biasa bagi Go untuk menulis kueri dalam bare SQL (ORM tidak menghormati).  Ini merupakan keuntungan dan juga sumber kesulitan tambahan. </p><br><p> Oleh karena itu, dengan mengambil paket bahasa <code>database/sql</code> standar, Anda ingin memperluas antarmuka-nya.  Setelah itu terjadi, lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jmoiron/sqlx</a> .  Izinkan saya menunjukkan kepada Anda beberapa contoh bagaimana ekstensi ini dapat menyederhanakan hidup Anda. </p><br><p>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StructScan</a> menghilangkan kebutuhan untuk secara manual memindahkan data dari kolom ke properti struktur. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Place <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> City sql.NullString TelephoneCode <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`db:"telcode"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place err = rows.StructScan(&amp;p)</code> </pre> <br><p>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NamedQuery</a> memungkinkan Anda untuk menggunakan properti struktur sebagai placeholder dalam kueri. </p><br><pre> <code class="go hljs">p := Place{Country: <span class="hljs-string"><span class="hljs-string">"South Africa"</span></span>} sql := <span class="hljs-string"><span class="hljs-string">`.. WHERE country=:country`</span></span> rows, err := db.NamedQuery(sql, p)</code> </pre> <br><p>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Get</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Select</a> memungkinkan Anda untuk menghilangkan kebutuhan untuk secara manual menulis loop yang mendapatkan baris dari database. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pp []Place <span class="hljs-comment"><span class="hljs-comment">// Get   p     err = db.Get(&amp;p, ".. LIMIT 1") // Select   pp   . err = db.Select(&amp;pp, ".. WHERE telcode &gt; ?", 50)</span></span></code> </pre> <br><h1 id="drayvery">  Driver </h1><br><p>  <code>database/sql</code> adalah seperangkat antarmuka untuk bekerja dengan database, dan <code>sqlx</code> adalah ekstensi mereka.  Agar antarmuka ini berfungsi, mereka membutuhkan implementasi.  Driver bertanggung jawab atas implementasi. </p><br><p>  Driver paling populer: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/lib/pq</a> - <code>pure Go Postgres driver for database/sql.</code>  Driver ini telah lama tetap menjadi standar standar.  Tetapi hari ini telah kehilangan relevansinya dan tidak sedang dikembangkan oleh penulis. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jackc/pgx</a> - <code>PostgreSQL driver and toolkit for Go.</code>  Hari ini lebih baik memilih alat ini. </li></ul><br><p>  <strong>github.com/jackc/pgx</strong> - ini adalah driver yang ingin Anda gunakan.  Mengapa </p><br><ul><li>  <strong>Didukung dan dikembangkan secara</strong> aktif. </li><li>  Ini bisa lebih <strong>produktif</strong> jika digunakan tanpa antarmuka <code>database/sql</code> . </li><li>  Dukungan untuk lebih dari <strong>60 jenis PostgreSQL</strong> yang diterapkan <code>PostgreSQL</code> luar standar <code>SQL</code> . </li><li>  Kemampuan untuk dengan mudah mengimplementasikan <strong>pencatatan</strong> apa yang terjadi di dalam driver. </li><li>  <code>pgx</code> <strong>kesalahan yang dapat dibaca manusia</strong> , sementara hanya <code>lib/pq</code> melempar serangan panik.  Jika Anda tidak panik, program akan macet.  ( <em>Anda seharusnya tidak menggunakan panik di Go, ini tidak sama dengan pengecualian.</em> ) </li><li>  Dengan <code>pgx</code> , kami memiliki kemampuan untuk <strong>mengkonfigurasi setiap koneksi</strong> secara independen. </li><li>  Ada dukungan <strong>untuk protokol replikasi logis</strong> <code>PostgreSQL</code> . </li></ul><br><h2 id="4kb">  4KB </h2><br><p>  Biasanya, kami menulis loop ini untuk mendapatkan data dari database: </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, sql) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { err = rows.Scan(...) }</code> </pre> <br><p>  Di dalam driver, kami mendapatkan data dengan menyimpannya di <strong>buffer 4KB</strong> .  <code>rows.Next()</code> memunculkan perjalanan jaringan dan mengisi buffer.  Jika buffer tidak cukup, maka kami pergi ke jaringan untuk data yang tersisa.  Lebih banyak kunjungan jaringan - lebih sedikit kecepatan pemrosesan.  Di sisi lain, karena batas buffer adalah 4KB, jangan lupa seluruh memori proses. </p><br><p>  Tapi, tentu saja, saya ingin membuka volume buffer secara maksimal untuk mengurangi jumlah permintaan ke jaringan dan mengurangi latensi layanan kami.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami menambahkan</a> kesempatan ini dan mencoba untuk mengetahui percepatan yang diharapkan pada <a href="">tes sintetis</a> : </p><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -run=XXX -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/furdarius/pgxexperiments/bufsize BenchmarkBufferSize/4KB 5 315763978 ns/op 53112832 B/op 12967 allocs/op BenchmarkBufferSize/8KB 5 300140961 ns/op 53082521 B/op 6479 allocs/op BenchmarkBufferSize/16KB 5 298477972 ns/op 52910489 B/op 3229 allocs/op BenchmarkBufferSize/1MB 5 299602670 ns/op 52848230 B/op 50 allocs/op PASS ok github.com/furdarius/pgxexperiments/bufsize 10.964s</code> </pre> <br><p>  Dapat dilihat bahwa tidak ada perbedaan besar dalam kecepatan pemrosesan.  Kenapa begitu </p><br><p>  Ternyata kita dibatasi oleh ukuran buffer untuk mengirim data di dalam Postgres itu sendiri.  Buffer ini memiliki ukuran <a href="">tetap</a> <strong>8KB</strong> .  Menggunakan <code>strace</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat melihat</a> bahwa OS mengembalikan <code>8192</code> byte dalam panggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baca</a> .  Dan <code>tcpdump</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengkonfirmasi</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan</a> ukuran paket. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tom Lane</a> ( <em>salah satu pengembang inti dari kernel Postgres</em> ) <a href="">berkomentar</a> seperti ini: </p><br><blockquote>  Secara tradisional, setidaknya, itu adalah ukuran buffer pipa di mesin Unix, jadi pada prinsipnya ini adalah ukuran chunk yang paling optimal untuk mengirim data melalui soket Unix. </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andres Freund</a> ( <em>pengembang Postgres dari EnterpriseDB</em> ) <a href="">percaya</a> bahwa buffer 8KB bukanlah pilihan implementasi terbaik saat ini, dan Anda perlu menguji perilaku pada ukuran yang berbeda dan dengan konfigurasi soket yang berbeda. </p><br><p>  Kita juga harus ingat bahwa PgBouncer juga memiliki buffer dan ukurannya dapat dikonfigurasi dengan parameter <code>pkt_buf</code> . </p><br><h2 id="oids">  OID </h2><br><p>  Fitur lain dari driver pgx ( <em>v3</em> ): untuk setiap koneksi, ia membuat permintaan ke database untuk mendapatkan informasi tentang <strong>Object ID</strong> ( <em>OID</em> ). </p><br><p>  Pengidentifikasi ini ditambahkan ke Postgres untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara unik mengidentifikasi</a> objek internal: baris, tabel, fungsi, dll. </p><br><p>  Pengemudi menggunakan pengetahuan <code>OIDs</code> untuk memahami kolom basis data mana yang menjadi bahasa primitif untuk menambahkan data.  Untuk ini, <code>pgx</code> mendukung tabel seperti itu ( <em>kuncinya adalah nama tipe, nilainya adalah Object ID</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Value{ <span class="hljs-string"><span class="hljs-string">"_aclitem"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"_bool"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"_int4"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"_int8"</span></span>: <span class="hljs-number"><span class="hljs-number">55</span></span>, ... }</code> </pre> <br><p>  Implementasi ini mengarah pada fakta bahwa driver untuk setiap koneksi yang dibuat dengan database membuat sekitar tiga permintaan untuk membentuk tabel dengan <code>Object ID</code> .  Dalam mode operasi normal dari database dan aplikasi, kumpulan koneksi di Go memungkinkan Anda untuk tidak membuat koneksi baru ke database.  Tetapi pada degradasi terkecil dari database, kumpulan koneksi pada sisi aplikasi habis dan jumlah koneksi yang dihasilkan per unit waktu meningkat secara signifikan.  Permintaan <code>OIDs</code> cukup berat, sebagai akibatnya, pengemudi dapat membawa database ke kondisi kritis. </p><br><p>  Inilah saat ketika permintaan seperti itu dituangkan ke salah satu dari basis data kami: </p><br><p><img src="https://habrastorage.org/webt/lm/ra/vb/lmravbubtqb2ah8dvbvvpklbz8m.png"></p><br><p>  <strong>15 transaksi per menit</strong> dalam mode normal, lompatan hingga <strong>6500 transaksi</strong> selama degradasi. </p><br><p>  <strong>Apa yang harus dilakukan</strong> </p><br><p>  Pertama dan terpenting, batasi ukuran kolam Anda dari atas. </p><br><p>  Untuk <code>database/sql</code> ini dapat dilakukan dengan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DB.SetMaxOpenConns</a> .  Jika Anda meninggalkan antarmuka <code>database/sql</code> dan menggunakan <code>pgx.ConnPool</code> ( <code>pgx.ConnPool</code> <em>koneksi yang diimplementasikan oleh driver itu sendiri</em> ), Anda dapat menentukan <code>MaxConnections</code> ( <em>standarnya adalah 5</em> ). </p><br><p>  Omong-omong, ketika menggunakan <code>pgx.ConnPool</code> driver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan menggunakan kembali</a> informasi tentang <code>OIDs</code> diterima dan tidak akan membuat pertanyaan ke database untuk setiap koneksi baru. </p><br><p>  Jika Anda tidak ingin menolak <code>database/sql</code> , maka Anda dapat menyimpan informasi tentang <code>OIDs</code> sendiri. </p><br><pre> <code class="go hljs">github.com/jackc/pgx/stdlib.OpenDB(pgx.ConnConfig{ CustomConnInfo: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pgtype.ConnInfo, error)</span></span></span></span> { cachedOids = <span class="hljs-comment"><span class="hljs-comment">//  OIDs   . info := pgtype.NewConnInfo() info.InitializeDataTypes(cachedOids) return info, nil } })</span></span></code> </pre> <br><p>  Ini adalah metode yang berfungsi, tetapi menggunakannya bisa berbahaya dalam dua kondisi: </p><br><ul><li>  Anda menggunakan enum atau tipe domain di Postgres; </li><li>  jika wisaya gagal, Anda beralih aplikasi ke replika, yang dituangkan oleh replikasi logis. </li></ul><br><p>  Pemenuhan kondisi-kondisi ini mengarah pada fakta bahwa <code>OIDs</code> cache menjadi tidak valid.  Tapi kami tidak akan bisa membersihkannya, karena kami tidak tahu saat beralih ke pangkalan baru. </p><br><p>  Di dunia <code>Postgres</code> , replikasi fisik biasanya digunakan untuk mengatur ketersediaan tinggi, yang menyalin contoh basis data sedikit demi sedikit, sehingga masalah dengan cache <code>OIDs</code> jarang terlihat di alam liar.  ( <em>Tetapi lebih baik untuk memeriksa dengan DBA Anda bagaimana siaga bekerja untuk Anda</em> ). </p><br><p>  Dalam versi utama driver <code>pgx</code> - <code>v4</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak akan ada</a> kampanye untuk <code>OIDs</code> .  Sekarang driver hanya akan bergantung pada daftar <code>OIDs</code> yang <code>OIDs</code> dalam kode.  Untuk tipe kustom, Anda perlu mengendalikan deserialization di sisi aplikasi Anda: driver hanya akan memberikan sepotong memori sebagai array byte. </p><br><h1 id="logirovanie-i-monitoring">  Penebangan dan Pemantauan </h1><br><p>  Pemantauan dan logging akan membantu untuk melihat masalah sebelum pangkalan crash. </p><br><p>  <code>database/sql</code> menyediakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DB.Stats ()</a> .  Snapshot status yang dikembalikan akan memberi Anda gambaran tentang apa yang terjadi di dalam driver. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DBStats <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxOpenConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// Pool State OpenConnections int InUse int Idle int // Counters WaitCount int64 WaitDuration time.Duration MaxIdleClosed int64 MaxLifetimeClosed int64 }</span></span></code> </pre> <br><p>  Jika Anda menggunakan kumpulan dalam <code>pgx</code> secara langsung, metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ConnPool.Stat ()</a> akan memberi Anda informasi yang serupa: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConnPoolStat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AvailableConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  Logging sama pentingnya, dan <code>pgx</code> memungkinkan Anda melakukan ini.  Pengemudi menerima antarmuka <code>Logger</code> , dengan menerapkan yang, Anda mendapatkan semua peristiwa yang terjadi di dalam pengandar. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Log a message at the given level with data key/value pairs. // data may be nil. Log(level LogLevel, msg string, data map[string]interface{}) }</span></span></code> </pre> <br><p>  Kemungkinan besar, Anda bahkan tidak perlu mengimplementasikan antarmuka ini sendiri.  Dalam <code>pgx</code> out of the box ada satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">set adapter</a> untuk penebang paling populer, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uber-go / zap</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sirupsen / logrus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rs / zerolog</a> . </p><br><h1 id="infrastruktura">  Infrastruktur </h1><br><p>  Hampir selalu ketika bekerja dengan <code>Postgres</code> Anda akan menggunakan <strong>pooler koneksi</strong> , dan itu akan menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PgBouncer</a> ( <em>atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengembaraan</a> - jika Anda Yandex</em> ). </p><br><p>  Mengapa demikian, Anda dapat membaca di artikel yang sangat bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">brandur.org/postgres-connections</a> .  Singkatnya, ketika jumlah klien <strong>melebihi 100,</strong> kecepatan pemrosesan permintaan mulai menurun.  Ini terjadi karena fitur implementasi Postgres itu sendiri: peluncuran proses terpisah untuk setiap koneksi, mekanisme untuk menghapus foto dan penggunaan memori bersama untuk interaksi - semua ini mempengaruhi. </p><br><p>  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patokan dari</a> berbagai implementasi penghubung koneksi: <br><img src="https://habrastorage.org/webt/im/p1/-n/imp1-nuasdxn1wmve7l89rrvmbw.png"></p><br><p>  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">benchmark</a> bandwidth dengan dan tanpa PgBouncer. </p><br><p><img src="https://habrastorage.org/webt/jc/cp/21/jccp2150oefyeiixeu005lpsl_0.png"></p><br><p>  Akibatnya, infrastruktur Anda akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/bf/ee/ok/bfeeokt_cdojbuddo7_rhzddjis.png"></p><br><p>  Di mana <code>Server</code> adalah proses yang memproses permintaan pengguna.  Proses ini berputar dalam <code>kubernetes</code> dalam 3 salinan ( <em>setidaknya</em> ).  Secara terpisah, pada server besi, ada <code>Postgres</code> , dicakup oleh <code>PgBouncer'</code> .  <code>PgBouncer</code> sendiri <code>PgBouncer</code> single-threaded, jadi kami meluncurkan beberapa bouncer, lalu lintas yang kami gunakan menggunakan <code>HAProxy</code> .  Sebagai hasilnya, kami mendapatkan rangkaian eksekusi permintaan dalam database: <code>   → HAProxy → PgBouncer → Postgres</code> . </p><br><p>  <code>PgBouncer</code> dapat bekerja dalam tiga mode: </p><br><ul><li>  <strong>Pengumpulan sesi</strong> - untuk setiap sesi, satu koneksi dikeluarkan dan ditugaskan padanya untuk seumur hidup. </li><li>  <strong>Pengumpulan transaksi</strong> - koneksi aktif saat transaksi berjalan.  Segera setelah transaksi selesai, <code>PgBouncer</code> mengambil koneksi ini dan mengembalikannya ke transaksi lain.  Mode ini memungkinkan pembuangan senyawa yang sangat baik. </li><li>  <strong>Pengumpulan pernyataan</strong> - mode <strong>usang</strong> .  Itu dibuat hanya untuk mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PL / Proxy</a> . </li></ul><br><p>  Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks</a> properti apa yang tersedia di setiap mode.  Kami memilih <strong>Pengumpulan Transaksi</strong> , tetapi memiliki batasan untuk bekerja dengan <code>Prepared Statements</code> . </p><br><h2 id="transaction-pooling--prepared-statements">  Pooling Transaksi + Pernyataan Disiapkan </h2><br><p>  Mari kita bayangkan bahwa kita ingin menyiapkan permintaan dan kemudian melaksanakannya.  Pada titik tertentu, kami memulai transaksi di mana kami mengirim permintaan Siapkan, dan kami mendapatkan ID permintaan yang disiapkan dari database. </p><br><p><img src="https://habrastorage.org/webt/pb/tu/bq/pbtubqa7cvmly0ntnhs0dwc9etc.png"></p><br><p>  Setelah, pada saat lain, kami menghasilkan transaksi lain.  Di dalamnya, kita beralih ke database dan ingin memenuhi permintaan menggunakan pengidentifikasi dengan parameter yang ditentukan. </p><br><p><img src="https://habrastorage.org/webt/uy/ci/h4/uycih4iuh8aasw43aqodbsxolac.png"></p><br><p>  Dalam mode <strong>Transaction Pooling</strong> , dua transaksi dapat dieksekusi dalam koneksi yang berbeda, tetapi <strong>ID Pernyataan</strong> hanya valid dalam satu koneksi.  Kami mendapatkan <code>prepared statement does not exist</code> kesalahan saat mencoba menjalankan permintaan. </p><br><p>  Yang paling tidak menyenangkan: karena selama pengembangan dan pengujian bebannya kecil, <code>PgBouncer</code> sering mengeluarkan koneksi yang sama dan semuanya berfungsi dengan benar.  Tetapi segera setelah kami meluncurkannya ke prod, permintaan mulai jatuh dengan kesalahan. </p><br><p>  Sekarang temukan <code>Prepared Statements</code> dalam kode ini: </p><br><pre> <code class="go hljs">sql := <span class="hljs-string"><span class="hljs-string">`select * from places where city = ?`</span></span> rows, err := s.db.Query(sql, city)</code> </pre> <br><p>  Anda tidak akan melihatnya!  Persiapan kueri akan secara implisit terjadi di dalam <code>Query()</code> .  Pada saat yang sama, persiapan dan pelaksanaan permintaan akan terjadi dalam transaksi yang berbeda dan kami akan sepenuhnya menerima semua yang saya jelaskan di atas. </p><br><p>  <strong>Apa yang harus dilakukan</strong> </p><br><p>  Opsi pertama dan termudah adalah <strong>mengganti <code>PgBouncer</code> ke <code>Session pooling</code></strong> .  Satu koneksi dialokasikan ke sesi, semua transaksi mulai masuk dalam koneksi ini dan permintaan yang disiapkan berfungsi dengan benar.  Tetapi dalam mode ini, efisiensi pemanfaatan senyawa meninggalkan banyak hal yang diinginkan.  Oleh karena itu, opsi ini tidak dipertimbangkan. </p><br><p>  Opsi kedua adalah <strong>menyiapkan permintaan di sisi klien</strong> .  Saya tidak ingin melakukan ini karena dua alasan: </p><br><ul><li>  Potensi kerentanan SQL.  Pengembang mungkin lupa atau tidak sengaja melarikan diri. </li><li>  Melewati parameter kueri setiap kali Anda harus menulis dengan tangan Anda. </li></ul><br><p>  Pilihan lain adalah dengan <strong>membungkus secara eksplisit setiap permintaan dalam suatu transaksi</strong> .  Lagi pula, selama transaksi berlangsung, <code>PgBouncer</code> tidak mengambil koneksi.  Ini berfungsi, tetapi, selain verbositas dalam kode kami, kami juga mendapatkan lebih banyak panggilan jaringan: Mulai, Siapkan, Jalankan, Komit.  Total 4 panggilan jaringan per permintaan.  Latensi sedang tumbuh. </p><br><p>  Tetapi saya menginginkannya dengan aman, nyaman, dan efisien.  Dan ada opsi seperti itu!  Anda dapat secara eksplisit memberi tahu pengemudi bahwa Anda ingin <strong>menggunakan mode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertanyaan Sederhana</a></strong> .  Dalam mode ini, tidak akan ada persiapan dan seluruh permintaan akan berlalu dalam satu panggilan jaringan.  Dalam hal ini, driver akan membuat perisai dari masing-masing parameter itu sendiri ( <em><code>standard_conforming_strings</code> harus diaktifkan di tingkat dasar atau ketika membuat koneksi</em> ). </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... RuntimeParams: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"standard_conforming_strings"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span>, }, PreferSimpleProtocol: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }</code> </pre> <br><h1 id="otmena-zaprosov">  Batalkan permintaan </h1><br><p>  Masalah-masalah berikut terkait dengan membatalkan permintaan di sisi aplikasi. </p><br><p>  Lihatlah kode ini.  Dimana jebakannya? </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, ...)</code> </pre> <br><p>  Go memiliki metode untuk mengendalikan alur eksekusi program - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">context.Context</a> .  Dalam kode ini, kami meneruskan <code>ctx</code> driver sehingga ketika konteksnya ditutup, driver membatalkan permintaan di tingkat database. </p><br><p>  Pada saat yang sama, diharapkan bahwa kami akan menghemat sumber daya dengan membatalkan permintaan yang tidak ditunggu oleh siapa pun.  Tetapi ketika membatalkan permintaan, <code>PgBouncer</code> versi <em>1.7</em> mengirimkan informasi ke koneksi yang koneksi ini siap digunakan, dan setelah itu mengembalikannya ke pool.  Perilaku <code>PgBouncer'</code> ini menyesatkan pengemudi, yang ketika mengirim permintaan berikutnya, langsung menerima <code>ReadyForQuery</code> sebagai tanggapan.  Pada akhirnya, kami menangkap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan ReadyForQuery yang tidak terduga</a> . </p><br><p>  Dimulai dengan <code>PgBouncer</code> versi <em>1.8,</em> perilaku ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah diperbaiki</a> .  Gunakan versi <code>PgBouncer</code> . </p><br><p>  Dan, meskipun, dalam kasus ini, kesalahan akan hilang - perilaku yang menarik akan tetap ada.  Dalam beberapa kasus, aplikasi kita mungkin menerima jawaban bukan untuk permintaannya, tetapi untuk yang bertetangga (yang utama adalah bahwa permintaan sesuai dengan jenis dan urutan data yang diminta).  Misalnya, ke kueri di <code>where user_id = 2</code> , respons kueri di <code>where user_id = 42</code> akan dikembalikan.  Hal ini disebabkan oleh pemrosesan permintaan pembatalan di level yang berbeda: di level pool driver dan pool bouncer. </p><br><h3 id="otlozhennaya-otmena">  Pembatalan yang tertunda </h3><br><p>  Untuk membatalkan permintaan, kita perlu membuat koneksi baru ke database dan meminta pembatalan.  <code>Postgres</code> menciptakan proses terpisah untuk setiap koneksi.  Kami mengirim perintah untuk membatalkan permintaan <strong>saat ini</strong> dalam proses tertentu.  Untuk melakukan ini, buat koneksi baru dan di dalamnya transfer ID proses (PID) yang menarik kepada kami.  Tetapi sementara perintah pembatalan terbang ke pangkalan, permintaan yang dibatalkan dapat berakhir dengan sendirinya. </p><br><p><img src="https://habrastorage.org/webt/us/xf/v_/usxfv_i0ze_axpmjtlir183reiu.png"></p><br><p>  <code>Postgres</code> akan menjalankan perintah dan membatalkan permintaan <strong>saat ini</strong> dalam proses yang diberikan.  Namun permintaan saat ini bukan yang ingin kami batalkan pada awalnya.  Karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perilaku ini</a> ketika bekerja dengan <code>Postgres</code> dengan <code>PgBouncer</code> lebih aman untuk tidak membatalkan permintaan di tingkat driver.  Untuk melakukan ini, Anda dapat mengatur <code>CustomCancel</code> , yang tidak akan membatalkan permintaan, bahkan jika <code>context.Context</code> . <code>context.Context</code> digunakan. </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... CustomCancel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, }</code> </pre> <br><h1 id="cheklist-po-rabote-s-postgres">  Daftar Periksa Postgres </h1><br><p>  Alih-alih kesimpulan, saya memutuskan untuk membuat daftar periksa untuk bekerja dengan Postgres.  Ini akan membantu artikel masuk ke kepala saya. </p><br><ul><li>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jackc/pgx</a> sebagai driver untuk bekerja dengan Postgres. </li><li>  Batasi ukuran kumpulan koneksi dari atas. </li><li>  Cache <code>OIDs</code> atau gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pgx.ConnPool</a> jika Anda bekerja dengan <code>pgx</code> versi 3. </li><li>  Kumpulkan metrik dari kumpulan koneksi menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DB.Stats ()</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ConnPool.Stat ()</a> . </li><li>  Catat apa yang terjadi pada pengemudi. </li><li>  Gunakan mode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertanyaan Sederhana</a> untuk menghindari masalah dengan persiapan kueri dalam mode transaksional <code>PgBouncer</code> . </li><li>  Perbarui <code>PgBouncer</code> ke versi terbaru. </li><li>  Hati-hati dengan membatalkan permintaan dari aplikasi. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461935/">https://habr.com/ru/post/id461935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461919/index.html">Menggunakan kembali formulir pada Bereaksi</a></li>
<li><a href="../id461921/index.html">HDMI-LVDS. Pengembangan pada TSUMV59 dari MStar</a></li>
<li><a href="../id461923/index.html">JetBrains Open Day di St. Petersburg: video</a></li>
<li><a href="../id461927/index.html">Pembelajaran Peringkat Aktif</a></li>
<li><a href="../id461929/index.html">Memantau dan memeriksa status SSD di Linux</a></li>
<li><a href="../id461937/index.html">Hukum Parkinson dan cara melanggarnya</a></li>
<li><a href="../id461939/index.html">Tahun petualangan dengan graphene-python</a></li>
<li><a href="../id461941/index.html">Pijat itu</a></li>
<li><a href="../id461945/index.html">Intisari acara untuk profesional SDM di bidang TI untuk Agustus 2019</a></li>
<li><a href="../id461949/index.html">AppCode 2019.2: Swift 5.1, analisis cakupan kode dengan tes, tampilan kode dibongkar dan banyak lagi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>