<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏿 🏴‍☠️ 🐋 西格玛规则。 工艺或新的SOC标准 🎱 😈 🐃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我是Infosecurity SOC（安全运营中心）负责人Sergey Rublev。 
 在本文中，我将详细研究雄心勃勃的Sigma Rules项目，其座右铭是：“用于日志的Sigma就像流量的Snort一样，对于文件就像Yara一样。” 



 这将涉及三个方面： 



- Sigma-ru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>西格玛规则。 工艺或新的SOC标准</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/softline/blog/442570/"> 我是Infosecurity SOC（安全运营中心）负责人Sergey Rublev。 <br> 在本文中，我将详细研究雄心勃勃的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sigma Rules</a>项目，其座右铭是：“用于日志的Sigma就像流量的Snort一样，对于文件就像Yara一样。” <br><br><img src="https://habrastorage.org/webt/xi/c9/_a/xic9_a4hwhjkjsi4shhsk2oqalk.png"><br><br> 这将涉及三个方面： <br><br><ul><li>  Sigma-rule语法在维护威胁检测脚本的知识库中的适用性 </li><li> 盒装SIEM系统的规则生成工具的功能 </li><li>  Sigma规则公共存储库中当前内容的SOC值 </li></ul><a name="habracut"></a><br><h2> 曾几何时，在遥远的星系中 </h2><br> 一切始于几年前的树木大，而我们的监控团队仍然很小。 我们面临很多问题，几乎所有成长为三人团队的团队都需要经历这一过程。 <br><br><img src="https://habrastorage.org/webt/eu/0a/1t/eu0a1ti-3y93okrcileh_cymq3w.png"><br><br> 出现问题的原因不同： <br><br><ul><li> 团队成长 </li><li> 员工流动 </li><li> 大量用于监视的异构系统 </li></ul><br> 如果您必须接受SIEM某人已经配置的支持，问题的数量会像雪崩般增加。 <br><br><h2> 用例库 </h2><br> 建立监控中心的全球经验已经提出了解决混乱的解决方案，其名称是案例研究库。 每种情况的目的都是在信息安全监视框架中全面描述问题的解决方案。 <br><br> 在每种情况下积累的知识组成可能有所不同；我们从以下几组着手： <br><br><ul><li>  <b>目标</b> -案件解决的任务 </li><li>  <b>威胁</b> -检测规则试图检测的威胁。 </li><li>  <b>利益相关者</b> -对此规则感兴趣的人：IB / IT /商业 </li><li>  <b>数据要求</b> -识别威胁所需的数据集 </li><li>  <b>逻辑</b> -威胁检测规则逻辑 </li><li>  <b>测试</b> -一种测试检测规则正确性的算法 </li><li>  <b>优先级</b> -根据案例处理事件的<b>优先</b>级（通常根据成功实施的威胁造成的潜在损害来计算） </li><li>  <b>输出</b> -解析警报的操作列表，解析过程正确退出的描述以及解析结果中记录的数据组成 </li></ul><br> 用于检测与僵尸网络管理服务器（通常称为C＆C或仅称为C2）的通信的任务的用例示例： <br><br><img src="https://habrastorage.org/webt/jh/zz/s9/jhzzs9zblfsxc5-vehzmadc_hjk.png"><br><br> 该示例已大大简化；实际上，只要有适当的描述，案例就会发展成多页文档。 <br><br> 那时，当案例数超过几十时，我们开始寻找现成的工具来维护这样的知识库，最好是除了对人类友好之外，还具有某种机器友好的工作界面。 <br><br><h2> 西格玛项目 </h2><br> 在基于事件检测规则的知识库中，Sigma项目当然值得考虑。 它始于2016年，我几乎从一开始就一直关注它。 <br><br> 实际上，该项目包括 <br><br><ul><li> 适马自己统治 </li><li> 用于将规则转换为各种SIEM系统查询的实用程序 </li></ul><br>  SIEM列表令人印象深刻：几乎所有流行的事件分析解决方案都存在。 关于所有细节的详细信息和顺序。 <br><br><h2> 规则语法 </h2><br>  Sigma规则是YAML文档，描述了检测特定攻击的方案。 从语法上讲，规则包括以下块： <br><br><h3> 元信息 </h3><br> 描述性部分，用于结构化和简化对必要规则的搜索。 <br><br><pre><code class="plaintext hljs">title: Access to ADMIN$ Share description: Detects access to $ADMIN share author: Florian Roth falsepositives: - Legitimate administrative activity level: low tags: - attack.lateral_movement - attack.t1077 status: experimental</code> </pre> <br> 我还想指出，根据MITER ATT＆CK方法，已经提供了许多与攻击技术的链接的规则。 <br><br><h3> 数据源声明 </h3><br> 基于实现了检测逻辑的事件的源描述。 <br><br><pre> <code class="actionscript hljs">logsource: product: windows service: security</code> </pre><br> 从句法上讲，既可以描述特定产品的最终服务，又可以描述整个系统类别。 <br><br><h3> 处理逻辑声明 </h3><br> 在检测逻辑级别，描述了以下内容： <br><br><ul><li> 搜索模式 </li><li> 日志中某些字段的值 </li><li> 时间范围 </li><li> 汇总功能 </li></ul><br> 逻辑可以很简单，例如，施加在一组字段上的条件： <br><br><pre> <code class="actionscript hljs">detection: selection: EventID: <span class="hljs-number"><span class="hljs-number">5140</span></span> ShareName: Admin$ filter: SubjectUserName: <span class="hljs-string"><span class="hljs-string">'*$'</span></span> condition: selection and not filter</code> </pre><br> 而且很复杂： <br><br><pre> <code class="actionscript hljs">detection: selection1: EventID: - <span class="hljs-number"><span class="hljs-number">529</span></span> - <span class="hljs-number"><span class="hljs-number">4625</span></span> UserName: <span class="hljs-string"><span class="hljs-string">'*'</span></span> WorkstationName: <span class="hljs-string"><span class="hljs-string">'*'</span></span> selection2: EventID: <span class="hljs-number"><span class="hljs-number">4776</span></span> UserName: <span class="hljs-string"><span class="hljs-string">'*'</span></span> Workstation: <span class="hljs-string"><span class="hljs-string">'*'</span></span> timeframe: <span class="hljs-number"><span class="hljs-number">24</span></span>h condition: - selection1 | count(UserName) by WorkstationName &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> - selection2 | count(UserName) by Workstation &gt; <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br> 该语言的表达方式虽然不是通用的，但仍然很广泛，可以让您描述大量识别攻击的案例。 <br><br><h2> 规则开发工具 </h2><br> 除了您最喜欢的YAML文本编辑器之外，还可以使用SOC Prime的WEB UI，它使您既可以验证已编写规则的语法，又可以从图形块手动创建规则。 <br><br><img src="https://habrastorage.org/webt/_a/fj/yv/_afjyva1emrq4kapfrzhsdfa25g.png"><br><br><h2>  Sigma作为知识库工具 </h2><br> 总结一个简短的总结。 <br><br> 目前，规则的语法主要集中在威胁检测逻辑的描述上，并不打算对用例进行全面描述；因此，仅使用Sigma规则来维护完整的库将不起作用。 <br><br> 对于我们选择的用例结构，Sigma仅关闭一半（目标，数据需求，逻辑和优先级）。 <br><br><img src="https://habrastorage.org/webt/cc/f7/ee/ccf7ee58wrz2rtolzizshobhrdi.png"><br><br><h2> 转换为各种SIEM </h2><br> 由于我们是SOC服务的服务提供者，因此按照相关规则以某种通用格式保留我们所有的开发，并在实施阶段转换为所需的SIEM格式的想法对我们来说很有吸引力。 <br><br> 该项目包括控制台实用程序，用于生成各种SIEM格式的事件请求。 考虑一下什么是转变，什么是她的内幕。 <br><br><img src="https://habrastorage.org/webt/ff/eh/6e/ffeh6eo7eo57c9jqruz-wzptwnm.png"><br><br> 转换分为三个阶段： <br><br><ol><li> 解析规则-我认为这很明确：YAML文档被分类为组件块 </li><li> 简化为SIEM分类法 <br> 此阶段的必要性与以下事实有关：SIEM系统中的规范化以稍微不同的方式实现，因此需要将Sigma规则的声明简化为所选SIEM事件的分类法 </li><li>  SIEM的请求生成 <br> 为了使此阶段正常工作，需要另一个组件-该SIEM的后端。 <br> 实际上，后端是转换实用程序的插件，其中包含用于转换为SIEM中最终请求格式的逻辑。 检测和日志源块在转换时会考虑到先前叠加的字段映射，并添加了其他特定于SIEM的信息。 <br></li></ol><br> 结果，启动转换实用程序如下所示： <br><br><img src="https://habrastorage.org/webt/p8/co/pu/p8copuabozrkspbihteeynh_sxy.png"><br><br> 传递了以下参数： <br><br><ul><li> 目标SIEM </li><li> 规则 </li><li> 该SIEM的映射文件 </li></ul><br><br>  SOC Prime还具有用于转换功能的现成UI（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">uncoder.io</a> ） <br><br><img src="https://habrastorage.org/webt/gz/-i/jj/gz-ijj-iw3bu_pcbng8orprja0w.png"><br><br><h2> 转换的陷阱 </h2><br><ul><li> 在研究了转换机制之后，我们遇到了很大的限制，这使我们无法将所有开发成果都转换为Sigma格式： </li><li> 转换器仅根据请求运行。  SIEM中的关联规则会影响更多方面：时间窗口，聚合，基于已识别警报结果的操作 </li><li> 不考虑单个SIEM的关键功能，例如ActiveList。 </li><li> 字段映射的详细信息不足-作为映射配置的一部分，仅描述了少数几个源的字段；因此，对于数据库中数十种不同类型的事件源的规则，您将不得不投入大量精力来编写映射。 </li></ul><br><h2> 规则库 </h2><br> 让我们看看可公开获得的Sigma规则库的含义。 当前，内容正在积极地添加到两个存储库中： <br><br><ul><li> 主要项目资料库 </li><li>  SOC Prime威胁检测市场 </li></ul><br> 存储库中的规则具有非零交集。 <br>  SOC Prime有许多适用于付费订阅的规则；我不在本文中讨论它们的内容。 <br><br> 对于分析，我们需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">适用</a>于Python的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sigmatools</a>库和一些编程技巧。 <br><br> 要将规则从目录解析并加载到字典中，可以使用以下代码： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sigma.parser.collection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SigmaCollectionParser <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> itertools <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alliter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sub <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> path.iterdir(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sub.name.startswith(<span class="hljs-string"><span class="hljs-string">"."</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sub.is_dir(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> alliter(sub) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sub <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_inputs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(paths, recursive)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> recursive: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list(itertools.chain.from_iterable([list(alliter(pathlib.Path(p))) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paths])) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [pathlib.Path(p) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paths] BASE_PATH = [<span class="hljs-string"><span class="hljs-string">r'sigma\rules'</span></span>] path_list = get_inputs(BASE_PATH, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) rules_map = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sigmafile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> get_inputs(BASE_PATH, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): f = sigmafile.open(encoding=<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) parser = SigmaCollectionParser(f) rule = next(iter(parser)) rules_map[rule[<span class="hljs-string"><span class="hljs-string">'title'</span></span>]] = rule</code> </pre><br> 对相同的规则进行重复数据删除，出现以下情况： <br><br><img src="https://habrastorage.org/webt/pd/92/jt/pd92jtrbth6glocd2kh-m9rcuqw.png"><br><br> 作为唯一规则列表的一部分，我们获得以下分布： <br><br>  <b>按事件源类型：</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/sn/h5/avsnh5hk5_szx4lfbc7tule8d9g.png"></div><br> 更大的统计数据 <br><br><ul><li> 窗户〜80％ </li><li> 西蒙〜53％ </li><li> 代理〜8％ </li><li>  Linux〜4％ </li></ul><br> 基本上，当前的内容主要集中在Windows和Sysmon系统上，尤其是其余系统的规则很少。 <br><br>  <b>通过内容可用性：</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rt/v2/vd/rtv2vd91ppx816ok1jtdhchylmq.png"></div><br> 事实证明，Sigma-rules的开发者标记为稳定的不到所有现有规则的20％。 <br><br><h2> 总结一下 </h2><br> 在公开可用的资源中，有很多规则。 它们会定期更新，并且会很快出现检测指标的规则，有时甚至是最受瞩目的APT公司的技术人员。 <br><br> 在现实生活中应用规则有很多限制： <br><br><ul><li>  Microsoft Sysmon有很多规则，在企业中很少使用。 </li><li> 有许多实际执行IoC检查的规则（哈希，IP地址，URL，用户代理）。 这样的规则很快就会过时，并且找到比规则更有效的IoC机制。 </li><li> 在调试之前，对高质量的测试分别有很多实验内容和附加要求。 </li></ul><br> 在Infosecurity，我们将Sigma规则的内容用作其他知识来源，以更有效地检测事件。 如果发现一些有趣的东西，我们将在关联规则的框架内实现该规则，该规则同时考虑了规则所基于的内核（Apache Spark）以及基础结构的细节以及我们使用的保护手段。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442570/">https://habr.com/ru/post/zh-CN442570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442558/index.html">“如果不需要产品，无论您如何包装，都将毫无意义”：技术公司如何在界面上工作</a></li>
<li><a href="../zh-CN442560/index.html">混搭：多线程，协程，异步和等待</a></li>
<li><a href="../zh-CN442562/index.html">如何冷却数据中心的设备-三种新技术</a></li>
<li><a href="../zh-CN442566/index.html">与月球一样：混合运算放大器模块的反向工程</a></li>
<li><a href="../zh-CN442568/index.html">安全周10：NVIDIA驱动程序漏洞</a></li>
<li><a href="../zh-CN442572/index.html">使用数据路径配置工具</a></li>
<li><a href="../zh-CN442574/index.html">创建了广义神经网络理论的基础</a></li>
<li><a href="../zh-CN442576/index.html">超频万岁：数据中心中的液体冷却如何开始占主导地位</a></li>
<li><a href="../zh-CN442578/index.html">Linux 5.0版本</a></li>
<li><a href="../zh-CN442580/index.html">以Korg .SNG文件为例的二进制格式逆向工程</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>