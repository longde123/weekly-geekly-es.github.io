<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 鮫勇 游뱛游낕 [Traducci칩n] Enviado modelo de subprocesos 游뱆游 驕쉺잺 游낺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducci칩n del art칤culo "Modelo de subprocesos de enviado" de Matt Klein. 

 Este art칤culo me pareci칩 lo suficientemente in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Traducci칩n] Enviado modelo de subprocesos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449826/">  Hola Habr!  Les presento la traducci칩n del art칤culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Modelo de subprocesos de enviado"</a> de Matt Klein. <br><br>  Este art칤culo me pareci칩 lo suficientemente interesante, y dado que Envoy se usa con mayor frecuencia como parte de "istio" o simplemente como "controlador de ingreso" kubernetes, por lo tanto, la mayor칤a de las personas no tienen la misma interacci칩n directa con 칠l como, por ejemplo, con las instalaciones t칤picas de Nginx o Haproxy.  Sin embargo, si algo se rompe, ser칤a bueno entender c칩mo funciona desde adentro.  Trat칠 de traducir la mayor cantidad de texto posible al ruso, incluyendo palabras especiales, para aquellos que son dolorosos de ver esto, dej칠 los originales entre par칠ntesis.  Bienvenido a cat. <br><a name="habracut"></a><br>  La documentaci칩n t칠cnica de bajo nivel en la base del c칩digo Envoy es actualmente bastante escasa.  Para solucionar esto, planeo hacer una serie de art칤culos de blog sobre los diversos subsistemas de Envoy.  Dado que este es el primer art칤culo, h치game saber lo que piensa y lo que podr칤a interesarle en los siguientes art칤culos. <br><br>  Una de las preguntas t칠cnicas m치s comunes que recibo sobre Envoy es una solicitud de una descripci칩n de bajo nivel del modelo de subprocesos utilizado.  En esta publicaci칩n, describir칠 c칩mo Envoy asigna conexiones a subprocesos, as칤 como una descripci칩n del sistema Thread Local Storage, que se usa internamente para hacer que el c칩digo sea m치s paralelo y de alto rendimiento. <br><br><h1>  Resumen de subprocesos </h1><br><img src="https://habrastorage.org/webt/jy/46/yw/jy46ywgcjdk8zvrpwyeisan8hzm.png"><br><br>  <b>Envoy utiliza tres tipos diferentes de transmisiones:</b> <br><br><ul><li>  <b>Principal:</b> este subproceso controla el inicio y el final del proceso, todo el procesamiento de la API XDS (xDiscovery Service), incluido DNS, comprobaci칩n de estado, administraci칩n general de cl칰ster y servicio (tiempo de ejecuci칩n), restablecimiento de estad칤sticas, administraci칩n y administraci칩n general procesos: se침ales de Linux, reinicio en caliente, etc. Todo lo que sucede en este hilo es as칤ncrono y no bloquea.  En general, el hilo principal coordina todos los procesos cr칤ticos de funcionalidad, que no requieren una gran cantidad de CPU para completarse.  Esto permite que la mayor칤a del c칩digo de control se escriba como si fuera un subproceso 칰nico. </li><li>  <b>Trabajador: de</b> forma predeterminada, Envoy crea un subproceso de trabajo para cada subproceso de hardware en el sistema, esto se puede controlar mediante la opci칩n <code>--concurrency</code> .  Cada subproceso de trabajo inicia un bucle de eventos "sin bloqueo", que es responsable de escuchar a cada oyente, al momento de escribir (29 de julio de 2017) no hay fragmentaci칩n del oyente, recibiendo nuevos conexiones, creando una instancia de la pila de filtros para conectar y procesando todas las operaciones de E / S durante la vida 칰til de la conexi칩n.  Nuevamente, esto permite que la mayor칤a del c칩digo de procesamiento de la conexi칩n se escriba como si fuera de un solo subproceso. </li><li>  <b>File flusher:</b> cada archivo que escribe Envoy, principalmente registros de acceso, actualmente tiene una secuencia de bloqueo independiente.  Esto se debe al hecho de que la escritura en archivos almacenados en cach칠 por el sistema de archivos, incluso cuando se utiliza <code>O_NONBLOCK</code> , a veces se puede bloquear (suspiro).  Cuando los subprocesos de trabajo necesitan escribir en un archivo, los datos se mueven realmente a un b칰fer en la memoria, donde eventualmente se transfieren a trav칠s del flujo de <b>descarga de archivos</b> .  Esta es un 치rea de c칩digo donde t칠cnicamente todos los subprocesos de trabajo pueden bloquear el mismo bloqueo al intentar llenar el b칰fer de memoria. </li></ul><br><h1>  Manejo de conexi칩n </h1><br>  Como se discuti칩 brevemente arriba, todos los hilos de trabajo escuchan a todos los oyentes sin ninguna segmentaci칩n.  Por lo tanto, el n칰cleo se utiliza para enviar correctamente los sockets recibidos a los subprocesos de trabajo.  Los n칰cleos modernos generalmente son muy buenos en esto, usan caracter칤sticas como aumentar la prioridad de entrada-salida (IO) para tratar de llenar el hilo con trabajo, antes de comenzar a usar otros hilos que tambi칠n escuchan en el mismo z칩calo, y tampoco usan bloqueo circular (Spinlock) para manejar cada solicitud. <br><br>  Una vez que se acepta una conexi칩n en un subproceso de trabajo, nunca abandona este subproceso.  Todo el procesamiento posterior de la conexi칩n se procesa completamente en el subproceso de trabajo, incluido cualquier comportamiento de reenv칤o. <br><br>  <b>Esto tiene varias consecuencias importantes:</b> <br><br><ul><li>  <u>Todos los grupos de conexiones en Envoy est치n en un flujo de trabajo.</u>  <u>Por lo tanto, aunque los grupos de conexiones HTTP / 2 solo hacen una conexi칩n a cada host ascendente a la vez, si hay cuatro subprocesos de trabajo, habr치 cuatro conexiones HTTP / 2 al host ascendente en un estado estable.</u> </li><li>  La raz칩n por la que Envoy funciona de esta manera es porque al almacenar todo en un flujo de trabajo, casi todo el c칩digo puede escribirse sin bloqueo y como si fuera un subproceso 칰nico.  Este dise침o facilita la escritura de una gran cantidad de c칩digo y se escala incre칤blemente bien para una cantidad casi ilimitada de flujos de trabajo. </li><li>  Sin embargo, una de las principales conclusiones es que, desde el punto de vista del conjunto de memoria y la eficiencia de la conexi칩n, en realidad es muy importante configurar el par치metro <code>--concurrency</code> .  Tener m치s subprocesos de trabajo de los necesarios conducir치 a la p칠rdida de memoria, creando m치s conexiones inactivas y disminuyendo la velocidad de acceso al grupo de conexiones.  En Lyft, nuestros contenedores de sidecar de mensajer칤a funcionan con una concurrencia muy baja, por lo que el rendimiento es m치s o menos equivalente a los servicios en los que se encuentran.  Ejecutamos Envoy como un proxy de borde (borde) solo con la m치xima concurrencia. </li></ul><br><h1>  쯈u칠 significa sin bloqueo? </h1><br>  El t칠rmino "sin bloqueo" se ha utilizado hasta ahora varias veces para analizar c칩mo funcionan los hilos principales y de trabajo.  Todo el c칩digo est치 escrito siempre que nada est칠 bloqueado.  Sin embargo, esto no es del todo cierto (쯤u칠 no es del todo cierto?). <br><br>  <b>Envoy utiliza varios bloqueos de proceso largos:</b> <br><br><ul><li>  Como ya se mencion칩, al escribir registros de acceso, todos los subprocesos de trabajo obtienen el mismo bloqueo antes de llenar el b칰fer de registro en la memoria.  El tiempo de retenci칩n del bloqueo debe ser muy bajo, pero es posible que este bloqueo se vea desafiado con una alta concurrencia y un alto rendimiento. </li><li>  Envoy utiliza un sistema muy sofisticado para procesar estad칤sticas que es local a la secuencia.  Este ser치 el tema de una publicaci칩n separada.  Sin embargo, mencionar칠 brevemente que, como parte del procesamiento local de estad칤sticas de flujo, a veces se requiere obtener un bloqueo para el "almac칠n de estad칤sticas" central.  Esta cerradura nunca deber칤a ser necesaria. </li><li>  El hilo principal peri칩dicamente necesita coordinaci칩n con todos los flujos de trabajo.  Esto se hace "publicando" desde el hilo principal a los hilos de trabajo y, a veces, desde los hilos de trabajo de vuelta al hilo principal.  Para el env칤o, se requiere el bloqueo para que el mensaje publicado se pueda poner en cola para entrega posterior.  Estas cerraduras nunca deben estar sujetas a una competencia seria, pero a칰n pueden ser bloqueadas t칠cnicamente. </li><li>  Cuando Envoy escribe un registro en la secuencia de errores del sistema (error est치ndar), recibe un bloqueo en todo el proceso.  En general, el registro local de Envoy se considera terrible en t칠rminos de rendimiento, por lo que no se presta mucha atenci칩n a mejorarlo. </li><li>  Hay varios otros bloqueos aleatorios, pero ninguno de ellos es cr칤tico para el rendimiento y nunca se debe disputar. </li></ul><br><h1>  Hilo de almacenamiento local </h1><br>  Debido a la forma en que Envoy separa las responsabilidades del hilo principal de las tareas del flujo de trabajo, existe el requisito de que se pueda realizar un procesamiento complejo en el hilo principal y luego proporcionar a cada flujo de trabajo un alto grado de concurrencia.  Esta secci칩n describe el sistema Envoy Thread Local Storage (TLS) en un nivel alto.  En la siguiente secci칩n, describir칠 c칩mo se usa para administrar el cl칰ster. <br><br><img src="https://habrastorage.org/webt/hc/e4/bs/hce4bsjgfljckbekacfilceotyq.png"><br><br>  Como ya se describi칩, el subproceso principal procesa casi todas las funciones de administraci칩n y la funcionalidad del plano de control en el proceso Envoy.  El plano de control est치 un poco sobrecargado aqu칤, pero si lo mira dentro del proceso Envoy y lo compara con el reenv칤o que realizan los subprocesos de trabajo, esto parece apropiado.  Como regla general, el proceso del subproceso principal hace algo de trabajo y luego necesita actualizar cada subproceso de trabajo de acuerdo con el resultado de este trabajo, <u>mientras que el subproceso de trabajo no necesita establecer un bloqueo en cada acceso</u> . <br><br>  <b>El sistema Enviado TLS (Thread local storage) funciona de la siguiente manera:</b> <br><br><ul><li>  El c칩digo que se ejecuta en el subproceso principal puede asignar una ranura TLS para todo el proceso.  Aunque esto se abstrae, en la pr치ctica es un 칤ndice en un vector que proporciona acceso O (1). </li><li>  La transmisi칩n principal puede establecer datos arbitrarios en su ranura.  Cuando se hace esto, los datos se publican en cada flujo de trabajo como un evento de bucle de evento regular. </li><li>  Los subprocesos de los trabajadores pueden leer desde su ranura TLS y recuperar los datos de subprocesos locales disponibles all칤. </li></ul><br>  Aunque este es un paradigma muy simple e incre칤blemente poderoso, es muy similar al concepto de bloqueo de RCU (Read-Copy-Update).  En esencia, los flujos de trabajo nunca ven ning칰n cambio de datos en las ranuras TLS en tiempo de ejecuci칩n.  El cambio solo ocurre durante el per칤odo de descanso entre eventos de trabajo. <br><br>  <b>Envoy usa esto de dos maneras diferentes:</b> <br><br><ul><li>  Al almacenar diversos datos en cada flujo de trabajo, el acceso a estos datos se realiza sin ning칰n bloqueo. </li><li>  Al almacenar un puntero global a datos globales en modo de solo lectura en cada subproceso de trabajo.  Por lo tanto, cada subproceso de trabajo tiene un contador de referencia de datos, que no se puede reducir durante la ejecuci칩n del trabajo.  Solo cuando todos los trabajadores se calmen y carguen nuevos datos compartidos, se destruir치n los datos antiguos.  Es id칠ntico a la RCU. </li></ul><br><h1>  Subprocesos de actualizaci칩n de cl칰ster </h1><br>  En esta secci칩n, describir칠 c칩mo se usa TLS (almacenamiento local de subprocesos) para administrar un cl칰ster.  La gesti칩n de cl칰steres incluye el procesamiento de API xDS y / o DNS, as칤 como la comprobaci칩n del estado. <br><br><img src="https://habrastorage.org/webt/by/jw/4q/byjw4qhlo9xjsprdu9ngi9dop_y.png"><br><br>  <b>La gesti칩n del flujo de cl칰ster incluye los siguientes componentes y pasos:</b> <br><br><ol><li>  Cluster Manager es un componente dentro de Envoy que gestiona todas las API conocidas de cl칰ster aguas arriba, CDS (Cluster Discovery Service), SDS (Secret Discovery Service) y EDS (Endpoint Discovery Service), DNS y comprobaciones externas activas salud (control de salud).  Es responsable de crear una representaci칩n "en 칰ltima instancia coherente" de cada grupo aguas arriba que incluya los hosts descubiertos, as칤 como el estado de salud. </li><li>  El verificador de salud realiza una verificaci칩n de salud activa e informa sobre los cambios en el estado de salud al administrador del cl칰ster. </li><li>  Se realizan CDS (Cluster Discovery Service) / SDS (Secret Discovery Service) / EDS (Endpoint Discovery Service) / DNS para determinar la membres칤a del cl칰ster.  El cambio de estado se devuelve al administrador del cl칰ster. </li><li>  Cada flujo de trabajo ejecuta constantemente un bucle de eventos. </li><li>  Cuando el administrador del cl칰ster determina que el estado del cl칰ster ha cambiado, crea una nueva instant치nea del cl칰ster de solo lectura y la env칤a a cada subproceso de trabajo. </li><li>  Durante el pr칩ximo per칤odo de inactividad, el flujo de trabajo actualizar치 la instant치nea en la ranura TLS dedicada. </li><li>  Durante un evento de E / S que el host debe determinar para el equilibrio de carga, el equilibrador de carga solicitar치 una ranura TLS (almacenamiento local de subprocesos) para obtener informaci칩n del host.  No se requieren bloqueos para esto.  Tenga en cuenta tambi칠n que TLS tambi칠n puede desencadenar eventos durante la actualizaci칩n, por lo que los equilibradores de carga y otros componentes pueden contar cach칠s, estructuras de datos, etc.  Esto est치 m치s all치 del alcance de esta publicaci칩n, pero se usa en varios lugares del c칩digo. </li></ol><br>  Usando el procedimiento anterior, Envoy puede procesar cada solicitud sin ning칰n bloqueo (aparte de los descritos anteriormente).  Adem치s de la complejidad del c칩digo TLS en s칤, la mayor칤a del c칩digo no necesita comprender c칩mo funciona el subprocesamiento m칰ltiple, y se puede escribir en modo de subproceso 칰nico.  Esto facilita la escritura de la mayor칤a del c칩digo, adem치s de un rendimiento superior. <br><br><h1>  Otros subsistemas que hacen uso de TLS </h1><br>  TLS (Thread local storage) y RCU (Read Copy Update) se usan ampliamente en Envoy. <br><br>  <b>Ejemplos de uso:</b> <br><br><ul><li>  <b>El mecanismo de cambio de funcionalidad durante la ejecuci칩n:</b> la lista actual de funcionalidad habilitada se calcula en el hilo principal.  Luego, cada flujo de trabajo se proporciona con una instant치nea de solo lectura utilizando la sem치ntica de RCU. </li><li>  <b>Sustituci칩n de tablas de ruta</b> : para las tablas de ruta proporcionadas por el RDS (Servicio de descubrimiento de ruta), las tablas de ruta se crean en el hilo principal.  Posteriormente se proporcionar치 una instant치nea de solo lectura a cada flujo de trabajo utilizando la sem치ntica de RCU (Actualizaci칩n de lectura de copia).  Esto hace que la modificaci칩n de las tablas de rutas sea at칩micamente eficiente. </li><li>  <b>Cach칠 de encabezado HTTP:</b> Resulta que calcular el encabezado HTTP para cada solicitud (cuando se realizan ~ 25K + RPS por n칰cleo) es bastante costoso.  Envoy calcula centralmente el encabezado aproximadamente cada medio segundo y se lo proporciona a cada empleado a trav칠s de TLS y RCU. </li></ul><br>  Hay otros casos, pero los ejemplos anteriores deber칤an proporcionar una buena comprensi칩n de para qu칠 se utiliza TLS. <br><br><h1>  Problemas conocidos de rendimiento </h1><br>  Aunque Envoy funciona bastante bien en general, hay algunas 치reas bien conocidas que necesitan atenci칩n cuando se usan con muy alta concurrencia y ancho de banda: <br><br><ul><li>  Como ya se describi칩 en este art칤culo, actualmente todos los subprocesos de trabajo est치n bloqueados cuando escriben en el b칰fer de memoria del registro de acceso.  Con alta concurrencia y alto rendimiento, ser치 necesario empaquetar registros de acceso para cada flujo de trabajo debido a una entrega no ordenada al escribir en el archivo final.  Alternativamente, puede crear un registro de acceso separado para cada flujo de trabajo. </li><li>  Aunque las estad칤sticas est치n muy optimizadas, con una concurrencia y un rendimiento muy altos, es probable que haya una competencia at칩mica en las estad칤sticas individuales.  La soluci칩n a este problema son los contadores por flujo de trabajo con reinicio peri칩dico de los contadores centrales.  Esto se discutir치 en una publicaci칩n posterior. </li><li>  La arquitectura existente no funcionar치 bien si Envoy se implementa en un escenario en el que hay muy pocas conexiones que requieren recursos de procesamiento significativos.  No hay garant칤a de que las comunicaciones se distribuyan de manera uniforme entre los flujos de trabajo.  Esto se puede resolver equilibrando las conexiones de trabajo, en las que se realizar치 la capacidad de intercambiar conexiones entre flujos de trabajo. </li></ul><br><h1>  Conclusi칩n </h1><br>  El modelo de subprocesos de Envoy est치 dise침ado para proporcionar una programaci칩n sencilla y una concurrencia masiva debido al uso potencialmente in칰til de memoria y conexiones si no est치n configuradas correctamente.  Este modelo le permite funcionar muy bien con una gran cantidad de hilos y rendimiento. <br><br>  Como mencion칠 brevemente en Twitter, un dise침o tambi칠n puede ejecutarse sobre una pila de red completamente funcional en modo de usuario, como el DPDK (Kit de desarrollo de plano de datos), que puede hacer que los servidores regulares procesen millones de solicitudes por segundo con un procesamiento L7 completo.  Ser치 muy interesante ver lo que se construir치 en los pr칩ximos a침os. <br><br>  Un 칰ltimo comentario r치pido: muchas veces me han preguntado por qu칠 elegimos C ++ para Envoy.  La raz칩n, como antes, es que sigue siendo el 칰nico lenguaje de nivel industrial ampliamente hablado sobre el cual construir la arquitectura descrita en esta publicaci칩n.  C ++ definitivamente no es adecuado para todos o incluso para muchos proyectos, pero para ciertos casos de uso sigue siendo la 칰nica herramienta para hacer el trabajo (para hacer el trabajo). <br><br><h1>  Enlaces al c칩digo </h1><br>  <b>Enlaces a archivos con interfaces e implementaciones de encabezado discutidos en esta publicaci칩n:</b> <br><br><ul><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/thread_local/thread_local.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/thread_local/thread_local_impl.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/upstream/cluster_manager.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/upstream/cluster_manager_impl.h</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449826/">https://habr.com/ru/post/449826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449808/index.html">Experimento Positivo Hack Days 9: c칩mo el pensamiento cr칤tico ayuda en la vida y el trabajo</a></li>
<li><a href="../449814/index.html">Windows XP est치 oficialmente muerto, ahora finalmente</a></li>
<li><a href="../449818/index.html">Estad칤sticas y monitoreo de scripts PHP en tiempo real. ClickHouse y Grafana van a Pinba para obtener ayuda</a></li>
<li><a href="../449820/index.html">Personalice al instante asociaciones de archivos familiares</a></li>
<li><a href="../449824/index.html">Las aventuras de la startup de hierro en Rusia: Team Building</a></li>
<li><a href="../449828/index.html">"Los ratones lloraron y pincharon ..." Sustituci칩n de importaciones en la pr치ctica. Parte 4 (te칩rica, final). Sistemas y servicios</a></li>
<li><a href="../449830/index.html">Control de l칤nea de potencia HD44780</a></li>
<li><a href="../449832/index.html">Futuro cu치ntico</a></li>
<li><a href="../449836/index.html">Dell U2419HC: elegante monitor de 24 pulgadas con Full HD y USB-C</a></li>
<li><a href="../449840/index.html">Barra de inicio: un nuevo m칠todo de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>