<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎸 🔼 🧑🏽‍🤝‍🧑🏽 Menanam fungsi yang cacat di Go 👩🏻‍🔧 🏞️ 🧘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah kode yang ditunjukkan di bawah ini setara dengan kinerja? 


// (A). HasPrefix . return strings.HasPrefix(s, "#") // (B). HasPrefix. return len...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menanam fungsi yang cacat di Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438636/"><p><img src="https://habrastorage.org/webt/lm/rt/rk/lmrtrkww5knurdsaznutrksterk.jpeg"></p><br><p>  Apakah kode yang ditunjukkan di bawah ini setara dengan kinerja? </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// (A).  HasPrefix  . return strings.HasPrefix(s, "#") // (B).    HasPrefix. return len(s) &gt;= len("#") &amp;&amp; s[:len("#")] == "#"</span></span></code> </pre> <br><p>  Jawabannya adalah <strong>tidak</strong> . </p><br><p>  Untuk detail dan penjelasan, saya bertanya di bawah kucing. </p><a name="habracut"></a><br><hr><br><p>  Selamat siang, sebelum Anda membuka topik, saya ingin memperkenalkan diri. <br>  Nama saya Iskander dan dari waktu ke waktu saya mengirim komit ke repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang / go</a> . </p><br><img src="https://habrastorage.org/webt/ls/jy/t3/lsjyt3z-jg1l5dx2nlecj17lbks.png" alt="gambar" align="left"><br><p>  Saya dulu melakukan ini atas nama tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel Go</a> , tetapi jalur kami berbeda dan sekarang saya adalah kontributor independen.  Baru-baru ini saya telah bekerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vk</a> di tim infrastruktur. </p><br><p>  Di waktu senggang, saya membuat berbagai alat untuk Go, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-critic</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-konsisten</a> .  Saya juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambar akan menghubungkan</a> . </p><br><p><br></p><br><h1 id="measure-it">  Ukur itu! </h1><br><p>  Segera lanjutkan ke perbandingan dan garis besar tolok ukur: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"#string"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"#"</span></span>) _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"x"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixInlined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"#"</span></span> _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"x"</span></span> } }</code> </pre> <br><p>  Alih-alih merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">benchstat</a> kepada Anda, saya akan menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">benchrun kepada</a> Anda. </p><br><p>  Dengan satu perintah, kita dapat menjalankan kedua tolok ukur dan mendapatkan perbandingan: </p><br><pre> <code class="bash hljs">go-benchrun HasPrefixCall HasPrefixInlined -v -count=10 . Benchstat results: name old time/op new time/op delta HasPrefixCall-8 9.15ns ± 1% 0.36ns ± 3% -96.09% (p=0.000 n=10+9)</code> </pre> <br><p>  Opsi dengan embedding manual jauh lebih cepat daripada kode yang diperoleh dengan menanamkan fungsi tubuh dengan kompiler.  Mari kita coba mencari tahu mengapa ini terjadi. </p><br><h1 id="stringshasprefix">  strings.HasPrefix </h1><br><p>  Ingat implementasi <code>strings.HasPrefix</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HasPrefix tests whether the string s begins with prefix. func HasPrefix(s, prefix string) bool { return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix }</span></span></code> </pre> <br><p>  Fungsi <code>HasPrefix</code> dibangun oleh kompiler. <br>  Anda dapat memverifikasi ini sebagai berikut: </p><br><pre> <code class="bash hljs">go build -gcflags=<span class="hljs-string"><span class="hljs-string">'-m=2'</span></span> strings 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'can inline HasPrefix'</span></span></code> </pre> <br><p>  Untuk memanggil <code>strings.HasPrefix</code> dari opsi <code>(A)</code> kita mendapatkan kode mesin berikut: </p><br><pre> <code class="plaintext hljs"> MOVQ (TLS), CX CMPQ SP, 16(CX) JLS more_stack fn_body: SUBQ $40, SP MOVQ BP, 32(SP) LEAQ 32(SP), BP XCHGL AX, AX MOVQ s+56(SP), AX CMPQ AX, $1 JGE compare_strings XORL AX, AX MOVB AL, ~ret1+64(SP) MOVQ 32(SP), BP ADDQ $40, SP return: RET compare_strings: MOVQ s+48(SP), AX MOVQ AX, (SP) LEAQ go.string."#"(SB), AX MOVQ AX, 8(SP) MOVQ $1, 16(SP) CALL runtime.memequal(SB) MOVBLZX 24(SP), AX JMP return more_stack: CALL runtime.morestack_noctxt(SB) JMP fn_body</code> </pre> <br><p>  Abaikan fakta bahwa kode tersebut terlihat seperti mie. </p><br><p>  Apa yang harus Anda perhatikan: </p><br><ul><li>  <code>strings.HasPrefix</code> benar-benar dimasukkan, tidak ada panggilan. </li><li>  Untuk membandingkan string, <code>runtime.memequal</code> . </li></ul><br><p>  Tapi apa yang kemudian dihasilkan untuk versi built-in secara manual, kode dari example <code>(B)</code> ? </p><br><pre> <code class="plaintext hljs"> MOVQ s+16(SP), AX CMPQ AX, $1 JLT different_length MOVQ s+8(SP), AX CMPB (AX), $35 // 35 -   "#" SETEQ AL return: MOVB AL, "".~ret1+24(SP) RET different_length: XORL AX, AX JMP 22</code> </pre> <br><p>  Dan di sini kompiler tidak menghasilkan panggilan ke <code>runtime.memequal</code> dan satu karakter dibandingkan secara langsung.  Idealnya, dia seharusnya melakukan hal yang sama untuk opsi pertama. </p><br><p>  Kami mengamati sisi lemah pengoptimal Go, dan kami akan menganalisisnya. </p><br><h1 id="optimizacii-konstantnyh-vyrazheniy">  Optimasi Ekspresi Konstan </h1><br><p>  Alasan yang memanggil <code>strings.HasPrefix(s, "#")</code> dapat dioptimalkan adalah karena argumen awalan adalah konstan.  Kami tahu panjang dan isinya.  Tidak masuk akal untuk memanggil <code>runtime.memequal</code> untuk string pendek, lebih cepat untuk membuat perbandingan karakter "di tempat", menghindari panggilan tambahan. </p><br><p>  Seperti yang Anda ketahui, kompiler biasanya memiliki setidaknya dua bagian: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">compiler frontend</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">compiler backend</a> .  Yang pertama bekerja dengan tampilan tingkat yang lebih tinggi, yang kedua lebih dekat ke mesin dan tampilan perantara akan terlihat seperti aliran instruksi.  Beberapa versi Go telah menggunakan representasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSA</a> untuk optimisasi di bagian backend dari kompiler. </p><br><p>  Lipat konstan, seperti <code>{10*2 =&gt; 20}</code> , diterapkan di backend.  Secara umum, sebagian besar operasi yang terkait dengan penurunan biaya komputasi ekspresi terletak di bagian kompiler ini.  Namun ada beberapa pengecualian. </p><br><p>  Satu pengecualian adalah optimalisasi perbandingan string konstan.  Ketika kompiler melihat perbandingan string (atau substring) di mana satu atau kedua operan adalah konstanta, kode yang lebih efisien dihasilkan daripada panggilan ke <code>runtime.memequal</code> . </p><br><p>  Anda dapat melihat kode sumber yang bertanggung jawab untuk ini di file <a href="">cmd / compile / internal / gc / walk.go: 3362</a> . </p><br><p>  Penyisipan fungsi terjadi sebelum optimasi ini diluncurkan, tetapi juga di bagian frontend dari kompiler. </p><br><p>  Tampaknya semua sama tidak memungkinkan pengoptimalan ini berfungsi dalam kasus kami? </p><br><h1 id="kak-go-vstraivaet-vyzovy-funkciy">  How Go Embeds Function Memanggil </h1><br><p>  Begini cara penyematan akan terjadi: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    : return strings.HasPrefix(s, "#") //  : func HasPrefix(s, prefix string) bool //    : _s, _prefix := s, "#" return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix</span></span></code> </pre> <br><p>  Ketika menyematkan fungsi, kompiler memberikan argumen ke variabel sementara, yang memecah optimasi, karena algoritma di <a href="">walk.go</a> tidak melihat konstanta, tetapi argumen dengan variabel.  Itu masalahnya. </p><br><p>  Omong-omong, ini tidak mengganggu optimasi backend yang dimiliki SSA.  Tetapi ada masalah lain di sana, misalnya, ketidakmampuan untuk mengembalikan konstruksi bahasa tingkat tinggi untuk perbandingan efektif mereka (pekerjaan untuk menghilangkan kelemahan ini telah "direncanakan" selama beberapa tahun). </p><br><h1 id="eschyo-odin-primer-escape-analysis">  Contoh lain: analisis pelarian </h1><br><p>  Bayangkan sebuah fungsi yang penting untuk mengalokasikan buffer sementara pada stack: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">// buf    //    . return nil }</span></span></code> </pre> <br><p>  Karena <code>buf</code> tidak "lari", kompiler akan dapat mengalokasikan 16 byte ini di stack, tanpa alokasi di heap.  Sekali lagi, semua berkat nilai konstan saat menelepon <code>make</code> .  Untuk mengalokasikan memori pada stack, penting bagi kita untuk mengetahui ukuran yang diperlukan, yang akan menjadi bagian dari frame yang dialokasikan untuk pemanggilan fungsi. </p><br><p>  Misalkan di masa depan kami ingin mengalokasikan buffer sementara dari berbagai ukuran dan merangkum beberapa logika dalam metode.  Kami memperkenalkan abstraksi baru dan memutuskan untuk menggunakan tipe <code>tmpBuf</code> baru di <code>tmpBuf</code> .  Fungsi desainnya sangat sederhana: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTmpBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeHint </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmpBuf</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmpBuf{buf: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeHint)} }</code> </pre> <br><p>  Mengadaptasi contoh asli: </p><br><pre> <code class="diff hljs">func businessLogic() error { - buf := make([]byte, 0, 16) + buf := newTmpBuf(16) // buf    //    . return nil }</code> </pre> <br><p>  Konstruktor akan disematkan, tetapi alokasi sekarang akan selalu berada di heap, karena alasan yang sama bahwa argumen dilewatkan melalui variabel sementara.  Analisis melarikan diri akan melihat <code>make([]byte, 0, _sizeHint)</code> yang tidak termasuk dalam pola pengenalannya untuk <code>make</code> panggilan yang dioptimalkan. </p><br><p>  Jika kita memiliki "semuanya seperti manusia", masalahnya tidak akan ada, setelah menanamkan konstruktor <code>newTmpBuf</code> akan jelas bahwa ukurannya masih diketahui pada tahap kompilasi. </p><br><p>  Ini mengganggu hampir lebih dari situasi dengan membandingkan string. </p><br><h1 id="gorizonty-go-113">  Horizons Go 1.13 </h1><br><p>  Situasinya dapat dengan mudah diperbaiki dan saya sudah mengirim bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama dari keputusan</a> . </p><br><img src="https://habrastorage.org/webt/uv/gv/16/uvgv16e70jy6qdip9wju_vqzvog.png" alt="gambar" align="left"><br><p>  Jika Anda berpikir bahwa masalah yang dijelaskan dalam artikel tersebut benar-benar membutuhkan solusi, harap acungkan jempol dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah yang terkait</a> . </p><br><p></p><hr><br><br><p>  Posisi saya adalah bahwa menanamkan kode dengan tangan Anda hanya karena itu bekerja lebih cepat di versi Go saat ini salah.  Penting untuk memperbaiki cacat ini di pengoptimal, setidaknya ke titik di mana contoh yang dijelaskan di atas berfungsi tanpa regresi kinerja yang tidak terduga. </p><br><p>  Jika semuanya berjalan sesuai rencana, optimasi ini akan disertakan dalam rilis Go 1.13. </p><br><p>  Terima kasih atas perhatian anda </p><br><h1 id="dopolnenie-predlozhennoe-reshenie">  Tambahan: solusi yang diusulkan </h1><br><p>  Bagian ini untuk yang paling berani, mereka yang tidak bosan membaca. </p><br><p>  Jadi, kami memiliki beberapa tempat yang bekerja lebih buruk ketika menggunakan variabel alih-alih nilainya secara langsung.  Solusi yang diusulkan adalah untuk memperkenalkan fungsi baru di frontend bagian compiler, yang memungkinkan Anda untuk mendapatkan nilai terikat terakhir dengan nama.  Setelah itu, dalam setiap optimisasi yang mengharapkan nilai konstan, jangan menyerah ketika suatu variabel terdeteksi, tetapi terima status yang disimpan sebelumnya ini. </p><br><p>  Tanda tangan fitur baru kami mungkin terlihat seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre> <br><p>  Definisi <code>Node</code> dapat ditemukan di file <a href="">syntax.go</a> . </p><br><p>  Setiap definisi variabel memiliki tag <code>Node</code> dengan tag <code>ONAME</code> .  Di dalam <code>Node.Name.Defn</code> sebagian besar variabel ini memiliki nilai inisialisasi. </p><br><p>  Jika <code>Node</code> sudah menjadi literal, Anda tidak perlu melakukan apa pun dan kami hanya mengembalikan <code>n</code> .  Jika ini <code>ONAME</code> (variabel), maka Anda dapat mencoba mengekstrak nilai inisialisasi yang sama dari <code>n.Name.Defn</code> . </p><br><p>  Tapi bagaimana dengan modifikasi antara mendeklarasikan dan membaca variabel yang kita sebut <code>getConstValue</code> ?  Jika kita membatasi diri hanya untuk variabel read-only, maka tidak ada masalah.  Frontend Go telah memiliki tanda simpul khusus yang menandai nama yang mirip.  Jika variabel telah dimodifikasi, <code>getConstValue</code> tidak akan mengembalikan nilai inisialisasi. </p><br><p>  Programmer, sebagai suatu peraturan, tidak memodifikasi argumen input tipe numerik dan string, dan ini memungkinkan untuk mencakup sejumlah besar kasus dengan algoritma primitif ini. </p><br><p>  Sekarang kami siap mempertimbangkan implementasinya: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ONAME    definition. if n.Op != ONAME || n.Name.Defn == nil { return n } //   ,     . // ,    ,     //      escape analysis' . maybeModified := n.Assigned() || n.Name.Defn.Assigned() || n.Addrtaken() if maybeModified { return n } // OAS - Node  . // n.Name.Defn.Left -  LHS. // n.Name.Defn.Right -  RHS. // consttype(v)     . //   CTxxx,      . if n.Name.Defn.Op == OAS { v := n.Name.Defn.Right if v != nil &amp;&amp; consttype(v) != CTxxx { return v } } return n }</span></span></code> </pre> <br><p>  Berikut cara perubahan kode, yang bergantung pada konstanta: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- i := indexconst(r) + i := indexconst(getConstValue(r))</span></span></code> </pre> <br><p>  Hebat, dan bahkan berfungsi: </p><br><pre> <code class="go hljs">n := <span class="hljs-number"><span class="hljs-number">10</span></span> xs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, n) <span class="hljs-comment"><span class="hljs-comment">//     !</span></span></code> </pre> <br><p>  Sebelum perubahan ini, analisis pelarian tidak bisa mendapatkan nilai <code>10</code> hingga <code>n</code> , itulah sebabnya saya membuat asumsi tentang perlunya menempatkan <code>xs</code> di heap. </p><br><p>  Kode di atas secara sintaksis mirip dengan situasi yang diamati selama penyematan.  <code>n</code> mungkin variabel sementara yang ditambahkan ketika argumen dilewatkan. </p><br><p>  Sayangnya, ada nuansa. </p><br><p>  Kami memecahkan masalah untuk variabel lokal yang diperkenalkan melalui <a href="">OAS</a> , tetapi Go menginisialisasi variabel untuk fungsi <a href="">bawaan</a> melalui <a href="">OAS2</a> .  Karena itu, kita perlu perubahan kedua yang memperluas fungsi <code>getConstValue</code> dan sedikit memodifikasi kode inliner itu sendiri, karena, di antara hal-hal lain, <code>OAS2</code> tidak memiliki bidang <code>OAS2</code> yang sesuai. </p><br><p>  Itu berita buruk.  Berita bagus: Saluran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">#gocontributing</a> muncul di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slack berbahasa Rusia</a> , tempat Anda dapat berbagi ide dan rencana, mengajukan pertanyaan, dan mendiskusikan segala sesuatu yang berkaitan dengan berpartisipasi dalam pengembangan Go. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438636/">https://habr.com/ru/post/id438636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438626/index.html">Intisari materi menarik untuk pengembang seluler # 284 (28 Januari - 3 Februari)</a></li>
<li><a href="../id438628/index.html">SharedState Component Change Status Notification</a></li>
<li><a href="../id438630/index.html">Google+ Sic transit gloria mundi ...</a></li>
<li><a href="../id438632/index.html">Hardcore 2D RPG Gamedev Diaries, vol.0 - INTRO, atau "How I Got Here"</a></li>
<li><a href="../id438634/index.html">Di kantor, terlalu panas atau terlalu dingin: apakah ada cara yang lebih baik untuk menyesuaikan suhu?</a></li>
<li><a href="../id438638/index.html">Kami menganalisis protokol pesan pager POCSAG, bagian 2</a></li>
<li><a href="../id438640/index.html">Mata uang elektronik terbuka berkecepatan tinggi</a></li>
<li><a href="../id438642/index.html">Dasar-dasar pemrograman reaktif menggunakan RxJS</a></li>
<li><a href="../id438644/index.html">Keamanan algoritma pembelajaran mesin. Melindungi dan Menguji Model Menggunakan Python</a></li>
<li><a href="../id438646/index.html">Tentang membuat gambar stereo anggaran dengan jari (stereogram, anaglyph, stereoscope)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>