<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèõÔ∏è üèõÔ∏è üë®‚Äçüç≥ Memonitor Aplikasi .NET üëÅÔ∏è üëá üî†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET adalah runtime yang dikelola . Ini berarti bahwa itu berisi fungsi tingkat tinggi yang mengontrol program Anda untuk Anda (dari Pendahuluan hingg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memonitor Aplikasi .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/466097/"><p>  .NET adalah <em>runtime yang dikelola</em> .  Ini berarti bahwa itu berisi fungsi tingkat tinggi yang mengontrol program Anda untuk Anda (dari <a href="">Pendahuluan hingga Common Language Runtime (CLR), 2007</a> ): </p><br><blockquote>  Runtime menyediakan banyak fungsi, jadi mudah untuk membaginya ke dalam kategori berikut: <br><br><ol><li>  <b>Fungsi utama</b> yang memengaruhi perangkat orang lain.  Ini termasuk: <ol><li>  pengumpulan sampah; </li><li>  mengamankan akses memori dan mengetikkan keamanan sistem; </li><li>  dukungan tingkat tinggi untuk bahasa pemrograman. </li></ol></li><li>  <b>Fungsi tambahan</b> - bekerja berdasarkan yang utama.  Banyak program bermanfaat yang melakukannya tanpa mereka.  Fungsi-fungsi ini meliputi: <ol><li>  Mengisolasi aplikasi menggunakan AppDomains </li><li>  perlindungan aplikasi dan isolasi kotak pasir. </li></ol></li><li>  <b>Fungsi lain</b> dibutuhkan oleh semua runtime, tetapi mereka tidak menggunakan fungsi CLR dasar.  Fitur-fitur tersebut mencerminkan keinginan untuk menciptakan lingkungan pemrograman yang lengkap.  Ini termasuk: <br><ol><li>  kontrol versi; </li><li>  debugging / profil; </li><li>  memastikan interaksi. </li></ol></li></ol></blockquote><p>  Dapat dilihat bahwa meskipun debugging dan profiling bukan fungsi utama atau tambahan, mereka ada dalam daftar karena ' <em>keinginan untuk menciptakan lingkungan pemrograman yang lengkap</em> '. </p><br><p><img src="https://habrastorage.org/webt/mh/eq/nn/mheqnnqmnlkhoroovhqseskeyba.jpeg"></p><a name="habracut"></a><br><p>  <strong>Sisa postingan ini menjelaskan fitur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemantauan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengamatan,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">introspeksi apa yang</a> ada dalam Core CLR, mengapa mereka berguna, dan bagaimana lingkungan menyediakannya.</strong> </p><br><h2 id="diagnostika">  Diagnostik </h2><br><p>  Pertama, lihat informasi diagnostik yang diberikan CLR kepada kami.  Secara tradisional, Pelacakan Peristiwa untuk Windows (ETW) telah digunakan untuk ini. <br>  Ada banyak peristiwa dimana CLR memberikan informasi.  Mereka terkait dengan: </p><br><ul><li>  pengumpulan sampah (GC); </li><li>  Kompilasi JIT; </li><li>  modul dan domain aplikasi; </li><li>  bekerja dengan utas dan konflik saat memblokir; </li><li>  serta banyak lainnya. </li></ul><br><p>  Misalnya, di sini suatu <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">peristiwa</a> terjadi <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">selama pemuatan di AppDomain</a> , di sini <a href="">acara tersebut dikaitkan dengan melempar pengecualian</a> , dan di sini dengan <a href="">siklus alokasi memori oleh pengumpul sampah</a> . </p><br><h3 id="perf-view">  Tampilan perf </h3><br><p> Jika Anda ingin melihat peristiwa dalam sistem jejak (ETW) yang terkait dengan aplikasi .NET Anda, saya sarankan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat PerfView yang</a> sangat baik dan mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video pelatihan</a> ini atau presentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PerfView: Alat Kinerja .NET Ultimate ini</a> .  PerfView telah dikenal luas karena menyediakan informasi yang tak ternilai.  Sebagai contoh, insinyur Microsoft secara teratur menggunakannya untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menganalisis kinerja</a> . </p><br><h3 id="obschaya-infrastruktura">  Infrastruktur umum </h3><br><p>  Jika tiba-tiba namanya tidak jelas, pelacakan acara di ETW hanya tersedia di bawah Windows, yang tidak cocok dengan dunia lintas-platform .NET Core.  Anda dapat menggunakan <a href="">PerfView untuk menganalisis kinerja di Linux</a> (menggunakan LTTng).  Namun, alat baris perintah ini, yang disebut PerfCollect, hanya mengumpulkan data.  Kemampuan analisis dan antarmuka pengguna yang kaya (termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flamegraphs</a> ) saat ini hanya tersedia dalam solusi Windows. </p><br><p>  Tetapi jika Anda masih ingin menganalisis kinerja .NET di Linux, ada beberapa pendekatan lain: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mendapatkan Tumpukan untuk Acara LTTng dengan .NET Core di Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah kinerja Linux</a> </li></ul><br><p>  Tautan kedua di atas mengarah ke diskusi tentang <strong>infrastruktur EventPipe</strong> baru, yang sedang dikerjakan di .NET Core (di samping EventSources &amp; EventListeners).  Tujuan pengembangannya dapat ditemukan dalam dokumen <a href="">Desain Pemantauan Kinerja Cross-Platform</a> .  Pada tingkat tinggi, infrastruktur ini akan menciptakan satu tempat di mana CLR akan mengirim acara yang berkaitan dengan diagnostik dan kinerja.  Kemudian acara-acara ini akan dialihkan ke satu atau lebih penebang, yang, misalnya, dapat mencakup ETW, LTTng dan BPF.  Logger yang diperlukan akan ditentukan tergantung pada OS atau platform di mana CLR berjalan.  Untuk penjelasan rinci tentang pro dan kontra dari berbagai teknologi logging, lihat <a href="">.NET Cross-Plat Performance dan Eventing Design</a> . </p><br><p>  Kemajuan EventPipes dipantau melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek Pemantauan Kinerja</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah 'EventPipe'</a> terkait. </p><br><h3 id="plany-na-buduschee">  Rencana masa depan </h3><br><p>  Akhirnya, ada rencana untuk membuat <a href="">Pengontrol Profil Kinerja</a> , yang memiliki tugas-tugas berikut: </p><br><p>  Pengontrol harus mengelola infrastruktur profil dan menyajikan data kinerja yang dihasilkan oleh .NET komponen yang bertanggung jawab untuk diagnostik kinerja secara sederhana dan lintas platform. </p><br><p>  Menurut rencana, pengontrol harus menyediakan <a href="">fungsionalitas berikut melalui server HTTP</a> , menerima semua data yang diperlukan dari infrastruktur EventPipes: </p><br><p>  <strong>API REST</strong> </p><br><ul><li>  Prinsip 1: profil sederhana: profil runtime selama periode waktu X dan kembalikan jejaknya. </li><li>  Prinsip 1: profil lanjutan: mulai pelacakan (bersama dengan konfigurasi) </li><li>  Prinsip 1: profil lanjutan: pelacakan lengkap (jawaban untuk panggilan ini akan menjadi jejaknya sendiri). </li><li>  Prinsip 2: Dapatkan statistik yang terkait dengan semua EventCounters atau EventCounter tertentu. </li></ul><br><p>  <strong>Halaman HTML yang Dapat Ditelusuri</strong> </p><br><ul><li>  Prinsip 1: Representasi tekstual dari semua tumpukan kode yang dikelola dalam suatu proses. <br><ul><li>  Membuat snapshot dari proses yang berjalan untuk digunakan sebagai laporan diagnostik sederhana. </li></ul></li><li>  Prinsip 2: menampilkan keadaan saat ini (mungkin dengan riwayat) penghitung EventCounters. <br><ul><li>  Memberikan ikhtisar tentang penghitung yang ada dan nilainya. </li><li>  MASALAH YANG TAK TERLIBAT: Saya tidak berpikir ada API publik yang diperlukan untuk menghitung EventCounters. </li></ul></li></ul><br><p>  Saya benar-benar ingin melihat apa yang terjadi dengan pengontrol profil kinerja (PPC?).  Saya pikir jika itu dibangun ke dalam CLR, itu akan membawa banyak manfaat untuk .NET.  Fungsionalitas tersebut ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di runtimes lain</a> . </p><br><h2 id="profilirovanie">  Pembuatan profil </h2><br><p>  Alat efektif lain yang dimiliki CLR adalah API profiling.  Ini (terutama) digunakan oleh alat pihak ketiga untuk terhubung ke runtime di tingkat rendah.  Anda dapat mempelajari lebih lanjut tentang API <a href="">dari ulasan ini</a> , tetapi pada tingkat tinggi, Anda dapat menggunakannya untuk membuat panggilan balik yang diaktifkan jika: </p><br><ul><li>  acara yang berkaitan dengan pemulung; </li><li>  pengecualian dilemparkan; </li><li>  majelis dimuat / dibongkar; </li><li>  <a href="">dan masih banyak lagi</a> . </li></ul><br><p>  <em>Gambar dari <a href="">Halaman API Profiling BOTR - Tinjauan Umum</a></em> </p><br><p>  Selain itu, ia memiliki fitur-fitur efektif lainnya.  Pertama, Anda dapat mengatur penangan yang dipanggil setiap kali metode .NET dijalankan, baik di lingkungan itu sendiri atau dari kode pengguna.  Callback ini dikenal sebagai Enter / Leave handler.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh yang bagus tentang</a> bagaimana menggunakannya.  Namun, untuk ini, Anda perlu memahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konvensi pemanggilan untuk arsitektur OS dan CPU yang berbeda</a> , yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak selalu mudah</a> .  Juga, ingat bahwa API profil adalah komponen COM yang hanya dapat diakses dari kode C / C ++, tetapi bukan dari C # / F # / VB.NET. </p><br><p>  Kedua, profiler dapat menulis ulang kode IL dari setiap metode .NET sebelum kompilasi JIT menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API SetILFunctionBody ()</a> .  API ini sangat efisien.  Ini mendasari banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat APM .NET</a> .  Anda dapat mempelajari lebih lanjut tentang penggunaannya dari posting saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara mengejek kelas yang disegel dan metode statis</a> dan kode terkait. </p><br><h3 id="icorprofiler-api">  API ICorProfiler </h3><br><p>  Ternyata API pembuatan profil berhasil, harus ada segala macam trik di lingkungan runtime.  Lihat saja diskusi pada halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Izinkan izin pada lampiran</a> (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReJIT: Panduan Cara Untuk</a> informasi lebih lanjut tentang ReJIT). </p><br><p> Definisi lengkap semua profil API dan panggilan balik profil dapat ditemukan di <a href="">\ vm \ inc \ corprof.idl</a> (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahasa deskripsi antarmuka</a> ).  Ini dibagi menjadi 2 bagian logis.  Satu bagian adalah <strong>profiler -&gt;</strong> antarmuka <strong>Runtime Environment (EE)</strong> , yang dikenal sebagai <code>ICorProfilerInfo</code> : </p><br><pre> <code class="plaintext hljs">//  ,    ICorProfilerInfo*,  //     .  ,  DLL   //          ,     //    .</code> </pre> <br><p>  Ini diimplementasikan dalam file-file berikut: </p><br><ul><li>  <a href="">\ vm \ proftoeeinterfaceimpl.h</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.inl</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.cpp</a> </li></ul><br><p>  Bagian utama lainnya adalah callback Runtime -&gt; Profiler, yang dikelompokkan di bawah antarmuka <code>ICorProfilerCallback</code> : </p><br><pre> <code class="plaintext hljs">//       //  ICorProfilerCallaback* .       // ,     EEToProfInterfaceImpl.</code> </pre> <br><p>  Callback ini diimplementasikan dalam file-file berikut: </p><br><ul><li>  <a href="">vm \ eetoprofinterfaceimpl.h</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.inl</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.cpp</a> </li><li>  <a href="">vm \ eetoprofinterfacewrapper.inl</a> </li></ul><br><p>  Akhirnya, perlu dicatat bahwa profil API tidak dapat berfungsi pada semua OS dan arsitektur yang menjalankan .NET Core.  Berikut ini salah satu contohnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah rintisan panggilan ELT di Linux</a> .  Lihat <a href="">Status API Profiler CoreCLR</a> untuk informasi lebih lanjut. </p><br><h3 id="profiling-v-debugging">  Pembuatan profil v.  Debugging </h3><br><p>  Sebagai penyimpangan kecil, saya harus mengatakan bahwa profil dan debugging masih tumpang tindih sedikit.  Oleh karena itu, penting untuk memahami apa yang disediakan oleh API berbeda dalam konteks .NET Runtime (diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CLR Debugging vs. CLR Profiling</a> ). </p><br><p>  <strong>Perbedaan antara debugging dan profil di CLR</strong> </p><br><div class="scrollable-table"><table><thead><tr><th>  Debugging </th><th>  Pembuatan profil </th></tr></thead><tbody><tr><td>  Dirancang untuk menemukan masalah dengan kebenaran kode. </td><td>  Dirancang untuk mendiagnosis dan memecahkan masalah kinerja. </td></tr><tr><td>  Mungkin memiliki tingkat gangguan yang sangat tinggi. </td><td>  Umumnya memiliki tingkat intervensi yang rendah.  Meskipun profiler mendukung memodifikasi kode IL atau menginstal enter / leave handler, semua ini untuk instrumentasi, bukan untuk perubahan kode radikal. </td></tr><tr><td>  Tugas utama adalah kontrol penuh terhadap target.  Ini termasuk inspeksi, kontrol pelaksanaan (misalnya, perintah set-next-statement), dan modifikasi (fungsi Edit-and-Continue). </td><td>  Tugas utama adalah inspeksi target.  Untuk melakukan ini, instrumentasi disediakan (mengubah kode IL, menginstal enter / meninggalkan penangan) </td></tr><tr><td>  API yang luas dan model objek tebal yang diisi dengan abstraksi. </td><td>  API kecil.  Ada beberapa atau tidak ada abstraksi. </td></tr><tr><td>  Tingkat interaktivitas tinggi: tindakan debugger dikendalikan oleh pengguna (atau algoritma).  Faktanya, editor dan debugger sering terintegrasi (IDE). </td><td>  Tidak ada interaktivitas: data biasanya dikumpulkan tanpa intervensi pengguna dan kemudian dianalisis. </td></tr><tr><td>  Sejumlah kecil perubahan kritis jika kompatibilitas diperlukan.  Kami berpikir bahwa bermigrasi dari versi 1.1 ke versi 2.0 dari profiler akan menjadi tugas yang sederhana atau tidak terlalu sulit. </td><td>  Sejumlah besar perubahan kritis jika kompatibilitas diperlukan.  Kami berpikir bahwa bermigrasi dari versi 1.1 ke versi 2.0 dari profiler akan menjadi tugas yang sulit, identik dengan menulis ulang sepenuhnya. </td></tr></tbody></table></div><br><h2 id="otladka">  Debugging </h2><br><p>  Pengembang berbeda memahami apa itu debugging.  Sebagai contoh, saya bertanya di Twitter ‚Äúbagaimana Anda men-debug program .NET‚Äù dan mendapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban berbeda</a> .  Pada saat yang sama, jawabannya memang berisi daftar alat dan metode yang bagus, jadi saya sarankan untuk melihatnya.  Terima kasih #LazyWeb </p><br><p>  Saya pikir yang terbaik dari semua esensi dari debugging mencerminkan pesan ini: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="399339918213652480"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  CLR menyediakan daftar lengkap fitur-fitur terkait debugging.  Namun, mengapa dana ini dibutuhkan?  Setidaknya ada tiga alasan yang disebutkan dalam postingan hebat ini. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa debugging yang dikelola berbeda dengan debugging asli?</a>  : </p><br><ol><li>  Debugging kode yang tidak dikelola dapat diabstraksi pada level perangkat keras, tetapi debugging kode yang dikelola harus diabstraksikan pada level IL-code. </li><li>  Kode terkelola debugging membutuhkan banyak informasi yang tidak tersedia sebelum eksekusi. </li><li>  Debugger kode yang dikelola harus berkoordinasi dengan pengumpul sampah (GC) </li></ol><br><p>  Oleh karena itu, untuk kemudahan penggunaan, CLR harus menyediakan API debugging tingkat tinggi yang dikenal sebagai <code>ICorDebug</code> .  Itu ditunjukkan pada gambar di bawah ini yang menunjukkan skenario debugging umum (sumber: BOTR): </p><br><h3 id="icordebug-api">  API ICorDebug </h3><br><p>  Prinsip implementasi dan deskripsi berbagai komponen diambil dari <a href="">CLR Debugging, sebuah pengantar singkat</a> : </p><br><blockquote>  Semua dukungan debugging di .Net diimplementasikan di atas perpustakaan dll, yang kita sebut The Dac.  File ini (biasanya disebut <code>mscordacwks.dll</code> ) adalah elemen struktural untuk API debugging publik kami ( <code>ICorDebug</code> ) dan dua API debugging pribadi: SOS-Dac API dan IXCLR. <br>  Di dunia yang ideal, semua orang akan menggunakan <code>ICorDebug</code> , API publik kami.  Namun, <code>ICorDebug</code> tidak memiliki banyak fitur yang dibutuhkan pengembang alat.  Ini adalah masalah yang kami coba perbaiki di mana kami bisa.  Namun, peningkatan ini hanya ada di CL.v.next, tetapi tidak di versi CLR sebelumnya.  Bahkan, dukungan debug dump dump muncul di API <code>ICorDebug</code> hanya dengan rilis CLR v4.  Setiap orang yang menggunakan crash dumps untuk debugging di CLR v2 tidak akan dapat menerapkan <code>ICorDebug</code> sama sekali. </blockquote><p>  <em>(Lihat SOS &amp; ICorDebug untuk informasi lebih lanjut)</em> </p><br><p>  Faktanya, API <code>ICorDebug</code> dibagi menjadi lebih dari 70 antarmuka.  Saya tidak akan memberikan semuanya, tetapi saya akan menunjukkan berdasarkan kategori apa mereka dapat dibagi.  Untuk informasi lebih lanjut, lihat Partisi ICorDebug, di mana daftar ini telah diterbitkan. </p><br><ul><li>  <strong>Tingkat atas</strong> : ICorDebug + ICorDebug2 - antarmuka tingkat atas yang berfungsi sempurna sebagai kumpulan objek ICorDebugProcess. </li><li>  <strong>Callback</strong> : Kejadian debugging kode terkelola dikirim melalui metode ke objek callback yang diimplementasikan oleh debugger. </li><li>  <strong>Proses</strong> : Set antarmuka ini mewakili kode kerja dan termasuk API yang terkait dengan peristiwa. </li><li>  <strong>Kode / Jenis Inspeksi</strong> : Sebagian besar bekerja dengan gambar PE statis, tetapi ada metode yang mudah untuk data nyata. </li><li>  <strong>Kontrol pelaksanaan</strong> : Kemampuan untuk memantau kemajuan utas.  Dalam praktiknya, ini berarti kemampuan untuk mengatur breakpoints (F9) dan melangkah melalui kode (entri kode F11, bypass kode F10, kode keluar S + F11).  Fungsi kontrol eksekusi ICorDebug hanya berfungsi dalam kode terkelola. </li><li>  <strong>Utas + tumpukan panggilan</strong> : <strong>tumpukan panggilan</strong> adalah dasar untuk fungsi inspeksi yang diterapkan oleh debugger.  Bekerja dengan tumpukan panggilan dilakukan menggunakan antarmuka berikut.  ICorDebug hanya mendukung debugging kode terkelola dan, karenanya, Anda dapat melacak tumpukan kode terkelola saja. </li><li>  <strong>Pemeriksaan objek</strong> : Pemeriksaan objek adalah bagian dari API yang memungkinkan Anda untuk melihat nilai-nilai variabel dalam kode debug.  Untuk setiap antarmuka, saya memberikan metode MVP, yang menurut saya, harus menjelaskan secara singkat tujuan dari antarmuka ini. </li></ul><br><p>  Seperti halnya profil API, level dukungan API debugging bervariasi menurut OS dan arsitektur prosesor.  Misalnya, pada Agustus 2018, masih belum ada solusi ARM Linux untuk mendiagnosis dan men-debug kode yang dikelola.  Untuk informasi lebih lanjut tentang dukungan Linux, lihat Debugging .NET Core di Linux dengan LLDB dan repositori Diagnostics dari Microsoft, yang bertujuan untuk mempermudah debugging program .NET di Linux. </p><br><p>  Terakhir, jika Anda ingin melihat bagaimana <code>ICorDebug</code> API terlihat di C #, lihat pembungkus di perpustakaan CLRMD, termasuk semua panggilan balik yang tersedia (lebih banyak tentang CLRMD akan dibahas nanti dalam posting ini). </p><br><h3 id="sos-i-dac">  SOS dan DAC </h3><br><p>  Komponen Akses Data (DAC) dibahas secara rinci di <a href="">halaman BOTR</a> .  Pada dasarnya, ini menyediakan akses keluar-proses ke struktur data CLR sehingga informasi di dalamnya dapat dibaca dari proses lain.  Dengan demikian, debugger (melalui <code>ICorDebug</code> ) atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi 'Son of Strike' (SOS)</a> dapat mengakses instance CLR yang berjalan atau dump memori dan menemukan, misalnya: </p><br><ul><li>  semua utas berjalan; </li><li>  berhasil menumpuk benda </li><li>  informasi lengkap tentang metode ini, termasuk kode mesin; </li><li>  jejak tumpukan saat ini. </li></ul><br><p>  <strong>Penyimpangan kecil</strong> : jika Anda ingin mencari tahu dari mana nama-nama aneh ini berasal dan mendapatkan sedikit pelajaran dalam sejarah .NET, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban ini di Stack Overflow</a> . </p><br><p>  Daftar lengkap perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SOS</a> sangat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengesankan</a> .  Jika Anda menggunakannya bersama dengan WinDBG, Anda dapat mengetahui apa yang terjadi di dalam program Anda dan CLR pada tingkat yang sangat rendah.  Untuk melihat bagaimana semuanya diimplementasikan, mari kita lihat <code>!HeapStat</code> , yang menampilkan deskripsi ukuran berbagai tumpukan yang digunakan. NET GC: </p><br><p>  (Gambar diambil dari SOS: Rilis yang akan datang memiliki beberapa perintah baru - HeapStat) </p><br><p>  Berikut ini adalah aliran kode yang menunjukkan bagaimana SOS dan DAC bekerja bersama: </p><br><ul><li>  Tim <strong>SOS</strong> Lengkap <code>!HeapStat</code> ( <a href="">tautan</a> ) </li><li>  Kode <strong>SOS</strong> di perintah <code>!HeapStat</code> yang berfungsi dengan Workstation GC (tautan) </li><li>  <strong>SOS</strong> Function <code>GCHeapUsageStats(..)</code> , yang melakukan bagian pekerjaan yang paling sulit ( <a href="">tautan</a> ) </li><li>  <strong>Shared</strong> <code>DacpGcHeapDetails</code> data yang berisi pointer ke data utama di heap GC, seperti segmen, bit mask, dan generasi individu ( <a href="">referensi</a> ). </li><li>  Fungsi <strong>DAC</strong> <code>GetGCHeapStaticData</code> yang mengisi struktur <code>DacpGcHeapDetails</code> ( <a href="">tautan</a> ) </li><li>  <code>DacpHeapSegmentData</code> data <code>DacpHeapSegmentData</code> <strong>bersama</strong> yang berisi informasi tentang segmen heap GC individu ( <a href="">tautan</a> ) </li><li>  <strong>DAC</strong> <code>GetHeapSegmentData(..)</code> , yang mengisi struktur <code>DacpHeapSegmentData</code> ( <a href="">tautan</a> ) </li></ul><br><h3 id="storonnie-otladchiki">  Debuggers pihak ketiga </h3><br><p>  Sejak Microsoft menerbitkan API debugging, pengembang pihak ketiga dapat menggunakan antarmuka <code>ICorDebug</code> .  Berikut adalah daftar yang berhasil saya temukan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Samsung</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Debugger untuk .NET Core runtime</a> <br><ul><li>  Debugger memungkinkan Anda untuk menggunakan antarmuka adaptor debugging GDB / MI atau VSCode untuk memperbaiki kesalahan dalam aplikasi .NET dari bawah runtime .NET Core. </li><li>  <em>Mungkin</em> ditulis sebagai bagian dari proyek ke port <a href="">.NET Core ke OS Tizen mereka</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dnSpy</a> - .NET debugger dan editor perakitan <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alat yang sangat kuat</a> .  Ini adalah debugger, editor perakitan, hex editor, dekompiler, dan banyak lagi. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDbg.exe (.NET Framework Command-Line Debugger)</a> <br><ul><li>  Tersedia sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket NuGet</a> .  Itu juga dapat diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori GitHub</a> atau situs web Microsoft. </li><li>  Namun, saat ini, MDBG tampaknya tidak mendukung .NET Core.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Port MDBG ke CoreCLR</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ETA untuk porting mdbg ke coreclr untuk informasi lebih lanjut</a> . </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">'Rider' JetBrains</a> memungkinkan Anda untuk men-debug .NET Core pada Windows. <br><ul><li>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa masalah</a> lisensi dengan alat ini. </li><li>  Informasi lebih lanjut dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas HackerNews ini.</a> </li></ul></li></ul><br><h3 id="dampy-pamyati">  Kesedihan memori </h3><br><p>  Hal terakhir yang akan kita bicarakan adalah dump memori, yang dapat diperoleh dari sistem kerja dan dianalisis di luarnya.  NET runtime selalu mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dumping memori di Windows</a> .  Dan sekarang. NET Core telah menjadi lintas-platform, alat telah muncul yang melakukan tugas yang sama pada OS lain. </p><br><p>  Saat menggunakan dump memori, kadang-kadang sulit untuk mendapatkan versi yang benar, yang cocok dengan file SOS dan DAC.  Untungnya, Microsoft baru-baru ini merilis alat CLI <code>dotnet symbol</code> , yang: </p><br><blockquote>  dapat mengunduh semua file yang diperlukan untuk debugging (set karakter, modul, file SOS dan DAC untuk modul coreclr tertentu) untuk setiap dump inti spesifik, minidump atau file platform apa pun yang didukung, termasuk ELF, MachO, Windows DLL, PDB, dan portable PDB </blockquote><p>  Akhirnya, jika Anda melakukan sedikit analisis dump memori, saya sarankan melihat perpustakaan MD CLR yang sangat baik yang dirilis Microsoft beberapa tahun lalu.  Saya sudah menulis tentang fungsinya.  Singkatnya, menggunakan perpustakaan, Anda dapat bekerja dengan dump memori melalui C # API yang mengandung kelas intuitif yang menyediakan akses ke ClrHeap, GC Roots, CLR Threads, Stack Frames dan banyak lagi.  Faktanya, CLR MD dapat mengimplementasikan sebagian besar (jika tidak semua) perintah SOS. </p><br><p>  Anda dapat mengetahui cara kerjanya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos</a> ini: </p><br><blockquote>  ClrMD Managed Library adalah pembungkus seputar debugging API yang ditujukan untuk penggunaan internal hanya di CLR.  Terlepas dari kenyataan bahwa API ini sangat efektif untuk diagnostik, kami tidak mendukung mereka dalam bentuk rilis publik, terdokumentasi, karena penggunaannya kompleks dan terkait erat dengan fitur lain dari implementasi CLR.  ClrMD memecahkan masalah ini dengan menyediakan pembungkus yang mudah digunakan dan dikelola di sekitar API debugging tingkat rendah ini. </blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466097/">https://habr.com/ru/post/id466097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466075/index.html">Bagaimana saya meninggalkan ilmu dasar dalam sebuah startup</a></li>
<li><a href="../id466077/index.html">Siaran Hari Techdir di St. Petersburg</a></li>
<li><a href="../id466081/index.html">3 September</a></li>
<li><a href="../id466089/index.html">Algoritma Berpikir dan Kesadaran, Bagian 2</a></li>
<li><a href="../id466093/index.html">Bagaimana cara kerja kubectl exec?</a></li>
<li><a href="../id466099/index.html">Fitur pengujian aplikasi web untuk layanan video</a></li>
<li><a href="../id466103/index.html">Pemantauan keamanan cloud</a></li>
<li><a href="../id466105/index.html">Overclocking Magento Rest API dengan RoadRunner</a></li>
<li><a href="../id466107/index.html">Lakukan sistem Smart Home sendiri</a></li>
<li><a href="../id466109/index.html">Pemecahan masalah dengan pwnable.kr 22 - brainfuck. Serangan ret2libc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>