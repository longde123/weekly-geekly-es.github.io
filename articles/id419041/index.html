<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ« ğŸ•´ï¸ ğŸŒ² Sembilan garu Elasticsearch yang saya injak ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸ¬ ğŸ‘©â€âœˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="â€œSeseorang yang terlatih juga menginjak garu. 
 Tetapi di sisi lain, di mana pulpen itu berada. " 

 Elasticsearch adalah alat yang hebat, tetapi seti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sembilan garu Elasticsearch yang saya injak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/419041/"><img src="https://habrastorage.org/webt/ap/2k/jc/ap2kjcsehhaliahrmgg6a3r27xw.jpeg" alt="Ilustrasi oleh Anton Gudim"><br><br><br>  <i>â€œSeseorang yang terlatih juga menginjak garu.</i> <i><br></i>  <i>Tetapi di sisi lain, di mana pulpen itu berada. "</i> <br><br>  Elasticsearch adalah alat yang hebat, tetapi setiap alat tidak hanya membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyetelan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perawatan</a> , tetapi juga perhatian terhadap detail.  Beberapa tidak signifikan dan terletak di permukaan, sementara yang lain tersembunyi begitu dalam sehingga dibutuhkan lebih dari satu hari untuk mencari, tidak selusin cangkir kopi dan tidak satu kilometer saraf.  Dalam artikel ini saya akan memberi tahu Anda tentang sembilan garu yang indah dalam pengaturan elastis yang saya injak. <br><a name="habracut"></a><br>  Saya akan mengatur penggaruk dalam urutan bukti.  Dari yang dapat diramalkan dan dielakkan pada tahap pengaturan dan memasuki sebuah cluster di negara produksi, hingga yang sangat aneh yang membawa pengalaman paling banyak (dan bintang di mata). <br><br><h2>  Node data harus sama </h2><br>  "Cluster berjalan pada kecepatan simpul data paling lambat" - aksioma yang menyakitkan.  Tetapi ada titik jelas lain yang tidak terkait dengan kinerja: elastis tidak berpikir dalam ruang disk, tetapi dalam pecahan, dan mencoba untuk mendistribusikannya secara merata di antara data node.  Jika beberapa node data memiliki lebih banyak ruang daripada yang lain, maka akan sia-sia untuk diam. <br><br><h2>  Deprecation.log </h2><br>  Mungkin terjadi bahwa seseorang tidak menggunakan cara paling modern untuk mengirim data ke elastis, yang tidak tahu cara mengatur Tipe-Konten saat menjalankan kueri.  Dalam daftar ini, misalnya, heka, atau ketika log meninggalkan perangkat dengan cara bawaannya).  Dalam hal ini, penghinaan.  log mulai tumbuh pada tingkat yang mengkhawatirkan, dan untuk setiap permintaan, baris berikut muncul di dalamnya: <br><br><pre><code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,659</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,670</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,671</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,673</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController</span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [<span class="hljs-string"><span class="hljs-string">Content-Type</span></span>] header. [<span class="hljs-string"><span class="hljs-string">2018-07-07T14:10:26,677</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">WARN </span></span>][<span class="hljs-string"><span class="hljs-string">oedrRestController </span></span>] Content type detection for rest requests is deprecated. Specify the content type using the [Content-Type] header.</code> </pre> <br>  Permintaan datang, rata-rata, setiap 5-10 ms - dan setiap kali baris baru ditambahkan ke log.  Ini secara negatif mempengaruhi kinerja subsistem disk dan meningkatkan iowait.  Deprecation.log dapat dimatikan, tetapi itu tidak terlalu masuk akal.  Untuk mengumpulkan log elastis ke dalamnya, tetapi tidak membuang sampah sembarangan, saya hanya menonaktifkan log dari kelas oedrRestController. <br><br>  Untuk melakukan ini, tambahkan konstruksi berikut ke logs4j2.properties: <br><br><pre> <code class="hljs pgsql">logger.restcontroller.name = org.elasticsearch.deprecation.rest.RestController logger.restcontroller.<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = error</code> </pre><br>  Ini akan menaikkan log kelas ini ke tingkat kesalahan, dan mereka tidak akan lagi jatuh ke dalam deprecation.log. <br><br><h2>  .kibana </h2><br>  Seperti apa proses instalasi kluster?  Kami menempatkan node, menggabungkan mereka ke dalam sebuah cluster, menempatkan x-pack (yang membutuhkannya), dan tentu saja, Kibana.  Kami mulai, memverifikasi bahwa semuanya berfungsi dan Kibana melihat cluster, dan terus mengonfigurasi.  Masalahnya adalah bahwa pada cluster yang baru diinstal, template default terlihat seperti ini: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"order"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"template"</span></span>: <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"settings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_shards"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_replicas"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"aliases"</span></span>: {} }</code> </pre> <br>  Dan indeks .kibana, tempat semua pengaturan disimpan, dibuat dalam satu salinan. <br><br>  Pernah ada kasus ketika, karena kegagalan perangkat keras, salah satu node data di cluster terbunuh.  Dengan cepat mencapai kondisi yang konsisten, meningkatkan replika pecahan dari node data tetangga, tetapi, untungnya, pada node data inilah satu-satunya pecahan dengan indeks .ibibana ditemukan.  Situasinya macet - cluster hidup, dalam kondisi kerja, dan Kibana dalam status merah, dan ponsel saya dihancurkan oleh panggilan karyawan yang sangat membutuhkan log mereka. <br><br>  Semua ini diselesaikan dengan sederhana.  Sejauh ini, tidak ada yang jatuh: <br><br><pre> <code class="hljs objectivec">XPUT .kibana/_settings { <span class="hljs-string"><span class="hljs-string">"index"</span></span>: { <span class="hljs-string"><span class="hljs-string">"number_of_replicas"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;__&gt;"</span></span> } }</code> </pre> <br><h2>  XMX / XMS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi</a> mengatakan "Tidak lebih dari 32 GB," dan memang demikian.  Tetapi juga benar bahwa Anda tidak perlu menginstal di pengaturan layanan <br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Xms32g</span></span> <span class="hljs-literal"><span class="hljs-literal">-Xmx32g</span></span></code> </pre> <br>  Karena sudah lebih dari 32 gigabytes, dan di sini kita melihat nuansa Java yang menarik dengan memori.  Di atas batas tertentu, Java berhenti menggunakan pointer terkompresi dan mulai mengkonsumsi banyak memori.  Memeriksa apakah pointer terkompresi menggunakan mesin Java yang menjalankan Elasticsearch sangat sederhana.  Kami melihat di log layanan: <br><br><pre> <code class="hljs powershell">[<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">07</span></span>-<span class="hljs-number"><span class="hljs-number">29</span></span><span class="hljs-type"><span class="hljs-type">T15</span></span>:<span class="hljs-number"><span class="hljs-number">04</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>,<span class="hljs-number"><span class="hljs-number">041</span></span>][<span class="hljs-type"><span class="hljs-type">INFO</span></span>][<span class="hljs-type"><span class="hljs-type">oeeNodeEnvironment</span></span>][<span class="hljs-type"><span class="hljs-type">log</span></span>-<span class="hljs-type"><span class="hljs-type">elastic</span></span>-<span class="hljs-type"><span class="hljs-type">hot3</span></span>] heap size [<span class="hljs-number"><span class="hljs-number">31.6</span></span><span class="hljs-type"><span class="hljs-type">gb</span></span>], compressed ordinary object pointers [<span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  Jumlah memori yang tidak boleh terlampaui tergantung, antara lain, pada versi Java yang digunakan.  Untuk menghitung volume tepat dalam kasus Anda, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br>  Sekarang saya telah menginstal pada semua data node elastis: <br><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Xms32766m</span></span> <span class="hljs-literal"><span class="hljs-literal">-Xmx32766m</span></span></code> </pre> <br>  Tampaknya menjadi fakta biasa, dan dokumentasinya dijelaskan dengan baik, tetapi saya secara teratur menemukan instalasi Elasticsearch di mana saya melewatkan poin ini, dan Xms / Xmx diatur ke 32g. <br><br><h2>  / var / lib / elasticsearch </h2><br>  Ini adalah jalur default untuk menyimpan data dalam elasticsearch.  yml: <br><br><pre> <code class="hljs kotlin">path.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/elasticsearch</code> </pre> <br>  Di sana saya biasanya memasang satu array RAID besar, dan inilah sebabnya: kami menetapkan ES beberapa cara untuk menyimpan data, misalnya, seperti ini: <br><br><pre> <code class="hljs kotlin">path.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/elasticsearch/data1, /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/elasticsearch/data2</code> </pre> <br>  Disk atau raid array yang berbeda dipasang di data1 dan data2.  Tetapi elastis tidak seimbang dan tidak mendistribusikan beban antara jalur ini.  Pertama, dia mengisi satu bagian, lalu mulai menulis di bagian lain, sehingga beban pada penyimpanan tidak merata.  Mengetahui hal ini, saya membuat keputusan yang tidak ambigu - saya menggabungkan semua disk di RAID0 / 1 dan memasangnya di path yang ditentukan di path.data. <br><br><h2>  tersedia_prosesor </h2><br>  Dan tidak, saya tidak bermaksud prosesor pada node menelan sekarang.  Jika Anda melihat properti dari simpul yang berjalan (melalui API _nodes), Anda dapat melihat sesuatu seperti ini: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"os"</span></span>. { <span class="hljs-string"><span class="hljs-string">"refresh_interval_in_millis"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>, <span class="hljs-string"><span class="hljs-string">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"amd64"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.4.0-87-generic"</span></span>, <span class="hljs-string"><span class="hljs-string">"available_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-string"><span class="hljs-string">"allocated_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span> }</code> </pre> <br>  Dapat dilihat bahwa node berjalan pada host dengan 28 core, dan elastis menentukan dengan benar jumlah mereka dan mulai semuanya.  Tetapi jika ada lebih dari 32 core, kadang-kadang terjadi seperti ini: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"os"</span></span>: { <span class="hljs-string"><span class="hljs-string">"refresh_interval_in_millis"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>, <span class="hljs-string"><span class="hljs-string">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"amd64"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.4.0-116-generic"</span></span>, <span class="hljs-string"><span class="hljs-string">"available_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-string"><span class="hljs-string">"allocated_processors"</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span> }</code> </pre> <br>  Anda harus memaksa jumlah prosesor yang tersedia untuk layanan - ini memiliki efek yang baik pada kinerja node. <br><br><pre> <code class="hljs">processors: 72</code> </pre> <br><h2>  thread_pool.bulk.queue_size </h2><br>  Di bagian thread_pool.bulk.rejected dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, ada</a> semacam metrik - hitungan jumlah kegagalan permintaan untuk menambahkan data. <br><br>  Saya menulis bahwa pertumbuhan indikator ini adalah pertanda yang sangat buruk, dan pengembang merekomendasikan untuk tidak menyiapkan thread thread, tetapi menambahkan node baru ke cluster - yang seharusnya, ini memecahkan masalah kinerja.  Tetapi aturan dibutuhkan untuk kadang-kadang melanggarnya.  Dan tidak selalu mungkin untuk "melempar masalah dengan besi", jadi salah satu langkah untuk memerangi kegagalan dalam permintaan massal adalah meningkatkan ukuran antrian ini. <br><br>  Secara default, pengaturan antrian terlihat seperti ini: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"thread_pool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bulk"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fixed"</span></span>, <span class="hljs-string"><span class="hljs-string">"min"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-string"><span class="hljs-string">"max"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-string"><span class="hljs-string">"queue_size"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> } }</code> </pre> <br>  Algoritma adalah sebagai berikut: <br><br><ol><li>  Kami mengumpulkan statistik tentang ukuran rata-rata antrian sepanjang hari (nilai instan disimpan di thread_pool.bulk.queue); </li><li>  Hati-hati tingkatkan queue_size ke ukuran yang sedikit lebih besar daripada ukuran rata-rata antrian aktif - karena kegagalan terjadi ketika melebihi; </li><li>  Kami menambah ukuran kolam - ini tidak perlu, tapi bisa diterima. </li></ol><br>  Untuk melakukan ini, tambahkan sesuatu seperti ini ke pengaturan host (Anda tentu saja akan memiliki nilai sendiri): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">thread_pool</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bulk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.size</span></span>: 32 <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread_pool</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bulk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.queue_size</span></span>: 500</code> </pre> <br>  Dan setelah me-restart node, kita pasti akan memonitor beban, I / O, konsumsi memori.  dan semua yang mungkin untuk mengembalikan pengaturan jika perlu. <br><br>  <i>Penting: pengaturan ini hanya masuk akal pada node yang bekerja untuk menerima data baru.</i> <br><br><h2>  Pembuatan Indeks Awal </h2><br>  Seperti yang saya katakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> pertama seri ini, kami menggunakan Elasticsearch untuk menyimpan log dari semua layanan Microsoft.  Intinya sederhana - satu indeks menyimpan log dari satu komponen dalam satu hari. <br><br>  Dari sini dapat disimpulkan bahwa setiap hari indeks-indeks baru dibuat oleh jumlah layanan-mikro - oleh karena itu, lebih awal setiap malam, elastis jatuh ke dalam lubang selama sekitar 8 menit, sementara seratus indeks baru dibuat, beberapa ratus pecahan baru, jadwal pemuatan disk pergi â€œke rakâ€, antrian bertambah untuk mengirim log ke elastis pada host, dan Zabbix berkembang dengan peringatan seperti pohon Natal. <br><br>  Untuk menghindari ini, adalah akal sehat untuk menulis skrip Python untuk membuat indeks sebelumnya.  Script bekerja seperti ini: ia menemukan indeks untuk hari ini, mengekstrak pemetaan mereka dan membuat indeks baru dengan pemetaan yang sama, tetapi untuk hari berikutnya.  Ini berjalan pada cron, berjalan selama jam-jam ketika Elastis adalah yang paling sedikit dimuat.  Script menggunakan perpustakaan elasticsearch dan tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><h2>  Halaman induk transparan yang besar </h2><br>  Setelah kami menemukan bahwa node elastis yang mengoperasikan penerimaan data mulai menggantung di bawah beban selama jam sibuk.  Dan dengan gejala yang sangat aneh: penggunaan semua inti prosesor turun ke nol, namun demikian, layanan ini hang dalam memori, mendengarkan dengan benar ke port, tidak melakukan apa-apa, tidak menanggapi permintaan, dan setelah beberapa waktu jatuh dari cluster.  Layanan tidak menanggapi restart systemctl.  Hanya pembunuhan lama yang bagus yang membantu. <br><br>  Ini tidak ditangkap oleh alat pemantauan standar, pada grafik sampai saat jatuhnya gambar biasa, dalam log layanan - kosong.  Memori dump mesin java pada saat ini juga tidak mungkin. <br><br>  Tetapi, seperti yang mereka katakan, "kami adalah profesional, jadi setelah beberapa waktu kami mencari solusinya."  Masalah serupa juga dibahas dalam utas pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendiskusikan.elastic.co</a> dan ternyata merupakan bug kernel yang terkait dengan halaman besar tranparent.  Semuanya diselesaikan dengan mematikan thp di kernel menggunakan paket sysfsutils. <br><br>  Memeriksa apakah Anda mengaktifkan halaman besar transparan itu sederhana: <br><br><pre> <code class="hljs powershell">cat /sys/kernel/mm/transparent_hugepage/enabled always madvise [<span class="hljs-type"><span class="hljs-type">never</span></span>]</code> </pre> <br>  Jika [selalu] ada, Anda berpotensi berisiko. <br><br><h2>  Kesimpulan </h2><br>  Ini adalah penggaruk utama (sebenarnya ada, tentu saja, lebih banyak), yang kebetulan saya tapak selama satu setengah tahun sebagai administrator dari cluster Elasticsearch.  Saya harap informasi ini berguna dalam perjalanan yang sulit dan misterius ke cluster Elasticsearch yang ideal. <br><br>  Terima kasih untuk ilustrasinya, Anton Gudim - masih ada banyak kebaikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instagramnya</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419041/">https://habr.com/ru/post/id419041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419027/index.html">Keamanan informasi pembayaran tanpa uang tunai bank. Bagian 6 - Analisis Kejahatan Perbankan</a></li>
<li><a href="../id419029/index.html">Fortnite telah menjadi fenomena sosial. Orang tua semakin merekrut pelatih untuk anak-anak mereka dan bermain bersama mereka</a></li>
<li><a href="../id419033/index.html">Sebuah catatan kecil tentang topik menjalankan vue.js di cluster kubernetes</a></li>
<li><a href="../id419035/index.html">Buku â€œHead First Agile. Manajemen proyek yang fleksibel â€</a></li>
<li><a href="../id419037/index.html">Implementasi PPPOS pada stm32f4-discovery</a></li>
<li><a href="../id419043/index.html">Masalah frame timing yang sulit dipahami</a></li>
<li><a href="../id419047/index.html">Reddit meretas, membocorkan database dengan kata sandi dan email untuk 2005-2007</a></li>
<li><a href="../id419049/index.html">GeekBrains Meluncurkan marathon edukasi online â€œFind Yourself in Digitalâ€ gratis</a></li>
<li><a href="../id419051/index.html">Bagaimana Flant Membantu Pemula</a></li>
<li><a href="../id419053/index.html">Menguji Teknologi Cache Adaptec RAID</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>