<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö° ‚òØÔ∏è ü§û O rake mais comum ao usar printf em programas para microcontroladores ‚öóÔ∏è üçæ üë®üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De tempos em tempos, em meus projetos, tenho que usar o printf em conjunto com uma porta serial (UART ou uma abstra√ß√£o via USB que imita uma porta ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O rake mais comum ao usar printf em programas para microcontroladores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459420/">  De tempos em tempos, em meus projetos, tenho que usar o printf em conjunto com uma porta serial (UART ou uma abstra√ß√£o via USB que imita uma porta serial).  E, como sempre, passa muito tempo entre suas aplica√ß√µes e consigo esquecer completamente todas as nuances que precisam ser levadas em considera√ß√£o para que funcionem normalmente em um projeto grande. <br><br>  Neste artigo, compilei minhas pr√≥prias nuances principais que surgem ao usar o printf em programas para microcontroladores, classificadas por evid√™ncias do mais √≥bvio ao completamente n√£o-√≥bvio. <br><a name="habracut"></a><br><h2>  Breve introdu√ß√£o </h2><br>  De fato, para usar o printf em programas para microcontroladores, basta: <ul><li>  inclua o arquivo de cabe√ßalho no c√≥digo do projeto; </li><li>  redefina a fun√ß√£o do sistema _write para enviar para a porta serial; </li><li>  Descreva os stubs de chamadas do sistema que o vinculador exige (_fork, _wait e outros); </li><li>  use printf chamada no projeto. </li></ul><br>  De fato, nem tudo √© t√£o simples. <br><br><h2>  Descreva todos os stubs, n√£o apenas os usados. </h2><br>  A presen√ßa de v√°rios links vagos no layout do projeto √© surpreendente, mas depois de ler um pouco, fica claro o que e o porqu√™.  Em todos os meus projetos, estou conectando este <a href="">subm√≥dulo</a> .  Assim, no projeto principal, redefino apenas os m√©todos que preciso (apenas _write neste caso) e o restante permanece inalterado. <br><br>  √â importante observar que todos os stubs devem ser fun√ß√µes C.  N√£o √© C ++ (ou est√° envolto em "C" externo).  Caso contr√°rio, o layout falhar√° (lembre-se da mudan√ßa de nome durante a montagem com o G ++). <br><br><h2>  Em _write vem 1 caractere </h2><br>  Apesar do prot√≥tipo do m√©todo _write ter um argumento que transmite o tamanho da mensagem exibida, ele tem um valor de 1 (na verdade, n√≥s mesmos faremos com que seja sempre 1, mas mais sobre isso posteriormente). <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { ... }</code> </pre> <br>  Na Internet, muitas vezes voc√™ pode ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exatamente essa implementa√ß√£o</a> desse m√©todo: <br><div class="spoiler">  <b class="spoiler_title">Implementa√ß√£o frequente da fun√ß√£o _write</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uart_putc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); {} USART_SendData(USART2, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) ch); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write_r (struct _reent *r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { r = r; file = file; ptr = ptr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 int index; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For example, output string by UART */</span></span></span><span class="hljs-meta"> for(index=0; index&lt;len; index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr[index] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta">) { uart_putc(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">); } uart_putc(ptr[index]); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return len; }</span></span></code> </pre> <br></div></div><br>  Essa implementa√ß√£o tem as seguintes desvantagens: <br><ul><li>  baixa produtividade; </li><li>  inseguran√ßa de streaming; </li><li>  incapacidade de usar a porta serial para outros fins; </li></ul><br><br><h3>  Baixo desempenho </h3><br>  O desempenho lento ocorre devido ao envio de bytes usando os recursos do processador: voc√™ precisa monitorar o registro de status em vez de usar o mesmo DMA.  Para resolver esse problema, voc√™ pode preparar o buffer para o envio antecipado e, ao receber o caractere do final da linha (ou preencher o buffer), envie.  Este m√©todo requer uma mem√≥ria buffer, mas melhora significativamente o desempenho com o envio frequente. <br><div class="spoiler">  <b class="spoiler_title">Exemplo de implementa√ß√£o de _write com um buffer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;errno.h&gt; #include &lt;sys/unistd.h&gt; extern mc::uart uart_1; extern "C" { //      uart. static const uint32_t buf_size = 254; static uint8_t tx_buf[buf_size] = {0}; static uint32_t buf_p = 0; static inline int _add_char (char data) { tx_buf[buf_p++] = data; if (buf_p &gt;= buf_size) { if (uart_1.tx(tx_buf, buf_p, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } buf_p = 0; } return 0; } // Putty  \r\n    //    . static inline int _add_endl () { if (_add_char('\r') != 0) { return -1; } if (_add_char('\n') != 0) { return -1; } uint32_t len = buf_p; buf_p = 0; if (uart_1.tx(tx_buf, len, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } return 0; } int _write (int file, char *data, int len) { len = len; //   . if ((file != STDOUT_FILENO) &amp;&amp; (file != STDERR_FILENO)) { errno = EBADF; return -1; } //     //   \n. if (*data != '\n') { if (_add_char(*data) != 0) { return -1; } } else { if (_add_endl() != 0) { return -1; } } return 1; } }</span></span></span></span></code> </pre> </div></div><br>  Aqui, o objeto uart, uart_1, √© respons√°vel por enviar diretamente usando o dma.  O objeto usa m√©todos FreeRTOS para bloquear o acesso de terceiros ao objeto no momento do envio de dados do buffer (recebendo e retornando mutex).  Portanto, ningu√©m pode usar o objeto uart ao enviar de outro thread. <br>  Alguns links: <br><ul><li>  _escreva o c√≥digo de fun√ß√£o como parte de um projeto real <a href="">aqui</a> </li><li>  a interface da classe uart est√° <a href="">aqui</a> </li><li>  implementa√ß√£o da interface da classe uart sob stm32f4 <a href="">aqui</a> e <a href="">aqui</a> </li><li>  instancia√ß√£o da classe uart como parte do projeto <a href="">aqui</a> </li></ul><br><br><h3>  Inseguran√ßa de streaming </h3><br>  Essa implementa√ß√£o tamb√©m permanece desprotegida, j√° que ningu√©m incomoda no fluxo FreeRTOS vizinho come√ßar a enviar outra linha para printf e, assim, triturar o buffer que est√° sendo enviado no momento (o mutex dentro do uart protege o objeto de ser usado em fluxos diferentes, mas os dados n√£o s√£o transmitidos a eles )  Caso exista o risco de que printf de outro encadeamento seja chamado, √© necess√°rio implementar um objeto de camada que bloqueie totalmente o acesso ao printf.  No meu caso particular, apenas um thread interage com printf, portanto complica√ß√µes adicionais reduzir√£o apenas o desempenho (captura e libera√ß√£o constantes de mutex dentro da camada). <br><br><h3>  Incapacidade de usar a porta serial para outros fins </h3><br>  Como enviamos somente depois que toda a cadeia foi recebida (ou o buffer est√° cheio), em vez do objeto uart, voc√™ pode chamar o m√©todo converter para alguma interface de n√≠vel superior para transfer√™ncia de pacotes subsequente (por exemplo, entrega com garantia de acordo com o protocolo de transmiss√£o semelhante aos pacotes modbus de transa√ß√£o).  Isso permitir√° que voc√™ use um uart para exibir informa√ß√µes de depura√ß√£o e, por exemplo, para intera√ß√£o do usu√°rio com o console de gerenciamento (se houver um dispon√≠vel no dispositivo).  Basta escrever um descompressor no lado do destinat√°rio. <br><br><h2>  Por padr√£o, a sa√≠da flutuante n√£o funciona </h2><br>  Se voc√™ usar newlib-nano, por padr√£o printf (assim como todos os seus derivados, como sprintf / snprintf ... e outros) n√£o suportar√° a sa√≠da de valores flutuantes.  Isso √© facilmente resolvido adicionando os seguintes sinalizadores de vinculador ao projeto. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS -Wl,-u,vfprintf; -Wl,-u,_printf_float; -Wl,-u,_scanf_float; <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre> <br>  Veja a lista completa de sinalizadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  O programa congela em algum lugar nas entranhas do printf </h2><br>  Essa √© outra falha nos sinalizadores do vinculador.  Para que o firmware seja configurado com a vers√£o desejada da biblioteca, voc√™ deve especificar explicitamente os par√¢metros do processador. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS <span class="hljs-variable"><span class="hljs-variable">${HARDWARE_FLAGS}</span></span> <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre><br>  Veja a lista completa de sinalizadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  printf for√ßa o microcontrolador a entrar em uma falha grave </h2><br>  Pode haver pelo menos dois motivos: <br><ul><li>  problemas de pilha; </li><li>  problemas com _sbrk; </li></ul><br><h3>  Problemas de pilha </h3><br>  Esse problema realmente se manifesta ao usar o FreeRTOS ou qualquer outro sistema operacional.  O problema est√° usando o buffer.  O primeiro par√°grafo dizia que em _write vem 1 byte cada.  Para que isso ocorra, voc√™ deve proibir o uso de buffer no seu c√≥digo antes de usar o printf pela primeira vez. <br><pre> <code class="cpp hljs">setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  A partir da descri√ß√£o da fun√ß√£o, segue-se que um dos seguintes valores pode ser definido da mesma maneira: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOFBF 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set fully buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOLBF 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set line buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IONBF 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set unbuffered */</span></span></span></span></code> </pre> <br>  No entanto, isso pode levar a um estouro da pilha de tarefas (ou interrup√ß√µes, se de repente voc√™ for uma pessoa muito ruim que chama printf de interrup√ß√µes). <br><br>  Tecnicamente, √© poss√≠vel organizar pilhas com muito cuidado para cada fluxo, mas essa abordagem requer um planejamento cuidadoso e √© dif√≠cil detectar os erros que ela carrega.  Uma solu√ß√£o muito mais simples √© receber um byte cada, armazen√°-lo em seu pr√≥prio buffer e envi√°-lo no formato necess√°rio, analisado anteriormente. <br><br><h3>  Problemas com _sbrk </h3><br>  Esse problema foi para mim pessoalmente o mais impl√≠cito.  E ent√£o, o que sabemos sobre _sbrk? <br><ul><li>  Outro esbo√ßo que precisa ser implementado para suportar uma parte consider√°vel das bibliotecas padr√£o; </li><li>  necess√°rio para alocar mem√≥ria na pilha; </li><li>  usado por todos os tipos de m√©todos de biblioteca como malloc, gr√°tis. </li></ul><br>  Pessoalmente, em meus projetos, em 95% dos casos, eu uso o FreeRTOS com m√©todos redefinidos new / delete / malloc que usam um monte de FreeRTOS.  Portanto, quando aloco mem√≥ria, tenho certeza de que a aloca√ß√£o est√° no heap do FreeRTOS, que ocupa uma quantidade predeterminada de mem√≥ria na √°rea bss.  Voc√™ pode olhar para a camada <a href="">aqui</a> .  Portanto, puramente tecnicamente, n√£o deve haver problema.  Uma fun√ß√£o simplesmente n√£o deve ser chamada.  Mas vamos pensar, se ela ligar, ent√£o onde ela tentar√° recuperar sua mem√≥ria? <br><br>  Lembre-se do layout da RAM do projeto "cl√°ssico" para microcontroladores: <br><ul><li>  .data; </li><li>  .bss; </li><li>  espa√ßo vazio </li><li>  pilha inicial. </li></ul><br>  Em dados, temos os dados iniciais de objetos globais (vari√°veis, estruturas e outros campos globais do projeto).  No bss, campos globais que possuem um valor zero inicial e, com cuidado, um monte de FreeRTOS.  √â apenas uma matriz na mem√≥ria.  com o qual os m√©todos do arquivo heap_x.c funcionam.  Em seguida √© o espa√ßo vazio, ap√≥s o qual (ou melhor, do final) √© a pilha.  Porque  O FreeRTOS √© usado no meu projeto, ent√£o essa pilha √© usada apenas at√© o agendador iniciar.  E, portanto, seu uso, na maioria dos casos, √© limitado ao colobyte (na verdade, geralmente um limite de 100 bytes). <br><br>  Mas onde, ent√£o, a mem√≥ria √© alocada usando _sbrk?  Veja quais vari√°veis ‚Äã‚Äãela usa no script vinculador. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *__attribute__ ((weak)) _sbrk (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> incr) { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_start; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_end; ...</code> </pre> <br>  Agora, n√≥s os encontramos no script do vinculador (meu script √© um pouco diferente do que o st fornece, no entanto, essa parte √© praticamente a mesma): <br><pre> <code class="bash hljs">__stack = ORIGIN(SRAM) + LENGTH(SRAM); __main_stack_size = 1024; __main_stack_limit = __stack - __main_stack_size; ...  flash,    ... .bss (NOLOAD) : ALIGN(4) { ... . = ALIGN(4); __bss_end = .; } &gt;SRAM __heap_start = __bss_end; __heap_end = __main_stack_limit;</code> </pre> <br>  Ou seja, ele usa mem√≥ria entre a pilha (1 kb de 0x20020000 para baixo com 128 kb de RAM) e bss. <br><br>  Entendido.  Mas ele tinha uma redefini√ß√£o dos m√©todos malloc, free e outros.  Use _sbrk depois de tudo n√£o √© necess√°rio?  Como se viu, uma obriga√ß√£o.  Al√©m disso, esse m√©todo n√£o usa printf, mas o m√©todo para definir o modo de buffer - <b>setvbuf</b> (ou melhor, _malloc_r, que n√£o √© declarado como uma fun√ß√£o fraca na biblioteca. Ao contr√°rio do malloc, que pode ser facilmente substitu√≠do). <br><img src="https://habrastorage.org/webt/me/cf/er/mecfercw11rpbrxrfn0twjyqvva.jpeg"><br>  Como eu tinha certeza de que o sbrk n√£o era usado, coloquei um monte de FreeRTOS (se√ß√£o bss) pr√≥ximo √† pilha (porque sabia com certeza que a pilha era usada 10 vezes menos que o necess√°rio). <br><br>  Solu√ß√µes para o problema 3: <br><ul><li>  recuo entre bss e a pilha; </li><li>  substitua _malloc_r para que _sbrk n√£o seja chamado (separe um m√©todo da biblioteca); </li><li>  reescreva o sbrk via malloc e gratuitamente. </li></ul><br>  Eu decidi pela primeira op√ß√£o, pois n√£o foi poss√≠vel substituir o _malloc_r padr√£o (que est√° dentro da libg_nano.a (lib_a-nano-mallocr.o)) (o m√©todo n√£o foi declarado como __attribute__ ((fraco)), mas para excluir apenas uma fun√ß√£o da bi-biblioteca N√£o consegui vincular).  Eu realmente n√£o queria reescrever o sbrk para uma liga√ß√£o. <br><br>  A solu√ß√£o final foi alocar parti√ß√µes separadas na RAM para a pilha inicial e _sbrk.  Isso garante que as se√ß√µes n√£o sejam empilhadas umas sobre as outras durante a fase de configura√ß√£o.  Dentro do sbrk, h√° tamb√©m uma verifica√ß√£o para sair da se√ß√£o.  Eu tive que fazer uma pequena corre√ß√£o para que, ao detectar uma transi√ß√£o para o exterior, o fluxo travasse em um loop while (j√° que o uso do sbrk ocorre apenas no est√°gio inicial de inicializa√ß√£o e deve ser processado no est√°gio de depura√ß√£o do dispositivo). <br><div class="spoiler">  <b class="spoiler_title">Mem.ld modificado</b> <div class="spoiler_text"><pre> <code class="bash hljs">MEMORY { FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 1M CCM_SRAM (RW) : ORIGIN = 0x10000000, LENGTH = 64K SRAM (RW) : ORIGIN = 0x20000000, LENGTH = 126K SBRK_HEAP (RW) : ORIGIN = 0x2001F800, LENGTH = 1K MAIN_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Altera√ß√µes para section.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">__stack = ORIGIN(MAIN_STACK) + LENGTH(MAIN_STACK); __heap_start = ORIGIN(SBRK_HEAP); __heap_end = ORIGIN(SBRK_HEAP) + LENGTH(SBRK_HEAP);</code> </pre> </div></div><br>  Voc√™ pode olhar para <a href="">mem.ld</a> e <a href="">section.ld</a> no meu projeto de sandbox <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste commit</a> . <br><br>  UPD 07/12/2019: corrigida a lista de sinalizadores para trabalhar printf com valores flutuantes.  Corrigi o link para as CMakeLists em funcionamento com sinalizadores de compila√ß√£o e layout corrigidos (havia nuances com o fato de que os sinalizadores deveriam ser listados um por um e por meio de ";", enquanto em uma linha ou em linhas diferentes isso n√£o importa). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459420/">https://habr.com/ru/post/pt459420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459404/index.html">Id√©ia: registro / autoriza√ß√£o an√¥nima na rede Ethereum + Metamask, sem e-mails, etc.</a></li>
<li><a href="../pt459408/index.html">Como eu tentei consertar uma pesquisa no mapa por drivers. Parte 3 (final)</a></li>
<li><a href="../pt459410/index.html">Como escrever c√≥digo para que seus colegas n√£o jurem</a></li>
<li><a href="../pt459414/index.html">Escrevendo uma API para reagir componentes, parte 4: Cuidado com o Apropacalypse</a></li>
<li><a href="../pt459416/index.html">Escrevendo uma API para reagir componentes, parte 5: apenas usar composi√ß√£o</a></li>
<li><a href="../pt459422/index.html">Escrevemos API para componentes React, parte 6: criamos comunica√ß√£o entre componentes</a></li>
<li><a href="../pt459426/index.html">Como o design do Yandex.Avto foi criado</a></li>
<li><a href="../pt459428/index.html">Intel Quartus Prime - tudo o que voc√™ precisa para trabalhar com o Intel FPGA</a></li>
<li><a href="../pt459430/index.html">Aplica√ß√£o m√≥vel com gera√ß√£o autom√°tica de formul√°rios: nosso caso</a></li>
<li><a href="../pt459432/index.html">RD-180: os EUA podem fabricar motores de foguete?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>