<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☔️ 🙋 👩🏽‍🌾 Membalikkan adaptor USB-SATA (riwayat satu magang) 🐓 👨🏿‍🤝‍👨🏻 👨🏽‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Latar belakang 


 Magang adalah proses mendapatkan pengetahuan dan pengalaman. Tim Keamanan Raccoon kami percaya bahwa meningkatkan keamanan informas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membalikkan adaptor USB-SATA (riwayat satu magang)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/485966/"><h1 id="predystoriya">  Latar belakang </h1><br><p>  Magang adalah proses mendapatkan pengetahuan dan pengalaman.  Tim Keamanan Raccoon kami percaya bahwa meningkatkan keamanan informasi perangkat dan perangkat lunak di sekitar kita tidak mungkin tanpa meneruskan pengetahuan dan pengalaman ini kepada generasi spesialis di masa mendatang.  Itulah sebabnya kami telah menyelenggarakan magang individu untuk siswa dan lulusan berbakat selama bertahun-tahun. </p><br><p>  Penelitian keamanan adalah keterampilan yang tidak diajarkan di universitas.  Anda dapat mempelajarinya dari contoh nyata dan di bawah bimbingan mentor yang berpengalaman.  Setiap tahun, karyawan magang kami memecahkan masalah teknis yang kompleks, mencapai tujuan mereka dan melanjutkan, memperluas cakrawala profesional mereka dan membuat dunia sedikit lebih aman.  Masing-masing dari mereka memiliki kisah tersendiri tentang menjadi seorang spesialis, dan di bawah potongan - awal dari salah satunya. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/dr/h-/eudrh-mevrjhfjo4jfjouffyyk4.png"></div><a name="habracut"></a><br><h1 id="vvedenie">  Pendahuluan </h1><br><p>  Pada Oktober tahun lalu, saya datang untuk magang teknis di perusahaan NTC Vulkan.  Ketertarikan saya diarahkan pada bidang rekayasa terbalik.  Saya tahu apa itu, saya sudah mencoba untuk secara mandiri meneliti crackme di bawah x86, tetapi saya mengerti bahwa hal yang paling menarik terletak tepat di persimpangan perangkat lunak dan perangkat keras.  Saya tidak memiliki pengalaman di bidang ini, tetapi saya memiliki keinginan untuk mencoba tangan saya. </p><br><p> Saya tidak memiliki harapan khusus dari acara ini - teman dan kenalan sering berbicara tentang magang teknis di berbagai perusahaan terkenal.  Dan ketika saya ditawari untuk mencoba meneliti adaptor USB-SATA, saya senang dengan peluang baru untuk mempelajari sesuatu.  Pengalaman yang diperoleh dan hasil yang saya capai memungkinkan untuk memverifikasi kebenaran pilihan tempat magang dan profesi masa depan. </p><br><p>  Dan penelitian dimulai dengan mendapatkan adaptor USB-SATA biasa.  Inilah yang saya lakukan selanjutnya. </p><br><h1 id="vizualnyy-shemotehnicheskiy-analiz">  Analisis rangkaian visual </h1><br><p>  Pertama, Anda perlu memeriksa papan adaptor dan menentukan elemen dasar perangkat.  Pada gambar di bawah ini, blok utama komponen yang penting untuk pengoperasian perangkat ditandai.  Foto yang diambil setelah penelitian: </p><br><img src="https://habrastorage.org/webt/9x/1n/ej/9x1nejzyxjz-zpfnb_d_v9y9giy.jpeg"><br><p>  <em>Adaptor USB ke SATA.</em>  <em>Tampilan atas</em> </p><br><img src="https://habrastorage.org/webt/tx/ra/je/txrajeoqdj1x7ytwn7huh0gdy6g.jpeg"><br><p>  <em>Adaptor USB ke SATA.</em>  <em>Tampak bawah</em> </p><br><p>  Setelah menghabiskan beberapa waktu di Google, saya menemukan bahwa ada dua konverter tegangan di papan: satu di 3,3 V, yang lain di 1,2 V. Ini juga sangat mudah untuk menentukan memori flash yang dipasang di papan.  ROM bekerja pada antarmuka SPI, dan kapasitas memori 512 Kbps. </p><br><p>  Tampaknya tahap pengintaian sirkuit hampir selesai, tetapi pencarian cepat di Internet tidak menghasilkan hasil apa pun untuk kueri "ASM1051".  Tidak ada dokumen yang ditemukan untuk chip yang dipasang di papan tulis.  Benar, masih berhasil menemukan perangkat lunak yang memungkinkan Anda memperbaruinya.  Selain itu, ada <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">datasheet</a> kecil untuk model <strong>ASM1053 yang</strong> lebih lama. </p><br><h1 id="usb">  USB </h1><br><p>  Saat terhubung ke komputer, adaptor muncul sebagai perangkat penyimpanan USB.  Saya memutuskan bahwa pengetahuan yang lebih dalam tentang <a href="https://ru.wikipedia.org/wiki/USB">USB</a> mungkin akan berguna untuk penelitian saya, jadi beberapa jam berikutnya saya habiskan mempelajari antarmuka. <br>  Secara umum, perangkat USB dapat dari kelas yang berbeda, tergantung pada fungsinya.  Misalnya, flash drive adalah Mass Storage Device, dan keyboard dan mouse adalah <a href="https://ru.wikipedia.org/wiki/USB_HID">Human Interface Device (HID)</a> .  Dan karena adaptor saya terlihat di manajer perangkat sebagai perangkat penyimpanan, itu berarti itu didefinisikan sebagai Mass Storage dan harus bekerja dengan perintah SCSI. </p><br><div class="spoiler">  <b class="spoiler_title">Literatur USB dasar yang berguna</b> <div class="spoiler_text"><ul><li><p>  <a href="https://pierrelib.pagesperso-orange.fr/buses/USB_in_a_Nutshell.pdf">USB dalam NutShell</a> </p><br></li><li><p>  <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Kelas Penyimpanan Massal Universal Serial Bus</a> </p><br></li><li><p>  <a href="http://ww1.microchip.com/downloads/en/appnotes/01169a.pdf">Kelas Penyimpanan Massal USB pada Perangkat Tertanam</a> </p><br></li><li><p>  <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Manual Referensi Perintah SCSI</a> </p><br></li></ul></div></div><br><h1 id="chtenie-pamyati-iz-pzu">  Baca memori dari ROM </h1><br><p>  Karena tidak ada yang diketahui tentang ASM1051 yang dipasang di papan, memori dari ROM dianggap sebagai tindakan yang paling jelas.  Saya pindah ke laboratorium.  Memisahkan chip memori flash dengan pengering rambut solder, menghubungkannya ke programmer USB ChipProg-48.  Tidak ada masalah membaca, dan saya memiliki file biner di tangan saya.  Saat itu, saya tidak bisa mengatakan apa yang ada di flash drive, dan mulai menganalisis data. </p><br><h1 id="analiz-binarnogo-fayla">  Analisis file biner </h1><br><p>  Pertama-tama, saya membuka dump memori dari ROM menggunakan WinHex, tetapi Anda dapat menggunakan editor HEX.  Mulai melihat byte: </p><br><img src="https://habrastorage.org/webt/fz/g8/v7/fzg8v7gjqsop97y-kgybcmudrqa.jpeg"><br><p>  <em>Mulai dari dump memori yang dibaca dari ROM</em> </p><br><p> Tangkapan layar di atas adalah tangkapan layar dari editor.  Baris <code>ASMT1051</code> , yang dimulai dengan alamat 0x44, segera terbukti.  Anda juga dapat melihat garis <code>asmedia</code> dari alamat 0x18.  Untuk analisis data awal, saya menggunakan alat analisis frekuensi, yang tersedia di WinHex. </p><br><img src="https://habrastorage.org/webt/ui/r9/ad/uir9adkobpc6gnl55k6vjnaf65i.jpeg"><br><p>  <em>Histogram analisis frekuensi memori ROM</em> </p><br><p>  Histogram menunjukkan byte yang paling banyak dalam file.  Selain tumpukan 0x00 dan 0xFF (kolom ekstrim pada histogram), byte berikut ini sering ditemukan dalam memori: </p><br><ul><li>  0x02; </li><li>  0x74; </li><li>  0x90; </li><li>  0xA3; </li><li>  0xE0; </li><li>  0xF0. </li></ul><br><p>  Mungkin saja untuk mengkonfirmasi asumsi saya bahwa ada firmware dalam ROM.  Cara mudah untuk melakukan ini adalah mencoba membandingkan <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">opcodes dari</a> berbagai arsitektur yang cocok untuk mikrokontroler (selanjutnya - MC) dengan byte yang sering ditemukan dalam memori. </p><br><p>  Jika diperkirakan secara kasar, maka sangat sering dalam kode apa pun di assembler harus memenuhi perintah seperti: </p><br><ul><li>  mov; </li><li>  jmp; </li><li>  menelepon; </li><li>  ret. </li></ul><br><p>  Tentu saja, dalam arsitektur yang berbeda perintah ini mungkin memiliki variasi yang berbeda, tetapi ada satu akal sehat. </p><br><p>  Saya harus melalui beberapa set instruksi untuk kernel yang berbeda sebelum saya menemukan yang tepat.  Perbandingan dengan arsitektur <a href="https://ru.wikipedia.org/wiki/Intel_8051">Intel 8051</a> memberikan hasil yang sangat masuk akal.  Opcode dari beberapa <a href="http://www.keil.com/support/man/docs/is51/is51_opcodes.htm">perintah</a> bertepatan dengan byte populer dari file, misalnya: </p><br><ul><li>  0x02 - LJMP addr16; </li><li>  0x74 - MOV A, #immed; </li><li>  0x90 - MOV DPTR, #immed; </li><li>  0xA3 - INC DPTR; </li><li>  0xE0 - MOVX A, @DPTR; </li><li>  0xF0 - MOVX @DPTR, A. </li></ul><br><p>  Sepertinya ada firmware untuk MK di ROM.  Seseorang dapat langsung memuat biner ke disassembler <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA Pro</a> , tetapi saat makan siang salah satu rekan bertanya: </p><br><blockquote>  <em>"Apakah kamu yakin kode dalam memori dimulai tepat dari alamat nol?"</em> </blockquote><p>  Dan sungguh, Anda perlu mempertimbangkan bahwa beberapa "sampah" atau data dari alamat 0x00 dapat di memori. </p><br><p>  Secara umum, saya menghadapi tugas menentukan alamat awal kode.  Untuk mencapai tujuan ini, yang terbaik adalah menggunakan emulator <a href="https://www.eltan.com/products/spi-flash-tools/46-em100-emulator.html">EM100</a> SPI.  Emulator menggantikan chip memori di papan, dengan itu tidak perlu menyolder ROM setiap kali dengan firmware, selain itu, EM100 dapat merekam log akses memori.  Mengingat firmware dari ROM telah dibaca, sekarang Anda dapat mengunduhnya ke emulator SPI.  Selanjutnya, Anda perlu menyolder emulator ke papan adaptor dan merekam log saat menghubungkan adaptor melalui USB ke PC. </p><br><img src="https://habrastorage.org/webt/8i/rp/f2/8irpf2mpqht4crvi8aqwcj3ot7s.jpeg"><br><p>  <em>Emulator SPI disolder ke papan adaptor USB-SATA</em> </p><br><p>  Saya menyolder kabel dari emulator ke bantalan dari memori flash dan mem-flash emulator dengan beberapa firmware.  Sekarang tinggal melihat apakah MK mengalamatkan memori, dan jika demikian, di alamat apa. </p><br><img src="https://habrastorage.org/webt/yc/v6/te/ycv6teqfm5n_7gzvwgss1d6ycwk.png"><br><p>  <em>ROM akses ke memori ROM (diperoleh dengan menggunakan perangkat lunak emulator SPI)</em> </p><br><p>  Gambar di atas menunjukkan bahwa ketika daya terhubung ke adaptor, pengontrol ASM1051 yang terpasang di papan mengirimkan beberapa perintah 0x03 (Baca Data). </p><br><p>  Pertama, ASM1051 membaca 0x80 byte, mulai dari 0x0000.  Berikut ini adalah dua byte, mulai dari alamat 0x0080, lalu dua byte lagi dari alamat 0x8082.  Kemudian ia membaca sebagian besar memori dari ROM, mulai dari alamat 0x0082. </p><br><p>  Kita dapat mengasumsikan bahwa sejumlah besar byte yang dibaca dari ROM terakhir, dimulai dengan alamat 0x0082, mungkin merupakan kode.  Apa dan mengapa diminta sebelum ini belum jelas.  Hanya diketahui bahwa sebagai respons terhadap permintaan pertama, ASM1051 akan menerima baris dari memori flash yang ditandai pada gambar di atas.  Mereka hanya terletak di 0x80 byte pertama. </p><br><p>  Sudah waktunya untuk memeriksa dugaan bahwa memori eksternal di papan berisi firmware untuk MK dengan kernel 8051, dan kode itu sendiri terletak dari alamat 0x0082.  Buka dump memori di IDA Pro, tentukan jenis Prosesor Intel 8051 dan offset untuk kode 0x0082. </p><br><img src="https://habrastorage.org/webt/r8/fy/pl/r8fyplytapyh-i_lfgazwcsoxga.png"><br><p>  <em>File biner dibuka di IDA Pro dengan offset 0x82</em> </p><br><p>  Tidak ada masalah membuka biner di disassembler. </p><br><p>  <strong><em>Kesimpulan:</em></strong> </p><br><ol><li>  MK ASM1051 memiliki arsitektur 8.051. </li><li>  Di ROM ada kode yang dimulai dengan alamat 0x82.  Ada hal lain selain kode. </li><li>  0x80 byte pertama menarik perhatian. </li></ol><br><h1 id="analiz-koda">  Analisis kode </h1><br><p>  Sekarang saya telah memastikan bahwa kode dalam IDA dimuat dengan benar, Anda dapat mulai menganalisis dan mengomentarinya secara paralel. </p><br><p>  Selama mempelajari kode, fungsi sederhana ditemukan, seperti mengurangi angka 32-bit, berbagai penangan ditemukan, mirip dengan <code>switch ()</code> di S. Melkali, dan fungsi yang sangat sederhana, seperti menyimpan nilai dari register R7 ke dalam memori di beberapa alamat.  Temuan paling signifikan yang akan saya jelaskan di bawah. </p><br><h2 id="nahodka--1">  Temukan No. 1 </h2><br><p>  Menariknya, sebagai tanggapan atas permintaan INQUIRY ( <a href="https://en.wikipedia.org/wiki/SCSI_command">perintah SCSI</a> ) saya, saya menerima respons yang berisi dua baris yang kami lihat di awal memori ROM.  Tentu saja, saya segera mengubah baris ini dalam memori emulator, menunggu permintaan INQUIRY untuk melihat apa yang saya tulis.  Mimpi naif seperti itu dengan cepat runtuh.  Sekarang, sebagai tanggapan terhadap perintah, saya melihat baris lain, ASM1051 tidak meminta sebagian besar memori dari ROM.  MK hanya membaca 0x80 byte pertama dan semua.  Dalam arsitektur 8051, mask (perangkat keras) firmware dapat digunakan, tampaknya, ASM1051 mulai mem-boot darinya. </p><br><p>  Jadi menjadi jelas bahwa 0x80 byte pertama sangat penting, dan mengubahnya tidak akan berfungsi.  Saya memutuskan untuk mempelajari secara lebih rinci permintaan yang dibuat MK pada SPI sebelum mengunduh kode. </p><br><img src="https://habrastorage.org/webt/ep/cl/8i/epcl8it0d2d63f8oq1tctpmfvii.png"><br><p>  <em>Permintaan data SPI dalam ROM</em> </p><br><p>  Dua permintaan dua byte tampak menarik.  Pencarian di IDA 0x00, 0x80 dan 0xEB menghasilkan sejumlah besar hasil yang saya tidak menganalisis, tetapi byte 0x5A jarang ditemui. </p><br><img src="https://habrastorage.org/webt/sv/ym/kf/svymkfdb-0nsj764k8igczukjj0.png"><br><p>  <em>Perbandingan dengan byte 0x5A.</em>  <em>Menghitung checksum-8</em> </p><br><p>  Secara harfiah klik keenam membawa saya ke bagian kode yang ditunjukkan pada gambar di atas.  Dapat dilihat bahwa nilai dari register dengan alamat 0x80 <strong>7E</strong> dibandingkan dengan 0x5A.  Kemudian checksum-8 dibaca untuk nilai yang terletak dari alamat 0x80 <strong>04</strong> hingga 0x80 <strong>7E</strong> .  Selanjutnya, nilai pada 0x80 <strong>7F</strong> dibandingkan dengan jumlah yang diterima sebelumnya. </p><br><img src="https://habrastorage.org/webt/j4/ao/x2/j4aox2tkbow4wzw57rrbprixw9u.png"><br><p>  <em>Awal memori dalam ROM</em> </p><br><p>  Offset seperti ini menyerupai awal dump memori dari ROM.  Gambar di atas menunjukkan bahwa alamat 0x7E berisi byte 0x5A.  Dan jika Anda menghitung checksum-8 untuk byte dari posisi 0x04 hingga 0x7E, maka kami mendapatkan 0xA7, dan nilai ini hanya terletak di alamat 0x7F. </p><br><p>  Dengan cara yang sama, kami berhasil menemukan perhitungan jumlah cek untuk byte dari alamat 0x0082 hingga 0x807F (tampaknya ini adalah seluruh kode), yang diperiksa dengan byte di alamat 0x8083.  Dan pada 0x8082 lagi terletak nilai 0x5A. </p><br><p>  Ya, ini sedikit lebih rumit daripada hanya mengubah garis dalam memori.  Saya juga mengubah mereka, tetapi saya juga menghitung dan menuliskan cek-jumlah untuk file baru di tempat yang tepat.  Setelah itu, sebagai tanggapan atas perintah SCSI INQUIRY, saya melihat dialog saya. </p><br><p>  <strong><em>Kesimpulan:</em></strong> </p><br><ol><li>  Selama boot, ASM1051 berupaya mengunduh kode dari ROM. </li><li>  Pertama, ASM1051 membandingkan byte checksum-8 dari alamat 0x04 ke 0x7E dengan nilai 0x7F. </li><li>  Jika perbandingan jumlah cek untuk pembukaan telah berhasil, maka kita dapat mempertimbangkannya untuk "kode" (alamat dari 0x0082 hingga 0x807F).  ASM1051 membandingkan jumlah ini dengan nilai pada alamat 0x8083 dan memverifikasi bahwa byte 0x5A terletak di alamat 0x8082. </li><li>  Jika semua pemeriksaan sudah benar, maka ASM1051 diambil dari ROM, jika tidak menggunakan firmware mask. </li></ol><br><h2 id="nahodka--2">  Temukan nomor 2 </h2><br><p>  Saat meninjau dan mengomentari fungsi, saya menemukan bahwa seringkali fungsi PRINTF digunakan dalam kode (saya menyebutnya demikian).  Hal yang menarik tentang itu adalah bahwa sebelum dipanggil, karakter yang <strong>dicetak</strong> ditulis ke register R7. </p><br><img src="https://habrastorage.org/webt/fn/0a/9a/fn0a9aafvgus1v4emxuf6j9kbea.png"><br><p>  <em>Fungsi PRINTF di IDA Pro</em> </p><br><p>  Fungsi itu sendiri disajikan pada gambar di atas.  Mari kita hadapi dia.  Pertama-tama, Anda perlu memindahkan nilai dari register dengan alamat 0x7F6 ke baterai.  Jika ada nol, maka keluarlah dari fungsinya.  Hal yang paling menarik terjadi jika tidak ada nol.  Kemudian nilai register R7 dipindahkan ke register dengan alamat 0xC001, dan, seperti yang kita ingat, sebelum memanggil fungsi ini, karakter yang dicetak ditulis ke R7.  Selanjutnya, periksa apakah nilai dalam R7 sama dengan kode karakter "." Atau "-", jika tidak, maka keluar dari fungsinya.  Tetapi jika perbandingan ternyata berhasil, maka fungsi mengambil nilai dari register dengan alamat 0x16A dan memindahkannya ke 0xC001, tetapi apakah itu rumit.  Misalnya, alih-alih byte <strong>0x41</strong> (karakter "A" di ASCII), fungsinya akan pindah ke 0xC001 byte 0x34 (karakter <strong>"4"</strong> di ASCII), lalu 0x31 (karakter <strong>"1"</strong> di ASCII).  Keluar dari fungsi lagi. </p><br><p>  Saya menemukan bahwa pemeriksaan di awal fungsi tidak dapat dilewati, karena register dengan alamat 0x7F6 diinisialisasi ke nol, maka tidak berubah dalam kode.  Artinya, fungsi ini dinonaktifkan oleh programmer, meskipun tetap dikompilasi.  Fakta bahwa byte hanya ditulis ke register 0xC001 (dan terkadang dua berturut-turut), menunjukkan bahwa ini kemungkinan besar merupakan register perangkat keras. </p><br><p>  Semua ini menyerupai UART.  Untuk mengetahui apakah ini benar, Anda harus melakukan yang berikut: </p><br><ol><li>  Identifikasi kaki-kaki pada ASM1051 di mana UART adalah output. </li><li>  Tentukan parameter UART (kecepatan, paritas, jumlah bit stop). </li><li>  Alangkah baiknya untuk mengaktifkan UART dalam kode (rupanya, dimatikan). </li></ol><br><p>  Semuanya terlihat cukup sederhana: Anda dapat bergiliran menyentuh kaki dengan penganalisa logis dan mencari yang di mana saat mengirim UART akan terlihat.  Di hadapan sinyal, kecepatan dapat ditentukan oleh waktu pulsa.  Dengan sisa parameter, semuanya juga jelas, lihat saja saat mengirim byte pada alat analisa. </p><br><p>  Untuk "mengaktifkan" fungsi ini, Anda dapat menulis nol alih-alih tiga baris pertama, di mana nilainya diperiksa dalam register dengan alamat 0x7F6.  Untuk melakukan ini, saya kembali membuka firmware di WinHex. </p><br><img src="https://habrastorage.org/webt/rm/rw/mg/rmrwmgen5bw46g0r1a7uchsnkog.png"><br><p>  <em>Enam byte yang akan direset dialokasikan.</em> </p><br><p>  Di editor, saya mengubah enam byte yang diinginkan menjadi nol.  Sekarang firmware siap dan dapat diunduh ke emulator ROM.  Jika kita mengasumsikan bahwa fungsi untuk menghasilkan byte di UART dinyalakan, dan panggilannya terletak sangat sering di seluruh kode, maka kita dapat berharap bahwa byte harus "terbang" dari UART ketika adaptor berjalan.  Saya berharap untuk melihat pelacak yang memberi sinyal dalam byte di UART berapa banyak kode yang dieksekusi. </p><br><p>  Seperti yang saya tulis di atas, untuk menemukan kaki Rx dan Tx yang diperlukan, Anda dapat melihat penganalisa logika satu per satu.  Namun, saya berasumsi bahwa Rx dan Tx pada ASM1051 berada di tempat yang sama dengan ASM1053 - kaki 40 dan 41, masing-masing.  Saya meletakkan probe analyzer ke pin 41 (diasumsikan Tx) dan saya melihat sesuatu yang mirip dengan sinyal yang diinginkan: </p><br><img src="https://habrastorage.org/webt/qn/s7/rq/qns7rq-nxvqvqcgzlo4hwqb7spc.png"><br><p>  <em>Diagram waktu dengan kaki 41 - Tx</em> </p><br><p>  Untuk menghubungkan konverter USB-UART dan mengamati karakter cetak yang masuk di terminal, saya harus menyolder dua kabel tipis langsung ke papan adaptor dan memperbaikinya dengan lem panas. </p><br><img src="https://habrastorage.org/webt/jn/x2/-f/jnx2-fwuhcewoy4aodelx7ugqbk.jpeg"><br><p>  <em>Dua kabel disolder ke RX dan TX</em> </p><br><p>  Saya mempelajari diagram dari gambar "Timing diagram from leg 41 - Tx" sedikit: waktu satu pulsa, ternyata, adalah 1 μs, dan untuk enam bit - 6,3 μs.  Setelah menghitung ulang nilai dalam baud, saya menerima sekitar 950.000 baud, kecepatan UART standar terdekat adalah 921600 baud.  Saya pikir perbedaan ini diperoleh karena kesalahan pengukuran oleh penganalisis logis, saya mengambil bukan perangkat yang paling layak, tetapi “bayi” Tiongkok.  Setelah mengatur parameter di jendela program Terminal 1.9b, saya dapat mengamati byte yang masuk dari ASM1051 MK selama operasinya. </p><br><img src="https://habrastorage.org/webt/fa/de/pc/fadepckvko4t2dyacaqt93hidao.png"><br><p>  <em>Jendela program Terminal 1.9b selama operasi adaptor</em> </p><br><p>  <strong><em>Kesimpulan:</em></strong> </p><br><p>  ASM1051 MK memiliki modul perangkat keras UART.  Register untuk mengirim data memiliki alamat 0xC001.  Kecepatan data adalah 921600 baud.  Ada one stop bit.  Leg 41 adalah Tx dan Leg 40 adalah Rx (meskipun ini tidak akurat). </p><br><h2 id="nahodka--3">  Temukan nomor 3 </h2><br><p>  Menggulir kode di disassembler, menambahkan komentar, Anda dapat menemukan konstruksi lebih sulit daripada menulis nomor dalam register.  Jadi saya menemukan penangan yang menarik, yang sebagian di C, tampak seperti <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/zq/ra/nr/zqranrtexseqh7xpj0ynpjav9su.png"><br><p>  <em>Penangan perintah dari register dengan alamat 0x800F</em> </p><br><p>  Memahami bahwa di suatu tempat <a href="https://en.wikipedia.org/wiki/SCSI_command">perintah SCSI</a> harus diproses, saya mulai mencari di antara mereka untuk byte yang isi register dengan alamat 0x800F dibandingkan pada gambar di atas.  Ternyata empat cabang pertama memeriksa perintah Baca (10), Tulis (10), Baca (16), Tulis (16).  Tidak ada keraguan bahwa ini adalah penangan perintah SCSI.  Selanjutnya, saya melihat fungsi yang dipanggil jika perintah yang masuk tidak Baca / Tulis (u_Switch).  Itu, tergantung pada byte dalam register dengan alamat 0x16A (nilainya diambil dari 0x800F), membaca alamat yang akan kita dapatkan ketika mereka keluar dari fungsi ini.  Ini mirip dengan <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/8c/ni/xf/8cnixfxf9a1bcyzv0ttlsgpmcqo.png"><br><p>  <em>Ganti Perintah SCSI</em> </p><br><p>  Karena saya sudah menentukan byte yang saya bandingkan dengan perintah SCSI yang datang ke adaptor, saya dengan cepat mengatur korespondensi alamat dengan perintah.  Jadi, misalnya, pada gambar di atas dapat dilihat bahwa jika byte 0x1A berada dalam register dengan alamat 0x16A, maka setelah keluar dari fungsi u_Switch kita akan pergi ke alamat 0x1B85.  Menariknya, tidak semua byte yang dibandingkan dengan u_Switch didefinisikan dalam standar SCSI.  Artinya, adaptor dapat memproses byte 0xE6 atau 0xDF, tetapi tidak diperbaiki oleh standar. </p><br><p>  Seperti yang Anda lihat, adaptor dapat menjalankan perintah khusus dan ada fungsi handler untuknya. </p><br><img src="https://habrastorage.org/webt/4m/kn/bz/4mknbzam6xol2fhb750trvrxs_c.png"><br><p>  <em>Halaman 13 dari <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Kelas Penyimpanan Massal Universal Serial Bus</a></em> </p><br><p>  Perhatikan offset <strong>0x0F</strong> relatif terhadap alamat 0x8000.  Sebelum prosesor, dari register dengan alamat 0x800F perintah SCSI dibaca.  Jika Anda hati-hati membaca tabel pada gambar di atas, Anda dapat melihat bahwa di Command Block Wrapper (CBW), bidang CBWCB juga memiliki offset <strong>0x0F</strong> .  Ternyata alamat memori ASM1051 RAM, dimulai dengan 0x8000, dapat berupa buffer USB, seperti yang ditunjukkan pada tabel di bawah ini. </p><br><div class="scrollable-table"><table><thead><tr><th>  Alamat memori </th><th>  Deskripsi </th></tr></thead><tbody><tr><td>  0x8000-0x8003 </td><td>  dCBWSignature (USBC - dalam hal menerima paket) </td></tr><tr><td>  0x8004-0x8007 </td><td>  dCBWTag </td></tr><tr><td>  0x8008-0x800B </td><td>  dCBWDataTransferLength </td></tr><tr><td>  0x800C </td><td>  bmdCBWFlag </td></tr><tr><td>  0x800D </td><td>  bCBWLUN </td></tr><tr><td>  0x800E </td><td>  bCBWCPanjang </td></tr><tr><td>  0x800F-0x801F </td><td>  CBWCB - perintah SCSI dan parameternya </td></tr></tbody></table></div><br><p>  Gambar di bawah ini menunjukkan bagian kode di mana perbandingan dengan string USBC terjadi (harus berupa tanda tangan dCBWSignature) dan tanda tangan yang diusulkan terletak dari alamat 0x8000.  Saya pikir ini cukup untuk memastikan bahwa buffer USB terletak di memori RAM mulai dari 0x8000. </p><br><img src="https://habrastorage.org/webt/-t/et/eo/-teteok9i6rotmpp1w6wxy0bun4.png"><br><p>  <em>Periksa bidang dCBWSignature untuk kecocokan dengan string USBC</em> </p><br><p>  <strong><em>Kesimpulan:</em></strong> </p><br><ol><li>  MK ASM1051 tidak hanya dapat menangani perintah SCSI, yang dijelaskan dalam standar. </li><li>  Alamat awal buffer USB adalah 0x8000.  Perintah SCSI terletak di register dengan alamat 0x800F, yang berarti bahwa akan ada data / argumen lebih lanjut dari perintah. </li></ol><br><h2 id="nahodka--4">  Temukan nomor 4 </h2><br><p>  Mengetahui bahwa MK dapat memproses tim yang tidak standar, saya ingin tahu apa yang mereka lakukan.  Kebanyakan dari mereka dengan cepat menaati saya.  Saya tidak akan mengutip studi kode dari perintah-perintah ini, karena ini bisa memakan waktu lama dan mungkin menjadi bahan untuk artikel terpisah yang berjudul "Assembler itu sederhana," Saya akan menjelaskan hasil dalam tabel di bawah ini. </p><br><div class="scrollable-table"><table><thead><tr><th>  Perintah SCSI </th><th>  Deskripsi tim </th></tr></thead><tbody><tr><td>  0xE0 </td><td>  Memungkinkan Anda membaca 0x80 byte pertama dari ROM.  Di masa depan, saya akan menyebut bagian memori ini sebagai <em>pembukaan</em> (ya, 0x80 byte yang sama di mana ada baris <code>asmedia</code> dan <code>ASM1051</code> ) </td></tr><tr><td>  0xE1 </td><td>  Menulis 0x80 byte pertama ke ROM </td></tr><tr><td>  0xE3 </td><td>  Menulis ke memori ROM dari 0x80 alamat sejumlah byte.  Argumennya (ternyata) adalah ukuran paket </td></tr><tr><td>  0xE4 </td><td>  Membaca blok byte dari ASM1051 RAM.  Sebagai argumen, ambil alamat awal dan jumlah byte yang kita baca </td></tr><tr><td>  0xE5 </td><td>  Menulis satu byte ke RAM pada </td></tr><tr><td>  0xE7 </td><td>  Membaca paket yang diterima terakhir ke dalam buffer ATA. </td></tr><tr><td>  0xE8 </td><td>  Reboot perangkat </td></tr></tbody></table></div><br><p>  Saya akui bahwa saya tidak mengetahui semua perintah dengan membaca fungsi di IDA.  Setelah menabrak dinding selama penelitian, saya ingat bahwa saya melihat <a href="https://www.usbdev.ru/files/asmedia/asm105mptool/">perangkat lunak dan banyak firmware</a> untuk ASM1051 ketika saya sedang mencari dokumentasi di dalamnya.  Dengan menggunakan perangkat lunak yang ditemukan, Anda dapat memperbarui firmware dan menyalakan ulang perangkat.  Oleh karena itu, saya memutuskan bahwa sudah waktunya untuk menggunakan <a href="https://www.syssoft.ru/HHD-Software/Device-Monitoring-Studio/">Device Monitoring Studio</a> dan melihat apa yang mengirim PC ke adaptor selama pembaruan. </p><br><p>  Dengan demikian, dimungkinkan untuk memahami bagaimana proses pembaruan firmware terjadi: pertama pembukaan dibuka (dengan perintah 0xE1), kemudian kode ditulis dengan perintah 0xE3, kemudian semua ini dipoles dengan me-reboot (perintah 0xE8).  Untuk pembaruan yang cepat dan mudah, saya menulis skrip Python yang menyisipkan baris yang diperlukan ke dalam pembukaan, kemudian membaca jumlah cek dan memperbarui perangkat.  Sekarang saya tidak lagi membutuhkan emulator, saya mendapat kesempatan untuk mengunggah firmware ke ASM1051 melalui USB, Anda dapat mengembalikan ROM asli ke papan. </p><br><p>  <strong><em>Kesimpulan</em></strong> </p><br><p>  Untuk memperbarui firmware, tiga perintah SCSI harus dijalankan secara berurutan: 0xE1, 0xE3 dan 0xE8. </p><br><h2 id="nahodka--5">  Temukan nomor 5 </h2><br><p>  Selain perintah tidak berdokumen, itu menarik untuk melihat penangan perintah standar. </p><br><img src="https://habrastorage.org/webt/be/9e/st/be9estiir9g45o0thkj4bacvsmm.png"><br><p>  <em>Memindahkan bit ketiga dari register 0xC884 ke bit ketujuh register 0x8002</em> </p><br><p>  Ada satu tes menarik dalam penangan perintah MODE SENSE (10) SCSI.  Gambar di atas menunjukkan bagian dari kode fungsi.  Dapat dilihat bahwa bit ketiga sedang dibaca dari register <strong>0xC884</strong> .  Kemudian nilai bit ini diatur dalam register pada 0x8002. </p><br><p>  Yang menarik di sini adalah bahwa register <strong>0xC884</strong> tidak diinisialisasi di mana pun dalam kode, yang berarti kemungkinan besar perangkat keras. </p><br><img src="https://habrastorage.org/webt/fc/mw/sh/fcmwsh6pa3zzkpbsfxxici-t4g4.jpeg"><br><p>  <em>Tabel 362 <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Manual Referensi Perintah SCSI</a></em> </p><br><p>  Selain itu, jika Anda melihat dokumentasi untuk <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">perintah</a> 0x5A <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">SCSI</a> (MODE SENSE), menjadi jelas bahwa adaptor USB-SATA harus menanggapi permintaan MODE SENSE.  Byte ketiga dari respons berisi bit ketujuh dari WP (Write Protect - write protection).  By the way, saya sudah melihat bit <strong>ketujuh</strong> di 0x8002, dan <strong>offset</strong> dari awal buffer USB (0x8000) persis <strong>3 di sini</strong> . </p><br><p>  <strong><em>Kesimpulan:</em></strong> </p><br><p>  Adaptor USB-SATA yang teruji membaca bit ketiga dari register perangkat keras pada <strong>0xC884</strong> dan mengirimkannya ke host USB sebagai bit WP. </p><br><h2 id="nahodka--6">  Temukan nomor 6 </h2><br><p>  Register perangkat keras yang ditemukan selama penyelidikan MODE SENSE SCSI handler sangat mirip dengan GPIO.  Untuk mengkonfirmasi ini, saya memutuskan untuk menyentuh kaki ASM1051 dengan resistor langsung dan membaca nilai register (perintah SCSI 0xE4) dengan alamat <strong>0xC884</strong> .  Untuk melakukan ini, saya menulis skrip Python menggunakan perintah SCSI khusus yang memantau nilai dalam register <strong>0xC884</strong> dan menampilkannya di PC. </p><br><div class="scrollable-table"><table><thead><tr><th>  Bit 0xC884 </th><th>  7 </th><th>  6 </th><th>  5 </th><th>  4 </th><th>  3 </th><th>  2 </th><th>  1 </th><th>  0 </th></tr></thead><tbody><tr><td>  Kaki ASM1051 </td><td>  - </td><td>  - </td><td>  37 </td><td>  - </td><td>  9 </td><td>  10 </td><td>  45 </td><td>  44 </td></tr></tbody></table></div><br><p>  Setelah melakukan percobaan seperti itu, saya menyusun tabel di mana saya menampilkan bit mana dalam register <strong>0xC884 yang</strong> berubah ketika resistor ASM1051 menyentuh kaki.  Ternyata register yang diteliti terkait erat dengan GPIO, tetapi upaya untuk menulisnya (dengan perintah SCSI 0xE5) tidak berhasil - nilainya tidak berubah. </p><br><p>  Kemudian saya memutuskan bahwa register ini hanya baca-saja, atau di suatu tempat menulisnya dilarang di tingkat perangkat keras.  Jika, misalnya, kaki-kaki MK awalnya diatur hanya untuk membaca, maka, mungkin, menulis ke register <strong>0xC884</strong> bisa jadi tidak tersedia. </p><br><p>  Secara umum, untuk menemukan register yang terkait dengan GPIO, saya membahas kode inisialisasi MK.  Saya mencatat semua register yang alamatnya dekat dengan <strong>0xC884</strong> .  Saya mendapat sekitar 10 dari mereka, saya mengingatkan Anda bahwa kaki kesepuluh dari MK terhubung ke LED di papan, itu sesuai dengan bit kedua di register <strong>0xC884</strong> .          – <strong>0880</strong> ,            (,    ).  ,   ,   <strong>0880</strong>      (/),   <strong>0884</strong>   ,  - . </p><br><p>         <strong>0880</strong>    ,    <strong>0884</strong>    .     <strong>0884</strong>  .           ASM1051. </p><br><p> <strong><em>:</em></strong> </p><br><p>    GPIO  ASM1051.    <strong>0880</strong>   /   I/O.  0884    I/O. </p><br><h2 id="nahodka--5-prodolzhenie">  № 5.  </h2><br><p>   GPIO-  ,  45-           <strong>0884</strong> .           <strong>WP</strong> ,    USB.       45-    ,    HDD,     ,  . </p><br><img src="https://habrastorage.org/webt/9m/yq/lv/9myqlvzd8guku1qfcllendjrtcc.png"><br><p> <em>     HDD,      45-  </em> </p><br><p>     .       GND 45-      ,      HDD.     . </p><br><p> <strong><em></em></strong> </p><br><p>   45-  ASM1051         HDD. </p><br><h1 id="razrabotka-sobstvennogo-ustroystva">    </h1><br><p>       USB-SATA-.           ASM1051.   ,  -  ,     .   ,     GPIO.    –  ASM1051  ,         HDD. ,   ,     («     »),     ,  ,         USB-SATA-   ASM1051. </p><br><p> ,           footprint  ASM1051,       datasheet  ASM1053.     ,        ASM1051   . </p><br><img src="https://habrastorage.org/webt/mf/9k/pi/mf9kpiav5oxxejflxjfndixzccy.jpeg"><br><p> <em>ASM1051     </em> </p><br><p>    ,       3D- ,    . </p><br><img src="https://habrastorage.org/webt/4n/vk/ea/4nvkearirndsx2wx6lzbv2--iu0.png"><br><p> <em>3D-      </em> </p><br><p>            <strong>WP</strong> .  GPIO ASM1051      ,   UART.  ,      SATA,     HDD.      USB 3.0 Micro-B     Type-C.  HDD      USB,   HDD 3.5"  +12 ,           12  21 .     . </p><br><img src="https://habrastorage.org/webt/zh/ji/wu/zhjiwuyqzibs09gswjbdlths-_g.jpeg"><br><p> <em>    </em> </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>       ,       . </p><br><p>           -,    ,   .         « «»,          .        ,       . </p><br><p>   ,    (,   )   embedded-. ,  ,       .      ,    ,    , ,         . </p><br><p>       ,   datasheets,    ,   .       ,  <strong>   !</strong> </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p> <em>Raccoon Security –     «»     , , ,       .</em> <br> <em>        ,         ,     .       <a href="https://raccoonsecurity.ru/internship/"></a> .</em> </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485966/">https://habr.com/ru/post/id485966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485946/index.html">Lightning Talk: Anatoly Wasserman di Slurm DevOps</a></li>
<li><a href="../id485950/index.html">Epidemi dan penyensoran: apakah pihak berwenang Cina berusaha menahan penyebaran informasi tentang coronavirus?</a></li>
<li><a href="../id485954/index.html">Java digest untuk 28 Januari</a></li>
<li><a href="../id485958/index.html">[Ringkasan Admin] Bagaimana jika program menginginkan hak administrator dan Anda tidak</a></li>
<li><a href="../id485962/index.html">Penelitian pribadi pada 2019-nCoV</a></li>
<li><a href="../id485968/index.html">Dan lagi memotong kunci. RouterOS + BGP + OSPF</a></li>
<li><a href="../id485970/index.html">Tiga puluh wawancara top baru-baru ini: pengembangan, desain, sciencepop dan gaya hidup</a></li>
<li><a href="../id485972/index.html">Metode Analisis Regresi dalam Ilmu Data</a></li>
<li><a href="../id485974/index.html">Raspberry Pi dan SIM7600E 4G HAT Modem</a></li>
<li><a href="../id485986/index.html">5 Tren Pelokalan Teratas di 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>