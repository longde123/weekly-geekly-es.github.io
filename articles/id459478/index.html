<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêá ü¶ç ü§• Pengalaman saya dalam membuat aplikasi multi-utas untuk bekerja dengan cadangan üëµ üßì üïµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, Anda tidak akan mengejutkan siapa pun dengan aplikasi multithread, tetapi saya pikir dalam artikel ini Anda dapat menemukan beberapa ide men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman saya dalam membuat aplikasi multi-utas untuk bekerja dengan cadangan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459478/"><p>  Saat ini, Anda tidak akan mengejutkan siapa pun dengan aplikasi multithread, tetapi saya pikir dalam artikel ini Anda dapat menemukan beberapa ide menarik.  Pelajaran saya tentang Jawa dimulai dengan proyek khusus ini, jadi mungkin di beberapa tempat saya akan sangat salah atau membangun sepeda besar, tetapi saya berharap seseorang akan tertarik dengan pengalaman seorang pemula di Jawa.  Saya akan memberikan beberapa fitur aplikasi: </p><br><ul><li>  Ini bekerja dengan cadangan secara eksklusif di memori, terlepas dari ukuran cadangan </li><li>  Tidak memuat seluruh cadangan ke dalam memori </li><li>  Operasi pencadangan / pengembalian dapat dibatalkan </li></ul><br><p>  Di bawah cut akan dianggap arsitektur aplikasi, serta masalah utama yang dihadapi dan solusinya. </p><a name="habracut"></a><br><h2 id="obzor-prilozheniya">  Ikhtisar Aplikasi </h2><br><p>  Komunikasi dengan aplikasi terjadi melalui Web UI, tetapi di masa mendatang akan dimungkinkan untuk menambahkan REST API jika perlu. </p><br><p>  Aplikasi dapat: </p><br><ol><li>  Buat cadangan dan unggah ke satu atau beberapa penyimpanan </li><li>  Kembalikan cadangan dengan memuatnya dari penyimpanan </li><li>  Hapus cadangan dari semua penyimpanan </li><li>  Buat cadangan secara berkala </li></ol><br><p>  Repositori yang saat ini didukung: </p><br><ul><li>  Sistem file lokal (tidak didukung dari Docker) </li><li>  Dropbox </li></ul><br><p>  Database yang saat ini didukung: </p><br><ul><li>  PostgreSQL </li></ul><br><p>  Dari aplikasi khusus, saya dapat mencatat: </p><br><ol><li>  Pekerjaan yang benar dalam konfigurasi cluster </li><li>  Cadangan tidak pernah dimuat penuh ke dalam memori, terlepas dari ukuran cadangan.  Sistem file untuk penyimpanan cadangan sementara juga tidak terlibat.  Baik pembuatan cadangan maupun pemulihan, dan karenanya pemuatan / pembongkaran cadangan, terjadi secara eksklusif di memori. </li><li>  Cross-platform - berfungsi pada Windows dan Linux. </li><li>  Kami dapat memantau semua tugas yang berjalan dan membatalkannya jika perlu. </li></ol><br><p>  Di bawah ini adalah tangkapan layar dari Web UI yang menggambarkan dengan jelas fitur-fitur aplikasi. </p><br><div class="spoiler">  <b class="spoiler_title">Manajemen penyimpanan</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vl/qg/n5/vlqgn5f58ub5jhxixeeg2uq-oa8.png" title="Menambahkan Penyimpanan"></a> <br> <a href=""><img src="https://habrastorage.org/webt/oj/o5/uj/ojo5uj_raxkwd1btsjrktiowifo.png" title="Daftar penyimpanan"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Manajemen basis data</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wn/6p/bk/wn6pbkcqg4qu_9btgrvnqm3l7x0.png" title="Menambahkan Database"></a> <br> <a href=""><img src="https://habrastorage.org/webt/wu/9a/4k/wu9a4ky7icuiyqdxeiii9xbu5d8.png" title="Daftar basis data"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Pembuatan cadangan</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/1d/zb/6s/1dzb6scvtua5v3m_3l11lch4rgm.png" title="Pembuatan cadangan"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Pemulihan cadangan</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/gj/9f/w0/gj9fw0onqw7f0lf7ycw05aphinc.png" title="Pemulihan cadangan"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Kelola cadangan yang dibuat</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/sy/jz/y6/syjzy68wqxgi8smgq74giqstgu0.png" title="Daftar cadangan yang dibuat"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Pencadangan berkala</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/hk/pw/tg/hkpwtg3kf7c5ho3f7ae7_uos7v0.png" title="Buat tugas berkala"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Lacak tugas yang sedang berjalan</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/al/dt/su/aldtsuel4amtjlvbbbusccxddh0.png" title="Daftar tugas yang sedang berjalan"></a> </p></div></div><br><hr><br><h2 id="arhitektura">  Arsitektur </h2><br><p>  Pekerjaan utama akan berlangsung di 3 layanan - <em>DatabaseBackup</em> , <em>Prosesor</em> , <em>Penyimpanan</em> , dan kami akan menghubungkan mereka bersama-sama menggunakan <em>konsep tugas</em> .  Tentang semua ini lebih jauh. </p><br><h3 id="databasebackup">  Databasebackup </h3><br><p>  Layanan ini bertanggung jawab untuk membuat dan memulihkan cadangan teks biasa. </p><br><p>  Antarmuka Layanan: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseBackup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Kedua metode antarmuka beroperasi pada instance <strong>InputStream</strong> , karena kita membutuhkan seluruh cadangan untuk tidak dimuat ke dalam memori, yang berarti bahwa cadangan tersebut harus dibaca / ditulis dalam mode streaming.  Entitas <em>DatabaseSettings</em> dibuat sebelumnya dari UI Web dan menyimpan berbagai pengaturan yang diperlukan untuk mengakses database.  Apa parameter ini - <code>id</code> - akan dijelaskan sedikit lebih jauh. </p><br><p>  Persyaratan layanan adalah sebagai berikut: </p><br><ol><li>  Kedua metode seharusnya tidak membaca seluruh cadangan ke dalam memori. </li><li>  Metode <code>restoreBackup()</code> harus mengembalikan cadangan dalam satu transaksi, sehingga jika terjadi kesalahan, jangan biarkan database dalam keadaan tidak konsisten. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Implementasi untuk PostgreSQL (deskripsi teks)</b> <div class="spoiler_text"><p>  Secara khusus, dalam implementasi untuk PostgreSQL, layanan diimplementasikan sebagai berikut: </p><br><ol><li>  <code>createBackup()</code> : proses <em>pg_dump</em> dibuat yang akan membuat cadangan dan menuliskannya ke aliran output standar.  Aliran output proses standar dikembalikan dari metode (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#getInputStream--</a> ).  I / O stream dalam sistem didasarkan pada buffer dengan ukuran tertentu, dan ketika suatu proses menulis ke aliran output, itu sebenarnya menulis ke buffer dalam memori.  Yang paling penting di sini adalah bahwa utas proses tidak akan menulis ke buffer yang <em>diisi</em> sampai yang terakhir telah dibaca oleh pihak lain, yang berarti utas akan dalam keadaan terkunci dan cadangan tidak akan dimuat sepenuhnya ke dalam memori.  Anda mungkin pernah mengalami situasi di mana program Java Anda menemui jalan buntu saat bekerja dengan proses karena Anda tidak membaca stdout atau stderr proses.  Sangat penting untuk memantau ini, karena proses tidak dapat dilanjutkan jika diblokir pada panggilan pemblokiran I / O saat menulis ke buffer penuh dan tidak ada yang membaca buffer ini. </li><li>  <code>restoreBackup()</code> : proses <em>psql</em> dibuat, cadangan dibaca dari InputStream yang diteruskan ke metode dan secara simultan ditulis ke aliran input standar psql (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process. html # getOutputStream--</a> ).  Ini berfungsi karena cadangan teks biasa PostgreSQL hanyalah kumpulan perintah DDL dan DML yang mudah dimengerti psql. </li></ol><br><p>  Ada banyak kode, jadi saya tidak akan memberikannya di sini, tetapi Anda dapat melihatnya di GitHub menggunakan tautan di akhir artikel. </p></div></div><br><h3 id="processor">  Prosesor </h3><br><p>  Layanan ini bertanggung jawab untuk penggunaan prosesor dan membalikkan pemrosesan ulang cadangan.  Prosesor digunakan sebelum mengunduh ke penyimpanan atau setelah membongkar dari penyimpanan.  Contoh prosesor: kompresor, enkripsi. </p><br><p>  Antarmuka Layanan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ProcessorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ProcessorType -  Enum,     int getPrecedence(); //   }</span></span></code> </pre> <br><p>  Setiap prosesor memiliki prioritas - jika beberapa prosesor ditentukan, mereka akan diterapkan dalam urutan prioritas yang menurun.  Menerapkan fungsi terbalik dalam urutan yang sama ketika prosesor diterapkan, kami mendapatkan cadangan asli. </p><br><h3 id="storage">  Penyimpanan </h3><br><p>  Layanan ini bertanggung jawab untuk memuat dan membongkar cadangan, serta menghapusnya dari penyimpanan.  Contoh penyimpanan: Dropbox, sistem file lokal. </p><br><p>  Antarmuka Layanan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Setiap cadangan yang dibuat diberi nama unik - jadi kami dapat menemukannya di penyimpanan mana pun yang diunduh.  Cara cadangan disajikan ke penyimpanan adalah masalah implementasi layanan secara eksklusif, tetapi ketika mentransfer nama cadangan ke salah satu fungsi, kita harus mengharapkan perilaku yang benar.  Entitas <em>StorageSettings</em> sudah dibuat sebelumnya dari UI Web dan menyimpan pengaturan yang diperlukan untuk mengakses penyimpanan. </p><br><hr><br><h3 id="koncepciya-taskov">  Konsep tugas </h3><br><p>  Kami ingin dapat melacak status tugas kami, menangani kemungkinan kesalahan tergantung pada kemajuan tugas, dan juga membatalkan tugas.  Karena itu, kami akan terus beroperasi hanya dengan tugas.  Setiap tugas akan diwakili dalam database dengan catatan dalam tabel, dan secara terprogram oleh instance <strong>Future</strong> (lihat Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Future</a> ).  Setiap catatan dalam tabel dikaitkan dengan masa depannya sendiri (apalagi, jika beberapa server berjalan, contoh masa depan dapat di memori server yang berbeda). </p><br><p>  Mari kita berurutan.  Pertama-tama, kami membutuhkan layanan untuk meluncurkan tugas - membuat, memulihkan, dan menghapus cadangan. </p><br><h4 id="zapusk-zadach">  Peluncuran tugas </h4><br><p>  <strong>Membuat cadangan:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startBackupTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull List&lt;String&gt; storageSettingsNameList, @Nullable List&lt;ProcessorType&gt; processors, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(storageSettingsNameList); Objects.requireNonNull(processors); Objects.requireNonNull(databaseSettings); BackupProperties backupProperties = backupPropertiesManager.initNewBackupProperties(storageSettingsNameList, processors, databaseSettings.getName()); Task task = tasksManager.initNewTask(Task.Type.CREATE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.CREATING); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream backupStream = databaseBackupManager.createBackup(databaseSettings, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_PROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Applying processors on created backup. Processors: {}"</span></span>, processors); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream processedBackupStream = backupProcessorManager.process(backupStream, processors)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.UPLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Uploading backup..."</span></span>); backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of created backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while creating backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Backup creating task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Membuat cadangan berjalan melalui 3 langkah utama dalam urutan berikut: membuat cadangan -&gt; aplikasi prosesor -&gt; mengunggah ke penyimpanan.  Di hampir semua metode layanan, kami meneruskan ID tugas saat ini sehingga layanan dapat melaporkan kesalahan dari utas yang berfungsi di latar belakang.  Tentang penanganan kesalahan, mengapa <em>InterruptedException di</em> sini dan apa yang terjadi dengan kesalahan setelah menerima <em>RuntimeException</em> akan dibahas nanti. </p><br><p>  Dan inilah cara kita menjalankan tugas membuat cadangan: </p><br><pre> <code class="java hljs">tasksStarterService.startBackupTask(Task.RunType.USER, storageSettingsNameList, processors, databaseSettings);</code> </pre> <br><p>  Parameter pertama yang kami berikan ke inisiator tugas: tugas pengguna atau server internal (contoh tugas internal adalah cadangan berkala).  Pengetahuan tentang inisiator tugas memungkinkan kami untuk menampilkan di UI Web hanya tugas-tugas yang diluncurkan oleh pengguna.  Parameter yang tersisa diperlukan untuk membuat cadangan secara langsung - daftar penyimpanan, prosesor yang akan digunakan, database yang dump Anda perlu buat. </p><br><p>  Saat membuat cadangan, catatan juga dibuat dalam database yang disebut <strong>BackupProperties</strong> .  Entitas ini akan menyimpan properti cadangan seperti nama, prosesor yang digunakan, dan daftar repositori tempat cadangan diunduh.  Selanjutnya, untuk mengembalikan atau menghapus cadangan, kami akan beroperasi dengan entitas khusus ini. </p><br><p>  Tugas dalam database disimpan dalam bentuk berikut: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"backup_tasks"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of each backup task. Identifier is generated by PostgreSQL database after saving of entity. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task type. * &lt;p&gt; * Type is set at the very start of any task and can't be changed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Type */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Type type; <span class="hljs-comment"><span class="hljs-comment">/** * Who initiated a task: user or server. * &lt;p&gt; * We need to know it to show on front only these tasks that was started by user. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> RunType */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RunType runType; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task state. * &lt;p&gt; * State is updated with every new step in task being executed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Task.State */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> State state; <span class="hljs-comment"><span class="hljs-comment">/** * Whether task has been interrupted or not. * &lt;p&gt; * Default is {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> false}. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted; <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties}. * &lt;p&gt; * We need to know backup ID to be able to handle occurred errors. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer backupPropertiesId; <span class="hljs-comment"><span class="hljs-comment">/** * Start time of the task. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime date; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RunType { USER, INTERNAL } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { PLANNED, CREATING, RESTORING, DELETING, APPLYING_PROCESSORS, APPLYING_DEPROCESSORS, DOWNLOADING, UPLOADING, COMPLETED, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { CREATE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CREATE BACKUP"</span></span>; } }, RESTORE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"RESTORE BACKUP"</span></span>; } }, DELETE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DELETE BACKUP"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters... }</span></span></code> </pre> <br><p>  Dengan demikian, Anda dapat menggambarkan proses membuat cadangan dalam bentuk diagram sebagai berikut: <br><img src="https://habrastorage.org/webt/bm/um/cy/bmumcyhyapjg4ono73qo8kiquom.png" alt="Proses pencadangan" title="Proses pencadangan"></p><br><hr><br><p>  Jenis tugas lain diluncurkan dengan analogi.  Agar tidak mengacaukan artikel dengan sejumlah besar kode, bagi yang penasaran saya akan memberikan kode untuk meluncurkan tugas untuk mengembalikan dan menghapus cadangan secara terpisah di spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Pemulihan cadangan</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRestoreTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties, @NotNull String storageSettingsName, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Objects.requireNonNull(storageSettingsName); Objects.requireNonNull(databaseSettings); Task task = tasksManager.initNewTask(Task.Type.RESTORE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.DOWNLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Downloading backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream downloadedBackup = backupLoadManager.downloadBackup(backupProperties.getBackupName(), storageSettingsName, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted() || downloadedBackup == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_DEPROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Deprocessing backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream deprocessedBackup = backupProcessorManager.deprocess(downloadedBackup, backupProperties.getProcessors())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.RESTORING); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup..."</span></span>); databaseBackupManager.restoreBackup(deprocessedBackup, databaseSettings, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of downloaded backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.info(<span class="hljs-string"><span class="hljs-string">"Error occurred while restoring backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Memulihkan cadangan melalui 3 langkah utama dalam urutan berikut: membongkar cadangan dari penyimpanan -&gt; menggunakan deprocessor untuk mendapatkan cadangan teks biasa -&gt; memulihkan cadangan. </p><br><p>  Mulai pemulihan sebagai berikut: </p><br><pre> <code class="java hljs">tasksStarterService.startRestoreTask(Task.RunType.USER, backupProperties, storageSettingsName, databaseSettings);</code> </pre> <br><p>  Proses pemulihan cadangan dalam bentuk diagram: <br><img src="https://habrastorage.org/webt/hr/_m/bk/hr_mbkvfkszhyhj6ebi1q_wa1nc.png" alt="  " title="Proses pemulihan cadangan"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Hapus cadangan</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDeleteTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Task task = tasksManager.initNewTask(Task.Type.DELETE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup started. Backup properties: {}"</span></span>, backupProperties); tasksManager.updateTaskState(taskId, Task.State.DELETING); backupLoadManager.deleteBackup(backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup completed. Backup properties: {}"</span></span>, backupProperties); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while deleting backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Proses menghapus cadangan cukup sederhana: cadangan hanya dihapus dari semua penyimpanan yang diunduh. </p><br><p>  Jalankan uninstall sebagai berikut: </p><br><pre> <code class="java hljs">tasksStarterService.startDeleteTask(Task.RunType.USER, backupProperties);</code> </pre> <br><p>  Proses menghapus cadangan dalam bentuk diagram: <br><img src="https://habrastorage.org/webt/y4/ca/yp/y4cayp76w4v0tx8umvzcp6flzd4.png" alt="  " title="Proses penghapusan cadangan"></p></div></div><br><hr><br><h3 id="otmena-taskov">  Batalkan Tugas </h3><br><p>  Apakah pembatalan tugas itu?  Tentu saja, ini tidak lebih dari penghentian utas.  Anda bisa melihat bahwa semua kode utama yang berjalan di Future dibungkus dalam konstruksi try-catch berikut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { ... tasksManager.setInterrupted(taskId); }</code> </pre> <br><p>  Dan juga setelah setiap metode penting, alur eksekusi yang kami kontrol, konstruksi berikut dipasang: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); }</code> </pre> <br><p>  Sebelum melanjutkan, teori singkat tentang gangguan dan status utas JVM harus diberikan. </p><br><p>  Utas di JVM dapat memiliki status berikut: </p><br><ol><li>  Baru </li><li>  Runnable </li><li>  Waktunya menunggu </li><li>  Menunggu </li><li>  Dicekal </li><li>  Dihentikan </li></ol><br><p>  Kami hanya tertarik pada status Menunggu dan Jangka waktu.  <code>Object.wait()</code> di status <em>Menunggu</em> oleh metode <code>Object.wait()</code> , <code>Thread.join()</code> dan lainnya.  Utas ditransfer ke status <em>menunggu Jangka Waktu</em> (mis., Tunggu yang berlangsung selama periode waktu tertentu) menggunakan metode <code>Object.wait(timeout)</code> , <code>Thread.join(timeout)</code> , <code>Thread.sleep(sleeping)</code> dan lainnya. </p><br><p>  Yang paling penting di sini adalah jika Anda mengganggu utas <em>sebelum memasuki status</em> Menunggu atau Menunggu waktunya atau saat utas <em>dalam keadaan ini</em> , utas bangun, melempar <strong>InterruptedException</strong> . </p><br><p>  Tapi itu belum semuanya.  Sama sekali bukan fakta bahwa utas akan pernah masuk ke data negara dengan membuat, memulihkan, atau menghapus cadangan.  Lalu bagaimana cara memberi tahu utas bahwa itu terputus? </p><br><p>  Cara pertama adalah dengan memeriksa flag interupsi secara independen dengan menggunakan metode Thread.interrupted <code>Thread.interrupted()</code> atau <code>Thread.currentThread.isInterrupted()</code> .  Perbedaan antara keduanya adalah bahwa yang pertama memanggil metode private asli <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , memberikan <code>true</code> , yang menunjukkan bahwa flag interrupt akan dihapus, dan yang kedua passing <code>false</code> , membiarkan flag interrupt tidak tersentuh.  Pilihan antara kedua metode ini sepenuhnya tergantung pada situasi.  Ketika InterruptedException dilempar, bendera interrupt juga dihapus - ini perlu diingat. </p><br><p>  Tapi pasti ada cara yang lebih mudah - dan memang begitu.  Dalam aplikasi, ada sejumlah besar pekerjaan dengan aliran I / O, dan karenanya dengan metode I / O.  Tugas kami adalah memastikan bahwa ketika memanggil metode <code>read()</code> atau <code>write(int b)</code> pada aliran I / O, kesalahan terjadi saat interupsi, memberi tahu bahwa panggilan pemblokiran I / O terganggu.  Untungnya, Java memiliki pengecualian seperti itu - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InterruptedIOException</a> .  Namun, tidak semua metode aliran baca / tulis memantau gangguan utas, dan secara khusus hanya <em>PipedInputStream yang</em> memantaunya.  Oleh karena itu, di tempat-tempat di mana aliran ini tidak terlibat, kita harus memperluas metode baca / tulis sehingga ketika ada interupsi, InterruptedIOException dilemparkan.  Bahkan, ekstensi metode read () sudah cukup bagi saya dalam aplikasi hanya di satu tempat - ketika InputStream kembali dari metode unggah cadangan.  Ini adalah bagaimana kita bisa belajar tentang asal usul interupsi tanpa harus menempatkan pemeriksaan templat pada bendera di mana-mana.  Namun, penting untuk menangkap pengecualian ini secara terpisah dari IOException dan menanganinya secara terpisah.  Tentu saja, Anda tidak dapat melakukannya tanpa bantuan pemeriksaan templat bendera di beberapa tempat, tetapi sudah menjadi lebih baik. </p><br><p>  Penting juga untuk dicatat bahwa jika flag dikosongkan selama pemrosesan interupsi, selalu diperlukan untuk mengatur flag interrupt lagi sehingga setelah kembali dari metode kita dapat mengetahui tentang interupsi yang terjadi. </p><br><p>  Izinkan saya menjelaskan dengan sebuah contoh mengapa ini penting.  Misalkan kita mengunggah cadangan ke penyimpanan dalam metode unggah () dan terjadi interupsi.  Interupsi diproses, pekerjaan dihentikan dan metode kembali.  Gangguan tidak terjadi dengan santai - itu berarti bahwa kesalahan terjadi di suatu tempat, atau pengguna membatalkan tugas.  Apa pun alasannya, kita harus menghentikan semua pekerjaan di Masa Depan ini.  Tetapi jika Anda tidak mengatur flag interupsi lagi sebelum kembali dari metode boot, kita tidak akan pernah tahu di blok Future utama tentang interupsi yang terjadi. <br>  Contoh kode yang sama: </p><br><pre> <code class="java hljs">backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); &lt;-   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-comment"><span class="hljs-comment">//      ,      - ,    throw new InterruptedException(); }</span></span></code> </pre> <br><p>  Oleh karena itu, praktik yang baik untuk menangani <strong>InterruptedException</strong> atau <strong>InterruptedIOException</strong> sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">//  InterruptedIOException ... // re-interrupt the thread Thread.currentThread().interrupt(); }</span></span></code> </pre> <br><p>  Ya, kita bisa menangani interupsi, tetapi siapa yang benar-benar akan mengganggu utasnya? <br>  Untuk melakukan ini, kami akan membuat entitas lain yang disebut <em>CancelTask</em> , yang akan menyimpan ID tugas untuk pembatalan, dan juga menulis arloji yang akan mencoba mengganggu tugas.  Mengapa mencoba  Karena: </p><br><ol><li>  Tidak dapat mengakhiri utas di memori server lain.  Beberapa server dapat bekerja untuk kita, yang berarti Masa Depan tersebar di berbagai server.  Jadi, ketika permintaan untuk membatalkan tugas tiba di salah satu server, Masa Depan yang diinginkan mungkin ada di memori server lain. </li><li>  Tugas tidak dapat dibatalkan karena Masa Depan hilang karena server crash. </li></ol><br><p>  Jelaskan secara singkat algoritma pembatalan di malam hari: <br>  Watercher mengeluarkan semua catatan dari tabel <em>cancel_tasks</em> (kunci tidak diatur pada waktu yang sama), menelusuri masing-masing dan mencoba untuk mendapatkan Masa Depan yang sesuai dari ingatannya.  Jika Future berhasil diterima, utas yang terkait terputus, tugas dikembalikan dan permintaan dihapus dari tabel.  Jika permintaan batas waktu untuk membatalkan tugas terlampaui (yang berarti bahwa server macet dan Masa Depan hilang) - permintaan dihapus dari tabel.  Jika beberapa server melihat batas waktu dan menghapus catatan dari tabel, tidak ada hal buruk yang akan terjadi, karena penghapusan di PostgreSQL idempoten. </p><br><p>  <strong>CancelTasksWatcher Code:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for tasks to cancel and tries to cancel them. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CancelTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(CancelTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Duration cancelTimeout = Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CancelTasksManager cancelTasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksStarterService tasksStarterService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 10 seconds passed from the last completion, checks if there are any tasks to cancel and tries to * cancel each task. * &lt;p&gt; * Since there are can be working more that one instance of the program, {@literal Future} instance of task can belong to different * servers. We can't get access to {@literal Future} if it's not in memory of the server where task cancellation request was accepted. * So the purpose of this watcher is to be able cancel tasks that works in the other instance of program. Each server has this watcher * checking for available cancellation requests and if any, the watcher tries to cancel corresponding {@literal Future}. * If cancellation is successful task will be also reverted. * &lt;p&gt; * If task cancellation request timeout exceeded, then it means a server that had requested {@literal Future} instances has been * shutdown, so all {@literal Future} instances lost and task can't be canceled. In such case task cancellation request will be ignored. * * @see TasksStarterService#getFuture(Integer) * @see TasksManager#revertTask(Task) */ @Scheduled(fixedDelay = 10 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchTasksToCancel() { Iterable&lt;CancelTask&gt; cancelTasks = cancelTasksManager.findAll(); Iterable&lt;Task&gt; tasks = tasksManager.findAllById(StreamSupport.stream(cancelTasks.spliterator(), false) .map(CancelTask::getTaskId).collect(Collectors.toList())); Map&lt;Integer, Task&gt; tasksAsMap = StreamSupport.stream(tasks.spliterator(), false) .collect(Collectors.toMap(Task::getId, Function.identity())); List&lt;Integer&gt; taskIdsForDeleting = new ArrayList&lt;&gt;(); for (CancelTask cancelTask : cancelTasks) { Integer taskId = cancelTask.getTaskId(); Task task = tasksAsMap.get(taskId); if (task == null) { logger.error("Can't cancel task: no such entity with ID {}", taskId); taskIdsForDeleting.add(taskId); continue; } // timeout exceeded, that is server shutdown and lost all Future instances, so task can't be canceled if (LocalDateTime.now(ZoneOffset.UTC).isAfter(cancelTask.getPutTime().plus(cancelTimeout))) { logger.error("Can't cancel task: timeout exceed. Task ID: {}", taskId); taskIdsForDeleting.add(taskId); continue; } tasksStarterService.getFuture(taskId).ifPresent(future -&gt; { logger.info("Canceling task with ID {}", taskId); boolean canceled = future.cancel(true); if (canceled) { try { // give time to properly handle interrupt Thread.sleep(10000); } catch (InterruptedException e) { // should not happen } tasksManager.revertTask(task); } taskIdsForDeleting.add(taskId); logger.info("Task canceled: {}. Task ID: {}", canceled, taskId); }); } cancelTasksManager.deleteByTaskIdIn(taskIdsForDeleting); } }</span></span></code> </pre> </div></div><br><hr><br><h4 id="obrabotka-oshibok">  Menangani kesalahan </h4><br><p>    ,    ,   Future,    try-catch : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { ... errorTasksManager.addErrorTask(taskId); }</code> </pre> <br><p>     <em>RuntimeException</em>   ,     Future  ,         . </p><br><p>  <code>addErrorTask(taskId)</code>        ,   ID ,    . <br>      ?       ,    ,        ,   . </p><br><p>      : <br>                  ,        ,       .  ‚Äî  PostgreSQL <code>select for update</code> ,   select   <code>skip locked</code>      . ,  ,    <code>revertTask()</code> ,               . </p><br><p> <strong> ErrorTasksWatcher</strong> : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for erroneous tasks and handles them depending on their state. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ErrorTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer nRows = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ErrorTasksManager errorTasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 1 minute passed from the last completion, checks backup states periodically and handles erroneous * tasks if any. * &lt;p&gt; * The watcher handles at most N tasks as described by {@link #nRows} constant and skips already locked tasks. * When retrieving error tasks from database pessimistic lock is set. It allows safely run more than one copy of program, as no other * watcher can pick up already being handled error tasks. * &lt;p&gt; * If the server shutdowns while rows was locked, transaction will be rolled back and lock released, so these entities can be picked * up by the other running server. */ @Scheduled(fixedDelay = 60 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchErrorTasks() { for (ErrorTask errorTask : errorTasksManager.findFirstNAndLock(nRows)) { if (!errorTask.isErrorHandled()) { Integer backupTaskId = errorTask.getTaskId(); Optional&lt;Task&gt; optionalTask = tasksManager.findById(backupTaskId); if (!optionalTask.isPresent()) { logger.info("Can't handle erroneous task: no corresponding backup task entity. Backup task ID: {}", backupTaskId); continue; } tasksManager.revertTask(optionalTask.get()); errorTask.setErrorHandled(true); } } } }</span></span></code> </pre> </div></div><br><p> <strong> <code>revertTask(Task)</code> :</strong> </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This function reverts erroneous task by its entity. * &lt;p&gt; * Use this function only after canceling related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> Future}. * &lt;p&gt; * If the task was of the type {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Task.Type#CREATE_BACKUP} then related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties} will be deleted. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> task the entity */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revertTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task task)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(task); Task.State state = task.getState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DOWNLOADING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_DEPROCESSORS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESTORING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DELETING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. No extra actions required"</span></span>, state.toString()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_PROCESSORS: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Delete backup properties..."</span></span>, state.toString()); Integer backupPropertiesID = task.getBackupPropertiesId(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!backupPropertiesManager.existsById(backupPropertiesID)) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } backupPropertiesManager.deleteById(backupPropertiesID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPLOADING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Deleting backup from storage..."</span></span>, state); Integer backupPropertiesId = task.getBackupPropertiesId(); Optional&lt;BackupProperties&gt; optionalBackupProperties = backupPropertiesManager.findById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalBackupProperties.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tasksStarterService.startDeleteTask(Task.RunType.INTERNAL, optionalBackupProperties.get()); backupPropertiesManager.deleteById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: unknown state. Task info: {}"</span></span>, task); } } }</code> </pre> <br><p>   : </p><br><ol><li>     <em>DOWNLOADING</em> , <em>APPLYING_DEPROCESSORS</em> , <em>RESTORING</em> , <em>DELETING</em> ‚Äî    .      ,       . </li><li>     <em>CREATING</em> , <em>APPLYING_PROCESSORS</em> ‚Äî  ,       .      BackupProperties  ,       ( BackupProperties   Web UI    ). </li><li>     <em>UPLOADING</em> ‚Äî       .        BackupProperties   ,       .       . </li></ol></div></div><br><p> ,    .         ,    ? ,   ,    Future (  1),     ,          InputStream (  2). ,      2,   1            2    ? </p><br><p>  ,     ,    ,       .      Future (    1)     : </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Throwable t, @NotNull Integer taskId)</span></span></span><span class="hljs-function"> </span></span>{ logger.error(<span class="hljs-string"><span class="hljs-string">"Exception caught. Task ID: {}"</span></span>, taskId, t); Optional&lt;Future&gt; optionalFuture = tasksStarterService.getFuture(taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalFuture.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't cancel the Future of task with ID {}: no such Future instance"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> canceled = optionalFuture.get().cancel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canceled) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error canceling the Future of task with ID {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Task canceled. Task ID: {}"</span></span>, taskId); errorTasksManager.setError(taskId); } } }</code> </pre> <br><p>   ,     ,      ID  ,   ,    Future   -  ,  ID     . </p><br><p>    ,          ,     ,     ,         ,          . </p><br><p> <strong>  ,   :</strong> </p><br><p> ,   ,        ,    .       ‚Äî       Future. </p><br><p>   ,      ,    ,      I/O ,          ‚Äî     /   .     ,      .       : </p><br><ol><li>  ,  .     ,      ‚Äî     . </li><li>     ‚Äî     Future   ,   .  , /   ,  ,     (  ,     ‚Äî    IOException  ,        ,   ). </li></ol><br><p>  ,   ‚Äî            (   ID       ,  ,    ),        . </p><br><hr><br><p>  ,    ,        .      ,    ,             . </p><br><h3 id="plany-na-buduschee">    </h3><br><ol><li>  Web UI:   ,   .     ,      </li><li>     </li><li>      </li><li>     </li><li>     </li></ol><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>   : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Docker Hub</strong></a> </li></ul><br><p>   ,   !           ,       GitHub! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459478/">https://habr.com/ru/post/id459478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459464/index.html">Lua di Moskow 2019: wawancara dengan Roberto Jerusalem</a></li>
<li><a href="../id459466/index.html">Lua di Moskow 2019: Wawancara dengan Roberto Ierusalimschy</a></li>
<li><a href="../id459470/index.html">Bagian 4: Masih menjalankan Linux di RISC-V RISC-V</a></li>
<li><a href="../id459472/index.html">Heroku + Docker + Boot Musim Semi</a></li>
<li><a href="../id459474/index.html">Cara membuat teks yang diketik dengan sempurna dalam hitungan detik: makro di Word untuk mereka yang banyak menulis</a></li>
<li><a href="../id459480/index.html">Vivaldi: Bagaimana cara browser menghasilkan uang?</a></li>
<li><a href="../id459482/index.html">Bagaimana kami mengalahkan pohon kategori</a></li>
<li><a href="../id459484/index.html">Generasi Arduino. Apa yang ditemukan oleh siswa modern</a></li>
<li><a href="../id459488/index.html">Mode permainan khusus dalam konteks Roguelike</a></li>
<li><a href="../id459490/index.html">Trik kotor vendor CRM: apakah Anda akan membeli mobil tanpa roda?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>