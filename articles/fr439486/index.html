<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèª ü§î ‚èπÔ∏è Types de r√©f√©rence .NET vs types de valeur. Partie 1 üí¨ üôèüèø üî£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parlons d'abord des types de r√©f√©rence et des types de valeur. Je pense que les gens ne comprennent pas vraiment les diff√©rences et les avantages des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types de r√©f√©rence .NET vs types de valeur. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439486/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Parlons d'abord des types de r√©f√©rence et des types de valeur.  Je pense que les gens ne comprennent pas vraiment les diff√©rences et les avantages des deux.  Ils disent g√©n√©ralement que les types de r√©f√©rence stockent le contenu sur le tas et que les types de valeur stockent le contenu sur la pile, ce qui est faux. </p><br><p>  Discutons des vraies diff√©rences: </p><br><ul><li>  <em>Un type de valeur</em> : sa valeur est <strong>une structure enti√®re</strong> .  La valeur d'un type de r√©f√©rence est <strong>une r√©f√©rence</strong> √† un objet.  - Une structure en m√©moire: les types de valeurs contiennent uniquement les donn√©es que vous avez indiqu√©es.  Les types de r√©f√©rence contiennent √©galement deux champs syst√®me.  Le premier stocke ¬´SyncBlockIndex¬ª, le second stocke les informations sur un type, y compris les informations sur une table de m√©thodes virtuelles (VMT). </li><li>  Les types de r√©f√©rence peuvent avoir des m√©thodes qui sont remplac√©es lorsqu'elles sont h√©rit√©es.  Les types de valeur ne peuvent pas √™tre h√©rit√©s. </li><li>  Vous devez allouer de l'espace sur le tas pour une instance d'un type de r√©f√©rence.  Un type de valeur <em>peut</em> √™tre allou√© sur la pile ou il devient la partie d'un type de r√©f√©rence.  Cela augmente suffisamment les performances de certains algorithmes. </li></ul><br><p>  Cependant, il existe des caract√©ristiques communes: </p><br><ul><li>  Les deux sous-classes peuvent h√©riter du type d'objet et devenir ses repr√©sentants. </li></ul><br><p>  Regardons de plus pr√®s chaque fonctionnalit√©. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/z0/iq/m6/z0iqm6nihoilvykxs3el7zujlrk.jpeg"></a> </p><a name="habracut"></a><br><p>  Regardons de plus pr√®s chaque fonctionnalit√©. </p><br><h2 id="copying">  Copie </h2><br><p>  La principale diff√©rence entre les deux types est la suivante: </p><br><ul><li>  Chaque variable, classe ou structure champs ou param√®tres de m√©thode qui prennent un type de r√©f√©rence stockent <strong>une r√©f√©rence</strong> √† une valeur; </li><li>  Mais chaque variable, classe ou structure de champs ou param√®tres de m√©thode qui prennent un type de valeur stockent une valeur exacte, c'est-√†-dire une structure enti√®re. </li></ul><br><p>  Cela signifie que l'attribution ou la transmission d'un param√®tre √† une m√©thode copiera la valeur.  M√™me si vous modifiez la copie, l'original restera le m√™me.  Cependant, si vous modifiez des champs de type de r√©f√©rence, cela ¬´affectera¬ª toutes les pi√®ces avec une r√©f√©rence √† une instance d'un type.  Regardons le <br>  exemple: </p><br><pre><code class="cs hljs">DateTime dt = DateTime.Now; <span class="hljs-comment"><span class="hljs-comment">// Here, we allocate space for DateTime variable when calling a method, // but it will contain zeros. Next, let's copy all // values of the Now property to dt variable DateTime dt2 = dt; // Here, we copy the value once again object obj = new object(); // Here, we create an object by allocating memory on the Small Object Heap, // and put a pointer to the object in obj variable object obj2 = obj; // Here, we copy a reference to this object. Finally, // we have one object and two references.</span></span></code> </pre> <br><p>  Il semble que cette propri√©t√© produise des constructions de code ambigu√´ telles que le <br>  changement de code dans les collections: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create an array of such structures and initialize the Data field = 5 var array = new [] { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field array[0].Data = 4; // Let's check the value Console.WriteLine(array[0].Data);</code> </pre> <br><p>  Il y a une petite astuce dans ce code.  Il semble que nous obtenions d'abord l'instance de structure, puis attribuons une nouvelle valeur au champ Donn√©es de la copie.  Cela signifie que nous devrions obtenir √† nouveau <code>5</code> lors de la v√©rification de la valeur.  Cependant, cela ne se produit pas.  MSIL a une instruction distincte pour d√©finir les valeurs des champs dans les structures d'un tableau, ce qui augmente les performances.  Le code fonctionnera comme pr√©vu: le programme <br>  sortie <code>4</code> vers une console. </p><br><p>  Voyons ce qui se passera si nous modifions ce code: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field list[0].Data = 4; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  La compilation de ce code √©chouera, car lorsque vous √©crivez la <code>list[0].Data = 4</code> vous obtenez d'abord la copie de la structure.  En fait, vous appelez une m√©thode d'instance de type <code>List&lt;T&gt;</code> qui sous-tend l'acc√®s par un index.  Il prend la copie d'une structure √† partir d'un tableau interne ( <code>List&lt;T&gt;</code> stocke les donn√©es dans des tableaux) et vous renvoie cette copie √† partir de la m√©thode d'acc√®s √† l'aide d'un index.  Ensuite, vous essayez de modifier la copie, qui n'est pas utilis√©e plus loin.  Ce code est inutile.  Un compilateur interdit un tel comportement, sachant que les utilisateurs abusent des types de valeur.  Nous devons r√©√©crire cet exemple de la mani√®re suivante: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field. Then, let's save it again. var copy = list[0]; copy.Data = 4; list[0] = copy; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  Ce code est correct malgr√© sa redondance apparente.  Le programme <br>  sortie <code>4</code> vers une console. </p><br><p>  L'exemple suivant montre ce que j'entends par ¬´la valeur d'une structure est un <br>  structure enti√®re ¬ª </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } int x = 5; PersonInfo person; int y = 6; // Variant 2 int x = 5; int Height; int Width; int HairColor; int y = 6;</code> </pre> <br><p>  Les deux exemples sont similaires en termes d'emplacement des donn√©es en m√©moire, car la valeur de la structure est la structure enti√®re.  Il alloue la m√©moire pour elle-m√™me o√π elle se trouve. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } class Employee { public int x; public PersonInfo person; public int y; } // Variant 2 class Employee { public int x; public int Height; public int Width; public int HairColor; public int y; }</code> </pre> <br><p>  Ces exemples sont √©galement similaires en termes de localisation des √©l√©ments en m√©moire car la structure prend une place d√©finie parmi les champs de classe.  Je ne dis pas qu'ils sont totalement similaires car vous pouvez utiliser des champs de structure en utilisant des m√©thodes de structure. </p><br><p>  Bien s√ªr, ce n'est pas le cas des types de r√©f√©rence.  Une instance elle-m√™me se trouve sur le petit tas d'objets inaccessibles (SOH) ou le grand tas d'objets (LOH).  Un champ de classe contient uniquement la valeur d'un pointeur vers une instance: un nombre 32 ou 64 bits. </p><br><p>  Regardons le dernier exemple pour fermer le probl√®me. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } void Method(int x, PersonInfo person, int y); // Variant 2 void Method(int x, int HairColor, int Width, int Height, int y);</code> </pre> <br><p>  En termes de m√©moire, les deux variantes de code fonctionneront de mani√®re similaire, mais pas en termes d'architecture.  Il ne s'agit pas seulement de remplacer un nombre variable d'arguments.  L'ordre change car les param√®tres de m√©thode sont d√©clar√©s les uns apr√®s les autres.  Ils sont plac√©s sur la pile de la m√™me mani√®re. </p><br><p>  Cependant, la pile passe d'adresses sup√©rieures √† des adresses inf√©rieures.  Cela signifie que l'ordre de pousser une structure pi√®ce par pi√®ce sera diff√©rent de la pousser dans son ensemble. </p><br><h2 id="overridable-methods-and-inheritance">  M√©thodes rempla√ßables et h√©ritage </h2><br><p>  La prochaine grande diff√©rence entre les deux types est le manque de virtuel <br>  table de m√©thodes dans les structures.  Cela signifie que: </p><br><ol><li>  Vous ne pouvez pas d√©crire et remplacer des m√©thodes virtuelles dans des structures. </li><li>  Une structure ne peut en h√©riter une autre.  La seule fa√ßon d'√©muler l'h√©ritage est de mettre une structure de type de base dans le premier champ.  Les champs d'une structure ¬´h√©rit√©e¬ª iront apr√®s les champs d'une structure ¬´de base¬ª et cr√©eront un h√©ritage logique.  Les champs des deux structures co√Øncideront en fonction du d√©calage. </li><li>  Vous pouvez passer des structures √† du code non manag√©.  Cependant, vous perdrez les informations sur les m√©thodes.  En effet, une structure n'est qu'un espace en m√©moire, rempli de donn√©es sans les informations sur un type.  Vous pouvez le transmettre √† des m√©thodes non manag√©es, par exemple, √©crites en C ++, sans modifications. </li></ol><br><p>  L'absence d'une table de m√©thodes virtuelles soustrait une certaine partie de la ¬´magie¬ª de l'h√©ritage aux structures mais leur donne d'autres avantages.  Le premier est que nous pouvons transmettre des instances d'une telle structure √† des environnements externes (en dehors de .NET Framework).  Rappelez-vous, ce n'est qu'un souvenir <br>  gamme!  Nous pouvons √©galement prendre une plage de m√©moire de code non manag√© et convertir un type √† notre structure pour rendre ses champs plus accessibles.  Vous ne pouvez pas faire cela avec des classes car elles ont deux champs inaccessibles.  Il s'agit de SyncBlockIndex et d'une adresse de table de m√©thodes virtuelles.  Si ces deux champs passent au code non manag√©, ce sera dangereux.  En utilisant un tableau de m√©thodes virtuelles, on peut acc√©der √† n'importe quel type et le modifier pour attaquer une application. </p><br><p>  Montrons qu'il ne s'agit que d'une plage de m√©moire sans logique suppl√©mentaire. </p><br><pre> <code class="plaintext hljs">unsafe void Main() { int secret = 666; HeightHolder hh; hh.Height = 5; WidthHolder wh; unsafe { // This cast wouldn't work if structures had the information about a type. // The CLR would check a hierarchy before casting a type and if it didn't find WidthHolder, // it would output an InvalidCastException exception. But since a structure is a memory range, // you can interpret it as any kind of structure. wh = *(WidthHolder*)&amp;hh; } Console.WriteLine("Width: " + wh.Width); Console.WriteLine("Secret:" + wh.Secret); } struct WidthHolder { public int Width; public int Secret; } struct HeightHolder { public int Height; }</code> </pre> <br><p>  Ici, nous effectuons l'op√©ration impossible en typage fort.  Nous convertissons un type en un autre incompatible qui contient un champ suppl√©mentaire.  Nous introduisons une variable suppl√©mentaire √† l'int√©rieur de la m√©thode Main.  En th√©orie, sa valeur est secr√®te.  Cependant, l'exemple de code affichera la valeur d'une variable, introuvable dans aucune des structures √† l'int√©rieur de la m√©thode <code>Main()</code> .  Vous pouvez le consid√©rer comme une atteinte √† la s√©curit√©, mais les choses ne sont pas si simples.  Vous ne pouvez pas vous d√©barrasser du code non manag√© dans un programme.  La raison principale est la structure de la pile de threads.  On peut l'utiliser pour acc√©der au code non manag√© et jouer avec des variables locales.  Vous pouvez d√©fendre votre code contre ces attaques en randomisant la taille d'un cadre de pile.  Ou, vous pouvez supprimer les informations sur le registre <code>EBP</code> pour compliquer le retour d'une trame de pile.  Cependant, cela n'a plus d'importance pour nous maintenant.  Ce qui nous int√©resse dans cet exemple est le suivant.  La variable "secr√®te" va <strong>avant</strong> la d√©finition de la variable hh et ensuite dans la structure WidthHolder (√† diff√©rents endroits, en fait).  Alors, pourquoi avons-nous facilement obtenu sa valeur?  La r√©ponse est que la pile cro√Æt de droite √† gauche.  Les variables d√©clar√©es en premier auront des adresses beaucoup plus √©lev√©es, et celles d√©clar√©es plus tard auront des adresses inf√©rieures. </p><br><h2 id="the-behavior-when-calling-instance-methods">  Le comportement lors de l'appel de m√©thodes d'instance </h2><br><p>  Les deux types de donn√©es ont une autre caract√©ristique qui n'est pas √©vidente √† voir et peut expliquer la structure des deux types.  Il traite de l'appel des m√©thodes d'instance. </p><br><pre> <code class="plaintext hljs">// The example with a reference type class FooClass { private int x; public void ChangeTo(int val) { x = val; } } // The example with a value type struct FooStruct { private int x; public void ChangeTo(int val) { x = val; } } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); klass.ChangeTo(10); strukt.ChangeTo(10);</code> </pre> <br><p>  Logiquement, nous pouvons d√©cider que la m√©thode a un corps compil√©.  En d'autres termes, il n'y a pas d'instance d'un type qui poss√®de son propre ensemble de m√©thodes compil√©, semblable aux ensembles d'autres instances.  Cependant, la m√©thode appel√©e sait √† quelle instance elle appartient car une r√©f√©rence √† l'instance d'un type est le premier param√®tre.  Nous pouvons r√©√©crire notre exemple et il sera identique √† ce que nous avons dit auparavant.  Je n'utilise pas d√©lib√©r√©ment un exemple avec des m√©thodes virtuelles, car elles ont une autre proc√©dure. </p><br><pre> <code class="plaintext hljs">// An example with a reference type class FooClass { public int x; } // An example with a value type struct FooStruct { public int x; } public void ChangeTo(FooClass klass, int val) { klass.x = val; } public void ChangeTo(ref FooStruct strukt, int val) { strukt.x = val; } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); ChangeTo(klass, 10); ChangeTo(ref strukt, 10);</code> </pre> <br><p>  Je devrais expliquer l'utilisation du mot-cl√© ref.  Si je ne l'utilisais pas, j'obtiendrais une <strong>copie</strong> de la structure comme param√®tre de m√©thode au lieu de l'original.  Ensuite, je le changerais, mais l'original resterait le m√™me.  Je devrais retourner une copie modifi√©e d'une m√©thode √† un appelant (une autre copie), et l'appelant enregistrerait cette valeur dans la variable (une copie de plus).  Au lieu de cela, une m√©thode d'instance obtient un pointeur et l'utilise pour changer imm√©diatement l'original.  L'utilisation d'un pointeur n'influence pas les performances car toutes les op√©rations au niveau du processeur utilisent des pointeurs.  Ref fait partie du monde C #, pas plus. </p><br><h2 id="the-capability-to-point-to-the-position-of-elements">  La capacit√© de pointer vers la position des √©l√©ments. </h2><br><p>  Les structures et les classes ont une autre capacit√© de pointer vers le d√©calage d'un champ particulier par rapport au d√©but d'une structure en m√©moire.  Cela sert √† plusieurs fins: </p><br><ul><li>  de travailler avec des API externes dans le monde non manag√© sans avoir √† ins√©rer les champs inutilis√©s avant celui n√©cessaire; </li><li>  pour demander √† un compilateur de localiser un champ juste au d√©but du type ( <code>[FieldOffset(0)]</code> ).  Cela rendra le travail avec ce type plus rapide.  S'il s'agit d'un champ fr√©quemment utilis√©, nous pouvons augmenter les performances de l'application.  Cependant, cela n'est vrai que pour les types de valeur.  Dans les types de r√©f√©rence, le champ avec un d√©calage nul contient l'adresse d'une table de m√©thodes virtuelle, qui prend 1 mot machine.  M√™me si vous adressez le premier champ d'une classe, il utilisera un adressage complexe (adresse + offset).  En effet, le champ de classe le plus utilis√© est l'adresse d'une table de m√©thodes virtuelles.  La table est n√©cessaire pour appeler toutes les m√©thodes virtuelles; </li><li>  pour pointer vers plusieurs champs en utilisant une seule adresse.  Dans ce cas, la m√™me valeur est interpr√©t√©e comme diff√©rents types de donn√©es.  En C ++, ce type de donn√©es est appel√© union; </li><li>  ne pas se soucier de d√©clarer quoi que ce soit: un compilateur allouera les champs de mani√®re optimale.  Ainsi, l'ordre final des champs peut √™tre diff√©rent. </li></ul><br><p>  <strong>Remarques g√©n√©rales</strong> </p><br><ul><li>  <strong>Auto</strong> : l'environnement d'ex√©cution choisit automatiquement un emplacement et un emballage pour tous les champs de classe ou de structure.  Les structures d√©finies qui sont marqu√©es par un membre de cette √©num√©ration ne peuvent pas passer en code non manag√©.  La tentative de le faire produira une exception; </li><li>  <strong>Explicite</strong> : un programmeur contr√¥le explicitement l'emplacement exact de chaque champ d'un type avec FieldOffsetAttribute; </li><li>  <strong>S√©quentiel</strong> : les membres de type viennent dans un ordre s√©quentiel, d√©fini lors de la conception du type.  La valeur StructLayoutAttribute.Pack d'une √©tape de conditionnement indique leur emplacement. </li></ul><br><p>  <strong>Utilisation de FieldOffset pour ignorer les champs de structure inutilis√©s</strong> </p><br><p>  Les structures provenant du monde non manag√© peuvent contenir des champs r√©serv√©s.  On peut les utiliser dans une future version d'une biblioth√®que.  En C / C ++, nous comblons ces lacunes en ajoutant des champs, par exemple <code>[StructLayout(LayoutKind.Explicit)]</code> , ... Cependant, en .NET, nous nous contentons de compenser au d√©but d'un champ en utilisant l'attribut FieldOffsetAttribute et <code>[StructLayout(LayoutKind.Explicit)]</code> . </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] public struct SYSTEM_INFO { [FieldOffset(0)] public ulong OemId; // 92 bytes reserved [FieldOffset(100)] public ulong PageSize; [FieldOffset(108)] public ulong ActiveProcessorMask; [FieldOffset(116)] public ulong NumberOfProcessors; [FieldOffset(124)] public ulong ProcessorType; }</code> </pre> <br><p>  Un espace est occup√© mais l'espace inutilis√©.  La structure aura la taille √©gale √† 132 et non 40 octets comme cela peut sembler au d√©but. </p><br><p>  <strong>Union</strong> </p><br><p>  √Ä l'aide de FieldOffsetAttribute, vous pouvez √©muler le type C / C ++ appel√© union.  Il permet d'acc√©der aux m√™mes donn√©es que les entit√©s de <br>  diff√©rents types.  Regardons l'exemple: </p><br><pre> <code class="plaintext hljs">// If we read the RGBA.Value, we will get an Int32 value accumulating all // other fields. // However, if we try to read the RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, we // will get separate components of Int32. [StructLayout(LayoutKind.Explicit)] public struct RGBA { [FieldOffset(0)] public uint Value; [FieldOffset(0)] public byte R; [FieldOffset(1)] public byte G; [FieldOffset(2)] public byte B; [FieldOffset(3)] public byte Alpha; }</code> </pre> <br><p>  Vous pourriez dire qu'un tel comportement n'est possible que pour les types de valeur.  Cependant, vous pouvez le simuler pour les types de r√©f√©rence, en utilisant une adresse pour chevaucher deux types de r√©f√©rence ou un type de r√©f√©rence et un type de valeur: </p><br><pre> <code class="plaintext hljs">class Program { public static void Main() { Union x = new Union(); x.Reference.Value = "Hello!"; Console.WriteLine(x.Value.Value); } [StructLayout(LayoutKind.Explicit)] public class Union { public Union() { Value = new Holder&lt;IntPtr&gt;(); Reference = new Holder&lt;object&gt;(); } [FieldOffset(0)] public Holder&lt;IntPtr&gt; Value; [FieldOffset(0)] public Holder&lt;object&gt; Reference; } public class Holder&lt;T&gt; { public T Value; } }</code> </pre> <br><p>  J'ai utilis√© un type g√©n√©rique pour se chevaucher expr√®s.  Si j'ai utilis√© d'habitude <br>  qui se chevauchent, ce type entra√Ænerait l'exception TypeLoadException lorsqu'il est charg√© dans un domaine d'application.  Cela peut ressembler √† une faille de s√©curit√© en th√©orie (en particulier lorsque l'on parle de <strong>plug-ins d'</strong> application), mais si nous essayons d'ex√©cuter ce code √† l'aide d'un domaine prot√©g√©, nous obtiendrons la m√™me <code>TypeLoadException</code> . </p><br><h2 id="the-difference-in-allocation">  La diff√©rence d'allocation </h2><br><p>  Une autre caract√©ristique qui diff√©rencie les deux types est l'allocation de m√©moire pour les objets ou les structures.  Le CLR doit d√©cider de plusieurs choses avant d'allouer de la m√©moire √† un objet.  Quelle est la taille d'un objet?  Est-ce plus ou moins de 85K?  S'il est inf√©rieur, y a-t-il suffisamment d'espace libre sur le SOH pour allouer cet objet?  Si c'est plus, le CLR active le garbage collector.  Il passe par un graphique d'objet, compacte les objets en les d√©pla√ßant vers l'espace d√©gag√©.  S'il n'y a toujours pas d'espace sur le SOH, l'allocation de pages de m√©moire virtuelle suppl√©mentaires commencera.  Ce n'est qu'alors qu'un objet obtient l'espace allou√©, d√©barrass√© des ordures.  Ensuite, le CLR pr√©sente SyncBlockIndex et VirtualMethodsTable.  Enfin, la r√©f√©rence √† un objet revient √† un utilisateur. </p><br><p>  Si un objet allou√© est plus grand que 85 Ko, il va au tas d'objets volumineux (LOH).  C'est le cas des grandes cha√Ænes et des tableaux.  Ici, nous devons trouver l'espace le plus appropri√© en m√©moire dans la liste des plages inoccup√©es ou en allouer une nouvelle.  Ce n'est pas rapide, mais nous allons traiter avec soin les objets de cette taille.  De plus, nous n'allons pas en parler ici. </p><br><p>  Il existe plusieurs sc√©narios possibles pour les RefTypes: </p><br><ul><li>  RefType &lt;85K, il y a de l'espace sur le SOH: allocation rapide de m√©moire; </li><li>  RefType &lt;85K, l'espace sur le SOH est √©puis√©: allocation de m√©moire tr√®s lente; </li><li>  RefType&gt; 85K, allocation de m√©moire lente. </li></ul><br><p>  De telles op√©rations sont rares et ne peuvent pas rivaliser avec ValTypes.  L'algorithme d'allocation de m√©moire pour les types de valeur n'existe pas.  L'allocation de m√©moire pour les types de valeur ne co√ªte rien.  La seule chose qui se produit lors de l'allocation de m√©moire pour ce type est de d√©finir les champs sur null.  Voyons pourquoi cela se produit: 1. Lorsque l'on d√©clare une variable dans le corps d'une m√©thode, le temps d'allocation de m√©moire pour une structure est proche de z√©ro.  En effet, le temps d'allocation des variables locales ne d√©pend pas de leur nombre;  2. Si ValTypes sont allou√©s en tant que champs, Reftypes augmentera la taille des champs.  Un type de valeur est allou√© enti√®rement, devenant sa partie;  3. Comme dans le cas de la copie, si les ValTypes sont pass√©s en tant que param√®tres de m√©thode, il appara√Æt une diff√©rence, selon la taille et l'emplacement d'un param√®tre. </p><br><p>  Cependant, cela ne prend pas plus de temps que de copier une variable dans une autre. </p><br><h2 id="the-choice-between-a-class-or-a-structure">  Le choix entre une classe ou une structure </h2><br><p>  Discutons des avantages et des inconv√©nients des deux types et d√©cidons de leurs sc√©narios d'utilisation.  Un principe classique dit que nous devons choisir un type de valeur s'il n'est pas sup√©rieur √† 16 octets, reste inchang√© pendant sa dur√©e de vie et n'est pas h√©rit√©.  Cependant, choisir le bon type signifie le revoir sous diff√©rentes perspectives en se basant sur des sc√©narios d'utilisation future.  Je propose trois groupes de crit√®res: </p><br><ul><li>  bas√© sur l'architecture du syst√®me de type, dans lequel votre type interagira; </li><li>  en fonction de votre approche en tant que programmeur syst√®me pour choisir un type avec des performances optimales; </li><li>  quand il n'y a pas d'autre choix. </li></ul><br><p>  Chaque fonctionnalit√© con√ßue doit refl√©ter son objectif.  Cela ne concerne pas uniquement son nom ou son interface d'interaction (m√©thodes, propri√©t√©s).  On peut utiliser des consid√©rations architecturales pour choisir entre les types de valeur et de r√©f√©rence.  Pensons pourquoi une structure et non une classe pourrait √™tre choisie du point de vue du syst√®me de type syst√®me. </p><br><ol><li><p>  Si votre type con√ßu est agnostique √† son √©tat, cela signifie que son √©tat refl√®te un processus ou est une valeur de quelque chose.  En d'autres termes, une instance d'un type est constante et immuable par nature.  Nous pouvons cr√©er une autre instance d'un type bas√© sur cette constante en indiquant un d√©calage.  Ou, nous pouvons cr√©er une nouvelle instance en indiquant ses propri√©t√©s.  Cependant, nous ne devons pas le changer.  Je ne veux pas dire que la structure est un type immuable.  Vous pouvez modifier ses valeurs de champ.  De plus, vous pouvez passer une r√©f√©rence √† une structure dans une m√©thode en utilisant le param√®tre ref et vous obtiendrez des champs modifi√©s apr√®s avoir quitt√© la m√©thode.  Ce dont je parle ici, c'est du sens architectural.  Je vais donner plusieurs exemples. </p><br><ul><li>  DateTime est une structure qui r√©sume le concept d'un moment dans le temps.  Il stocke ces donn√©es sous la forme d'une uint mais donne acc√®s √† des caract√©ristiques distinctes d'un moment dans le temps: ann√©e, mois, jour, heure, minutes, secondes, millisecondes et m√™me ticks du processeur.  Cependant, il est immuable, bas√© sur ce qu'il encapsule.  Nous ne pouvons pas changer un instant dans le temps.  Je ne peux pas vivre la minute suivante comme si c'√©tait mon meilleur anniversaire dans l'enfance.  Ainsi, si nous choisissons un type de donn√©es, nous pouvons choisir une classe avec une interface en lecture seule, qui produit une nouvelle instance pour chaque changement de propri√©t√©s.  Ou, nous pouvons choisir une structure, qui peut mais ne doit pas changer les champs de ses instances: sa <em>valeur</em> est la description d'un moment dans le temps, comme un nombre.  Vous ne pouvez pas acc√©der √† la structure d'un num√©ro et la modifier.  Si vous souhaitez obtenir un autre moment dans le temps, qui diff√®re d'un jour de l'original, vous obtiendrez simplement une nouvelle instance d'une structure. </li><li>  <code>KeyValuePair&lt;TKey, TValue&gt;</code> est une structure qui encapsule le concept d'une paire cl√©-valeur connect√©e.  Cette structure sert uniquement √† afficher le contenu d'un dictionnaire pendant l'√©num√©ration.  Du point de vue architectural, une cl√© et une valeur sont des concepts indissociables dans <code>Dictionary&lt;T&gt;</code> .  Cependant, √† l'int√©rieur, nous avons une structure complexe, o√π une cl√© se trouve s√©par√©ment d'une valeur.  Pour un utilisateur, une paire cl√©-valeur est un concept indissociable en termes d'interface et de signification d'une structure de donn√©es.  C'est une <em>valeur</em> enti√®re en soi.  Si l'on attribue une autre valeur √† une cl√©, la paire enti√®re changera.  Ainsi, ils repr√©sentent une seule entit√©.  Cela fait d'une structure une variante id√©ale dans ce cas. </li></ul><br></li><li><p>  Si votre type con√ßu est une partie ins√©parable d'un type externe mais est structurellement int√©gr√©.  Cela signifie qu'il est incorrect de dire que le type externe fait r√©f√©rence √† une instance d'un type encapsul√©.  Cependant, il est correct de dire qu'un type encapsul√© fait partie d'un externe avec toutes ses propri√©t√©s.  Ceci est utile lors de la conception d'une structure qui fait partie d'une autre structure. </p><br><ul><li>  Par exemple, si nous prenons la structure d'un en-t√™te de fichier, il sera inappropri√© de passer une r√©f√©rence d'un fichier √† un autre, par exemple un fichier header.txt.  Cela serait appropri√© lors de l'insertion d'un document dans un autre, non pas en incorporant un fichier mais en utilisant une r√©f√©rence dans un syst√®me de fichiers.  Un bon exemple est les fichiers de raccourcis dans le syst√®me d'exploitation Windows.  Cependant, si nous parlons d'un en-t√™te de fichier (par exemple, un en-t√™te de fichier JPEG contenant des m√©tadonn√©es sur la taille d'une image, les m√©thodes de compression, les param√®tres de photographie, les coordonn√©es GPS et autres), nous devons utiliser des structures pour concevoir des types d'analyse de l'en-t√™te.  Si vous d√©crivez tous les en-t√™tes dans les structures, vous obtiendrez la m√™me position des champs en m√©moire que dans un fichier.  En utilisant une simple transformation <code>*(Header *)readedBuffer</code> non s√©curis√©e <code>*(Header *)readedBuffer</code> sans d√©s√©rialisation, vous obtiendrez des structures de donn√©es enti√®rement remplies. </li></ul><br></li></ol><br><ol><li>  Aucun des deux exemples ne montre l'h√©ritage du comportement.  Ils montrent qu'il n'est pas n√©cessaire d'h√©riter du comportement de ces entit√©s.  Ils sont autonomes.  Cependant, si nous prenons en compte l'efficacit√© du code, nous verrons le choix d'un autre c√¥t√©: </li><li>  Si nous devons prendre des donn√©es structur√©es √† partir de code non manag√©, nous devons choisir des structures.  Nous pouvons √©galement transmettre la structure des donn√©es √† une m√©thode non s√©curis√©e.  Un type de r√©f√©rence ne convient pas du tout. </li><li>  Une structure est votre choix si un type transmet les donn√©es dans des appels de m√©thode (en tant que valeurs renvoy√©es ou en tant que param√®tre de m√©thode) et qu'il n'est pas n√©cessaire de faire r√©f√©rence √† la m√™me valeur √† diff√©rents endroits.  L'exemple parfait est les tuples.  Si une m√©thode renvoie plusieurs valeurs √† l'aide de tuples, elle renverra un ValueTuple, d√©clar√© en tant que structure.  La m√©thode n'allouera pas d'espace sur le tas, mais utilisera la pile du thread, o√π l'allocation de m√©moire ne co√ªte rien. </li><li>  Si vous concevez un syst√®me qui cr√©e un trafic important d'instances qui ont une taille et une dur√©e de vie r√©duites, l'utilisation de types de r√©f√©rence entra√Ænera soit un pool d'objets, soit, sans le pool d'objets, une accumulation de d√©chets incontr√¥l√©e sur le tas.  Certains objets se transformeront en g√©n√©rations plus anciennes, augmentant la charge sur GC.  L'utilisation de types de valeurs dans de tels endroits (si c'est possible) augmentera les performances car rien ne passera au SOH.  Cela r√©duira la charge sur GC et l'algorithme fonctionnera plus rapidement; </li></ol><br><p>  Sur la base de ce que j'ai dit, voici quelques conseils sur l'utilisation des structures: </p><br><ol><li>  Lorsque vous choisissez des collections, vous devez √©viter que les grands tableaux stockent de grandes structures.  Cela inclut les structures de donn√©es bas√©es sur des tableaux.  Cela peut entra√Æner une transition vers le tas d'objets volumineux et sa fragmentation.  Il est faux de penser que si notre structure a 4 champs de type octet, cela prendra 4 octets.  Nous devons comprendre que dans les syst√®mes 32 bits, chaque champ de structure est align√© sur des limites de 4 octets (chaque champ d'adresse doit √™tre divis√© exactement par 4) et dans les syst√®mes 64 bits - sur des limites de 8 octets.  La taille d'un tableau doit d√©pendre de la taille d'une structure et d'une plate-forme ex√©cutant un programme.  Dans notre exemple avec 4 octets - 85 Ko / (de 4 √† 8 octets par champ * le nombre de champs = 4) moins la taille d'un en-t√™te de tableau √©quivaut √† environ 2 600 √©l√©ments par tableau selon la plate-forme (cela doit √™tre arrondi vers le bas )  Ce n'est pas beaucoup.  Il pouvait sembler que nous pouvions facilement atteindre une constante magique de 20 000 √©l√©ments </li><li>  Parfois, vous utilisez une structure de grande taille comme source de donn√©es et la placez comme champ dans une classe, tout en ayant une copie r√©pliqu√©e pour produire un millier d'instances.  Ensuite, vous d√©veloppez chaque instance d'une classe pour la taille d'une structure.  Cela entra√Ænera un gonflement de la g√©n√©ration z√©ro et une transition vers la g√©n√©ration un et m√™me deux.  Si les instances d'une classe ont une courte dur√©e de vie et que vous pensez que le GC les collectera √† la g√©n√©ration z√©ro - pendant 1 ms, vous serez d√©√ßu.  Ils sont d√©j√† en g√©n√©ration un et m√™me deux.  Cela fait la diff√©rence.  Si le GC collecte la g√©n√©ration z√©ro pendant 1 ms, les g√©n√©rations une et deux sont collect√©es tr√®s lentement, ce qui entra√Ænera une diminution de l'efficacit√©; </li><li>  Pour la m√™me raison, vous devez √©viter de passer de grandes structures via une s√©rie d'appels de m√©thode.  Si tous les √©l√©ments s'appellent les uns les autres, ces appels prendront plus d'espace sur la pile et entra√Æneront la mort de votre application par StackOverflowException.  La prochaine raison est la performance.  Plus il y a d'exemplaires, plus tout fonctionne lentement. </li></ol><br><p>  C'est pourquoi le choix d'un type de donn√©es n'est pas un processus √©vident.  Souvent, cela peut faire r√©f√©rence √† une optimisation pr√©matur√©e, ce qui n'est pas recommand√©.  Cependant, si vous savez que votre situation correspond aux principes √©nonc√©s ci-dessus, vous pouvez facilement choisir un type de valeur. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439486/">https://habr.com/ru/post/fr439486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439476/index.html">Argot de Cockney: histoire moderne et statut social</a></li>
<li><a href="../fr439478/index.html">C # divertissant. Cinq exemples de pauses caf√©</a></li>
<li><a href="../fr439480/index.html">C√©dez le passage, ou pourquoi votre CRM (et CRM) ralentit-il?</a></li>
<li><a href="../fr439482/index.html">devleads - motivation (non) financi√®re</a></li>
<li><a href="../fr439484/index.html">Obtention de donn√©es d'√©num√©ration dans une perspective Automapper</a></li>
<li><a href="../fr439488/index.html">Enregistrement vid√©o Meetup QA</a></li>
<li><a href="../fr439490/index.html">Types de r√©f√©rence .NET vs types de valeur. 2e partie</a></li>
<li><a href="../fr439492/index.html">10 conseils pour √™tre un bon leader technologique</a></li>
<li><a href="../fr439496/index.html">Comment la facturation se fait-elle: lorsque le client et le d√©veloppeur parlent des langues diff√©rentes</a></li>
<li><a href="../fr439498/index.html">Sur quel mat√©riel analyser un √©norme puits d'informations?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>