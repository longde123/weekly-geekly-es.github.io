<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎵 👊🏾 🖖🏼 Minha experiência de desenvolvimento Nim ✌🏼 🤪 😑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 


 Já faz algum tempo que estou escrevendo minha estrutura de jogo - um projeto tão bom para a alma. E já que para a alma você precisa esco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Minha experiência de desenvolvimento Nim</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462577/"><p><img src="https://habrastorage.org/webt/vx/0d/ig/vx0dignqhsbwiaewbqugebd06iw.jpeg"></p><br><p>  Olá Habr! </p><br><p>  Já faz algum tempo que estou escrevendo minha estrutura de jogo - um projeto tão bom para a alma.  E já que para a alma você precisa escolher algo que você gosta (e, neste caso, o que você gosta de escrever), minha escolha caiu nim.  Neste artigo, quero falar especificamente sobre nim, sobre seus recursos, prós e contras, e o tema gamedev apenas define o contexto da minha experiência - quais tarefas eu resolvi, que dificuldades surgiram. </p><br><p>  Era uma vez, quando a grama era mais verde e o céu mais limpo, eu o encontrei.  Não, não é assim.  Era uma vez, eu queria desenvolver jogos para escrever o meu jogo mais legal - acho que muitos passaram por isso.  Naqueles dias, Unity e Unreal Engine estavam apenas começando a aparecer na audiência e, como, ainda não estavam livres.  Eu não os usei, não tanto por causa da ganância, mas por causa do desejo de escrever tudo sozinho, de criar um mundo de jogo completamente do zero, desde o início. <del>  o primeiro </del>  zero byte.  Sim, por um longo tempo, sim, é difícil, mas o próprio processo traz prazer - mas o que mais é necessário para a felicidade? </p><a name="habracut"></a><br><p> Armado com Straustrup e Qt, eu bebi merda para o bem, porque, em primeiro lugar, eu não era uma das 10 pessoas no mundo que conhecia <em>bem o</em> C ++ <em>e</em> , em segundo lugar, as vantagens colocavam paus nas minhas rodas.  Não vejo razão para repetir o que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">platoff</a> já escreveu extraordinariamente para mim: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como eu encontrei a melhor linguagem de programação do mundo.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como eu encontrei a melhor linguagem de programação do mundo.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como eu encontrei a melhor linguagem de programação do mundo.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Yo Part (2,72)</a> </p><br><blockquote>  É um zumbido louco quando você escreve código livremente, quase sem pensar, sem esperar pelo core despejado antes de cada lançamento, quando os recursos são adicionados bem diante de nossos olhos, agora podemos fazê-lo, e agora é assim, diga-me, por favor, que diferença isso faz para mim Eu não tenho modelos se eu nem senti falta deles?  A produtividade é o principal objetivo do programador que faz as coisas e a única tarefa da ferramenta que ele usa. </blockquote><p>  Ao trabalhar com C ++, eu estava constantemente pensando em <em>como</em> escrever o que quero, e não <em>o</em> que escrever para mim.  Então eu mudei para nim.  A história acabou, deixe-me compartilhar minha experiência com você depois de vários anos no nim. </p><br><h2 id="obschie-svedeniya-dlya-teh-kto-ne-v-kurse">  Informações gerais para quem não conhece </h2><br><ul><li>  Open Source Compiler (MIT), desenvolvido por entusiastas.  O criador do idioma é Andreas Rumpf (Araq).  O segundo desenvolvedor é Dominik Picheta (dom96), que escreveu o livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim em ação</a> .  Além disso, há algum tempo, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Status</a> começou a patrocinar o desenvolvimento da linguagem, então nim conseguiu mais 2 desenvolvedores em período integral.  Além deles, é claro, outras pessoas contribuirão. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">A versão 1.0</a> foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">lançada</a> recentemente, o que significa que o idioma é estável e não são mais esperadas "alterações recentes".  Se antes você não queria usar a versão instável, porque as atualizações poderiam interromper o aplicativo, agora é a hora de tentar nim em seus projetos. </li><li>  Nim compila (ou transpõe) em C, C ++ (que são compilados posteriormente em código nativo) ou JS (com algumas limitações).  Assim, com a ajuda da FFI, todas as bibliotecas existentes para C e C ++ estão disponíveis para você.  Se não houver um pacote necessário no nim - procure por s ou vantagens. </li><li>  Os idiomas mais próximos são python (por sintaxe, à primeira vista) e D (por funcionalidade) - IMHO </li></ul><br><h2 id="dokumentaciya">  A documentação </h2><br><p>  Isso é realmente ruim.  Os problemas: </p><br><ol><li>  A documentação está espalhada em diferentes fontes </li><li>  A documentação <del>  merda </del>  não descreve totalmente todos os recursos do idioma </li><li>  A documentação às vezes é muito concisa. </li></ol><br><p> Exemplo: se você deseja escrever aplicativos multithread, há muitos núcleos, mas não há para onde ir. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Aqui está a seção de documentação oficial sobre fluxos</a> .  Não, veja você, os <em>threads</em> são uma parte importante separada do idioma, seu recurso que você precisa incluir com o sinalizador <code>--threads:on</code> ao compilar.  Lá, heap compartilhado ou local de encadeamento, dependendo do coletor de lixo, todos os tipos de memória e bloqueios compartilhados, segurança de encadeamento, módulos compartilhados especiais e muito mais.  Como eu sabia tudo sobre isso?  É isso mesmo, desde o livro em ação, o fórum, o excesso de pilha, a TV e o vizinho, em geral, de qualquer lugar, mas não da documentação oficial. </p><br><p>  Ou há um chamado.  "notação" - funciona muito bem ao usar modelos etc., geralmente sempre que você precisar passar um retorno de chamada ou apenas um bloco de código.  Onde posso ler sobre isso?  Sim, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">manual de recursos experimentais</a> . </p><br><p>  Concordo, coletar informações sobre várias fontes não informativas ainda é um prazer.  Se você escreve em nim, precisa fazê-lo. </p><br><p>  No fórum e nas questões do github, havia sugestões para melhorar a documentação, mas as coisas não avançaram.  Parece-me que está faltando algum tipo de mão dura, que dirá "tudo, a comunidade, pegue as pás e vá vasculhar esse monte de g ... engenhosos pedaços de texto espalhados". </p><br><p>  Felizmente, eu bati no meu próprio, então eu apresento a você a lista de campeões </p><br><h3 id="dokumentaciya-1">  A documentação </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Tutorial 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Tutorial 2</a> - comece com eles </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim em ação</a> é um livro explicativo que realmente explica bem muitos aspectos da linguagem, às vezes muito melhores do que.  documentação </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim manual</a> - na verdade, um manual - quase tudo é descrito, mas não </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim manual experimental</a> - por que não continuar a documentação em uma página separada? </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">O Índice</a> - links para tudo são coletados aqui, ou seja, geralmente tudo o que pode ser encontrado em nim.  Se você não encontrou o que precisa nos tutoriais e no manual, definitivamente o encontrará no índice. </li></ul><br><h3 id="uroki-i-tutorialy">  Lições e Tutoriais </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim basics</a> - o básico para iniciantes, tópicos complexos não abordados </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim Days</a> - pequenos projetos (exemplos ao vivo) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Código Rosetta</a> - é muito legal comparar a solução das mesmas tarefas em diferentes PL, incluindo  nim </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Exercism.io</a> - aqui você pode ir "nim path", completando tarefas </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim por exemplo</a> </li></ul><br><h3 id="pomosch">  Ajuda </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">O IRC</a> é o habitat principal ... dos nimmers?, Que é transmitido em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Discord</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Gitter</a> .  Eu nunca usei o IRC (e ainda não o uso).  Em geral, essa é uma escolha muito estranha.  Ainda há correio de pombo para ele ... tudo bem, brincando. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Fórum Nim</a> Os recursos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">do fórum</a> são mínimos, mas 1) aqui você pode encontrar a resposta 2) aqui você pode fazer uma pergunta se o item 1 não funcionou 3) a probabilidade de uma resposta é superior a 50% 4) os desenvolvedores de idiomas estão sentados no fórum e estão respondendo ativamente.  A propósito, o fórum está escrito em nim e, portanto, não há funcionalidade </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim grupo de telegrama</a> - é possível fazer uma pergunta e [não] obter uma resposta. </li><li>  Há também um grupo de telegrama russo, se você está cansado de nim e não quer ouvir nada sobre isso, você deve ir lá :) (em parte uma piada) </li></ul><br><h3 id="playground">  Parque infantil </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim playground</a> - aqui você pode executar o programa no nim diretamente no navegador </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim docker cross-compiling</a> - aqui você pode ler como iniciar uma imagem do docker e compilar o programa para diferentes plataformas. </li></ul><br><h3 id="pakety">  Pacotes </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">nimble.directory</a> - aqui estão todos os pacotes publicados disponíveis para instalação através do gerenciador de pacotes nimble. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Lista de pacotes organizados</a> - uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">lista de pacotes</a> mais ou menos ativos, compilados por entusiastas </li></ul><br><h3 id="perehod-na-nim-s-drugih-yazykov">  Mudar para nim de outros idiomas </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Importações no Nim</a> - o artigo descreve a melhor forma de importar módulos e por que permite que você expulsar temporariamente o espírito do pythonist </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim para programadores python</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Nim para programadores c</a> </li></ul><br><h2 id="chto-nravitsya">  Do que você gosta </h2><br><p>  Não faz sentido listar todos os recursos do idioma, mas aqui estão alguns recursos: </p><br><h3 id="fraktal-slozhnosti">  Complexidade fractal </h3><br><p>  Nim fornece um "fractal de complexidade".  Você pode escrever código de alto nível.  Você pode usar ponteiros brutos e aproveitar todas as <code>attempt to read from nil</code> .  Você pode incorporar o código C.  Você pode escrever <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">inserções no assembler</a> .  Você pode escrever procedimentos (expedição estática).  Não é suficiente - existem "métodos" (envio dinâmico).  Mais?  Existem genéricos e existem genéricos que imitam funções.  Existem modelos - um mecanismo de substituição, mas não tão vômito quanto em C ++ (existem macros aqui - é apenas uma substituição de texto ou é algo mais inteligente?).  No final, existem macros - é como o IDDQD, elas ativam o modo god e permitem que você trabalhe diretamente com o AST e literalmente substitua partes da árvore de sintaxe, ou expanda o idioma você mesmo. <br>  Ou seja, em um nível "alto", você pode escrever palavras do inferno e pesar para não saber, mas ninguém o proíbe de realizar fraudes de qualquer complexidade. </p><br><h3 id="skorost-razrabotki">  Velocidade de desenvolvimento </h3><br><p>  A curva de aprendizado não é uma curva.  Isso é direto.  Ao instalar o nim, você iniciará seu primeiro olá mundo no primeiro minuto e, no primeiro dia, escreverá um utilitário simples.  Mas em alguns meses você terá algo a aprender.  Por exemplo, comecei com procedimentos, depois precisei de métodos, depois de um tempo os genéricos foram muito úteis para mim, recentemente descobri modelos em toda a sua glória e, ao mesmo tempo, não toquei em macros.  Comparando com a mesma ferrugem ou c ++, a fusão com o nim é muito mais fácil. </p><br><h3 id="package-management">  Gerenciamento de pacotes </h3><br><p>  Existe um gerenciador de pacotes chamado nimble que pode instalar, desinstalar, criar pacotes e carregar dependências.  Ao criar seu pacote (= projeto), é possível gravar tarefas diferentes no nimble (usando nimscript, que é um subconjunto de nim executável na VM), por exemplo, gerando documentação, executando testes, copiando ativos etc.  Nimble não apenas coloca as dependências necessárias, mas também permite que você configure o ambiente de trabalho para o seu projeto.  Ou seja, ágil é, grosso modo, o CMake, que foi escrito não por pervertidos, mas por pessoas normais. </p><br><h3 id="chitaemost-i-vyrazitelnost">  Legibilidade e expressividade </h3><br><p>  Externamente, nim é muito semelhante ao python com anotações de tipo, embora nim não seja python.  Os pitonistas terão que esquecer a digitação dinâmica, a herança, os decoradores e outras alegrias, e geralmente reestruturar seu pensamento.  Não tente transferir sua experiência python para o nim, porque a diferença é muito grande.  No começo, eu realmente quero coleções heterogêneas e mixins com decoradores.  mas então de alguma forma você se acostuma a viver dificuldades :) </p><br><p>  Aqui está um exemplo de programa nim: </p><br><pre> <code class="plaintext hljs"> type NumberGenerator = object of Service # this service just generates some numbers NumberMessage = object of Message number: int proc run(self: NumberGenerator) = if not waitAvailable("calculator"): echo "Calculator is unavailable, shutting down" return for number in 0..&lt;10: echo &amp;"Sending number {number}" (ref NumberMessage)(number: number).send("calculator")</code> </pre> <br><h3 id="modulnost">  Modularidade </h3><br><p>  Tudo é dividido em módulos que você pode importar como quiser - para importar apenas determinados caracteres, ou todos, exceto certos, ou todos, ou nenhum, e forçar o usuário a especificar o caminho completo para la <code>module.function()</code> e também importar com um nome diferente.  É claro que toda essa variedade é muito útil como outro argumento no debate "qual linguagem de programação é melhor"; bem, em seu projeto, você escreverá discretamente o <code>import mymodule</code> e não lembrará outras opções. </p><br><h3 id="method-call-syntax">  Sintaxe de Chamada de Método </h3><br><p>  Uma chamada de função pode ser gravada de diferentes maneiras: </p><br><pre> <code class="plaintext hljs"> double(2) double 2 2.double() 2.double</code> </pre> <br><p>  Por um lado, agora todo mundo ... escreve como ele gosta (e todo mundo gosta de maneiras diferentes, é claro, e de maneiras diferentes, mesmo dentro da estrutura de um projeto).  Mas todas as funções podem ser escritas como uma chamada de método, o que melhora muito a legibilidade.  Em python, pode ser: </p><br><pre> <code class="python hljs">list(set(some_list)) <span class="hljs-comment"><span class="hljs-comment"># -:   ,     map  filter    </span></span></code> </pre> <br><p>  O mesmo código no nim pode ser reescrito mais logicamente: </p><br><pre> <code class="plaintext hljs">some_list.set.list #   </code> </pre> <br><h3 id="oop">  OOP </h3><br><p>  OOP, embora esteja presente, difere dele em vantagens e python: objetos e métodos são entidades diferentes e podem muito bem existir em módulos diferentes.  Além disso, você pode escrever seus métodos para tipos básicos como <code>int</code> </p><br><pre> <code class="plaintext hljs"> proc double(number: int): int = number * 2 echo $2.double() # prints "4"</code> </pre> <br><p>  Por outro lado, há encapsulamento no nim (a primeira regra do módulo no nim é não contar a ninguém sobre identificadores sem um asterisco).  Aqui está um exemplo de um módulo padrão: </p><br><pre> <code class="plaintext hljs"># sharedtables.nim type SharedTable*[A, B] = object ## generic hash SharedTable data: KeyValuePairSeq[A, B] counter, dataLen: int lock: Lock</code> </pre> <br><p>  O tipo <code>SharedTable*</code> está marcado com um asterisco, o que significa que é "visível" em outros módulos e pode ser importado.  Mas aqui <code>data</code> , <code>counter</code> e <code>lock</code> são membros privados e <code>sharedtables.nim</code> não são acessíveis de fora.  Isso me deixou muito feliz quando decidi escrever algumas funções adicionais para o tipo <code>SharedTable</code> , como <code>len</code> ou <code>hasKey</code> , e <code>hasKey</code> que não tinha acesso ao <code>counter</code> ou aos <code>data</code> , e a única maneira de "expandir" o <code>SharedTable</code> era escrever o seu próprio <del>  com bl </del></p><br><p>  Em geral, a herança é usada com muito menos frequência do que no mesmo python (por experiência pessoal), porque há sintaxe de chamada de método (veja acima) e variantes de objeto (veja abaixo).  O caminho nim é composição, e não herança.  O mesmo ocorre com o polimorfismo: em nim existem métodos que podem ser substituídos em classes sucessoras, mas isso deve ser especificado explicitamente durante a compilação usando o <code>--multimethods:on</code> .  Ou seja, por padrão, os métodos não funcionam, o que incentiva um pouco o trabalho sem eles. </p><br><h3 id="compile-time-execution">  Execução em tempo de compilação </h3><br><p>  Const - a capacidade de calcular algo no estágio de compilação e "costurá-lo" no binário resultante.  É legal e confortável.  Em geral, nim tem uma relação especial com "tempo de compilação", existe até uma palavra-chave <code>when</code> - é como <code>if</code> , mas a comparação está no estágio de compilação.  Você pode escrever algo como </p><br><pre> <code class="plaintext hljs"> when defined(SDL_VIDEO_DRIVER_WINDOWS): import windows ## oldwinapi lib elif defined(SDL_VIDEO_DRIVER_X11): import x11/x, x11/xlib ## x11 lib</code> </pre> <br><p>  Isso é muito conveniente, embora haja restrições sobre o que você pode fazer no estágio de compilação (por exemplo, você não pode fazer chamadas FFI). </p><br><h3 id="reference-type">  Tipo de referência </h3><br><p>  Tipo de referência - um análogo do shared_ptr em C ++, do qual o coletor de lixo cuidará.  Mas você também pode ligar para o coletor de lixo nos momentos em que for conveniente para você.  Ou você pode tentar opções diferentes para coletores de lixo.  Ou você pode desativar o coletor de lixo e usar ponteiros regulares. </p><br><p>  Idealmente, se você não usar ponteiros brutos e FFI, é improvável que obtenha erros de segmentação.  Na prática, até agora sem a FFI em qualquer lugar. </p><br><h3 id="lambdas">  Lambdas </h3><br><p>  Existem procedimentos anônimos (também conhecidos como lambdas no python), mas, diferentemente do python no procedimento anônimo, você pode usar várias instruções: </p><br><pre> <code class="plaintext hljs">someProc(callback=proc(a: int) -&gt; int = var b = 5*a; result = a)</code> </pre> <br><h3 id="exceptions">  Exceções </h3><br><p>  Existem exceções, elas são muito inconvenientes para lançar: python <code>raise ValueError('bad value')</code> , nim <code>raise newException(ValueError, "bad value")</code> .  Nada mais incomum - tente, exceto, finalmente, tudo é como todo mundo.  Eu, como defensor de exceções, não de códigos de erro, me alegro.  A propósito, você pode indicar para funções quais exceções elas podem lançar, e o compilador verificará isso: </p><br><pre> <code class="plaintext hljs">proc p(what: bool) {.raises: [IOError, OSError].} = if what: raise newException(IOError, "IO") else: raise newException(OSError, "OS")</code> </pre> <br><h3 id="generics">  Genéricos </h3><br><p>  Os genéricos são muito expressivos, por exemplo, você pode limitar os tipos possíveis </p><br><pre> <code class="plaintext hljs">proc onlyIntOrString[T: int|string](x, y: T) = discard #  int  string</code> </pre> <br><p>  E você pode passar um tipo em geral como parâmetro - parece uma função comum, mas de fato um genérico: </p><br><pre> <code class="plaintext hljs">proc p(a: typedesc; b: a) = discard # is roughly the same as: proc p[T](a: typedesc[T]; b: T) = discard # hence this is a valid call: p(int, 4) # as parameter 'a' requires a type, but 'b' requires a value.</code> </pre> <br><h3 id="templates">  Templates </h3><br><p>  Modelos são algo como macros em C ++, feitas <em>corretamente corretamente</em> :) - você pode transferir com segurança blocos inteiros de código para modelos, e não pensar que a substituição arruine algo no código externo (mas você pode novamente , para fazer bagunça, se você realmente precisar). </p><br><p>  Aqui está um exemplo de modelo de <code>app</code> , que, dependendo do valor da variável, chama um dos blocos de código: </p><br><pre> <code class="plaintext hljs">template app*(serverCode: untyped, clientCode: untyped) = # ... case mode of client: clientCode of server: serverCode else: discard</code> </pre> <br><p>  Com <code>do</code> posso passar blocos inteiros para o modelo, por exemplo: </p><br><pre> <code class="plaintext hljs">app do: # serverCode echo "I'm server" serverProc() do: # clientCode echo "I'm client" clientProc()</code> </pre> <br><h3 id="interactive-shell">  Shell interativo </h3><br><p>  Se você precisar testar rapidamente algo, ou seja, a capacidade de chamar um "intérprete" ou "nim shell" (como se você executasse <code>python</code> sem parâmetros).  Para fazer isso, use o comando <code>nim secret</code> ou faça o download do pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">inim</a> . </p><br><h3 id="ffi">  Ffi </h3><br><p>  FFI - a capacidade de interagir com bibliotecas de terceiros em C / C ++.  Infelizmente, para usar uma biblioteca externa, você precisa escrever um wrapper explicando de onde e de onde importar.  Por exemplo: </p><br><pre> <code class="plaintext hljs">{.link: "/usr/lib/libOgreMain.so".} type ManualObjectSection* {.importcpp: "Ogre::ManualObject::ManualObjectSection", bycopy.} = object</code> </pre> <br><p>  Existem ferramentas que tornam esse processo semi-automático: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">c2nim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">nimterop</a> </li></ul><br><h2 id="chto-ne-nravitsya">  O que não gosta </h2><br><h3 id="slozhnost">  Dificuldade </h3><br><p>  Muitas coisas.  A linguagem foi concebida como minimalista, mas agora está muito longe da verdade.  Por exemplo, por que conseguimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">reordenar o código</a> ?! </p><br><h3 id="izbytochnost">  Redundância </h3><br><p>  Muita merda: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">system.addInt</a> - "Converte inteiro para sua representação de string e anexa ao resultado".  Parece-me que esta é uma função muito conveniente, eu a uso em todos os projetos.  Aqui está outra questão interessante: fileExists and existirFile ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://forum.nim-lang.org/t/3636</a> ) </p><br><h3 id="net-unifikacii">  Sem unificação </h3><br><p>  "Há apenas uma maneira de fazer algo" - nenhuma: </p><br><ul><li>  Sintaxe de chamada de método - escreva uma chamada de função como desejar </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><code>fmt</code> vs <code>&amp;</code></a> </li><li>  camelCase e underscore_notation </li><li>  isso e isso (spoiler: é a mesma coisa) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">função</a> vs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">procedimento</a> vs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">modelo</a> </li></ul><br><h3 id="bagi-net-bagi">  Erros (sem sacos!) </h3><br><p>  Existem bugs, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">cerca de 1400</a> .  Ou basta ir ao fórum - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">eles</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">constantemente</a> encontram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">alguns</a> erros. </p><br><h3 id="stabilnost">  Estabilidade </h3><br><p>  Além do parágrafo anterior, a v1 implica estabilidade, certo?  E aqui o criador da linguagem Araq voa para o fórum e diz: "caras, eu tenho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">outro (sexto)</a> coletor de lixo aqui, é mais legal, mais rápido, mais novo, dá a você uma memória compartilhada de threads (ha ha, e antes disso você sofreu e muletas usadas), baixe o ramo de desenvolvimento e tente ".  E tudo isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">"Uau, que legal! E o que isso significa para meros mortais? Agora precisamos mudar todo o código novamente?"</a>  Parece que não, então, atualizo o nim, corro um novo coletor de lixo <code>--gc:arc</code> e meu programa trava em algum lugar no estágio de compilação do código c ++ (ou seja, não no nim, mas no gcc): </p><br><pre> <code class="plaintext hljs">/usr/lib/nim/system.nim:274:77: error: 'union pthread_cond_t' has no member named 'abi' 274 | result = x</code> </pre> <br><p>  Ótimo!  Agora, em vez de escrever um novo código, tenho que reparar o antigo.  Não era disso que eu estava fugindo quando escolhi nim? </p><br><p>  É bom saber que não estou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">sozinha</a> </p><br><h3 id="metody-i-mnogopotochnost">  Métodos e multithreading </h3><br><p>  Por padrão, os sinalizadores multimétodos e threads estão desativados - você não vai <del>  2019 </del>  2020 escreva um aplicativo multiencadeado com métodos de substituição ?!  E como é ótimo se sua biblioteca foi criada sem considerar os fluxos e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">usuário os ativou</a> ... Ah, sim, existem pragmas maravilhosos {.inheritable.} E {.base.} Para herança, para que seu código não seja muito conciso. </p><br><h3 id="object-variants">  Variantes de objeto </h3><br><p>  Você pode evitar a herança usando o chamado  variantes de objeto: </p><br><pre> <code class="plaintext hljs">type CoordinateSystem = enum csCar, # Cartesian csCyl, # Cylindrical Coordinates = object case cs: CoordinateSystem: # cs is the coordinate discriminator of csCar: x: float y: float z: float of csCyl: r: float phi: float k: float</code> </pre> <br><p>  Dependendo do valor de <code>cs</code> , os campos x, y, z ou r, phi e k estarão disponíveis para você. </p><br><p>  Quais são as desvantagens? <br>  Em primeiro lugar, a memória é reservada para a "maior opção" - para garantir que ela caiba na memória alocada para o objeto. <br>  Em segundo lugar, a herança ainda é mais flexível - você sempre pode criar um descendente e adicionar mais campos, e na variante de objeto todos os campos são rigidamente definidos em uma seção. <br>  Em terceiro lugar, o que mais enfurece é que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">você não pode "reutilizar"</a> campos em diferentes tipos: </p><br><pre> <code class="plaintext hljs">type # The 3 notations refer to the same 3-D entity, and some coordinates are shared CoordinateSystem = enum csCar, # Cartesian (x,y,z) csCyl, # Cylindrical (r,φ,z) Coordinates = object case cs: CoordinateSystem: # cs is the coordinate discriminator of csCar: x: float y: float z: float # z already defined here of csCyl: r: float phi: float z: float # fails to compile due to redefinition of z</code> </pre> <br><h3 id="do-notation">  Faça notação </h3><br><p>  Apenas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">citar</a> : </p><br><ul><li>  fazer com parênteses é um processo anônimo </li><li>  fazer sem parênteses é apenas um bloco de código <br>  Uma expressão significa coisas diferentes ¯_ (ツ) _ / ¯ </li></ul><br><h3 id="kogda-chto-ispolzovat">  Quando usar </h3><br><p>  Portanto, temos funções, procedimentos, genéricos, multimétodos, modelos e macros.  Quando é melhor usar um modelo e quando é um procedimento?  Modelo ou genérico?  Função ou procedimento?  Então, e as macros?  Eu acho que você entendeu. </p><br><h3 id="custom-pragma">  Pragma personalizado </h3><br><p>  Existem decoradores em python que podem ser aplicados mesmo a classes, até a funções. <br>  Existem pragmas para isso.  E aqui está o que: </p><br><ul><li>  Você pode escrever seu próprio pragma que irá decorar o procedimento: <br><pre> <code class="plaintext hljs">proc fib(n : int) : int {.cached.} = # do smth</code> </pre> </li><li>  Você <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">não pode</a> escrever seu próprio pragma que irá decorar o tipo (= classe). </li></ul><br><h3 id="nimble">  Nimble </h3><br><p>  O que está morto não pode morrer.  No ágil, vários projetos que não são atualizados há muito tempo (e, no caso, são como a morte) - e não são removidos.  Ninguém está seguindo isso.  É claro, compatibilidade com versões anteriores ", você não pode simplesmente pegar e remover o pacote do nabo", mas ainda assim ... Ok, obrigado, pelo menos não como o npm. </p><br><h3 id="dyryavye-abstrakcii">  Abstração com vazamento </h3><br><p>  Existe uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">lei dessas abstrações vazias</a> - você usa algum tipo de abstração, mas mais cedo ou mais tarde encontrará um "buraco" nela que o levará a um nível mais baixo.  Nim é uma abstração de C e C ++ e, mais cedo ou mais tarde, você falhará lá.  Aposto que você não gosta daqui? </p><br><pre> <code class="plaintext hljs">Error: execution of an external compiler program 'g++ -c -w -w -fpermissive -pthread -I/usr/lib/nim -I/home/user/c4/systems/network -o /home/user/.cache/nim/enet_d/@m..@s..@s..@s..@s..@s..@s.nimble@spkgs@smsgpack4nim-0.3.0@smsgpack4nim.nim.cpp:6987:136: note: initializing argument 2 of 'void unpack_type__k2dhaoojunqoSwgmQ9bNNug(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA*, NU&amp;)' 6987 | N_LIB_PRIVATE N_NIMCALL(void, unpack_type__k2dhaoojunqoSwgmQ9bNNug)(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA* s, NU&amp; val) { nimfr_("unpack_type", "/home/user/.nimble/pkgs/msgpack4nim-0.3.0/msgpack4nim.nim"); |</code> tyObject_MsgStreamcolonObjectType ___ kto5qgghQl207nm2KQZEDA * s, NU &amp; val) {nimfr _ ( "unpack_type", "/home/user/.nimble/pkgs/msgpack4nim-0.3.0/msgpack4nim.nim"); <code class="plaintext hljs">Error: execution of an external compiler program 'g++ -c -w -w -fpermissive -pthread -I/usr/lib/nim -I/home/user/c4/systems/network -o /home/user/.cache/nim/enet_d/@m..@s..@s..@s..@s..@s..@s.nimble@spkgs@smsgpack4nim-0.3.0@smsgpack4nim.nim.cpp:6987:136: note: initializing argument 2 of 'void unpack_type__k2dhaoojunqoSwgmQ9bNNug(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA*, NU&amp;)' 6987 | N_LIB_PRIVATE N_NIMCALL(void, unpack_type__k2dhaoojunqoSwgmQ9bNNug)(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA* s, NU&amp; val) { nimfr_("unpack_type", "/home/user/.nimble/pkgs/msgpack4nim-0.3.0/msgpack4nim.nim"); |</code> </pre> <br><pre> <code class="plaintext hljs">/usr/bin/ld: /home/user/.cache/nim/enet_d/stdlib_dollars.nim.cpp.o: in function `dollar___uR9bMx2FZlD8AoPom9cVY9ctA(tyObject_ConnectMessage__e5GUVMJGtJeVjEZUTYbwnA*)': stdlib_dollars.nim.cpp:(.text+0x229): undefined reference to `resizeString(NimStringDesc*, long)' /usr/bin/ld: stdlib_dollars.nim.cpp:(.text+0x267): undefined reference to `resizeString(NimStringDesc*, long)' /usr/bin/ld: stdlib_dollars.nim.cpp:(.text+0x2a2): undefined reference to `resizeString(NimStringDesc*, long)'</code> </pre> <br><h1 id="itak">  Então </h1><br><p>  Eu sou um programador idiota.  Não quero saber como o GC funciona, o que existe e como está vinculado, onde está armazenado em cache e como o lixo é removido.  É como um carro - em princípio, eu sei como funciona, um pouco sobre o alinhamento das rodas, um pouco sobre a caixa de velocidades, preciso preencher o óleo e outras coisas, mas, em geral, só quero me sentar e ir (e rápido) para a festa.  Uma máquina não é uma meta, mas um meio para atingir um fim.  Se quebrar, não quero entrar no assunto, mas leve-o ao serviço (no sentido, vou abrir o problema no github), e seria ótimo se eles o corrigissem rapidamente. </p><br><p>  Nim deveria ser uma máquina dessas.  Em parte, ele se tornou, mas ao mesmo tempo, quando corro pela estrada neste carro, meu volante cai e o espelho traseiro aponta para a frente.  Os engenheiros correm atrás de mim e prendem algo em tempo real ("agora seu carro é ainda mais rápido com esse novo spoiler"), mas a partir disso o porta-malas cai.  E você sabe o que?  Ainda gosto muito desse carro, porque este é o melhor de todos os carros que vi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462577/">https://habr.com/ru/post/pt462577/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462567/index.html">Sodinokibi Ransomware: um estudo detalhado</a></li>
<li><a href="../pt462569/index.html">O sistema de transporte conosco e com eles ou "Estações de ônibus contra agregadores 2"</a></li>
<li><a href="../pt462571/index.html">As aventuras dos indescritíveis Malvari: defesa versátil (pensamentos finais)</a></li>
<li><a href="../pt462573/index.html">Concursos em projetos: o que, por que e por quê?</a></li>
<li><a href="../pt462575/index.html">Semana 32 de segurança: falha no iMessage, privacidade da entrada de voz</a></li>
<li><a href="../pt462581/index.html">Como organizamos o primeiro leasing eletrônico e o que isso levou a</a></li>
<li><a href="../pt462583/index.html">Conheça o ponteiro determinista do coletor de lixo</a></li>
<li><a href="../pt462585/index.html">Criação rápida de CRUD com nest, @ nestjsx / crud e TestMace</a></li>
<li><a href="../pt462587/index.html">AirTest IDE e reconhecimento de imagem - Automação de teste de jogos para celular com base no reconhecimento de imagem</a></li>
<li><a href="../pt462589/index.html">Crie um pipeline para processamento de dados de streaming. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>