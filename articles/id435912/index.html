<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘§ğŸ» ğŸŒ¦ï¸ ğŸ¥ Masalah utama pengembangan antarmuka modern â†•ï¸ ğŸ¤˜ğŸ» ğŸ”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya sajikan kepada Anda terjemahan dari posting Dan Abramov "The Elements of UI Engineering" pada masalah dan tugas kontemporer yang haru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masalah utama pengembangan antarmuka modern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435912/">  Halo, Habr!  Saya sajikan kepada Anda terjemahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> Dan Abramov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"The Elements of UI Engineering"</a> pada masalah dan tugas kontemporer yang harus diselesaikan dalam antarmuka yang baik.  Penulis memeriksa masalah mendasar dalam pengembangan antarmuka, interpretasi dan solusi yang sendirian - tanpa menggunakan perpustakaan dan kerangka kerja yang sudah jadi - dapat memberikan pemahaman mendalam tentang solusi di bidang pengembangan frontend yang ada di pasar. <br><br><img src="https://habrastorage.org/webt/yu/ux/hz/yuuxhzbuo7lxanozsubwbhcjsb8.jpeg"><br><br><div class="spoiler">  <b class="spoiler_title">Catatan Penerjemah</b> <div class="spoiler_text">  Teks ditulis dan diterjemahkan sebagai orang pertama.  Penulis asli dalam bahasa Inggris adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dan Abramov</a> , pengembang perpustakaan React untuk membangun antarmuka pengguna yang kompleks. </div></div><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi terakhir</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya menulis tentang pentingnya bisa mengenali kesenjangan dalam pengetahuan seseorang.  Mungkin sepertinya aku menawarkanmu alasan untuk menjadi biasa-biasa saja.  Tidak semuanya!  Namun pada kenyataannya, pengetahuan kita adalah topik pembicaraan yang luas. <br><br>  Saya yakin bahwa Anda dapat memulai pengetahuan Anda â€œlangsungâ€ dan tidak perlu mempelajari teknologi (tumpukan teknologi untuk pengembangan web - sekitar Penerjemah) dalam urutan tertentu.  Tetapi saya juga percaya bahwa akumulasi pengalaman dan keterampilan profesional di bidang yang dipilih sangat penting.  Secara pribadi, saya selalu paling tertarik untuk membuat antarmuka pengguna. <br><br>  <b>Dan saya bertanya-tanya <i>apa yang</i> saya pahami dan <i>apa yang</i> saya temukan penting?</b>  Tentu saja, saya kenal baik dengan teknologi seperti Javascript dan Bereaksi.  Namun, hal paling penting yang datang dengan pengalaman sulit dipahami dan biasanya hilang ketika mencoba mengartikulasikan mereka secara akurat.  Saya tidak pernah mencoba memasukkannya ke dalam kata-kata.  Ini adalah upaya pertama saya untuk mensistematisasikan dan menggambarkan beberapa di antaranya. <br><a name="habracut"></a><br><hr><br>  Saat ini, ada banyak cara untuk mempelajari teknologi.  Perpustakaan mana yang bertaruh pada 2019?  Dan pada tahun 2020?  Haruskah saya mempelajari Vue atau React?  Atau sudut?  Bagaimana dengan Redux atau Rx?  Apakah saya perlu belajar Apollo?  ISTIRAHAT atau GraphQL?  Mudah tersesat di sini!  Selain itu, penulis mungkin juga salah. <br><br>  Prestasi terbesar saya dalam kognisi tidak terkait dengan teknologi tertentu.  Saya mulai lebih mengerti ketika saya sedang memecahkan masalah UI (Antarmuka Pengguna - sekitar. Penerjemah) tertentu.  Pada saat yang sama, kadang-kadang saya menemukan perpustakaan dan pola orang lain yang membantu saya memecahkan masalah.  Dan terkadang dia menulis keputusannya sendiri (baik dan buruk). <br>  Kombinasi ini - yang terdiri dari <i>memahami masalah</i> , bereksperimen dengan <i>alat</i> dan menerapkan berbagai <i>solusi</i> - memberi saya pengalaman dan keterampilan yang paling berharga.  <b>Posting ini hanya berfokus pada masalah yang saya bahas dalam pengembangan antarmuka pengguna.</b> <br><br><hr><br>  Jika Anda mengembangkan antarmuka pengguna, maka kemungkinan besar Anda menemukan beberapa masalah ini - langsung atau saat menggunakan perpustakaan.  Dalam kedua kasus, saya sarankan Anda bekerja pada aplikasi sederhana tanpa perpustakaan sama sekali, cobalah untuk mereproduksi dan menyelesaikan masalah ini.  Tidak ada satu solusi yang benar untuk mereka.  Pengalaman datang dengan mengenal masalah-masalah ini dan mengeksplorasi solusi yang mungkin, mengingat kekuatan dan kelemahan masing-masing. <br><br><h4>  Konsistensi </h4><br>  Anda menyukai pos dan tulisan itu muncul: "Anda dan 3 teman Anda lebih menghargainya."  Anda mengklik tombol Suka lagi dan tulisan itu menghilang.  Kedengarannya mudah!  Tetapi ada kemungkinan bahwa prasasti semacam itu ada di beberapa tempat di layar.  Ada kemungkinan bahwa ada juga indikasi visual tambahan untuk sejenisnya (misalnya, warna latar belakang tombol), yang juga harus berubah.  Dan daftar "likers", yang sebelumnya diterima dari server dan ditampilkan ketika Anda mengarahkan mouse, sekarang harus menyertakan nama Anda.  Dan jika Anda pergi ke bagian lain atau mengklik tombol Kembali, maka pos tersebut tidak boleh â€œlupaâ€ bahwa ia memiliki kesukaan Anda.  Seperti yang Anda lihat, bahkan integritas lokal untuk satu pengguna membuat sejumlah tugas sulit.  Pada saat yang sama, pengguna lain juga dapat berinteraksi dengan data yang ditampilkan pada Anda (misalnya, seperti posting yang Anda lihat).  Bagaimana kita menjaga data disinkronkan di berbagai bagian layar?  Bagaimana dan kapan kita harus memeriksa data lokal dengan server dan menerima / mengirim perubahan? <br><br><h4>  Responsif </h4><br>  Orang memungkinkan kurangnya umpan balik visual untuk tindakan mereka hanya untuk waktu yang sangat terbatas.  Untuk tindakan pengguna <i>terus</i> - <i>menerus</i> , seperti menggulir, kurangnya reaksi aplikasi hanya mungkin untuk periode yang terpendek.  Bahkan melewatkan satu frame pada 16 milidetik sudah terlihat bermasalah dan belum selesai.  Untuk tindakan <i>diskrit</i> (satu kali), seperti klik, menurut beberapa penelitian, pengguna biasanya merasakan keterlambatan dalam respons kurang dari 100 milidetik.  Jika tindakan membutuhkan waktu lebih lama, maka perlu untuk menunjukkan indikator visual.  Namun, ada beberapa tugas yang berlawanan dengan intuisi.  Indikator yang menyebabkan pergeseran pada templat halaman atau yang melewati beberapa tahap bergantian dapat membuat tindakan lebih lama â€œterasaâ€ daripada yang sebenarnya.  Demikian pula, respons aplikasi dalam 20 milidetik dengan melewatkan satu frame animasi mungkin "merasa" lebih lambat daripada animasi penuh dalam 30 milidetik.  Kesadaran kita tidak bekerja seperti tolok ukur.  Bagaimana kita membuat aplikasi responsif? <br><br><h4>  Waktu Respons (Latensi) </h4><br>  Komputer menghitung dan mentransmisikan data melalui jaringan membutuhkan waktu.  Terkadang kami dapat mengabaikan waktu perhitungan jika tidak memengaruhi responsif pada perangkat pengguna (namun, pastikan Anda telah menguji kode Anda pada perangkat lama dan anggaran).  Namun, memproses waktu pengiriman data melalui jaringan tidak dapat dihindari - ini dapat dihitung dalam hitungan detik!  Sebuah aplikasi tidak bisa begitu saja "hang" sambil menunggu data atau kode dimuat.  Ini berarti bahwa setiap tindakan yang memerlukan data, kode, atau aset baru berpotensi tidak sinkron dan harus menangani status muatannya.  Ini berlaku untuk sebagian besar layar dan elemen.  Bagaimana menangani penundaan pengiriman data dengan benar tanpa menampilkan kaskade pemintalan yang berputar atau "lubang" kosong di antarmuka?  Bagaimana cara menghindari pergeseran tata letak halaman?  Dan bagaimana cara mengubah dependensi asinkron tanpa perlu menulis ulang kode konstan? <br><br><h4>  Navigasi </h4><br>  Kami berharap antarmuka menjadi "stabil" saat berinteraksi dengannya.  Elemen seharusnya tidak tiba-tiba menghilang.  Navigasi, baik di dalam aplikasi (misalnya, tautan) dan eksternal (misalnya, tombol Kembali di browser) juga harus mematuhi prinsip ini.  Misalnya, beralih antara tab <code>/profile/likes</code> dan <code>/profile/follows</code> berikut di bagian pengguna tidak boleh membatalkan konten bidang pencarian di luar bagian ini.  Bahkan beralih ke layar lain harus terlihat seperti berjalan ke ruangan lain.  Orang-orang berharap bahwa ketika mereka kembali, mereka akan menemukan semua hal di mana mereka meninggalkan mereka (dan, mungkin, akan senang dengan beberapa hal baru).  Jika Anda berada di tengah-tengah rekaman Anda, klik pada tab profil, dan kemudian kembali ke kaset - maka Anda pasti tidak ingin menggulir ulang rekaman itu dari awal atau menunggu sampai keadaan masa lalu rekaman itu dimuat.  Bagaimana cara merancang aplikasi untuk menangani navigasi pengguna sewenang-wenang tanpa kehilangan konteks penting? <br><br><h4>  Staleness </h4><br>  Kita dapat membuat implementasi tombol Kembali seketika dengan menambahkan cache lokal ke aplikasi.  Untuk melakukan ini, kami akan menyimpan data yang diperlukan dalam cache (data dari kondisi sebelumnya - sekitar Penerjemah).  Kami bahkan dapat memperbarui cache secara teoritis untuk menjaga agar data tetap terbaru.  Namun, implementasi caching memerlukan tantangan baru.  Tembolok mungkin kedaluwarsa.  Jika saya mengubah avatar, maka itu harus diperbarui termasuk dalam cache.  Jika saya menerbitkan posting baru, maka itu akan segera muncul di cache, jika tidak cache akan menjadi tidak valid.  Kode semacam itu pada akhirnya menjadi terlalu rumit dan sulit dipertahankan.  Bagaimana jika proses penerbitan gagal?  Berapa lama cache dalam memori?  Saat kami mendapatkan kembali kumpulan data, apakah kami menggabungkan data baru dengan data yang di-cache sebelumnya, atau apakah kami membuang cache lama dan meng-cache seluruh set lagi?  Bagaimana seharusnya pagination dan sortasi disajikan dalam cache? <br><br><h4>  Entropi </h4><br>  Hukum kedua termodinamika berbunyi kira-kira sebagai berikut: "Seiring waktu, semuanya berubah menjadi berantakan total" (tentu saja tidak kata demi kata).  Ini juga berlaku untuk antarmuka pengguna.  Kami tidak dapat memprediksi tindakan pengguna tertentu dan urutannya.  Pada waktu tertentu, aplikasi kita dapat menjadi salah satu dari sejumlah besar negara (besar!).  Kami berusaha sebaik mungkin untuk membuat hasilnya dapat diprediksi dan terbatas sesuai dengan desain kami.  Kami tidak ingin melihat tangkapan layar dengan bug dan berpikir untuk diri kita sendiri: "Bagaimana ini bisa terjadi?"  Untuk <i>N</i> kemungkinan keadaan, ada <i>N Ã— (N - 1)</i> transisi yang mungkin di antara mereka.  Misalnya, jika lima keadaan berbeda dimungkinkan untuk sebuah tombol (normal, aktif, melayang, disorot, dan dinonaktifkan), maka kode yang bertanggung jawab untuk mengubah tombol harus benar untuk 5 Ã— 4 = 20 kemungkinan transisi - atau secara eksplisit melarang beberapa di antaranya.  Bagaimana kita berurusan dengan peningkatan kombinatorial dalam keadaan yang memungkinkan dan membuat keluaran visual yang dapat diprediksi? <br><br><h4>  Prioritas </h4><br>  Beberapa hal lebih penting daripada yang lain.  Mungkin antarmuka dialog Anda akan muncul secara ketat "di atas" tombol yang dipanggil, dan melampaui wadah induk.  Atau, tugas yang baru saja dijadwalkan (mis., Hasil klik) mungkin lebih penting daripada tugas jangka panjang yang telah dimulai.  Ketika aplikasi memperbesar, bagian-bagiannya yang berbeda, yang ditulis oleh orang yang berbeda atau bahkan tim, mulai bersaing untuk sumber daya yang terbatas, seperti daya komputasi prosesor, lalu lintas jaringan, ruang layar, atau ukuran bundel.  Kadang-kadang Anda dapat mendistribusikan item pada skala "kepentingan" tunggal, mirip dengan aturan CSS <code>z-index</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tetapi biasanya itu tidak berakhir dengan sesuatu yang baik</a> .  Setiap pengembang dengan tulus menganggap kode itu penting.  Tetapi jika semuanya sama pentingnya, artinya - tidak ada yang penting.  Bagaimana kita dapat membuat bagian independen dari aplikasi <i>berinteraksi</i> daripada memperjuangkan sumber daya yang terbatas? <br><br><h4>  Aksesibilitas </h4><br>  Situs yang tidak disesuaikan untuk penyandang cacat bukan masalah yang sangat terspesialisasi.  Misalnya, di Inggris setiap pengguna kelima menghadapi masalah ini (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini adalah</a> infografis visual).  Saya merasakannya sendiri.  Terlepas dari kenyataan bahwa saya hanya berusia 26 tahun, saya jarang menggunakan situs dengan font tipis dan skema warna buram.  Saya mencoba menggunakan trackpad lebih jarang, tetapi saya takut pada hari ketika saya harus menggunakan situs yang tidak cocok untuk keyboard.  Kita tidak boleh mengubah aplikasi kita menjadi mimpi buruk bagi para penyandang cacat - dan kabar baiknya adalah itu tidak terlalu sulit.  Anda harus mulai dengan mengeksplorasi solusi dan alat.  Selain itu, kita harus membuatnya sederhana dan mudah dipahami bagi desainer dan pengembang untuk membuat keputusan yang tepat.  Apa yang dapat kita lakukan untuk memastikan bahwa ketersediaan aplikasi kita diaktifkan secara default, dan bukan revisi yang terlambat? <br><br><h4>  Internasionalisasi </h4><br>  Aplikasi kita harus bekerja di seluruh dunia.  Ya, orang berbicara bahasa yang berbeda, tetapi selain itu, dukungan untuk menulis diperlukan dari kanan ke kiri, dan dengan upaya minimal dari pengembang.  Bagaimana kami dapat mendukung berbagai bahasa dan skrip tanpa kehilangan respons dan waktu respons aplikasi? <br><br><h4>  Pengiriman </h4><br>  Kita harus mengirimkan kode aplikasi ke komputer pengguna akhir.  Metode dan format transmisi apa yang akan kita gunakan?  Dalam pertanyaan ini, setiap jawaban akan berkompromi dengan kekuatan dan kelemahan masing-masing.  Misalnya, aplikasi asli harus mengunduh semua kode mereka terlebih dahulu karena ukurannya yang besar.  Meskipun aplikasi web biasanya memiliki waktu boot yang jauh lebih pendek, tetapi dipaksa untuk menangani banyak latensi dan unduhan saat digunakan.  Bagaimana kita memutuskan jenis penundaan untuk memilih dari dua opsi ini?  Bagaimana cara mengoptimalkan waktu respons berdasarkan statistik penggunaan pengguna?  Data apa yang perlu kita miliki untuk membuat keputusan terbaik? <br><br><h4>  Fleksibilitas (Ketahanan) </h4><br>  Tidak ada yang suka bertemu bug di program mereka sendiri.  Namun, beberapa bug pasti akan dapat diproduksi.  Dan ini sangat penting - apa yang akan terjadi kemudian.  Beberapa bug menyebabkan perilaku yang salah, tetapi secara ketat didefinisikan dan ditentukan sebelumnya.  Misalnya, kode Anda menunjukkan kondisi yang tidak pantas untuk kondisi tertentu.  Tetapi bagaimana jika, sebagai akibat dari bug, aplikasi sepenuhnya berhenti render?  Dalam hal ini, kami tidak akan dapat melanjutkan eksekusi program yang berarti, karena output visual tidak akan ditentukan.  Kesalahan saat merender satu pos dari umpan tidak boleh â€œmematahkanâ€ rendering seluruh umpan atau menempatkan aplikasi dalam keadaan tidak stabil, yang akan menyebabkan kesalahan lebih lanjut.  Bagaimana kita dapat menulis kode yang mengisolasi kesalahan ketika membuat atau menerima data di salah satu bagian dan melanjutkan operasi yang benar dari sisa aplikasi?  Apa arti toleransi kesalahan saat membuat antarmuka pengguna? <br><br><h4>  Abstraksi </h4><br>  Dalam aplikasi kecil, kita dapat melakukan hardcode dan menyelesaikan semua masalah di dahi.  Tetapi aplikasi cenderung tumbuh.  Kami ingin dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan kembali, bercabang, dan menggabungkan</a> berbagai bagian aplikasi dan melakukannya bersama-sama dengan orang lain.  Kami ingin mendefinisikan batas-batas yang dapat dimengerti antara bagian-bagian dari keseluruhan yang akan diterima oleh orang yang berbeda dan pada saat yang sama menghindari logika yang terlalu kaku, karena sering berubah dan berkembang dalam proses kerja.  Bagaimana kita membuat abstraksi yang menyembunyikan detail implementasi UI?  Bagaimana kita bisa menghindari terulangnya masalah ini dengan pertumbuhan aplikasi? <br><br><hr><br>  Tentu saja, ada banyak lagi masalah yang belum saya sebutkan.  Daftar ini sama sekali tidak lengkap atau lengkap.  Misalnya, saya tidak menyentuh topik kolaborasi antara desain dan pengembangan, topik debugging atau pengujian.  Mungkin kita akan kembali ke ini lain waktu. <br><br>  Sangat menggoda untuk membaca tentang masalah-masalah ini, mengingat sebagai solusi kerangka kerja khusus untuk menampilkan data atau pustaka untuk menerima data.  Tetapi saya sarankan Anda membayangkan bahwa solusi ini tidak ada dan coba baca lagi.  Bagaimana Anda mencoba menyelesaikan masalah ini?  Cobalah untuk mewujudkan ide-ide Anda pada aplikasi sederhana.  Saya akan senang melihat hasil percobaan Anda di Github.  (Cukup beri tag Dan Abramov di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> dan lampirkan tautan ke repositori - kira-kira. Penerjemah). <br><br>  Apa yang sangat menarik dalam masalah ini adalah bahwa kebanyakan dari mereka memanifestasikan diri pada skala apa pun.  Anda dapat menjumpai mereka ketika bekerja pada widget kecil, seperti tooltip, dan dalam aplikasi besar seperti Twitter atau Facebook. <br><br>  Pikirkan tentang elemen antarmuka pengguna non-sepele dari aplikasi yang ingin Anda gunakan, dan jalankan kembali daftar masalah di atas.  Bisakah Anda menggambarkan trade-off yang dibuat pengembang?  Cobalah untuk mereproduksi perilaku serupa dari awal! <br><br>  Saya menyadari banyak tentang pengembangan antarmuka pengguna yang baik, bereksperimen dengan masalah ini dalam aplikasi kecil tanpa menggunakan perpustakaan dan kerangka kerja pihak ketiga.  Saya merekomendasikan hal ini kepada siapa pun yang ingin mendapatkan pemahaman yang mendalam tentang solusi dan pertukaran ketika mengembangkan antarmuka yang kompleks. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435912/">https://habr.com/ru/post/id435912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435902/index.html">Anda tidak bisa hanya mengambil dan menulis PILIH jika vendor tidak mengizinkannya ... tetapi kami akan menulis</a></li>
<li><a href="../id435904/index.html">AI menerjemahkan aktivitas otak ke dalam ucapan</a></li>
<li><a href="../id435906/index.html">Penyimpanan Cluster Pacemaker + DRBD (Dual primer) + ctdb</a></li>
<li><a href="../id435908/index.html">Web asketis: prototipe pasar loak saat bepergian dan js</a></li>
<li><a href="../id435910/index.html">Mengapa BSD kalah dalam pertempuran dengan GNU / Linux?</a></li>
<li><a href="../id435914/index.html">Pengemasan Aplikasi Inti ASP.NET Menggunakan Docker</a></li>
<li><a href="../id435916/index.html">Meretas VK, otentikasi dua faktor tidak akan menyimpan</a></li>
<li><a href="../id435920/index.html">Buku Masakan Pengembang: Resep DDD (Bagian 4, Struktur)</a></li>
<li><a href="../id435922/index.html">Layanan Java, Spring, Kurento dan media. Bagian 2</a></li>
<li><a href="../id435924/index.html">Jaringan saraf menghasilkan gambar hidangan sesuai dengan resep untuk persiapan mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>