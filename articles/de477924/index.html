<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêù üë©üèø‚Äçüî¨ üëãüèº JavaFX Tutorial: CSS-Stil üåâ üö© üë©üèª‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie man JavaFX-Komponenten mit einem guten alten CSS formatiert. 

 Alle Beitr√§ge in der JavaFX-Reihe: 



1. JavaFX Tutorial: Erste Schritte 
2. Java...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaFX Tutorial: CSS-Stil</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477924/">  Wie man JavaFX-Komponenten mit einem guten alten CSS formatiert. <br><br>  Alle Beitr√§ge in der JavaFX-Reihe: <br><br><ol><li>  <a href="https://habr.com/ru/post/474292/">JavaFX Tutorial: Erste Schritte</a> </li><li>  <a href="https://habr.com/ru/post/474498/">JavaFX Tutorial: Hallo Welt!</a> </li><li>  <a href="https://habr.com/ru/post/474982/">JavaFX Tutorial: FXML und SceneBuilder</a> </li><li>  <a href="https://habr.com/ru/post/475882/">JavaFX Tutorial: Grundlegende Layouts</a> </li><li>  <a href="https://habr.com/ru/post/477408/">JavaFX Tutorial: Erweiterte Layouts</a> </li><li>  JavaFX Tutorial: CSS-Stil </li><li>  <a href="https://habr.com/ru/post/478402/">JavaFX Weaver: Integration von JavaFX- und Spring-Boot-Anwendungen</a> </li></ol><a name="habracut"></a><br><h3>  Trennung visueller Elemente </h3><br>  In einem fr√ºheren <a href="https://habr.com/ru/post/474982/">Artikel √ºber FXML haben</a> wir erfahren, wie JavaFX eine klare Aufgabentrennung erm√∂glicht, indem der Code der Benutzeroberfl√§che in zwei <a href="https://habr.com/ru/post/474982/">Teile aufgeteilt wird</a> .  Komponenten und ihre Eigenschaften werden in der FXML-Datei deklariert und die Interaktionslogik ist dem Controller eindeutig zugeordnet. <br><br>  Dar√ºber hinaus gibt es einen dritten Teil, die FXML-Sprache, die nur die Komponenten Ihrer Anwendung, ihre Eigenschaften und ihre Einbettung ineinander steuert.  Es definiert nicht die visuellen Elemente einer Komponente, n√§mlich: Schriftarten, Farben, Hintergr√ºnde, Einz√ºge.  Im Allgemeinen k√∂nnen Sie dies in FXML erreichen, sollten es aber nicht.  Stattdessen sollten visuelle Elemente in CSS-Stylesheets klar definiert sein. <br><br>  Auf diese Weise wird Ihr Design unabh√§ngig und kann leicht ersetzt oder ge√§ndert werden, ohne den Rest der Anwendung zu beeintr√§chtigen.  Sie k√∂nnen sogar einfach mehrere Themen implementieren, die auf Wunsch des Benutzers umgeschaltet werden k√∂nnen. <br><br><h3>  CSS </h3><br>  Sie sind wahrscheinlich mit CSS (Cascading Style Sheets) vertraut, mit denen HTML-Seiten im Web formatiert werden.  Ein √§hnlicher Ansatz ist in JavaFX implementiert, obwohl JavaFX eine Reihe eigener benutzerdefinierter Eigenschaften verwendet. <br><br>  Schauen wir uns ein Beispiel an: <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.button</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-font-size</span></span>: <span class="hljs-number"><span class="hljs-number">15px</span></span>; }</code> </pre> <br>  Hier werden zwei Hauptkonzepte verwendet.  Der erste ist der. <i>Button</i> Selector.  Es legt fest, auf welche Komponenten der Stil angewendet werden soll.  In diesem Beispiel wird der Stil auf alle Schaltfl√§chen angewendet. <br><br>  Der zweite Teil sind die tats√§chlichen Eigenschaften des Stils, die auf alle Komponenten angewendet werden, die zu unserer Auswahl passen.  Eigenschaften sind alles in geschweiften Klammern. <br><br>  Jede Eigenschaft hat eine bestimmte Bedeutung.  In unserem Beispiel gibt es die <i>Eigenschaft -fx-font-size</i> , die bestimmt, wie gro√ü der Text sein wird.  In diesem Beispiel ist der Wert <i>15px</i> , aber dieser Wert kann jeder andere sein. <br><br>  Zusammenfassend haben wir eine Regel erstellt, die besagt, dass alle Schaltfl√§chen √ºberall Text mit 15 Pixeln enthalten sollen. <br><br><h3>  Selektoren </h3><br>  Schauen wir uns nun genauer an, wie Selektoren in JavaFX funktionieren.  Dies geschieht fast genauso wie bei normalem CSS. <br><br><h3>  Klasse </h3><br>  Eine Klasse in CSS repr√§sentiert mehrere √§hnliche Elemente.  Zum Beispiel Schaltfl√§chen oder Kontrollk√§stchen.  Die Auswahl, die auf alle Elemente derselben Klasse angewendet werden soll, beginnt mit einem Punkt ".", Unmittelbar gefolgt vom Klassennamen.  Eine Klassennamenskonvention besteht darin, einzelne W√∂rter mit dem Zeichen "-" zu trennen.  Der folgende Selektor gilt f√ºr alle Elemente mit der <b>Beschriftungsklasse</b> . <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.label</span></span> { // Some properties }</code> </pre> <br><h3>  Eingebaute Klassen </h3><br>  Die gute Nachricht ist, dass alle in JavaFX integrierten Komponenten (wie Label oder Button) bereits eine vordefinierte Klasse haben.  Wenn Sie den Stil aller Beschriftungen in Ihrer Anwendung anpassen m√∂chten, m√ºssen Sie f√ºr jede Beschriftung keine benutzerdefinierten Klassen hinzuf√ºgen.  Jedes Etikett hat standardm√§√üig eine <i>Etikettenklasse</i> . <br><br>  Es ist einfach, den Klassennamen aus der Komponente zu ermitteln: <br><br><ul><li>  Nehmen Sie zum Beispiel den Namen der Java-Komponentenklasse.  <i>Label</i> </li><li>  Machen Sie den Namen in Kleinbuchstaben </li><li>  Wenn es aus mehreren W√∂rtern besteht, trennen Sie diese mit dem Symbol "-" </li></ul><br>  Einige Beispiele: <br><br><ul><li>  Beschriftung ‚Üí Beschriftung </li><li>  Kontrollk√§stchen ‚Üí Kontrollk√§stchen </li></ul><br>  Wenn Sie Klassen wie Selektoren verwenden, m√ºssen Sie "." Hinzuf√ºgen.  Dies bedeutet, dass der Selektor f√ºr die <i>Label-</i> Klasse <i>.label ist</i> . <br><br><h3>  Eigene Klassen </h3><br>  Wenn die integrierten Klassen nicht ausreichen, k√∂nnen Sie Ihren Komponenten eigene Klassen hinzuf√ºgen.  Sie k√∂nnen mehrere durch Komma getrennte Klassen verwenden: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">styleClass</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-label,other-class"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Oder in Java: <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I am a simple label"</span></span>); label.getStyleClass().addAll(<span class="hljs-string"><span class="hljs-string">"my-label"</span></span>, <span class="hljs-string"><span class="hljs-string">"other-class"</span></span>);</code> </pre> <br>  Durch das Hinzuf√ºgen von Klassen auf diese Weise wird die Komponentenklasse nicht standardm√§√üig entfernt (in diesem Fall <i>label</i> ). <br><br>  Es gibt eine spezielle Klasse namens <i>root</i> .  Es ist die Wurzelkomponente Ihrer Szene.  Sie k√∂nnen damit alles in Ihrer Szene gestalten (z. B. eine globale Schriftart festlegen).  Dies √§hnelt der Verwendung des Body-Tag-Selektors in HTML. <br><br><h3>  ID </h3><br>  Eine andere M√∂glichkeit, Komponenten in CSS auszuw√§hlen, ist die Verwendung einer Komponenten-ID.  Es ist eine eindeutige Kennung f√ºr eine Komponente.  Im Gegensatz zu Klassen, die mehreren Komponenten zugewiesen werden k√∂nnen, muss der Bezeichner in der Szene eindeutig sein. <br><br>  Das Symbol "." Kennzeichnet die Klasse.  Vor dem Namen in ihren Selektoren sind Bezeichner mit dem Symbol "#" gekennzeichnet. <br><br><pre> <code class="css hljs"><span class="hljs-selector-id"><span class="hljs-selector-id">#my-component</span></span> { ... }</code> </pre> <br>  In FXML k√∂nnen Sie mit <i>fx: id</i> die CSS-Kennung einer Komponente festlegen. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Es gibt jedoch eine Einschr√§nkung.  Mit demselben <a href="https://habr.com/ru/post/474982/">Bezeichner wird auf das in Ihrer Steuerung deklarierte Komponentenobjekt</a> mit demselben Namen verwiesen.  Da der Bezeichner und der Feldname im Controller √ºbereinstimmen m√ºssen, muss <i>fx: id</i> die Java-Namensbeschr√§nkung f√ºr Feldnamen ber√ºcksichtigen.  Obwohl die CSS-Namenskonvention einzelne W√∂rter definiert, die durch ein "-" getrennt sind, ist dies ein ung√ºltiges Zeichen f√ºr Java-Feldnamen.  Daher m√ºssen Sie f√ºr <i>fx: id</i> mit ein paar W√∂rtern eine andere Namenskonvention wie CamelCase oder einen Unterstrich verwenden. <br><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- This is not valid --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-label"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- This is valid --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my_label"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MyLabel"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In Java k√∂nnen Sie einfach die <i>setId ()</i> -Methode Ihrer Komponente aufrufen. <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I am a simple label"</span></span>); label.setId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>);</code> </pre> <br><h3>  Eigenschaften </h3><br>  Obwohl das in JavaFX verwendete CSS dem urspr√ºnglichen Web-CSS sehr √§hnlich ist, gibt es einen gro√üen Unterschied.  Eigenschaftsnamen sind unterschiedlich und es gibt viele neue JavaFX-spezifische Eigenschaften.  Sie haben das Pr√§fix <i>-fx-</i> . <br><br>  Hier einige Beispiele: <br><br><ul><li>  <i>-fx-background-color</i> : Hintergrundfarbe </li><li>  <i>-fx-text-fill</i> : <i>Textfarbe</i> </li><li>  <i>-fx-font-size</i> : <i>Textgr√∂√üe</i> </li></ul><br>  Eine Auflistung aller Objekte finden Sie im <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">offiziellen Planungshandbuch</a> . <br><br><h3>  Pseudoklassen </h3><br>  Neben den √ºblichen Klassen, die bestimmte Komponenten kennzeichnen, gibt es sogenannte Pseudoklassen, die den Zustand einer Komponente anzeigen.  Dies kann beispielsweise eine Klasse sein, mit der markiert wird, dass die Komponente den Fokus hat oder sich der Mauszeiger darauf befindet. <br><br>  Es gibt viele eingebaute Pseudoklassen.  Schauen wir uns den Knopf an.  Es gibt verschiedene Pseudoklassen, die Sie beispielsweise verwenden k√∂nnen: <br><br><ul><li>  <i>Hover</i> : Maus √ºber Button </li><li>  <i>fokussiert</i> : Die Schaltfl√§che ist fokussiert </li><li>  <i>disabled</i> : Schaltfl√§che ist deaktiviert </li><li>  <i>gedr√ºckt</i> : Taste gedr√ºckt </li></ul><br>  Pseudoklassen beginnen in CSS-Selektoren mit dem Zeichen ":" (z. B. <i>:: hover</i> ).  Nat√ºrlich m√ºssen Sie angeben, zu welcher Komponente Ihre Pseudoklasse geh√∂rt - zum Beispiel <i>button: hover</i> .  Das folgende Beispiel zeigt eine Auswahl, die f√ºr alle Schaltfl√§chen mit Fokus gilt: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:focused</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-background-color</span></span>: red; }</code> </pre> <br>  Im Gegensatz zu CSS, das nur grundlegende Pseudoklassen f√ºr Zust√§nde wie <i>focus</i> und <i>hover enth√§lt</i> , verf√ºgt JavaFX √ºber komponentenspezifische Pseudoklassen, die sich auf verschiedene Zust√§nde oder Eigenschaften von Komponenten beziehen. <br><br>  Zum Beispiel: <br><br><ul><li>  Bildlaufleisten haben <i>horizontale</i> und <i>vertikale</i> Pseudoklassen </li><li>  Elemente (Zellen) haben gerade und <i>ungerade</i> Pseudoklassen </li><li>  TitledPane hat Pseudoklassen <i>erweitert</i> und reduziert. </li></ul><br><h3>  Benutzerdefinierte Pseudoklassen </h3><br>  Zus√§tzlich zu den eingebauten Pseudoklassen k√∂nnen Sie Ihre eigenen Pseudoklassen definieren und verwenden. <br><br>  Lassen Sie uns ein eigenes Label erstellen (das von der Label-Klasse erbt).  Es wird eine neue logische Eigenschaft namens <i>shiny haben</i> .  In diesem Fall m√∂chten wir, dass unser Label eine <i>gl√§nzende</i> Pseudoklasse hat. <br><br>  Da das Tag eine <i>gl√§nzende</i> Pseudoklasse hat, k√∂nnen wir den Hintergrund des <i>Gold-</i> Tags festlegen: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.shiny-label</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:shiny</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-background-color</span></span>: gold; }</code> </pre><br>  Erstellen Sie nun die Klasse selbst. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShinyLabel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BooleanProperty shiny; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShinyLabel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ getStyleClass().add(<span class="hljs-string"><span class="hljs-string">"shiny-label"</span></span>); shiny = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleBooleanProperty(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); shiny.addListener(e -&gt; { pseudoClassStateChanged(PseudoClass.getPseudoClass(<span class="hljs-string"><span class="hljs-string">"shiny"</span></span>), shiny.get()); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isShiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shiny.get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setShiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shiny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shiny.set(shiny); } }</code> </pre><br>  Hier gibt es mehrere wichtige Teile: <br><br><ol><li>  Wir haben die Eigenschaft <i>BooleanProperty</i> <i>boolean</i> anstelle des √ºblichen <i>Booleschen</i> <i>Werts</i> .  Dies bedeutet, dass das <i>gl√§nzende</i> Objekt beobachtbar ist und wir √Ñnderungen in seinem Wert verfolgen (anh√∂ren) k√∂nnen. </li><li>  Wir registrieren einen Listener, der jedes Mal aufgerufen wird, wenn sich der Wert des <i>gl√§nzenden</i> Objekts mit <i>shiny.addListener ()</i> √§ndert. </li><li>  Wenn sich der <i>gl√§nzende</i> Wert √§ndert, wird die <i>gl√§nzende</i> <i>Pseudoklasse</i> abh√§ngig vom aktuellen Wert von <i>pseudoClassStateChanged (PseudoClass.getPseudoClass ("shiny"), shiny.get ()) hinzugef√ºgt / entfernt</i> . </li><li>  Wir f√ºgen eine benutzerdefinierte Klasse f√ºr alle <i>gl√§nzenden Beschriftungen hinzu</i> , anstatt nur die <i>Beschriftungsklasse</i> vom √ºbergeordneten Element zu erben.  Daher k√∂nnen wir nur <i>gl√§nzende</i> Tags ausw√§hlen. </li></ol><br><h3>  Standard-Stylesheet </h3><br>  Auch wenn Sie selbst keine Stile angeben, verf√ºgt jede JavaFX-Anwendung bereits √ºber einige visuelle Stile.  Es gibt ein Standard-Stylesheet, das f√ºr jede Anwendung gilt.  Es hei√üt <i>Modena</i> (seit JavaFX 8, fr√ºher <i>Kaspisch</i> ). <br><br>  Dieses Stylesheet finden Sie in der Datei: <br><br>  <i>jfxrt.jar \ com \ sun \ javafx \ scene \ control \ skin \ modena \ modena.css</i> <br><br>  Oder Sie finden die Datei <a href="">hier</a> .  Im selben Verzeichnis befinden sich viele Bilder, die vom Stylesheet verwendet werden. <br><br>  Dieses Stylesheet bietet Standardstile, hat jedoch die niedrigste Priorit√§t gegen√ºber anderen Stylesheet-Typen, sodass Sie es leicht √ºberschreiben k√∂nnen. <br><br><h3>  Szenen-Stylesheet </h3><br>  Zus√§tzlich zu dem oben genannten Standard-Stylesheet k√∂nnen Sie nat√ºrlich auch ein eigenes bereitstellen.  Die h√∂chste Ebene, auf der Sie die Stilisierung anwenden k√∂nnen, ist die gesamte Szene.  Sie k√∂nnen dies in Ihre FXML implementieren: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BorderPane</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://javafx.com/javafx"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:fx</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://javafx.com/fxml"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stylesheets</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> &gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BorderPane</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Oder in Ihrem Java-Code: <br><br><pre> <code class="java hljs">String stylesheet = getClass().getResource(<span class="hljs-string"><span class="hljs-string">"/styles.css"</span></span>).toExternalForm(); scene.getStylesheets().add(stylesheet);</code> </pre> <br>  <i>Achten Sie</i> auf den Aufruf <i>vonExternalForm ()</i> .  Scene erwartet, dass der Inhalt des Stylesheets als Zeichenfolge und nicht als Datei abgerufen wird. Daher m√ºssen wir den Inhalt unseres Stylesheets als Zeichenfolge bereitstellen. <br><br><h3>  √úbergeordnetes Stylesheet </h3><br>  Zus√§tzlich zum Stylesheet f√ºr die gesamte Szene ist es manchmal n√ºtzlich, Stile auf Layoutebene zu haben.  Das hei√üt - f√ºr einen separaten Container wie VBox, HBox oder GridPane.  Das gemeinsame √ºbergeordnete Element aller Layouts ist die √ºbergeordnete Klasse, die Methoden f√ºr die Verarbeitung von Stylesheets auf Layoutebene definiert.  Diese Stile gelten nur f√ºr die Komponenten in diesem Layout und nicht f√ºr die gesamte Szene.  Ein Stil auf Layoutebene hat Vorrang vor einem Stil auf Szenenebene. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HBox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stylesheets</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HBox</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In Java m√ºssen Sie den Inhalt des Stylesheets wie zuvor f√ºr die Szene selbst laden: <br><br><pre> <code class="java hljs">HBox box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HBox(); String stylesheet = getClass().getResource(<span class="hljs-string"><span class="hljs-string">"/styles.css"</span></span>).toExternalForm(); box.getStylesheets().add(stylesheet);</code> </pre> <br><h3>  Inline-Stile </h3><br>  Bisher haben wir nur F√§lle betrachtet, in denen ein externes Stylesheet einer gesamten Szene oder einem Layout zugewiesen wurde.  Sie k√∂nnen jedoch einzelne Stileigenschaften auf Komponentenebene festlegen. <br><br>  Hier m√ºssen Sie sich nicht um den Selektor k√ºmmern, da alle Eigenschaften f√ºr eine bestimmte Komponente festgelegt sind. <br><br>  Sie k√∂nnen mehrere durch Semikolon getrennte Eigenschaften angeben: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"-fx-background-color: blue; -fx-text-fill: white"</span></span></span><span class="hljs-tag">&gt;</span></span> I'm feeling blue. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In Java k√∂nnen Sie die Methode <i>setStyle ()</i> verwenden: <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I'm feeling blue."</span></span>); label.setStyle(<span class="hljs-string"><span class="hljs-string">"-fx-background-color: blue; -fx-text-fill: white"</span></span>);</code> </pre><br>  Stile auf Komponentenebene haben Vorrang vor Szenenstilen sowie √ºbergeordneten Stilen auf Layoutebene. <br><br><h3>  Warum m√ºssen Sie sie vermeiden </h3><br>  Styling auf Komponentenebene kann praktisch sein, ist aber eine schnelle und schmutzige L√∂sung.  Sie verzichten auf den Hauptvorteil von CSS, n√§mlich die Trennung von Stilen und Komponenten.  Jetzt binden Sie Ihre visuellen Elemente direkt an die Komponenten.  Sie k√∂nnen Ihre Stylesheets bei Bedarf nicht mehr einfach wechseln, Sie k√∂nnen keine Themen mehr √§ndern. <br><br>  Au√üerdem haben Sie keine zentrale Stelle mehr, an der Ihr Stil definiert ist.  Wenn Sie etwas in einer Reihe √§hnlicher Komponenten √§ndern m√ºssen, m√ºssen Sie jede der Komponenten einzeln √§ndern und d√ºrfen nicht nur eine Stelle im externen Stylesheet bearbeiten.  Daher sollten Inline-Komponentenstile vermieden werden. <br><br><h3>  Stylesheet-Priorit√§ten </h3><br>  Sie k√∂nnen das Styling auf verschiedenen Ebenen bereitstellen - Szenen-, √ºbergeordnete und Inline-Styles. Au√üerdem gibt es ein Standard-Modem-Stylesheet.  Wenn Sie dieselbe Eigenschaft derselben Komponente auf mehreren Ebenen √§ndern, hat JavaFX eine Priorit√§tseinstellung, die bestimmt, welche Stile verwendet werden sollen.  Priorit√§tenliste - von der h√∂chsten zur niedrigsten: <br><br><ol><li>  Inline-Stile </li><li>  √úbergeordnete Stile </li><li>  Szenenstile </li><li>  Standardstile </li></ol><br>  Das hei√üt, wenn Sie die Hintergrundfarbe einer bestimmten Beschriftung sowohl auf Inline- als auch auf Szenenebene festlegen, verwendet JavaFX den in den Inline-Stilen festgelegten Wert, da er eine h√∂here Priorit√§t hat. <br><br><h3>  Zus√§tzliche Lekt√ºre </h3><br>  JavaFX verf√ºgt √ºber viele CSS-Eigenschaften, deren Beschreibung den Rahmen dieses Beitrags <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">sprengt</a> . Eine detaillierte Liste finden Sie im <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">offiziellen CSS-Referenzhandbuch f√ºr JavaFX</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477924/">https://habr.com/ru/post/de477924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477910/index.html">Black Friday 2019 - VDS in Moskau und Amsterdam, Server mit GPU</a></li>
<li><a href="../de477912/index.html">Erste Eindr√ºcke vom 10,3-Zoll-PocketBook X-Reader mit E-Ink-Carta-Mobius-Bildschirm</a></li>
<li><a href="../de477914/index.html">Projektion an der Decke: Eindr√ºcke nach einer Woche mit dem Projektor "am Ende" setzen</a></li>
<li><a href="../de477916/index.html">Wie die Sch√∂pfer b√∂sartiger Software versuchen, ihre Entdeckung zu vermeiden: Wir analysieren Spy.GmFUToMitm als Beispiel</a></li>
<li><a href="../de477918/index.html">Open Source Helpdesk als Alternative zu Zendesk und Help Scout. Architektur, Design und Benutzerfreundlichkeit</a></li>
<li><a href="../de477926/index.html">So reduzieren Sie die Speichernutzung und beschleunigen den Python-Code mithilfe von Generatoren</a></li>
<li><a href="../de477928/index.html">Aufzeichnungen von Berichten von QA-mitap Redmadrobot</a></li>
<li><a href="../de477930/index.html">Beste Architektur f√ºr MVP: Monolith, SOA, Microservices oder Serverless? Teil 2</a></li>
<li><a href="../de477934/index.html">Rabatte von Hostern am Black Friday 2019</a></li>
<li><a href="../de477936/index.html">IT-W√∂rterbuch oder was? Wo? Wohin Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>