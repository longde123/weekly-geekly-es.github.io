<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐝 👩🏿‍🔬 👋🏼 JavaFX Tutorial: CSS-Stil 🌉 🚩 👩🏻‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie man JavaFX-Komponenten mit einem guten alten CSS formatiert. 

 Alle Beiträge in der JavaFX-Reihe: 



1. JavaFX Tutorial: Erste Schritte 
2. Java...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaFX Tutorial: CSS-Stil</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477924/">  Wie man JavaFX-Komponenten mit einem guten alten CSS formatiert. <br><br>  Alle Beiträge in der JavaFX-Reihe: <br><br><ol><li>  <a href="https://habr.com/ru/post/474292/">JavaFX Tutorial: Erste Schritte</a> </li><li>  <a href="https://habr.com/ru/post/474498/">JavaFX Tutorial: Hallo Welt!</a> </li><li>  <a href="https://habr.com/ru/post/474982/">JavaFX Tutorial: FXML und SceneBuilder</a> </li><li>  <a href="https://habr.com/ru/post/475882/">JavaFX Tutorial: Grundlegende Layouts</a> </li><li>  <a href="https://habr.com/ru/post/477408/">JavaFX Tutorial: Erweiterte Layouts</a> </li><li>  JavaFX Tutorial: CSS-Stil </li><li>  <a href="https://habr.com/ru/post/478402/">JavaFX Weaver: Integration von JavaFX- und Spring-Boot-Anwendungen</a> </li></ol><a name="habracut"></a><br><h3>  Trennung visueller Elemente </h3><br>  In einem früheren <a href="https://habr.com/ru/post/474982/">Artikel über FXML haben</a> wir erfahren, wie JavaFX eine klare Aufgabentrennung ermöglicht, indem der Code der Benutzeroberfläche in zwei <a href="https://habr.com/ru/post/474982/">Teile aufgeteilt wird</a> .  Komponenten und ihre Eigenschaften werden in der FXML-Datei deklariert und die Interaktionslogik ist dem Controller eindeutig zugeordnet. <br><br>  Darüber hinaus gibt es einen dritten Teil, die FXML-Sprache, die nur die Komponenten Ihrer Anwendung, ihre Eigenschaften und ihre Einbettung ineinander steuert.  Es definiert nicht die visuellen Elemente einer Komponente, nämlich: Schriftarten, Farben, Hintergründe, Einzüge.  Im Allgemeinen können Sie dies in FXML erreichen, sollten es aber nicht.  Stattdessen sollten visuelle Elemente in CSS-Stylesheets klar definiert sein. <br><br>  Auf diese Weise wird Ihr Design unabhängig und kann leicht ersetzt oder geändert werden, ohne den Rest der Anwendung zu beeinträchtigen.  Sie können sogar einfach mehrere Themen implementieren, die auf Wunsch des Benutzers umgeschaltet werden können. <br><br><h3>  CSS </h3><br>  Sie sind wahrscheinlich mit CSS (Cascading Style Sheets) vertraut, mit denen HTML-Seiten im Web formatiert werden.  Ein ähnlicher Ansatz ist in JavaFX implementiert, obwohl JavaFX eine Reihe eigener benutzerdefinierter Eigenschaften verwendet. <br><br>  Schauen wir uns ein Beispiel an: <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.button</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-font-size</span></span>: <span class="hljs-number"><span class="hljs-number">15px</span></span>; }</code> </pre> <br>  Hier werden zwei Hauptkonzepte verwendet.  Der erste ist der. <i>Button</i> Selector.  Es legt fest, auf welche Komponenten der Stil angewendet werden soll.  In diesem Beispiel wird der Stil auf alle Schaltflächen angewendet. <br><br>  Der zweite Teil sind die tatsächlichen Eigenschaften des Stils, die auf alle Komponenten angewendet werden, die zu unserer Auswahl passen.  Eigenschaften sind alles in geschweiften Klammern. <br><br>  Jede Eigenschaft hat eine bestimmte Bedeutung.  In unserem Beispiel gibt es die <i>Eigenschaft -fx-font-size</i> , die bestimmt, wie groß der Text sein wird.  In diesem Beispiel ist der Wert <i>15px</i> , aber dieser Wert kann jeder andere sein. <br><br>  Zusammenfassend haben wir eine Regel erstellt, die besagt, dass alle Schaltflächen überall Text mit 15 Pixeln enthalten sollen. <br><br><h3>  Selektoren </h3><br>  Schauen wir uns nun genauer an, wie Selektoren in JavaFX funktionieren.  Dies geschieht fast genauso wie bei normalem CSS. <br><br><h3>  Klasse </h3><br>  Eine Klasse in CSS repräsentiert mehrere ähnliche Elemente.  Zum Beispiel Schaltflächen oder Kontrollkästchen.  Die Auswahl, die auf alle Elemente derselben Klasse angewendet werden soll, beginnt mit einem Punkt ".", Unmittelbar gefolgt vom Klassennamen.  Eine Klassennamenskonvention besteht darin, einzelne Wörter mit dem Zeichen "-" zu trennen.  Der folgende Selektor gilt für alle Elemente mit der <b>Beschriftungsklasse</b> . <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.label</span></span> { // Some properties }</code> </pre> <br><h3>  Eingebaute Klassen </h3><br>  Die gute Nachricht ist, dass alle in JavaFX integrierten Komponenten (wie Label oder Button) bereits eine vordefinierte Klasse haben.  Wenn Sie den Stil aller Beschriftungen in Ihrer Anwendung anpassen möchten, müssen Sie für jede Beschriftung keine benutzerdefinierten Klassen hinzufügen.  Jedes Etikett hat standardmäßig eine <i>Etikettenklasse</i> . <br><br>  Es ist einfach, den Klassennamen aus der Komponente zu ermitteln: <br><br><ul><li>  Nehmen Sie zum Beispiel den Namen der Java-Komponentenklasse.  <i>Label</i> </li><li>  Machen Sie den Namen in Kleinbuchstaben </li><li>  Wenn es aus mehreren Wörtern besteht, trennen Sie diese mit dem Symbol "-" </li></ul><br>  Einige Beispiele: <br><br><ul><li>  Beschriftung → Beschriftung </li><li>  Kontrollkästchen → Kontrollkästchen </li></ul><br>  Wenn Sie Klassen wie Selektoren verwenden, müssen Sie "." Hinzufügen.  Dies bedeutet, dass der Selektor für die <i>Label-</i> Klasse <i>.label ist</i> . <br><br><h3>  Eigene Klassen </h3><br>  Wenn die integrierten Klassen nicht ausreichen, können Sie Ihren Komponenten eigene Klassen hinzufügen.  Sie können mehrere durch Komma getrennte Klassen verwenden: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">styleClass</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-label,other-class"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Oder in Java: <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I am a simple label"</span></span>); label.getStyleClass().addAll(<span class="hljs-string"><span class="hljs-string">"my-label"</span></span>, <span class="hljs-string"><span class="hljs-string">"other-class"</span></span>);</code> </pre> <br>  Durch das Hinzufügen von Klassen auf diese Weise wird die Komponentenklasse nicht standardmäßig entfernt (in diesem Fall <i>label</i> ). <br><br>  Es gibt eine spezielle Klasse namens <i>root</i> .  Es ist die Wurzelkomponente Ihrer Szene.  Sie können damit alles in Ihrer Szene gestalten (z. B. eine globale Schriftart festlegen).  Dies ähnelt der Verwendung des Body-Tag-Selektors in HTML. <br><br><h3>  ID </h3><br>  Eine andere Möglichkeit, Komponenten in CSS auszuwählen, ist die Verwendung einer Komponenten-ID.  Es ist eine eindeutige Kennung für eine Komponente.  Im Gegensatz zu Klassen, die mehreren Komponenten zugewiesen werden können, muss der Bezeichner in der Szene eindeutig sein. <br><br>  Das Symbol "." Kennzeichnet die Klasse.  Vor dem Namen in ihren Selektoren sind Bezeichner mit dem Symbol "#" gekennzeichnet. <br><br><pre> <code class="css hljs"><span class="hljs-selector-id"><span class="hljs-selector-id">#my-component</span></span> { ... }</code> </pre> <br>  In FXML können Sie mit <i>fx: id</i> die CSS-Kennung einer Komponente festlegen. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Es gibt jedoch eine Einschränkung.  Mit demselben <a href="https://habr.com/ru/post/474982/">Bezeichner wird auf das in Ihrer Steuerung deklarierte Komponentenobjekt</a> mit demselben Namen verwiesen.  Da der Bezeichner und der Feldname im Controller übereinstimmen müssen, muss <i>fx: id</i> die Java-Namensbeschränkung für Feldnamen berücksichtigen.  Obwohl die CSS-Namenskonvention einzelne Wörter definiert, die durch ein "-" getrennt sind, ist dies ein ungültiges Zeichen für Java-Feldnamen.  Daher müssen Sie für <i>fx: id</i> mit ein paar Wörtern eine andere Namenskonvention wie CamelCase oder einen Unterstrich verwenden. <br><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- This is not valid --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-label"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- This is valid --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my_label"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MyLabel"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In Java können Sie einfach die <i>setId ()</i> -Methode Ihrer Komponente aufrufen. <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I am a simple label"</span></span>); label.setId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>);</code> </pre> <br><h3>  Eigenschaften </h3><br>  Obwohl das in JavaFX verwendete CSS dem ursprünglichen Web-CSS sehr ähnlich ist, gibt es einen großen Unterschied.  Eigenschaftsnamen sind unterschiedlich und es gibt viele neue JavaFX-spezifische Eigenschaften.  Sie haben das Präfix <i>-fx-</i> . <br><br>  Hier einige Beispiele: <br><br><ul><li>  <i>-fx-background-color</i> : Hintergrundfarbe </li><li>  <i>-fx-text-fill</i> : <i>Textfarbe</i> </li><li>  <i>-fx-font-size</i> : <i>Textgröße</i> </li></ul><br>  Eine Auflistung aller Objekte finden Sie im <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">offiziellen Planungshandbuch</a> . <br><br><h3>  Pseudoklassen </h3><br>  Neben den üblichen Klassen, die bestimmte Komponenten kennzeichnen, gibt es sogenannte Pseudoklassen, die den Zustand einer Komponente anzeigen.  Dies kann beispielsweise eine Klasse sein, mit der markiert wird, dass die Komponente den Fokus hat oder sich der Mauszeiger darauf befindet. <br><br>  Es gibt viele eingebaute Pseudoklassen.  Schauen wir uns den Knopf an.  Es gibt verschiedene Pseudoklassen, die Sie beispielsweise verwenden können: <br><br><ul><li>  <i>Hover</i> : Maus über Button </li><li>  <i>fokussiert</i> : Die Schaltfläche ist fokussiert </li><li>  <i>disabled</i> : Schaltfläche ist deaktiviert </li><li>  <i>gedrückt</i> : Taste gedrückt </li></ul><br>  Pseudoklassen beginnen in CSS-Selektoren mit dem Zeichen ":" (z. B. <i>:: hover</i> ).  Natürlich müssen Sie angeben, zu welcher Komponente Ihre Pseudoklasse gehört - zum Beispiel <i>button: hover</i> .  Das folgende Beispiel zeigt eine Auswahl, die für alle Schaltflächen mit Fokus gilt: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:focused</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-background-color</span></span>: red; }</code> </pre> <br>  Im Gegensatz zu CSS, das nur grundlegende Pseudoklassen für Zustände wie <i>focus</i> und <i>hover enthält</i> , verfügt JavaFX über komponentenspezifische Pseudoklassen, die sich auf verschiedene Zustände oder Eigenschaften von Komponenten beziehen. <br><br>  Zum Beispiel: <br><br><ul><li>  Bildlaufleisten haben <i>horizontale</i> und <i>vertikale</i> Pseudoklassen </li><li>  Elemente (Zellen) haben gerade und <i>ungerade</i> Pseudoklassen </li><li>  TitledPane hat Pseudoklassen <i>erweitert</i> und reduziert. </li></ul><br><h3>  Benutzerdefinierte Pseudoklassen </h3><br>  Zusätzlich zu den eingebauten Pseudoklassen können Sie Ihre eigenen Pseudoklassen definieren und verwenden. <br><br>  Lassen Sie uns ein eigenes Label erstellen (das von der Label-Klasse erbt).  Es wird eine neue logische Eigenschaft namens <i>shiny haben</i> .  In diesem Fall möchten wir, dass unser Label eine <i>glänzende</i> Pseudoklasse hat. <br><br>  Da das Tag eine <i>glänzende</i> Pseudoklasse hat, können wir den Hintergrund des <i>Gold-</i> Tags festlegen: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.shiny-label</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:shiny</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-background-color</span></span>: gold; }</code> </pre><br>  Erstellen Sie nun die Klasse selbst. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShinyLabel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BooleanProperty shiny; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShinyLabel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ getStyleClass().add(<span class="hljs-string"><span class="hljs-string">"shiny-label"</span></span>); shiny = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleBooleanProperty(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); shiny.addListener(e -&gt; { pseudoClassStateChanged(PseudoClass.getPseudoClass(<span class="hljs-string"><span class="hljs-string">"shiny"</span></span>), shiny.get()); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isShiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shiny.get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setShiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shiny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shiny.set(shiny); } }</code> </pre><br>  Hier gibt es mehrere wichtige Teile: <br><br><ol><li>  Wir haben die Eigenschaft <i>BooleanProperty</i> <i>boolean</i> anstelle des üblichen <i>Booleschen</i> <i>Werts</i> .  Dies bedeutet, dass das <i>glänzende</i> Objekt beobachtbar ist und wir Änderungen in seinem Wert verfolgen (anhören) können. </li><li>  Wir registrieren einen Listener, der jedes Mal aufgerufen wird, wenn sich der Wert des <i>glänzenden</i> Objekts mit <i>shiny.addListener ()</i> ändert. </li><li>  Wenn sich der <i>glänzende</i> Wert ändert, wird die <i>glänzende</i> <i>Pseudoklasse</i> abhängig vom aktuellen Wert von <i>pseudoClassStateChanged (PseudoClass.getPseudoClass ("shiny"), shiny.get ()) hinzugefügt / entfernt</i> . </li><li>  Wir fügen eine benutzerdefinierte Klasse für alle <i>glänzenden Beschriftungen hinzu</i> , anstatt nur die <i>Beschriftungsklasse</i> vom übergeordneten Element zu erben.  Daher können wir nur <i>glänzende</i> Tags auswählen. </li></ol><br><h3>  Standard-Stylesheet </h3><br>  Auch wenn Sie selbst keine Stile angeben, verfügt jede JavaFX-Anwendung bereits über einige visuelle Stile.  Es gibt ein Standard-Stylesheet, das für jede Anwendung gilt.  Es heißt <i>Modena</i> (seit JavaFX 8, früher <i>Kaspisch</i> ). <br><br>  Dieses Stylesheet finden Sie in der Datei: <br><br>  <i>jfxrt.jar \ com \ sun \ javafx \ scene \ control \ skin \ modena \ modena.css</i> <br><br>  Oder Sie finden die Datei <a href="">hier</a> .  Im selben Verzeichnis befinden sich viele Bilder, die vom Stylesheet verwendet werden. <br><br>  Dieses Stylesheet bietet Standardstile, hat jedoch die niedrigste Priorität gegenüber anderen Stylesheet-Typen, sodass Sie es leicht überschreiben können. <br><br><h3>  Szenen-Stylesheet </h3><br>  Zusätzlich zu dem oben genannten Standard-Stylesheet können Sie natürlich auch ein eigenes bereitstellen.  Die höchste Ebene, auf der Sie die Stilisierung anwenden können, ist die gesamte Szene.  Sie können dies in Ihre FXML implementieren: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BorderPane</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://javafx.com/javafx"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:fx</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://javafx.com/fxml"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stylesheets</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> &gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BorderPane</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Oder in Ihrem Java-Code: <br><br><pre> <code class="java hljs">String stylesheet = getClass().getResource(<span class="hljs-string"><span class="hljs-string">"/styles.css"</span></span>).toExternalForm(); scene.getStylesheets().add(stylesheet);</code> </pre> <br>  <i>Achten Sie</i> auf den Aufruf <i>vonExternalForm ()</i> .  Scene erwartet, dass der Inhalt des Stylesheets als Zeichenfolge und nicht als Datei abgerufen wird. Daher müssen wir den Inhalt unseres Stylesheets als Zeichenfolge bereitstellen. <br><br><h3>  Übergeordnetes Stylesheet </h3><br>  Zusätzlich zum Stylesheet für die gesamte Szene ist es manchmal nützlich, Stile auf Layoutebene zu haben.  Das heißt - für einen separaten Container wie VBox, HBox oder GridPane.  Das gemeinsame übergeordnete Element aller Layouts ist die übergeordnete Klasse, die Methoden für die Verarbeitung von Stylesheets auf Layoutebene definiert.  Diese Stile gelten nur für die Komponenten in diesem Layout und nicht für die gesamte Szene.  Ein Stil auf Layoutebene hat Vorrang vor einem Stil auf Szenenebene. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HBox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stylesheets</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HBox</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In Java müssen Sie den Inhalt des Stylesheets wie zuvor für die Szene selbst laden: <br><br><pre> <code class="java hljs">HBox box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HBox(); String stylesheet = getClass().getResource(<span class="hljs-string"><span class="hljs-string">"/styles.css"</span></span>).toExternalForm(); box.getStylesheets().add(stylesheet);</code> </pre> <br><h3>  Inline-Stile </h3><br>  Bisher haben wir nur Fälle betrachtet, in denen ein externes Stylesheet einer gesamten Szene oder einem Layout zugewiesen wurde.  Sie können jedoch einzelne Stileigenschaften auf Komponentenebene festlegen. <br><br>  Hier müssen Sie sich nicht um den Selektor kümmern, da alle Eigenschaften für eine bestimmte Komponente festgelegt sind. <br><br>  Sie können mehrere durch Semikolon getrennte Eigenschaften angeben: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"-fx-background-color: blue; -fx-text-fill: white"</span></span></span><span class="hljs-tag">&gt;</span></span> I'm feeling blue. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In Java können Sie die Methode <i>setStyle ()</i> verwenden: <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I'm feeling blue."</span></span>); label.setStyle(<span class="hljs-string"><span class="hljs-string">"-fx-background-color: blue; -fx-text-fill: white"</span></span>);</code> </pre><br>  Stile auf Komponentenebene haben Vorrang vor Szenenstilen sowie übergeordneten Stilen auf Layoutebene. <br><br><h3>  Warum müssen Sie sie vermeiden </h3><br>  Styling auf Komponentenebene kann praktisch sein, ist aber eine schnelle und schmutzige Lösung.  Sie verzichten auf den Hauptvorteil von CSS, nämlich die Trennung von Stilen und Komponenten.  Jetzt binden Sie Ihre visuellen Elemente direkt an die Komponenten.  Sie können Ihre Stylesheets bei Bedarf nicht mehr einfach wechseln, Sie können keine Themen mehr ändern. <br><br>  Außerdem haben Sie keine zentrale Stelle mehr, an der Ihr Stil definiert ist.  Wenn Sie etwas in einer Reihe ähnlicher Komponenten ändern müssen, müssen Sie jede der Komponenten einzeln ändern und dürfen nicht nur eine Stelle im externen Stylesheet bearbeiten.  Daher sollten Inline-Komponentenstile vermieden werden. <br><br><h3>  Stylesheet-Prioritäten </h3><br>  Sie können das Styling auf verschiedenen Ebenen bereitstellen - Szenen-, übergeordnete und Inline-Styles. Außerdem gibt es ein Standard-Modem-Stylesheet.  Wenn Sie dieselbe Eigenschaft derselben Komponente auf mehreren Ebenen ändern, hat JavaFX eine Prioritätseinstellung, die bestimmt, welche Stile verwendet werden sollen.  Prioritätenliste - von der höchsten zur niedrigsten: <br><br><ol><li>  Inline-Stile </li><li>  Übergeordnete Stile </li><li>  Szenenstile </li><li>  Standardstile </li></ol><br>  Das heißt, wenn Sie die Hintergrundfarbe einer bestimmten Beschriftung sowohl auf Inline- als auch auf Szenenebene festlegen, verwendet JavaFX den in den Inline-Stilen festgelegten Wert, da er eine höhere Priorität hat. <br><br><h3>  Zusätzliche Lektüre </h3><br>  JavaFX verfügt über viele CSS-Eigenschaften, deren Beschreibung den Rahmen dieses Beitrags <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">sprengt</a> . Eine detaillierte Liste finden Sie im <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">offiziellen CSS-Referenzhandbuch für JavaFX</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477924/">https://habr.com/ru/post/de477924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477910/index.html">Black Friday 2019 - VDS in Moskau und Amsterdam, Server mit GPU</a></li>
<li><a href="../de477912/index.html">Erste Eindrücke vom 10,3-Zoll-PocketBook X-Reader mit E-Ink-Carta-Mobius-Bildschirm</a></li>
<li><a href="../de477914/index.html">Projektion an der Decke: Eindrücke nach einer Woche mit dem Projektor "am Ende" setzen</a></li>
<li><a href="../de477916/index.html">Wie die Schöpfer bösartiger Software versuchen, ihre Entdeckung zu vermeiden: Wir analysieren Spy.GmFUToMitm als Beispiel</a></li>
<li><a href="../de477918/index.html">Open Source Helpdesk als Alternative zu Zendesk und Help Scout. Architektur, Design und Benutzerfreundlichkeit</a></li>
<li><a href="../de477926/index.html">So reduzieren Sie die Speichernutzung und beschleunigen den Python-Code mithilfe von Generatoren</a></li>
<li><a href="../de477928/index.html">Aufzeichnungen von Berichten von QA-mitap Redmadrobot</a></li>
<li><a href="../de477930/index.html">Beste Architektur für MVP: Monolith, SOA, Microservices oder Serverless? Teil 2</a></li>
<li><a href="../de477934/index.html">Rabatte von Hostern am Black Friday 2019</a></li>
<li><a href="../de477936/index.html">IT-Wörterbuch oder was? Wo? Wohin Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>