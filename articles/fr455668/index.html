<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôà ü¶Ç üï¥üèª Nous √©crivons sous FPGA sans HDL. Comparaison d'outils de d√©veloppement de haut niveau ‚ô†Ô∏è üë©üèΩ‚Äçüéì ‚ô®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, les fabricants de FPGA et des soci√©t√©s tierces ont d√©velopp√© activement des m√©thodes de d√©veloppement pour les FPGA qui diff√®rent des appro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons sous FPGA sans HDL. Comparaison d'outils de d√©veloppement de haut niveau</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455668/">  R√©cemment, les fabricants de FPGA et des soci√©t√©s tierces ont d√©velopp√© activement des m√©thodes de d√©veloppement pour les FPGA qui diff√®rent des approches conventionnelles utilisant des outils de d√©veloppement de haut niveau. <br><br>  En tant que d√©veloppeur FPGA, j'utilise le langage de description mat√©rielle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDL</a> ) de Verilog comme outil principal, mais la popularit√© croissante des nouvelles m√©thodes a suscit√© mon grand int√©r√™t, alors dans cet article, j'ai d√©cid√© de comprendre ce qui se passait. <br><br>  Cet article n'est pas un guide ou une instruction d'utilisation, c'est mon examen et mes conclusions sur ce que divers outils de d√©veloppement de haut niveau peuvent donner √† un d√©veloppeur ou programmeur FPGA qui veut plonger dans le monde du FPGA.  Afin de comparer les outils de d√©veloppement les plus int√©ressants √† mon avis, j'ai √©crit plusieurs tests et analys√© les r√©sultats.  Sous la coupe - ce qui en est sorti. <br><a name="habracut"></a><br><h2>  Pourquoi avez-vous besoin d'outils de d√©veloppement de haut niveau pour FPGA? </h2><br><ul><li>  Acc√©l√©rez le d√©veloppement du projet <br>  - en raison de la r√©utilisation de code d√©j√† √©crit dans des langages de haut niveau; <br>  - gr√¢ce √† l'utilisation de tous les avantages des langages de haut niveau, lors de l'√©criture de code √† partir de z√©ro; <br>  - en r√©duisant le temps de compilation et la v√©rification du code. <br></li><li>  Possibilit√© de cr√©er du code universel qui fonctionnera sur n'importe quelle famille FPGA. </li><li>  R√©duisez le seuil de d√©veloppement des FPGA, par exemple, en √©vitant les concepts de ¬´vitesse d'horloge¬ª et d'autres entit√©s de bas niveau.  Possibilit√© d'√©crire du code pour FPGA √† un d√©veloppeur qui n'est pas familier avec HDL. </li></ul><br><h2>  D'o√π viennent les outils de d√©veloppement de haut niveau? </h2><br>  Aujourd'hui, beaucoup sont attir√©s par l'id√©e d'un d√©veloppement de haut niveau.  Des passionn√©s, comme par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quokka</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le g√©n√©rateur de code Python</a> , ainsi que des soci√©t√©s telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mathworks</a> et les fabricants de FPGA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Xilinx s'y</a> sont engag√©s. <br><br>  Chacun utilise ses m√©thodes et ses outils pour atteindre son objectif.  Les amateurs de lutte pour un monde parfait et beau utilisent leurs langages de d√©veloppement pr√©f√©r√©s, tels que Python ou C #.  Les entreprises, essayant de plaire au client, proposent les leurs ou adaptent les outils existants.  Mathworks propose son propre outil de codage HDL pour g√©n√©rer du code HDL √† partir de scripts m et de mod√®les Simulink, tandis qu'Intel et Xilinx proposent des compilateurs pour le C / C ++ commun. <br><br>  √Ä l'heure actuelle, les entreprises dot√©es de ressources financi√®res et humaines importantes ont connu un plus grand succ√®s, tandis que les passionn√©s sont quelque peu en retard.  Cet article sera consacr√© √† l'examen du codeur HDL produit de Mathworks et du compilateur HLS d'Intel. <br><br><div class="spoiler">  <b class="spoiler_title">Qu'en est-il de Xilinx</b> <div class="spoiler_text">  Dans cet article, je ne consid√®re pas HIL de Xilinx, en raison des diff√©rentes architectures et syst√®mes de CAO d'Intel et de Xilinx, ce qui rend impossible de faire une comparaison sans ambigu√Øt√© des r√©sultats.  Mais je veux noter que Xilinx HLS, comme Intel HLS, fournit un compilateur C / C ++ et ils sont conceptuellement similaires. <br></div></div><br>  Commen√ßons par comparer le codeur HDL de Mathworks et Intel HLS Compiler, apr√®s avoir r√©solu plusieurs probl√®mes en utilisant diff√©rentes approches. <br><br><h2>  Comparaison d'outils de d√©veloppement de haut niveau </h2><br><h3>  Testez-en un.  "Deux multiplicateurs et un additionneur" </h3><br>  La solution √† ce probl√®me n'a aucune valeur pratique, mais convient bien comme premier test.  La fonction prend 4 param√®tres, multiplie le premier par le second, le troisi√®me par le quatri√®me et ajoute les r√©sultats de la multiplication.  Rien de compliqu√©, mais voyons comment nos sujets y font face. <br><br><h4>  Codeur HDL par Mathworks </h4><br>  Pour r√©soudre ce probl√®me, le m-script se pr√©sente comme suit: <br><br><pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c,d)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a*b)</span></span></span><span class="hljs-function">+</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c*d)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Voyons ce que Mathworks nous offre pour convertir le code en HDL. <br><br>  Je ne consid√©rerai pas en d√©tail le travail avec le codeur HDL, je m'attarderai uniquement sur les param√®tres que je changerai √† l'avenir pour obtenir des r√©sultats diff√©rents dans FPGA, et dont les changements devront √™tre pris en compte par le programmeur MATLAB qui doit ex√©cuter son code dans FPGA. <br><br>  Ainsi, la premi√®re chose √† faire est de d√©finir le type et la plage de valeurs d'entr√©e.  Il n'y a pas de char, int, float, double familier dans FPGA.  La profondeur de bits du nombre peut √™tre quelconque, il est logique de le choisir, en fonction de la plage de valeurs d'entr√©e que vous pr√©voyez d'utiliser. <br><br><img src="https://habrastorage.org/webt/yi/vt/rm/yivtrmsrseix9d6-r5ktf7q4i98.png" alt="image"><br>  <i>Figure 1</i> <br><br>  MATLAB v√©rifie les types de variables, leurs valeurs et s√©lectionne les bonnes tailles de bits pour les bus et les registres, ce qui est vraiment pratique.  S'il n'y a aucun probl√®me de profondeur de bit et de frappe, vous pouvez passer aux points suivants. <br><br> <a href=""><img src="https://habrastorage.org/webt/hy/bw/zv/hybwzvt-w0xzsta5gkf-0oapcrq.png" alt="image"></a> <br>  <i>Figure 2</i> <br><br>  Il y a plusieurs onglets dans la g√©n√©ration de code HDL o√π vous pouvez choisir la langue vers laquelle convertir (Verilog ou VHDL);  style de code  noms des signaux.  L'onglet le plus int√©ressant, √† mon avis, est l'optimisation, et je vais l'exp√©rimenter, mais plus tard, pour l'instant, laissons tous les param√®tres par d√©faut et voyons ce qui se passe avec le codeur HDL ¬´pr√™t √† l'emploi¬ª. <br><br>  Appuyez sur le bouton Ex√©cuter et obtenez le code suivant: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (a, b, c, d, out); input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output [16:0] out; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Le code semble bon.  MATLAB comprend que l'√©criture de l'expression enti√®re sur une seule ligne sur Verilog est une mauvaise pratique.  Cr√©e des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fils</a> s√©par√©s pour le multiplicateur et l'additionneur, il n'y a rien √† redire. <br><br>  Il est alarmant que la description des registres soit manquante.  Cela est arriv√© parce que nous n'avons pas demand√© √† ce sujet le codeur HDL et laiss√© tous les champs dans les param√®tres √† leurs valeurs par d√©faut. <br><br>  Voici ce que Quartus synth√©tise √† partir d'un tel code. <br><br><img src="https://habrastorage.org/webt/zf/af/ja/zfafjaezynolikraaha86gadp-e.png"><br>  <i>Figure 3</i> <br><br>  Aucun probl√®me, tout √©tait comme pr√©vu. <br><br>  Dans FPGA, nous impl√©mentons des circuits synchrones, et je voudrais toujours voir les registres.  Le codeur HDL offre un m√©canisme pour placer des registres, mais o√π les placer d√©pend du d√©veloppeur.  On peut placer les registres √† l'entr√©e des multiplicateurs, √† la sortie des multiplicateurs devant l'additionneur, ou √† la sortie de l'additionneur. <br><br>  Pour synth√©tiser les exemples, j'ai choisi la famille FPGA Cyclone V, o√π des blocs DSP sp√©ciaux avec des additionneurs et des multiplicateurs int√©gr√©s sont utilis√©s pour impl√©menter des op√©rations arithm√©tiques.  Le bloc DSP ressemble √† ceci: <br><br> <a href=""><img src="https://habrastorage.org/webt/zf/5s/bt/zf5sbts5ke1t_pw3dsmrc4uhtrc.png"></a> <br>  <i>Figure 4</i> <br><br>  Le bloc DSP a des registres d'entr√©e et de sortie.  Il n'est pas n√©cessaire d'essayer de capturer les r√©sultats de la multiplication dans le registre avant l'ajout, cela ne fera que violer l'architecture (dans certains cas, cette option est possible et m√™me n√©cessaire).  C'est au d√©veloppeur de d√©cider comment g√©rer le registre d'entr√©e et de sortie en fonction des exigences de latence et de la fr√©quence maximale requise.  J'ai d√©cid√© d'utiliser uniquement le registre de sortie.  Pour que ce registre soit d√©crit dans le code g√©n√©r√© par le codeur HDL, dans l'onglet Options du codeur HDL, vous devez cocher la case Enregistrer la sortie et red√©marrer la conversion. <br><br>  Il s'av√®re que le code suivant: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (clk, reset, clke_ena_i, a, b, c, d, clke_ena_o, out); input clk; input reset; input clke_ena_i; input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output clke_ena_o; output [16:0] out; // ufix17 wire enb; wire [16:0] out_1; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 reg [16:0] out_2; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out_1 = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; assign enb = clke_ena_i; always @(posedge clk or posedge reset) begin : out_reg_process if (reset == 1'b1) begin out_2 &lt;= 17'b00000000000000000; end else begin if (enb) begin out_2 &lt;= out_1; end end end assign clke_ena_o = clke_ena_i; assign out = out_2; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Comme vous pouvez le voir, le code pr√©sente des diff√©rences fondamentales par rapport √† la version pr√©c√©dente.  Un bloc toujours apparu, qui est une description du registre (juste ce que nous voulions).  Pour l'op√©ration toujours bloqu√©e, les entr√©es du module clk (fr√©quence d'horloge) et reset (reset) sont √©galement apparues.  On peut voir que la sortie de l'additionneur est verrouill√©e dans le d√©clencheur d√©crit dans toujours.  Il y a aussi quelques signaux d'autorisation ena, mais ils ne sont pas tr√®s int√©ressants pour nous. <br><br>  Regardons le diagramme que Quartus synth√©tise maintenant. <br><br><img src="https://habrastorage.org/webt/ro/we/px/rowepxxw-fun6ey4x2tpw4cfjyg.png"><br>  <i>Figure 5</i> <br><br>  Et encore une fois, les r√©sultats sont bons et attendus. <br><br>  Le tableau ci-dessous montre le tableau des ressources utilis√©es - nous le gardons √† l'esprit. <br><br><img src="https://habrastorage.org/webt/_z/wy/lk/_zwylksweoc_mhrps-rqhwankbe.png"><br>  <i>Figure 6</i> <br><br>  Pour cette premi√®re qu√™te, Mathworks re√ßoit un cr√©dit.  Tout n'est pas compliqu√©, pr√©visible et avec le r√©sultat souhait√©. <br><br>  J'ai d√©crit en d√©tail un exemple simple, fourni un sch√©ma d'un bloc DSP et d√©crit les possibilit√©s d'utilisation des param√®tres d'utilisation des registres dans le codeur HDL, qui sont diff√©rents des param√®tres ¬´par d√©faut¬ª.  Cela est fait pour une raison.  Par cela, je tiens √† souligner que m√™me dans un exemple aussi simple, lors de l'utilisation du codeur HDL, la connaissance de l'architecture FPGA et des principes fondamentaux des circuits num√©riques est n√©cessaire, et les param√®tres doivent √™tre modifi√©s consciemment. <br><br><h4>  Compilateur Intel HLS </h4><br>  Essayons de compiler du code avec les m√™mes fonctionnalit√©s √©crites en C ++ et de voir ce qui est finalement synth√©tis√© dans FPGA √† l'aide du compilateur HLS. <br><br>  Donc du code C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a*b)+(c*d); }</code> </pre><br>  J'ai choisi des types de donn√©es pour √©viter les d√©bordements de variables. <br><br>  Il existe des m√©thodes avanc√©es pour d√©finir les profondeurs de bits, mais notre objectif est de tester la capacit√© d'assembler des fonctions √©crites en style C / C ++ sous FPGA sans apporter de modifications, le tout d√®s le d√©part. <br><br>  Le compilateur HLS √©tant un outil natif d'Intel, nous collectons le code avec un compilateur sp√©cial et v√©rifions le r√©sultat imm√©diatement dans Quartus. <br><br>  Regardons le circuit synth√©tis√© par Quartus. <br><br><img src="https://habrastorage.org/webt/ra/wy/bg/rawybgvk1yirtlaxi5yfmqjk6mi.png"><br>  <i>Figure 7</i> <br><br>  Le compilateur a cr√©√© des registres √† l'entr√©e et √† la sortie, mais l'essentiel est cach√© dans le module wrapper.  Nous commen√ßons √† d√©ployer le wrapper et ... voir de plus en plus de modules imbriqu√©s. <br><br>  La structure du projet ressemble √† ceci. <br><br> <a href=""><img src="https://habrastorage.org/webt/x6/3x/pi/x63xpin-73wlqtuear-rhyhcpcy.png"></a> <br>  <i>Figure 8</i> <br><br>  Un indice √©vident d'Intel est ¬´ne mettez pas la main dessus!¬ª.  Mais on va essayer, surtout la fonctionnalit√© n'est pas compliqu√©e. <br><br>  Dans les entrailles de l'arborescence du projet | quartus_compile | TwoMultAdd: TwoMultAdd_inst | TwoMultAdd_internal: twomultadd_internal_inst | TwoMultAdd_fu <br>  nction_wrapper: TwoMultAdd_internal | TwoMultAdd_function: theTwoMultAdd_function | bb_TwoMultAdd_B1_start: <br>  thebb_TwoMultAdd_B1_start | bb_TwoMultAdd_B1_start_stall_region: thebb_TwoMultAdd_B1_start_stall_region | i <br>  _sfc_c1_wt_entry_twomultadd_c1_enter_twomultadd: thei_sfc_c1_wt_entry_twomultadd_c1_enter_twomultad <br>  d_aunroll_x | i_sfc_logic_c1_wt_entry_twomultadd_c1_enter_twomultadd13: thei_sfc_logic_c1_wt_entry_twom <br>  ultadd_c1_enter_twomultadd13_aunroll_x | Mult1 est le module que vous recherchez. <br><br>  Nous pouvons regarder le sch√©ma du module souhait√© synth√©tis√© par Quartus. <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/e8/_c/4me8_cxojdb6zyvo0mkvc-i7a60.png"></a> <br>  <i>Figure 9</i> <br><br>  Quelles conclusions peut-on tirer de ce sch√©ma. <br><br>  Il est √©vident que quelque chose s'est produit que nous avons essay√© d'√©viter en travaillant dans MATLAB: le cas √† la sortie du multiplicateur a √©t√© synth√©tis√© - ce n'est pas tr√®s bon.  On peut voir sur le sch√©ma de principe du DSP (figure 4) qu'il n'y a qu'un seul registre √† sa sortie, ce qui signifie que chaque multiplication devra √™tre effectu√©e dans un bloc s√©par√©. <br><br>  Le tableau des ressources utilis√©es montre √† quoi cela m√®ne. <br><br><img src="https://habrastorage.org/webt/es/eu/tj/eseutjlsyur_gibiank94suhhca.png"><br>  <i>Figure 10</i> <br><br>  Comparez les r√©sultats avec le tableau du codeur HDL (figure 6). <br><br>  Si vous utilisez un plus grand nombre de registres, alors d√©penser de pr√©cieux blocs DSP sur des fonctionnalit√©s aussi simples est tr√®s d√©sagr√©able. <br><br>  Mais il y a un √©norme plus dans Intel HLS par rapport au codeur HDL.  Avec les param√®tres par d√©faut, le compilateur HLS a d√©velopp√© une conception synchrone dans FPGA, bien qu'il ait d√©pens√© plus de ressources.  Une telle architecture est possible, il est clair qu'Intel HLS est configur√© pour atteindre des performances maximales, et non pour √©conomiser des ressources. <br><br>  Voyons comment nos sujets se comportent avec des projets plus complexes. <br><br><h3>  Le deuxi√®me test.  ¬´Multiplication des matrices √©l√©ment par √©l√©ment avec sommation du r√©sultat¬ª </h3><br>  Cette fonction est largement utilis√©e dans le traitement d'images: le soi-disant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´filtre matriciel¬ª</a> .  Nous le vendons √† l'aide d'outils de haut niveau. <br><br><h4>  Codeur HDL par Mathwork </h4><br>  Le travail commence imm√©diatement avec une limitation.  Le codeur HDL ne peut pas accepter les fonctions matricielles 2D comme entr√©es.  √âtant donn√© que MATLAB est un outil pour travailler avec des matrices, cela porte un coup s√©rieux √† tout le code h√©rit√©, ce qui peut devenir un probl√®me grave.  Si le code est √©crit √† partir de z√©ro, c'est une fonctionnalit√© d√©sagr√©able qui doit √™tre prise en compte.  Il faut donc d√©ployer toutes les matrices dans un vecteur et impl√©menter les fonctions en tenant compte des vecteurs d'entr√©e. <br><br>  Le code de la fonction dans MATLAB est le suivant <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Le code HDL g√©n√©r√© s'est av√©r√© √™tre tr√®s gonfl√© et contient des centaines de lignes, donc je ne le donnerai pas ici.  Voyons quel sch√©ma Quartus synth√©tise √† partir de ce code. <br><br> <a href=""><img src="https://habrastorage.org/webt/6d/3z/cd/6d3zcdcx0yzcqp-ht6fhz_mtx2i.png"></a> <br>  <i>Figure 11</i> <br><br>  Ce sch√©ma semble infructueux.  Formellement, cela fonctionne, mais je suppose que cela fonctionnera √† une fr√©quence tr√®s basse, et il peut difficilement √™tre utilis√© dans du vrai mat√©riel.  Mais toute hypoth√®se doit √™tre v√©rifi√©e.  Pour ce faire, nous placerons les registres √† l'entr√©e et √† la sortie de ce circuit et √† l'aide de Timing Analyzer nous √©valuerons la situation r√©elle.  Pour effectuer l'analyse, vous devez sp√©cifier la fr√©quence de fonctionnement souhait√©e du circuit afin que Quartus sache quoi rechercher lors du c√¢blage et, en cas de panne, fournit des rapports de violations. <br><br>  Nous avons r√©gl√© la fr√©quence √† 100 MHz, voyons ce que Quartus peut faire sortir du circuit propos√©. <br><br><img src="https://habrastorage.org/webt/r7/zv/xy/r7zvxygef12ws12mmyfwgxc0plk.png"><br>  <i>Figure 12</i> <br><br>  On peut voir que cela s'est av√©r√© un peu: 33 MHz ont l'air frivole.  Le retard dans la cha√Æne des multiplicateurs et des additionneurs est d'environ 30 ns.  Pour se d√©barrasser de ce ¬´goulot d'√©tranglement¬ª, vous devez utiliser le convoyeur: ins√©rez des registres apr√®s les op√©rations arithm√©tiques, r√©duisant ainsi le chemin critique. <br><br>  Le codeur HDL nous offre cette opportunit√©.  Dans l'onglet Options, vous pouvez d√©finir des variables de pipeline.  √âtant donn√© que le code en question est √©crit dans le style MATLAB, il n'y a aucun moyen de pipeline de variables (√† l'exception des variables mult et summ), ce qui ne nous convient pas.  Il est n√©cessaire d'ins√©rer les registres dans les circuits interm√©diaires cach√©s dans notre code HDL. <br><br>  De plus, la situation avec l'optimisation pourrait √™tre pire.  Par exemple, rien ne nous emp√™che d'√©crire du code <br><br><pre> <code class="matlab hljs">out = (sum(target.*kernel))/len;</code> </pre> <br>  il est tout √† fait ad√©quat pour MATLAB, mais nous prive compl√®tement de la possibilit√© d'optimiser le HDL. <br><br>  La prochaine solution consiste √† modifier le code √† la main.  C'est un point tr√®s important, car nous refusons d'h√©riter et de commencer √† r√©√©crire le m-script, et PAS dans le style MATLAB. <br><br>  Le nouveau code est le suivant <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/2)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/4)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/8)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/2)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/4)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_1(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/8)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_2(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Dans Quartus, nous collectons le code g√©n√©r√© par le codeur HDL.  On peut voir que le nombre de couches avec des primitives a diminu√©, et le sch√©ma semble beaucoup mieux. <br><br> <a href=""><img src="https://habrastorage.org/webt/nd/7j/sr/nd7jsrm1hiursvzgredphpuvr7k.png"></a> <br>  <i>Figure 12</i> <br><br>  Avec la disposition correcte des primitives, la fr√©quence augmente presque 3 fois, jusqu'√† 88 MHz. <br><br><img src="https://habrastorage.org/webt/3z/4s/o3/3z4so3o-whcbn8jct8y-wtfsja4.png"><br>  <i>Figure 13</i> <br><br>  Maintenant la touche finale: dans les param√®tres d'optimisation, sp√©cifiez summ_1, summ_2 et summ_3 comme √©l√©ments du pipeline.  Nous collectons le code r√©sultant dans Quartus.  Le sch√©ma change comme suit: <br><br> <a href=""><img src="https://habrastorage.org/webt/cu/kr/ua/cukruasropyfoifoib6er-fhck4.png"></a> <br>  <i>Figure 14</i> <br><br>  La fr√©quence maximale augmente √† nouveau et maintenant sa valeur est d'environ 195 MHz. <br><br><img src="https://habrastorage.org/webt/tl/gg/dd/tlggddvndao-cm0bavadgbuxx30.png"><br>  <i>Figure 15</i> <br><br>  Combien de ressources sur la puce prendront une telle conception?  La figure 16 montre le tableau des ressources utilis√©es pour le cas d√©crit. <br><br><img src="https://habrastorage.org/webt/vl/ju/io/vljuioe1zmgnc-zr-nxvyv0lawu.png"><br>  <i>Figure 16</i> <br><br>  Quelles conclusions peut-on tirer apr√®s avoir examin√© cet exemple? <br><br>  Le principal inconv√©nient du codeur HDL est qu'il est peu probable qu'il utilise le code MATLAB dans sa forme pure. <br>  Il n'y a pas de prise en charge des matrices comme entr√©es de fonction, la disposition du code dans le style MATLAB est m√©diocre. <br><br>  Le principal danger est le manque de registres dans le code g√©n√©r√© sans param√®tres suppl√©mentaires.  Sans ces registres, m√™me apr√®s avoir re√ßu un code HDL fonctionnellement formel sans erreurs de syntaxe, l'utilisation d'un tel code dans les r√©alit√©s et d√©veloppements modernes n'est pas souhaitable. <br><br>  Il est conseill√© d'√©crire imm√©diatement du code affin√© pour la conversion en HDL.  Dans ce cas, vous pouvez obtenir des r√©sultats tout √† fait acceptables en termes de vitesse et d'intensit√© des ressources. <br><br>  Si vous √™tes un d√©veloppeur MATLAB, ne vous pr√©cipitez pas pour cliquer sur le bouton Ex√©cuter et compilez votre code sous FPGA, n'oubliez pas que votre code sera synth√©tis√© dans un circuit r√©el.  =) <br><br><h4>  Compilateur Intel HLS </h4><br>  Pour la m√™me fonctionnalit√©, j'ai √©crit le code C / C ++ suivant <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *kernel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summl; summl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { mult_res[i] = data[i] * kernel[i]; summl = summl+mult_res[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summl/<span class="hljs-number"><span class="hljs-number">16</span></span>; }</code> </pre><br>  La premi√®re chose qui attire votre attention est la quantit√© de ressources utilis√©es. <br><br><img src="https://habrastorage.org/webt/yg/t1/zq/ygt1zq3p67hkkly29pneur9x6bu.png"><br>  <i>Figure 17</i> <br><br>  Le tableau montre qu'un seul bloc DSP a √©t√© utilis√©, donc quelque chose s'est mal pass√© et les multiplications ne sont pas effectu√©es en parall√®le.  Le nombre de registres utilis√©s est √©galement surprenant, et m√™me la m√©moire est impliqu√©e, mais nous laisserons cela √† la conscience du compilateur HLS. <br><br>  Il convient de noter que le compilateur HLS a d√©velopp√© un sous-optimal, en utilisant une √©norme quantit√© de ressources suppl√©mentaires, mais toujours un circuit de travail qui, selon les rapports Quartus, fonctionnera √† une fr√©quence acceptable, et un √©chec comme le codeur HDL ne le fera pas. <br><br><img src="https://habrastorage.org/webt/y-/wg/fa/y-wgfaigf6zgbaljoez__xzxuqm.png"><br>  <i>Figure 18</i> <br><br>  Essayons d'am√©liorer la situation.  Que faut-il pour cela?  C'est vrai, fermez les yeux sur l'h√©ritage et explorez le code, mais jusqu'√† pr√©sent, ce n'est pas beaucoup. <br><br>  HLS a des directives sp√©ciales pour optimiser le code pour FPGA.  Nous ins√©rons la directive unroll, qui devrait √©tendre notre boucle en parall√®le: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; }</span></span></code> </pre><br><br>  Voyons comment Quartus y a r√©agi <br><br><img src="https://habrastorage.org/webt/fi/7j/nk/fi7jnkhaoeals29m0pfk38shv70.png"><br>  <i>Figure 19</i> <br><br>  Tout d'abord, faites attention au nombre de blocs DSP - il y en a 16, ce qui signifie que les multiplications sont effectu√©es en parall√®le. <br><br>  Hourra!  d√©rouler les travaux!  Mais il est d√©j√† difficile de supporter l‚Äôaugmentation de l‚Äôutilisation des autres ressources.  Le circuit est devenu compl√®tement illisible. <br><br> <a href=""><img src="https://habrastorage.org/webt/vj/gs/tu/vjgstugdk5a661jnk281gys8-qo.png"></a> <br>  <i>Figure 20</i> <br><br>  Je pense que cela est d√ª au fait que personne n'a signal√© au compilateur que les calculs en nombres √† virgule fixe nous convenaient tout √† fait, et il a honn√™tement mis en ≈ìuvre toutes les math√©matiques √† virgule flottante sur la logique et les registres.  Nous devons expliquer au compilateur ce qui est requis de lui, et pour cela nous replongons dans le code. <br><br>  Dans le but d'utiliser des virgules fixes, des classes de mod√®les sont impl√©ment√©es. <br><br><img src="https://habrastorage.org/webt/0a/a8/dj/0aa8djn0cwvyf8tplhtay6lymdg.png"><br>  <i>Figure 21</i> <br><br>  En parlant avec nos propres mots, nous pouvons utiliser des variables dont la profondeur de bits est d√©finie manuellement jusqu'√† un bit.  Pour ceux qui √©crivent en HDL, vous ne pouvez pas vous y habituer, mais les programmeurs C / C ++ vont probablement se serrer la t√™te.  Profondeurs de bits, comme dans MATLAB, dans ce cas, personne ne le dira, et le d√©veloppeur lui-m√™me doit compter le nombre de bits. <br><br>  Voyons √† quoi cela ressemble dans la pratique. <br><br>  Nous √©ditons le code comme suit: <br><br><pre> <code class="cpp hljs">component ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; conv(ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *data, ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *kernel) { ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;summl; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; } for (int i = 0; i &lt; 16; i++) { summl = summl+mult_res[i]; } return summl/16; }</span></span></code> </pre><br>  Et au lieu des p√¢tes effrayantes de la figure 20, nous obtenons cette beaut√©: <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/v0/ot/kgv0ot9el2l5a3u4wawqsbw4hli.png"></a> <br>  <i>Figure 22</i> <br><br>  Malheureusement, quelque chose d'√©trange continue de se produire avec les ressources utilis√©es. <br><br><img src="https://habrastorage.org/webt/my/dk/bk/mydkbkemq-dzzzhk53gky-zix00.png"><br>  <i>Figure 23</i> <br><br>  Mais un examen d√©taill√© des rapports montre que le module qui nous int√©resse directement semble plus que suffisant: <br><br> <a href=""><img src="https://habrastorage.org/webt/tn/t0/da/tnt0daffouamtkyozxnrnu_zoku.png"></a> <br>  <i>Figure 24</i> <br><br>  L'√©norme consommation de registres et de m√©moire de bloc est associ√©e √† un grand nombre de modules p√©riph√©riques.  Je ne comprends toujours pas pleinement le sens profond de leur existence, et cela devra √™tre r√©gl√©, mais le probl√®me est r√©solu.  Dans un cas extr√™me, vous pouvez soigneusement d√©couper un module qui nous int√©resse dans la structure g√©n√©rale du projet, ce qui nous √©pargnera des modules p√©riph√©riques qui d√©vorent les ressources. <br><br><h3>  Le troisi√®me test.  ¬´Transition de RVB √† HSV¬ª </h3><br>  Commen√ßant √† √©crire cet article, je ne m'attendais pas √† ce qu'il soit si volumineux.  Mais je ne peux pas refuser le troisi√®me et le dernier dans le cadre de cet article, un exemple. <br><br>  Tout d'abord, c'est un v√©ritable exemple de ma pratique, et c'est √† cause de cela que j'ai commenc√© √† me tourner vers des outils de d√©veloppement de haut niveau. <br><br>  Deuxi√®mement, √† partir des deux premiers exemples, nous pourrions faire l'hypoth√®se que plus la conception est complexe, plus les outils de haut niveau font face √† la t√¢che. <br><br>  Je veux d√©montrer que ce jugement est erron√© et, en fait, plus la t√¢che est complexe, plus les avantages des outils de d√©veloppement de haut niveau se manifestent. <br><br>  L'ann√©e derni√®re, lorsque je travaillais sur l'un des projets, je n'aimais pas l'appareil photo achet√© sur Aliexpress, √† savoir que les couleurs n'√©taient pas assez satur√©es.  L'une des fa√ßons les plus courantes de faire varier la saturation des couleurs consiste √† passer de l'espace colorim√©trique RVB √† l'espace HSV, o√π l'un des param√®tres est la saturation.  Je me souviens de la fa√ßon dont j'ai ouvert la formule de transition et pris une profonde inspiration ... La mise en ≈ìuvre de tels calculs dans FPGA n'est pas quelque chose d'extraordinaire, mais bien s√ªr, il faudra du temps pour √©crire du code.  Ainsi, la formule pour passer du RVB au HSV est la suivante: <br><br><img src="https://habrastorage.org/webt/z_/6u/_t/z_6u_tufgvs_wkbknmisu_gtn1e.png"><br>  <i>Figure 25</i> <br><br>  La mise en ≈ìuvre d'un tel algorithme dans FPGA ne prendra pas des jours, mais des heures, et tout cela doit √™tre fait tr√®s soigneusement en raison des sp√©cificit√©s de HDL, et la mise en ≈ìuvre en C ++ ou en MATLAB prendra, je pense, quelques minutes. <br><br>  En C ++, vous pouvez √©crire du code directement sur le front et toujours obtenir un r√©sultat fonctionnel. <br>  J'ai √©crit l'option suivante en C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color_space</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rh; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> gs; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bv; }; <span class="hljs-function"><span class="hljs-function">component color_space </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rgb2hsv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color_space rgb_0)</span></span></span><span class="hljs-function"> </span></span>{ color_space hsv; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h,s,v,r,g,b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max_col, min_col; r = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.rh)/<span class="hljs-number"><span class="hljs-number">255</span></span>; g = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.gs)/<span class="hljs-number"><span class="hljs-number">255</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.bv)/<span class="hljs-number"><span class="hljs-number">255</span></span>; max_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r,g),b); min_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r,g),b); <span class="hljs-comment"><span class="hljs-comment">// H if (max_col == min_col) h = 0; else if (max_col==r &amp;&amp; g&gt;=b) h = 60*((gb)/(max_col-min_col)); else if (max_col==r &amp;&amp; g&lt;b) h = 60*((gb)/(max_col-min_col))+360; else if (max_col==g) h = 60*((br)/(max_col-min_col))+120; else if (max_col==b) h = 60*((rg)/(max_col-min_col))+240; // S if (max_col == 0) s = 0; else { s = (1-(min_col/max_col))*100; } // V v = max_col*100; hsv.rh = static_cast&lt;char&gt;(h); hsv.gs = static_cast&lt;char&gt;(s); hsv.bv = static_cast&lt;char&gt;(v); return hsv; }</span></span></code> </pre><br>  Et Quartus a r√©ussi √† mettre en ≈ìuvre le r√©sultat, comme le montre le tableau des ressources utilis√©es. <br><br><img src="https://habrastorage.org/webt/us/bs/qx/usbsqx6dg4ncv_kkefii6ul8msq.png"><br>  <i>Figure 26</i> <br><br>  La fr√©quence est tr√®s bonne. <br><br><img src="https://habrastorage.org/webt/t-/tk/hd/t-tkhdxq-d1yr7uo28m5_k7sfaa.png"><br>  <i>Figure 27</i> <br><br>  Avec le codeur HDL, les choses sont un peu plus compliqu√©es. <br><br>  Afin de ne pas gonfler l'article, je ne fournirai pas de m-script pour cette t√¢che, cela ne devrait pas poser de probl√®me.  Un m-script √©crit sur le front peut difficilement √™tre utilis√© avec succ√®s, mais si vous modifiez le code et sp√©cifiez correctement les emplacements de pipelining, nous obtenons un r√©sultat fonctionnel.  Bien s√ªr, cela prendra plusieurs dizaines de minutes, mais pas des heures. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C ++, il est √©galement souhaitable de d√©finir les directives et de traduire les calculs en un point fixe, ce qui prendra √©galement tr√®s peu de temps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, en utilisant des outils de d√©veloppement de haut niveau, nous gagnons du temps, et plus l'algorithme est compliqu√©, plus il gagne de temps - cela continuera jusqu'√† ce que nous rencontrions des limites de ressources FPGA ou des limites de vitesse de calcul strictes o√π vous devez vous attaquer au HDL.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui peut √™tre dit en conclusion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De toute √©vidence, le marteau d'or n'a pas encore √©t√© invent√©, mais il existe des outils suppl√©mentaires qui peuvent √™tre utilis√©s dans le d√©veloppement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le principal avantage des outils de haut niveau, √† mon avis, est la rapidit√© de d√©veloppement. C‚Äôest une r√©alit√© d‚Äôobtenir suffisamment de qualit√© en termes de temps, parfois un ordre de grandeur plus petit que lors du d√©veloppement avec HDL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je me m√©fie des avantages tels que l'utilisation du code h√©rit√© pour FPGA et la connexion au d√©veloppement pour les programmeurs FPGA sans pr√©paration pr√©alable. Pour obtenir des r√©sultats satisfaisants, vous devrez abandonner de nombreuses techniques de programmation famili√®res. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encore une fois, je tiens √† noter que cet article n'est qu'un aper√ßu superficiel des outils de d√©veloppement de haut niveau pour FPGA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le compilateur HLS offre de grandes opportunit√©s d'optimisations: pragmas, biblioth√®ques sp√©ciales avec fonctions optimis√©es, descriptions d'interfaces, nombreux articles sur Internet sur les ¬´meilleures pratiques¬ª, etc. La puce MATLAB, qui n'a pas √©t√© prise en compte, est la capacit√© de g√©n√©rer directement, par exemple, un filtre √† partir de l'interface graphique sans √©crire une seule ligne de code, indiquant simplement les caract√©ristiques souhait√©es, ce qui acc√©l√®re encore le temps de d√©veloppement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qui a gagn√© l'√©tude d'aujourd'hui? Mon opinion est le compilateur Intel HLS. Il g√©n√®re une conception fonctionnelle m√™me √† partir de code non optimis√©. Codeur HDL sans analyse r√©fl√©chie et traitement de code que j'aurais peur d'utiliser. Je tiens √©galement √† noter que le codeur HDL est un outil assez ancien, mais comme je le sais, il n'a pas √©t√© largement reconnu. Mais HLS, bien que jeune, il est clair que les fabricants de FPGA parient dessus, je pense que nous verrons son d√©veloppement et sa popularit√© grandir.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les repr√©sentants de Xilinx assurent que le d√©veloppement et la mise en ≈ìuvre d'outils de haut niveau est la seule opportunit√© √† l'avenir de se d√©velopper pour des puces FPGA de plus en plus grandes. Les outils traditionnels ne pourront tout simplement pas faire face √† cela, et Verilog / VHDL est probablement destin√© √† l'assembleur, mais c'est dans le futur. Et maintenant, nous avons entre nos mains des outils de d√©veloppement (avec leurs avantages et leurs inconv√©nients), que nous devons choisir en fonction de la t√¢che. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vais-je utiliser des outils de d√©veloppement de haut niveau dans mon travail? Au contraire, oui, maintenant leur d√©veloppement va √† pas de g√©ant, nous devons donc au moins suivre le rythme, mais je ne vois aucune raison objective d'abandonner imm√©diatement le HDL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En fin de compte, je tiens √† noter une fois de plus qu'√† ce stade du d√©veloppement d'outils de conception de haut niveau, l'utilisateur ne doit pas oublier une minute qu'il √©crit un programme qui n'est pas ex√©cutable dans le processeur, mais cr√©e un circuit avec de vrais fils, d√©clencheurs et √©l√©ments logiques. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455668/">https://habr.com/ru/post/fr455668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455650/index.html">Comment nous avons form√© un r√©seau de neurones pour classer les vis</a></li>
<li><a href="../fr455652/index.html">Deep Learning vs bon sens: d√©velopper un chat bot</a></li>
<li><a href="../fr455658/index.html">Intel Core i7-2600K l√©gendaire: test de Sandy Bridge en 2019 (partie 3)</a></li>
<li><a href="../fr455662/index.html">Grand √©cran m√©canique avec m√©canisme √† came comme d√©codeur</a></li>
<li><a href="../fr455666/index.html">G√©n√©rer des ventes sortantes dans une entreprise de services informatiques</a></li>
<li><a href="../fr455670/index.html">Comment les imprimantes 3D impriment les os, les vaisseaux sanguins et les organes</a></li>
<li><a href="../fr455676/index.html">La bulle d'apprentissage automatique a-t-elle √©clat√© ou le d√©but d'une nouvelle aube</a></li>
<li><a href="../fr455678/index.html">Sur le chemin de Sergey Pavlovich Korolev. Projet habit√© russe moderne. Partie 1. ¬´F√©d√©ration¬ª</a></li>
<li><a href="../fr455682/index.html">Combien d√©pensez-vous en infrastructure? Et comment √©conomiser sur cela?</a></li>
<li><a href="../fr455684/index.html">Pourquoi avons-nous organis√© un hackathon pour les testeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>