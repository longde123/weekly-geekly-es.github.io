<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚑 🐣 🏟️ ChaiScript - bahasa scripting untuk C ++ 👩🏼‍🎤 💎 🤙🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika ada kebutuhan untuk menanamkan bahasa scripting dalam proyek C ++, hal pertama yang paling diingat orang adalah Lua. Dalam artikel ini tidak ak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChaiScript - bahasa scripting untuk C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483540/">  Ketika ada kebutuhan untuk menanamkan bahasa scripting dalam proyek C ++, hal pertama yang paling diingat orang adalah Lua.  Dalam artikel ini tidak akan, saya akan berbicara tentang yang lain, tidak kurang nyaman dan mudah dipelajari bahasa yang disebut ChaiScript. <br><br><img src="https://habrastorage.org/webt/zh/vl/py/zhvlpyg_87wuf7gg0alk-s7qeyo.png" alt="gambar"><br><a name="habracut"></a><br><h4>  Pengantar singkat </h4><br>  Saya sendiri menemukan ChaiScript secara kebetulan ketika saya menyaksikan <a href="https://youtu.be/uzF4u9KgUWI">salah satu ceramah</a> Jason Turner, salah satu pencipta bahasa tersebut.  Itu membuat saya tertarik, dan pada saat itu ketika perlu untuk memilih bahasa scripting dalam proyek, saya memutuskan - mengapa tidak mencoba ChaiScript?  Hasilnya mengejutkan saya (pengalaman pribadi saya akan ditulis lebih dekat ke akhir artikel), namun, tidak peduli betapa aneh kedengarannya, tidak ada satu artikel pun di hub yang bahkan menyebutkan bahasa ini, dan saya memutuskan bahwa alangkah baiknya menulis tentang dia.  Tentu saja, bahasanya memiliki <a href="">dokumentasi</a> dan <a href="http://chaiscript.com/">situs resmi</a> , tetapi tidak semua orang akan membacanya dari pengamatan, dan format artikel lebih dekat dengan banyak orang (termasuk saya). <br><br>  Pertama, kita akan berbicara tentang sintaks bahasa dan semua fitur-fiturnya, kemudian tentang bagaimana mengimplementasikannya dalam proyek C ++ Anda, dan pada akhirnya saya akan berbicara sedikit tentang pengalaman saya.  Jika beberapa bagian dari Anda tidak tertarik, atau Anda ingin membaca artikel dalam urutan yang berbeda, Anda dapat menggunakan daftar isi: <br><br><ul><li>  <a href="https://habr.com/ru/post/483540/">Sintaksis ChaiScript</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Implementasi dalam C ++</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Pengalaman pribadi</a> </li></ul><br><a name="syntax"></a><br><h2>  Sintaks bahasa </h2><br>  ChaiScript sangat mirip dengan C ++ dan JS dalam sintaksnya.  Pertama-tama, itu, seperti sebagian besar bahasa scripting, diketik secara dinamis, namun, tidak seperti JavaScript, ia memiliki pengetikan yang ketat (no <code>1 + "2"</code> ).  Ada juga pengumpul sampah bawaan, bahasanya sepenuhnya dapat ditafsirkan, memungkinkan Anda untuk mengeksekusi kode per baris, tanpa kompilasi ke dalam bytecode.  Ini memiliki dukungan untuk pengecualian (apalagi, bersama, memungkinkan Anda untuk menangkap keduanya di dalam skrip dan di C ++), fungsi lambda, operator overloading.  Itu tidak sensitif terhadap spasi, memungkinkan Anda untuk menulis sebagai satu baris melalui titik koma, atau dengan gaya python, memisahkan ekspresi dengan baris baru. <br><br><h4>  Tipe primitif </h4><br>  ChaiScript secara default menyimpan variabel integer sebagai int, real double, dan string dengan std :: string.  Ini dilakukan terutama untuk memastikan kompatibilitas dengan kode panggilan.  Bahasa tersebut bahkan memiliki akhiran untuk angka, sehingga kami dapat secara eksplisit menunjukkan jenis variabel kami: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   chaiscript    js    ,  var / auto `;`      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInt = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// int var myLongLong = 1ll // long long int var myFloating = 3.3 // double var myBoolean = false // bool var myString = "hello world!\n" // std::string</span></span></code> </pre><br>  Mengubah jenis variabel tidak berfungsi, kemungkinan besar Anda perlu mendefinisikan operator `=` Anda sendiri untuk jenis-jenis ini, jika tidak Anda berisiko melempar pengecualian (kita akan membicarakan ini nanti) atau menjadi korban pembulatan, seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integer = <span class="hljs-number"><span class="hljs-number">3</span></span> integer = <span class="hljs-number"><span class="hljs-number">5.433</span></span> print(integer) <span class="hljs-comment"><span class="hljs-comment">//  5    double    int! integer = true //   -   `=`  (int, bool)</span></span></code> </pre><br>  Namun, Anda dapat mendeklarasikan variabel tanpa memberikan nilai padanya, dalam hal ini ia akan berisi jenis yang tidak terdefinisi sampai variabel tersebut diberi nilai. <br><br><h4>  Wadah sebaris </h4><br>  Bahasa ini memiliki dua wadah - Vektor dan Peta.  Mereka bekerja sangat mirip dengan rekan-rekan mereka di C ++ (std :: vector dan std :: map, masing-masing), tetapi mereka tidak memerlukan tipe, karena mereka dapat menyimpan apa pun.  Pengindeksan dapat dilakukan seperti biasa dengan int, tetapi Peta membutuhkan kunci dengan string.  Tampaknya terinspirasi oleh python, penulis juga menambahkan kemampuan untuk dengan cepat mendeklarasikan kontainer dalam kode menggunakan sintaks berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>u, <span class="hljs-number"><span class="hljs-number">4</span></span>ll, <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">`+`</span></span> ] <span class="hljs-comment"><span class="hljs-comment">//      var m = [ "key1" : 1, "key2": "Bob" ]; //    - var M = Map() //    var V = Vector() //    //        C++ : v.push_back(123) //    ,     v.push_back_ref(m); // m -   //      m["key"] = 3 //       (reference assignment): m["key"] := m //      </span></span></code> </pre><br>  Kedua kelas ini hampir sepenuhnya mengulangi analog mereka dalam C ++, dengan pengecualian iterators, karena alih-alih mereka ada Range dan Const_Range kelas khusus.  By the way, semua kontainer dilewatkan dengan referensi bahkan jika Anda menggunakan penugasan melalui =, yang sangat aneh bagi saya, karena untuk semua jenis lainnya, penyalinan menurut nilai terjadi. <br><br><h4>  Konstruksi Bersyarat </h4><br>  Hampir semua konstruksi kondisi dan siklus dapat dijelaskan secara harfiah dalam satu contoh kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  if-else if (a &gt; b) { print("a &gt; b") } else if (a == b){ print("a == b") } else { print("a &lt; b") } // switch -    if- //      //  break    ,    C++ var str = "hello" switch(str) { case("hi") { print("hi!"); break; } case("hello") { print("hello!" break; } case("bye") { print("bye-bye!") break; } default { print("what have you said?") } } var x = true //     ,       while (x) { print("x was true") x = false; } //    C.        ,    ,    ,    for (var i = 0; i &lt; 10; ++i) //   -,    { print(i); //  0 ... 9  10  } // ranged-for loop for(element : [1, 2, 3, 4, 5]) { puts(element) //   12345 } //  :   C++17 if-init statements: if(var x = get_value(); x &lt; 10) { print(x) // x     if }</span></span></code> </pre><br>  Saya pikir orang yang akrab dengan C ++ belum menemukan sesuatu yang baru.  Ini tidak mengherankan, karena ChaiScript diposisikan sebagai bahasa yang mudah bagi "pelajar" untuk belajar, dan karena itu meminjam semua desain klasik yang terkenal.  Penulis memutuskan untuk menyoroti bahkan dua kata kunci untuk mendeklarasikan variabel - <code>var</code> dan <code>auto</code> , jika Anda benar-benar menyukai plus dengan otomatis. <br><br><h4>  Konteks eksekusi </h4><br>  ChaiScript memiliki konteks lokal dan global.  Kode dijalankan dari atas ke bawah baris demi baris, namun dapat diambil dalam fungsi dan dipanggil nanti (tetapi tidak lebih awal!).  Variabel yang dideklarasikan di dalam fungsi atau kondisi / loop tidak terlihat secara default dari luar, tetapi Anda dapat mengubah perilaku ini menggunakan pengidentifikasi <code>global</code> alih-alih <code>var</code> .  Variabel global berbeda dari yang biasa dalam hal itu, pertama, mereka terlihat di luar konteks lokal, dan kedua, mereka dapat dinyatakan kembali (jika nilainya tidak ditetapkan selama deklarasi ulang, maka ia tetap sama) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     chaiscript def foo(x) { global G = 2 print(x) } foo(0) //  foo(x), G = 2 print(G) //  2 global G = 3 //  G = 3,   global -  !</span></span></code> </pre><br>  Omong-omong, jika Anda memiliki variabel, dan Anda perlu memeriksa apakah suatu nilai ditetapkan untuknya, gunakan fungsi <code>is_var_undef</code> yang mengembalikan true jika variabel tidak terdefinisi. <br><br><h4>  Interpolasi string </h4><br>  Objek dasar atau objek pengguna yang memiliki metode <code>to_string()</code> dapat dimasukkan ke dalam string menggunakan sintaks <code>${object}</code> .  Ini menghindari rangkaian string yang tidak perlu dan umumnya terlihat jauh lebih rapi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">//  sum of 3 + 4 = 7 print("sum of ${x} + ${y} = ${x + y}")</span></span></code> </pre><br>  Vektor, Peta, MapPair dan semua primitif juga mendukung fitur ini.  Vektor ditampilkan dalam format <code>[o1, o2, ...]</code> , Peta sebagai <code>[&lt;key1, val1&gt;, &lt;key2, val2&gt;, ...]</code> , dan MapPair: <code>&lt;key, val&gt;</code> . <br><br><h4>  Fungsi dan nuansa mereka </h4><br>  Fungsi chaiScript adalah objek seperti yang lainnya.  Mereka dapat ditangkap, ditugaskan ke variabel, dibuat bersarang di fungsi lain, dan diteruskan sebagai argumen.  Juga untuk mereka, Anda dapat menentukan jenis nilai input (yang tidak dimiliki oleh bahasa yang diketik secara dinamis!), Untuk ini, Anda perlu menentukan jenisnya sebelum mendeklarasikan parameter fungsi.  Jika, ketika dipanggil, parameter dapat dikonversi ke yang ditentukan, maka konversi akan terjadi sesuai dengan aturan C ++, jika tidak pengecualian akan dilemparkan: <br><br><pre> <code class="javascript hljs">def adder(int x, int y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } def adder(bool x, bool y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x || y } adder(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  3 adder(1.22, -3.7) // ,  1 + (-3) = 2 adder(true, true) // ,  true adder(true, 3) // ,    adder(bool, int)</span></span></code> </pre><br>  Fungsi dalam bahasa juga dapat mengatur kondisi panggilan (penjaga panggilan).  Jika tidak dihormati, pengecualian dilemparkan, jika tidak panggilan akan dilakukan.  Saya juga mencatat bahwa jika fungsi tidak memiliki pernyataan pengembalian di akhir, maka ekspresi terakhir akan dikembalikan.  Sangat nyaman untuk rutinitas kecil: <br><br><pre> <code class="javascript hljs">def div(x, y) : y != <span class="hljs-number"><span class="hljs-number">0</span></span> { x / y } <span class="hljs-comment"><span class="hljs-comment">//  `y`    -    `x`  `y` print(div(2, 0.5)) //  4.0 print(div(2, 0)) // , `y`  0!</span></span></code> </pre><br><h4>  Kelas dan Dynamic_Object </h4><br>  ChaiScript memiliki dasar-dasar OOP, yang merupakan nilai tambah pasti jika Anda perlu memanipulasi objek yang kompleks.  Bahasa ini memiliki tipe khusus - Dynamic_Object.  Bahkan, semua instance dari kelas dan ruang nama persis Dynamic_Object dengan properti yang telah ditentukan.  Objek dinamis memungkinkan Anda untuk menambahkan bidang selama eksekusi skrip, dan kemudian mengaksesnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Dynamic_Object(); obj.x = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj.f = fun(arg) { print(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + arg); } <span class="hljs-comment"><span class="hljs-comment">//  obj   f (     `x` obj.f(-3); //  0</span></span></code> </pre><br>  Kelas didefinisikan dengan cukup sederhana.  Mereka dapat diatur ke bidang, metode, konstruktor.  Dari <code>set_explicit(object, value)</code> menarik <code>set_explicit(object, value)</code> melalui fungsi khusus <code>set_explicit(object, value)</code> Anda dapat "memperbaiki" bidang objek dengan melarang penambahan metode atau atribut baru setelah deklarasi kelas (ini biasanya dilakukan di konstruktor): <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id; <span class="hljs-comment"><span class="hljs-comment">//  id def Widget() { this.id= 0 } //    def Widget(id) { this.id = id } //   1  def get_id() { id } //   } var w = Widget(10) print(w.get_id()) //  10 (w.id) print(w.get_id) //   10,        set_explicit(w, true) //    wx = 3 //      Widget   x</span></span></code> </pre><br>  Poin penting - pada kenyataannya, metode kelas hanya fungsi yang argumen pertamanya adalah objek dari kelas dengan tipe yang ditentukan secara eksplisit.  Oleh karena itu, kode berikut ini setara dengan menambahkan metode ke kelas yang ada: <br><br><pre> <code class="javascript hljs">def set_id(Widget w, id) { w.id = id } w.set_id(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">// w.id = 9 set_id(w, 9) //  , w.id = 9</span></span></code> </pre><br>  Siapa pun yang akrab dengan C # dapat menggantikan apa yang tampak menyakitkan seperti metode ekstensi, dan akan mendekati kebenaran.  Dengan demikian, dalam bahasa Anda dapat menambahkan fungsionalitas baru bahkan untuk kelas bawaan, misalnya, untuk string atau int.  Penulis juga menawarkan cara yang rumit untuk membebani operator: untuk melakukan ini, Anda perlu mengelilingi simbol operator dengan tilde (`) seperti pada contoh di bawah ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   +     Widget def `+`(Widget w1, Widget w2) { print("merging two widgets!") } var widget1 = Widget() var widget2 = Widget() widget1 + widget2 //      //        : var plus = `+` print(plus(1, 7)) //  8</span></span></code> </pre><br><h4>  Ruang nama </h4><br>  Berbicara tentang namespace di ChaiScript, harus diingat bahwa ini pada dasarnya adalah kelas yang selalu dalam konteks global.  Anda bisa membuatnya menggunakan fungsi <code>namespace(name)</code> , dan kemudian menambahkan fungsi dan kelas yang diperlukan.  Secara default, tidak ada perpustakaan dalam bahasa ini, namun Anda dapat menginstalnya menggunakan ekstensi, yang akan kita bicarakan sedikit kemudian.  Secara umum, inisialisasi namespace mungkin terlihat seperti ini: <br><br><pre> <code class="javascript hljs">namespace(<span class="hljs-string"><span class="hljs-string">"math"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    math //   math.square = fun(x) { x * x } math.hypot_squared= fun(x, y) { math.square(x) + math.square(y) } print(math.square(4)) //  16 print(math.hypot_squared(3, 4)) //  25</span></span></code> </pre><br><h4>  Ekspresi Lambda dan fitur lainnya </h4><br>  Ekspresi Lambda di ChaiScript mirip dengan apa yang kita ketahui dari C ++.  Kata kunci yang <b>menyenangkan</b> digunakan untuk mereka, dan mereka juga membutuhkan secara eksplisit menentukan variabel yang ditangkap, namun mereka selalu melakukan ini dengan referensi.  Bahasa ini juga memiliki fungsi bind yang memungkinkan Anda untuk mengikat nilai ke parameter fungsi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func_object = fun(x) { x * x } func_object(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  81 var name = "John" var greet = fun[name]() { "Hello, " + name } print(greet()) //  Hello, John name = "Bob" print(greet()) //  Hello, Bob var message = bind(fun(msg, name) { msg + " from " + name }, _, "ChaiScript"); print(message("Hello")) //  Hello from ChaiScript</span></span></code> </pre><br><h4>  Pengecualian </h4><br>  Pengecualian dapat terjadi selama eksekusi skrip.  Mereka dapat dicegat baik dalam ChaiScript itu sendiri (yang akan kita bahas di sini) dan di C ++.  Sintaksnya benar-benar identik dengan plus, Anda bahkan dapat membuang angka atau string: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// x   } catch (e) { print("Error during evaluation")) } //   C++   ChaiScript //   Vector -   std::vector,    std::exception      try { var vec = [1, 2] var val = vec[3] //     } catch (e) { print("index out of range: " + e.what()); // e.what    ChaiScript } //  atch   guard     ,    `:` try { throw(5.2) } catch(e) : is_type(e, "int") { print("Int: ${e}"); //   `e`  int } catch(e) : is_type(e, "double") { print("Double: ${e}"); //  `e`  double }</span></span></code> </pre><br>  Dengan cara yang baik, Anda harus mendefinisikan kelas pengecualian dan membuangnya.  Kami akan berbicara tentang cara mencegatnya di C ++ di bagian kedua.  Untuk pengecualian juru bahasa, ChaiScript melempar pengecualiannya, seperti eval_error, bad_boxed_cast, dll. <br><br><h4>  Konstanta juru bahasa </h4><br>  Yang mengejutkan saya, bahasanya ternyata semacam makro kompiler - hanya ada 4 dan semuanya berfungsi untuk mengidentifikasi konteks dan sebagian besar digunakan untuk penanganan kesalahan: <br><div class="scrollable-table"><table><tbody><tr><td>  __LINE__ </td><td>  baris saat ini, jika kode tidak dieksekusi dari file, maka '1' </td></tr><tr><td>  __FILE__ </td><td>  file saat ini, jika kode tidak dipanggil dari file, maka "__EVAL__" </td></tr><tr><td>  __CLASS__ </td><td>  kelas saat ini atau "NOT_IN_CLASS" </td></tr><tr><td>  __FUNC__ </td><td>  fungsi saat ini atau "NOT_IN_FUNCTION" </td></tr></tbody></table></div><br><h4>  Terjebak kesalahan </h4><br>  Jika fungsi yang Anda panggil belum diumumkan, pengecualian dilemparkan.  Jika ini tidak dapat diterima untuk Anda, Anda dapat mendefinisikan fungsi khusus - <code>method_missing(object, func_name, params)</code> , yang akan dipanggil dengan argumen yang sesuai jika terjadi kesalahan: <br><br><pre> <code class="javascript hljs">def method_missing(Widget w, string name, Vector v) { print(<span class="hljs-string"><span class="hljs-string">"widget method ${name} with params {v} was not found"</span></span>) } w = Widget() w.invoke_error(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  widget method invoke_error with params [1, 2, 3] was not found</span></span></code> </pre><br><h4>  Fungsi bawaan </h4><br>  ChaiScript mendefinisikan banyak fungsi built-in, dan dalam artikel ini saya ingin berbicara tentang yang sangat berguna.  Diantaranya: <code>eval(str)</code> , <code>eval_file(filename)</code> , <code>to_json(object)</code> , <code>from_json(str)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"x * y"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// res = 15,  eval     //     : //  eval_file eval_file("source.chai") //   use,  ,         use("source.chai") // to_json    Map    var w = Widget(0) var j = to_json(w) // j = "{ "id" : 0 }" // from_json    Map ( ,   ) var m = from_json(" { "x": 0, "y": 3, "z": 2 }") print(m) //  Map  [&lt;x, 0&gt;, &lt;y, 3&gt;, &lt;z, 2&gt;]</span></span></code> </pre><br><a name="cppchai"></a><br><h2>  Implementasi dalam C ++ </h2><br><h4>  Instalasi </h4><br>  ChaiScript adalah pustaka hanya header berbasis template C ++.  Dengan demikian, untuk instalasi Anda hanya perlu membuat <a href="https://github.com/ChaiScript/ChaiScript">repositori</a> clone atau hanya memasukkan semua file dari <a href="https://github.com/ChaiScript/ChaiScript/tree/develop/include/chaiscript">folder ini</a> ke proyek Anda.  Karena, tergantung pada IDE, semua ini dilakukan secara berbeda dan telah dideskripsikan secara rinci di forum untuk waktu yang lama, maka kami akan menganggap bahwa Anda berhasil menghubungkan pustaka, dan kode dengan menyertakan: <code>#include &lt;chaiscript/chaiscript.hpp&gt;</code> dikompilasi. <br><br><h4>  Doa kode C ++ dan pemuatan skrip </h4><br>  Kode sampel terkecil menggunakan ChaiScript adalah seperti yang ditunjukkan di bawah ini.  Kami mendefinisikan fungsi sederhana dalam C ++ yang mengambil std :: string dan mengembalikan string yang diubah, dan kemudian kami menambahkan tautan ke dalamnya di objek ChaiScript untuk memanggilnya.  Kompilasi dapat memakan waktu yang cukup lama, tetapi ini terutama disebabkan oleh fakta bahwa instantiasi sejumlah besar templat untuk kompiler tidaklah mudah: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;chaiscript/chaiscript.hpp&gt; std::string greet_name(const std::string&amp; name) { return "hello, " + name; } int main() { chaiscript::ChaiScript chai; //  chaiscript chai.add(chaiscript::fun(&amp;greet_name), "greet"); //    greet //  eval      chai.eval(R"( print(greet("John")); )"); }</span></span></span></span></code> </pre> <br>  Saya harap Anda berhasil, dan Anda melihat hasil dari fungsinya.  Saya ingin segera mencatat satu nuansa - jika Anda mendeklarasikan objek ChaiScript sebagai statis, Anda mendapatkan kesalahan runtime yang tidak menyenangkan.  Ini disebabkan oleh fakta bahwa bahasa mendukung multithreading secara default dan menyimpan variabel aliran lokal yang diakses di destruktornya.  Namun, mereka dihancurkan sebelum destruktor instance statis dipanggil, dan sebagai hasilnya, kami memiliki pelanggaran akses atau kesalahan kesalahan segmentasi.  Berdasarkan <a href="https://github.com/ChaiScript/ChaiScript/issues/338">masalah pada github</a> , solusi paling sederhana adalah dengan cukup meletakkan <b><code>#define CHAISCRIPT_NO_THREADS</code></b> dalam pengaturan kompiler atau sebelum memasukkan file perpustakaan, sehingga menonaktifkan multithreading.  Seperti yang saya pahami, itu tidak mungkin untuk memperbaiki kesalahan ini. <br><br>  Sekarang kita akan menganalisis secara terperinci bagaimana interaksi antara C ++ dan ChaiScript terjadi.  Pustaka mendefinisikan <code>fun</code> fungsi templat khusus, yang dapat membawa pointer ke fungsi, functor, atau pointer ke variabel kelas, dan lalu mengembalikan objek khusus yang menyimpan status.  Sebagai contoh, mari kita mendefinisikan kelas Widget dalam kode C ++ dan mencoba mengaitkannya dengan ChaiScript dengan cara yang berbeda: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget  C++  chai.add(chaiscript::fun([&amp;w] { return w; }), "get_widget"); //         chai.add(chaiscript::fun(ToString), "to_string"); //   chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); //   //    ,   Widget    GetId,    to_string,    chai.eval(R"( var w = get_widget() print(w.get_id) //  2 print(w) //  widget #2 )"); }</span></span></code> </pre><br>  Seperti yang Anda lihat, ChaiScript bekerja dengan sangat tenang dengan kelas C ++ yang tidak diketahui dan dapat memanggil metode mereka.  Jika Anda membuat kesalahan di suatu tempat dalam kode, kemungkinan besar skrip akan melemparkan pengecualian <code>error in function dispatch</code> jenis <code>error in function dispatch</code> , yang sama sekali tidak kritis.  Namun, tidak hanya fungsi yang dapat diimpor, mari kita lihat cara menambahkan variabel ke skrip menggunakan pustaka.  Untuk melakukan ini, pilih tugas sedikit lebih keras - import std :: vector &lt;Widget&gt;.  Fungsi <code>chaiscript::var</code> dan metode <code>add_global</code> akan membantu kami dalam hal ini.  Kami juga akan menambahkan bidang publik <code>Data</code> ke Widget kami untuk melihat cara mengimpor bidang kelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data = <span class="hljs-number"><span class="hljs-number">0</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()) + <span class="hljs-string"><span class="hljs-string">" with data: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.Data); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; W; <span class="hljs-comment"><span class="hljs-comment">//    Widget W.emplace_back(1); W.emplace_back(2); W.emplace_back(3); chai.add(chaiscript::fund(ToString), "to_string"); chai.add(chaiscript::fun(&amp;Widget::Data), "data"); //     //     ChaiScript chai.add_global(chaiscript::var(std::ref(W)), "widgets"); //     std::ref chai.add(chaiscript::fun(&amp;std::vector&lt;Widget&gt;::size), "size"); //   // .        using IndexFuncType = Widget&amp; (std::vector&lt;Widget&gt;::*)(const size_t); chai.add(chaiscript::fun(IndexFuncType(&amp;std::vector&lt;Widget&gt;::operator[])), "[]"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { vec[i].data = i * 2; print(vec[i]) } )"); }</span></span></code> </pre><br>  Kode di atas menampilkan: <b><code>widget #1 with data: 0</code> , <code>widget #2 with data: 2</code> , <code>widget #3 with data: 4</code></b> .  Kami menambahkan pointer ke bidang kelas di ChaiScript, dan karena bidang ternyata menjadi tipe primitif, kami mengubah nilainya.  Juga, beberapa metode ditambahkan untuk bekerja dengan <code>std::vector</code> , termasuk <code>operator[]</code> .  Mereka yang terbiasa dengan STL tahu bahwa <code>std::vector</code> dua metode pengindeksan - satu mengembalikan tautan yang konstan, yang lain merupakan tautan sederhana.  Itulah sebabnya untuk fungsi kelebihan beban, Anda harus secara eksplisit menunjukkan jenisnya - jika tidak, ambiguitas muncul, dan kompiler akan membuat kesalahan. <br><br>  Perpustakaan menyediakan beberapa metode lagi untuk menambahkan objek, tetapi semuanya hampir identik, jadi saya tidak melihat gunanya mempertimbangkannya secara rinci.  Sebagai petunjuk kecil, berikut adalah kode di bawah ini: <br><br><pre> <code class="cpp hljs">chai.add(chaiscript::var(x), <span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// x   ChaiScript chai.add(chaiscript::var(std::ref(x), "x"); //  ,    C++  ChaiScript auto shared_x = std::make_shared&lt;int&gt;(5); chai.add(chaiscript::var(shared_x), "x"); // shared_ptr      C++  ChaiScript chai.add(chaiscript::const_var(x), "x"); //   ChaiScript    chai.add_global_const(chaiscript::const_var(x), "x"); // global const . ,  x   chai.add_global(chaiscript::var(x), "x"); // global , .  x   chai.set_global(chaiscript::var(x), "x"); //   global ,    const</span></span></code> </pre><br><h4>  Menggunakan STL Containers </h4><br>  Jika Anda ingin meneruskan wadah STL yang berisi tipe <b>primitif</b> ke ChaiScript, Anda bisa menambahkan instantiasi wadah template ke skrip Anda sehingga Anda tidak mengimpor metode untuk setiap jenis. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyVector = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;; MyVector V; V.emplace_back(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); V.emplace_back(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    - vector  pair chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;MyVector&gt;("MyVec")); chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;MyVector::value_type&gt;("MyVecData")); chai.add(chaiscript::var(std::ref(V)), "vec"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { print(to_string(vec[i].first) + " " + vec[i].second) } )");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah tenda, beberapa fungsi ChaiScript dipanggil, yang dengan sendirinya menambahkan metode yang diperlukan. </font><font style="vertical-align: inherit;">Secara umum, jika kelas Anda mendukung operasi serupa dengan wadah STL, Anda juga dapat menambahkannya dengan cara ini. </font><font style="vertical-align: inherit;">Dalam kasus c, </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini, sayangnya, tidak mungkin, karena ChaiScript membutuhkan konstruktor tanpa parameter untuk elemen </font></font><code>vector_type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang tidak dimiliki oleh Widget kami.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas C ++ di dalam ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin sebagai bagian dari tugas Anda, Anda tidak hanya perlu memodifikasi objek dalam ChaiScript, tetapi juga membuatnya dalam skrip. </font><font style="vertical-align: inherit;">Yah, ini sepenuhnya mungkin. </font><font style="vertical-align: inherit;">Mari kita ambil kelas Widget lagi sebagai contoh dan mewarisi kelas WindowWidget darinya, dan kemudian menambahkan ke skrip kemampuan untuk membuat keduanya dan juga mengonversi kelas yang diwarisi ke basis:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WindowWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Widget { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WindowWidget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) : Widget(id), Size(width, height) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.second; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//   Widget    chai.add(chaiscript::user_type&lt;Widget&gt;(), "Widget"); chai.add(chaiscript::constructor&lt;Widget(int)&gt;(), "Widget"); //   WindowWidget    chai.add(chaiscript::user_type&lt;WindowWidget&gt;(), "WindowWidget"); chai.add(chaiscript::constructor&lt;WindowWidget(int, int, int)&gt;(), "WindowWidget"); // ,  Widget -    WindowWidget chai.add(chaiscript::base_class&lt;Widget, WindowWidget&gt;()); //   Widget  WindowWidget chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); chai.add(chaiscript::fun(&amp;WindowWidget::GetWidth), "width"); chai.add(chaiscript::fun(&amp;WindowWidget::GetHeight), "height"); //  WindowWidget     chai.eval(R"( var window = WindowWidget(1, 800, 600) print("${window.width} * ${window.height}") print("widget.id is ${window.get_id}") )"); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polimorfisme bekerja di ChaiScript dengan cara yang persis sama seperti di C ++ untuk jenis yang Anda berikan informasi tentang. </font><font style="vertical-align: inherit;">Jika karena alasan tertentu ada ambiguitas ketika menambahkan pointer ke metode yang diwarisi (mungkin kelas diwarisi dari beberapa metode dasar sekaligus), bawa ke kelas yang diinginkan secara eksplisit, seperti yang dilakukan dalam contoh di atas dengan operator pengindeksan </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengikat instance ke metode dan mengonversi tipe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk objek tunggal, akan lebih mudah untuk menggunakan pengambilan tautan ke mereka bersama-sama dengan metode atau bidang. </font><font style="vertical-align: inherit;">Dalam hal ini, dalam ChaiScript kita mendapatkan fungsi atau variabel global yang dapat diakses tanpa menyebutkan objek ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.Data = <span class="hljs-number"><span class="hljs-number">4444</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w chai.add(chaiscript::fun(&amp;Widget::GetId, &amp;w), "widget_id"); chai.add(chaiscript::fun(&amp;Widget::Data, &amp;w), "widget_data"); chai.eval(R"( print(widget_id) print(widget_data) )");</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, ketika mengekspor lebih banyak "perpustakaan" kelas dari C ++ ke ChaiScript (misalnya, vec3, complex, matrix), kemungkinan konversi implisit dari satu jenis ke yang lain sering diperlukan. Dalam ChaiScript, masalah ini diselesaikan dengan menambahkan </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skrip ke objek. Sebagai contoh, pertimbangkan kelas Complex dan implementasi konversi int dan gandakan untuk itu selama penambahan:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Re, Im; Complex(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> re, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> im = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : Re(re), Im(im) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//  Complex,   re, im,    `=` chai.add(chaiscript::user_type&lt;Complex&gt;(), "Complex"); chai.add(chaiscript::bootstrap::standard_library::assignable_type&lt;Complex&gt;("Complex")); chai.add(chaiscript::constructor&lt;Complex(float, float)&gt;(), "Complex"); chai.add(chaiscript::fun(&amp;Complex::Re), "re"); chai.add(chaiscript::fun(&amp;Complex::Im), "im"); //     double  int  Complex chai.add(chaiscript::type_conversion&lt;int, Complex&gt;()); chai.add(chaiscript::type_conversion&lt;double, Complex&gt;()); //     `+`    chai.eval(R"( def `+`(Complex c, x) { var res = Complex(0, 0) res.re = c.re + x.re res.im = c.im + x.im return res } var c = Complex(1, 2) c = c + 3 print("${c.re} + ${c.im}i") )"); // : `4 + 2i` }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, tidak perlu menulis fungsi konversi dalam C ++ itu sendiri, dan hanya kemudian mengekspornya ke ChaiScript. </font><font style="vertical-align: inherit;">Anda dapat menambahkan transformasi, dan sudah menjelaskan fungsionalitas baru dalam kode skrip itu sendiri. </font><font style="vertical-align: inherit;">Jika konversi untuk kedua jenis ini nontrivial, Anda bisa meneruskan lambda sebagai argumen ke suatu fungsi </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan dipanggil saat casting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip serupa digunakan untuk mengubah Vector atau Map ChaiScript menjadi tipe khusus Anda. </font><font style="vertical-align: inherit;">Untuk ini, </font></font><code>vector_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font><font style="vertical-align: inherit;">didefinisikan di perpustakaan </font></font><code>map_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membongkar Nilai Pengembalian ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode </font></font><code>eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>eval_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan nilai ekspresi yang terakhir dieksekusi sebagai objek </font></font><code>Boxed_Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk membukanya dan menggunakan hasil dalam kode C ++, Anda dapat secara eksplisit menentukan jenis nilai kembali, atau menggunakan fungsi </font></font><code>boxed_cast&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika konversi antara jenis ada, itu akan dieksekusi, jika tidak pengecualian akan dimunculkan </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       double d = chai.eval&lt;double&gt;("5.3 + 2.1"); //     Boxed_Value,     auto v = chai.eval("5.3 + 2.1"); double d = chai.boxed_cast&lt;double&gt;(v);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena semua objek di dalam ChaiScript disimpan menggunakan shared_ptr, Anda bisa mendapatkan objek sebagai penunjuk untuk dikerjakan lebih lanjut. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tentukan secara eksplisit tipe shared_ptr saat mengonversi nilai kembali:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(<span class="hljs-string"><span class="hljs-string">"var x = 3.2"</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal utama adalah tidak menyimpan referensi ke nilai shared_ptr dereferenced, jika tidak Anda berisiko mengambil pelanggaran akses setelah variabel dihapus selama pengumpulan sampah otomatis dalam skrip. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti variabel, Anda bisa mendapatkan fungsi dari ChaiScript dalam bentuk functors dikemas yang menangkap keadaan objek ChaiScript. </font><font style="vertical-align: inherit;">Misalnya, kita akan menggunakan fungsionalitas kelas Complex yang sudah diterapkan dan mencoba menggunakannya untuk memanggil fungsi pada tahap pelaksanaan program:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printComplex = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Complex)&gt;&gt;(<span class="hljs-string"><span class="hljs-string">R"( fun(Complex c) { print("${c.re} + ${c.im}i"); } )"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ,      C++ printComplex(Complex(2, 3)); //  chaiscript,  `2 + 3i`</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengecualian ChaiScript menangkap </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penulis menyarankan untuk menangkap tiga jenis pengecualian selain yang Anda hasilkan sendiri. </font><font style="vertical-align: inherit;">Ini </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk kesalahan runtime, </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang disebut ketika nilai-nilai kembali dibongkar salah dan </font></font><code>std::exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk semua yang lain. </font><font style="vertical-align: inherit;">Jika Anda berencana untuk membuang pengecualian Anda sendiri, Anda dapat mengonfigurasi konversi otomatis ke tipe C ++:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data; MyException(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) : <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"MyException"</span></span>), Data(data) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//      chaiscript chai.add(chaiscript::user_type&lt;MyException&gt;(), "MyException"); chai.add(chaiscript::constructor&lt;MyException(int)&gt;(), "MyException"); try { //          chai.eval("throw(MyException(11111))", chaiscript::exception_specification&lt;MyException, std::exception&gt;()); } catch (MyException&amp; e) { std::cerr &lt;&lt; e.Data; //   `11111` } catch (chaiscript::exception::eval_error&amp; e) { std::cerr &lt;&lt; e.pretty_print(); } catch(std::exception&amp; e) { std::cerr &lt;&lt; e.what(); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh di atas menunjukkan cara menangkap sebagian besar pengecualian di C ++. </font><font style="vertical-align: inherit;">Selain metode ini </font></font><code>pretty_print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masih ada banyak data berguna, seperti tumpukan panggilan, nama file, detail kesalahan, tetapi kami tidak akan membahas kelas ini terlalu banyak dalam artikel ini.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perpustakaan ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, secara default, ChaiScript tidak menyediakan fungsionalitas tambahan dalam hal perpustakaan. </font><font style="vertical-align: inherit;">Misalnya, ia tidak memiliki fungsi matematika, tabel hash, dan sebagian besar algoritma. </font><font style="vertical-align: inherit;">Anda dapat mengunduh beberapa di antaranya dalam bentuk pustaka modul dari repositori resmi </font></font><a href="https://github.com/ChaiScript/ChaiScript_Extras"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaiScript Extras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan kemudian mengimpor ke dalam skrip Anda. </font><font style="vertical-align: inherit;">Misalnya, ambil perpustakaan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matematika</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan fungsi acos (x):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chaiscript/chaiscript.hpp&gt; #include &lt;chaiscript/extras/math.hpp&gt; int main() { chaiscript::ChaiScript chai; //   auto mathlib = chaiscript::extras::math::bootstrap(); chai.add(mathlib); std::cout &lt;&lt; chai.eval&lt;double&gt;("acos(0.5)"); // ~1.047 }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga dapat menulis perpustakaan Anda untuk bahasa lalu mengimpor. </font><font style="vertical-align: inherit;">Ini dilakukan cukup sederhana, jadi saya menyarankan Anda untuk membiasakan diri dengan matematika open source atau sumber lain di repositori. </font><font style="vertical-align: inherit;">Pada prinsipnya, sebagai bagian dari integrasi dengan C ++, kami memeriksa hampir semuanya, jadi saya pikir bagian ini dapat diselesaikan.</font></font><br><a name="myexp"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengalaman pribadi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini saya sedang menulis mesin 3D di bawah OpenGL sebagai proyek pribadi, dan saya memiliki ide yang sepenuhnya logis untuk mengimplementasikan konsol debugging untuk mengendalikan keadaan aplikasi secara real time melalui perintah. Tentu saja mungkin untuk </font></font><a href="https://github.com/MomoDeve/MSL"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bersepeda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi seperti yang mereka katakan, "permainan tidak akan sepadan dengan lilin", jadi saya memutuskan untuk mengambil perpustakaan yang sudah selesai.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang saya sebutkan di awal artikel, saya sudah tahu tentang ChaiScript, jadi saya punya pilihan antara dia dan Lua. </font><font style="vertical-align: inherit;">Sampai saat itu, saya tidak terbiasa dengan kedua bahasa tersebut, oleh karena itu, faktor-faktor seperti: sintaks yang jelas, kemudahan penyisipan ke dalam kode yang ada, dan dukungan untuk C ++ alih-alih yang paling dipengaruhi oleh C agar tidak membuat pagar dari pembungkus OOP di atas C- fungsi gaya. </font><font style="vertical-align: inherit;">Saya pikir, ketika Anda membaca artikel ini, Anda sudah menebak pilihan saya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, bahasanya lebih dari cocok untukku, dan menulis di kelas bukan masalah besar. </font><font style="vertical-align: inherit;">Dalam kode mesin, satu instance konsol pada ImGui dilampirkan ke aplikasi yang diluncurkan, di mana objek chaiscript diinisialisasi. </font><font style="vertical-align: inherit;">Dengan beberapa makro, tugas memperkenalkan kelas baru ke dalam skrip diturunkan ke deskripsi sederhana dari semua metode yang perlu diekspor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3D-: // rotation CHAI_IMPORT(&amp;GLInstance::RotateX, rotate_x); CHAI_IMPORT(&amp;GLInstance::RotateY, rotate_y); CHAI_IMPORT(&amp;GLInstance::RotateZ, rotate_z); // scale CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float))&amp;GLInstance::Scale, scale); CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float, float, float))&amp;GLInstance::Scale, scale); // translation CHAI_IMPORT(&amp;GLInstance::Translate, translate); CHAI_IMPORT(&amp;GLInstance::TranslateX, translate_x); CHAI_IMPORT(&amp;GLInstance::TranslateY, translate_y); CHAI_IMPORT(&amp;GLInstance::TranslateZ, translate_z); // hide / show CHAI_IMPORT(&amp;GLInstance::Hide, hide); CHAI_IMPORT(&amp;GLInstance::Show, show); // getters CHAI_IMPORT(&amp;GLInstance::GetTranslation, translation); CHAI_IMPORT(&amp;GLInstance::GetRotation, rotation); CHAI_IMPORT(&amp;GLInstance::GetScale, scale);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan cara yang sama, beberapa kelas lagi diekspor, dan kemudian semuanya dihubungkan bersama oleh fungsi lambda yang dideklarasikan langsung dalam kode inisialisasi. Anda dapat melihat hasil skrip di tangkapan layar: </font></font><br><br><img src="https://habrastorage.org/webt/rl/bo/td/rlbotdpcfl4pdpbplwxfrvsk73i.png" alt="gambar"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konsol dari chaiscript ke ImGui: mengunduh dan menginstal objek melalui perintah</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengingat fleksibilitas perpustakaan secara keseluruhan, mengubah pendekatan untuk mengekspor kelas ke skrip akan hampir secara langsung. Tentu saja, Lua memiliki dokumentasi dan komunitas yang lebih luas, dan bahasa ini akan lebih disukai jika Anda perlu mendapatkan lebih banyak kinerja dari kode skrip (JIT masih melakukan tugasnya), tetapi Anda tetap tidak harus menghapus ChaiScript. Jika Anda memiliki proyek kecil yang membutuhkan skrip, Anda dapat dengan aman bereksperimen dengan alternatif yang tersedia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada catatan ini, saya ingin menyelesaikan artikel ini. </font><font style="vertical-align: inherit;">Jika Anda sudah memiliki pengalaman bekerja dengan bahasa scripting di dalam C ++ (baik itu Lua atau bahasa lain), di komentar saya akan senang mendengar pendapat Anda tentang ChaiScript dan scripting secara umum. </font><font style="vertical-align: inherit;">Saya juga menyambut setiap pertanyaan atau komentar mengenai publikasi ini. </font><font style="vertical-align: inherit;">Terima kasih sudah membaca.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tautan yang bermanfaat </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situs web resmi </font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;">ChaiScript</font></a><font style="vertical-align: inherit;"> : </font></font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaiscript.com</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi Cepat Sintaks dan Perpustakaan: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaiScript cheatsheet</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi Resmi: </font></font><a href="https://codedocs.xyz/ChaiScript/ChaiScript/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codedocs.xyz/ChaiScript/ChaiScript</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek saya menggunakan ChaiScript: </font></font><a href="https://github.com/MomoDeve/MomoEngine"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/MomoDeve/MomoEngine</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483540/">https://habr.com/ru/post/id483540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483528/index.html">REST API harus berdasarkan pada hypertext</a></li>
<li><a href="../id483530/index.html">Bagaimana kami melakukan permainan papan. Kenapa dan mengapa?</a></li>
<li><a href="../id483532/index.html">Konferensi DefCon 27: Di Balik Layar Membuat Lencana Elektronik Bagian 1</a></li>
<li><a href="../id483536/index.html">Sejarah mikroprosesor dan komputer pribadi: 1974 - 1980</a></li>
<li><a href="../id483538/index.html">Menghubungkan Layar 10 "ER-TFT101-1 ke STM32F429 via FMC</a></li>
<li><a href="../id483542/index.html">Intisari telekomunikasi - materi tentang pekerjaan penyedia</a></li>
<li><a href="../id483544/index.html">Data baru membantah asumsi utama energi gelap</a></li>
<li><a href="../id483550/index.html">Layanan dan Pengembangan IaaS: Kompilasi Awan, Penyimpanan, dan Evolusi 1cloud</a></li>
<li><a href="../id483552/index.html">MVVM dan pemilihan elemen dalam adaptor</a></li>
<li><a href="../id483554/index.html">Platform teknologi baru tahun 20-an. Kenapa saya tidak setuju dengan Zuckerberg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>