<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐮 👨‍💼 ↕️ Surprise fsync () PostgreSQL 🧝 💋 💅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengembang DBMS, berdasarkan kebutuhan, khawatir bahwa data dengan aman jatuh ke penyimpanan permanen. Karena itu, ketika komunitas PostgreSQL menemuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Surprise fsync () PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472684/"><img width="50%" align="left" src="https://habrastorage.org/webt/oz/ps/ut/ozpsutp44sz5dvmpfteszdiba5o.png">  Pengembang DBMS, berdasarkan kebutuhan, khawatir bahwa data dengan aman jatuh ke penyimpanan permanen.  Karena itu, ketika komunitas PostgreSQL menemukan bahwa cara kernel menangani kesalahan I / O dapat menyebabkan hilangnya data tanpa ada kesalahan yang dilaporkan ke ruang pengguna, banyak ketidakpuasan muncul.  Masalahnya, yang diperburuk oleh fakta bahwa PostgreSQL melakukan buffered I / O, tidak unik untuk Linux, dan tidak akan mudah untuk diselesaikan bahkan di sana. <br><br>  Craig Ringer pertama kali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melaporkan masalah ini</a> ke milis pgsql-hacker pada akhir Maret.  Singkatnya, PostgreSQL mengasumsikan bahwa panggilan <code>fsync()</code> berhasil menunjukkan bahwa semua data yang direkam sejak panggilan terakhir yang berhasil dengan aman ditransfer ke penyimpanan persisten.  Ketika penulisan buffer I / O gagal karena kesalahan perangkat keras, sistem file bereaksi secara berbeda, tetapi perilaku ini biasanya melibatkan menghapus data pada halaman terkait dan menandainya sebagai bersih.  Oleh karena itu, membaca blok yang baru saja ditulis kemungkinan besar akan mengembalikan sesuatu yang lain, tetapi tidak mencatat data. <br><a name="habracut"></a><br>  Bagaimana dengan pelaporan kesalahan?  Setahun yang lalu, KTT Linux Filesystem, Storage and Memory-Management Summit (LSFMM) termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sesi</a> laporan bug di mana semuanya disebut "berantakan";  kesalahan dapat dengan mudah hilang, jadi tidak ada aplikasi yang akan melihatnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beberapa tambalan yang</a> termasuk dalam 4.13 sedikit memperbaiki situasi selama siklus pengembangan (dan pada 4.16 ada beberapa perubahan untuk memperbaikinya lebih lanjut), namun, ada cara untuk kehilangan pemberitahuan kesalahan, seperti dijelaskan di bawah ini.  Jika ini terjadi pada server PostgreSQL, ini dapat menyebabkan korupsi basis data otomatis. <br><br>  Pengembang PostgreSQL tidak senang.  Tom Lane <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambarkan</a> ini sebagai " <b>kerusakan otak pada nukleus,</b> " sementara Robert Haas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyebutnya</a> " <b>100% bodoh</b> ."  Pada awal diskusi, pengembang PostgreSQL memahami dengan jelas bagaimana, menurut mereka, kernel harus bekerja: halaman yang tidak dapat ditulis harus disimpan dalam memori dalam keadaan "kotor" (untuk upaya selanjutnya), dan deskriptor file yang sesuai harus diterjemahkan ke dalam Status kesalahan permanen sehingga server PostgreSQL tidak dapat melewati masalah. <br><br><h4>  Di mana ada yang tidak beres </h4><br>  Namun, bahkan sebelum komunitas kernel masuk ke dalam diskusi, menjadi jelas bahwa situasinya tidak sesederhana kelihatannya.  Thomas Munro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa Linux tidak unik dalam perilaku ini;  OpenBSD dan NetBSD mungkin juga tidak melaporkan kesalahan tulis di ruang pengguna.  Dan, ternyata, cara PostgreSQL menangani operasi I / O buffered sangat menyulitkan gambar. <br><br>  Mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>ini telah dijelaskan secara rinci oleh</u></a> Haas.  Server PostgreSQL berfungsi sebagai serangkaian proses, banyak di antaranya dapat melakukan I / O pada file database.  Namun, <code>fsync()</code> panggilan <code>fsync()</code> ditangani dalam proses checkpointer tunggal ("checkpointer"), yaitu menjaga penyimpanan disk dalam keadaan yang konsisten untuk pulih dari kegagalan.  Checkpointer biasanya tidak membuat semua file yang relevan tetap terbuka, jadi sering kali harus membuka file sebelum memanggil <code>fsync()</code> .  Di sinilah masalah muncul: bahkan di kernel 4.13 dan versi yang lebih baru, checkpointer tidak akan melihat kesalahan apa pun yang terjadi sebelum file dibuka.  Jika sesuatu yang buruk terjadi sebelum memanggil <code>open()</code> checkpointer-a, maka panggilan berikutnya ke <code>fsync()</code> akan mengembalikan kesuksesan.  Ada beberapa cara untuk menyebabkan kesalahan I / O di luar <code>fsync()</code> ;  misalnya, kernel mungkin menemui salah satunya saat melakukan penulisan balik latar belakang.  <code>sync()</code> panggilan seseorang <code>sync()</code> juga mungkin mengalami kesalahan I / O dan “menyerap” status kesalahan yang dihasilkan. <br><br>  Haas menggambarkan perilaku ini sebagai tidak dapat memenuhi harapan PostgreSQL: <br><blockquote>  Semua yang Anda (atau seseorang) miliki pada dasarnya merupakan asumsi yang tidak terbukti <br>  deskriptor file mana yang mungkin relevan dengan kesalahan tertentu, tetapi kebetulan PostgreSQL tidak pernah cocok dengannya.  Anda dapat terus mengatakan bahwa masalahnya ada di dugaan kami, tetapi bagi saya keliru menganggap bahwa kami adalah satu-satunya program yang pernah melakukannya. </blockquote><br>  Akibatnya, Joshua Drake <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memindahkan percakapan</a> ke daftar pengembangan untuk ext4, termasuk bagian dari komunitas pengembangan kernel.  Dave Chinner dengan cepat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambarkan</a> perilaku ini sebagai " <b>resep untuk bencana, terutama dalam kode lintas-platform, di mana setiap platform OS berperilaku berbeda dan hampir tidak pernah cocok dengan apa yang diharapkan</b> ."  Sebagai gantinya, Ted Tso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjelaskan</a> mengapa halaman yang terpengaruh ditandai sebagai bersih setelah kesalahan I / O;  singkatnya, penyebab paling umum dari kesalahan I / O adalah ketika pengguna mengeluarkan drive USB pada waktu yang salah.  Jika suatu proses menyalin banyak data ke disk ini, hasilnya adalah akumulasi dari halaman-halaman kotor dalam memori, mungkin sampai pada titik bahwa sistem tidak memiliki cukup memori untuk tugas-tugas lain.  Dengan demikian, halaman-halaman ini tidak dapat disimpan dan akan dihapus jika pengguna ingin sistem tetap dapat digunakan setelah peristiwa semacam itu. <br><br>  Baik Chinner dan Tso, bersama dengan yang lain, mengatakan PostgreSQL memiliki solusi yang tepat - beralih ke I / O (DIO) langsung.  Menggunakan DIO memberikan tingkat kontrol yang lebih besar atas penulisan kembali dan I / O secara umum;  ini termasuk akses ke informasi tentang operasi I / O yang mungkin gagal.  Andres Freund, seperti sejumlah pengembang PostgreSQL lainnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengakui</a> bahwa DIO adalah solusi jangka panjang terbaik.  Tetapi dia juga mencatat bahwa orang seharusnya tidak mengharapkan pengembang untuk terjun jauh ke dalam pelaksanaan tugas ini.  Sementara itu, dia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa ada program lain (dia menyebutkan dpkg) yang juga rentan terhadap perilaku ini. <br><br><h4>  Menuju solusi jangka pendek </h4><br>  Selama diskusi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perhatian yang</a> cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besar</a> diberikan pada gagasan bahwa kegagalan menulis harus mengarah pada fakta bahwa halaman yang terpengaruh akan disimpan dalam memori dalam keadaan kotor mereka.  Tetapi para pengembang PostgreSQL dengan cepat menjauh dari ide ini dan tidak menuntutnya.  Yang benar-benar mereka butuhkan pada akhirnya adalah cara yang andal untuk mencari tahu apakah ada yang salah.  Dengan mengingat hal ini, mekanisme penanganan kesalahan PostgreSQL yang biasa dapat menangani hal ini;  Namun, sedikit yang bisa dilakukan tanpa kehadirannya. <br><br>  Pada beberapa titik dalam diskusi, Tso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyebutkan</a> bahwa Google memiliki mekanisme penanganan kesalahan I / O sendiri.  Kernel diinstruksikan untuk melaporkan kesalahan I / O melalui soket netlink;  Proses khusus menerima pemberitahuan ini dan merespons sesuai.  Namun mekanisme ini tidak pernah melakukan ini di pintu masuk.  Freind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> bahwa mekanisme ini akan "ideal" untuk PostgreSQL, sehingga mungkin muncul dalam domain publik dalam waktu dekat. <br><br>  Sementara itu, Jeff Leighton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memikirkan</a> ide lain: untuk menetapkan bendera di superblok sistem file ketika kesalahan I / O terjadi.  Panggilan ke <code>syncfs()</code> kemudian akan menghapus bendera ini dan mengembalikan kesalahan jika sudah diatur.  <code>syncfs()</code> PostgreSQL secara berkala dapat memanggil <code>syncfs()</code> untuk mencari kesalahan pada sistem file yang berisi database.  Freund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setuju</a> bahwa ini bisa menjadi solusi untuk masalah tersebut. <br><br>  Tentu saja, mekanisme semacam itu hanya akan muncul di kernel baru;  Sementara itu, instalasi PostgreSQL biasanya berjalan pada kernel lama yang didukung oleh distribusi perusahaan.  Dalam kernel ini, tampaknya tidak ada perbaikan yang termasuk dalam 4.13.  Untuk sistem ini, sedikit yang bisa dilakukan untuk membantu PostgreSQL mendeteksi kesalahan I / O.  Mungkin cukup untuk memulai daemon yang memindai log sistem dan mencari pesan kesalahan I / O di sana.  Bukan solusi yang paling elegan, dan ini diperumit oleh fakta bahwa driver blok dan sistem file yang berbeda, sebagai aturan, melaporkan kesalahan dengan cara yang berbeda, tetapi ini mungkin merupakan pilihan terbaik yang tersedia. <br><br>  Langkah selanjutnya adalah diskusi di acara LSFMM 2018 pada 23 April.  Jika Anda beruntung, akan ada semacam solusi yang akan bekerja untuk pihak yang berkepentingan.  Namun, satu hal yang tidak akan berubah adalah fakta sederhana bahwa penanganan kesalahan sulit dilakukan dengan benar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472684/">https://habr.com/ru/post/id472684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472670/index.html">Musim gugur yang tenang, Musim dingin yang ...</a></li>
<li><a href="../id472672/index.html">Judul "Baca artikel untuk Anda." Juli - September 2019</a></li>
<li><a href="../id472674/index.html">Variabel Lingkungan untuk Proyek Python</a></li>
<li><a href="../id472676/index.html">Kami membuat departemen jones untuk membantu tim utama, hanya menggunakan Slack, Jira dan pita listrik biru</a></li>
<li><a href="../id472682/index.html">Memperlambat Penuaan dengan Sinergi Narkoba di C. elegans</a></li>
<li><a href="../id472686/index.html">Studio Video Berdasarkan i486</a></li>
<li><a href="../id472688/index.html">Cara kerja rendering game 3D: pemrosesan vertex</a></li>
<li><a href="../id472690/index.html">Apa yang Baru di Zabbix 4.4</a></li>
<li><a href="../id472694/index.html">Lebih dari Ceph: MCS Block Cloud Storage</a></li>
<li><a href="../id472702/index.html">JH Rainwater "Cara merumput kucing": keturunan programmer dan fitur pembiakan mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>