<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐕 🕹️ 🙅🏾 Kotak pasir yang ditingkatkan untuk skrip asyik 🙅 🐡 🤴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari seorang penerjemah: Saat mengembangkan Platform CUBA, kami menempatkan dalam kerangka kerja ini kemampuan untuk mengeksekusi skrip khusus untuk k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotak pasir yang ditingkatkan untuk skrip asyik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/445114/"><p><img src="https://habrastorage.org/webt/l7/d9/cg/l7d9cgoh4tjgptdfr68phnooab4.jpeg"></p><br><p>  <em>Dari seorang penerjemah: Saat mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Platform CUBA,</a> kami menempatkan dalam kerangka kerja ini kemampuan untuk mengeksekusi skrip khusus untuk konfigurasi yang lebih fleksibel dari logika bisnis aplikasi.</em>  <em>Apakah peluang ini baik atau buruk (dan kita berbicara tidak hanya tentang CUBA) sedang diperdebatkan untuk waktu yang lama, tetapi fakta bahwa kontrol atas eksekusi skrip pengguna diperlukan tidak menimbulkan pertanyaan.</em>  <em>Salah satu fitur berguna Groovy untuk mengelola eksekusi skrip kustom disajikan dalam terjemahan Cédric Champeau ini.</em>  <em>Terlepas dari kenyataan bahwa ia baru-baru ini meninggalkan tim pengembangan Groovy, komunitas programmer tampaknya mengambil keuntungan dari pekerjaannya untuk waktu yang lama.</em> </p><br><p>  Salah satu cara yang paling umum digunakan untuk menggunakan Groovy adalah melalui scripting, karena Groovy membuatnya mudah untuk mengeksekusi kode secara dinamis dalam runtime.  Tergantung pada aplikasinya, skrip dapat ditempatkan di tempat yang berbeda: sistem file, basis data, layanan jarak jauh ... tetapi yang paling penting, pengembang aplikasi yang menjalankan skrip tidak harus menulisnya.  Selain itu, skrip dapat bekerja di lingkungan terbatas (memori terbatas, batas jumlah deskriptor file, runtime ...), atau Anda mungkin ingin mencegah pengguna menggunakan semua fitur bahasa dalam skrip. </p><br><p>  <strong>Posting ini akan memberi tahu Anda.</strong> </p><br><ul><li>  mengapa asyik baik untuk menulis dsl internal </li><li>  apa saja fitur-fiturnya dalam hal keamanan aplikasi Anda </li><li>  cara mengkonfigurasi kompilasi untuk meningkatkan DSL </li><li> tentang nilai <code>SecureASTCustomizer</code> </li><li>  tentang ekstensi kontrol tipe </li><li>  cara menggunakan ekstensi kontrol tipe untuk menjadikan sandboxing efektif </li></ul><a name="habracut"></a><br><p>  Misalnya, bayangkan apa yang perlu Anda lakukan agar pengguna dapat menghitung ekspresi matematika.  Salah satu opsi implementasi adalah menanamkan DSL internal, membuat parser, dan akhirnya seorang juru bahasa untuk ungkapan-ungkapan ini.  Untuk melakukan ini, tentu saja, Anda harus bekerja, tetapi jika Anda perlu meningkatkan produktivitas, misalnya, dengan menghasilkan bytecode untuk ekspresi alih-alih menghitungnya dalam interpreter atau menggunakan caching kelas yang dihasilkan dalam runtime, maka Groovy adalah pilihan yang bagus. </p><br><p>  Ada banyak opsi yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , tetapi contoh paling sederhana adalah hanya menggunakan kelas <code>Eval</code> : </p><br><p> <code>Example.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = (Integer) Eval.me(<span class="hljs-string"><span class="hljs-string">"1+1"</span></span>);</code> </pre> <br><p>  <code>1+1</code> kode diuraikan, dikompilasi menjadi bytecode, dimuat dan dieksekusi oleh Groovy dalam runtime.  Tentu saja, kode dalam sampel ini sangat sederhana, dan Anda perlu menambahkan parameter, tetapi idenya adalah bahwa kode yang dapat dieksekusi dapat berubah-ubah.  Dan itu mungkin bukan yang Anda butuhkan.  Dalam kalkulator Anda harus mengizinkan sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs">1+1 x+y 1+(2*x)**y cos(alpha)*r v=1+x</code> </pre> <br><p>  tapi tentu saja tidak </p><br><pre> <code class="plaintext hljs">println 'Hello' (0..100).each { println 'Blah' } Pong p = new Pong() println(new File('/etc/passwd').text) System.exit(-1) Eval.me('System.exit(-1)') // a script within a script!</code> </pre> <br><p>  Di sinilah kesulitan dimulai, dan juga menjadi jelas bahwa kita perlu menyelesaikan beberapa masalah: </p><br><ul><li>  batasi tata bahasa suatu subset dari kemampuannya </li><li>  mencegah pengguna mengeksekusi kode yang tidak disediakan </li><li>  mencegah eksekusi kode berbahaya </li></ul><br><p>  Contoh dengan kalkulator ini cukup sederhana, tetapi untuk DSL yang lebih kompleks, orang mungkin tidak memperhatikan bahwa mereka sedang menulis kode bermasalah, terutama jika DSL sangat sederhana sehingga <em>pengembang tidak</em> dapat menggunakannya. </p><br><p>  Beberapa tahun yang lalu saya berada dalam situasi ini.  Saya mengembangkan mesin yang menjalankan "skrip" Groovy yang ditulis oleh ahli bahasa.  Satu masalah, misalnya, adalah bahwa mereka secara tidak sengaja dapat membuat loop tanpa akhir.  Kode dieksekusi di server, dan muncul utas melahap 100% dari CPU, setelah itu diperlukan untuk me-restart server aplikasi.  Saya harus mencari cara untuk menyelesaikan masalah tanpa mempengaruhi DSL, alat atau kinerja aplikasi. </p><br><p>  Bahkan, banyak orang memiliki kebutuhan serupa.  Selama 4 tahun terakhir, saya telah berbicara dengan banyak orang yang memiliki pertanyaan yang sama: <em>Bagaimana saya dapat mencegah pengguna melakukan omong kosong dalam skrip Groovy?</em> </p><br><h2 id="kastomayzery-kompilyacii">  Penyusun penyesuaian </h2><br><p>  Pada saat itu, saya sudah memiliki keputusan sendiri dan saya tahu bahwa orang lain juga mengembangkan sesuatu yang serupa.  Pada akhirnya, Guillaume Laforge menyarankan agar saya membuat mekanisme di kernel Groovy untuk membantu memecahkan masalah ini.  Itu muncul di Groovy 1.8.0 sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyesuai kompilasi</a> . </p><br><p>  Penyesuai kompilasi adalah sekumpulan kelas yang memodifikasi proses kompilasi skrip Groovy.  Anda dapat menulis penyesuai sendiri, tetapi Groovy memasok: </p><br><ul><li>  impor penyesuai yang secara implisit menambahkan impor ke skrip sehingga pengguna tidak perlu menambahkan deskripsi impor </li><li>  customizer AST (Abstract Syntax Tree) transformasi, memungkinkan Anda untuk menambahkan transformasi AST langsung ke skrip </li><li>  Penyesuai AST aman membatasi konstruksi tata bahasa dan sintaksis suatu bahasa </li></ul><br><p>  Penyesuai transformasi AST membantu saya memecahkan masalah loop tanpa akhir dengan transformasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>@ThreadInterrupt</code></a> , tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SecureASTCustomizer</a> adalah hal yang mungkin paling disalahpahami dalam sebagian besar kasus. </p><br><p>  Saya harus minta maaf untuk itu.  Maka saya tidak dapat menemukan nama yang lebih baik.  Bagian terpenting dalam nama "SecureASTCustomizer" adalah <strong>AST</strong> .  Tujuan dari mekanisme ini adalah untuk membatasi akses ke fungsi AST tertentu.  Kata "aman" pada judul umumnya berlebihan, dan saya akan menjelaskan alasannya.  Bahkan ada posting blog oleh Jenuke-terkenal Kosuke Kawaguchi, berjudul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Fatal Groovy SecureASTCustomizer"</a> .  Dan semuanya ditulis dengan sangat benar di sana.  SecureASTCustomizer tidak dirancang untuk sandboxing.  Itu dibuat untuk membatasi bahasa pada waktu kompilasi, tetapi tidak eksekusi.  Sekarang saya pikir nama terbaik adalah <em>GrammarCustomizer</em> .  Tetapi, seperti yang Anda tentu tahu, ada tiga kesulitan dalam ilmu komputer: pembatalan cache, menciptakan nama, dan kesalahan per unit. </p><br><p>  Sekarang bayangkan Anda mempertimbangkan penyesuai AST aman sebagai cara untuk memastikan keamanan skrip Anda, dan tugas Anda adalah mencegah pengguna dari <code>System.exit</code> dari skrip.  Dokumentasi mengatakan bahwa panggilan dapat dilarang di penerima khusus dengan membuat daftar hitam atau putih.  Jika keamanan diperlukan, saya selalu merekomendasikan daftar putih yang secara ketat menyatakan apa yang diperbolehkan, tetapi bukan daftar hitam yang melarang apa pun.  Karena peretas selalu memikirkan apa yang mungkin tidak Anda pertimbangkan.  Saya akan memberi contoh. </p><br><p>  Berikut cara menyiapkan mesin skrip kotak pasir primitif menggunakan <code>SecureASTCustomizer</code> .  Meskipun saya bisa menulisnya di Groovy, saya memberikan contoh konfigurasi Java untuk membuat perbedaan antara kode integrasi dan skrip lebih eksplisit. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); SecureASTCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureASTCustomizer(); customizer.setReceiversBlackList(Arrays.asList(System.class.getName())); conf.addCompilationCustomizers(customizer); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(conf); Object v = shell.evaluate(<span class="hljs-string"><span class="hljs-string">"System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Result = "</span></span> +v); } }</code> </pre> <br><ol><li>  buat konfigurasi kompiler </li><li>  buat pengubahsuaian AST aman </li><li>  menyatakan bahwa kelas <code>System</code> sebagai penerima panggilan metode dimasukkan daftar hitam </li><li>  tambahkan customizer ke konfigurasi kompiler </li><li>  mengikat konfigurasi dengan skrip shell, yaitu, mencoba membuat kotak pasir </li><li>  jalankan skrip "buruk" </li><li>  tampilkan hasil menjalankan skrip </li></ol><br><p>  Jika Anda menjalankan kelas ini, kesalahan akan terjadi selama eksekusi skrip: </p><br><pre> <code class="plaintext hljs">General error during canonicalization: Method calls not allowed on [java.lang.System] java.lang.SecurityException: Method calls not allowed on [java.lang.System]</code> </pre> <br><p>  Kesimpulan ini dikeluarkan oleh aplikasi dengan customizer AST yang aman, yang tidak memungkinkan eksekusi metode dari kelas <code>System</code> .  Sukses!  Jadi kami telah melindungi skrip kami!  Tapi tunggu sebentar ... </p><br><h2 id="secureastcustomizer-vzloman">  SecureASTCustomizer diretas! </h2><br><p>  Perlindungan, katakan?  Tetapi bagaimana jika saya melakukan ini: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Jika Anda menjalankan program lagi, Anda akan melihat program mogok <strong>tanpa</strong> kesalahan dan <strong>tanpa</strong> menampilkan hasilnya di layar.  Kode keluar proses adalah -1, yang berarti skrip pengguna telah dijalankan!  Apa yang terjadi  Pada waktu kompilasi, pengubahsuaian AST aman tidak dapat mengenali bahwa <code>c.exit</code> pada <code>c.exit</code> adalah panggilan ke metode <code>System</code> karena ia bekerja pada level AST!  Ini menganalisis pemanggilan metode, dan dalam hal ini pemanggilan metode adalah <code>c.exit(-1)</code> , maka ia menentukan penerima dan memeriksa apakah itu ada dalam daftar putih (atau hitam).  Dalam hal ini, penerima adalah <code>c</code> , variabel ini <strong>dideklarasikan melalui def</strong> , dan ini sama dengan menyatakannya sebagai <code>Object</code> , dan pengubah AST yang aman akan berpikir bahwa jenis variabel <code>c</code> adalah <code>Object</code> , bukan <code>System</code> ! </p><br><p>  Secara umum, ada <strong>banyak</strong> cara untuk menyiasati berbagai konfigurasi yang dibuat pada AST customizer yang aman.  Berikut ini beberapa yang keren: </p><br><pre> <code class="java hljs">((Object)System).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) Class.forName(<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span> as Class).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.<span class="hljs-function"><span class="hljs-function">exit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  dan masih <strong>banyak</strong> lagi.  Sifat dinamis Groovy menghalangi kemampuan untuk memperbaiki masalah ini pada waktu kompilasi.  Namun, solusinya memang ada.  Salah satu opsi adalah mengandalkan manajer keamanan JVM standar.  Namun, ini adalah solusi kelas berat dan banyak sekali untuk seluruh sistem, dan ini setara dengan menembakkan meriam ke burung pipit.  Selain itu, ini tidak berfungsi dalam semua kasus, misalnya, jika Anda ingin melarang membaca file, tetapi tidak membuat ... </p><br><p>  Keterbatasan ini - agak disesalkan bagi banyak dari kita - menyebabkan terciptanya solusi berdasarkan <strong>cek saat runtime</strong> .  Jenis cek ini tidak memiliki masalah seperti itu.  Misalnya, karena Anda akan mengetahui jenis penerima pesan yang sebenarnya sebelum memulai validasi panggilan metode.  Yang menarik adalah implementasi berikut: </p><br><ul><li>  <a href="">SecureScript</a> oleh Jim White </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Groovy Sandbox</a> oleh Kosuke Kawaguchi </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Groovy Sandbox</a> oleh Simon Temple </li></ul><br><p>  Namun, tidak satu pun dari implementasi ini yang sepenuhnya dapat diandalkan dan aman.  Sebagai contoh, versi Kosuke didasarkan pada peretasan implementasi internal situs panggilan caching.  Masalahnya adalah bahwa itu tidak kompatibel dengan versi Groovy invokedynamic, dan kelas-kelas batin ini tidak akan berada di versi Groovy masa depan.  Versi Simon, di sisi lain, didasarkan pada transformasi AST, tetapi meninggalkan banyak lubang potensial. </p><br><p>  Akibatnya, teman-teman saya Corinne Crisch, Fabrice Matrat dan Sebastian Blanc, dan saya memutuskan untuk membuat mekanisme sandboxing baru dalam runtime, yang tidak akan memiliki masalah seperti proyek-proyek ini.  Kami mulai menerapkannya di hackathon di Nice, dan pada konferensi Greach tahun lalu kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat laporan tentang hal itu</a> .  Mekanisme ini didasarkan pada transformasi AST dan pada dasarnya menulis ulang kode untuk diperiksa sebelum setiap pemanggilan metode, upaya untuk mengakses bidang kelas, menambahkan variabel, ekspresi biner ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi</a> ini masih belum siap, dan tidak banyak pekerjaan yang telah dilakukan di atasnya, jadi ketika saya menyadari bahwa masalah dengan metode dan parameter dipanggil melalui "implisit ini" belum diselesaikan, seperti, misalnya, dalam pembangun: </p><br><pre> <code class="plaintext hljs">xml { cars { // cars is a method call on an implicit this: "this".cars(...) car(make:'Renault', model: 'Clio') } }</code> </pre> <br><p>  Sampai saat ini, saya masih belum menemukan cara untuk memecahkan masalah ini karena arsitektur protokol meta-objek di Groovy, yang didasarkan pada kenyataan bahwa penerima melempar pengecualian ketika tidak dapat menemukan metode, sebelum beralih ke penerima lain.  Singkatnya, ini berarti bahwa Anda tidak dapat mengetahui jenis penerima sebelum panggilan metode yang sebenarnya.  Dan jika panggilan telah lewat, maka sudah terlambat ... </p><br><p>  Dan sampai saat ini, saya tidak memiliki solusi optimal untuk masalah ini untuk kasus di mana skrip yang dapat dieksekusi menggunakan sifat dinamis dari bahasa tersebut.  Tetapi sekaranglah saatnya untuk menjelaskan bagaimana Anda dapat memperbaiki situasi secara signifikan jika Anda bersedia mengorbankan sedikit kedinamisan bahasa tersebut. </p><br><h2 id="proverka-tipov">  Ketik memeriksa </h2><br><p>  Mari kita kembali ke masalah utama dengan SecureASTCustomizer: ini bekerja dengan pohon sintaksis abstrak dan tidak memiliki informasi tentang jenis dan penerima pesan tertentu.  Tetapi dengan Groovy 2, Groovy telah menambahkan kompilasi, dan di Groovy 2.1 kami telah menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi untuk pemeriksaan jenis</a> . </p><br><p>  Ekstensi untuk pengecekan tipe adalah hal yang sangat kuat: mereka memungkinkan pengembang DSL Groovy untuk membantu kompiler dengan inferensi tipe, dan juga memungkinkan generasi kesalahan kompilasi dalam kasus di mana mereka biasanya tidak terjadi.  Ekstensi ini digunakan secara internal oleh Groovy untuk mendukung kompiler statis, misalnya, ketika menerapkan sifat atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin templat markup</a> . </p><br><p>  Bagaimana jika, alih-alih menggunakan hasil parser, kita dapat mengandalkan informasi dari mekanisme pengecekan tipe?  Ambil kode yang coba ditulis oleh peretas kami: </p><br><p> <code>((Object)System).exit(-1)</code> </p> <br><p>  Jika Anda mengaktifkan pemeriksaan tipe, kode tidak dapat dikompilasi: </p><br><pre> <code class="plaintext hljs">1 compilation error: [Static type checking] - Cannot find matching method java.lang.Object#exit(java.lang.Integer). Please check if the declared type is right and if the method exists.</code> </pre> <br><p>  Jadi kode ini tidak lagi dikompilasi.  Dan bagaimana jika kita mengambil kode ini: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Seperti yang Anda lihat, ini melewati pemeriksaan tipe, dibungkus dengan metode dan dieksekusi menggunakan perintah <code>groovy</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@groovy</span></span>.transform.TypeChecked <span class="hljs-comment"><span class="hljs-comment">// or even @CompileStatic void foo() { def c = System c.exit(-1) } foo()</span></span></code> </pre> <br><p>  Pemeriksa tipe mendeteksi bahwa metode <code>exit</code> dipanggil dari kelas <code>System</code> dan valid.  Ini tidak akan membantu kami di sini.  Tetapi yang kita tahu adalah bahwa jika kode ini melewati pemeriksaan tipe, itu berarti bahwa kompiler mengenali panggilan ke penerima dengan tipe <code>System</code> .  Secara umum, idenya adalah untuk melarang panggilan dengan ekstensi untuk pemeriksaan tipe. </p><br><h2 id="prostoe-rasshirenie-dlya-proverki-tipov">  Ekstensi sederhana untuk pemeriksaan jenis </h2><br><p>  Sebelum mempelajari lebih lanjut tentang sandboxing, mari kita coba "mengamankan" skrip kami dengan bantuan ekstensi standar untuk pemeriksaan jenis.  Mendaftarkan ekstensi semacam itu mudah: cukup atur parameter <code>extensions</code> untuk penjelasan <code>@TypeChecked</code> (atau <code>@CompileStatic</code> jika Anda menggunakan kompilasi statis): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TypeChecked</span></span>(extensions=[<span class="hljs-string"><span class="hljs-string">'SecureExtension1.groovy'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) } foo()</code> </pre> <br><p>  Pencarian ekstensi akan berlangsung di classpath dalam format kode sumber (Anda dapat membuat ekstensi yang telah dikompilasi untuk pemeriksaan tipe, tetapi kami tidak akan mempertimbangkannya dalam artikel ini): </p><br><p> <code>SecureExtension1.groovy</code> </p> <br><pre> <code class="java hljs">onMethodSelection { expr, methodNode -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodNode.declaringClass.name==<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"Method call is not allowed!"</span></span>, expr) } }</code> </pre> <br><ol><li>  ketika pemeriksa tipe memilih metode untuk memanggil </li><li>  jika metode milik <code>System</code> kelas </li><li>  kemudian biarkan pemeriksa ketik menghasilkan kesalahan </li></ol><br><p>  Itu saja yang Anda butuhkan.  Sekarang jalankan kode lagi dan Anda akan melihat kesalahan kompilasi! </p><br><pre> <code class="plaintext hljs">/home/cchampeau/tmp/securetest.groovy: 6: [Static type checking] - Method call is not allowed! @ line 6, column 3. c.exit(-1) ^ 1 error</code> </pre> <br><p>  Kali ini, berkat type checker, <code>c</code> diakui sebagai turunan dari kelas <code>System</code> , dan kami dapat melarang panggilan.  Ini adalah contoh yang sangat sederhana, dan tidak menunjukkan semua yang dapat dilakukan dengan penyesuai AST aman dalam hal konfigurasi.  Dalam ekstensi yang kami <strong>tulis</strong> , cek di- <strong>hardcode</strong> , tetapi mungkin lebih baik membuatnya disesuaikan.  Jadi mari kita buat contoh lebih rumit. </p><br><p>  Misalkan aplikasi Anda menghitung metrik tertentu untuk dokumen dan memungkinkan pengguna untuk menyesuaikannya.  Dalam hal ini, DSL: </p><br><ul><li>  akan mengoperasikan (setidaknya) variabel <code>score</code> </li><li>  memungkinkan pengguna untuk melakukan operasi matematika (termasuk memanggil metode <em>cos</em> , <em>abs</em> , ...) </li><li>  harus melarang semua metode lain </li></ul><br><p>  Contoh skrip pengguna: </p><br><p> <code>abs(cos(1+score))</code> </p> <br><p>  DSL ini mudah dikonfigurasi.  Ini adalah varian dari apa yang kami definisikan di atas: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs">CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding,conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score))"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore);</code> </pre> <br><ol><li>  tambahkan importizer yang akan menambahkan <code>import static java.lang.Math.*</code> ke semua skrip </li><li>  buat variabel <code>score</code> tersedia untuk skrip </li><li>  jalankan skrip </li></ol><br><p>  <em>Ada beberapa cara untuk men-cache skrip alih-alih menguraikan dan mengompilasinya setiap kali.</em>  <em>Lihat dokumentasi untuk detailnya.</em> </p><br><p>  Jadi, skrip kami berfungsi, tetapi tidak ada yang mencegah peretas meluncurkan kode berbahaya.  Karena kami berencana untuk menggunakan pengecekan tipe, saya akan merekomendasikan menggunakan transformasi <code>@CompileStatic</code> : </p><br><ul><li>  itu mengaktifkan pemeriksaan jenis dalam skrip, dan kami akan dapat melakukan pemeriksaan tambahan berkat ekstensi untuk pemeriksaan jenis </li><li>  meningkatkan kinerja skrip </li></ul><br><p>  Menambahkan anotasi <code>@CompileStatic</code> ke skrip Anda secara tersirat cukup sederhana.  Anda hanya perlu memperbarui konfigurasi kompiler: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer(CompileStatic.class); conf.addCompilationCustomizers(astcz);</code> </pre> <br><p>  Sekarang jika Anda mencoba menjalankan skrip lagi, Anda akan melihat kesalahan kompilasi: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - The variable [score] is undeclared. @ line 1, column 11. abs(cos(1+score)) ^ Script1.groovy: 1: [Static type checking] - Cannot find matching method int#plus(java.lang.Object). Please check if the declared type is right and if the method exists. @ line 1, column 9. abs(cos(1+score)) ^ 2 errors</code> </pre> <br><p>  Apa yang terjadi  Jika Anda membaca skrip dari sudut pandang kompiler, menjadi jelas bahwa dia tidak tahu apa-apa tentang variabel "skor".  Tetapi <strong>Anda,</strong> sebagai pengembang, tahu bahwa ini adalah variabel <code>double</code> , tetapi kompiler tidak dapat menampilkannya.  Untuk ini, ekstensi untuk pemeriksaan jenis dibuat: Anda dapat memberikan informasi tambahan kepada kompiler, dan kompilasi akan berfungsi dengan baik.  Dalam hal ini, kita perlu menunjukkan bahwa variabel <code>score</code> bertipe <code>double</code> . </p><br><p>  Oleh karena itu, Anda dapat sedikit mengubah cara anotasi <code>@CompileStatic</code> : </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension2.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Ini "mengemulasi" kode yang dianotasi oleh <code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code> .  Sekarang, tentu saja, kita perlu menulis ekstensi yang akan mengenali variabel <code>score</code> : </p><br><p> <code>SecureExtension2.groovy</code> </p> <br><pre> <code class="java hljs">unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name==<span class="hljs-string"><span class="hljs-string">'score'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, double_TYPE) } }</code> </pre> <br><ol><li>  dalam pemeriksa tipe kasus tidak dapat menentukan variabel </li><li>  jika nama variabel adalah <code>score</code> </li><li>  biarkan kompiler mendefinisikan variabel secara dinamis dengan tipe <code>double</code> </li></ol><br><p>  Deskripsi lengkap ekstensi DSL untuk pemeriksaan jenis dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di bagian dokumentasi ini</a> , tetapi ada contoh mode kompilasi gabungan: kompilator tidak dapat menentukan variabel <code>score</code> .  Anda, sebagai pengembang DSL, <strong>tahu</strong> bahwa variabel itu sebenarnya jenisnya - <code>double</code> , jadi panggilan untuk membuat <code>makeDynamic</code> sini untuk mengatakan: "ok, jangan khawatir, saya tahu apa yang saya lakukan, variabel ini dapat didefinisikan secara dinamis dengan jenis <code>double</code> "  Itu saja! </p><br><h2 id="pervoe-zavershennoe-secure-rasshirenie">  Ekstensi "aman" pertama selesai </h2><br><p>  Sekarang mari kita kumpulkan semuanya.  Kami menulis satu ekstensi pengecekan tipe yang mencegah panggilan ke metode kelas <code>System</code> di satu sisi dan yang lain yang mendefinisikan variabel <code>score</code> di sisi lain.  Jadi, jika kita menghubungkannya, kita mendapatkan ekstensi penuh pertama untuk pemeriksaan tipe: </p><br><p> <code>SecureExtension3.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// disallow calls on System onMethodSelection { expr, methodNode -&gt; if (methodNode.declaringClass.name=='java.lang.System') { addStaticTypeError("Method call is not allowed!", expr) } } // resolve the score variable unresolvedVariable { var -&gt; if (var.name=='score') { return makeDynamic(var, double_TYPE) } }</span></span></code> </pre> <br><p>  Ingatlah untuk memperbarui konfigurasi di kelas Java Anda untuk menggunakan ekstensi baru untuk pemeriksaan tipe: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension3.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Jalankan kode lagi - masih berfungsi.  Sekarang coba ini: </p><br><pre> <code class="plaintext hljs">abs(cos(1+score)) System.exit(-1)</code> </pre> <br><p>  Kompilasi skrip akan macet dengan kesalahan: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - Method call is not allowed! @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p>  Selamat, Anda baru saja menulis ekstensi pengecekan tipe pertama yang mencegah kode berbahaya berjalan! </p><br><h2 id="uluchshenie-konfiguracii-rasshireniya">  Konfigurasi ekstensi yang ditingkatkan </h2><br><p>  Jadi, semuanya berjalan dengan baik, kita dapat melarang panggilan ke metode kelas <code>System</code> , tetapi tampaknya kerentanan baru akan segera ditemukan, dan kita perlu mencegah peluncuran kode berbahaya.  Jadi, alih-alih hardcode semua yang ada di ekstensi, kami akan mencoba membuat ekstensi kami universal dan dapat disesuaikan.  Ini mungkin yang paling sulit, karena tidak ada cara langsung untuk meneruskan konteks ke ekstensi untuk pemeriksaan tipe.  Gagasannya, oleh karena itu, didasarkan pada penggunaan variabel lokal thread (metode kurva, ya) untuk meneruskan data konfigurasi ke tipe checker. </p><br><p>  Pertama-tama, kita akan membuat daftar variabel yang dapat disesuaikan.  Ini akan menjadi seperti apa kode Java: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String VAR_TYPES = <span class="hljs-string"><span class="hljs-string">"sandboxing.variable.types"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocal&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension4.groovy"</span></span>)), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Map&lt;String,ClassNode&gt; variableTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, ClassNode&gt;(); variableTypes.put(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Object&gt;(); options.put(VAR_TYPES, variableTypes); COMPILE_OPTIONS.set(options); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score));System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { COMPILE_OPTIONS.remove(); } } }</code> </pre> <br><ol><li>  <code>ThreadLocal</code> ,          </li><li>    — <code>SecureExtension4.groovy</code> </li><li> <code>variableTypes</code> —   “  →  ” </li><li>      <code>score</code> </li><li> <code>options</code> —     </li><li>   "variable types"     VAR_TYPES </li><li>     thread local </li><li> ,    ,     thread local </li></ol><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>        thread local </li><li>      ,      , </li><li>   type checker       </li></ol><br><p>         thread local,    ,  type checker  . ,      <code>unresolvedVariable</code> ,    ,  ,    type checker,   .  ,     .   ! </p><br><p>           .        ,       . </p><br><h2 id="konfiguraciya-belogo-spiska-metodov">     </h2><br><p>    .   ,       .      ,         ,     . ,  <code>System.exit</code> ,   : </p><br><pre> <code class="plaintext hljs">java.lang.System#exit(int)</code> </pre> <br><p> ,     Java,    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WHITELIST_PATTERNS = <span class="hljs-string"><span class="hljs-string">"sandboxing.whitelist.patterns"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... public static void main(String[] args) { // ... try { Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); patterns.add("java\\.lang\\.Math#"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><ol><li>    </li><li>    <code>java.lang.Math</code>   </li><li>        </li></ol><br><p>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!whiteList.any { descr =~ it }) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"You tried to call a method which is not allowed, what did you expect?: $descr"</span></span>, expr) } } unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>       <code>MethodNode</code> </li><li>     thread local </li><li>       </li><li>        ,   </li></ol><br><p>      ,    : </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - You tried to call a method which is not allowed, what did you expect?: java.lang.System#exit(int) @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p> ,  !        ,   <strong>  </strong> , <strong>  </strong>  .    ,      !     ,       ,       . ,   (  <code>foo.text</code> ,     <code>foo.getText()</code> ). </p><br><h2 id="sobiraem-vse-vmeste">    </h2><br><p>     ,    type checker'    "property selection", ,   .      ,         ,  .         ,     ,       —    .     . </p><br><p> <code>SandboxingTypeCheckingExtension.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassCodeVisitorSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.expr.PropertyExpression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.control.SourceUnit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SandboxingTypeCheckingExtension</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyTypeCheckingExtensionSupport</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeCheckingDSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Fetch white list of regular expressions of authorized method calls def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) if (!whiteList.any { descr =~ it }) { addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr) } } unresolvedVariable { var -&gt; if (isDynamic(var) &amp;&amp; typesOfVariables[var.name]) { storeType(var, typesOfVariables[var.name]) handled = true } } // handling properties (like foo.text) is harder because the type checking extension // does not provide a specific hook for this. Harder, but not impossible! afterVisitMethod { methodNode -&gt; def visitor = new PropertyExpressionChecker(context.source, whiteList) visitor.visitMethod(methodNode) } } private class PropertyExpressionChecker extends ClassCodeVisitorSupport { private final SourceUnit unit private final List&lt;String&gt; whiteList PropertyExpressionChecker(final SourceUnit unit, final List&lt;String&gt; whiteList) { this.unit = unit this.whiteList = whiteList } @Override protected SourceUnit getSourceUnit() { unit } @Override void visitPropertyExpression(final PropertyExpression expression) { super.visitPropertyExpression(expression) ClassNode owner = expression.objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER) if (owner) { if (expression.spreadSafe &amp;&amp; StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(owner, classNodeFor(Collection))) { owner = typeCheckingVisitor.inferComponentType(owner, ClassHelper.int_TYPE) } def descr = "${prettyPrint(owner)}#${expression.propertyAsString}" if (!whiteList.any { descr =~ it }) { addStaticTypeError("Property is not allowed: $descr", expression) } } } } }```     sandbox',     assert' ,  ,     : ``Sandbox.java`` ```java public class Sandbox { public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns"; public static final String VAR_TYPES = "sandboxing.variable.types"; public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;(); public static void main(String[] args) { CompilerConfiguration conf = new CompilerConfiguration(); ImportCustomizer customizer = new ImportCustomizer(); customizer.addStaticStars("java.lang.Math"); ASTTransformationCustomizer astcz = new ASTTransformationCustomizer( singletonMap("extensions", singletonList("SandboxingTypeCheckingExtension.groovy")), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = new Binding(); binding.setVariable("score", 2.0d); try { Map&lt;String, ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); // allow method calls on Math patterns.add("java\\.lang\\.Math#"); // allow constructors calls on File patterns.add("File#&lt;init&gt;"); // because we let the user call each/times/... patterns.add("org\\.codehaus\\.groovy\\.runtime\\.DefaultGroovyMethods"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Object result; try { result = shell.evaluate("Eval.me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("System.exit(-1)"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("((Object)Eval).me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').getText()"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').text"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } Double userScore = (Double) shell.evaluate("abs(cos(1+score))"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>      Groovy       JVM.        ,      . ,    ,    ,      .  ,    Groovy,      sandboxing'          (,       ,   ). </p><br><p>  ,            ,          .      ,            .  ,      ,        . </p><br><p>    ,   sandboxing',   , —  <strong></strong>  <code>SecureASTCustomizer</code> .    <strong> ,  </strong> ,       : secure AST customizer    ,      (,       ),              (   ,   ). </p><br><p> ,    : ,   , .   Groovy   .          Groovy,   ,  -      pull request,      -  ! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445114/">https://habr.com/ru/post/id445114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445104/index.html">Sejarah singkat merek audio Klipsch</a></li>
<li><a href="../id445106/index.html">Round table: Teknologi aditif sebagai alternatif untuk manufaktur tradisional</a></li>
<li><a href="../id445108/index.html">Tidak satu pun Falcon - proyek ESA dan ULA yang dapat digunakan kembali yang berbeda secara fundamental</a></li>
<li><a href="../id445110/index.html">Komputer dengan drive terminal gaya Fallout</a></li>
<li><a href="../id445112/index.html">Mengurai kusut kerentanan di situs</a></li>
<li><a href="../id445116/index.html">Angkatan Udara AS bekerja pada drone AI yang disebut Skyborg</a></li>
<li><a href="../id445118/index.html">Dalam obrolan Telegram pribadi, Anda dapat menghapus semua pesan - bahkan orang asing (hasil pemungutan suara telah ditambahkan)</a></li>
<li><a href="../id445120/index.html">Frontend Weekly Digest (18 - 24 Mar 2019)</a></li>
<li><a href="../id445122/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 357 (18 - 24 Maret 2019)</a></li>
<li><a href="../id445124/index.html">Pengerasan Sedang untuk Firefox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>