<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèê üéë üíé Sedikit tentang pemrograman ESP8266 di C di bawah FreeRTOS ü•¶ üê® ü¶à</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seharusnya ada CAP, tetapi tidak ada anggaran yang cukup untuk itu. 

 Termotivasi oleh tanggapan dari Tarson terhadap komentar saya tentang Pemrogram...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sedikit tentang pemrograman ESP8266 di C di bawah FreeRTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406813/"> <i><b>Seharusnya ada CAP, tetapi tidak ada anggaran yang cukup untuk itu.</b></i> <br><br>  Termotivasi oleh tanggapan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Tarson</a> terhadap komentar saya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman dan pertukaran data dengan ARDUINO melalui WIFI melalui ESP8266</a> , saya memutuskan untuk menulis tentang dasar-dasar pemrograman ESP8266 dalam C di bawah FreeRTOS.  Detail di bawah potongan. <br><a name="habracut"></a><br>  <b>Langkah 0 - perangkat</b> <br><br>  Pertama Anda perlu mendapatkan perangkat dengan ESP8266, diinginkan bahwa USB ke UART dipisahkan di sana, sehingga Anda tidak perlu mematikan pemrogram.  Saya menghabiskan eksperimen tidak manusiawi saya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NodeMCU</a> . <br><br>  <b>Jadi, langkah 1 - kumpulkan toolchain</b> <br><br>  Pertama, Anda perlu mendapatkan komputer dengan distribusi Linux diinstal di atasnya (Saya memiliki OpenSUSE Leap).  Kami pergi ke github di tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tyts</a> , membaca instruksi perakitan, menginstal dependensi yang diperlukan, mengkloning repositori, dan mengumpulkan.  Saya kloning di / opt / ESP dan sebelum merakit aturan Makefile, mengatur variabel: <br><br><pre><code class="bash hljs">STANDALONE = n VENDOR_SDK = 2.1.0</code> </pre> <br>  Selanjutnya, Anda bisa menambahkan path ke binary toolchain di PATH di ~ / .bashrc: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=/opt/ESP/esp-open-sdk/xtensa-lx106-elf/bin:<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span></code> </pre><br>  <b>Langkah 2 - dapatkan SDK</b> <br><br>  Kami pergi ke github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tynk</a> ), membaca instruksi, mengkloning (misalnya di / opt / ESP).  Selanjutnya, kita menetapkan variabel lingkungan ESP8266_SDK_PATH dengan cara favorit kami (misalnya, melalui ~ / .bashrc): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ESP8266_SDK_PATH=/opt/ESP/esp-open-rtos</code> </pre><br>  <b>Langkah 3 - buat proyek</b> <br><br>  Kami pergi ke direktori contoh di direktori dengan SDK dan menyalin contoh yang Anda suka.  Kami mengimpor / membuka proyek di lingkungan pengembangan favorit kami, masokis dapat menggunakan editor teks.  Saya lebih suka NetBeans - ini memiliki dukungan yang baik untuk proyek C / C ++, termasuk yang didasarkan pada Makefile.  Proyek ini dirakit menggunakan make, ini di-flash menggunakan make flash.  Dalam file local.mk, Anda dapat mengonfigurasi parameter untuk mem-flash perangkat Anda (ukuran dan mode mengakses memori flash, misalnya). <br><br>  <b>Langkah 4 - Pemrograman</b> <br><br>  Kami menganalisis persyaratan, area subjek, menyusun spesifikasi teknis sesuai dengan GOST 34.602-89, setelah itu Anda dapat mulai menulis kode :) Saya tidak akan berkedip LED, karena saya tidak memilikinya, jadi sebagai HelloWorld saya akan membaca data dari sensor AM2302 (itu adalah DHT22) dan mengirimkannya melalui protokol MQTT ke server. <br><br>  Untuk menggunakan modul tambahan, misalnya MQTT atau DHT, mereka harus ditambahkan ke Makefile: <br><br><pre> <code class="hljs ruby">PROGRAM=fffmeteo EXTRA_COMPONENTS = extras/paho_mqtt_c extras/dht <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $(ESP8266_SDK_PATH)/common.mk</code> </pre><br><div class="spoiler">  <b class="spoiler_title">main.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;limits.h&gt; #include &lt;FreeRTOS.h&gt; #include &lt;task.h&gt; #include &lt;queue.h&gt; #include &lt;semphr.h&gt; #define DEBUG #ifdef DEBUG #define debug(args...) printf("--- "); printf(args) #define SNTP_DEBUG_ENABLED true #else #define debug(args...) #define SNTP_DEBUG_ENABLED false #endif #define WIFI_SSID "kosmonaFFFt" #define WIFI_PASS "mysupermegapassword" #define MQTT_HOST "m11.cloudmqtt.com" #define MQTT_PORT 16464 #define MQTT_USER "kosmonaFFFt" #define MQTT_PASS "mysupermegapassword" #define MQTT_TOPIC "/meteo" #define NTP_SERVER "pool.ntp.org" #define UART0_BAUD 9600 #define STACK_SIZE 512 #define INIT_TASK_PRIORITY (configTIMER_TASK_PRIORITY + 1) #define MEASUREMENT_TASK_PRIORITY (INIT_TASK_PRIORITY + 1) #define SENDING_DATA_TASK_PRIORITY (MEASUREMENT_TASK_PRIORITY + 1) #define MEASUREMENTS_PERIOD_S 59 #define MAX_MEASUREMENTS_COUNT 16 #define SEND_PERIOD_S 120 #define RUN_SNTP_SYNC_PERIOD 5 #define MS(x) (x / portTICK_PERIOD_MS) #define AM2302_PIN 5 #ifdef __cplusplus extern "C" { #endif #ifdef __cplusplus } #endif #endif /* MAIN_H */</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sntp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;esp/uart.h&gt; #include &lt;espressif/esp_common.h&gt; #include &lt;paho_mqtt_c/MQTTESP8266.h&gt; #include &lt;paho_mqtt_c/MQTTClient.h&gt; #include &lt;dht/dht.h&gt; //-----------------------------------------------------------------------------+ // Measurements task section. | //-----------------------------------------------------------------------------+ struct measurement_results { time_t timestamp; int am2302_humidity; int am2302_temperature; }; static QueueHandle_t measurements_queue; void measurement_task(void *arg) { int16_t humidity; int16_t temperature; struct measurement_results measurements; while (true) { debug("MEASUREMENTS: Start measurements...\n"); measurements.timestamp = time(NULL); bool success = dht_read_data(DHT_TYPE_DHT22, AM2302_PIN, &amp;humidity, &amp;temperature); if (success &amp;&amp; temperature &gt;= -500 &amp;&amp; temperature &lt;= 1500 &amp;&amp; humidity &gt;= 0 &amp;&amp; humidity &lt;= 1000) { measurements.am2302_humidity = humidity; measurements.am2302_temperature = temperature; } else { debug("MEASUREMENT: Error! Cannot read data from AM2302!!!\n"); measurements.am2302_humidity = INT_MIN; measurements.am2302_temperature = INT_MIN; } debug("MEASUREMENTS: Measurements finished...\n"); xQueueSendToBack(measurements_queue, &amp;measurements, MS(250)); vTaskDelay(MS(MEASUREMENTS_PERIOD_S * 1000)); } vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Sending data task section. | //-----------------------------------------------------------------------------+ static uint8_t mqtt_buf[512]; static uint8_t mqtt_readbuf[128]; void sending_data_task(void *arg) { mqtt_network_t network; mqtt_network_new(&amp;network); mqtt_client_t client = mqtt_client_default; mqtt_packet_connect_data_t data = mqtt_packet_connect_data_initializer; uint8_t sntp_sync_counter = 0; while (true) { debug("MQTT: ConnectNetwork...\n"); int err = mqtt_network_connect(&amp;network, MQTT_HOST, MQTT_PORT); if (err) { debug("MQTT: Error!!! ConnectNetwork ERROR!\n"); vTaskDelay(MS(5 * 1000)); continue; } else { debug("MQTT: ConnectNetwork success...\n"); } // TODO: add check for errors!!! // TODO: replace magic constants!!! mqtt_client_new(&amp;client, &amp;network, 5000, mqtt_buf, 100, mqtt_readbuf, 100); data.willFlag = 0; data.MQTTVersion = 3; data.clientID.cstring = "fff"; data.username.cstring = MQTT_USER; data.password.cstring = MQTT_PASS; data.keepAliveInterval = 10; data.cleansession = 0; err = mqtt_connect(&amp;client, &amp;data); if (err) { debug("MQTT: Error!!! MQTTConnect ERROR!\n"); vTaskDelay(MS(5 * 1000)); continue; } else { debug("MQTT: MQTTConnect success...\n"); } struct measurement_results msg; while (xQueueReceive(measurements_queue, &amp;msg, 0) == pdTRUE) { if (msg.am2302_humidity == INT_MIN || msg.am2302_temperature == INT_MIN) { debug("MQTT: Got invalid message, no publishing!!!\n"); continue; } debug("MQTT: Got message to publish...\n"); debug(" timestamp: %ld\n", msg.timestamp); debug(" am2302_humidity: %.1f\n", msg.am2302_humidity / 10.0); debug(" am2302_temperature: %.1f\n", msg.am2302_temperature / 10.0); msg.timestamp = htonl(msg.timestamp); msg.am2302_humidity = htonl(msg.am2302_humidity); msg.am2302_temperature = htonl(msg.am2302_temperature); mqtt_message_t message; message.payload = &amp;msg; message.payloadlen = sizeof (msg); message.dup = 0; message.qos = MQTT_QOS1; message.retained = 0; err = mqtt_publish(&amp;client, MQTT_TOPIC, &amp;message); if (err) { debug("MQTT: Error!!! Error while publishing message!\n"); } else { debug("MQTT: Successfully publish message...\n"); } } mqtt_disconnect(&amp;client); mqtt_network_disconnect(&amp;network); ++sntp_sync_counter; if (sntp_sync_counter == RUN_SNTP_SYNC_PERIOD) { sntp_sync(NTP_SERVER, NULL, arg); sntp_sync_counter = 0; } vTaskDelay(MS(SEND_PERIOD_S * 1000)); } vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Init task section. | //-----------------------------------------------------------------------------+ /** * This semaphore is taken during sntp sync and released after it finished. */ static SemaphoreHandle_t init_task_sem; /** * Set time and free init task semaphore. * @param error unused * @param arg unused */ void init_sntp_callback(int8_t error, void* arg) { time_t ts = time(NULL); debug("TIME: %s", ctime(&amp;ts)); xSemaphoreGive(init_task_sem); } /** * Connection parameters. */ static struct sdk_station_config STATION_CONFIG = { .ssid = WIFI_SSID, .password = WIFI_PASS, }; void init_task(void* arg) { debug("INIT: setting pins...\n"); gpio_set_pullup(AM2302_PIN, false, false); debug("INIT: Set station parameters...\n"); sdk_wifi_station_set_auto_connect(false); sdk_wifi_station_set_config(&amp;STATION_CONFIG); debug("Station parameters has been set.\n"); debug("INIT: Connecting to AP...\n"); sdk_wifi_station_connect(); while (sdk_wifi_station_get_connect_status() != STATION_GOT_IP) { vTaskDelay(MS(1000)); } debug("INIT: Connection to AP has been estabilished...\n"); debug("INIT: Start SNTP synchronization...\n"); init_task_sem = xSemaphoreCreateMutex(); if (!init_task_sem) { debug("INIT: Cannot create init task semaphore!!!"); return; } xSemaphoreTake(init_task_sem, 0); sntp_init(); sntp_sync(NTP_SERVER, init_sntp_callback, arg); BaseType_t result = pdFALSE; while (true) { debug("INIT: Trying to take init task semaphore...\n"); result = xSemaphoreTake(init_task_sem, MS(5 * 1000)); if (result == pdTRUE) { debug("INIT: Init task semaphore is taken...\n"); break; } } measurements_queue = xQueueCreate(MAX_MEASUREMENTS_COUNT, sizeof (struct measurement_results)); if (!measurements_queue) { debug("INIT: ERROR!!! Cannot create queue for measurements!\n"); goto fail; } result = xTaskCreate(measurement_task, "measurement_task", STACK_SIZE, NULL, MEASUREMENT_TASK_PRIORITY, NULL); if (result == pdFAIL) { debug("INIT: Measurement task creation failed!!!\n"); goto fail; } debug("INIT: Measurement task created...\n"); result = xTaskCreate(sending_data_task, "send_data_task", STACK_SIZE, NULL, SENDING_DATA_TASK_PRIORITY, NULL); if (result == pdFAIL) { debug("INIT: Send task creation failed!!!\n"); goto fail; } debug("INIT: Send data task created...\n"); fail: vSemaphoreDelete(init_task_sem); vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Application entry point. | //-----------------------------------------------------------------------------+ void user_init(void) { debug("USER_INIT: SDK version: %s\n", sdk_system_get_sdk_version()); debug("USER_INIT: sizeof (int): %d\n", sizeof (int)); debug("USER_INIT: sizeof (float): %d\n", sizeof (float)); debug("USER_INIT: sizeof (time_t): %d\n", sizeof (time_t)); uart_set_baud(0, UART0_BAUD); BaseType_t result = xTaskCreate(init_task, (const char * const) "init_task", STACK_SIZE, NULL, INIT_TASK_PRIORITY, NULL); if (!result) { debug("USER_INIT: Cannot create init task!!!"); return; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sntp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SNTP_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SNTP_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;time.h&gt; #include &lt;stdint.h&gt; #ifdef __cplusplus extern "C" { #endif #define SNTP_ERR_OK 0 #define SNTP_ERR_CONTEXT -1 #define SNTP_ERR_DNS -2 #define SNTP_ERR_UDP_PCB_ALLOC -3 #define SNTP_ERR_PBUF_ALLOC -4 #define SNTP_ERR_SEND -5 #define SNTP_ERR_RECV_ADDR_PORT -6; #define SNTP_ERR_RECV_SIZE -7 #define SNTP_ERR_RECV_MODE -8 #define SNTP_ERR_RECV_STRATUM -9 typedef void (*sntp_sync_callback)(int8_t error, void *arg); void sntp_init(); void sntp_sync(char *server, sntp_sync_callback callback, void *callback_arg); time_t sntp_get_rtc_time(int32_t *us); void sntp_update_rtc(time_t t, uint32_t us); #ifdef __cplusplus } #endif #endif /* SNTP_H */</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sntp.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sntp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;time.h&gt; #include &lt;string.h&gt; #include &lt;lwip/ip_addr.h&gt; #include &lt;lwip/err.h&gt; #include &lt;lwip/dns.h&gt; #include &lt;lwip/udp.h&gt; #include &lt;esp/rtc_regs.h&gt; #include &lt;espressif/esp_common.h&gt; #define TIMER_COUNT RTC.COUNTER /** * Daylight settings. * Base calculated with value obtained from NTP server (64 bits). */ #define SNTP_BASE (*((uint64_t*) RTC.SCRATCH)) /** * Timer value when base was obtained. */ #define SNTP_TIME_REF (RTC.SCRATCH[2]) /** * Calibration value. */ #define SNTP_CALIBRATION (RTC.SCRATCH[3]) /** * SNTP modes. */ #define SNTP_MODE_CLIENT 0x03 #define SNTP_MODE_SERVER 0x04 #define SNTP_MODE_BROADCAST 0x05 /** * Kiss-of-death code. */ #define SNTP_STRATUM_KOD 0x00 #define SNTP_OFFSET_LI_VN_MODE 0 #define SNTP_OFFSET_STRATUM 1 #define SNTP_OFFSET_RECEIVE_TIME 32 #define DIFF_SEC_1900_1970 (2208988800UL) struct sntp_message { uint8_t li_vn_mode; uint8_t stratum; uint8_t poll; uint8_t precision; uint32_t root_delay; uint32_t root_dispersion; uint32_t reference_identifier; uint32_t reference_timestamp[2]; uint32_t originate_timestamp[2]; uint32_t receive_timestamp[2]; uint32_t transmit_timestamp[2]; } __attribute__ ((packed)); struct sntp_sync_context { ip_addr_t ip_address; sntp_sync_callback callback; void* callback_arg; }; void sntp_init() { SNTP_BASE = 0; SNTP_CALIBRATION = 1; SNTP_TIME_REF = TIMER_COUNT; } void on_dns_found(const char* name, ip_addr_t* ipaddr, void* arg); void on_udp_recv(void* arg, struct udp_pcb* pcb, struct pbuf* p, ip_addr_t* addr, u16_t port); void sntp_sync(char* server, sntp_sync_callback callback, void* callback_arg) { int result = ERR_OK; debug("SNTP: Start SNTP synchronization, allocating memory for context...\n"); struct sntp_sync_context* context = malloc(sizeof (struct sntp_sync_context)); if (!context) { debug("SNTP: Error!!! Cannot allocate memory for context!\n"); result = SNTP_ERR_CONTEXT; goto fail; } context-&gt;callback = callback; context-&gt;callback_arg = callback_arg; debug("SNTP: Context successfully allocated...\n"); debug("SNTP: Start DNS lookup...\n"); err_t err = dns_gethostbyname(server, &amp;(context-&gt;ip_address), on_dns_found, context); if (!(err == ERR_OK || err == ERR_INPROGRESS)) { debug("SNTP: Error!!! DNS lookup error!\n"); result = SNTP_ERR_DNS; goto fail; } return; fail: if (context) { free(context); } if (callback) { callback(result, callback_arg); } } // //============================================================================================================================================================== // void on_dns_found(const char* name, ip_addr_t* ipaddr, void* arg) { debug("SNTP: Start DNS lookup successfully finished...\n"); int result = ERR_OK; struct sntp_sync_context* context = arg; sntp_sync_callback callback = context-&gt;callback; void* callback_arg = context-&gt;callback_arg; debug("SNTP: Creating upd_pcb...\n"); struct udp_pcb* sntp_pcb = udp_new(); if (!sntp_pcb) { debug("SNTP: Error!!! Cannot allocate udp_pcb!\n"); result = SNTP_ERR_UDP_PCB_ALLOC; goto fail; } debug("SNTP: Successfully created upd_pcb...\n"); debug("SNTP: Allocating pbuf...\n"); struct pbuf* p = pbuf_alloc(PBUF_TRANSPORT, sizeof (struct sntp_message), PBUF_RAM); if (!p) { debug("SNTP: Error!!! DNS lookup error!\n"); result = SNTP_ERR_PBUF_ALLOC; goto fail; } struct sntp_message* message = p-&gt;payload; memset(message, 0, sizeof (struct sntp_message)); message-&gt;li_vn_mode = 0b00100011; // li = 00, vn = 4, mode = 3 debug("SNTP: Pbuf allocated successfully...\n"); debug("SNTP: Sending data to server...\n"); udp_recv(sntp_pcb, on_udp_recv, context); err_t err = udp_sendto(sntp_pcb, p, ipaddr, 123); pbuf_free(p); if (err != ERR_OK) { debug("SNTP: Error!!! data sending error!\n"); result = SNTP_ERR_SEND; goto fail; } debug("SNTP: Data sent...\n"); return; fail: if (context) { free(context); } if (sntp_pcb) { udp_remove(sntp_pcb); } if (callback) { callback(result, callback_arg); } } void on_udp_recv(void* arg, struct udp_pcb* pcb, struct pbuf* p, ip_addr_t* addr, u16_t port) { debug("SNTP: Response has successfully received...\n"); int result = ERR_OK; struct sntp_sync_context* context = arg; sntp_sync_callback callback = context-&gt;callback; void* callback_arg = context-&gt;callback_arg; debug("SNTP: Checking response size...\n"); if (p-&gt;tot_len &lt; sizeof (struct sntp_message)) { debug("SNTP: Error!!! Invalid response size!\n"); result = SNTP_ERR_RECV_SIZE; goto fail; } debug("SNTP: Response size is OK...\n"); debug("SNTP: Checking mode...\n"); u8_t mode = 0x0; pbuf_copy_partial(p, &amp;mode, sizeof (mode), SNTP_OFFSET_LI_VN_MODE); mode &amp;= 0b00000111; if (mode != SNTP_MODE_SERVER &amp;&amp; mode != SNTP_MODE_BROADCAST) { debug("SNTP: Error!!! Invalid mode!\n"); result = SNTP_ERR_RECV_MODE; goto fail; } debug("SNTP: Mode is OK...\n"); debug("SNTP: Checking stratum...\n"); u8_t stratum = 0x0; pbuf_copy_partial(p, &amp;stratum, sizeof (stratum), SNTP_OFFSET_STRATUM); if (stratum == SNTP_STRATUM_KOD) { debug("SNTP: Error!!! Kiss of death!\n"); result = SNTP_ERR_RECV_STRATUM; goto fail; } debug("SNTP: Stratum is OK...\n"); debug("SNTP: Updating system timer...\n"); uint32_t receive_time[2]; pbuf_copy_partial(p, &amp;receive_time, 2 * sizeof (uint32_t), SNTP_OFFSET_RECEIVE_TIME); time_t t = ntohl(receive_time[0]) - DIFF_SEC_1900_1970; uint32_t us = ntohl(receive_time[1]) / 4295; sntp_update_rtc(t, us); debug("SNTP: System timer updated...\n"); fail: if (context) { free(context); } if (pcb) { udp_remove(pcb); } if (callback) { callback(result, callback_arg); } } /** * Check if a timer wrap has occurred. Compensate sntp_base reference * if affirmative. * TODO: think about multitasking and race conditions. */ inline void sntp_check_timer_wrap(uint32_t current_value) { if (current_value &lt; SNTP_TIME_REF) { // Timer wrap has occurred, compensate by subtracting 2^32 to ref. SNTP_BASE -= 1LLU &lt;&lt; 32; } } /** * Return secs. If us is not a null pointer, fill it with usecs */ time_t sntp_get_rtc_time(int32_t *us) { time_t secs; uint32_t tim; uint64_t base; tim = TIMER_COUNT; // Check for timer wrap. sntp_check_timer_wrap(tim); base = SNTP_BASE + tim - SNTP_TIME_REF; secs = base * SNTP_CALIBRATION / (1000000U &lt;&lt; 12); if (us) { *us = base * SNTP_CALIBRATION % (1000000U &lt;&lt; 12); } return secs; } /** * Update RTC timer. Called by SNTP module each time it receives an update. */ void sntp_update_rtc(time_t t, uint32_t us) { // Apply daylight and timezone correction // DEBUG: Compute and print drift int64_t sntp_current = SNTP_BASE + TIMER_COUNT - SNTP_TIME_REF; int64_t sntp_correct = (((uint64_t) us + (uint64_t) t * 1000000U) &lt;&lt; 12) / SNTP_CALIBRATION; debug("RTC Adjust: drift = %ld ticks, cal = %d\n", (time_t) (sntp_correct - sntp_current), SNTP_CALIBRATION); SNTP_TIME_REF = TIMER_COUNT; SNTP_CALIBRATION = sdk_system_rtc_clock_cali_proc(); SNTP_BASE = (((uint64_t) us + (uint64_t) t * 1000000U) &lt;&lt; 12) / SNTP_CALIBRATION; } /** * Syscall implementation. doesn't seem to use tzp. */ int _gettimeofday_r(struct _reent* r, struct timeval* tp, void* tzp) { // Syscall defined by xtensa newlib defines tzp as void* // So it looks like it is not used. Also check tp is not NULL if (tzp || !tp) { return EINVAL; } tp-&gt;tv_sec = sntp_get_rtc_time((int32_t*) &amp; tp-&gt;tv_usec); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Penyimpangan liris tentang ketersediaan kode sinkronisasi waktu Anda sendiri melalui SNTP: dalam ekstensi dari SDK sudah ada modul seperti itu, tetapi untuk beberapa alasan saya tidak menyukainya (dulu sekali, saya tidak ingat mengapa), jadi saya menyalin kode ini dengan kurang hati-hati dan memodifikasinya untuk saya sendiri. <br><br>  Semuanya berfungsi sederhana: ketika pengendali mulai, tugas inisialisasi dimulai, yang menghubungkan ke titik akses, menyinkronkan waktu melalui SNTP, memulai tugas mengukur suhu dengan kelembaban dan mengirim data ke server, setelah itu membunuh sendiri.  Tugas pengukuran menyurvei sensor sekali setiap 59 detik dan menempatkan hasilnya dalam antrian, tugas pengiriman dimulai setiap 2 menit, membaca data dari antrian dan mengirimkannya ke server MQTT. <br><br>  Secara teoritis, Anda dapat menulis dalam C ++. <br><br>  <b>Langkah 5 - kesimpulan, di mana tanpa dia</b> <br><br>  Sedemikian sederhananya, menggunakan bahasa C dan tangan dengan jari-jari kecil kelengkungan, Anda dapat memprogram pengontrol ESP8266.  Keuntungan utama dari pendekatan ini daripada solusi scripting (misalnya, LUA atau MicroPython) adalah kontrol penuh atas komposisi dan sumber daya dari firmware, dan kemampuan untuk menjejalkan lebih banyak fungsi dengan sumber daya pengontrol yang terbatas.  Ada juga opsi untuk menggunakan RTOS SDK atau NONOS SDK dari Espressif, tetapi saya tidak tumbuh bersama dengan yang pertama, dan saya tidak mencoba menggunakan yang kedua.  Jika seseorang tertarik, dan ketika saya mengetahuinya sendiri, saya dapat menulis tutorial berikut tentang OTA (pembaruan firmware melalui udara). <br><br>  Beberapa hasil kode ini: <br><br><div class="spoiler">  <b class="spoiler_title">Data diterima dari server MQTT dan diunggah ke database</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/db8/1b7/085/db81b70850ce4ef8afbb77536c57f973.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Debug controller knalpot di UART</b> <div class="spoiler_text"><pre> <code class="hljs delphi">SDK version: <span class="hljs-number"><span class="hljs-number">0.9</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span> --- USER_INIT: sizeof (int): <span class="hljs-number"><span class="hljs-number">4</span></span> --- USER_INIT: sizeof (float): <span class="hljs-number"><span class="hljs-number">4</span></span> --- USER_INIT: sizeof (time_t): <span class="hljs-number"><span class="hljs-number">4</span></span> mode : sta(<span class="hljs-number"><span class="hljs-number">18</span></span>:fe:<span class="hljs-number"><span class="hljs-number">34</span></span>:d2:c5:a7) add if0 --- INIT: setting pins... --- INIT: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> station parameters... --- Station parameters has been <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>. --- INIT: Connecting <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AP... scandone add <span class="hljs-number"><span class="hljs-number">0</span></span> aid <span class="hljs-number"><span class="hljs-number">2</span></span> cnt connected <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> kosmonaFFFt, channel <span class="hljs-number"><span class="hljs-number">1</span></span> dhcp client start... ip:<span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">1.21</span></span>,mask:<span class="hljs-number"><span class="hljs-number">255.255</span></span>.<span class="hljs-number"><span class="hljs-number">255.0</span></span>,gw:<span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">1.1</span></span> --- INIT: Connection <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AP has been estabilished... --- INIT: Start SNTP synchronization... --- SNTP: Start SNTP synchronization, allocating memory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> context... --- SNTP: Context successfully allocated... --- SNTP: Start DNS lookup... --- INIT: Trying <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> take init task semaphore... --- SNTP: Start DNS lookup successfully finished... --- SNTP: Creating upd_pcb... --- SNTP: Successfully created upd_pcb... --- SNTP: Allocating pbuf... --- SNTP: Pbuf allocated successfully... --- SNTP: Sending data <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> server... --- SNTP: Data sent... --- SNTP: Response has successfully received... --- SNTP: Checking response size... --- SNTP: Response size <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Checking mode... --- SNTP: Mode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Checking stratum... --- SNTP: Stratum <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Updating system timer... --- RTC Adjust: drift = <span class="hljs-number"><span class="hljs-number">1220897578</span></span> ticks, cal = <span class="hljs-number"><span class="hljs-number">1</span></span> --- SNTP: System timer updated... --- TIME: Thu Sep <span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span> --- INIT: Init task semaphore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> taken... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- INIT: Measurement task created... --- MQTT: ConnectNetwork... --- INIT: Send data task created... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021636</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">55.8</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">23.4</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021694</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">55.2</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">23.8</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021751</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">56.5</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.4</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021807</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">53.0</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.7</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021863</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">52.3</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.8</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021919</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">52.0</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.9</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021975</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">53.3</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">25.2</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>...</code> </pre> <br></div></div><br>  <b>PS Saya</b> sarankan menggunakan minicom (konsol), atau cutecom (GUI) untuk bekerja dengan UART pada PC. <br><br>  <b>Tautan yang bermanfaat:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API FreeRTOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan ESP RTOS SDK</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id406813/">https://habr.com/ru/post/id406813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id406803/index.html">Rossvyaz sedang menjajaki kemungkinan membuat basis data IMEI tunggal untuk telepon yang beroperasi di Federasi Rusia</a></li>
<li><a href="../id406805/index.html">Antarmuka otak-komputer bukan lagi fiksi ilmiah</a></li>
<li><a href="../id406807/index.html">Angkatan Laut AS memutuskan untuk menggunakan pengontrol Xbox 360 alih-alih remote $ 38.000 yang mahal</a></li>
<li><a href="../id406809/index.html">Pesawat Stratolaunch terbesar di dunia menguji mesin dan sistem bahan bakar</a></li>
<li><a href="../id406811/index.html">Bagaimana dunia rahasia untuk pelatihan robomobiles Waymo</a></li>
<li><a href="../id406815/index.html">Tidak, tidak mungkin untuk langsung merasa kasihan pada semua orang</a></li>
<li><a href="../id406817/index.html">Bisakah makhluk hidup seukuran galaksi?</a></li>
<li><a href="../id406819/index.html">Cara kerja tonase otomatis untuk gel bekerja</a></li>
<li><a href="../id406821/index.html">Membuat kertas dengan Epson PaperLab</a></li>
<li><a href="../id406823/index.html">Simetri C, P, T (dan kombinasi keduanya)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>