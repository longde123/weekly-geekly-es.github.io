<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üìâ üë©üèº‚Äçüíº Kotlin: cavando m√°s profundo. Constructores e inicializadores üõ§Ô∏è üö¥üèª üêä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mayo de 2017, Google anunci√≥ que Kotlin se hab√≠a convertido en el lenguaje de desarrollo oficial para Android. Luego, alguien escuch√≥ el nombre de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: cavando m√°s profundo. Constructores e inicializadores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/425943/"><img src="https://habrastorage.org/webt/fy/cu/i6/fycui6wsj3p54nc1y7v5ga_hfdq.jpeg"><br><br>  En mayo de 2017, Google anunci√≥ que Kotlin se hab√≠a convertido en el lenguaje de desarrollo oficial para Android.  Luego, alguien escuch√≥ el nombre de este idioma por primera vez, alguien escribi√≥ sobre √©l durante mucho tiempo, pero a partir de ese momento qued√≥ claro que todos los que est√°n cerca del desarrollo de Android ahora simplemente est√°n obligados a conocerlo.  Esto fue seguido por respuestas entusiastas "¬°Finalmente!" Y terrible indignaci√≥n "¬øPor qu√© necesitamos un nuevo idioma?"  ¬øQu√© no hizo Java, por favor?  etc.  etc. <br><br>  Ha pasado suficiente tiempo desde entonces, y aunque el debate sobre si Kotlin es bueno o malo todav√≠a no ha disminuido, cada vez se escribe m√°s c√≥digo para Android.  E incluso los desarrolladores bastante conservadores tambi√©n se est√°n cambiando.  Adem√°s, en la red puede tropezar con la informaci√≥n de que la velocidad de desarrollo despu√©s de dominar este lenguaje aumenta en un 30% en comparaci√≥n con Java. <br><br>  Hoy, Kotlin ya ha logrado recuperarse de varias enfermedades infantiles, con muchas preguntas y respuestas sobre Stack Overflow.  A simple vista, tanto sus ventajas como sus debilidades se hicieron visibles. <br><br>  Y en esta ola, se me ocurri√≥ la idea de analizar en detalle los elementos individuales de un lenguaje joven pero popular.  Preste atenci√≥n a puntos complejos y comp√°relos con Java para mayor claridad y mejor comprensi√≥n.  Para entender la pregunta un poco m√°s profundo que esto se puede hacer leyendo la documentaci√≥n.  Si este art√≠culo despierta inter√©s, lo m√°s probable es que sentar√° las bases para toda una serie de art√≠culos.  Mientras tanto, comenzar√© con cosas bastante b√°sicas, que, sin embargo, esconden muchas trampas.  Hablemos de constructores e inicializadores en Kotlin. <a name="habracut"></a><br><br>  Como en Java, en Kotlin, la creaci√≥n de nuevos objetos, entidades de cierto tipo, se produce llamando al constructor de la clase.  Tambi√©n puede pasar argumentos al constructor, y puede haber varios constructores.  Si observa este proceso desde afuera, la √∫nica diferencia con respecto a Java es la falta de la nueva palabra clave cuando se llama al constructor.  Ahora eche un vistazo m√°s profundo y vea qu√© sucede dentro de la clase. <br><br>  Una clase puede tener constructores primarios y secundarios. <br>  Un constructor se declara utilizando la palabra clave constructor.  Si el constructor principal no tiene modificadores de acceso y anotaciones, se puede omitir la palabra clave. <br>  Una clase puede no tener constructores declarados expl√≠citamente.  En este caso, despu√©s de la declaraci√≥n de la clase no hay construcciones, procedemos inmediatamente al cuerpo de la clase.  Si dibujamos una analog√≠a con Java, esto es equivalente a la ausencia de una declaraci√≥n expl√≠cita de constructores, como resultado de lo cual el constructor predeterminado (sin par√°metros) se generar√° autom√°ticamente en la etapa de compilaci√≥n.  Se ve como se esperaba: <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span></code> </pre> <br>  Esto es equivalente a la siguiente entrada: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Pero si escribe de esta manera, se le pedir√° cort√©smente que elimine el constructor primario sin par√°metros. <br><br>  El constructor primario es el que siempre se llama cuando se crea un objeto en caso de que exista.  Si bien tenemos esto en cuenta y lo analizaremos con m√°s detalle m√°s adelante, cuando pasemos a los constructores secundarios.  Por consiguiente, recordamos que si no hay constructores en absoluto, entonces de hecho hay uno (primario), pero no lo vemos. <br><br>  Si, por ejemplo, queremos que el constructor primario sin par√°metros no tenga acceso p√∫blico, entonces junto con la modificaci√≥n <code>private</code> tendremos que declararlo expl√≠citamente con la palabra clave del <code>constructor</code> . <br><br>  La caracter√≠stica principal del constructor primario es que no tiene cuerpo, es decir  no puede contener c√≥digo ejecutable.  Simplemente toma par√°metros en s√≠ mismo y los pasa a la clase para su uso futuro.  En el nivel de sintaxis, se ve as√≠: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Los par√°metros pasados ‚Äã‚Äãde esta manera se pueden usar para varias inicializaciones, pero no m√°s.  En su forma pura, no podemos usar estos argumentos en el c√≥digo de trabajo de la clase.  Sin embargo, podemos inicializar los campos de la clase aqu√≠ mismo.  Se ve as√≠: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Aqu√≠, <code>param1</code> y <code>param2</code> se pueden usar en el c√≥digo como campos de la clase, que es equivalente a lo siguiente: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ val param1 = p1 var param2 = p2 // some code }</span></span></span></span></code> </pre><br>  Bueno, si compara con Java, entonces se ver√≠a as√≠ (y, por cierto, en este ejemplo puede evaluar cu√°nto Kotlin puede reducir la cantidad de c√≥digo): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassAJava(String p1, Integer p2, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> param3) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String getParam1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer getParam2() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void setParam2(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer param2) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = param2; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Hablemos de dise√±adores adicionales.  Son m√°s reminiscentes de los constructores ordinarios en Java: aceptan par√°metros y pueden tener un bloque ejecutable.  Al declarar constructores adicionales, se requiere la palabra clave constructor.  Como se mencion√≥ anteriormente, a pesar de la posibilidad de crear un objeto llamando a un constructor adicional, el constructor primario (si lo hay) tambi√©n deber√≠a llamarse con la ayuda de <code>this</code> .  En el nivel de sintaxis, esto se organiza de la siguiente manera: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Es decir  el constructor adicional es, por as√≠ decirlo, el heredero del primario. <br>  Ahora, si creamos un objeto llamando a un constructor adicional, suceder√° lo siguiente: <br><br>  llamar a un constructor adicional; <br>  llamar al constructor principal; <br>  inicializaci√≥n de un campo de clase <code>p1</code> en el constructor principal; <br>  ejecuci√≥n de c√≥digo en el cuerpo de un constructor adicional. <br><br>  Esto es similar a tal construcci√≥n en Java: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ param1 = p1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, Boolean param3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1); <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Recuerde que en Java podemos llamar a un constructor desde otro utilizando la <code>this</code> solo al comienzo del cuerpo del constructor.  En Kotlin, este problema se decidi√≥ radicalmente: hicieron que esa llamada formara parte de la firma del constructor.  Por si acaso, noto que est√° prohibido llamar a cualquier constructor (primario o adicional) directamente desde el cuerpo del adicional. <br><br>  Un constructor adicional siempre debe referirse al principal (si lo hay), pero puede hacerlo indirectamente, refiri√©ndose a otro constructor adicional.  La conclusi√≥n es que al final de la cadena todav√≠a llegamos a lo principal.  La activaci√≥n de los constructores obviamente ocurrir√° en el orden inverso de los dise√±adores que recurren entre s√≠: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA(p1: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String, p2: Int, p3: Boolean) : this(p1) { // some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, p3: Boolean, p4: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> :</span></span> this(p1, p2, p3) <span class="hljs-comment"><span class="hljs-comment">{ // some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Ahora la secuencia es: <br><br><ul><li>  llamar a un constructor adicional con 4 par√°metros; </li><li>  llamar a un constructor adicional con 3 par√°metros; </li><li>  llamar al constructor primario; </li><li>  inicializaci√≥n de un campo de clase p1 en el constructor primario; </li><li>  ejecuci√≥n de c√≥digo en el cuerpo del constructor con 3 par√°metros; </li><li>  ejecuci√≥n de c√≥digo en el cuerpo del constructor con 4 par√°metros. </li></ul><br>  En cualquier caso, el compilador nunca nos dejar√° olvidar llegar al constructor primario. <br><br>  Sucede que una clase no tiene un constructor primario, mientras que puede tener uno o m√°s adicionales.  Entonces los constructores adicionales no est√°n obligados a referirse a alguien, pero tambi√©n pueden referirse a otros constructores adicionales de esta clase.  Anteriormente, descubrimos que el constructor principal, no especificado expl√≠citamente, se genera autom√°ticamente, pero esto se aplica a los casos en que no hay ning√∫n constructor en la clase.  Si hay al menos un constructor adicional, no se crea un constructor primario sin par√°metros: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Podemos crear un objeto de clase llamando a: <br><br><pre> <code class="hljs lisp">val myClassA = MyClassA()</code> </pre> <br>  En este caso: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Podemos crear un objeto solo con esta llamada: <br><br><pre> <code class="hljs pgsql">val myClassA = MyClassA(‚Äú<span class="hljs-keyword"><span class="hljs-keyword">some</span></span> string‚Äù, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br>  No hay nada nuevo en Kotlin en comparaci√≥n con Java. <br><br>  Por cierto, al igual que el constructor primario, el constructor adicional puede no tener un cuerpo si su tarea es solo pasar par√°metros a otros constructores. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, p4: String) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Tambi√©n vale la pena prestar atenci√≥n al hecho de que, a diferencia del constructor primario, la inicializaci√≥n de los campos de clase en la lista de argumentos del constructor adicional est√° prohibida. <br>  Es decir  dicho registro ser√° inv√°lido: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Por separado, vale la pena se√±alar que el constructor adicional, como el primario, puede estar sin par√°metros: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Hablando de constructores, uno no puede dejar de mencionar una de las caracter√≠sticas convenientes de Kotlin: la capacidad de asignar valores predeterminados para argumentos. <br><br>  Ahora supongamos que tenemos una clase con varios constructores que tienen un n√∫mero diferente de argumentos.  Dar√© un ejemplo en Java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> param3; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> param4; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, p2, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param3 = p3; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param4 = p4; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Como muestra la pr√°ctica, tales dise√±os son bastante comunes.  Veamos c√≥mo se puede escribir lo mismo en Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p4: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Ahora, d√©mosle una palmada a Kotlin por cu√°nto cort√≥ el c√≥digo.  Por cierto, adem√°s de reducir el n√∫mero de l√≠neas, obtenemos m√°s orden.  Recuerde, debe haber visto algo como esto m√°s de una vez: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p3, p1, p2, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1, String p2, Integer p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Cuando vea esto, desea encontrar a la persona que lo escribi√≥, tomarlo con un bot√≥n, llevarlo a la pantalla y preguntar con voz triste: "¬øPor qu√©?" <br>  Aunque puedes repetir esta haza√±a en Kotlin, pero no es necesario. <br><br>  Sin embargo, hay un detalle que, en el caso de una notaci√≥n tan abreviada en Kotlin, es necesario tener en cuenta: si queremos llamar al constructor con valores predeterminados de Java, debemos agregarle la anotaci√≥n <b><code>@JvmOverloads</code></b> : <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p2: Int = 5, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3: Boolean = true, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4: Int = 20)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  De lo contrario, obtenemos un error. <br><br>  Ahora hablemos de <b>inicializadores</b> . <br><br>  Un inicializador es un bloque de c√≥digo marcado con la palabra clave <code>init</code> .  En este bloque, puede realizar algo de l√≥gica para inicializar los elementos de la clase, incluido el uso de los valores de los argumentos que vienen en el constructor primario.  Tambi√©n podemos llamar a funciones desde este bloque. <br><br>  Java tambi√©n tiene bloques de inicializaci√≥n, pero estos no son lo mismo.  En ellos, no podemos, como en Kotlin, pasar un valor desde el exterior (los argumentos del constructor primario).  El inicializador es muy similar al cuerpo del constructor primario, extra√≠do en un bloque separado.  Pero es a primera vista.  De hecho, esto no es del todo cierto.  Vamos a hacerlo bien. <br><br>  Tambi√©n puede existir un inicializador cuando no hay un constructor primario.  Si es as√≠, su c√≥digo, como todos los procesos de inicializaci√≥n, se ejecuta antes que el c√≥digo del constructor adicional.  Puede haber m√°s de un inicializador.  En este caso, el orden de su llamada coincidir√° con el orden de su ubicaci√≥n en el c√≥digo.  Tambi√©n tenga en cuenta que la inicializaci√≥n del campo de clase puede ocurrir fuera de los bloques de <code>init</code> .  En este caso, la inicializaci√≥n tambi√©n ocurre de acuerdo con la disposici√≥n de los elementos en el c√≥digo, y esto debe tenerse en cuenta al llamar a m√©todos desde el bloque inicializador.  Si lo toma descuidadamente, existe la posibilidad de que se encuentre con un error. <br><br>  Te dar√© algunos casos interesantes de trabajar con inicializadores. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Este c√≥digo es bastante v√°lido, aunque no del todo obvio.  Si observa, puede ver que la asignaci√≥n de un valor al campo <code>testParam</code> en el bloque inicializador ocurre antes de que se declare el par√°metro.  Por cierto, esto solo funciona si tenemos un constructor adicional en la clase, pero no tenemos uno primario (si elevamos la declaraci√≥n del campo <code>testParam</code> encima del bloque <code>init</code> , funcionar√° sin un constructor).  Si descompilamos el c√≥digo de bytes de esta clase en Java, obtenemos lo siguiente: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String getTestParam() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void setTestParam(<span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> String var1) { Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = var1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void showTestParam() { Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassB() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showTestParam(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"after"</span></span>; Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } }</code> </pre><br>  Aqu√≠ vemos que la primera llamada al campo durante la inicializaci√≥n (en el bloque <code>init</code> o fuera de √©l) es equivalente a su inicializaci√≥n habitual en Java.  Todas las dem√°s acciones asociadas con la asignaci√≥n de un valor durante el proceso de inicializaci√≥n, excepto la primera (la primera asignaci√≥n de un valor se combina con la declaraci√≥n de campo), se transfieren al constructor. <br>  Si llevamos a cabo experimentos con descompilaci√≥n, resulta que si no hay un constructor, se genera el constructor primario, y toda la magia ocurre en √©l.  Si hay varios constructores adicionales que no se refieren entre s√≠, y no hay uno primario, en el c√≥digo Java de esta clase, todas las asignaciones posteriores del valor al campo <code>testParam</code> duplican en todos los constructores adicionales.  Si hay un constructor primario, solo en el primario.  Fuf ... <br><br>  Y lo m√°s interesante para <code>testParam</code> : cambiemos la firma <code>testParam</code> de <code>var</code> a <code>val</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Y en alg√∫n lugar del c√≥digo llamamos: <br><br><pre> <code class="hljs cs">MyClassB myClassB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClassB();</code> </pre><br>  Todo se compil√≥ sin errores, comenz√≥ y ahora vemos la salida de los registros: <br><br>  en showTestParam testParam = alguna cadena <br>  en el constructor testParam = after <br><br>  Resulta que el campo declarado como <code>val</code> cambi√≥ el valor durante la ejecuci√≥n del c√≥digo.  Por qu√©  Creo que esto es una falla en el compilador de Kotlin, y en el futuro, tal vez esto no se compilar√°, pero hoy todo est√° como est√°. <br><br>  Al sacar conclusiones de los casos anteriores, solo podemos aconsejarle que no produzca bloques de inicializaci√≥n y que no los distribuya por la clase, para evitar la asignaci√≥n repetida de valores durante el proceso de inicializaci√≥n, para llamar solo funciones puras a partir de bloques de inicio.  Todo esto se hace para evitar posibles confusiones. <br><br>  Entonces  <b>Los inicializadores son un cierto bloque de c√≥digo que debe ejecutarse al crear un objeto, independientemente del constructor con el que se cree este objeto.</b> <br><br>  Parece resuelto.  Considere la interacci√≥n de constructores e inicializadores.  Dentro de una clase, todo es bastante simple, pero debe recordar: <br><br><ul><li>  llamar a un constructor adicional; </li><li>  llamar al constructor primario; </li><li>  inicializaci√≥n de campos de clase y bloques de inicializador en el orden de su ubicaci√≥n en el c√≥digo; </li><li>  ejecuci√≥n de c√≥digo en el cuerpo de un constructor adicional. </li></ul><br>  Los casos con herencia se ven m√°s interesantes. <br><br>  Vale la pena se√±alar que como Object es la base para todas las clases en Java, Any es tal en Kotlin.  Sin embargo, Any y Object no son lo mismo. <br><br>  Para comenzar sobre c√≥mo funciona la herencia.  La clase descendiente, como la clase padre, puede o no tener un constructor primario, pero debe referirse a un constructor espec√≠fico de la clase padre. <br><br>  Si la clase descendiente tiene un constructor primario, este constructor debe apuntar a un constructor espec√≠fico de la clase base.  En este caso, todos los constructores adicionales de la clase sucesora deben referirse al constructor principal de su clase. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassC</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p2</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">): this(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { //some code } //some code }</span></span></code> </pre><br>  Si la clase descendiente no tiene un constructor primario, cada uno de los constructores adicionales debe acceder al constructor de la clase padre utilizando la palabra clave <code>super</code> .  En este caso, diferentes constructores adicionales de la clase sucesora pueden acceder a diferentes constructores de la clase padre: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1) { //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> super(p1, p2) <span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Adem√°s, no olvide la posibilidad de llamar indirectamente al constructor de la clase padre a trav√©s de otros constructores de la clase derivada: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA<span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> this (p1)<span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Si la clase descendiente no tiene ning√∫n constructor, simplemente agregamos la llamada al constructor de la clase padre despu√©s del nombre de la clase descendiente: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassC</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span></span>(‚Äúsome string‚Äù) { <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Sin embargo, todav√≠a hay una opci√≥n con herencia, en la que no se requiere una referencia al constructor de la clase principal.  Tal registro es v√°lido: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassB <span class="hljs-comment"><span class="hljs-comment">{ constructor(){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ }</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//some code }</span></span></span></span></code> </pre><br>  Pero solo si la clase padre tiene un constructor sin par√°metros, que es el constructor predeterminado (primario u opcional, no importa). <br><br>  Ahora considere el orden de invocaci√≥n de inicializadores y constructores durante la herencia: <br><br><ul><li>  llame al constructor adicional del heredero; </li><li>  llame al constructor primario del heredero; </li><li>  llamar al constructor adicional del padre; </li><li>  llamar al constructor primario del padre; </li><li>  <code>init</code> bloques <code>init</code> primarios </li><li>  ejecuci√≥n del c√≥digo del cuerpo de un constructor padre adicional; </li><li>  ejecuci√≥n del bloque <code>init</code> del heredero; </li><li>  ejecuci√≥n del c√≥digo del cuerpo del constructor adicional del heredero. </li></ul><br>  Hablemos de la comparaci√≥n con Java, en la que, de hecho, no existe un an√°logo del constructor primario de Kotlin.  En Java, todos los constructores son pares y pueden ser llamados o no entre s√≠.  En Java y Kotlin hay un constructor predeterminado, es un constructor sin par√°metros, pero adquiere un estado especial solo cuando se hereda.  Aqu√≠ vale la pena prestar atenci√≥n a lo siguiente: al heredar en Kotlin, debemos decirle expl√≠citamente a la clase sucesora qu√© constructor de la clase padre usar: el compilador no nos permitir√° olvidarlo.  En Java, no podemos indicar expl√≠citamente esto.  Tenga cuidado: en este caso, se llamar√° al constructor predeterminado de la clase principal (si existe). <br><br>  En esta etapa, asumiremos que estudiamos a los dise√±adores e inicializadores bastante profundamente y ahora sabemos casi todo sobre ellos.  ¬°Descansaremos un poco y cavaremos en la otra direcci√≥n! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425943/">https://habr.com/ru/post/es425943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425931/index.html">"Quiero dejar la f√°brica en la web" - 10 preguntas para el programador, octava edici√≥n</a></li>
<li><a href="../es425933/index.html">Humedad en el centro de datos: por qu√© es importante</a></li>
<li><a href="../es425935/index.html">Suspensi√≥n de la unidad del sistema debajo de la mesa de pie</a></li>
<li><a href="../es425937/index.html">CoreBluetooth en la pr√°ctica</a></li>
<li><a href="../es425939/index.html">DataIncrement: adem√°s de las funciones de phpMyAdmin</a></li>
<li><a href="../es425945/index.html">Consejos para el uso profesional de RecyclerView. Parte 1</a></li>
<li><a href="../es425947/index.html">Ratatouille corporativo</a></li>
<li><a href="../es425951/index.html">C√≥mo piratearon blockchain y criptomonedas: 6 ataques exitosos "51 por ciento"</a></li>
<li><a href="../es425953/index.html">Estaci√≥n meteorol√≥gica en Arduino de la A a la Z. Parte 3</a></li>
<li><a href="../es425955/index.html">8 interesantes errores beta de iOS 12 y c√≥mo los buscamos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>