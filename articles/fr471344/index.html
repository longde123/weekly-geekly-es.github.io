<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📵 🐕 👩🏽‍🤝‍👩🏻 Encore une fois à propos d'ImmutableList en Java 🥥 🔚 👨🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans mon article précédent, « Cloaking around ImmutableList in Java », j'ai proposé une solution au problème de l'absence de listes immuables en Java,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encore une fois à propos d'ImmutableList en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471344/"><p>  Dans mon article précédent, « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cloaking around ImmutableList in Java</a> », j'ai proposé une solution au problème de l'absence de listes immuables en Java, qui n'est pas corrigé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, ni maintenant ni jamais</a> , en Java. </p><br><p>  La solution n'a alors été élaborée qu'au niveau «il y a une telle idée», et l'implémentation dans le code était tordue, donc tout était quelque peu sceptique.  Dans cet article, je propose une solution modifiée.  La logique d'utilisation et l'API sont portées à un niveau acceptable.  L'implémentation dans le code est jusqu'au niveau bêta. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Énoncé du problème </h2><br><p> Nous utiliserons les définitions de l'article d'origine.  En particulier, cela signifie que <code>ImmutableList</code> est une liste immuable de références à certains objets.  Si ces objets s'avèrent non immuables, alors la liste ne sera pas non plus un objet immuable, malgré le nom.  Dans la pratique, il est peu probable que cela nuise à qui que ce soit, mais pour éviter des attentes injustifiées, il convient de le mentionner. </p><br><p>  Il est également clair que l'immuabilité de la liste peut être "piratée" au moyen de réflexions, ou en créant vos propres classes dans le même package, puis en grimpant dans les champs protégés de la liste, ou quelque chose de similaire. </p><br><p>  Contrairement à l'article d'origine, nous n'adhérerons pas au principe du «tout ou rien»: l'auteur semble croire que si le problème ne peut être résolu au niveau du JDK, alors rien ne devrait être fait.  (En fait, il y a une autre question, "ne peut pas être résolue" ou "les auteurs Java n'avaient pas le désir de le résoudre". Il me semble qu'il serait toujours possible en ajoutant des interfaces, des classes et des méthodes supplémentaires pour rapprocher les collections existantes de l'apparence souhaitée, bien que moins belle que si vous y aviez pensé tout de suite, mais maintenant ce n'est pas à ce sujet.) </p><br><p>  Nous allons créer une bibliothèque qui peut coexister avec succès avec les collections existantes en Java. </p><br><p>  Les principales idées de la bibliothèque: </p><br><ul><li>  Il existe des <code>MutableList</code> et <code>MutableList</code> .  En lançant des types, il est impossible d'obtenir l'un de l'autre. </li><li>  Dans notre projet, que nous souhaitons améliorer à l'aide de la bibliothèque, nous remplaçons tous les <code>List</code> par l'une de ces deux interfaces.  Si, à un moment donné, vous ne pouvez pas vous passer de la <code>List</code> , à la première occasion, nous convertirons la <code>List</code> de / vers l'une des deux interfaces.  Il en va de même pour les moments de réception / transmission de données à des bibliothèques tierces à l'aide de <code>List</code> . </li><li>  Les conversions mutuelles entre <code>MutableList</code> , <code>MutableList</code> , <code>List</code> doivent être effectuées aussi rapidement que possible (c'est-à-dire sans copier les listes, si possible).  Sans conversions aller-retour «bon marché», l'idée commence à paraître douteuse. </li></ul><br><p>  Il convient de noter que seules les listes sont prises en compte, car pour l'instant seules elles sont implémentées dans la bibliothèque.  Mais rien n'empêche la bibliothèque de compléter avec <code>Set</code> et <code>Map</code> s. </p><br><h2 id="api">  API </h2><br><h3 id="immutablelist">  ImmutableList </h3><br><p>  <code>ImmutableList</code> est le successeur de <code>ReadOnlyList</code> (qui, comme dans l'article précédent, est une interface <code>List</code> copiée à partir de laquelle toutes les méthodes de mutation sont supprimées).  Méthodes ajoutées: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  La méthode <code>toList</code> offre la possibilité de passer une <code>ImmutableList</code> à des morceaux de code en attente d'une <code>List</code> .  Un wrapper est retourné dans lequel toutes les méthodes de modification renvoient une <code>UnsupportedOperationException</code> , et les méthodes restantes sont redirigées vers la liste <code>ImmutableList</code> origine. </p><br><p>  La méthode <code>mutable</code> convertit une <code>MutableList</code> une <code>MutableList</code> .  Un encapsuleur est renvoyé dans lequel toutes les méthodes sont redirigées vers la liste <code>ImmutableList</code> origine jusqu'à la première modification.  Avant la modification, l'encapsuleur est délié de la liste <code>ImmutableList</code> origine, copiant son contenu dans la liste <code>ArrayList</code> interne, vers laquelle toutes les opérations sont ensuite redirigées. </p><br><p>  La méthode <code>contentEquals</code> destinée à comparer le contenu de la liste avec le contenu d'un <code>Iterable</code> passé arbitrairement (bien sûr, cette opération n'a de sens que pour les implémentations <code>Iterable</code> qui ont un ordre distinct d'éléments). </p><br><p>  Notez que dans notre implémentation de <code>ReadOnlyList</code> , les <code>listIterator</code> <code>iterator</code> et <code>listIterator</code> renvoient la norme <code>java.util.Iterator</code> / <code>java.util.ListIterator</code> .  Ces itérateurs contiennent des méthodes de modification qui devront être supprimées en lançant une <code>UnsupportedOperationException</code> .  Il serait préférable de faire notre <code>ReadOnlyIterator</code> , mais dans ce cas nous ne pourrions pas écrire <code>for (Object item : immutableList)</code> , ce qui gâterait immédiatement tout le plaisir d'utiliser la bibliothèque. </p><br><h3 id="mutablelist">  MutableList </h3><br><p>  <code>MutableList</code> est le descendant de la <code>List</code> régulière.  Méthodes ajoutées: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releaseSnapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  La méthode d' <code>snapshot</code> est conçue pour obtenir un «instantané» de l'état actuel de <code>MutableList</code> tant que <code>MutableList</code> .  Le «snapshot» est enregistré à l'intérieur de <code>MutableList</code> , et si l'état n'a pas changé au moment du prochain appel de méthode, la même instance de <code>ImmutableList</code> .  Le «snapshot» stocké à l'intérieur est ignoré la première fois qu'une méthode de modification est appelée, ou lorsque <code>releaseSnapshot</code> appelé.  La méthode <code>releaseSnapshot</code> peut être utilisée pour économiser de la mémoire si vous êtes sûr que personne n'aura besoin d'un «instantané», mais les méthodes de modification ne seront pas appelées bientôt. </p><br><h3 id="mutabor">  Mutabor </h3><br><p>  La classe <code>Mutabor</code> fournit un ensemble de méthodes statiques qui sont les «points d'entrée» de la bibliothèque. </p><br><p>  Oui, le projet s'appelle désormais «mutabor» (il est en accord avec «mutable», et en traduction cela signifie «je vais transformer», ce qui est en bon accord avec l'idée de «transformer» rapidement certains types de collections en d'autres). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E[] original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;E&gt; original)</span></span></span></span>;</code> </pre> <br><p>  <code>copyTo*</code> méthodes <code>copyTo*</code> conçues pour créer des collections appropriées en copiant les données fournies.  Les méthodes <code>convertTo*</code> une conversion rapide de la collection transférée vers le type souhaité, et s'il n'était pas possible de convertir rapidement, elles effectuent une copie lente.  Si la conversion rapide a réussi, la collection d'origine est supprimée et il est supposé qu'elle ne sera pas utilisée à l'avenir (bien que cela soit possible, mais cela n'a guère de sens). </p><br><p>  Les appels aux constructeurs des <code>ImmutableList</code> implémentation <code>MutableList</code> / <code>MutableList</code> masqués.  Il est supposé que l'utilisateur ne traite que des interfaces, il ne crée pas de tels objets et utilise les méthodes décrites ci-dessus pour transformer les collections. </p><br><h2 id="detali-realizacii">  Détails d'implémentation </h2><br><h3 id="immutablelistimpl">  ImmutableListImpl </h3><br><p>  Encapsule un tableau d'objets.  L'implémentation correspond à peu près à l'implémentation <code>ArrayList</code> , à partir de laquelle toutes les méthodes de modification et vérifie les modifications simultanées sont rejetées. </p><br><p>  L'implémentation des <code>contentEquals</code> <code>toList</code> et <code>contentEquals</code> également assez triviale.  La méthode <code>toList</code> retourne un wrapper qui redirige les appels vers une <code>ImmutableList</code> donnée; la copie lente des données ne se produit pas. </p><br><p>  La méthode <code>mutable</code> renvoie un <code>MutableListImpl</code> créé sur la base de cet <code>ImmutableList</code> .  La copie des données ne se produit que <code>MutableList</code> méthode de modification est appelée sur la liste <code>MutableList</code> reçue. </p><br><h3 id="mutablelistimpl">  MutableListImpl </h3><br><p>  Encapsule les liens vers <code>ImmutableList</code> et <code>List</code> .  Lors de la création d'un objet, un seul de ces deux liens est toujours rempli, l'autre reste <code>null</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ImmutableList&lt;E&gt; immutable; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> List&lt;E&gt; list;</code> </pre> <br><p>  Les méthodes immuables redirigent les appels vers <code>ImmutableList</code> s'il n'est pas <code>null</code> et vers <code>List</code> cas contraire. </p><br><p>  La modification des méthodes redirige les appels vers <code>List</code> , après l'initialisation: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(immutable.toList()); } immutable = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  La méthode de l' <code>snapshot</code> ressemble à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> immutable; } immutable = InternalUtils.convertToImmutableList(list); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    //   ,  . //     immutable     . list = null; return immutable; } immutable = InternalUtils.copyToImmutableList(list); return immutable; }</span></span></code> </pre> <br><p>  L'implémentation des <code>contentEquals</code> et <code>contentEquals</code> triviale. </p><br><p>  Cette approche vous permet de minimiser le nombre de copies de données lors d'une utilisation "ordinaire", en remplaçant les copies par des conversions rapides. </p><br><h3 id="bystroe-preobrazovanie-spiskov">  Conversion de liste rapide </h3><br><p>  Des conversions rapides sont possibles pour les classes <code>ArrayList</code> ou <code>Arrays$ArrayList</code> (résultat de la méthode <code>Arrays.asList()</code> ).  En pratique, dans la grande majorité des cas, ce sont précisément ces classes qui se rencontrent. </p><br><p>  À l'intérieur de ces classes contiennent un tableau d'éléments.  L'essence d'une conversion rapide est d'obtenir une référence à ce tableau par le biais de réflexions (il s'agit d'un champ privé) et de le remplacer par une référence à un tableau vide.  Cela garantit que la seule référence au tableau reste avec notre objet et que le tableau reste inchangé. </p><br><p>  Dans la version précédente de la bibliothèque, des conversions rapides des types de collection étaient effectuées en appelant le constructeur.  Dans le même temps, l'objet de collection d'origine s'est détérioré (il est devenu impropre à une utilisation ultérieure), ce que vous n'attendez pas inconsciemment du designer.  Maintenant, une méthode statique spéciale est utilisée pour la conversion, et la collection d'origine ne se gâte pas, mais est simplement effacée.  Ainsi, un comportement inhabituel effrayant a été éliminé. </p><br><h3 id="problemy-s-equals--hashcode">  Problèmes avec equals / hashCode </h3><br><p>  Les collections Java utilisent une approche très étrange pour implémenter les méthodes <code>equals</code> et <code>hashCode</code> . </p><br><p>  La comparaison est effectuée en fonction du contenu, ce qui semble logique, mais la classe de la liste elle-même n'est pas prise en compte.  Par conséquent, par exemple, <code>ArrayList</code> et <code>LinkedList</code> avec le même contenu seront <code>equals</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Voici l'implémentation equals / hashCode de AbstractList (dont ArrayList est hérité)</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator e2 = ((List) o).listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e1.hasNext() &amp;&amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o1==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? o2==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : o1.equals(o2))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(e1.hasNext() || e2.hasNext()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashCode = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) hashCode = <span class="hljs-number"><span class="hljs-number">31</span></span>*hashCode + (e==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : e.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashCode; }</code> </pre> </div></div><br><p>  Ainsi, désormais, toutes les implémentations de <code>List</code> doivent avoir une implémentation d' <code>equals</code> similaire (et, par conséquent, <code>hashCode</code> ).  Sinon, vous pouvez obtenir des situations où <code>a.equals(b) &amp;&amp; !b.equals(a)</code> , ce qui n'est pas bon.  Une situation similaire est avec <code>Set</code> et <code>Map</code> . </p><br><p>  Lorsqu'il est appliqué à la bibliothèque, cela signifie que l'implémentation de <code>equals</code> et <code>hashCode</code> pour <code>MutableList</code> prédéfinie, et dans une telle implémentation, <code>MutableList</code> et <code>MutableList</code> avec le même contenu ne peuvent pas être <code>equals</code> (puisque <code>ImmutableList</code> pas une <code>List</code> ).  Par conséquent, les méthodes <code>contentEquals</code> ont été ajoutées pour comparer le contenu. </p><br><p>  L'implémentation des méthodes <code>equals</code> et <code>hashCode</code> pour <code>ImmutableList</code> complètement similaire à la version de <code>AbstractList</code> , mais avec le remplacement de <code>List</code> par <code>ReadOnlyList</code> . </p><br><h2 id="itogo">  Total </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les sources et tests de la bibliothèque sont affichés par référence</a> sous la forme d'un projet maven. </p><br><p>  Dans le cas où quelqu'un souhaite utiliser la bibliothèque, il a créé un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupe en contact</a> pour des «retours». </p><br><p>  L'utilisation de la bibliothèque est assez évidente, voici un petit exemple: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myBusinessProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Entity&gt; tempFromDb = queryEntitiesFromDatabase(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM my_table"</span></span>); ImmutableList&lt;Entity&gt; fromDb = Mutabor.convertToImmutableList(tempFromDb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromDb.isEmpty() || !someChecksPassed(fromDb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... MutableList&lt;Entity&gt; list = fromDb.mutable(); //time to change list.remove(1); ImmutableList&lt;Entity&gt; processed = list.snapshot(); //time to change ended //... if (!callSideLibraryExpectsListParameter(processed.toList())) { return false; } for (Entity entity : processed) { outputToUI(entity); } return true; }</span></span></code> </pre> <br><p>  Bonne chance à tous!  Envoyez des rapports de bogues! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471344/">https://habr.com/ru/post/fr471344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471332/index.html">Histoires de l'ordinateur lunaire. 3e partie</a></li>
<li><a href="../fr471334/index.html">Pour mémoriser, mais pas pour entasser - apprendre «par cartes»</a></li>
<li><a href="../fr471336/index.html">Holivar. Histoire de Runet. Partie 6. Serrures: Lurk, Tape, 282nd et Chinese path</a></li>
<li><a href="../fr471340/index.html">Drimsim vs Mate 20 Pro Round! Mais pour qui?</a></li>
<li><a href="../fr471342/index.html">Avalonia élégant</a></li>
<li><a href="../fr471346/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 384 (7-13 octobre 2019)</a></li>
<li><a href="../fr471348/index.html">Applications TypeScript à pile complète</a></li>
<li><a href="../fr471350/index.html">Ingénierie inverse des amplificateurs opérationnels à faible bruit à partir d'un ordinateur analogique en 1969</a></li>
<li><a href="../fr471352/index.html">Rédaction de présentations dans LaTeX</a></li>
<li><a href="../fr471358/index.html">Comment écrire un contrat intelligent avec Python sur l'ontologie? Partie 4: API native</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>