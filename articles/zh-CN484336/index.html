<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📼 📮 👨‍👩‍👦 使用动态数组和自定义集合类的规则 😘 🎊 🎯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="使用动态数组和自定义集合类的规则 
 这是我在使用动态数组时要遵守的规则。 实际上，这是设计数组的指南，但是我不想将其放在设计对象的指南中，因为并非每种面向对象的语言都具有动态数组。 这些示例是用PHP编写的，因为它类似于Java（您可能已经熟悉），但是使用动态数组而不是内置的集合类和接口。 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用动态数组和自定义集合类的规则</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484336/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/qy/hx/3d/qyhx3dbaepmsxkx2azb_tmi9dee.jpeg"></div><br><br> 使用动态数组和自定义集合类的规则 <br> 这是我在使用动态数组时要遵守的规则。 实际上，这是设计数组的指南，但是我不想将其放在设计对象的指南中，因为并非每种面向对象的语言都具有动态数组。 这些示例是用PHP编写的，因为它类似于Java（您可能已经熟悉），但是使用动态数组而不是内置的集合类和接口。 <br><a name="habracut"></a><br><h2> 使用数组作为列表 </h2><br><h4> 所有项目都必须是同一类型。 </h4><br> 如果将数组用作列表（按一定顺序排列的值的集合），则所有值都必须具有相同的类型： <br><br><pre><code class="php hljs">$goodList = [ <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> ]; $badList = [ <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ];</code> </pre> <br> 常见的列表类型注释样式为： <code>@var array&lt;TypeOfElment&gt;</code> 。 确保不添加索引类型，它应该始终为<code>int</code> 。 <br><br><h4> 需要忽略每个项目的索引 </h4><br>  PHP将为每个列表项（0、1、2等）自动创建一个新索引。 但是，您既不应依赖这些索引，也不应直接使用它们。 客户只能依靠<code>iterable</code>和<code>countable</code> 。 <br><br> 因此，您可以自由使用<code>foreach</code>和<code>count()</code> ，但不要使用<code>for</code>在列表项之间循环： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Good loop: foreach ($list as $element) { } // Bad loop (exposes the index of each element): foreach ($list as $index =&gt; $element) { } // Also bad loop (the index of each element should not be used): for ($i = 0; $i &lt; count($list); $i++) { }</span></span></code> </pre> <br> 在PHP中，如果列表中没有索引，或者索引数大于元素数，则<code>for</code>循环可能根本无法工作。 <br><br><h4> 使用过滤器而不是删除项目 </h4><br> 您可能希望按索引（ <code>unset()</code> ）删除项目，但是与其删除，不如使用<code>array_filter()</code>创建一个没有多余元素的新列表更好。 <br><br> 同样，不应依赖元素索引。 因此，在使用<code>array_filter()</code>请勿使用<a href="https://www.php.net/manual/en/function.array-filter.php">flag参数</a>来按索引甚至按元素和索引过滤掉元素。 <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Good filter: array_filter( $list, function (string $element): bool { return strlen($element) &gt; 2; } ); // Bad filter (uses the index to filter elements as well) array_filter( $list, function (int $index): bool { return $index &gt; 3; }, ARRAY_FILTER_USE_KEY ); // Bad filter (uses both the index and the element to filter elements) array_filter( $list, function (string $element, int $index): bool { return $index &gt; 3 || $element === 'Include'; }, ARRAY_FILTER_USE_BOTH );</span></span></code> </pre><br><h2> 将数组用作关联数组 </h2><br> 如果键是相关的而不是索引（0、1、2等），则可以自由使用关联数组（可以通过键的唯一键从中提取值的集合）。 <br><br><h4> 所有密钥必须具有相同的类型。 </h4><br> 使用关联数组的第一条规则：所有键必须具有相同的类型（最常见的是<code>string</code> ）。 <br><br><pre> <code class="php hljs">$goodMap = [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'baz'</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// Bad (uses different types of keys) $badMap = [ 'foo' =&gt; 'bar', 1 =&gt; 'baz' ];</span></span></code> </pre><br><h3> 所有值都必须是同一类型。 </h3><br> 值同样适用：它们必须是同一类型。 <br><br><pre> <code class="php hljs">$goodMap = [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'baz'</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// Bad (uses different types of values) $badMap = [ 'foo' =&gt; 'bar', 'bar' =&gt; 1 ];</span></span></code> </pre> <br> 注释类型的常见样式是： <code>@var array&lt;TypeOfKy, TypeOfValue&gt;</code> 。 <br><br><h4> 关联数组必须保持私有 </h4><br> 列表由于其特性的简单性，可以安全地从一个对象转移到另一个对象。 即使列表为空，任何客户端都可以循环浏览元素或对其进行计数。 由于客户可以依赖与任何值都不匹配的键，因此使用Map更加困难。 这意味着关联数组通常应相对于管理它们的对象保持私有。 而不是让客户端直接访问内部映射，而是让getter（可能还有setter）检索值。 如果请求的键没有值，则引发异常。 但是，如果您可以将地图及其值完全设为私有，请执行此操作。 <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Exposing a list is fine /** * @return array&lt;User&gt; */ public function allUsers(): array { // ... } // Exposing a map may be troublesome /** * @return array&lt;string, User&gt; */ public function usersById(): array { // ... } // Instead, offer a method to retrieve a value by its key /** * @throws UserNotFound */ public function userById(string $id): User { // ... }</span></span></code> </pre><br><h2> 将对象用作具有多种类型值的关联数组 </h2><br> 如果要使用关联数组，但要在其中存储不同类型的值，请使用对象。 定义一个类，添加公共类型属性，或添加一个构造函数和获取方法。 这些对象包括配置或命令对象： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SillyRegisterUserCommand</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string $username; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string $plainTextPassword; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool $wantsToReceiveSpam; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int $answerToIAmNotARobotQuestion; }</code> </pre><br><h4> 规则例外 </h4><br> 库和框架有时需要更动态地使用数组。 这样就不可能（也不希望）遵循以前的规则。 示例包括存储在数据库表中<a href="https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/">的数据数组以及</a> Symfony中<a href="https://symfony.com/doc/current/forms.html">的表单配置</a> 。 <br><br><h2> 自定义集合类 </h2><br> 自定义集合类可能是与<code>Iterator</code> ， <code>ArrayAccess</code>和其他实体一起使用的好工具，但是我发现代码常常令人困惑。 初次看代码的任何人都必须查阅PHP手册，即使他是一位经验丰富的开发人员。 此外，您将不得不编写更多代码进行维护（测试，调试等）。 因此，在大多数情况下，具有正确类型注释的简单数组就足够了。 <br><br> 什么表明您需要将数组包装在自定义集合对象中？ <br><br><ul><li> 与数组有关的逻辑重复。 <br></li><li> 客户必须处理有关数组内容的太多细节。 <br></li></ul><br><h4> 使用自定义集合类来防止重复逻辑。 </h4><br> 如果使用同一阵列的多个客户端执行相同的任务（例如，过滤，比较，减少，计数），则可以使用自定义集合类删除重复项。 将重复的逻辑转移到集合类方法可以使任何客户端仅通过调用集合方法即可执行相同的任务： <br><br><pre> <code class="php hljs">$names = [<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Found in several places: $shortNames = array_filter( $names, function (string $element): bool { return strlen($element) &lt; 5; } ); // Turned into a custom collection class: use Assert\Assert; final class Names { /** * @var array&lt;string&gt; */ private array $names; public function __construct(array $names) { Assert::that()-&gt;allIsString($names); $this-&gt;names = $names; } public function shortNames(): self { return new self( array_filter( $this-&gt;names, function (string $element): bool { return strlen($element) &lt; 5; } ) ); } } $names = new Names([/* ... */]); $shortNames = $names-&gt;shortNames();</span></span></code> </pre> <br> 使用方法转换集合的优点是，命名了此转换。 您可以为调用<code>array_filter()</code>添加一个简短的信息性名称，否则很难找到。 <br><br><h4> 取消客户与自定义集合类的绑定 </h4><br> 如果客户端遍历数组，从所选元素中获取部分数据并对它们执行某些操作，则该客户端将与所有相应类型紧密相关：数组，元素，检索到的值，选择器方法等。由于存在如此深的绑定，您在不破坏客户端的情况下更改与这些类型相关的任何内容将变得更加困难。 在这种情况下，您还可以将数组包装在自定义集合类中，并给出正确的答案，在内部执行必要的计算，然后放松客户对集合的绑定。 <br><br><pre> <code class="php hljs">$lines = []; $sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lines <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $line) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($line-&gt;isComment()) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $sum += $line-&gt;quantity(); } <span class="hljs-comment"><span class="hljs-comment">// Turned into a custom collection class: final class Lines { public function totalQuantity(): int { $sum = 0; foreach ($lines as $line) { if ($line-&gt;isComment()) { continue; } $sum += $line-&gt;quantity(); } return $sum; } }</span></span></code> </pre><br><h2> 自定义集合类的一些规则 </h2><br><h4> 使它们不变 </h4><br> 执行此类转换时，对集合实例的现有引用不应受到影响。 因此，任何执行此转换的方法都应返回该类的新实例，如上例所示： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Names</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> $names; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $names)</span></span></span><span class="hljs-function"> </span></span>{ Assert::that()-&gt;allIsString($names); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names = $names; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shortNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ); } }</code> </pre> <br> 当然，如果转换内部数组，则可以转换为其他类型的集合或简单数组。 与往常一样，请确保返回正确的类型。 <br><br><h4> 只提供客户真正需要的行为 </h4><br> 仅实现您真正需要的，而不是从具有通用集合的库中扩展类，或者实现通用过滤器或映射，以及为每个自定义集合类进行缩减，而不必实现。 如果在某个时候停止使用该方法，则将其删除。 <br><br><h4> 使用IteratorAggregate和ArrayIterator进行迭代 </h4><br> 如果您使用的是PHP，则不要实现<code>Iterator</code>接口的所有方法（保存内部指针等），而是仅实现<code>IteratorAggregate</code>接口，并使其基于内部数组返回<code>ArrayIterator</code>实例： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Names</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorAggregate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> $names; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $names)</span></span></span><span class="hljs-function"> </span></span>{ Assert::that()-&gt;allIsString($names); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names = $names; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterator</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayIterator(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names); } } $names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Names([<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($names <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><h4> 妥协 </h4><br> 由于您正在为自定义集合类编写更多代码，因此客户端应该更轻松地使用此集合（而不仅仅是数组）。 如果客户端代码变得更加清晰，如果集合提供了有用的行为，那么这证明了维护自定义集合类的额外努力是合理的。 但是由于使用动态数组非常容易（主要是因为您不需要指定使用的类型），所以我很少使用集合类。 但是，一些开发人员正在积极使用它们，因此，我一定会继续寻找可能的用例。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484336/">https://habr.com/ru/post/zh-CN484336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484320/index.html">在Quarkus，Kotlin和Gradle上创建微服务</a></li>
<li><a href="../zh-CN484326/index.html">跳转到伦敦或在跳转贸易公司实习</a></li>
<li><a href="../zh-CN484328/index.html">保罗·格雷厄姆（Paul Graham）宣布新的Bel编程语言</a></li>
<li><a href="../zh-CN484330/index.html">[Nginx]如何击败response_status = 0</a></li>
<li><a href="../zh-CN484332/index.html">专注于任务管理。 我们如何做我们的管理系统</a></li>
<li><a href="../zh-CN484338/index.html">三星的霓虹灯项目：数字银行家，电视节目主持人，同伴</a></li>
<li><a href="../zh-CN484340/index.html">1月17日的Java摘要。 新年的前两周</a></li>
<li><a href="../zh-CN484342/index.html">基于Eclipse和GTK +的工具包，用于“ Toradex Colibri T20（Linux）”</a></li>
<li><a href="../zh-CN484344/index.html">Kubernetes中自动缩放的三个级别：如何有效使用它们</a></li>
<li><a href="../zh-CN484356/index.html">一个友好的团队中一个有趣的项目，或者合适的员工要花多少钱？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>