<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí´ üì± üö∂üèæ Unidade: desenhe muitas barras de sa√∫de em uma chamada üë©‚Äçüë©‚Äçüë¶ üåö ‚õ∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, eu precisava resolver um problema bastante comum em muitos jogos com uma vista superior: renderizar na tela um monte de barras de sa√∫de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unidade: desenhe muitas barras de sa√∫de em uma chamada</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447716/">  Recentemente, eu precisava resolver um problema bastante comum em muitos jogos com uma vista superior: renderizar na tela um monte de barras de sa√∫de inimigas.  Algo assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  Obviamente, eu queria fazer isso da maneira mais eficiente poss√≠vel, de prefer√™ncia em uma chamada de empate.  Como sempre, antes de come√ßar o trabalho, fiz uma pequena pesquisa on-line sobre as decis√µes de outras pessoas, e os resultados foram muito diferentes. <br><br>  N√£o vou envergonhar ningu√©m pelo c√≥digo, mas basta dizer que algumas das solu√ß√µes n√£o foram totalmente brilhantes; por exemplo, algu√©m adicionou um objeto Canvas a cada inimigo (o que √© muito ineficiente). <br><br>  O m√©todo que cheguei como resultado √© um pouco diferente de tudo que vi com outras pessoas e n√£o usa nenhuma classe de interface do usu√°rio (incluindo o Canvas), ent√£o decidi document√°-lo para o p√∫blico.  E para quem quer aprender o c√≥digo-fonte, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publiquei no Github</a> . <br><a name="habracut"></a><br><h2>  Por que n√£o usar o Canvas? </h2><br>  Uma tela para cada inimigo √© obviamente uma m√° decis√£o, mas eu poderia usar uma tela comum para todos os inimigos;  um √∫nico Canvas tamb√©m levaria √† renderiza√ß√£o de lotes de chamadas. <br><br>  No entanto, n√£o gosto da quantidade de trabalho realizado em cada quadro relacionado a essa abordagem.  Se voc√™ usa o Canvas, em cada quadro voc√™ deve executar as seguintes opera√ß√µes: <br><br><ul><li>  Determine quais dos inimigos est√£o na tela e selecione cada um deles na faixa da interface do usu√°rio do pool. </li><li>  Projete a posi√ß√£o do inimigo na c√¢mera para posicionar a tira. </li><li>  Redimensione a parte "fill" da faixa, provavelmente como Image. </li><li>  √â mais prov√°vel que mude o tamanho das tiras de acordo com o tipo de inimigo;  por exemplo, inimigos grandes devem ter faixas grandes para que n√£o pare√ßam bobos. </li></ul><br>  De qualquer forma, tudo isso contaminaria os buffers da geometria do Canvas e levaria a uma reconstru√ß√£o de todos os dados de v√©rtices no processador.  Eu n√£o queria que tudo isso fosse feito para um elemento t√£o simples. <br><br><h2>  Brevemente sobre minha decis√£o </h2><br>  Uma breve descri√ß√£o do meu processo de trabalho: <br><br><ul><li>  Anexamos objetos de tiras de energia aos inimigos em 3D. <br><ul><li>  Isso permite organizar e aparar tiras automaticamente. </li><li>  A posi√ß√£o / tamanho da faixa pode ser ajustada de acordo com o tipo de inimigo. </li><li>  Direcionaremos as faixas para a c√¢mera no c√≥digo usando a transforma√ß√£o, que ainda est√° l√°. </li><li>  O shader garante que eles sempre sejam renderizados em cima de tudo. </li></ul></li><li>  Usamos Instanciamento para renderizar todas as faixas em uma √∫nica chamada de empate. </li><li>  Usamos coordenadas UV processuais simples para exibir o n√≠vel de plenitude da tira. </li></ul><br>  Agora vamos ver a solu√ß√£o com mais detalhes. <br><br><h2>  O que √© Instanciamento? </h2><br>  Ao trabalhar com gr√°ficos, a t√©cnica padr√£o tem sido usada h√° muito tempo: v√°rios objetos s√£o combinados para que eles tenham dados e materiais de v√©rtice comuns e possam ser renderizados em uma chamada de desenho.  √â exatamente disso que precisamos, porque cada chamada de empate √© uma carga extra na CPU e na GPU.  Em vez de fazer uma √∫nica chamada de desenho para cada objeto, renderizamos todos ao mesmo tempo e usamos um sombreador para adicionar variabilidade a cada c√≥pia. <br><br>  Voc√™ pode fazer isso manualmente duplicando os dados do v√©rtice da malha X vezes em um buffer, em que X √© o n√∫mero m√°ximo de c√≥pias que podem ser renderizadas e, em seguida, usando a matriz de par√¢metros do shader para converter / colorir / variar cada c√≥pia.  Cada c√≥pia deve armazenar conhecimento sobre qual √© a inst√¢ncia numerada, para usar esse valor como um √≠ndice da matriz.  Em seguida, podemos usar uma chamada de renderiza√ß√£o indexada que ordena ‚Äúrenderizar apenas para N‚Äù, onde N √© o n√∫mero de inst√¢ncias <em>realmente</em> necess√°rias no quadro atual, menor que o n√∫mero m√°ximo de X. <br><br>  As APIs mais modernas j√° possuem c√≥digo para isso, portanto, voc√™ n√£o precisa fazer isso manualmente.  Esta opera√ß√£o √© chamada "Instanciamento";  de fato, ele automatiza o processo descrito acima com restri√ß√µes predefinidas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O mecanismo do Unity tamb√©m suporta inst√¢ncias</a> , possui sua pr√≥pria API e um conjunto de macros de sombreador que ajudam na sua implementa√ß√£o.  Ele usa certas suposi√ß√µes, por exemplo, de que cada inst√¢ncia requer uma transforma√ß√£o 3D completa.  A rigor, para tiras 2D, isso n√£o √© necess√°rio completamente - podemos fazer simplifica√ß√µes, mas, como s√£o, as usaremos.  Isso simplificar√° nosso sombreador e tamb√©m fornecer√° a capacidade de usar indicadores 3D, por exemplo, c√≠rculos ou arcos. <br><br><h2>  Classe danific√°vel </h2><br>  Nossos inimigos ter√£o um componente chamado <code>Damageable</code> , dando a eles sa√∫de e permitindo que eles <code>Damageable</code> danos causados ‚Äã‚Äãpor colis√µes.  No nosso exemplo, √© bastante simples: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  HealthBar Object: Posi√ß√£o / Turno </h2><br>  O objeto da barra de sa√∫de √© muito simples: na verdade, √© apenas um Quad anexado ao inimigo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  Usamos a <strong>escala</strong> deste objeto para tornar a tira longa e fina, e a colocamos diretamente acima do inimigo.  N√£o se preocupe com sua rota√ß√£o, vamos corrigi-lo usando o c√≥digo anexado ao objeto no <code>HealthBar.cs</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  Esse c√≥digo sempre direciona o quad para a c√¢mera.  Podemos realizar redimensionamento e rota√ß√£o no sombreador, mas eu os implemento aqui por dois motivos. <br><br>  Primeiro, o instanciamento do Unity sempre usa a transforma√ß√£o completa de cada objeto e, como transferimos todos os dados de qualquer maneira, voc√™ pode us√°-lo.  Em segundo lugar, definir aqui a escala / rota√ß√£o garante que o paralelogramo delimitador para aparar a tira sempre seja verdadeiro.  Se tornarmos a tarefa de tamanho e rota√ß√£o a responsabilidade do shader, o Unity poder√° truncar as tiras que devem estar vis√≠veis quando estiverem pr√≥ximas √†s bordas da tela, porque o tamanho e a rota√ß√£o do paralelogramo delimitador n√£o corresponder√£o ao que vamos renderizar.  Obviamente, poder√≠amos implementar nosso pr√≥prio m√©todo de truncamento, mas geralmente √© melhor usar o que temos, se poss√≠vel (o c√≥digo do Unity √© nativo e tem acesso a mais dados espaciais do que n√≥s). <br><br>  Vou explicar como a tira √© renderizada depois de olharmos para o shader. <br><br><h2>  Shader HealthBar </h2><br>  Nesta vers√£o, criaremos uma simples faixa verde-vermelha cl√°ssica. <br><br>  Eu uso uma textura 2x1 com um pixel verde √† esquerda e um vermelho √† direita.  Naturalmente, desliguei o mipmapping, a filtragem e a compacta√ß√£o e defino o par√¢metro do modo de endere√ßamento como Clamp, o que significa que os pixels da nossa faixa sempre ser√£o perfeitamente verdes ou vermelhos e n√£o se espalhar√£o pelas bordas.  Isso nos permitir√° alterar as coordenadas da textura no sombreador para mudar a linha que divide os pixels vermelho e verde para baixo e para cima na faixa. <br><br>  <em>(Como existem apenas duas cores aqui, eu poderia usar a fun√ß√£o step no shader para retornar ao ponto de uma ou outra. No entanto, esse m√©todo √© conveniente porque voc√™ pode usar uma textura mais complexa, se desejar, e isso funcionar√° da mesma forma durante a transi√ß√£o. textura m√©dia.)</em> <br><br>  Primeiro, declararemos as propriedades necess√°rias: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> √© uma textura vermelho-verde e <code>_Fill</code> √© um valor de 0 a 1, em que 1 tem vida √∫til completa. <br><br>  Em seguida, precisamos solicitar que a faixa seja renderizada na fila de sobreposi√ß√£o, o que significa ignorar toda a profundidade da cena e renderizar sobre tudo: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  A pr√≥xima parte √© o pr√≥prio c√≥digo do sombreador.  Como escrevemos um sombreador sem ilumina√ß√£o (apagado), n√£o precisamos nos preocupar com a integra√ß√£o com v√°rios sombreadores de superf√≠cie do Unity; s√£o apenas alguns sombreadores de v√©rtice / fragmento.  Primeiro, escreva bootstrap: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  Na maioria das vezes, esse √© o bootstrap padr√£o, com exce√ß√£o do <code>#pragma multi_compile_instancing</code> , que informa ao compilador Unity o que precisa ser compilado para o Instanciamento. <br><br>  A estrutura do v√©rtice deve incluir dados da inst√¢ncia; portanto, faremos o seguinte: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  Tamb√©m precisamos especificar o que exatamente estar√° nos dados das inst√¢ncias, al√©m do que o Unity (transforma√ß√£o) processa para n√≥s: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  Portanto, estamos relatando que o Unity deve criar um buffer chamado "Props" para armazenar os dados de cada inst√¢ncia e, dentro dele, usaremos um float por inst√¢ncia para uma propriedade chamada <code>_Fill</code> . <br><br>  Voc√™ pode usar v√°rios buffers;  vale a pena fazer se voc√™ tiver v√°rias propriedades atualizadas em diferentes frequ√™ncias;  Ao dividi-los, voc√™ n√£o pode, por exemplo, alterar um buffer ao alterar outro, o que √© mais eficiente.  Mas n√£o precisamos disso. <br><br>  Nosso shader de v√©rtice quase completamente faz o trabalho padr√£o, porque tamanho, posi√ß√£o e rota√ß√£o j√° s√£o transferidos para transforma√ß√£o.  Isso √© implementado usando o <code>UnityObjectToClipPos</code> , que usa automaticamente a transforma√ß√£o de cada inst√¢ncia.  Pode-se imaginar que, sem instanciar, isso normalmente seria simples usando uma √∫nica propriedade da matriz.  mas ao usar instanciamento dentro do mecanismo, ele se parece com uma matriz de matrizes e o Unity seleciona independentemente uma matriz adequada para essa inst√¢ncia. <br><br>  Al√©m disso, voc√™ precisa alterar os UV para alterar o local do ponto de transi√ß√£o de vermelho para verde, de acordo com a propriedade <code>_Fill</code> .  Aqui est√° o trecho de c√≥digo relevante: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> e <code>UNITY_ACCESS_INSTANCED_PROP</code> fazem toda a m√°gica acessando a vers√£o correta da propriedade <code>_Fill</code> no buffer constante desta inst√¢ncia. <br><br>  Sabemos que, no estado normal, as coordenadas UV de um quadril√°tero cobrem todo o intervalo de textura e que a linha divis√≥ria da faixa est√° no meio da textura horizontalmente.  Portanto, pequenos c√°lculos matem√°ticos deslocam horizontalmente a faixa para a esquerda ou direita, e o valor de Fixa√ß√£o da textura garante o preenchimento da pe√ßa restante. <br><br>  O shader de fragmento n√£o poderia ser mais simples porque todo o trabalho j√° foi realizado: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  O c√≥digo completo do shader de coment√°rios est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio GitHub</a> . <br><br><h2>  Healthbar Material </h2><br>  Ent√£o tudo √© simples - precisamos atribuir √† nossa tira o material que esse shader usa.  Quase nada mais precisa ser feito, basta selecionar o sombreador desejado na parte superior, atribuir uma textura vermelho-verde e, mais importante, <strong>marcar a caixa "Ativar inst√¢ncia de GPU"</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="imagem"><br><br><h2>  Atualiza√ß√£o da propriedade de preenchimento HealthBar </h2><br>  Portanto, como temos o objeto da barra de integridade, o sombreador e o material a ser renderizado, agora precisamos definir a propriedade <code>_Fill</code> para cada inst√¢ncia.  Fazemos isso no <code>HealthBar.cs</code> seguinte maneira: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  <code>CurrentHealth</code> classe <code>CurrentHealth</code> em um valor de 0 a 1, dividindo-o pelo <code>MaxHealth</code> .  Em seguida, passamos para a propriedade <code>_Fill</code> usando <code>MaterialPropertyBlock</code> . <br><br>  Se voc√™ n√£o usou o <code>MaterialPropertyBlock</code> para transferir dados para shaders, mesmo sem instanciar, precisar√° estud√°-los.  Isso n√£o est√° bem explicado na documenta√ß√£o do Unity, mas √© a maneira mais eficiente de transferir dados de cada objeto para shaders. <br><br>  No nosso caso, quando o instanciamento √© usado, os valores para todas as barras de integridade s√£o compactados em um buffer constante, para que possam ser transferidos todos juntos e desenhados ao mesmo tempo. <br><br>  N√£o h√° quase nada aqui, exceto um padr√£o para definir vari√°veis, e o c√≥digo √© bastante chato;  veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o reposit√≥rio GitHub para</a> detalhes. <br><br><h2>  Demo </h2><br>  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio do GitHub</a> tem uma demonstra√ß√£o de teste na qual um monte de cubos azuis malignos s√£o destru√≠dos por esferas vermelhas her√≥icas (hurra!), Sofrendo os danos exibidos pelas faixas descritas no artigo.  Demonstra√ß√£o escrita em Unity 2018.3.6f1. <br><br>  O efeito do uso de instanciamento pode ser observado de duas maneiras: <br><br><h3>  Painel de Estat√≠sticas </h3><br>  Depois de clicar em Reproduzir, clique no bot√£o Estat√≠sticas acima do painel Jogo.  Aqui voc√™ pode ver quantas chamadas de empate foram salvas gra√ßas √† inst√¢ncia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="imagem"><br><br>  Ap√≥s o lan√ßamento do jogo, voc√™ pode clicar no material HealthBar e <em>desmarcar a</em> caixa de <em>sele√ß√£o</em> "Ativar inst√¢ncia de GPU", ap√≥s o qual o n√∫mero de chamadas salvas ser√° reduzido a zero. <br><br><h3>  Depurador de quadros </h3><br>  Depois de iniciar o jogo, v√° para Janela&gt; An√°lise&gt; Depurador de quadros e clique em "Ativar" na janela que aparece. <br><br>  No canto inferior esquerdo, voc√™ ver√° todas as opera√ß√µes de renderiza√ß√£o executadas.  Observe que, embora existam muitos desafios separados para inimigos e proj√©teis (se desejar, voc√™ tamb√©m pode implementar inst√¢ncias para eles).  Se voc√™ rolar para a parte inferior, ver√° o item "Barra de sa√∫de Draw Mesh (instanced)". <br><br>  Essa chamada √∫nica renderiza todas as tiras.  Se voc√™ clicar nessa opera√ß√£o e depois na opera√ß√£o, ver√° que todas as tiras desaparecem, porque s√£o sorteadas em uma chamada.  Se estiver no Depurador de quadros, desmarque a caixa de sele√ß√£o Ativar inst√¢ncia de GPU do material, ver√° que uma linha se transformou em v√°rias e depois de definir o sinalizador novamente em uma. <br><br><h2>  Como expandir este sistema </h2><br>  Como eu disse antes, como essas barras de sa√∫de s√£o objetos reais, n√£o h√° nada que o impe√ßa de transformar simples barras 2D em algo mais complexo.  Eles podem ser semic√≠rculos sob inimigos que diminuem em um arco ou losangos rotativos acima de suas cabe√ßas.  Usando a mesma abordagem, voc√™ ainda pode renderiz√°-los todos em uma chamada. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt447716/">https://habr.com/ru/post/pt447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt447704/index.html">Escalada Elbrus - Reconhecimento em batalha. Parte t√©cnica 1. Registros, pilhas e outros detalhes t√©cnicos</a></li>
<li><a href="../pt447706/index.html">Nem um √∫nico ORM</a></li>
<li><a href="../pt447708/index.html">Yandex presenteou jovens cientistas e l√≠deres cient√≠ficos com os primeiros pr√™mios Ilya Segalovich</a></li>
<li><a href="../pt447712/index.html">Ol√° SaaS | SaaS russo 2018 - resultados</a></li>
<li><a href="../pt447714/index.html">Sobre a aplica√ß√£o da teoria dos processos ARMA na pr√°tica de engenharia</a></li>
<li><a href="../pt447718/index.html">Tudo vai conforme o planejado</a></li>
<li><a href="../pt447720/index.html">Seguran√ßa da Internet das coisas. Edi√ß√£o 2. Casa Inteligente</a></li>
<li><a href="../pt447724/index.html">Como as cidades inteligentes acontecem</a></li>
<li><a href="../pt447728/index.html">Calculamos o or√ßamento de energia de uma linha de r√°dio para um sat√©lite no formato CubeSat</a></li>
<li><a href="../pt447730/index.html">A evolu√ß√£o do email marketing: do QWERTYUIOP ao GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>