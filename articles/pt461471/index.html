<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äç‚öñÔ∏è ü§î üë∑üèª Ferramentas para trabalhar com multithreading e assincronia - Parte 2 üêô ü§≤üèΩ ‚ö™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originalmente, eu publiquei este artigo no blog CodingSight . 
 Tamb√©m est√° dispon√≠vel em russo aqui . 

 Este artigo cont√©m a segunda parte do meu di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ferramentas para trabalhar com multithreading e assincronia - Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461471/">  <i>Originalmente, eu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publiquei</a> este artigo no blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CodingSight</a> .</i> <i><br></i>  <i>Tamb√©m est√° dispon√≠vel em russo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .</i> <br><br>  Este artigo cont√©m a segunda parte do meu discurso no meetup multithreading.  Voc√™ pode dar uma olhada na primeira parte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Na primeira parte, concentrei-me no conjunto b√°sico de ferramentas usadas para iniciar um encadeamento ou uma tarefa, as maneiras de rastrear seu estado e algumas outras coisas interessantes, como o PLinq.  Nesta parte, vou corrigir os problemas que voc√™ pode encontrar em um ambiente com v√°rios threads e algumas maneiras de resolv√™-los. <br><br><h2>  Conte√∫do </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobre recursos compartilhados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Poss√≠veis problemas em ambientes multithread</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Impasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Condi√ß√£o de corrida</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Espera ocupada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inani√ß√£o de thread</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">M√©todos de sincroniza√ß√£o</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intertravado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitor.Enter, Monitor.Exit, bloquear</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitor.Wait, Monitor.Pulse [Tudo]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A fam√≠lia ResetEvent</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√µes</a> </li></ul><br><a name="habracut"></a><a name="SharedResources"></a><br><h2>  Sobre recursos compartilhados </h2><br>  Voc√™ n√£o pode escrever um programa cujo trabalho se baseie em v√°rios threads sem ter recursos compartilhados.  Mesmo que funcione no seu n√≠vel de abstra√ß√£o atual, voc√™ descobrir√° que ele realmente compartilhou recursos assim que descer um ou mais n√≠veis de abstra√ß√£o.  Aqui est√£o alguns exemplos: <br><br>  <b>Exemplo 1:</b> <br><br>  Para evitar poss√≠veis problemas, fa√ßa com que os threads funcionem com arquivos diferentes, um arquivo para cada thread.  Parece que o programa n√£o possui recursos compartilhados. <br><br>  Ao descer alguns n√≠veis, voc√™ fica sabendo que existe apenas um disco r√≠gido, e cabe ao driver ou ao sistema operacional encontrar uma solu√ß√£o para problemas com o acesso ao disco r√≠gido. <br><br>  <b>Exemplo 2:</b> <br><br>  Depois de ler o <i>exemplo 1</i> , voc√™ decidiu colocar os arquivos em duas m√°quinas remotas diferentes com hardware e sistemas operacionais fisicamente diferentes.  Voc√™ tamb√©m mant√©m duas conex√µes FTP ou NFS diferentes. <br><br>  Ao descer alguns n√≠veis novamente, voc√™ entende que nada realmente mudou e o problema do acesso competitivo agora est√° delegado no driver da placa de rede ou no sistema operacional da m√°quina em que o programa est√° sendo executado. <br><br>  <b>Exemplo 3:</b> <br><br>  Depois de puxar a maior parte do seu cabelo durante as tentativas de provar que voc√™ pode escrever um programa multiencadeado, voc√™ decide abandonar os arquivos completamente e mover os c√°lculos para dois objetos diferentes, com os links para cada um dos objetos dispon√≠veis apenas para suas especificidades. t√≥picos. <br><br>  Para martelar a √∫ltima d√∫zia de pregos no caix√£o dessa id√©ia: um tempo de execu√ß√£o e o Garbage Collector, um planejador de encadeamentos, uma fisicamente uma RAM unificada e um processador ainda s√£o considerados recursos compartilhados. <br><br>  Portanto, aprendemos que √© imposs√≠vel escrever um programa multiencadeado sem recursos compartilhados em todos os n√≠veis de abstra√ß√£o e em todo o escopo da pilha de tecnologia.  Felizmente, cada n√≠vel de abstra√ß√£o (como regra geral) cuida parcial ou totalmente dos problemas de acesso competitivo ou apenas o nega imediatamente (exemplo: qualquer estrutura de interface do usu√°rio n√£o permite trabalhar com elementos de diferentes threads).  Normalmente, os problemas com recursos compartilhados aparecem no seu n√≠vel de abstra√ß√£o atual.  Para cuidar deles, √© introduzido o conceito de sincroniza√ß√£o. <br><a name="Problems"></a><br><h2>  Poss√≠veis problemas em ambientes multithread </h2><br>  Podemos classificar erros de software nas seguintes categorias: <br><ol><li>  O programa n√£o produz resultado - trava ou congela. </li><li>  O programa apresenta um resultado incorreto. </li><li>  O programa produz um resultado correto, mas n√£o atende a alguns requisitos n√£o relacionados √† fun√ß√£o - gasta muito tempo ou recursos. </li></ol><br>  Em ambientes multithread, os principais problemas que resultam nos erros 1 e 2 s√£o o <b>impasse</b> e a <b>condi√ß√£o de corrida</b> . <br><br><a name="Deadlock"></a><br><h3>  Impasse </h3><br>  O impasse √© um bloqueio m√∫tuo.  Existem muitas varia√ß√µes de um impasse.  O seguinte pode ser considerado como o mais comum: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Enquanto o <b>Thread # 1</b> estava fazendo algo, o <b>Thread # 2</b> bloqueou o recurso <b>B.</b>  Algum tempo depois, o <b>thread n¬∫ 1</b> bloqueou o recurso <b>A</b> e estava tentando bloquear o recurso B. infelizmente, isso nunca acontecer√° porque o <b>thread n¬∫ 2</b> liberar√° o recurso <b>B apenas</b> ap√≥s o bloqueio do recurso <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Condi√ß√£o de corrida </h3><br>  Condi√ß√£o de corrida √© uma situa√ß√£o em que ambos, o comportamento e os resultados dos c√°lculos dependem do planejador de encadeamentos do ambiente de execu√ß√£o <br><br>  O problema √© que seu programa pode funcionar incorretamente uma vez em cem, ou mesmo em um milh√£o. <br><br>  As coisas podem piorar quando os problemas ocorrem em tr√™s.  Por exemplo, o comportamento espec√≠fico do planejador de encadeamentos pode levar a um conflito m√∫tuo. <br><br>  Al√©m desses dois problemas que levam a erros expl√≠citos, tamb√©m existem problemas que, se n√£o levarem a resultados de c√°lculos incorretos, ainda podem levar o programa a levar muito mais tempo ou recursos para produzir o resultado desejado.  Dois desses problemas s√£o <b>Busy Wait</b> e <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Espera ocupada </h3><br>  A espera ocupada √© um problema que ocorre quando o programa gasta recursos do processador em espera e n√£o em c√°lculo. <br><br>  Normalmente, esse problema √© semelhante ao seguinte: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Este √© um exemplo de c√≥digo extremamente ruim, pois ocupa totalmente um n√∫cleo do seu processador sem realmente fazer nada produtivo.  Esse c√≥digo s√≥ pode ser justificado quando √© extremamente importante processar rapidamente uma altera√ß√£o de um valor em um thread diferente.  E com 'rapidamente' quero dizer que voc√™ n√£o pode esperar nem por alguns nanossegundos.  Em todos os outros casos, ou seja, em todos os casos em que uma mente razo√°vel possa surgir, √© muito mais conveniente usar as varia√ß√µes do ResetEvent e suas vers√µes Slim.  Falaremos sobre eles um pouco mais tarde. <br><br>  Provavelmente, alguns leitores sugeririam resolver o problema de um n√∫cleo estar totalmente ocupado com a espera adicionando Thread.Sleep (1) (ou algo semelhante) ao ciclo.  Embora ele resolva esse problema, um novo ser√° criado - o tempo necess√°rio para reagir √†s altera√ß√µes ser√° de 0,5 ms, em m√©dia.  Por um lado, n√£o √© muito, mas por outro lado, esse valor √© catastroficamente mais alto do que o que podemos alcan√ßar usando primitivas de sincroniza√ß√£o da fam√≠lia ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Inani√ß√£o de thread </h3><br>  Aus√™ncia de Thread √© um problema com o programa com muitos threads em opera√ß√£o simult√¢nea.  Aqui, estamos falando especificamente sobre os segmentos ocupados com o c√°lculo, e n√£o com a espera de uma resposta de algum pedido de veicula√ß√£o.  Com esse problema, perdemos os poss√≠veis benef√≠cios de desempenho que acompanham os threads porque o processador gasta muito tempo na altern√¢ncia de contextos. <br><br>  Voc√™ pode encontrar esses problemas usando v√°rios criadores de perfil.  A seguir, √© apresentada uma captura de tela do profiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotTrace que</a> funciona no modo Linha de tempo <br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(clique para ampliar).</i> <br><br>  Normalmente, os programas que n√£o sofrem com a inani√ß√£o do encadeamento n√£o possuem nenhuma se√ß√£o rosa nos gr√°ficos que representam os encadeamentos.  Al√©m disso, na categoria Subsistemas, podemos ver que o programa estava aguardando CPU por 30,6% do tempo. <br><br>  Quando esse problema √© diagnosticado, voc√™ pode resolv√™-lo de maneira simples: voc√™ iniciou muitos threads de uma s√≥ vez, portanto, inicie menos threads. <br><a name="SyncPrimitives"></a><br><h2>  M√©todos de sincroniza√ß√£o </h2><br><a name="Interlocked"></a><br><h3>  Intertravado </h3><br>  Este √© provavelmente o m√©todo de sincroniza√ß√£o mais leve.  Intertravado √© um conjunto de opera√ß√µes at√¥micas simples.  Quando uma opera√ß√£o at√¥mica est√° sendo executada, nada pode acontecer.  No .NET, Interlocked √© representado pela classe est√°tica de mesmo nome com uma sele√ß√£o de m√©todos, cada um deles implementando uma opera√ß√£o at√¥mica. <br><br>  Para perceber o horror final das opera√ß√µes n√£o at√¥micas, tente escrever um programa que inicie 10 threads, cada um deles incrementando a mesma vari√°vel um milh√£o de vezes.  Quando eles terminarem seu trabalho, imprima o valor dessa vari√°vel.  Infelizmente, ser√° muito diferente de 10 milh√µes.  Al√©m disso, ser√° diferente sempre que voc√™ executar o programa.  Isso acontece porque mesmo opera√ß√µes simples como o incremento n√£o s√£o at√¥micas e incluem a extra√ß√£o de valor da mem√≥ria, o c√°lculo do novo valor e a grava√ß√£o na mem√≥ria novamente.  Portanto, dois encadeamentos podem fazer qualquer uma dessas opera√ß√µes e um incremento ser√° perdido nesse caso. <br><br>  A classe Interlocked fornece os m√©todos de Incremento / Decremento, e n√£o √© dif√≠cil adivinhar o que eles devem fazer.  Eles s√£o realmente √∫teis se voc√™ processar dados em v√°rios threads e calcular alguma coisa.  Esse c√≥digo funcionar√° muito mais r√°pido que o bloqueio cl√°ssico.  Se us√°ssemos o Interlocked na situa√ß√£o descrita no par√°grafo anterior, o programa produziria com seguran√ßa um valor de 10 milh√µes em qualquer cen√°rio. <br><br>  A fun√ß√£o do m√©todo CompareExchange n√£o √© t√£o √≥bvia.  No entanto, sua exist√™ncia permite a implementa√ß√£o de muitos algoritmos interessantes.  Mais importante ainda, os da fam√≠lia sem bloqueio. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Este m√©todo usa tr√™s valores.  O primeiro √© passado por uma refer√™ncia e √© o valor que ser√° alterado para o segundo se o local1 for igual a comparar e quando a compara√ß√£o for realizada.  O valor original de location1 ser√° retornado.  Isso parece complicado, por isso √© mais f√°cil escrever um peda√ßo de c√≥digo que executa as mesmas opera√ß√µes que o CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  A √∫nica diferen√ßa √© que a classe Interlocked implementa isso de maneira at√¥mica.  Portanto, se escrev√™ssemos esse c√≥digo, poder√≠amos enfrentar um cen√°rio no qual a condi√ß√£o location1 == comparand j√° foi atendida.  Mas quando a instru√ß√£o location1 = value est√° sendo executada, um encadeamento diferente j√° alterou o valor location1, portanto ser√° perdido. <br><br>  Podemos encontrar um bom exemplo de como esse m√©todo pode ser usado no c√≥digo que o compilador gera para qualquer evento C #. <br><br>  Vamos escrever uma classe simples com um evento chamado MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Agora, vamos criar o projeto na configura√ß√£o da vers√£o e abrir a constru√ß√£o atrav√©s do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotPeek</a> com a op√ß√£o "Mostrar c√≥digo gerado pelo compilador" ativada: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Aqui, podemos ver que o compilador gerou um algoritmo bastante complexo nos bastidores.  Esse algoritmo nos impede de perder uma assinatura para o evento no qual alguns threads s√£o simultaneamente inscritos nesse evento.  Vamos elaborar o m√©todo add, mantendo em mente o que o m√©todo CompareExchange faz nos bastidores: <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Isso √© muito mais gerenci√°vel, mas provavelmente ainda requer uma explica√ß√£o.  √â assim que eu descreveria o algoritmo: <br><br>  <i>Se MyEvent ainda for o mesmo que era no momento em que come√ßamos a executar o Delegate.Combine, defina-o como o que Delegate.Combine retorna.</i>  <i>Se n√£o for o caso, tente novamente at√© que funcione.</i> <br><br>  Dessa forma, as assinaturas nunca ser√£o perdidas.  Voc√™ precisar√° resolver um problema semelhante se desejar implementar uma matriz din√¢mica, segura para threads e sem bloqueios.  Se v√°rios encadeamentos come√ßarem a adicionar elementos a essa matriz de repente, √© importante que todos esses elementos sejam adicionados com √™xito. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, bloquear </h3><br>  Essas constru√ß√µes s√£o usadas para sincroniza√ß√£o de threads com mais freq√º√™ncia.  Eles implementam o conceito de uma se√ß√£o cr√≠tica: ou seja, o c√≥digo gravado entre as chamadas Monitor.Enter e Monitor.Exit s√≥ pode ser executado em um recurso em um ponto do tempo por apenas um encadeamento.  O operador de bloqueio serve como a√ß√∫car de sintaxe nas chamadas Enter / Exit encerradas no try-finalmente.  Uma qualidade agrad√°vel da se√ß√£o cr√≠tica no .NET √© que ele suporta a reentrada.  Isso significa que o seguinte c√≥digo pode ser executado sem problemas reais: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  √â improv√°vel que algu√©m escreva dessa maneira exata, mas se voc√™ espalhar esse c√≥digo entre alguns m√©todos pela profundidade da pilha de chamadas, esse recurso poder√° economizar alguns IFs.  Para que esse truque funcione, os desenvolvedores do .NET precisaram adicionar uma limita√ß√£o - voc√™ s√≥ pode usar inst√¢ncias de tipos de refer√™ncia como um objeto de sincroniza√ß√£o e alguns bytes s√£o adicionados a cada objeto em que o identificador de encadeamento ser√° gravado. <br><br>  Essa peculiaridade do processo de trabalho da se√ß√£o cr√≠tica em C # imp√µe uma limita√ß√£o interessante ao operador de bloqueio: voc√™ n√£o pode usar o operador de espera dentro do operador de bloqueio.  No in√≠cio, isso me surpreendeu, pois uma constru√ß√£o semelhante de Monitor-Entrada / Sa√≠da de tentativa e finalmente pode ser compilada.  Qual √© o problema?  √â importante reler o par√°grafo anterior e aplicar algum conhecimento de como funciona o ass√≠ncrono / espera: o c√≥digo ap√≥s a espera n√£o ser√° executado no mesmo encadeamento que o c√≥digo antes da espera.  Isso depende do contexto de sincroniza√ß√£o e se o m√©todo ConfigureAwait √© chamado ou n√£o.  A partir disso, segue-se que Monitor.Exit pode ser executado em um thread diferente de Monitor.Enter, o que levar√° ao lan√ßamento de SynchronizationLockException.  Se voc√™ n√£o acredita em mim, tente executar o seguinte c√≥digo em um aplicativo de console - ele ir√° gerar um <b>SynchronizationLockException</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Vale a pena notar que, em um aplicativo WinForms ou WPF, esse c√≥digo funcionar√° corretamente se voc√™ o chamar do thread principal, pois haver√° um contexto de sincroniza√ß√£o que implementa o retorno ao UI-Thread ap√≥s a chamada em espera.  De qualquer forma, √© melhor n√£o brincar com se√ß√µes cr√≠ticas no contexto de um c√≥digo que cont√©m o operador aguardar.  Nesses exemplos, √© melhor usar as primitivas de sincroniza√ß√£o que veremos um pouco mais adiante. <br><br>  Enquanto estamos no t√≥pico de se√ß√µes cr√≠ticas do .NET, √© importante mencionar mais uma peculiaridade de como elas s√£o implementadas.  Uma se√ß√£o cr√≠tica no .NET funciona de dois modos: espera de rota√ß√£o e espera de n√∫cleo.  Podemos representar o algoritmo spin-wait como o seguinte pseudoc√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Essa otimiza√ß√£o √© direcionada para capturar uma se√ß√£o cr√≠tica o mais r√°pido poss√≠vel em um curto per√≠odo de tempo, com base em que, mesmo que o recurso esteja ocupado atualmente, ele ser√° liberado muito em breve.  Se isso n√£o acontecer em um curto per√≠odo de tempo, o thread passar√° para espera no modo principal, o que leva tempo - assim como voltar da espera.  Os desenvolvedores do .NET otimizaram o cen√°rio de blocos curtos, tanto quanto poss√≠vel.  Infelizmente, se muitos threads come√ßarem a puxar a se√ß√£o cr√≠tica entre si, isso poder√° levar a uma carga repentina na CPU. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Tendo mencionado o algoritmo de espera c√≠clica (spin-wait), vale a pena falar sobre as estruturas SpinLock e SpinWait da BCL.  Voc√™ deve us√°-los se houver motivos para supor que sempre ser√° poss√≠vel obter um bloco muito rapidamente.  Por outro lado, voc√™ realmente n√£o deve pensar neles at√© que os resultados da cria√ß√£o de perfil mostrem que o gargalo do seu programa √© causado pelo uso de outras primitivas de sincroniza√ß√£o. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Tudo] </h3><br>  Devemos olhar para esses dois m√©todos lado a lado.  Com a ajuda deles, voc√™ pode implementar v√°rios cen√°rios Produtor-Consumidor. <br><br>  Producer-Consumer √© um padr√£o de design multiprocesso / multithread que implica um ou mais threads / processos que produzem dados e um ou mais processos / threads que processam esses dados.  Geralmente, uma cole√ß√£o compartilhada √© usada. <br><br>  Ambos os m√©todos podem ser chamados apenas por um thread que atualmente possui um bloco.  O m√©todo Wait liberar√° o bloco e congelar√° at√© que outro thread chame Pulse. <br><br>  Como demonstra√ß√£o disso, escrevi um pequeno exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Usei uma imagem em vez de texto aqui para mostrar com precis√£o a ordem de execu√ß√£o das instru√ß√µes)</i> <br>  <b>Explica√ß√£o:</b> Defino uma lat√™ncia de 100 ms ao iniciar o segundo encadeamento para garantir especificamente que ele ser√° executado posteriormente. <br>  - T1: Linha 2, o encadeamento √© iniciado <br>  - T1: Linha 3, o thread entra em uma se√ß√£o cr√≠tica <br>  - T1: Linha 6, o encadeamento entra em suspens√£o <br>  - T2: Linha 3, o encadeamento √© iniciado <br>  - T2: Linha 4, congela e aguarda a se√ß√£o cr√≠tica <br>  - T1: Linha 7, permite que a se√ß√£o cr√≠tica congele e congele enquanto espera o pulso sair <br>  - T2: Linha 8, entra na se√ß√£o cr√≠tica <br>  - T2: Linha 11 sinaliza T1 com a ajuda do Pulse <br>  - T2: Linha 14, sai da se√ß√£o cr√≠tica.  T1 n√£o pode continuar sua execu√ß√£o antes que isso aconte√ßa. <br>  - T1: Linha 15 sai da espera <br>  - T1: Linha 16, que sai da se√ß√£o cr√≠tica <br><br>  <i>H√° uma observa√ß√£o importante no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MSDN</a> sobre o uso dos m√©todos Pulse / Wait: O Monitor n√£o armazena as informa√ß√µes de estado, o que significa que chamar o m√©todo Pulse antes do m√©todo Wait pode levar a um impasse.</i>  <i>Se esse caso for poss√≠vel, √© melhor usar uma das classes da fam√≠lia ResetEvent.</i> <br><br>  O exemplo anterior mostra claramente como os m√©todos Wait / Pulse da classe Monitor funcionam, mas ainda deixa algumas perguntas sobre os casos em que devemos us√°-los.  Um bom exemplo √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">essa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementa√ß√£o</a> do BlockingQueue &lt;T&gt;.  Por outro lado, a implementa√ß√£o do BlockingCollection &lt;T&gt; do System.Collections.Concurrent usa o SemaphoreSlim para sincroniza√ß√£o. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Eu amo muito essa primitiva de sincroniza√ß√£o e √© representada pela classe com o mesmo nome no espa√ßo para nome System.Threading.  Eu acho que muitos programas funcionariam muito melhor se seus desenvolvedores usassem essa classe em vez do bloqueio padr√£o. <br><br>  Id√©ia: muitos t√≥picos podem ler, e o √∫nico pode escrever.  Quando um encadeamento deseja gravar, novas leituras n√£o podem ser iniciadas - elas aguardam a grava√ß√£o at√© o fim.  H√° tamb√©m o conceito de upgrade-leitura-bloqueio.  Voc√™ pode us√°-lo quando, durante o processo de leitura, entender que √© necess√°rio escrever algo - esse bloqueio ser√° transformado em bloqueio de grava√ß√£o em uma opera√ß√£o at√¥mica. <br><br>  No espa√ßo para nome System.Threading, tamb√©m h√° a classe ReadWriteLock, mas √© altamente recomend√°vel n√£o us√°-la para novos desenvolvimentos.  A vers√£o Slim ajudar√° a evitar casos que levam a conflitos e permite capturar rapidamente um bloco, pois suporta a sincroniza√ß√£o no modo espera por rota√ß√£o antes de passar para o modo principal. <br><br>  Se voc√™ n√£o conhecia essa classe antes de ler este artigo, acho que agora j√° se lembrou de muitos exemplos do c√≥digo recentemente escrito, em que essa abordagem de blocos permitia que o programa funcionasse efetivamente. <br><br>  A interface da classe ReaderWriterLockSlim √© simples e f√°cil de entender, mas n√£o √© t√£o confort√°vel de usar: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Eu geralmente gosto de envolv√™-lo em uma classe - isso torna muito mais pr√°tico. <br><br>  <i><b>Id√©ia:</b> crie m√©todos Read / WriteLock que retornem um objeto junto com o m√©todo Dispose.</i>  <i>Voc√™ pode acess√°-los em Usando, e provavelmente n√£o ser√° muito diferente do bloqueio padr√£o quando se trata do n√∫mero de linhas.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Isso nos permite escrever o seguinte posteriormente no c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  A fam√≠lia ResetEvent </h3><br>  Incluo as seguintes classes nessa fam√≠lia: ManualResetEvent, ManualResetEventSlim e AutoResetEvent. <br><br>  A classe ManualResetEvent, sua vers√£o Slim e a classe AutoResetEvent podem existir em dois estados: <br><br>  - N√£o sinalizado - nesse estado, todos os encadeamentos que chamaram WaitOne congelam at√© que o evento mude para um estado sinalizado. <br>  - Sinalizado - nesse estado, todos os threads congelados anteriormente em uma chamada WaitOne s√£o liberados.  Todas as novas chamadas do WaitOne em um evento sinalizado s√£o realizadas de forma relativamente instant√¢nea. <br><br>  O AutoResetEvent difere de ManualResetEvent, pois alterna automaticamente para o estado n√£o sinalizado ap√≥s liberar <b>exatamente um segmento</b> .  Se alguns threads estiverem congelados enquanto aguarda o AutoResetEvent, a chamada de Set liberar√° apenas um thread aleat√≥rio, em oposi√ß√£o ao ManualResetEvent que libera todos os threads. <br><br>  Vejamos um exemplo de como o AutoResetEvent funciona: <br><br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>  Nesses exemplos, podemos ver que o evento muda para o estado n√£o sinalizado automaticamente somente depois de liberar o encadeamento que foi congelado em uma chamada WaitOne. <br><br>  Ao contr√°rio do ReaderWriterLock, o ManualResetEvent n√£o √© considerado obsoleto mesmo depois que a vers√£o Slim apareceu.  Esta vers√£o Slim da classe pode ser eficaz para esperas curtas, como acontece no modo de espera por rota√ß√£o;  a vers√£o padr√£o √© boa para longas esperas. <br><br>  Al√©m das classes ManualResetEvent e AutoResetEvent, tamb√©m h√° a classe CountdownEvent.  Essa classe √© muito √∫til para implementar algoritmos que mesclam resultados juntos ap√≥s uma se√ß√£o paralela.  Essa abordagem √© conhecida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jun√ß√£o de garfo</a> .  H√° um √≥timo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> dedicado a esta classe, ent√£o n√£o vou descrev√™-lo em detalhes aqui. <br><a name="Conclusions"></a><br><h2>  Conclus√µes </h2><br><ul><li>  Ao trabalhar com encadeamentos, h√° dois problemas que podem levar a resultados incorretos ou at√© a aus√™ncia de resultados - condi√ß√£o de corrida e conflito. </li><li>  Os problemas que podem fazer com que o programa gaste mais tempo ou recursos s√£o falta de thread e espera ocupada. </li><li>  O .NET fornece v√°rias maneiras de sincronizar threads. </li><li>  Existem dois modos de espera de bloco - Spin Wait e Core Wait.  Algumas primitivas de sincroniza√ß√£o de threads no .NET usam os dois. </li><li>  Interlocked √© um conjunto de opera√ß√µes at√¥micas que podem ser usadas para implementar algoritmos sem bloqueio.  √â a primitiva de sincroniza√ß√£o mais r√°pida. </li><li>  Os operadores lock e Monitor.Enter / Exit implementam o conceito de uma se√ß√£o cr√≠tica - um fragmento de c√≥digo que s√≥ pode ser executado por um encadeamento em um ponto do tempo. </li><li>  Os m√©todos Monitor.Pulse / Wait s√£o √∫teis para implementar cen√°rios Produtor-Consumidor. </li><li>  O ReaderWriterLockSlim pode ser mais √∫til do que os casos de bloqueio padr√£o quando se espera uma leitura paralela. </li><li>  A fam√≠lia de classes ResetEvent pode ser √∫til para sincroniza√ß√£o de threads. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461471/">https://habr.com/ru/post/pt461471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461461/index.html">O backup prospera na era da nuvem, mas os rolos de fita n√£o s√£o esquecidos. Conversa com Veeam</a></li>
<li><a href="../pt461463/index.html">Processos de neg√≥cios em empresas: especula√ß√£o e realidade. Ilumine a luz com R</a></li>
<li><a href="../pt461465/index.html">Guia de Medi√ß√£o</a></li>
<li><a href="../pt461467/index.html">Um exemplo de cria√ß√£o de aplicativos Makefile for Go</a></li>
<li><a href="../pt461469/index.html">Como √© ouvir c√≥digo a 1000 palavras por minuto</a></li>
<li><a href="../pt461473/index.html">Algoritmos de depura√ß√£o em gr√°ficos - agora com imagens</a></li>
<li><a href="../pt461475/index.html">AMA com Habr.1011</a></li>
<li><a href="../pt461483/index.html">Balanceamento de carga Openstack</a></li>
<li><a href="../pt461487/index.html">Tarefas Mini CTF</a></li>
<li><a href="../pt461493/index.html">O Django 3.0 ser√° ass√≠ncrono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>