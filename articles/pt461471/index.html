<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍⚖️ 🤔 👷🏻 Ferramentas para trabalhar com multithreading e assincronia - Parte 2 🐙 🤲🏽 ⚪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originalmente, eu publiquei este artigo no blog CodingSight . 
 Também está disponível em russo aqui . 

 Este artigo contém a segunda parte do meu di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ferramentas para trabalhar com multithreading e assincronia - Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461471/">  <i>Originalmente, eu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publiquei</a> este artigo no blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CodingSight</a> .</i> <i><br></i>  <i>Também está disponível em russo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .</i> <br><br>  Este artigo contém a segunda parte do meu discurso no meetup multithreading.  Você pode dar uma olhada na primeira parte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Na primeira parte, concentrei-me no conjunto básico de ferramentas usadas para iniciar um encadeamento ou uma tarefa, as maneiras de rastrear seu estado e algumas outras coisas interessantes, como o PLinq.  Nesta parte, vou corrigir os problemas que você pode encontrar em um ambiente com vários threads e algumas maneiras de resolvê-los. <br><br><h2>  Conteúdo </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobre recursos compartilhados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Possíveis problemas em ambientes multithread</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Impasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Condição de corrida</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Espera ocupada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inanição de thread</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Métodos de sincronização</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intertravado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitor.Enter, Monitor.Exit, bloquear</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitor.Wait, Monitor.Pulse [Tudo]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A família ResetEvent</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclusões</a> </li></ul><br><a name="habracut"></a><a name="SharedResources"></a><br><h2>  Sobre recursos compartilhados </h2><br>  Você não pode escrever um programa cujo trabalho se baseie em vários threads sem ter recursos compartilhados.  Mesmo que funcione no seu nível de abstração atual, você descobrirá que ele realmente compartilhou recursos assim que descer um ou mais níveis de abstração.  Aqui estão alguns exemplos: <br><br>  <b>Exemplo 1:</b> <br><br>  Para evitar possíveis problemas, faça com que os threads funcionem com arquivos diferentes, um arquivo para cada thread.  Parece que o programa não possui recursos compartilhados. <br><br>  Ao descer alguns níveis, você fica sabendo que existe apenas um disco rígido, e cabe ao driver ou ao sistema operacional encontrar uma solução para problemas com o acesso ao disco rígido. <br><br>  <b>Exemplo 2:</b> <br><br>  Depois de ler o <i>exemplo 1</i> , você decidiu colocar os arquivos em duas máquinas remotas diferentes com hardware e sistemas operacionais fisicamente diferentes.  Você também mantém duas conexões FTP ou NFS diferentes. <br><br>  Ao descer alguns níveis novamente, você entende que nada realmente mudou e o problema do acesso competitivo agora está delegado no driver da placa de rede ou no sistema operacional da máquina em que o programa está sendo executado. <br><br>  <b>Exemplo 3:</b> <br><br>  Depois de puxar a maior parte do seu cabelo durante as tentativas de provar que você pode escrever um programa multiencadeado, você decide abandonar os arquivos completamente e mover os cálculos para dois objetos diferentes, com os links para cada um dos objetos disponíveis apenas para suas especificidades. tópicos. <br><br>  Para martelar a última dúzia de pregos no caixão dessa idéia: um tempo de execução e o Garbage Collector, um planejador de encadeamentos, uma fisicamente uma RAM unificada e um processador ainda são considerados recursos compartilhados. <br><br>  Portanto, aprendemos que é impossível escrever um programa multiencadeado sem recursos compartilhados em todos os níveis de abstração e em todo o escopo da pilha de tecnologia.  Felizmente, cada nível de abstração (como regra geral) cuida parcial ou totalmente dos problemas de acesso competitivo ou apenas o nega imediatamente (exemplo: qualquer estrutura de interface do usuário não permite trabalhar com elementos de diferentes threads).  Normalmente, os problemas com recursos compartilhados aparecem no seu nível de abstração atual.  Para cuidar deles, é introduzido o conceito de sincronização. <br><a name="Problems"></a><br><h2>  Possíveis problemas em ambientes multithread </h2><br>  Podemos classificar erros de software nas seguintes categorias: <br><ol><li>  O programa não produz resultado - trava ou congela. </li><li>  O programa apresenta um resultado incorreto. </li><li>  O programa produz um resultado correto, mas não atende a alguns requisitos não relacionados à função - gasta muito tempo ou recursos. </li></ol><br>  Em ambientes multithread, os principais problemas que resultam nos erros 1 e 2 são o <b>impasse</b> e a <b>condição de corrida</b> . <br><br><a name="Deadlock"></a><br><h3>  Impasse </h3><br>  O impasse é um bloqueio mútuo.  Existem muitas variações de um impasse.  O seguinte pode ser considerado como o mais comum: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Enquanto o <b>Thread # 1</b> estava fazendo algo, o <b>Thread # 2</b> bloqueou o recurso <b>B.</b>  Algum tempo depois, o <b>thread nº 1</b> bloqueou o recurso <b>A</b> e estava tentando bloquear o recurso B. infelizmente, isso nunca acontecerá porque o <b>thread nº 2</b> liberará o recurso <b>B apenas</b> após o bloqueio do recurso <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Condição de corrida </h3><br>  Condição de corrida é uma situação em que ambos, o comportamento e os resultados dos cálculos dependem do planejador de encadeamentos do ambiente de execução <br><br>  O problema é que seu programa pode funcionar incorretamente uma vez em cem, ou mesmo em um milhão. <br><br>  As coisas podem piorar quando os problemas ocorrem em três.  Por exemplo, o comportamento específico do planejador de encadeamentos pode levar a um conflito mútuo. <br><br>  Além desses dois problemas que levam a erros explícitos, também existem problemas que, se não levarem a resultados de cálculos incorretos, ainda podem levar o programa a levar muito mais tempo ou recursos para produzir o resultado desejado.  Dois desses problemas são <b>Busy Wait</b> e <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Espera ocupada </h3><br>  A espera ocupada é um problema que ocorre quando o programa gasta recursos do processador em espera e não em cálculo. <br><br>  Normalmente, esse problema é semelhante ao seguinte: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Este é um exemplo de código extremamente ruim, pois ocupa totalmente um núcleo do seu processador sem realmente fazer nada produtivo.  Esse código só pode ser justificado quando é extremamente importante processar rapidamente uma alteração de um valor em um thread diferente.  E com 'rapidamente' quero dizer que você não pode esperar nem por alguns nanossegundos.  Em todos os outros casos, ou seja, em todos os casos em que uma mente razoável possa surgir, é muito mais conveniente usar as variações do ResetEvent e suas versões Slim.  Falaremos sobre eles um pouco mais tarde. <br><br>  Provavelmente, alguns leitores sugeririam resolver o problema de um núcleo estar totalmente ocupado com a espera adicionando Thread.Sleep (1) (ou algo semelhante) ao ciclo.  Embora ele resolva esse problema, um novo será criado - o tempo necessário para reagir às alterações será de 0,5 ms, em média.  Por um lado, não é muito, mas por outro lado, esse valor é catastroficamente mais alto do que o que podemos alcançar usando primitivas de sincronização da família ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Inanição de thread </h3><br>  Ausência de Thread é um problema com o programa com muitos threads em operação simultânea.  Aqui, estamos falando especificamente sobre os segmentos ocupados com o cálculo, e não com a espera de uma resposta de algum pedido de veiculação.  Com esse problema, perdemos os possíveis benefícios de desempenho que acompanham os threads porque o processador gasta muito tempo na alternância de contextos. <br><br>  Você pode encontrar esses problemas usando vários criadores de perfil.  A seguir, é apresentada uma captura de tela do profiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotTrace que</a> funciona no modo Linha de tempo <br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(clique para ampliar).</i> <br><br>  Normalmente, os programas que não sofrem com a inanição do encadeamento não possuem nenhuma seção rosa nos gráficos que representam os encadeamentos.  Além disso, na categoria Subsistemas, podemos ver que o programa estava aguardando CPU por 30,6% do tempo. <br><br>  Quando esse problema é diagnosticado, você pode resolvê-lo de maneira simples: você iniciou muitos threads de uma só vez, portanto, inicie menos threads. <br><a name="SyncPrimitives"></a><br><h2>  Métodos de sincronização </h2><br><a name="Interlocked"></a><br><h3>  Intertravado </h3><br>  Este é provavelmente o método de sincronização mais leve.  Intertravado é um conjunto de operações atômicas simples.  Quando uma operação atômica está sendo executada, nada pode acontecer.  No .NET, Interlocked é representado pela classe estática de mesmo nome com uma seleção de métodos, cada um deles implementando uma operação atômica. <br><br>  Para perceber o horror final das operações não atômicas, tente escrever um programa que inicie 10 threads, cada um deles incrementando a mesma variável um milhão de vezes.  Quando eles terminarem seu trabalho, imprima o valor dessa variável.  Infelizmente, será muito diferente de 10 milhões.  Além disso, será diferente sempre que você executar o programa.  Isso acontece porque mesmo operações simples como o incremento não são atômicas e incluem a extração de valor da memória, o cálculo do novo valor e a gravação na memória novamente.  Portanto, dois encadeamentos podem fazer qualquer uma dessas operações e um incremento será perdido nesse caso. <br><br>  A classe Interlocked fornece os métodos de Incremento / Decremento, e não é difícil adivinhar o que eles devem fazer.  Eles são realmente úteis se você processar dados em vários threads e calcular alguma coisa.  Esse código funcionará muito mais rápido que o bloqueio clássico.  Se usássemos o Interlocked na situação descrita no parágrafo anterior, o programa produziria com segurança um valor de 10 milhões em qualquer cenário. <br><br>  A função do método CompareExchange não é tão óbvia.  No entanto, sua existência permite a implementação de muitos algoritmos interessantes.  Mais importante ainda, os da família sem bloqueio. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Este método usa três valores.  O primeiro é passado por uma referência e é o valor que será alterado para o segundo se o local1 for igual a comparar e quando a comparação for realizada.  O valor original de location1 será retornado.  Isso parece complicado, por isso é mais fácil escrever um pedaço de código que executa as mesmas operações que o CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  A única diferença é que a classe Interlocked implementa isso de maneira atômica.  Portanto, se escrevêssemos esse código, poderíamos enfrentar um cenário no qual a condição location1 == comparand já foi atendida.  Mas quando a instrução location1 = value está sendo executada, um encadeamento diferente já alterou o valor location1, portanto será perdido. <br><br>  Podemos encontrar um bom exemplo de como esse método pode ser usado no código que o compilador gera para qualquer evento C #. <br><br>  Vamos escrever uma classe simples com um evento chamado MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Agora, vamos criar o projeto na configuração da versão e abrir a construção através do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotPeek</a> com a opção "Mostrar código gerado pelo compilador" ativada: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Aqui, podemos ver que o compilador gerou um algoritmo bastante complexo nos bastidores.  Esse algoritmo nos impede de perder uma assinatura para o evento no qual alguns threads são simultaneamente inscritos nesse evento.  Vamos elaborar o método add, mantendo em mente o que o método CompareExchange faz nos bastidores: <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Isso é muito mais gerenciável, mas provavelmente ainda requer uma explicação.  É assim que eu descreveria o algoritmo: <br><br>  <i>Se MyEvent ainda for o mesmo que era no momento em que começamos a executar o Delegate.Combine, defina-o como o que Delegate.Combine retorna.</i>  <i>Se não for o caso, tente novamente até que funcione.</i> <br><br>  Dessa forma, as assinaturas nunca serão perdidas.  Você precisará resolver um problema semelhante se desejar implementar uma matriz dinâmica, segura para threads e sem bloqueios.  Se vários encadeamentos começarem a adicionar elementos a essa matriz de repente, é importante que todos esses elementos sejam adicionados com êxito. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, bloquear </h3><br>  Essas construções são usadas para sincronização de threads com mais freqüência.  Eles implementam o conceito de uma seção crítica: ou seja, o código gravado entre as chamadas Monitor.Enter e Monitor.Exit só pode ser executado em um recurso em um ponto do tempo por apenas um encadeamento.  O operador de bloqueio serve como açúcar de sintaxe nas chamadas Enter / Exit encerradas no try-finalmente.  Uma qualidade agradável da seção crítica no .NET é que ele suporta a reentrada.  Isso significa que o seguinte código pode ser executado sem problemas reais: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  É improvável que alguém escreva dessa maneira exata, mas se você espalhar esse código entre alguns métodos pela profundidade da pilha de chamadas, esse recurso poderá economizar alguns IFs.  Para que esse truque funcione, os desenvolvedores do .NET precisaram adicionar uma limitação - você só pode usar instâncias de tipos de referência como um objeto de sincronização e alguns bytes são adicionados a cada objeto em que o identificador de encadeamento será gravado. <br><br>  Essa peculiaridade do processo de trabalho da seção crítica em C # impõe uma limitação interessante ao operador de bloqueio: você não pode usar o operador de espera dentro do operador de bloqueio.  No início, isso me surpreendeu, pois uma construção semelhante de Monitor-Entrada / Saída de tentativa e finalmente pode ser compilada.  Qual é o problema?  É importante reler o parágrafo anterior e aplicar algum conhecimento de como funciona o assíncrono / espera: o código após a espera não será executado no mesmo encadeamento que o código antes da espera.  Isso depende do contexto de sincronização e se o método ConfigureAwait é chamado ou não.  A partir disso, segue-se que Monitor.Exit pode ser executado em um thread diferente de Monitor.Enter, o que levará ao lançamento de SynchronizationLockException.  Se você não acredita em mim, tente executar o seguinte código em um aplicativo de console - ele irá gerar um <b>SynchronizationLockException</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Vale a pena notar que, em um aplicativo WinForms ou WPF, esse código funcionará corretamente se você o chamar do thread principal, pois haverá um contexto de sincronização que implementa o retorno ao UI-Thread após a chamada em espera.  De qualquer forma, é melhor não brincar com seções críticas no contexto de um código que contém o operador aguardar.  Nesses exemplos, é melhor usar as primitivas de sincronização que veremos um pouco mais adiante. <br><br>  Enquanto estamos no tópico de seções críticas do .NET, é importante mencionar mais uma peculiaridade de como elas são implementadas.  Uma seção crítica no .NET funciona de dois modos: espera de rotação e espera de núcleo.  Podemos representar o algoritmo spin-wait como o seguinte pseudocódigo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Essa otimização é direcionada para capturar uma seção crítica o mais rápido possível em um curto período de tempo, com base em que, mesmo que o recurso esteja ocupado atualmente, ele será liberado muito em breve.  Se isso não acontecer em um curto período de tempo, o thread passará para espera no modo principal, o que leva tempo - assim como voltar da espera.  Os desenvolvedores do .NET otimizaram o cenário de blocos curtos, tanto quanto possível.  Infelizmente, se muitos threads começarem a puxar a seção crítica entre si, isso poderá levar a uma carga repentina na CPU. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Tendo mencionado o algoritmo de espera cíclica (spin-wait), vale a pena falar sobre as estruturas SpinLock e SpinWait da BCL.  Você deve usá-los se houver motivos para supor que sempre será possível obter um bloco muito rapidamente.  Por outro lado, você realmente não deve pensar neles até que os resultados da criação de perfil mostrem que o gargalo do seu programa é causado pelo uso de outras primitivas de sincronização. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Tudo] </h3><br>  Devemos olhar para esses dois métodos lado a lado.  Com a ajuda deles, você pode implementar vários cenários Produtor-Consumidor. <br><br>  Producer-Consumer é um padrão de design multiprocesso / multithread que implica um ou mais threads / processos que produzem dados e um ou mais processos / threads que processam esses dados.  Geralmente, uma coleção compartilhada é usada. <br><br>  Ambos os métodos podem ser chamados apenas por um thread que atualmente possui um bloco.  O método Wait liberará o bloco e congelará até que outro thread chame Pulse. <br><br>  Como demonstração disso, escrevi um pequeno exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Usei uma imagem em vez de texto aqui para mostrar com precisão a ordem de execução das instruções)</i> <br>  <b>Explicação:</b> Defino uma latência de 100 ms ao iniciar o segundo encadeamento para garantir especificamente que ele será executado posteriormente. <br>  - T1: Linha 2, o encadeamento é iniciado <br>  - T1: Linha 3, o thread entra em uma seção crítica <br>  - T1: Linha 6, o encadeamento entra em suspensão <br>  - T2: Linha 3, o encadeamento é iniciado <br>  - T2: Linha 4, congela e aguarda a seção crítica <br>  - T1: Linha 7, permite que a seção crítica congele e congele enquanto espera o pulso sair <br>  - T2: Linha 8, entra na seção crítica <br>  - T2: Linha 11 sinaliza T1 com a ajuda do Pulse <br>  - T2: Linha 14, sai da seção crítica.  T1 não pode continuar sua execução antes que isso aconteça. <br>  - T1: Linha 15 sai da espera <br>  - T1: Linha 16, que sai da seção crítica <br><br>  <i>Há uma observação importante no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MSDN</a> sobre o uso dos métodos Pulse / Wait: O Monitor não armazena as informações de estado, o que significa que chamar o método Pulse antes do método Wait pode levar a um impasse.</i>  <i>Se esse caso for possível, é melhor usar uma das classes da família ResetEvent.</i> <br><br>  O exemplo anterior mostra claramente como os métodos Wait / Pulse da classe Monitor funcionam, mas ainda deixa algumas perguntas sobre os casos em que devemos usá-los.  Um bom exemplo é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">essa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementação</a> do BlockingQueue &lt;T&gt;.  Por outro lado, a implementação do BlockingCollection &lt;T&gt; do System.Collections.Concurrent usa o SemaphoreSlim para sincronização. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Eu amo muito essa primitiva de sincronização e é representada pela classe com o mesmo nome no espaço para nome System.Threading.  Eu acho que muitos programas funcionariam muito melhor se seus desenvolvedores usassem essa classe em vez do bloqueio padrão. <br><br>  Idéia: muitos tópicos podem ler, e o único pode escrever.  Quando um encadeamento deseja gravar, novas leituras não podem ser iniciadas - elas aguardam a gravação até o fim.  Há também o conceito de upgrade-leitura-bloqueio.  Você pode usá-lo quando, durante o processo de leitura, entender que é necessário escrever algo - esse bloqueio será transformado em bloqueio de gravação em uma operação atômica. <br><br>  No espaço para nome System.Threading, também há a classe ReadWriteLock, mas é altamente recomendável não usá-la para novos desenvolvimentos.  A versão Slim ajudará a evitar casos que levam a conflitos e permite capturar rapidamente um bloco, pois suporta a sincronização no modo espera por rotação antes de passar para o modo principal. <br><br>  Se você não conhecia essa classe antes de ler este artigo, acho que agora já se lembrou de muitos exemplos do código recentemente escrito, em que essa abordagem de blocos permitia que o programa funcionasse efetivamente. <br><br>  A interface da classe ReaderWriterLockSlim é simples e fácil de entender, mas não é tão confortável de usar: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Eu geralmente gosto de envolvê-lo em uma classe - isso torna muito mais prático. <br><br>  <i><b>Idéia:</b> crie métodos Read / WriteLock que retornem um objeto junto com o método Dispose.</i>  <i>Você pode acessá-los em Usando, e provavelmente não será muito diferente do bloqueio padrão quando se trata do número de linhas.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Isso nos permite escrever o seguinte posteriormente no código: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  A família ResetEvent </h3><br>  Incluo as seguintes classes nessa família: ManualResetEvent, ManualResetEventSlim e AutoResetEvent. <br><br>  A classe ManualResetEvent, sua versão Slim e a classe AutoResetEvent podem existir em dois estados: <br><br>  - Não sinalizado - nesse estado, todos os encadeamentos que chamaram WaitOne congelam até que o evento mude para um estado sinalizado. <br>  - Sinalizado - nesse estado, todos os threads congelados anteriormente em uma chamada WaitOne são liberados.  Todas as novas chamadas do WaitOne em um evento sinalizado são realizadas de forma relativamente instantânea. <br><br>  O AutoResetEvent difere de ManualResetEvent, pois alterna automaticamente para o estado não sinalizado após liberar <b>exatamente um segmento</b> .  Se alguns threads estiverem congelados enquanto aguarda o AutoResetEvent, a chamada de Set liberará apenas um thread aleatório, em oposição ao ManualResetEvent que libera todos os threads. <br><br>  Vejamos um exemplo de como o AutoResetEvent funciona: <br><br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>  Nesses exemplos, podemos ver que o evento muda para o estado não sinalizado automaticamente somente depois de liberar o encadeamento que foi congelado em uma chamada WaitOne. <br><br>  Ao contrário do ReaderWriterLock, o ManualResetEvent não é considerado obsoleto mesmo depois que a versão Slim apareceu.  Esta versão Slim da classe pode ser eficaz para esperas curtas, como acontece no modo de espera por rotação;  a versão padrão é boa para longas esperas. <br><br>  Além das classes ManualResetEvent e AutoResetEvent, também há a classe CountdownEvent.  Essa classe é muito útil para implementar algoritmos que mesclam resultados juntos após uma seção paralela.  Essa abordagem é conhecida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">junção de garfo</a> .  Há um ótimo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> dedicado a esta classe, então não vou descrevê-lo em detalhes aqui. <br><a name="Conclusions"></a><br><h2>  Conclusões </h2><br><ul><li>  Ao trabalhar com encadeamentos, há dois problemas que podem levar a resultados incorretos ou até a ausência de resultados - condição de corrida e conflito. </li><li>  Os problemas que podem fazer com que o programa gaste mais tempo ou recursos são falta de thread e espera ocupada. </li><li>  O .NET fornece várias maneiras de sincronizar threads. </li><li>  Existem dois modos de espera de bloco - Spin Wait e Core Wait.  Algumas primitivas de sincronização de threads no .NET usam os dois. </li><li>  Interlocked é um conjunto de operações atômicas que podem ser usadas para implementar algoritmos sem bloqueio.  É a primitiva de sincronização mais rápida. </li><li>  Os operadores lock e Monitor.Enter / Exit implementam o conceito de uma seção crítica - um fragmento de código que só pode ser executado por um encadeamento em um ponto do tempo. </li><li>  Os métodos Monitor.Pulse / Wait são úteis para implementar cenários Produtor-Consumidor. </li><li>  O ReaderWriterLockSlim pode ser mais útil do que os casos de bloqueio padrão quando se espera uma leitura paralela. </li><li>  A família de classes ResetEvent pode ser útil para sincronização de threads. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461471/">https://habr.com/ru/post/pt461471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461461/index.html">O backup prospera na era da nuvem, mas os rolos de fita não são esquecidos. Conversa com Veeam</a></li>
<li><a href="../pt461463/index.html">Processos de negócios em empresas: especulação e realidade. Ilumine a luz com R</a></li>
<li><a href="../pt461465/index.html">Guia de Medição</a></li>
<li><a href="../pt461467/index.html">Um exemplo de criação de aplicativos Makefile for Go</a></li>
<li><a href="../pt461469/index.html">Como é ouvir código a 1000 palavras por minuto</a></li>
<li><a href="../pt461473/index.html">Algoritmos de depuração em gráficos - agora com imagens</a></li>
<li><a href="../pt461475/index.html">AMA com Habr.1011</a></li>
<li><a href="../pt461483/index.html">Balanceamento de carga Openstack</a></li>
<li><a href="../pt461487/index.html">Tarefas Mini CTF</a></li>
<li><a href="../pt461493/index.html">O Django 3.0 será assíncrono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>