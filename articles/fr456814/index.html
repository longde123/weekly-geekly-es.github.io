<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕋 🆕 🙁 Apprenez la programmation fonctionnelle en Python en 10 minutes 🐘 👨‍🌾 👨🏾‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo: Chris Ried 

 Dans cet article, vous comprendrez ce qu'est un paradigme fonctionnel et comment utiliser la programmation fonctionnelle en Pytho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprenez la programmation fonctionnelle en Python en 10 minutes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456814/"><img src="https://habrastorage.org/getpro/habr/post_images/539/971/24e/53997124e1acc9aa28c273b0daa540b3.jpg" alt="image"><br>  <i>Photo:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chris Ried</a> <br><br>  Dans cet article, vous comprendrez ce qu'est un paradigme fonctionnel et comment utiliser la programmation fonctionnelle en Python.  Vous en apprendrez également sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">abstraction de liste</a> et d'autres compréhensions de liste. <br><br><h3>  Paradigme fonctionnel </h3><br>  Dans un paradigme impératif, vous écrivez un programme en spécifiant une séquence d'actions qui seront effectuées ultérieurement.  A ce moment, les états ( <i>approximativement Translator: variables, tableaux, etc.</i> ) changent.  Par exemple, laissez la variable A stocker la valeur 5, plus tard vous modifiez la valeur de cette variable.  Vous utilisez des variables pour que leurs valeurs changent. <a name="habracut"></a><br><br>  Dans un paradigme fonctionnel, vous ne dites pas à l'ordinateur quoi faire, mais spécifiez plutôt la nature des actions elles-mêmes.  Quel est le plus grand commun diviseur d'un nombre, le résultat des calculs de 1 à n, etc. <br><br>  Par conséquent, les variables ne changent pas.  Une fois qu'une variable est initialisée, sa valeur est sauvegardée pour toujours (notez que dans les langages fonctionnels purs, ils ne sont même pas appelés variables).  Par conséquent, dans le paradigme fonctionnel, les fonctions n'ont pas d' <i>effets secondaires</i> .  Un effet secondaire peut être défini comme le moment pendant lequel une fonction change quelque chose au-delà de ses limites.  Jetez un oeil à un exemple: <br><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> a a = <span class="hljs-number"><span class="hljs-number">5</span></span> some_func() print(a)</code> </pre> <br>  Le résultat de l'exécution de ce code est 5. En programmation fonctionnelle, le changement de variables est interdit, ainsi que le changement de fonctions de quelque chose au-delà de leurs frontières.  Tout ce que la fonction peut faire est de calculer / traiter quelque chose et de retourner le résultat. <br><br>  Maintenant, vous pourriez penser: «Pas de variables, pas d'effets secondaires?  Pourquoi est-ce bien? "  Vraiment une bonne question. <br><br>  Si une fonction a été appelée deux fois avec les mêmes paramètres, elle retournera évidemment le même résultat.  Si vous avez étudié quelque chose sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les fonctions mathématiques</a> , vous apprécierez cette opportunité.  C'est ce qu'on appelle la transparence des liens ou la transparence référentielle.  Comme les fonctions n'ont pas d'effets secondaires, si vous développez un programme de calcul, vous pouvez accélérer le processus d'exécution.  Si le programme sait que func (2) vaut 3, nous pouvons nous en souvenir.  Cela empêche la fonction d'être appelée à nouveau lorsque nous connaissons déjà le résultat. <br><br>  Habituellement, dans la programmation fonctionnelle, les boucles ne sont pas utilisées.  La récursivité est utilisée.  La récursivité est un concept mathématique, en fait, cela signifie «se nourrir quelque chose».  Dans une fonction récursive, la fonction elle-même s'appelle le rôle d'une sous-fonction.  Voici un exemple de fonction récursive en Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Base case: 1! = 1 #   if n == 1: return 1 # Recursive case: n! = n * (n-1)! #    else: return n * factorial_recursive(n-1)</span></span></code> </pre> <br>  Certains langages de programmation sont <b>paresseux</b> .  Cela signifie qu'ils calculent tout au dernier moment.  Supposons que si le code doit exécuter 2 + 2, le programme fonctionnel calculera le résultat uniquement lorsque le résultat est nécessaire.  Nous découvrirons la paresse de Python un peu plus tard. <br><br><h3>  <font color="#9933FF">La carte</font> </h3><br>  Pour comprendre la carte, vous devez d'abord gérer les conteneurs itérables.  Ceci est un tel conteneur sur lequel vous pouvez "passer".  Ce sont souvent des listes ou des tableaux, mais il existe de nombreux conteneurs de ce type en Python.  Vous pouvez même créer votre propre conteneur en introduisant <i>des méthodes magiques</i> .  Ces méthodes, comme les API, aident les objets à devenir plus pythoniques.  Il existe 2 méthodes de ce type pour rendre un objet itérable: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, low, high)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># set class attributes inside the magic method __init__ # for "inistalise" #      self.current = low self.high = high def __iter__(self): # first magic method to make this object iterable #    return self def __next__(self): # second magic method #    if self.current &gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1</span></span></code> </pre> <br>  La première méthode magique est "___iter__" ou dunder (double souligné par des soulignements) iter renvoie un objet itérable, il est souvent utilisé au début d'une boucle.  Dunder next (__next__) renvoie l'objet suivant. <br><br>  Vérifiez ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Counter(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>): print(c)</code> </pre> <br>  Résultat d'exécution: <br><br> <code>3 <br> 4 <br> 5 <br> 6 <br> 7 <br> 8</code> <br> <br>  En Python, un itérateur est un objet qui n'a que la méthode __iter__.  Cela signifie que vous pouvez accéder à l'emplacement des cellules de l'objet (conteneur), mais que vous ne pouvez pas "les parcourir".  Certains objets n'ont que la merveilleuse méthode __next__, sans la méthode magique __iter__, par exemple, définie (plus à ce sujet plus tard).  Dans cet article, nous couvrirons tout ce qui concerne les objets itérables. <br><br>  Maintenant que nous savons ce qu'est un objet itérable, revenons à la fonction map.  Cette fonction nous permet d'appliquer l'action d'une autre fonction à chaque élément d'un conteneur itéré.  Nous voulons appliquer une fonction à chaque élément de la liste, cela est possible pour presque tous les conteneurs itérables.  Map, prend deux arguments: la fonction à appliquer et le conteneur (liste, etc.). <br><br><pre> <code class="python hljs">map(function, iterable)</code> </pre> <br>  Supposons que nous ayons une liste avec les éléments suivants: <br><br> <code>[1, 2, 3, 4, 5]</code> <br> <br>  Et nous voulons cadrer chaque élément, cela peut être fait comme ceci: <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num*num print(list(map(square, x)))</code> </pre> <br>  Les fonctions fonctionnelles en Python sont paresseuses.  Si nous n'ajoutons pas «list ()», la fonction stockera la description du conteneur (list), et non la liste elle-même.  Nous devons directement dire à Python de le convertir en liste. <br><br>  C'est un peu étrange de passer d'une définition non paresseuse à une définition paresseuse si soudainement.  Vous vous y habituerez si vous pensez plus d'une manière fonctionnelle que d'un impératif. <br><br>  L'écriture de fonctions, par exemple, «carré (num)» est normale, mais pas entièrement correcte.  Avons-nous besoin de déclarer une fonction entière juste pour l'utiliser dans la carte?  Cela peut être simplifié en introduisant des fonctions lambda (anonymes). <br><br><h3>  <font color="#9933FF">Expressions lambda</font> </h3><br>  Les expressions lambda sont des fonctions sur une seule ligne, par exemple, voici une expression lambda qui met au carré le nombre résultant: <br><br><pre> <code class="python hljs">square = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br>  Et exécutez ceci: <br><br> <code>&gt;&gt;&gt; square(3) <br> 9</code> <br> <br>  Je vous entends.  "Brandon, où sont les arguments?"  De quoi s'agit-il?  Ce n'est pas comme une fonction. » <br><br>  Oui, cela peut être déroutant, mais cela peut s'expliquer.  Dans cette ligne, nous attribuons quelque chose à la variable «carré».  Cette partie: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br>  Indique à Python que nous utilisons la fonction lambda, et l'entrée est nommée x.  Tout ce qui se passera après les deux points est ce qui arrivera à l'entrée, et nous obtiendrons automatiquement le résultat plus tard. <br><br>  Pour notre programme a pris la forme d'une ligne, vous devez le faire: <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] print(list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, x)))</code> </pre> <br>  Ainsi, dans les expressions lambda, les arguments sont à gauche et les actions sur eux sont à droite.  C'est un peu désordonné, personne ne le nie.  La vérité est qu'il y a quelque chose dedans, pour écrire un tel code fonctionnel.  De plus, il est très cool de convertir des fonctions en une seule ligne. <br><br><h3>  <font color="#9933FF">Réduire</font> </h3><br>  Réduire est une fonction qui transforme un conteneur itérable en une seule chose.  Autrement dit, des calculs sont effectués qui transforment la liste en un seul numéro.  Cela ressemble à ceci: <br><br><pre> <code class="python hljs">reduce(function, list)</code> </pre> <br>  Nous pouvons (et utiliserons souvent) des fonctions lambda comme argument de fonction. <br><br>  Si nous voulons multiplier tous les nombres de la liste, cela peut être fait comme ceci: <br><br><pre> <code class="python hljs">product = <span class="hljs-number"><span class="hljs-number">1</span></span> x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: product = product * num</code> </pre> <br>  Et avec réduire, cela ressemblera à ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reduce product = reduce((<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x * y),[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>])</code> </pre> <br>  Le résultat sera le même, mais le code est plus court et avec la connaissance de la programmation fonctionnelle pour l'utiliser plus précisément. <br><br><h3>  <font color="#9933FF">Filtrer</font> </h3><br>  La fonction de filtre prend un conteneur itérable et le filtre selon une règle donnée (également une fonction). <br><br>  Habituellement, il prend une fonction et une liste en entrée.  Plus tard, il applique une fonction à chaque élément de la liste, si la fonction renvoie True, rien ne se passe et si False, l'élément est supprimé de la liste. <br><br>  Syntaxe: <br><br><pre> <code class="python hljs">filter(function, list)</code> </pre> <br>  Regardons un exemple sans utiliser de filtre: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) new_list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: new_list.append(num)</code> </pre> <br>  Avec filtre: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))</code> </pre> <br><h3>  <font color="#9933FF">Fonctions d'ordre supérieur</font> </h3><br>  Les fonctions d'ordre supérieur peuvent prendre des fonctions comme arguments et les renvoyer.  Un exemple simple ressemblerait à ceci: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nums)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(nums) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func, numbers)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(numbers) print(action(summation, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])) <span class="hljs-comment"><span class="hljs-comment"># Output is 6 #  6</span></span></code> </pre><br>  Ou un exemple est encore plus simple: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnBrandon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"brandon"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnJohn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"john"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> age = int(input(<span class="hljs-string"><span class="hljs-string">"What's your age?"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> age == <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnBrandon() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnJohn()</code> </pre> <br>  Rappelez-vous plus tôt, j'ai dit que la vraie programmation fonctionnelle n'utilisait pas de variables.  Les fonctions d'ordre supérieur rendent cela possible.  Vous n'avez pas besoin de sauvegarder la variable quelque part si vous passez des informations à travers un long «tunnel» de fonctions. <br><br>  Toutes les fonctions en Python sont des objets de première classe.  Un objet de la première classe est défini comme tel, ce qui correspond à un ou plusieurs des paramètres suivants: <br><br><ul><li>  Crée un cycle de service </li><li>  Attribué à une variable ou un élément dans une structure de données </li><li>  Passé comme argument de fonction </li><li>  Renvoyé suite à l'exécution de la fonction </li></ul><br>  Ainsi, toutes les fonctions en Python sont des objets de première classe et peuvent être utilisées comme des fonctions d'ordre supérieur. <br><br><h3>  <font color="#9933FF">Application partielle</font> </h3><br>  Une utilisation partielle (également interruption) est un peu étrange, mais très cool.  Vous pouvez appeler la fonction sans utiliser tous les arguments donnés.  Regardons un exemple.  Nous voulons créer une fonction qui prend 2 arguments, la base et le degré, et renvoie la base élevée à la puissance, cela ressemble à ceci: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base, exponent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base ** exponent</code> </pre><br>  Maintenant, nous devons créer une fonction distincte pour la quadrature et la calculer à l'aide de la fonction de puissance: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> power(base, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Cela fonctionne, mais que faire si nous voulons découper un nombre en cubes?  Ou au 4e degré?  Devriez-vous écrire ces fonctions pour toujours?  Bien sûr que vous le pouvez.  Mais les programmeurs sont paresseux.  Si vous répétez la même chose plusieurs fois, il existe probablement un moyen de le faire plus rapidement et d'arrêter de faire des répétitions.  Une application partielle peut être utilisée ici.  Regardons un exemple de la fonction de puissance utilisant une application partielle: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial square = partial(power, exponent=<span class="hljs-number"><span class="hljs-number">2</span></span>) print(square(<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 4 #  4</span></span></code> </pre><br>  N'est-ce pas cool?  Nous pouvons appeler une fonction qui a besoin de 2 arguments, en utilisant seulement 1, et en spécifiant ce que le second sera seul. <br><br>  Vous pouvez également utiliser une boucle pour simuler une fonction de puissance qui fonctionnera avec des cubes jusqu'à la 1000e puissance. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial powers = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1001</span></span>): powers.append(partial(power, exponent = x)) print(powers[<span class="hljs-number"><span class="hljs-number">0</span></span>](<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 9 #  9</span></span></code> </pre> <br><h3>  <font color="#9933FF">La programmation fonctionnelle ne correspond pas aux canons pythoniques</font> </h3><br>  Vous avez peut-être remarqué que beaucoup de choses que nous voulons faire dans la programmation fonctionnelle tournent autour des listes.  Outre la fonction de réduction et l'application partielle, toutes les fonctions que vous avez vues génèrent des listes.  Guido (le créateur de Python`a) n'aime pas les choses fonctionnelles en Python`e, car Python a sa propre méthode de création de listes. <br><br>  Si vous écrivez «importer ceci» dans la console, vous obtiendrez: <br> <code>&gt;&gt;&gt; import this <br> <br> The Zen of Python, by Tim Peters <br> <br> Beautiful is better than ugly. <br> Explicit is better than implicit. <br> Simple is better than complex. <br> Complex is better than complicated. <br> Flat is better than nested. <br> Sparse is better than dense. <br> Readability counts. <br> Special cases aren't special enough to break the rules. <br> Although practicality beats purity. <br> Errors should never pass silently. <br> Unless explicitly silenced. <br> In the face of ambiguity, refuse the temptation to guess. <br> There should be one — and preferably only one — obvious way to do it. <br> Although that way may not be obvious at first unless you're Dutch. <br> Now is better than never. <br> Although never is often better than *right* now. <br> If the implementation is hard to explain, it's a bad idea. <br> If the implementation is easy to explain, it may be a good idea. <br> Namespaces are one honking great idea — let's do more of those!</code> <br> <br>  C'est Python Zen.  Ceci est un verset sur ce que signifie être pythoniste.  La partie qui nous intéresse est: <br><br><blockquote>  Il devrait y avoir une - et de préférence une seule - manière évidente de le faire. </blockquote><br><blockquote>  <i>Il ne devrait y avoir qu'une seule - et de préférence une seule - façon évidente de faire quelque chose.</i> </blockquote><br>  En Python, la carte et le filtre peuvent faire la même chose que l'abstraction de liste ( <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a></i> ).  Cela viole l'une des règles de Python-Zen, donc cette partie de la programmation fonctionnelle n'est pas "pythonique". <br><br>  Les prochaines choses à parler sont la fonction lambda.  En Python, une fonction lambda est une fonction normale.  Et en fait, c'est du sucre syntaxique.  Ces deux parties font la même chose: <br><br><pre> <code class="python hljs">foo = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Une fonction standard peut toujours être la même qu'une fonction lambda, mais pas l'inverse.  Une fonction Lambda ne peut pas être la même qu'une fonction normale. <br><br>  C'était une petite remarque sur la raison pour laquelle la programmation fonctionnelle ne correspond pas tout à fait à l'idéologie pythonique.  Plus tôt, j'ai mentionné l'abstraction des listes ( <i>également l'inclusion</i> des listes), maintenant parlons-en. <br><br><h3>  <font color="#9933FF">Abstraction de liste</font> </h3><br>  J'ai déjà dit que tout ce qui peut être fait en utilisant la carte et le filtre peut être fait en utilisant l'abstraction de liste.  Dans cette partie, nous en discuterons. <br><br>  L'abstraction de listes est un moyen de créer des listes en Python.  Syntaxe: <br><br><pre> <code class="python hljs">[function <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable]</code> </pre> <br>  Carré chaque élément de la liste, par exemple: <br><br><pre> <code class="python hljs">print([x * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]])</code> </pre> <br>  D'accord, nous pouvons voir comment appliquer la fonction à chaque élément de la liste.  Comment contourner le filtre?  Jetez un oeil à ce code: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x)) print(all_less_than_zero)</code> </pre> <br>  Utilisez maintenant l'abstraction de liste: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  L'abstraction de liste prend en charge les expressions conditionnelles de ce type.  Vous n'avez plus besoin d'utiliser un million de fonctions pour obtenir quelque chose.  En fait, si vous essayez de faire quelque chose avec une liste, il est possible qu'elle soit plus propre et plus facile à réaliser avec l'abstraction des listes. <br><br>  Et si nous voulons mettre au carré chaque élément de la liste qui est en dessous de zéro.  Avec la fonction lambda, la carte et le filtre, cela ressemblera à ceci: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))))</code> </pre><br>  Cette entrée n'est pas rationnelle et pas très simple.  En utilisant l'abstraction de liste, cela ressemblera à ceci: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num * num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  L'abstraction des listes n'est bonne, curieusement, que pour les listes.  La carte et le filtre fonctionnent pour chaque conteneur itérable, alors qu'est-ce qui ne va pas? .. Oui, vous pouvez utiliser l'abstraction pour chaque conteneur itérable que vous rencontrez. <br><br><h3>  <font color="#9933FF">Autres abstractions</font> </h3><br>  Vous pouvez appliquer l'abstraction pour chaque conteneur itérable. <br><br>  Chaque conteneur itérable peut être créé en utilisant l'abstraction.  À partir de la version 2.7, vous pouvez même créer un dictionnaire (table de hachage). <br><br>  Si quelque chose est un conteneur itérable, alors quelque chose peut être généré.  Regardons le dernier exemple en utilisant set.  Si vous ne savez pas de quel ensemble il s'agit, consultez également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> écrit par moi.  En bref: <br><br><ul><li>  Set est un conteneur d'éléments; les éléments qu'il contient ne sont pas répétés </li><li>  L'ordre n'est pas important </li></ul><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># taken from page 87, chapter 3 of Fluent Python by Luciano Ramalho #    Fluent Python, . 87, . 3 &gt;&gt;&gt; from unicodedata import name &gt;&gt;&gt; {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')} {'×', '¥', '°', '£', '', '#', '¬', '%', 'µ', '&gt;', '¤', '±', '¶', '§', '&lt;', '=', '', '$', '÷', '¢', '+'}</span></span></code> </pre><br>  Comme vous l'avez peut-être remarqué, l'ensemble, comme un dictionnaire, utilise des accolades.  Python est vraiment intelligent.  Il devinera si vous utilisez une abstraction de dictionnaire ou une abstraction set`a, selon que vous spécifiez ou non des paramètres supplémentaires pour le dictionnaire.  Si vous voulez en savoir plus sur les abstractions, lisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceci</a> .  S'il s'agit d'abstractions et de génération, alors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celle-ci</a> . <br><br><h3>  <font color="#9933FF">Résumé</font> </h3><br>  La programmation fonctionnelle est excellente.  Le code fonctionnel peut être propre ou pas très.  Certains pythonistes inconditionnels n'acceptent pas le paradigme fonctionnel de Python.  Vous devez utiliser ce que vous voulez et ce qui vous convient. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Page d'auteur</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456814/">https://habr.com/ru/post/fr456814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456798/index.html">Tutoriels SDL 2: Leçon 5 - Textures</a></li>
<li><a href="../fr456804/index.html">Suivez l'argent: comment le groupe RTM a commencé à cacher les adresses des serveurs C&C dans un portefeuille crypté</a></li>
<li><a href="../fr456806/index.html">Un robot de tous les soucis</a></li>
<li><a href="../fr456808/index.html">Comment améliorer les performances des applications Web frontales: cinq conseils</a></li>
<li><a href="../fr456812/index.html">Ce qu'il y a à l'Université ITMO - festivals informatiques, hackathons, conférences et séminaires ouverts</a></li>
<li><a href="../fr456818/index.html">L'administrateur système dans une entreprise inaccessible. Le fardeau insupportable d'être?</a></li>
<li><a href="../fr456824/index.html">Qu'est-ce que la probabilité et comment la calculer</a></li>
<li><a href="../fr456826/index.html">Autoscaling DIY avec AWX, Ansible, haproxy et CROC Cloud</a></li>
<li><a href="../fr456828/index.html">Vias de réglage pour cartes de circuits imprimés</a></li>
<li><a href="../fr456830/index.html">Vivaldi 2.6 - Plaisirs d'été</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>