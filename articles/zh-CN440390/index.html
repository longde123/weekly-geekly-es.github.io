<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😻 🚴🏾 🌝 嵌入式系统的多样化世界以及Embox在其中的地位 💅🏽 🍤 👨🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Embox项目已经有9年历史了，但是许多人不了解它是什么，与它一起吃什么以及为什么需要它。 一些听说过该项目并知道这是一个操作系统的人相信Embox是一个“家用OS”。 的确，Embox被认为是试图用“二十一点和小船”制作“他们的”操作系统，但主要是“二十一点和小船”。 也就是说，其他项目所没有的某...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>嵌入式系统的多样化世界以及Embox在其中的地位</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/440390/"><img src="https://habrastorage.org/webt/ep/jc/qp/epjcqpyctt_7bt0cwewzqkz1iyg.jpeg" align="right" width="320">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Embox</a>项目已经有9年历史了，但是许多人不了解它是<s>什么，与它一起吃什么以及</s>为什么需要它。 一些听说过该项目并知道这是一个操作系统的人相信Embox是一个“家用OS”。 的确，Embox被认为是试图用“二十一点和小船”制作“他们的”操作系统，但主要是“二十一点和小船”。 也就是说，其他项目所没有的某些特征或它们的组合被置于最重要的位置。 <br><br> 当然，即使有一些芯片，也没人会编写通用操作系统。 标语Embox-“嵌入式开发的必要工具箱”-表示该项目针对嵌入式系统。 但是，此概念非常广泛，它包括：物联网（IoT）和机器人，各种覆盆子（RaPi）和车载系统，arduinki和ASU-TP，... 如您所知，该列表可以持续很长时间，在某些地方Linux可以很好地运行，在有些地方Linux是冗余的并且使用了各种小型RTOS。 在本文中，我想谈谈嵌入式世界的所有多样性，以及Embox在其中的位置。 <br><a name="habracut"></a><br><h2> 单板计算机 </h2><br><h3> 工业计算机 </h3><br> 让我们从单板计算机开始。 其中许多是工业设计制造的。 大多数都基于具有ARM和x86体系结构的处理器构建。 许多人认为x86处理器不在这一部分中使用，并且所有内容都仅限于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盆子</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">beagleboard</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">香蕉</a>等。 但是早在RaPi之前，还有其他针对工业PC领域的单板机，即所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PC / 104</a>外形。 它们的性能不如传统台式机，因为它们用于执行优先于功能的任务。 出于同样的原因，Linux并不经常被用作这些硬件平台的操作系统；有各种具有实时属性的专有操作系统（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VxWorks</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QNX</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LynxOS</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等等</a> ）。 我之所以没有写“ RTOS”（我将这三个操作系统都包括在内）是因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows CE</a>及其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows Embedded的</a>开发经常位于这些硬件平台上。 而且，我不会拒绝将整个动物园归功于RTOS。 <br><br><h3> 消费者单一付款人 </h3><br> 马林基树立了完全不同的趋势。 实际上，它们并不是针对工业实时系统，而是针对价格/功能比得到重视的消费者市场，而树莓（和类似物）在此参数方面远远领先于竞争对手。 毕竟，当您以有条件的30-50美元购买时，您将获得一个成熟的系统单元，使用它您可以轻松地使用Linux工具制造具有相当复杂功能的设备。 这对于原型制作或DIY非常有用。 另外，当然，树莓可以用作PC或小型服务器。 因此，现成的Linux发行版通常被用作OS，主要是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Raspbian</a> -Debian（用于Raspberry Pi），或者发行带有有趣名字的发行版（对于俄语使用者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pidora</a> -Fedora）用于RaspberryPi。 对于其他类似平台，设备制造商和OS社区（制造商）也提供了现成的发行版。 同意，当您需要制作原型时，最简单的方法是采用现成的指令包，并使用python编写功能。 结果，迅速获得了一个可行的原型。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个示例是使用OpenCV识别线的机器人</a> 。 <br><br><h2> 嵌入式设备中的Linux </h2><br> 但是嵌入式领域比标准ARM单板卡要宽得多。 而且，它们只占设备的一小部分，它们的主要贡献是普及和简化了此类设备的开发。 串行设备是基于相同的处理器（片上系统）或类似的设备创建的，但是板是为任务（项目，设备）而设计的。 因此，标准发行版至少是多余的，因为它们经常使用某种程序包管理器，并且您可以轻松交付许多有趣的东西（但对于解决特定任务而言则不必要）。 嵌入式设备通常具有完整的功能，甚至称为固件。 还有另一类用于创建固件的Linux发行版。 这样的发行版允许您使用存储库中的程序包管理器以静态方式“安装”必要的程序包-通过将其组装在根文件系统中，而不是动态地进行组装。 通常，这些发行版不仅可以构建应用程序应用程序和库，还可以构建给定配置中的内核。 而且通常也是交叉编译器，因为在设备本身上进行编译至少无效。 <br><br><h3>  Yocto项目 </h3><br> 迄今为止， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Yocto项目</a>是最著名的此类发行版（用于创建发行版的项目）。 反过来，它基于另一个著名的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenEmbedded</a>项目，该项目是一种Linux发行版的构建系统。 如果您不想将Raspberry Pi用作现成的小型系统，而是将其用作Linux的自定义设备，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Yocto</a>或其类似物将是一个不错的选择。 就个人而言，我看不到将非标准Linux发行版与标准组件一起使用时没有强大的优势，但如果您打算开发类似的设备或希望自己学习技术，那么这种方法看起来是最有前途的。 毕竟，在开发专用硬件的同时，程序员可以开发和调试系统的各个部分（算法，驱动程序，库等）。 这大大减少了开发时间，并因此缩短了臭名昭著的TTM（上市时间）。 <br><br><h3>  Openwrt </h3><br> 另一个著名的基于Linux的固件项目是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenWRT</a> 。 我相信那些喜欢定制路由器的人都听说过他。 基于此项目，为各种路由器制作了固件，它们是一个二进制文件，包括内核和根文件系统。 在嵌入式系统中使用固件（而不是通用发行版）与这样的想法有关，即最终系统的功能在开发时就已经知道，也就是说，即使路由器版本已更新，固件也会完全更改所有功能（或者以特殊方式替换了一部分固件） ） 例如，通常不需要安装办公套件，通常通常禁止安装，因为这可能会带来不确定性。 除其他外，这种方法可以大大节省硬件。 例如，与通用密封管相比，相同的路由器功能更差的处理器和更少的内存。 <br><br><h2> 实时系统 </h2><br> 回到工业计算器的话题，有必要讨论术语“实时系统”。 许多人认为实时系统速度更快。 这是一个谬论。 它可能与历史建筑相连。 毕竟，术语本身是在汽车行驶缓慢时出现的。 用户注意到系统的反应可能落后于他的动作。 术语“实时”是指系统必须对包括操作员动作在内的任何影响做出响应。 但是在现代计算机上，用户（操作员）不太可能注意到抑制。 在大多数情况下，当您单击菜单，图标，按钮时，我们会立即看到屏幕重绘，除非一切正常（除非存在互联网，该过程不会挂起，等等）。 但是，如果发生意外情况（例如，连接丢失），我们将看到实时系统有何不同（应该有所不同）。 我们将仅重新启动常规智能手机。 但是，如果此系统控制发电厂，那么您自己就会知道，这并非总是可能的。 由此得出的结论是，实时系统应该可预测地而不是快速地响应任何事件或事件集，而无论其状态和环境如何。 <br><br><h3>  Linux实时系统 </h3><br> 自然，已经（并且将会）尝试用Linux制作一个实时系统。 最有名的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTLinux</a> ，它最初是Linux的补丁，代替了原来的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完全诚实的调度程序</a> ”，更确切地说，是插入自己的，这是Linux调度程序设置的任务之一。 该调度程序处理静态任务优先级；因此，它的工作可预测性更高。 但是它不再是Linux，或者说Linux功能不是实时的。 <br><br><h3>  ARINC-653 </h3><br> 提供与Linux的RT补丁有些相似的实时方法是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ARINC653</a>标准要求的方法或所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MILS</a>方法。 这种方法意味着系统是分层设计的，下层则是非常轻量级的虚拟机管理程序，基于该虚拟机管理程序，可以在静态定义的部分中执行不同关键程度的任务。 我之所以称系统管理程序为轻，是因为它暗示着它具有最高的关键性，因此应尽可能全面地检查其代码（算法）（理想情况下，应以数学方式证明未处理情况的存在）。 因此，代码应尽可能小。 嗯，您可能已经知道，Linux位于其自己的部分中。 <br><br><h3>  uCLinux </h3><br> 很早以前就开始尝试在嵌入式系统中使用Linux。 第一个尝试是尝试在没有虚拟内存（MMU）硬件支持的系统中使用Linux。 这个项目称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">uCLinux</a> ，它对Linux内核的贡献是<a href="">NOMMU</a>或无MMU模式。 <br><br><h3>  Linux实时系统 </h3><br> 要总结在实时系统中使用Linux的尝试，您需要回答为什么会这样的问题。 就是说，一方面，Linux尚未（特别是目前的纯形式）特别适合于实时系统，另一方面，人们也在不断尝试这样做。 发生这种情况的原因是引入了限制（替换了调度程序，引入了管理程序，限制了对虚拟内存的使用等等）。 在我看来，答案在于Linux存在着巨大的代码库。 这些是驱动程序，是功能性应用程序和库。 显然，如果要创建一个可靠的系统，则应尽可能使用现成的零件，因为开发新零件（无论是功能逻辑还是驱动程序）总是会引入错误。 而且由于现代实时系统对功能的要求很高，因此从Linux重复使用现成的功能变得越来越诱人。 换句话说，尽管要基于实时操作系统开发功能，但将Linux升级到实时系统似乎并不那么昂贵，因为整个系统的可靠性（不仅是操作系统内核形式的一部分）必须是可靠的。 <br><br><h3> 嵌入式设备中的Windows </h3><br> 我想回到Windows一段时间。 在我职业生涯的初期，我与经验丰富的开发人员进行了讨论，他们认为Windows无法在可靠的系统中使用。 他反对，如果您使用必要的功能软件测试一个已经完成的系统并禁止进行任何更改：更新，软件安装等，则该系统将足以执行许多任务，包括我们执行的任务。决定了。 现在我毫不怀疑我的对手是正确的，而不是我。 而且，即使是古老的MS-DOS，也已经在工业系统中使用了很长时间。 事实是，似乎非常必要的多任务处理会带来不确定性。 而且，如果您运行完全控制整个系统的软件，则可以实现更具确定性的行为。 换句话说，如果无限多个任务在系统中旋转，那么不太可能在系统所有功能的工作中实现确定性。 因此，增加系统可预测性的最简单方法是限制其功能，并因此在运行时拒绝通用性。 实际上，我们在上述实时系统中使用Linux的示例中对此进行了观察。 <br><br><h2> 微控制器 </h2><br> 作为工业实时系统基本操作系统的MS-DOS的示例使我们想到，如果仅使用自己的软件，则可以实现整个系统的可预测行为。 确实是！ 的确，您需要保留一个前提，即只有在系统功能较小且已明确固定的情况下才有可能这样做。 如果系统的所有功能都包括使用GPIO控制电动机并通过UART接口接收（发送）一组有限的命令，则无需使用OS，您可以创建固件（称为裸机）。 这种方法通常用在微控制器中。 但是，由于微控制器变得越来越大（具有几KB RAM的32位ARM与具有一百字节RAM的8位AVR-ok），对功能的需求增加了。 现在，在开发固件时，他们至少使用制造商的软件，这使您可以使用一些现成的示例来与微控制器一起工作，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM32Cube</a> 。 <br><br><h3> 实时操作系统 </h3><br> 但是，由于对功能的需求不断增长，因此越来越多地在所谓的RTOS的基础上制造微控制器的固件。 与大型实时操作系统不同，它们是相对较小的开源项目，可提供对系统中所有代码的完全访问权限。 也就是说，存在一个概念组合：一方面，使用现成的代码，另一方面，开发人员可以完全访问系统中的所有内容，可以说是裸机固件。 <br><br> 有许多用于微控制器的RTOS。 因此，不可能谈论所有这些。 我认为，我将仅列出一些有趣的项目，并简要介绍它们的功能。 <br><br><h4>  FreeRTOS </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FreeRTOS</a>可能是目前最受欢迎的RTOS项目之一。 有人说这不是完整的操作系统，而只是一个调度程序。 但是考虑到以上有关裸机的讨论，支持的微控制器数量众多以及编写和集成了大量应用软件的事实，小的功能看起来更像是优点而不是缺点。 如项目网站上所写，这使我们成为微控制器的事实上的标准。 <br><br><h4> 孔蒂基 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Contiki-</a>由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">亚当·邓克尔斯</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Adam Dunkels）</a>开发的RTOS，他是lwIP和uIP等著名的TCP / IP堆栈的创建者。 我要说整个操作系统都是围绕网络堆栈构建的。  IPv6支持的存在和较小的资源要求使该项目对于创建各种无线设备非常有趣。 <br><br><h4>  RTEMS </h4><br> 多处理器系统的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTEMS</a>实时执行程序。 该缩写最初是为军事而开发的，其缩写是“导弹系统的实时执行程序”，然后是“军事系统的实时执行程序”。 相当古老但仍然活跃的开源项目。  libOS方法的杰出代表。 当开发的软件与已经组装好的OS链接时，不仅是内核，而且是所有可用的服务。 它被编译并作为库提供给编译器，这在开发的早期阶段非常方便。 <br><br><h4>  eCos </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eCos</a>嵌入式可配置操作系统。 这也是一个相当古老的项目，以前很受欢迎。 主要思想是制作一个非常可配置的OS，即仅将所需的内容包含在内核中。 <br><br><h4> 其他实时操作系统 </h4><br> 该列表持续了一段时间。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我</a>将在下面提到另一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NuttX</a>项目。 对于那些对更详细列表感兴趣的人，我建议您观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia</a> 。 对于微控制器，我还要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提到ChibiOS / RT</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MicroC / OS（µC / OS）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nut / OS</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RIOT</a> 。 但是，当然，这完全取决于任务。 <br><br><h2>  Arduino的 </h2><br> 我认为不提及Arduino就谈嵌入式是不完整的。 毕竟，像RaPi一样，它们非常常见，并为微控制器的普及做出了巨大贡献。 我本人对arduino主题持怀疑态度，因此我将跳过对此技术迷的批评。 但是，关于这是一项非常有趣的技术，我可以举<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个在集线器上描述的面包机示例</a> 非常好的解决方案。 嗯，或者已经引用过的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例，其中有一个通过openCV识别线的机器人</a> ，但是在那里也使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">arduino</a> 。 <br><br><h2> 微内核 </h2><br> 我从来没有提到微内核的概念，正如许多人所知，微内核使系统可靠且可预测。 一方面，这是事实，但另一方面，并​​非总是如此。 更准确地说，当然是对的，但是相信这个概念（体系结构）会立即将您的系统变成硬实时系统，这是一种错觉。 这是一个营销口号：“我们是实时系统，因为我们建立在微核原理之上”。 但是微内核的原理仅使简化软件开发成为可能，因为大多数部分都在用户空间中执行。 但是，如果您的服务器坏了怎么办呢？ 您可以重新启动它，但是需要时间，如果没有的话？ 另外，经典的微内核架构也有其缺点！ 例如，它很慢，因为有很多系统调用（服务器和应用程序软件之间的消息传输）。 否则，每个人都将在很久以前就切换到纯微内核体系结构，例如，他们看到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了L4上的项目</a> ，但事实并非如此。 好吧，当然，许多人还记得<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">莱纳斯·托瓦尔兹（Linus Torvalds）与安德鲁·塔南鲍姆（Andrew Tanenbaum）</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">论点</a> 。 <br><br> 也就是说，微核的概念不是灵丹妙药。 但是，作为一个很好的主意，它可以在大多数现代操作系统中以某种程度应用。 最终创建可靠的系统仍然取决于最终开发人员以及操作系统为其构建提供的功能。 <br><br><h2>  Embox在嵌入式系统世界中的地位 </h2><br> 我已经谈论了很多有关嵌入式世界各个方面的内容，但是我从未在其中使用Embox。 好吧，我可以说在上述示例中，可能不需要使用Embox。 而且，我们通常会问用户为什么他们需要Embox？ 如果使用Embox没有任何好处，建议您尝试使用上面列表中的内容或其他内容（例如Android）。 但是，在许多情况下，使用Embox可以带来明显的收益。 <br><br><h3> 设备开发系统 </h3><br> 我将首先使用Embox。 那时他甚至都不是Embox，而是C和汇编代码，您可以非常快速地启动并执行实用代码。 当时，这是一个帮助工程师调试FPGA开发的设备的项目。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他知道如何非常快速地运行，比使用已经提到的RTEMS编写的类似代码快得多。</font><font style="vertical-align: inherit;">这很重要，因为它也用于延时仿真阶段。</font><font style="vertical-align: inherit;">另外，他们开始在真正的硬件上使用它，为此编写了一个小的解释程序，可以调用用户命令。</font><font style="vertical-align: inherit;">后来，开发了这个方向，并移植了TCL语言的解释器，因为它对FPGA开发人员很熟悉。</font><font style="vertical-align: inherit;">而且由于在特定的配置中，团队可以直接访问设备（可以访问整个地址空间），因此开发人员能够进行相当复杂的测试。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux认证 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个第三方应用程序之一是对代码认证的特定要求。某些设备的功能有限，包括：使用套接字（UDP），文件系统以及其他一些功能。客户将所有功能实现为基于Linux的软件。该设备不是x86，也不是ARM。它有外围。有必要对设备中使用的代码进行认证，因为无法在此处使用经过认证的发行版。试图切断Linux内核导致了大约50万行代码，此外#ifdef和其他宏仍然存在问题。客户在评估该产品的认证成本时，要求考虑其他选择。当时的Embox已经有了网络堆栈，文件系统，并决定考虑认证要求对其进行修改。因此，我们获得了Mybuild模块描述语言，在某种程度上，我们通过宏解决了一些其他问题。结果，我们实现了在最终映像中，我们仅使用（在配置中声明）代码，通常对于特定任务并不需要太多代码。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 没有Linux的Linux </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">认证的方向通常很受欢迎。</font><font style="vertical-align: inherit;">客户经常有针对Linux的代码，但由于某些原因，他们无法在其设备上使用此OS。</font><font style="vertical-align: inherit;">Embox能够轻松地从Linux下的开源项目中转移应用程序软件。</font><font style="vertical-align: inherit;">因此，它已经被移植了一些流行的项目，即使是QT（嵌入式版本）或者已经</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述哈布雷SIP电话</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同时，由于使用Embox时仅包含所需的模块，因此启动所需的资源少得多。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在资源很少的系统上运行POSIX应用程序的想法是另一个开源项目</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">NuttX</font></a><font style="vertical-align: inherit;">的主要</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想法。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在某些方面，该项目在某些方面优于Embox-反之亦然。</font><font style="vertical-align: inherit;">据我所知，以Qt和SIP电话为例，NuttX太难了。</font><font style="vertical-align: inherit;">但是该项目确实非常有趣。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还值得注意的是，RTOS的一部分还添加了POSIX层。</font><font style="vertical-align: inherit;">例如，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FreeRTOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://archive.today/20130103183712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTEMS，如今已完全符合POSIX Profile 52，即“一个进程，多个线程，文件系统”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">RTEMS甚至进行了成功的实验，以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在微控制器</font></a><font style="vertical-align: inherit;">上启动</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 安全Linux </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一方面，如果我们查看小型RTOS映像的静态组合，即确定创建时的所有功能，则可以看到，这可以自然地防御恶意代码（即病毒）。当然，在Linux中，您可以创建一个非常好的安全系统，但是主要的安全问题仍然与人为因素有关（弱密码，密码丢失，用户权限提升等）。也就是说，当获得根权限时，实际上所有保护都变得无关紧要，您可以在任何地方安装任何东西。对于静态程序集，攻击者只能使用现有功能。是的，他也许可以获取统计信息或进行某种调整，但是，您必须承认，与安装恶意软件相比，这种恶意少得多。加号在通用系统上，保护系统的成本不等于零。在我们的情况下，这便宜得多，因为它已经在设计阶段实现。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux实时 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我已经投入大量精力将Linux用作实时系统。</font><font style="vertical-align: inherit;">解释了为什么很难做到这一点，以及为什么要尝试。</font><font style="vertical-align: inherit;">因此，回到有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV线识别机器人的文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您查看链接，您可能会注意到OpenCV在RaPi上旋转，并且电机在单独的Arduino板上进行控制。</font><font style="vertical-align: inherit;">造成这种情况的原因有两个：第一个是调度程序，第二个是管理来自用户模式，而Linux无法访问其中的硬件。</font><font style="vertical-align: inherit;">您可能已经猜到，在Embox中，这两个问题比在Linux中更容易解决。</font><font style="vertical-align: inherit;">在具有足够资源的同一板上，您可以运行OpenCV并控制电动机。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有几种设备结合了Linux功能和实时工作。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个示例是由Web界面控制的CNC机床，我在一篇文章中对此进行了简要描述</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">好吧，如果我们在多个板上制作机器人，那么这些就是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多代理系统</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 物联网 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与几乎所有的RTOS微控制器一样，Embox具有较低的资源需求。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在habr上已经描述了stm32vl-discovery上的玩具示例Embox甚至在具有512字节RAM的16位MSP-430上启动。但是，例如，如果您看一下玩具文章中的代码，您会发现它不使用标准POSIX流，而是使用其自己的无堆栈流（轻线程）实现。当然，如果您自己进一步执行所有代码，我相信您可以在内存成本方面取得更好的结果。但是智能传感器只是物联网的一部分。它们将数据传输到一些功能更强大的节点。他们按照某种协议来做。但是，如果Embox也将在此节点上启动，并且实现通信协议的库代码将是通用的，那么这将简化开发。毕竟，首先，代码是通用的，即使协议的实现有错误，也可以通过以下方法将其压平相同的代码将在对话的两面都起作用。其次，可以在具有大量资源的平台上调试代码，这更加熟悉和简单。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过观看我们</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在CodeFreeze</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上的第</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">一个首次表演</font></a><font style="vertical-align: inherit;">之一的视频，您可以了解有关该项目艰难命运的更多信息</font><font style="vertical-align: inherit;">。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文仅揭示了多元化嵌入式世界中的一小部分。</font><font style="vertical-align: inherit;">未提及的重要主题包括家用电器，汽车，仪器仪表，ASU-TP。</font><font style="vertical-align: inherit;">但是正如我在开始时所说，在本文中，我只想“谈谈”嵌入式功能。</font><font style="vertical-align: inherit;">我希望这篇文章足够有趣，阅读之后，您会学到一些新东西！</font><font style="vertical-align: inherit;">让我们在评论中讨论该区域的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS：是的，Embox不仅是“嵌入式”的，而且是“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开源的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font><font style="vertical-align: inherit;">因此，我们邀请您使用该项目，当然也要参与其中！</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440390/">https://habr.com/ru/post/zh-CN440390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440376/index.html">20个游戏来教孩子编程</a></li>
<li><a href="../zh-CN440378/index.html">回到Istio的微服务。 第二部分</a></li>
<li><a href="../zh-CN440382/index.html">200是好是坏？</a></li>
<li><a href="../zh-CN440386/index.html">通过消除错误来释放错误处理</a></li>
<li><a href="../zh-CN440388/index.html">时间间隔：即将到来的C ++演变</a></li>
<li><a href="../zh-CN440392/index.html">您网站上的WebRTC-没有错误，也没有预算</a></li>
<li><a href="../zh-CN440394/index.html">PostgreSQL权限提升-CVE-2018-10915解析</a></li>
<li><a href="../zh-CN440398/index.html">参加2018年俄罗斯AI杯的历史（和胜利）-CodeBall</a></li>
<li><a href="../zh-CN440400/index.html">Apache Kafka + Spring Boot：您好，微服务</a></li>
<li><a href="../zh-CN440402/index.html">SearchFace开发人员有关算法功能的信息</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>