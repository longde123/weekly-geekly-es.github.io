<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåô ü§Ωüèª üëàüèø Pare de alimentar os madeireiros! D√™ mais modificadores! Campos finais est√°ticos pregui√ßosos. Esbo√ßo de recurso de rascunho üà∏ üöë üå∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√â suficiente que, em Java, os loggers sejam inicializados no momento em que a classe √© inicializada, por que eles jogam lixo durante todo o lan√ßamento...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pare de alimentar os madeireiros! D√™ mais modificadores! Campos finais est√°ticos pregui√ßosos. Esbo√ßo de recurso de rascunho</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422629/"><p>  √â suficiente que, em Java, os loggers sejam inicializados no momento em que a classe √© inicializada, por que eles jogam lixo durante todo o lan√ßamento?  John Rose para o resgate! </p><br><p>  Aqui est√° o que pode parecer: </p><br><pre><code class="java hljs">lazy <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Este documento estende o comportamento das vari√°veis ‚Äã‚Äãfinais, permitindo que voc√™ suporte opcionalmente a execu√ß√£o lenta - tanto no pr√≥prio idioma quanto na JVM.  Prop√µe-se melhorar o comportamento dos mecanismos existentes da computa√ß√£o lenta, alterando a granularidade: agora n√£o ser√° preciso classificar, mas sim uma vari√°vel espec√≠fica. </p><br><img src="https://habrastorage.org/webt/zf/6q/yz/zf6qyzherz5jt3ufyhfp9rz70t4.png"><a name="habracut"></a><br><h1 id="motivaciya">  Motiva√ß√£o </h1><br><p>  Java construiu profundamente a computa√ß√£o lenta.  Quase todas as opera√ß√µes de link podem arrancar c√≥digo lento.  Por exemplo, executando o m√©todo <code>&lt;clinit&gt;</code> (bytecode do inicializador de classe) ou usando o m√©todo de autoinicializa√ß√£o (para um site de chamada <code>&lt;clinit&gt;</code> ou constantes <code>CONSTANT_Dynamic</code> ). </p><br><p>  Os inicializadores de classe s√£o algo muito rude em termos de granularidade quando comparados aos mecanismos que usam m√©todos de autoinicializa√ß√£o, j√° que o contrato deles √© executar <em>todo o</em> c√≥digo de inicializa√ß√£o da classe como um <em>todo</em> , em vez de se limitar √† inicializa√ß√£o relacionada a um campo espec√≠fico da classe.  Os efeitos dessa inicializa√ß√£o bruta s√£o dif√≠ceis de prever.  √â dif√≠cil isolar os efeitos colaterais do uso de <em>um</em> campo est√°tico de uma classe, pois o c√°lculo de um campo leva ao c√°lculo de <em>todos os</em> campos est√°ticos dessa classe. </p><br><p>  Se voc√™ tocar em um campo, afetar√° todos eles.  Nos compiladores AOT, isso torna particularmente dif√≠cil otimizar as refer√™ncias de campo est√°tico, mesmo para campos com um valor constante facilmente analisado.  Uma vez que pelo menos <em>um</em> campo est√°tico reprojetado est√° confuso entre os campos, torna-se imposs√≠vel analisar completamente <em>todos os</em> campos dessa classe.  Um problema semelhante se manifesta com os mecanismos propostos anteriormente para implementar a convolu√ß√£o de constantes (durante a opera√ß√£o <em>javac</em> ) para campos constantes com inicializadores complexos. </p><br><p>  Um exemplo de uma inicializa√ß√£o de campo redesenhada, que ocorre em diferentes projetos a cada etapa, em cada arquivo, √© a inicializa√ß√£o do criador de logs. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Essa inicializa√ß√£o de apar√™ncia in√≥cua lan√ßa sob o cap√¥ uma enorme quantidade de trabalho que ser√° executado durante a inicializa√ß√£o da classe - e, no entanto, √© extremamente improv√°vel que o criador de logs seja realmente necess√°rio no momento em que a classe √© inicializada, ou talvez nem seja necess√°rio.  A capacidade de adiar sua cria√ß√£o at√© o primeiro uso real simplificar√° a inicializa√ß√£o e, em alguns casos, ajudar√° a evitar completamente essa inicializa√ß√£o. </p><br><p>  As vari√°veis ‚Äã‚Äãfinais s√£o muito √∫teis, elas s√£o o principal mecanismo da API Java para indicar a const√¢ncia dos valores.  Vari√°veis ‚Äã‚Äãpregui√ßosas tamb√©m funcionaram bem.  A partir do Java 7, eles come√ßaram a desempenhar um papel cada vez mais importante nas <code>@Stable</code> internas do JDK, sendo marcados com a anota√ß√£o <code>@Stable</code> .  O JIT pode otimizar vari√°veis ‚Äã‚Äãfinais e est√°veis ‚Äã‚Äã- muito melhor do que apenas algumas vari√°veis.  A adi√ß√£o de vari√°veis ‚Äã‚Äãfinais pregui√ßosas permitir√° que esse padr√£o de uso √∫til se torne mais comum, possibilitando o uso em mais locais.  Por fim, o uso de vari√°veis ‚Äã‚Äãfinais pregui√ßosas permitir√° que bibliotecas como o JDK reduzam a depend√™ncia do c√≥digo <code>&lt;clinit&gt;</code> , o que, por sua vez, deve reduzir o tempo de inicializa√ß√£o e melhorar a qualidade das otimiza√ß√µes de AOT. </p><br><h1 id="opisanie">  Descri√ß√£o do produto </h1><br><p>  O campo pode ser declarado com o novo modificador <code>lazy</code> , que √© uma palavra-chave contextual que √© percebida exclusivamente como um modificador.  Esse campo √© chamado de <em>campo</em> lento e tamb√©m deve ter modificadores <code>static</code> e <code>final</code> . </p><br><p>  Um campo lento deve ter um inicializador.  O compilador e o tempo de execu√ß√£o concordam em iniciar o inicializador exatamente quando a vari√°vel √© usada pela primeira vez, e n√£o ao inicializar a classe √† qual esse campo pertence. </p><br><p>  Cada campo <code>lazy static final</code> √© associado no tempo de compila√ß√£o a um elemento de pool constante que representa seu valor.  Como os pr√≥prios elementos do pool constante s√£o calculados pregui√ßosamente, basta atribuir o valor correto para cada vari√°vel final pregui√ßosa est√°tica associada a esse elemento.  (Voc√™ pode vincular mais de uma vari√°vel lenta a um elemento, mas isso dificilmente √© um recurso √∫til ou significativo.) O nome do atributo √© <code>LazyValue</code> e deve se referir a um elemento de g√™nero constante que pode ser codificado por ldc em um valor que seja convers√≠vel em um tipo de campo lento .  Somente convers√µes que j√° s√£o usadas no <code>MethodHandle.invoke</code> . </p><br><p>  Assim, um campo est√°tico lento pode ser considerado um alias nomeado para um elemento de pool constante dentro da classe que declarou esse campo.  Ferramentas como compiladores podem, de alguma forma, tentar usar esse campo. </p><br><p>  Um campo lento nunca √© uma vari√°vel constante (no sentido de JLS 4.12.4) e √© explicitamente exclu√≠do de participar de express√µes constantes (no sentido de JLS 15.28).  Portanto, ele nunca captura o atributo <code>ConstantValue</code> , mesmo que seu inicializador seja uma express√£o constante.  Em vez disso, o campo lento captura um novo tipo de atributo de <code>LazyValue</code> chamado <code>LazyValue</code> , que a JVM consulta ao vincular a esse campo espec√≠fico.  O formato desse novo atributo √© semelhante ao anterior, pois tamb√©m aponta para um elemento do pool constante, nesse caso, aquele que √© resolvido com o valor do campo. </p><br><p>  Quando um campo est√°tico lento √© vinculado, o processo normal de execu√ß√£o dos inicializadores de classe <em>n√£o</em> deve desaparecer.  Em vez disso, qualquer m√©todo de classe <code>&lt;clinit&gt;</code> declarante √© inicializado de acordo com as regras definidas no JVMS 5.5.  Em outras palavras, o bytecode <code>getstatic</code> para um campo est√°tico lento executa o mesmo v√≠nculo que para <em>qualquer</em> campo est√°tico.  Ap√≥s a inicializa√ß√£o (ou durante a inicializa√ß√£o j√° iniciada do encadeamento atual), a JVM resolve os elementos do conjunto constante associados ao campo e armazena os valores obtidos do conjunto constante nesse campo. </p><br><p>  Como o final est√°tico pregui√ßoso n√£o pode estar vazio, eles n√£o podem receber nenhum valor - mesmo nos poucos contextos em que isso funciona para vari√°veis ‚Äã‚Äãfinais vazias. </p><br><p>  Durante a compila√ß√£o, todos os campos est√°ticos pregui√ßosos s√£o inicializados independentemente dos campos est√°ticos n√£o pregui√ßosos, independentemente de sua localiza√ß√£o no c√≥digo-fonte.  Portanto, as restri√ß√µes no local dos campos est√°ticos n√£o se aplicam aos campos est√°ticos pregui√ßosos.  O inicializador de campo est√°tico lento pode usar qualquer campo est√°tico da mesma classe, independentemente da ordem em que eles aparecem na origem.  O inicializador de qualquer campo n√£o est√°tico ou o inicializador de classe pode acessar o campo lento, independentemente da ordem na origem em que s√£o relativos um ao outro.  Geralmente, fazer isso n√£o √© a id√©ia mais sensata, pois todo o significado dos valores pregui√ßosos √© perdido, mas pode ser usado de alguma maneira em express√µes condicionais ou no fluxo de controle.  Portanto, campos est√°ticos pregui√ßosos podem ser tratados mais como campos de outra classe - no sentido de que podem ser referenciados em qualquer ordem de qualquer parte da classe em que s√£o declarados. </p><br><p>  Campos pregui√ßosos podem ser detectados usando a API de reflex√£o usando dois novos m√©todos de API em <code>java.lang.reflect.Field</code> .  O novo m√©todo <code>isLazy</code> retorna <code>true</code> se e somente se o campo tiver um modificador <code>lazy</code> .  O novo m√©todo <code>isAssigned</code> retorna <code>false</code> se, e somente se, o campo estiver lento e ainda n√£o inicializado no momento em que <code>isAssigned</code> .  (Ele pode retornar verdadeiro quase na pr√≥xima chamada no mesmo encadeamento, dependendo da presen√ßa de corridas).  N√£o h√° como descobrir se um campo foi inicializado, exceto usando <code>isAssigned</code> . </p><br><p>  (A chamada <code>isAssigned</code> √© necess√°ria <code>isAssigned</code> para ajudar com problemas raros relacionados √† resolu√ß√£o de depend√™ncias circulares. Talvez n√£o possamos implementar esse m√©todo. No entanto, as pessoas que escrevem c√≥digo com vari√°veis ‚Äã‚Äãpregui√ßosas √†s vezes querem saber se o valor est√° definido para uma vari√°vel ou n√£o ainda, da mesma maneira que os usu√°rios do mutex √†s vezes desejam descobrir a partir do mutex se ele est√° bloqueado ou n√£o, mas eles realmente n√£o querem bloquear) </p><br><p>  H√° uma limita√ß√£o incomum nos campos finais pregui√ßosos: eles nunca devem ser inicializados com seus valores padr√£o.  Ou seja, o campo de refer√™ncia lenta n√£o deve ser inicializado como <code>null</code> e os tipos num√©ricos n√£o devem ter um valor nulo.  Um valor booleano lento pode ser inicializado com apenas um valor - <code>true</code> , pois <code>false</code> √© o valor padr√£o.  Se o inicializador de um campo est√°tico lento retornar seu valor padr√£o, a vincula√ß√£o desse campo falhar√° com o erro correspondente. </p><br><p>  Essa restri√ß√£o √© introduzida para isso.  para permitir que as implementa√ß√µes da JVM reservem valores padr√£o como um valor de watchdog interno que marca o estado de um campo n√£o inicializado.  O valor padr√£o j√° est√° definido no valor inicial de qualquer campo, definido no momento da prepara√ß√£o (isso √© descrito no JLS 5.4.2).  Portanto, esse valor j√° existe naturalmente no in√≠cio do ciclo de vida de qualquer campo e, portanto, √© uma op√ß√£o l√≥gica para uso como um valor de vigil√¢ncia que monitora o estado desse campo.  Usando essas regras, voc√™ nunca pode obter o valor padr√£o original de um campo est√°tico lento.  Para isso, a JVM pode, por exemplo, implementar um campo lento como um link imut√°vel para o elemento do conjunto constante correspondente. </p><br><p>  Restri√ß√µes nos valores padr√£o podem ser contornadas envolvendo os valores (que s√£o possivelmente iguais aos valores padr√£o) em caixas ou recipientes de algum tipo conveniente.  Um n√∫mero zero pode ser quebrado em uma refer√™ncia inteira diferente de zero.  Tipos n√£o primitivos podem ser agrupados em Opcional, que fica vazio se atingir nulo. </p><br><p>  Para manter a liberdade nas maneiras de implementar recursos, os requisitos para o m√©todo <code>isAssigned</code> especialmente subestimados.  Se a JVM puder provar que uma vari√°vel est√°tica lenta pode ser inicializada sem efeitos externos observ√°veis, ela poder√° fazer essa inicializa√ß√£o a qualquer momento.  Nesse caso, <code>isAssigned</code> retornar√° <code>true</code> mesmo que <code>getfield</code> nunca tenha sido chamado.  O √∫nico requisito imposto ao <code>isAssigned</code> √© que, se ele retornar <code>false</code> , nenhum dos efeitos colaterais da inicializa√ß√£o da vari√°vel deve ser observado no encadeamento atual.  E se ele retornou <code>true</code> , o encadeamento atual poder√° no futuro observar os efeitos colaterais da inicializa√ß√£o.  Esse contrato permite que o compilador substitua <code>ldc</code> por <code>getstatic</code> por seus pr√≥prios campos, o que permite que a JVM n√£o monitore estados detalhados de vari√°veis ‚Äã‚Äãfinais que possuem elementos comuns ou degenerados no pool constante. </p><br><p>  V√°rios threads podem entrar em um estado de corrida para inicializar um campo final lento.  Como j√° acontece com <code>CONSTANT_Dynamic</code> , a JVM seleciona um vencedor arbitr√°rio desta corrida e fornece o valor desse vencedor a todos os segmentos que participam da corrida e o grava para todas as tentativas subsequentes de obter um valor.  Para contornar a corrida, implementa√ß√µes espec√≠ficas da JVM podem tentar usar opera√ß√µes CAS, se a plataforma as suportar, o vencedor da corrida ver√° o valor padr√£o anterior e os perdedores ver√£o o valor n√£o padr√£o que venceu a corrida. </p><br><p>  Assim, as regras existentes para a atribui√ß√£o √∫nica de vari√°veis ‚Äã‚Äãfinais continuam funcionando e agora capturam todas as dificuldades da computa√ß√£o lenta. </p><br><p>  A mesma l√≥gica se aplica √† publica√ß√£o segura usando campos finais - √© a mesma para campos pregui√ßosos e n√£o pregui√ßosos. </p><br><p>  Observe que uma classe pode converter um campo est√°tico em um campo est√°tico lento sem quebrar a compatibilidade bin√°ria.  A <code>getstatic</code> cliente <code>getstatic</code> id√™ntica nos dois casos.  Quando uma declara√ß√£o de vari√°vel muda para lento, o <code>getstatic</code> vinculado de uma maneira diferente. </p><br><h1 id="alternativnye-resheniya">  Solu√ß√µes alternativas </h1><br><p>  Voc√™ pode usar classes aninhadas como cont√™ineres para vari√°veis ‚Äã‚Äãpregui√ßosas. </p><br><p>  Voc√™ pode definir algo como uma API de biblioteca para gerenciar valores pregui√ßosos ou (de maneira mais geral) quaisquer dados mon√≥tonos. </p><br><p>  Refatorar o que eles tornariam vari√°veis ‚Äã‚Äãest√°ticas pregui√ßosas para que se transformassem em m√©todos est√°ticos nulos e seus corpos fossem publicados usando constantes ldc CONSTANT_Dynamic, de alguma forma. </p><br><p>  (Nota: As solu√ß√µes alternativas acima n√£o fornecem uma maneira bin√°ria compat√≠vel de desacoplar evolutivamente as constantes est√°ticas existentes de sua <code>&lt;clinit&gt;</code> ) </p><br><p>  Se falamos em fornecer <em>mais</em> funcionalidade, voc√™ pode permitir que campos pregui√ßosos sejam n√£o est√°ticos ou n√£o finais, mantendo as correspond√™ncias e analogias atuais entre o comportamento de campos est√°ticos e n√£o est√°ticos.  Um pool constante n√£o pode ser um reposit√≥rio para campos n√£o est√°ticos, mas ainda pode conter m√©todos de autoinicializa√ß√£o (dependendo da inst√¢ncia atual).  Matrizes congeladas (se implementadas) podem obter uma op√ß√£o lenta.  Tais estudos s√£o uma boa base para futuros projetos constru√≠dos com base neste documento.  E, a prop√≥sito, essas oportunidades tornam nossa decis√£o de proibir valores padr√£o ainda mais significativos. </p><br><p>  Vari√°veis ‚Äã‚Äãpregui√ßosas devem ser inicializadas usando suas pr√≥prias express√µes de inicializa√ß√£o.  √Äs vezes, isso parece uma limita√ß√£o muito desagrad√°vel que nos leva de volta ao tempo da inven√ß√£o de vari√°veis ‚Äã‚Äãfinais vazias.  Lembre-se de que essas vari√°veis ‚Äã‚Äãfinais vazias podem ser inicializadas com blocos de c√≥digo arbitr√°rios, incluindo a l√≥gica try-finally, e podem ser inicializadas em grupos e n√£o simultaneamente.  No futuro, ser√° poss√≠vel tentar aplicar as mesmas possibilidades a vari√°veis ‚Äã‚Äãfinais pregui√ßosas.  Talvez uma ou mais vari√°veis ‚Äã‚Äãpregui√ßosas possam ser associadas a um bloco particular de c√≥digo de inicializa√ß√£o, cuja tarefa √© atribuir cada vari√°vel exatamente uma vez, como acontece com um inicializador de classe ou construtor de objeto.  A arquitetura desse recurso pode se tornar mais clara ap√≥s o aparecimento dos desconstrutores, uma vez que as tarefas que eles resolvem se cruzam em algum sentido. </p><br><blockquote>  Minuto de publicidade.  A Confer√™ncia Joker 2018 ser√° realizada muito em breve, onde haver√° muitos especialistas de destaque em Java e JVM.  Veja a lista completa de palestrantes e relat√≥rios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site oficial</a> . </blockquote><br><h1 id="avtor">  O autor </h1><br><p>  <strong>John Rose</strong> √© engenheiro e arquiteto de JVM na Oracle.  Engenheiro L√≠der Da Vinci Machine Project (parte do OpenJDK).  O engenheiro l√≠der JSR 292 (Suporte a linguagens dinamicamente tipadas na plataforma Java) √© especializado em chamadas din√¢micas e t√≥picos relacionados, como cria√ß√£o de perfil de tipo e otimiza√ß√µes avan√ßadas de compilador.  Anteriormente, ele trabalhou em classes internas, criou a porta HotSpot original em SPARC, API insegura e tamb√©m desenvolveu muitas linguagens din√¢micas, paralelas e h√≠bridas, incluindo Common Lisp, Scheme ("esh"), ligantes din√¢micos para C ++. </p><br><h1 id="perevodchik">  Tradutor </h1><br><p>  <strong>Oleg Chirukhin</strong> - no momento em que escrevia este texto, ele trabalhava como gerente de comunidade no grupo JUG.ru da empresa, e estava envolvido na populariza√ß√£o da plataforma Java.  Antes de ingressar na JRG, ele participou do desenvolvimento de sistemas de informa√ß√µes banc√°rias e governamentais, um ecossistema de linguagens de programa√ß√£o auto-escritas e jogos online.  Os interesses atuais de pesquisa incluem m√°quinas virtuais, compiladores e linguagens de programa√ß√£o. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt422629/">https://habr.com/ru/post/pt422629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt422615/index.html">Toda a verdade sobre o RTOS. Artigo 9. Agendador: implementa√ß√£o</a></li>
<li><a href="../pt422617/index.html">Toda a verdade sobre o RTOS. Artigo 8. N√∫cleo SE: Projeto Interno e Implanta√ß√£o</a></li>
<li><a href="../pt422623/index.html">Como proteger C</a></li>
<li><a href="../pt422625/index.html">Conversamos com Troy Miles - o programador do "Neuromancer"</a></li>
<li><a href="../pt422627/index.html">Pesquisa de mercado de trabalho MongoDB e TI</a></li>
<li><a href="../pt422631/index.html">Terminais QIWI. Como tirar o m√°ximo proveito das tecnologias simples</a></li>
<li><a href="../pt422633/index.html">Como automatizamos o monitoramento do trabalho dos funcion√°rios da rede federal de postos de gasolina</a></li>
<li><a href="../pt422635/index.html">Voc√™ ainda n√£o disse a palavra "ol√°" e j√° sabemos quem voc√™ √©</a></li>
<li><a href="../pt422637/index.html">Presente de Geek: Prote√ß√£o Autom√°tica de Alkash</a></li>
<li><a href="../pt422641/index.html">Noite polar, bombeamento de √°gua e cofre inteligente: 5 projetos de estudantes no campo da IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>