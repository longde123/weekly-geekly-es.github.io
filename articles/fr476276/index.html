<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¥ üë∂üèæ üõ∂ √âcrire un simple √©quilibreur sur Go üì© ‚úåüèΩ üçü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les √©quilibreurs de charge jouent un r√¥le cl√© dans l'architecture Web. Ils vous permettent de r√©partir la charge sur plusieurs backends, am√©liorant ai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcrire un simple √©quilibreur sur Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476276/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t8/nm/ze/t8nmzevaswfyxtitu7xpx3ml-ho.jpeg"></div><br>  Les √©quilibreurs de charge jouent un r√¥le cl√© dans l'architecture Web.  Ils vous permettent de r√©partir la charge sur plusieurs backends, am√©liorant ainsi l'√©volutivit√©.  Et puisque nous avons plusieurs backends configur√©s, le service devient hautement disponible, car en cas de panne sur un serveur, l'√©quilibreur peut choisir un autre serveur de travail. <br><br>  Ayant jou√© avec des √©quilibreurs professionnels comme NGINX, j'ai essay√© de cr√©er un √©quilibreur simple pour le plaisir.  Je l'ai √©crit sur Go, c'est un langage moderne qui supporte le parall√©lisme complet.  La biblioth√®que standard de Go poss√®de de nombreuses fonctionnalit√©s et vous permet d'√©crire des applications hautes performances avec moins de code.  De plus, pour faciliter la distribution, il g√©n√®re un seul binaire li√© statiquement. <br><a name="habracut"></a><br><h2>  Comment fonctionne notre √©quilibreur </h2><br>  Diff√©rents algorithmes sont utilis√©s pour r√©partir la charge entre les backends.  Par exemple: <br><br><ul><li>  Round Robin - la charge est r√©partie uniform√©ment, en tenant compte de la m√™me puissance de calcul des serveurs. </li><li>  Round Robin pond√©r√© - Selon la puissance de traitement, les serveurs peuvent se voir attribuer des poids diff√©rents. </li><li>  Least Connections - la charge est r√©partie sur les serveurs avec le moins de connexions actives. </li></ul><br>  Dans notre √©quilibreur, nous impl√©mentons l'algorithme le plus simple - Round Robin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3e/35c/751/b3e35c7510dc44451088756d14739161.png"></div><br><br><h2>  S√©lection au Round Robin </h2><br>  L'algorithme Round Robin est simple.  Il donne √† tous les interpr√®tes la m√™me possibilit√© d'accomplir des t√¢ches. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/4a7/861/3b34a78610b7c1e2d22b85f0419700d2.png"></div><br>  <i>S√©lectionnez les serveurs dans Round Robin pour g√©rer les demandes entrantes.</i> <br><br>  Comme le montre l'illustration, l'algorithme s√©lectionne les serveurs dans un cercle, de mani√®re cyclique.  Mais nous ne pouvons pas les s√©lectionner <i>directement</i> , non? <br><br>  Et si le serveur ment?  Nous n'avons probablement pas besoin de lui envoyer de trafic.  Autrement dit, le serveur ne peut pas √™tre utilis√© directement tant que nous ne l'avons pas amen√© √† l'√©tat souhait√©.  Il est n√©cessaire de diriger le trafic uniquement vers les serveurs qui sont op√©rationnels. <br><br><h2>  D√©finir la structure </h2><br>  Nous devons suivre tous les d√©tails li√©s au backend.  Vous devez savoir s'il est vivant et suivre l'URL.  Pour ce faire, nous pouvons d√©finir la structure suivante: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Backend <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { URL *url.URL Alive <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mux sync.RWMutex ReverseProxy *httputil.ReverseProxy }</code> </pre> <br>  Ne vous inqui√©tez pas, je vais vous expliquer la signification des champs dans le Backend. <br><br>  Maintenant, dans l'√©quilibreur, vous devez en quelque sorte suivre tous les backends.  Pour ce faire, vous pouvez utiliser Slice et un compteur variable.  D√©finissez-le dans ServerPool: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ServerPool <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { backends []*Backend current <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> }</code> </pre> <br><h2>  Utilisation de ReverseProxy </h2><br>  Comme nous l'avons d√©j√† d√©termin√©, l'essence de l'√©quilibreur consiste √† distribuer le trafic vers diff√©rents serveurs et √† renvoyer les r√©sultats au client.  Comme l'indique la documentation de Go: <br><br>  <i>ReverseProxy est un gestionnaire HTTP qui prend les demandes entrantes et les envoie √† un autre serveur, renvoyant les r√©ponses par procuration au client.</i> <br><br>  Exactement ce dont nous avons besoin.  Pas besoin de r√©inventer la roue.  Vous pouvez simplement diffuser nos demandes via <code>ReverseProxy</code> . <br><br><pre> <code class="go hljs">u, _ := url.Parse(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080"</span></span>) rp := httputil.NewSingleHostReverseProxy(u) <span class="hljs-comment"><span class="hljs-comment">// initialize your server and add this as handler http.HandlerFunc(rp.ServeHTTP)</span></span></code> </pre> <br>  √Ä l'aide de <code>httputil.NewSingleHostReverseProxy(url)</code> vous pouvez initialiser <code>ReverseProxy</code> , qui diffusera les demandes √† l' <code>url</code> transmise.  Dans l'exemple ci-dessus, toutes les demandes ont √©t√© envoy√©es √† localhost: 8080 et les r√©sultats ont √©t√© envoy√©s au client. <br><br>  Si vous regardez la signature de la m√©thode ServeHTTP, vous pouvez y trouver la signature du gestionnaire HTTP.  Par cons√©quent, vous pouvez le transmettre √† <code>HandlerFunc</code> dans <code>http</code> . <br><br>  D'autres exemples sont dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://golang.org/pkg/net/http/">documentation</a> . <br><br>  Pour notre √©quilibreur, vous pouvez lancer <code>ReverseProxy</code> avec l' <code>URL</code> associ√©e dans <code>Backend</code> afin que ReverseProxy achemine les demandes vers l' <code>URL</code> . <br><br><h2>  Processus de s√©lection du serveur </h2><br>  Lors de la prochaine s√©lection de serveurs, nous devons ignorer les serveurs sous-jacents.  Mais vous devez organiser le d√©compte. <br><br>  De nombreux clients se connectent √† l'√©quilibreur et lorsque chacun d'eux demande au n≈ìud suivant de transf√©rer le trafic, une condition de concurrence critique peut se produire.  Pour √©viter cela, nous pouvons bloquer <code>ServerPool</code> avec <code>mutex</code> .  Mais ce sera redondant, d'ailleurs nous ne voulons pas du tout bloquer <code>ServerPool</code> .  Nous avons juste besoin d'augmenter le compteur d'une unit√©. <br><br>  La meilleure solution pour r√©pondre √† ces exigences serait l'incr√©mentation atomique.  Go le prend en charge avec le package <code>atomic</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *ServerPool)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(atomic.AddUint64(&amp;s.current, <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) % <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s.backends))) }</code> </pre> <br>  Nous augmentons atomiquement la valeur actuelle de un et retournons l'index en modifiant la longueur du tableau.  Cela signifie que la valeur doit toujours √™tre comprise entre 0 et la longueur du tableau.  En fin de compte, nous serons int√©ress√©s par un indice sp√©cifique, pas le compteur entier. <br><br><h2>  Choisir un serveur en direct </h2><br>  Nous savons d√©j√† que nos demandes tournent cycliquement sur tous les serveurs.  Et nous n'avons qu'√† sauter le ralenti. <br><br>  <code>GetNext()</code> renvoie toujours une valeur allant de 0 √† la longueur du tableau.  √Ä tout moment, nous pouvons obtenir le n≈ìud suivant, et s'il est inactif, nous devons rechercher plus loin dans le tableau dans le cadre de la boucle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/7a7/fc5/9c17a7fc56f9bf6c9e4583c29127aa55.png"></div><br>  <i>Nous parcourons le tableau.</i> <br><br>  Comme le montre l'illustration, nous voulons passer du n≈ìud suivant √† la fin de la liste.  Cela peut √™tre fait en utilisant <code>next + length</code> .  Mais pour s√©lectionner un index, vous devez le limiter √† la longueur du tableau.  Cela peut facilement √™tre fait en utilisant l'op√©ration de modification. <br><br>  Apr√®s avoir trouv√© un serveur qui fonctionne pendant la recherche, il doit √™tre marqu√© comme courant: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetNextPeer returns next active peer to take a connection func (s *ServerPool) GetNextPeer() *Backend { // loop entire backends to find out an Alive backend next := s.NextIndex() l := len(s.backends) + next // start from next and move a full cycle for i := next; i &lt; l; i++ { idx := i % len(s.backends) // take an index by modding with length // if we have an alive backend, use it and store if its not the original one if s.backends[idx].IsAlive() { if i != next { atomic.StoreUint64(&amp;s.current, uint64(idx)) // mark the current one } return s.backends[idx] } } return nil }</span></span></code> </pre><br><h2>  √âviter la condition de concurrence dans la structure Backend </h2><br>  Ici, vous devez vous souvenir d'un probl√®me important.  La structure <code>Backend</code> contient une variable que plusieurs goroutines peuvent modifier ou interroger en m√™me temps. <br><br>  Nous savons que les goroutines liront la variable plus que ne lui √©criront.  Par cons√©quent, pour s√©rialiser l'acc√®s √† <code>Alive</code> nous avons choisi <code>RWMutex</code> . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// SetAlive for this backend func (b *Backend) SetAlive(alive bool) { b.mux.Lock() b.Alive = alive b.mux.Unlock() } // IsAlive returns true when backend is alive func (b *Backend) IsAlive() (alive bool) { b.mux.RLock() alive = b.Alive b.mux.RUnlock() return }</span></span></code> </pre><br><h2>  √âquilibrer les demandes </h2><br>  Nous pouvons maintenant formuler une m√©thode simple pour √©quilibrer nos demandes.  Il √©chouera uniquement si tous les serveurs tombent. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Cette m√©thode peut √™tre transmise au serveur HTTP simplement en tant que <code>HandlerFunc</code> . <br><br><pre> <code class="go hljs">server := http.Server{ Addr: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">":%d"</span></span>, port), Handler: http.HandlerFunc(lb), }</code> </pre><br><h2>  Nous acheminons le trafic uniquement vers des serveurs en cours d'ex√©cution </h2><br>  Notre √©quilibreur a un s√©rieux probl√®me.  Nous ne savons pas si le serveur fonctionne.  Pour le savoir, vous devez v√©rifier le serveur.  Il existe deux fa√ßons de proc√©der: <br><br><ul><li>  Actif: en ex√©cutant la requ√™te en cours, nous constatons que le serveur s√©lectionn√© ne r√©pond pas et le marquons comme inactif. </li><li>  Passif: vous pouvez envoyer une requ√™te ping aux serveurs √† un certain intervalle et v√©rifier l'√©tat. </li></ul><br><h2>  V√©rification active des serveurs en cours d'ex√©cution </h2><br>  Si une erreur <code>ReverseProxy</code> lance la fonction de rappel <code>ErrorHandler</code> .  Cela peut √™tre utilis√© pour d√©tecter les pannes: <br><br><pre> <code class="go hljs">proxy.ErrorHandler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(writer http.ResponseWriter, request *http.Request, e error)</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"[%s] %s\n"</span></span>, serverUrl.Host, e.Error()) retries := GetRetryFromContext(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> retries &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-time.After(<span class="hljs-number"><span class="hljs-number">10</span></span> * time.Millisecond): ctx := context.WithValue(request.Context(), Retry, retries+<span class="hljs-number"><span class="hljs-number">1</span></span>) proxy.ServeHTTP(writer, request.WithContext(ctx)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">// after 3 retries, mark this backend as down serverPool.MarkBackendStatus(serverUrl, false) // if the same request routing for few attempts with different backends, increase the count attempts := GetAttemptsFromContext(request) log.Printf("%s(%s) Attempting retry %d\n", request.RemoteAddr, request.URL.Path, attempts) ctx := context.WithValue(request.Context(), Attempts, attempts+1) lb(writer, request.WithContext(ctx)) }</span></span></code> </pre> <br>  Pour d√©velopper ce gestionnaire d'erreurs, nous avons utilis√© les capacit√©s des fermetures.  Cela nous permet de capturer des variables externes telles que les URL de serveur dans notre m√©thode.  Le gestionnaire v√©rifie le compteur de nouvelles tentatives et s'il est inf√©rieur √† 3, nous envoyons √† nouveau la m√™me demande au m√™me serveur.  En effet, en raison d'erreurs temporaires, le serveur peut abandonner nos demandes, mais il devient bient√¥t disponible (le serveur peut ne pas avoir de sockets libres pour les nouveaux clients).  Vous devez donc r√©gler la temporisation pour une nouvelle tentative apr√®s environ 10 ms.  A chaque demande nous augmentons le compteur de tentatives. <br><br>  Apr√®s l'√©chec de chaque tentative, nous marquons le serveur comme inactif. <br><br>  Vous devez maintenant attribuer un nouveau serveur pour la m√™me demande.  Nous le ferons en utilisant le compteur de tentatives en utilisant le package de <code>context</code> .  Apr√®s avoir augment√© le compteur de tentatives, nous le passons √† <code>lb</code> pour s√©lectionner un nouveau serveur pour traiter la demande. <br><br>  Nous ne pouvons pas le faire ind√©finiment, nous v√©rifierons donc si le nombre maximal de tentatives a √©t√© atteint avant de poursuivre le traitement de la demande. <br><br>  Vous pouvez simplement obtenir le compteur de tentatives √† partir de la demande, s'il atteint le maximum, nous interrompons la demande. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { attempts := GetAttemptsFromContext(r) if attempts &gt; 3 { log.Printf("%s(%s) Max attempts reached, terminating\n", r.RemoteAddr, r.URL.Path) http.Error(w, "Service not available", http.StatusServiceUnavailable) return } peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Il s'agit d'une impl√©mentation r√©cursive. <br><br><h2>  Utilisation du package de contexte </h2><br>  Le package de <code>context</code> vous permet de stocker des donn√©es utiles dans des requ√™tes HTTP.  Nous l'utiliserons activement pour suivre les donn√©es li√©es aux demandes - compteurs de <code>Attempt</code> et de nouvelle <code>Attempt</code> . <br><br>  Tout d'abord, vous devez d√©finir les cl√©s du contexte.  Il est recommand√© d'utiliser non pas une cha√Æne, mais des valeurs num√©riques uniques.  Go a un mot-cl√© <code>iota</code> pour l'impl√©mentation incr√©mentielle des constantes, chacune contenant une valeur unique.  Il s'agit d'une excellente solution pour d√©finir des touches num√©riques. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( Attempts <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> Retry )</code> </pre> <br>  Vous pouvez ensuite extraire la valeur, comme nous le faisons habituellement avec le <code>HashMap</code> .  La valeur par d√©faut peut d√©pendre de la situation actuelle. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetAttemptsFromContext returns the attempts for request func GetRetryFromContext(r *http.Request) int { if retry, ok := r.Context().Value(Retry).(int); ok { return retry } return 0 }</span></span></code> </pre><br><h2>  Validation passive du serveur </h2><br>  Les contr√¥les passifs identifient et r√©cup√®rent les serveurs tomb√©s en panne.  Nous les cinglons √† un certain intervalle pour d√©terminer leur statut. <br><br>  Pour envoyer une requ√™te ping, essayez d'√©tablir une connexion TCP.  Si le serveur r√©pond, nous le marquons comme fonctionnant.  Cette m√©thode peut √™tre adapt√©e pour appeler des points de terminaison sp√©cifiques comme <code>/status</code> .  Assurez-vous de fermer la connexion apr√®s sa cr√©ation pour r√©duire la charge suppl√©mentaire sur le serveur.  Sinon, il tentera de maintenir cette connexion et finira par √©puiser ses ressources. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// isAlive checks whether a backend is Alive by establishing a TCP connection func isBackendAlive(u *url.URL) bool { timeout := 2 * time.Second conn, err := net.DialTimeout("tcp", u.Host, timeout) if err != nil { log.Println("Site unreachable, error: ", err) return false } _ = conn.Close() // close it, we dont need to maintain this connection return true }</span></span></code> </pre> <br>  Vous pouvez maintenant parcourir les serveurs et marquer leurs statuts: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HealthCheck pings the backends and update the status func (s *ServerPool) HealthCheck() { for _, b := range s.backends { status := "up" alive := isBackendAlive(b.URL) b.SetAlive(alive) if !alive { status = "down" } log.Printf("%s [%s]\n", b.URL, status) } }</span></span></code> </pre> <br>  Pour ex√©cuter ce code p√©riodiquement, vous pouvez ex√©cuter le minuteur dans Go.  Il vous permettra d'√©couter les √©v√©nements de la cha√Æne. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// healthCheck runs a routine for check status of the backends every 2 mins func healthCheck() { t := time.NewTicker(time.Second * 20) for { select { case &lt;-tC: log.Println("Starting health check...") serverPool.HealthCheck() log.Println("Health check completed") } } }</span></span></code> </pre> <br>  Dans ce code, le canal <code>&lt;-tC</code> renverra une valeur toutes les 20 secondes.  <code>select</code> vous permet de d√©finir cet √©v√©nement.  En l'absence de situation <code>default</code> , il attend qu'au moins un cas puisse √™tre ex√©cut√©. <br><br>  Maintenant, ex√©cutez le code dans un goroutine distinct: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> healthCheck()</code> </pre><br><h2>  Conclusion </h2><br>  Dans cet article, nous avons examin√© de nombreuses questions: <br><br><ul><li>  Algorithme Round Robin </li><li>  ReverseProxy de la biblioth√®que standard </li><li>  Mutex </li><li>  Op√©rations atomiques </li><li>  Court-circuits </li><li>  Rappels </li><li>  Op√©ration de s√©lection </li></ul><br>  Il existe de nombreuses autres fa√ßons d'am√©liorer notre √©quilibreur.  Par exemple: <br><br><ul><li>  Utilisez le tas pour trier les serveurs en direct afin de r√©duire la port√©e de la recherche. </li><li>  Recueillir des statistiques. </li><li>  Impl√©mentez l'algorithme round-robin pond√©r√© avec le moins de connexions. </li><li>  Ajoutez la prise en charge des fichiers de configuration. </li></ul><br>  Et ainsi de suite. <br><br>  Le code source est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476276/">https://habr.com/ru/post/fr476276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476264/index.html">Bot t√©l√©gramme pour l'apprentissage des langues √©trang√®res: du bourrage de mots √† la parole</a></li>
<li><a href="../fr476266/index.html">Stage chez Mars Digital Technologies. Comment nous avons appliqu√© le deep learning chez M&M's</a></li>
<li><a href="../fr476268/index.html">Solutions aux d√©fis de d√©tection de bugs propos√©s par l'√©quipe PVS-Studio lors de conf√©rences en 2018-2019</a></li>
<li><a href="../fr476270/index.html">Notre victoire: TopCoder Open 2019</a></li>
<li><a href="../fr476272/index.html">R√©ponses aux t√¢ches du stand PVS-Studio lors des conf√©rences 2018-2019</a></li>
<li><a href="../fr476278/index.html">Conf√©rence BLACK HAT USA. Devenez riche ou mourez: gagnez de l'argent sur Internet en utilisant Black Hat. 3e partie</a></li>
<li><a href="../fr476280/index.html">√Ä travers les √©pines jusqu'au DOS: quatre disquettes qui ont chang√© le monde</a></li>
<li><a href="../fr476284/index.html">Nous formulons une strat√©gie pour travailler avec les erreurs dans React</a></li>
<li><a href="../fr476286/index.html">Top 5 des cadres JS pour le d√©veloppement frontal en 2020. Partie 1</a></li>
<li><a href="../fr476288/index.html">Top 5 des cadres JS pour le d√©veloppement frontal en 2020. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>