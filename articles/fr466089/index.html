<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😛 🤬 🚉 Algorithme de pensée et de conscience, partie 2 ☝🏿 🚴🏽 🧥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce texte contient des explications sur l'algorithme de mon premier article «Algorithm of Thinking and Consciousness» . Thèses du premier article: 



...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithme de pensée et de conscience, partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466089/"> Ce texte contient des explications sur l'algorithme de mon premier article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Algorithm of Thinking and Consciousness»</a> .  Thèses du premier article: <br><br><ul><li>  Le phénomène de la pensée subjective peut être algorithmisé. </li><li>  L'algorithme présenté dans l'article pense et cela peut être utilisé pratiquement. </li><li>  En utilisant l'algorithme de pensée, nous pouvons définir la conscience sous une forme asymptotique. </li></ul><a name="habracut"></a><br>  <b>Point de vue de l'auteur en général</b> .  Tout d'abord, je pars de l'hypothèse que rationalité et complexité sont une seule et même chose.  En conséquence, la logique de la complexité, quelle qu'elle soit par essence, précède tout autre type de logique et est donc absolue.  C'est de ce point de vue que mon algorithme proposé est raisonnable, car il peut atteindre toute complexité structurelle dans un processus informatique formel. <br><br>  L'algorithme de réflexion est basé sur la logique formelle de la complexité avec les propriétés suivantes: <br><br><ol><li>  Les objets de la logique sont des théories abstraites. </li><li>  Toute théorie a de la complexité et cette complexité peut être clairement vérifiée. </li><li>  De toute théorie, une théorie plus complexe peut être déduite. </li><li>  De toute théorie complexe, une théorie simple peut être déduite. </li><li>  Il y aura des conclusions différentes de deux théories différentes. </li><li>  Toute théorie a un sens.  Une théorie est dite significative si elle est unique et infiniment complexe.  En pratique, cela signifie qu'une chaîne potentiellement infinie de conclusions peut être construite à partir d'une théorie significative, de sorte que toutes les conclusions de la chaîne sont uniques et que chaque conclusion ultérieure est plus compliquée que la précédente. </li></ol><br>  Le passage d'une théorie simple à une théorie plus complexe, avec de nombreuses théories substantielles, correspond intuitivement au concept de pensée idéale.  La mise en œuvre constructive d'une telle logique sera, entre autres, la théorie constructive de la pensée. <br><br>  <b>En savoir plus sur les théories abstraites</b> .  Les théories abstraites sont tout ce dont on sait seulement qu'elles sont inhérentes à la complexité constructive, car cette complexité peut être clairement vérifiée.  Et il est également connu que d'une telle chose une transition constructive vers d'autres pièces plus complexes est possible et cela peut également être vérifié. <br><br>  <b>Informellement sur la complexité constructive</b> .  Un objet complexe est quelque chose qui peut être uniquement décomposé en objets simples.  Plus les objets contenus dans un objet complexe sont simples, plus cet objet est complexe.  Les objets simples ne peuvent pas être dessinés de manière unique.  La complexité de tous les objets simples est la même. <br><br>  En conséquence, les théories abstraites sont divisées en deux types: simples et complexes.  Une théorie est appelée complexe si, à l'aide d'une procédure, un ensemble unique de théories simples peut en être dérivé.  À son tour, pour toutes les théories simples, la même procédure renvoie un résultat constant, et donc la complexité des théories simples est la même.  Du fait que la complexité de la logique considérée est déterminée de manière constructive, elle peut être calculée et comparée.  Deux théories ont la même complexité si elles peuvent être décomposées en le même nombre de théories simples.  Plus les théories sont simples, plus la théorie originale est complexe. <br><br>  <b>Définition formelle de la complexité</b> .  Sur l'ensemble des théories <b>S</b> = <b>P</b> ∪ <b>C</b> , où <b>P</b> = {s ∈ <b>S</b> |  A [s] = ∅} est un sous-ensemble de théories simples, <b>C</b> = {s ∈ <b>S</b> |  A [s] ≠ ∅} est un sous-ensemble de théories complexes, l'opérateur A: <b>S</b> → 2 <sup><b>P</b></sup> définit la complexité si ∀ (c <sub>1</sub> , c <sub>2</sub> ) ∈ <b>C</b> , c <sub>1</sub> ≠ c <sub>2</sub> , A [c <sub>1</sub> ] ≠ A [c <sub>2</sub> ] ;  c'est-à-dire que pour toute théorie complexe, il existe une décomposition unique en théories simples.  À son tour, | A [s] |: une mesure numérique de la complexité s. <br><br>  <b>La logique de la complexité</b> .  L'ensemble des théories <b>S</b> , l'opérateur A et l'opérateur D: <b>S</b> → <b>S</b> tels que ∀s ∈ <b>S</b> , | A [s] |  &lt;| A [D [s]] |, et ∀ (s <sub>1</sub> , s <sub>2</sub> ) ∈ <b>S</b> , s <sub>1</sub> ≠ s <sub>2</sub> , D [s <sub>1</sub> ] ≠ D [s <sub>2</sub> ], définissent la logique de la complexité.  L'opérateur D d'une théorie donnée en déduit une nouvelle, garantie plus compliquée. <br><br>  <b>La mise en œuvre de la logique de la complexité</b> .  La logique décrite ci-dessus peut être exprimée en opérations formelles sur des chaînes d'un type spécial.  Veuillez consulter le premier article pour une description détaillée de la mise en œuvre.  Ci-dessous est juste une description schématique simplifiée de la mise en œuvre. <br><br>  <b>De nombreuses théories</b> .  Pour représenter les théories, des chaînes sont utilisées qui consistent en une séquence arbitraire de parenthèses '(', ')' et de tout identifiant graphique à l'intérieur des crochets.  Par souci de concision, chaque lettre est considérée comme un identifiant distinct.  Le contenu entier de la chaîne doit être placé entre crochets externes communs.  Pour chaque support d'ouverture dans la ligne doit se fermer.  Exemple: la ligne <b>((b) a (e)) est</b> correcte, tandis que les lignes <b>(b) a (e)</b> , <b>(a (b (e) sont</b> incorrectes. <br><br>  De nombreuses théories <b>S</b> consistent en toutes les lignes régulières possibles. <br><br>  Deux lignes sont égales si elles coïncident jusqu'à une permutation d'éléments indivisibles dans des sous-chaînes.  Un exemple de la façon dont vous pouvez réorganiser les éléments: (ab (cd)) ≡ ((cd) ab) ≡ (b (dc) a) ≡ ... ≡ ((dc) ba).  Les sous-chaînes vides ne sont pas significatives et sont jetées, par exemple, (a ()) ≡ (a). <br><br>  <b>Règles de retrait</b> .  Sur l'ensemble <b>S,</b> trois règles d'inférence sont données. <br><br>  <b>Règle d'abstraction</b> .  S'applique aux sous-chaînes d'une chaîne donnée.  Vous permet de mettre entre crochets le même contenu.  De tout groupe de parenthèses au même niveau, toutes les sous-chaînes identiques peuvent être retirées des parenthèses, selon le principe suivant: <br><br> <code>((ab)(ac)) ⇒ (a(bc)); <br> <br> ((ab)(abc)) ⇒ { (a(bbc)), (b(aac)), (ab(c )) }; <br> <br> ((ab)(ac)(ae)) ⇒ { (a(bce)), (a(bc)(ae)), (a(ab)(ce)) };</code> <br> <br>  Selon la règle d'abstraction, les résultats sont toujours plus simples que la chaîne d'origine.  Dans le cas de chaînes simples, par exemple, ((a) (b)), le résultat de l'application de la règle d'abstraction est vide.  L'application récursive de la règle d'abstraction vous permet de décomposer toute chaîne complexe en chaînes simples. <br><br>  <b>La règle de la déduction</b> .  Selon cette règle, vous pouvez obtenir autant de nouvelles lignes que vous le souhaitez à partir de la ligne source en dupliquant tous les éléments de la ligne source un nombre donné de fois, selon le principe suivant: <br><br> <code>(a) ⇒ { ((aa)(aa)), ((aaa)(aaa)(aaa)), ((aaaa)(aaaa)(aaaa)(aaaa)), …}; <br> <br> (a(b)) ⇒ { ((aa(bb)(bb))(aa(bb)(bb))), ((aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))), …}; <br> <br> (a(b(cc))) ⇒ { (aa(bb(cccc)(cccc))(bb(cccc)(cccc)))(aa(bb(cccc)(cccc))(bb(cccc)(cccc))), …};</code> <br> <br>  <b>Règle de composition</b>  Tout ensemble de lignes de <b>S</b> peut être combiné en une seule ligne.  Par exemple: (a), (b), (e) ⇒ ((a) (b) (e)). <br><br>  <b>Opérateur</b> A. Le résultat de l'opérateur est un ensemble unique de chaînes simples.  L'application récursive de la règle d'abstraction à une ligne donnée, jusqu'à ce qu'elle s'arrête lorsque toutes les options de décomposition possibles sont épuisées, correspond à l'action de l'opérateur A. <br><br>  Je veux attirer l'attention sur le fait que dans l'article principal, l'opérateur d'abstraction, contrairement à l'opérateur A, dans le résultat de son travail comprend non seulement simple, mais en général toutes les lignes qui peuvent être affichées selon la règle d'abstraction. <br><br>  <b>Opérateur</b> D. Une règle de déduction avec un paramètre de duplication donné correspond à l'action de l'opérateur D. De n'importe quelle ligne donnée, une ligne plus complexe peut être déduite de la règle de déduction, et ce fait peut être vérifié en utilisant l'opérateur A. <br><br>  <b>Opérateur de composition</b> ().  Correspond à l'action de la règle de composition. <br><br>  Ainsi, un système formel est obtenu qui satisfait la définition de la logique de complexité. <br><br>  <b>Le contenu des théories</b> .  Dans la logique de la complexité, chaque théorie a un sens.  Puisque ∀s ∈ <b>S,</b> il existe une chaîne unique de conclusions t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]) de complexité croissante et potentiellement infinie. <br><br>  <b>L'hypothèse d'insolvabilité</b> .  Ensembles de la forme générale T <sub>s</sub> = {p ∈ <b>S</b> |  ∀n ∈ <b>N</b> , p ∈ A [D [t <sub>n</sub> ]];  t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]);  t <sub>0</sub> = s} Je considère comme insoluble.  L'ensemble T <sub>s</sub> contient toutes les chaînes simples dérivées par la fonction récursive t <sub>n</sub> de la ligne de départ s.  Étant donné l'insolvabilité de T <sub>s</sub> , la sortie t <sub>n</sub> est aléatoire de manière algorithmique.  Il n'y a aucune preuve. <br><br>  <b>Penser</b>  t <sub>n</sub> a le caractère de complexité comme dans la pensée idéale et sur cette base est une forme de pensée idéale.  À chaque itération t <sub>n,</sub> il y a une transition claire d'une théorie moins complexe à une nouvelle théorie plus complexe, chacune de ces transitions est unique et ce processus est potentiellement sans fin. <br><br>  La pensée réalise la conscience sous une forme asymptotique.  En gros, la «conscience de la théorie» est le contenu ultime et infiniment complexe auquel t <sub>n</sub> aspire dans le processus de calcul. <br><br>  <b>Expérience subjective</b> .  Les expériences subjectives sont l'apanage de la conscience.  La conscience n'est pas constructive. <br><br>  L'ordinateur survivra-t-il pendant l'informatique?  Non.  Mais dans les résultats des calculs, il peut y avoir des expériences aux dépens de l'ordinateur. <br><br>  <b>Conclusion</b>  Je crois que tout le monde sait combien d'imagination il faut pour construire quelque chose de vraiment complexe.  Pas seulement grand, mais complexe.  Et pour une complexité infinie, vous avez besoin d'une fantaisie sans fin.  D'où l'algorithme tire-t-il tant d'imagination?  A moins que le fantasme lui-même ne soit un algorithme. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466089/">https://habr.com/ru/post/fr466089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466069/index.html">Comment amener l'équipe à rechercher des idées plus productives</a></li>
<li><a href="../fr466071/index.html">10,3 secondes par hachage: extraction sur l'ordinateur de contrôle embarqué du vaisseau spatial Apollo</a></li>
<li><a href="../fr466075/index.html">Comment j'ai quitté la science fondamentale dans une startup</a></li>
<li><a href="../fr466077/index.html">Journée Techdir de diffusion à Saint-Pétersbourg</a></li>
<li><a href="../fr466081/index.html">3 septembre</a></li>
<li><a href="../fr466093/index.html">Comment fonctionne kubectl exec?</a></li>
<li><a href="../fr466097/index.html">Surveillance des applications .NET</a></li>
<li><a href="../fr466099/index.html">Caractéristiques du test d'une application Web pour le service vidéo</a></li>
<li><a href="../fr466103/index.html">Surveillance de la sécurité du cloud</a></li>
<li><a href="../fr466105/index.html">Overclocking de l'API Magento Rest avec RoadRunner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>