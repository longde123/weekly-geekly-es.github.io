<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕓 🌍 🖐🏽 Rohre & Filter. Beispielanwendung und Implementierung mit Spring 🎷 👊 👨🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird die Verwendung des Pipes & Filters-Musters erläutert. 


 Zunächst analysieren wir ein Beispiel einer Funktion, die wir später ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rohre & Filter. Beispielanwendung und Implementierung mit Spring</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479464/"><p>  In diesem Artikel wird die Verwendung des Pipes &amp; Filters-Musters erläutert. </p><br><p>  Zunächst analysieren wir ein Beispiel einer Funktion, die wir später anhand des oben genannten Musters umschreiben werden.  Änderungen im Code werden schrittweise vorgenommen und jedes Mal werden wir eine funktionsfähige Version erstellen, bis wir uns mit der Lösung unter Verwendung von DI befassen (in diesem Spring-Beispiel). </p><br><p>  Aus diesem Grund werden wir verschiedene Lösungen entwickeln, die die Möglichkeit bieten, beliebige Lösungen zu verwenden. <br>  Am Ende vergleichen wir die Erst- und Endimplementierungen, betrachten Anwendungsbeispiele in realen Projekten und fassen zusammen. </p><a name="habracut"></a><br><h2 id="zadacha">  Herausforderung </h2><br><p>  Angenommen, wir haben ein paar Kleidungsstücke, die wir durch Trocknen bekommen und die wir jetzt in den Schrank bringen müssen.  Es stellt sich heraus, dass die Daten (Kleidung) von einem separaten Dienst stammen und die Aufgabe darin besteht, dem Kunden diese Daten in der richtigen Form (in einem Schrank, von dem er Kleidung erhalten kann) zur Verfügung zu stellen. </p><br><p>  In den meisten Fällen können Sie die erhaltenen Daten nicht in der Form verwenden, in der sie bei uns eingehen.  Diese Daten müssen überprüft, transformiert, sortiert usw. werden. <br>  Angenommen, ein Kunde verlangt, dass Kleidung gebügelt wird, wenn sie neu ist. </p><br><p> Dann erstellen wir zum ersten Mal einen <code>Modifier</code> , in dem wir die Änderungen vorschreiben: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { <span class="hljs-comment"><span class="hljs-comment">// }); } }</span></span></code> </pre> <br><p>  In dieser Phase ist alles einfach und klar.  Lassen Sie uns einen Test schreiben, der prüft, ob alle zerknitterten Kleidungsstücke gebügelt wurden. </p><br><p>  Mit der Zeit treten jedoch neue Anforderungen auf und die Funktionalität der <code>Modifier</code> Klasse wird jedes Mal erweitert: </p><br><ul><li>  Stellen Sie keine schmutzige Wäsche in den Schrank. </li><li>  Hemden, Jacken und Hosen sollten an den Schultern hängen. </li><li>  Undichte Socken müssen zuerst vernäht werden </li><li>  ... </li></ul><br><p>  Die Reihenfolge der Änderungen ist ebenfalls wichtig.  Zum Beispiel können Sie nicht zuerst Kleidung auf die Schultern hängen und dann bügeln. </p><br><p>  Daher kann <code>Modifier</code> irgendwann die folgende Form annehmen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); (); (); (); <span class="hljs-comment"><span class="hljs-comment">//   return ; } private void (List&lt;&gt; ) { .stream() .filter(.class::isInstance) .map(.class::cast) .filter(::) .forEach(o -&gt; { // }); } private void (List&lt;&gt; ) { .stream() .filter(___) .forEach(o -&gt; { //   }); } private void (List&lt;&gt; ) { .removeIf(::); } private void (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { // }); } //  }</span></span></code> </pre> <br><p>  Dementsprechend sind die Tests komplizierter geworden, die nun zumindest jeden Schritt einzeln prüfen müssen. </p><br><p>  Und wenn eine neue Anforderung eingeht, sehen wir uns den Code an und entscheiden, dass der Zeitpunkt für das Refactoring gekommen ist. </p><br><h2 id="refactoring">  Refactoring </h2><br><p>  Das erste, was auffällt, ist das häufige Zerschlagen aller Kleidungsstücke.  Im ersten Schritt bewegen wir also alles in einem Zyklus und übertragen die Sauberkeitsprüfung auch auf den Beginn des Zyklus: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   } return result; } private void ( ) { if( instanceof ){ // ()  } } private void ( ) { if(___.test()){ //   } } private void ( ) { if(.()){ // } } //  }</span></span></code> </pre> <br><p>  Jetzt ist die Bearbeitungszeit für Kleidung verkürzt, aber der Code ist immer noch zu lang für eine Klasse und für den gesamten Zyklus.  Versuchen wir zunächst, den Zyklus zu verkürzen. </p><br><ul><li><p>  Nachdem Sie die Sauberkeit überprüft haben, können Sie alle Anrufe in einer separaten <code>modify( )</code> tätigen <code>modify( )</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); modify(o); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( o)</span></span></span><span class="hljs-function"> </span></span>{ (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br></li><li><p>  Sie können alle Anrufe zu einem <code>Consumer</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;&gt; modification = ((Consumer&lt;&gt;) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::); <span class="hljs-comment"><span class="hljs-comment">//   public List&lt;&gt; modify(List&lt;&gt; ){ return .stream() .filter(o -&gt; !o.()) .peek(modification) .collect(Collectors.toList()); }</span></span></code> </pre> <br><blockquote>  Stumpf: Blick <br>  Ich habe einen kurzen Blick verwendet.  Sonar wird sagen, dass ein solcher Code nicht gemacht werden sollte, weil  Javadoc teilt Peek mit, dass die Methode hauptsächlich für das Debug existiert.  Aber wenn Sie es auf der Karte neu schreiben: .map (o -&gt; {modification.accept (o); return o;}), dann sagt IDEA, dass es besser ist, peek zu verwenden </blockquote><br></li></ul><br><blockquote>  Stolpern: Verbraucher <br>  Ein Beispiel mit Consumer (und anschließend mit Function) zeigt die Fähigkeiten der Sprache. </blockquote><p>  Jetzt ist der Kreislauf kürzer geworden, aber die Klasse selbst ist noch zu groß und enthält zu viele Informationen (Kenntnis aller Schritte). </p><br><p>  Versuchen wir, dieses Problem mit bereits festgelegten Programmiermustern zu lösen.  In diesem Fall verwenden wir <code>Pipes &amp; Filters</code> . </p><br><h2 id="pipes--filters">  Rohre &amp; Filter </h2><br><p>  <a href="https://docs.microsoft.com/ru-ru/azure/architecture/patterns/pipes-and-filters">Die Kanal- und Filtervorlage</a> <a href="https://medium.com/nuances-of-programming/%25D0%25BA%25D1%2580%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B8%25D0%25B9-%25D0%25BE%25D0%25B1%25D0%25B7%25D0%25BE%25D1%2580-10-%25D0%25BF%25D0%25BE%25D0%25BF%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-81647be5c46f">beschreibt einen Ansatz,</a> bei dem eingehende Daten mehrere Verarbeitungsschritte durchlaufen. </p><br><p>  Versuchen wir, diesen Ansatz auf unseren Code anzuwenden. </p><br><h3 id="shag-1">  Schritt 1 </h3><br><p>  In der Tat ist unser Code bereits in der Nähe dieses Musters.  Die erhaltenen Daten durchlaufen mehrere unabhängige Schritte.  Bisher ist jede Methode ein Filter und <code>modify</code> selbst den Kanal, wobei zunächst alle schmutzigen Kleidungsstücke herausgefiltert werden. </p><br><p>  Jetzt werden wir jeden Schritt in eine separate Klasse übertragen und sehen, was wir bekommen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-comment"><span class="hljs-comment">//  public Modifier( ,  ,   //  ) { this. = ; this. = ; this. = ; //  } public List&lt;&gt; modify(List&lt;&gt; ) { return .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { .(o); .(o); .(o); //  }) .collect(Collectors.toList()); } }</span></span></code> </pre> <br><p>  Daher haben wir den Code in separate Klassen eingeteilt, um die Tests für einzelne Transformationen zu vereinfachen (und die Möglichkeit zu schaffen, Schritte wiederzuverwenden).  Die Reihenfolge der Aufrufe bestimmt die Reihenfolge der Schritte. </p><br><p>  Die Klasse selbst kennt aber noch alle Einzelschritte, kontrolliert die Reihenfolge und hat somit eine riesige Liste von Abhängigkeiten.  Zusätzlich zum Hinzufügen eines neuen Schritts müssen wir nicht nur eine neue Klasse schreiben, sondern sie auch zu <code>Modfier</code> hinzufügen. </p><br><h3 id="shag-2">  Schritt 2 </h3><br><p>  Vereinfachen Sie den Code mit Spring. <br>  Erstellen Sie zunächst für jeden einzelnen Schritt eine Schnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; }</code> </pre><br><p>  <code>Modifier</code> selbst wird jetzt viel kürzer sein: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Modification&gt; steps; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Modifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Modification&gt; steps)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.steps = steps; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { steps.forEach(m -&gt; m.modify(o)); }) .collect(Collectors.toList()); } }</code> </pre> <br><p>  <code>@Component</code> nun einen neuen Schritt hinzuzufügen, müssen Sie lediglich eine neue Klasse schreiben, die die <code>Modification</code> implementiert, und <code>@Component</code> darüber setzen.  Der Frühling findet es und fügt es der Liste hinzu. </p><br><p>  <code>Modifer</code> selbst weiß nichts über die einzelnen Schritte, wodurch eine „schwache Verbindung“ zwischen den Komponenten entsteht. </p><br><p>  Die einzige Schwierigkeit besteht darin, die Reihenfolge festzulegen.  Zu diesem <code>@Order</code> verfügt Spring über eine <code>@Order</code> Annotation, in die Sie einen int-Wert übergeben können.  Die Liste ist aufsteigend sortiert. <br>  Daher kann es vorkommen, dass Sie durch Hinzufügen eines neuen Schritts in der Mitte der Liste die Sortierwerte für vorhandene Schritte ändern müssen. </p><br><blockquote>  Auf Spring hätte verzichtet werden können, wenn alle bekannten Implementierungen manuell an den Modifier-Konstruktor übergeben worden wären.  Dies hilft, das Sortierproblem zu lösen, erschwert jedoch das Hinzufügen neuer Schritte. </blockquote><br><h3 id="shag-3">  Schritt 3 </h3><br><p>  Jetzt bestehen wir die Sauberkeitsprüfung in einem separaten Schritt.  Dazu schreiben wir unsere Schnittstelle so, dass sie immer einen Wert zurückgibt: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); }</code> </pre> <br><p>  Auf Sauberkeit prüfen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@Order</span></span>(Ordered.HIGHEST_PRECEDENCE) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CleanFilter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(.()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } }</code> </pre> <br><p>  <code>Modifier.modify</code> : </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .map(o -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modified = o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step : steps){ modified = step.modify(o); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(modified == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; }) .filter(Objects::nonNull) .collect(Collectors.toList()); }</code> </pre> <br><p>  In dieser Version verfügt <code>Modifier</code> über keine Dateninformationen.  Er gibt sie einfach an jeden bekannten Schritt weiter und sammelt die Ergebnisse. </p><br><p>  Wenn einer der Schritte null zurückgibt, wird die Verarbeitung für dieses Kleidungsstück unterbrochen. </p><br><p>  Ein ähnliches Prinzip wird im Frühjahr für HandlerInterceptors verwendet.  Vor und nach dem Controller-Aufruf werden alle entsprechenden Interceptors für diese URL aufgerufen.  Gleichzeitig wird in der preHandle-Methode true oder false zurückgegeben, um anzugeben, ob die Verarbeitung und der Aufruf nachfolgender Interceptors fortgesetzt werden können </p><br><h3 id="shag-n">  Schritt n </h3><br><p>  Der nächste Schritt ist das Hinzufügen der <code>matches</code> zur <code>Modification</code> , in der die Schritte zu einem separaten Attribut der Kleidung überprüft werden: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;} }</code> </pre> <br><p>  Aus diesem Grund können Sie die Logik beim <code>modify</code> Methoden leicht vereinfachen, indem Sie die Prüfungen für Klassen und Eigenschaften in eine separate Methode verschieben. </p><br><p>  Ein ähnlicher Ansatz wird im Spring-Filter (Anforderungsfilter) verwendet, der Hauptunterschied besteht jedoch darin, dass jeder Filter ein Wrapper für den nächsten Filter ist und FilterChain.doFilter explizit aufruft, um die Verarbeitung fortzusetzen. </p><br><h2 id="itogo">  Total </h2><br><p>  Das Endergebnis unterscheidet sich sehr von der ursprünglichen Version.  Wenn wir sie vergleichen, können wir die folgenden Schlussfolgerungen ziehen: </p><br><ul><li>  Die auf Pipes &amp; Filters basierende Implementierung vereinfacht die <code>Modifier</code> Klasse selbst. </li><li>  Besser verteilte Verantwortlichkeiten und „schwache“ Verbindungen zwischen Komponenten. </li><li>  Einfacher, einzelne Schritte zu testen. </li><li>  Einfacheres Hinzufügen und Entfernen von Schritten. </li><li>  Etwas schwieriger ist es, eine ganze Kette von Filtern zu testen.  Wir brauchen schon IntegrationTests. </li><li>  Weitere Klassen </li></ul><br><p>  Letztendlich eine bequemere und flexiblere Option als das Original. </p><br><p>  Außerdem können Sie die Datenverarbeitung einfach mit demselben parallelStream parallelisieren. </p><br><h3 id="chto-ne-reshaet-dannyy-primer">  Was dieses Beispiel nicht löst </h3><br><ol><li>  Die Beschreibung des Musters besagt, dass einzelne Filter wiederverwendet werden können, indem eine andere Filterkette (Kanal) erstellt wird. <br><ul><li>  Dies ist zum einen mit <code>@Qualifier</code> einfach zu <code>@Qualifier</code> . </li><li>  Andererseits <code>@Order</code> das Festlegen einer anderen Reihenfolge mit <code>@Order</code> fehl. </li></ul></li><li>  Für komplexere Beispiele müssen Sie mehrere Ketten verwenden, verschachtelte Ketten verwenden und dennoch die vorhandene Implementierung ändern. <br><ul><li>  Die Aufgabe "Suchen Sie für jede Socke nach einem Paar und fügen Sie es in eine Instanz von &lt;? Extends Clothing&gt; ein" passt daher nicht gut in die beschriebene Implementierung  Jetzt müssen Sie für jeden Zeh die gesamte Wäsche sortieren und die ursprüngliche Datenliste ändern. </li><li>  Um dies zu lösen, können Sie eine neue Schnittstelle schreiben, die eine Liste &lt;Kleidung&gt; akzeptiert und zurückgibt und diese an eine neue Kette überträgt.  Aber Sie müssen mit der Reihenfolge der Aufrufe der Ketten selbst vorsichtig sein, wenn die Socken nur vom Hotel genäht werden können. </li></ul></li></ol><br><h2 id="spasibo-za-vnimanie">  Vielen Dank für Ihre Aufmerksamkeit </h2></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479464/">https://habr.com/ru/post/de479464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479450/index.html">AppCode 2019.3: Arbeitet schneller, versteht Swift besser, kennt sich mit Mac Catalyst aus und zeigt Versammlungsnachrichten an</a></li>
<li><a href="../de479452/index.html">Wie sich das Domain Name System entwickelte: Das ARPANET-Zeitalter</a></li>
<li><a href="../de479458/index.html">Schönheit oder Zweckmäßigkeit im Serverraum</a></li>
<li><a href="../de479460/index.html">Ein Leitfaden für fliegende Autos</a></li>
<li><a href="../de479462/index.html">Serialisierung in C ++</a></li>
<li><a href="../de479466/index.html">Habraiting 2019: Statistik und Ranking der besten Artikel für 2019</a></li>
<li><a href="../de479468/index.html">Edge of Honesty und John Doe</a></li>
<li><a href="../de479474/index.html">Warum ist die Selbstorganisation von Teams in Scrum so wichtig und warum kann es keine Manager geben?</a></li>
<li><a href="../de479478/index.html">Java-Plug-In ohne Schmerzen</a></li>
<li><a href="../de479480/index.html">SARIF SDK und seine Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>