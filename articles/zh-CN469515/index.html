<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏼 👴🏾 🎐 为Istio准备应用程序 🧖🏾 👨🏽‍🤝‍👨🏼 😱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Istio是连接，保护和监视分布式应用程序的便捷工具。 Istio使用各种技术来大规模启动和管理软件，包括用于包装应用程序代码的容器和用于部署的依赖项，以及用于管理这些容器的Kubernetes。 因此，要使用Istio，您必须知道在没有 Istio的情况下具有基于这些技术的多种服务的应用程序如何工...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为Istio准备应用程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/469515/"><p><img src="https://habrastorage.org/webt/qy/yw/v1/qyywv1qmzphh1svbblasrxjc6ym.jpeg"></p><br><p>  Istio是连接，保护和监视分布式应用程序的便捷工具。  Istio使用各种技术来大规模启动和管理软件，包括用于包装应用程序代码的容器和用于部署的依赖项，以及用于管理这些容器的Kubernetes。 因此，要使用Istio，您必须知道在<em>没有</em> Istio的<em>情况下</em>具有基于这些技术的多种服务的应用程序如何工作。 如果您已经了解这些工具和概念，请随时跳过本指南，直接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转到在Google Kubernetes Engine（GKE）上</a>安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Istio</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GKE</a>扩展<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">程序上</a>安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Istio</a> 。 </p><br><p> 这是一个循序渐进的指南，在其中我们将介绍从源代码到GKE上的容器的整个过程，以便您通过示例了解这些技术的基本概念。 您还将看到Istio如何利用这些技术。 假定您对容器，Kubernetes，服务网格或Istio一无所知。 </p><a name="habracut"></a><br><h3 id="zadachi"> 任务 </h3><br><p> 在本指南中，您将完成以下任务： </p><br><ol><li> 探索带有多个服务的简单hello world应用程序。 </li><li> 从源代码运行应用程序。 </li><li>将应用程序包装在容器中。 </li><li> 创建一个Kubernetes集群 </li><li> 将容器部署到群集。 </li></ol><br><h3 id="prezhde-chem-nachat"> 开始之前 </h3><br><p> 按照说明启用Kubernetes Engine API： </p><br><ol><li> 转到Google Cloud Platform控制台中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的Kubernetes Engine页面</a> 。 </li><li> 创建或选择一个项目。 </li><li> 等待API和相关服务打开。 这可能需要几分钟。 </li><li> 确保为Google Cloud Platform项目配置了结算方式。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了解如何启用结算</a> 。 </li></ol><br><p> 在本指南中，您可以使用Cloud Shell，它可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>具有基于Debian的Linux或Linux或macOS计算机<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的Google Compute Engine中</a>准备<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">g1小型</a>虚拟机。 </p><br><h3 id="variant-a-ispolzovanie-cloud-shell"> 选项A：使用Cloud Shell </h3><br><p> 使用Cloud Shell的好处： </p><br><ul><li> 完全定制了Python 2和Python 3开发环境（包括<strong>virtualenv</strong> ）。 </li><li> 我们将使用的<strong>gcloud</strong> ， <strong>docker</strong> ， <strong>git</strong>和<strong>kubectl</strong>命令行<strong>工具</strong>已经安装。 </li><li> 您可以从以下几种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文本编辑器中</a>进行选择： <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a> Cloud Shell窗口顶部的编辑图标打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的代码编辑器</a> 。 </li><li> 从Cloud Shell中的命令行打开的Emacs，Vim或Nano。 </li></ol></li></ul><br><p> 要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cloud Shell</a> ： </p><br><ol><li> 转到GCP控制台。 </li><li> 单击GCP控制台窗口顶部的“ <strong>激活Cloud Shell”</strong>按钮。 </li></ol><br><p><img src="https://habrastorage.org/webt/yu/sh/9x/yush9xie9_peummad02lgu2n5x8.png"></p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GCP控制台</a>的底部<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>在新窗口中，使用命令行打开Cloud Shell会话。 </p><br><p><img src="https://habrastorage.org/webt/yi/no/-q/yino-qj5bwaluwxlo3xtf0yr7ty.png"></p><br><h3 id="variant-b-ispolzovanie-instrumentov-komandnoy-stroki-lokalno"> 选项B：在本地使用命令行工具 </h3><br><p> 如果要在装有Linux或macOS的计算机上工作，则需要配置和安装以下组件： </p><br><ol><li><p> 设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python 3和Python 2开发环境</a> 。 </p><br></li><li><p> 使用<strong>gcloud</strong>命令行<strong>工具</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装Cloud SDK</a> 。 </p><br></li><li><p> 安装<strong>kubectl</strong> ，这是用于<strong>Kubernetes</strong>的命令行工具。 </p><br><pre><code class="plaintext hljs">gcloud components install kubectl</code> </pre> <br></li><li><p> 安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker Community Edition（CE）</a> 。 您将使用<strong>docker</strong>命令行工具为示例应用程序创建容器映像。 </p><br></li><li><p> 安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Git版本控制</a>工具以通过GitHub获取示例应用程序。 </p><br></li></ol><br><h3 id="zagruzka-primera-koda"> 下载示例代码 </h3><br><ol><li><p> 下载<strong>helloserver</strong>源代码： </p><br><pre> <code class="plaintext hljs">git clone https://github.com/GoogleCloudPlatform/istio-samples</code> </pre> <br></li><li><p> 转到示例代码目录： </p><br><pre> <code class="plaintext hljs">cd istio-samples/sample-apps/helloserver</code> </pre> <br></li></ol><br><h3 id="izuchenie-prilozheniya-s-neskolkimi-servisami"> 探索多服务应用程序 </h3><br><p> 该示例应用程序是用Python编写的，由与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">REST</a>交互的两个组件组成： </p><br><ul><li>  <strong>服务器</strong> ：具有一个<strong>GET</strong>端点<strong>/</strong>的简单服务器，该控制台在控制台上显示“ hello world”。 </li><li>  <strong>loadgen</strong> ：一个脚本，它将流量发送到<strong>服务器</strong> ，每秒可配置的请求数。 </li></ul><br><p><img src="https://habrastorage.org/webt/b1/ky/lj/b1kyljxdkjdci12qtle2w3dmtjw.png"></p><br><h3 id="zapusk-prilozheniya-iz-ishodnogo-koda"> 从源代码运行应用程序 </h3><br><p> 要了解示例应用程序，请在Cloud Shell或计算机上运行它。 <br>  1）在<strong>istio-samples / sample-apps / helloserver</strong>目录中，运行<strong>server</strong> ： </p><br><pre> <code class="plaintext hljs">python3 server/server.py</code> </pre> <br><p>  <strong>服务器</strong>启动时，将显示以下内容： </p><br><pre> <code class="plaintext hljs">INFO:root:Starting server...</code> </pre> <br><p>  2）打开另一个终端窗口，以将请求发送到<strong>服务器</strong> 。 如果您使用的是Cloud Shell，请单击添加图标以打开另一个会话。 <br>  3）向<strong>服务器</strong>发送请求： </p><br><pre> <code class="plaintext hljs">curl http://localhost:8080</code> </pre> <br><p> 服务器答案： </p><br><pre> <code class="plaintext hljs">Hello World!</code> </pre> <br><p>  4）从下载示例代码的目录中，转到包含<strong>loadgen</strong>的目录： </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/loadgen</code> </pre> <br><p>  5）创建以下环境变量： </p><br><pre> <code class="plaintext hljs">export SERVER_ADDR=http://localhost:8080 export REQUESTS_PER_SECOND=5</code> </pre> <br><p>  6）运行<strong>virtualenv</strong> ： </p><br><pre> <code class="plaintext hljs">virtualenv --python python3 env</code> </pre> <br><p>  7）激活虚拟环境： </p><br><pre> <code class="plaintext hljs">source env/bin/activate</code> </pre> <br><p>  8）设置<strong>loadgen的</strong>要求： </p><br><pre> <code class="plaintext hljs">pip3 install -r requirements.txt</code> </pre> <br><p>  9）运行<strong>loadgen</strong> ： </p><br><pre> <code class="plaintext hljs">python3 loadgen.py</code> </pre> <br><p> 启动时， <strong>loadgen将</strong>显示以下消息： </p><br><pre> <code class="plaintext hljs">Starting loadgen: 2019-05-20 10:44:12.448415 5 request(s) complete to http://localhost:8080</code> </pre> <br><p> 在另一个终端窗口中， <strong>服务器</strong>向控制台显示以下消息： </p><br><pre> <code class="plaintext hljs">127.0.0.1 - - [21/Jun/2019 14:22:01] "GET / HTTP/1.1" 200 - INFO:root:GET request, Path: / Headers: Host: localhost:8080 User-Agent: python-requests/2.22.0 Accept-Encoding: gzip, deflate Accept: */*</code> </pre> <br><p> 从网络角度来看，整个应用程序都在同一主机（本地计算机或Cloud Shell虚拟机）上运行。 因此，您可以使用<strong>localhost</strong>将请求发送到<strong>server</strong> 。 <br>  10）要停止<strong>loadgen</strong>和<strong>server</strong> ，请在每个终端窗口中输入<strong>Ctrl-c</strong> 。 <br>  11）在<strong>loadgen</strong>终端<strong>窗口中，</strong>禁用虚拟环境： </p><br><pre> <code class="plaintext hljs">deactivate</code> </pre> <br><h3 id="upakovka-prilozheniya-v-konteynery"> 将应用程序包装在容器中 </h3><br><p> 要在GKE上运行该应用程序，您需要将示例应用程序<strong>服务器</strong> - <strong>服务器</strong>和<strong>loadgen-打包</strong>到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">容器中</a> 。 容器是打包应用程序以使其与环境隔离的一种方式。 </p><br><p> 要将应用程序打包在容器中，您需要一个<strong>Dockerfile</strong> 。  <strong>Dockerfile</strong>是一个文本文件，定义用于将应用程序源代码及其依赖项构建到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker映像中的命令。</a> 构建后，将映像上传到容器注册表，例如Docker Hub或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Container Registry</a> 。 </p><br><p> 该示例已经具有用于<strong>服务器</strong>和<strong>loadgen</strong>的<strong>Dockerfile</strong> ，以及用于组装映像的所有必需命令。 以下是<strong>服务器</strong>的<strong>Dockerfile</strong> ： </p><br><pre> <code class="plaintext hljs">FROM python:3-slim as base FROM base as builder RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ g++ \ &amp;&amp; rm -rf /var/lib/apt/lists/* # Enable unbuffered logging FROM base as final ENV PYTHONUNBUFFERED=1 RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ wget WORKDIR /helloserver # Grab packages from builder COPY --from=builder /usr/local/lib/python3.7/ /usr/local/lib/python3.7/ # Add the application COPY . . EXPOSE 8080 ENTRYPOINT [ "python", "server.py" ]</code> </pre> <br><ul><li>  <strong>FROM python：3-slim as base</strong>命令可以告诉Docker使用最新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python 3映像</a>作为基础。 </li><li>  <strong>COPY</strong>团队<strong>。</strong>  <strong>。</strong> 将源文件复制到容器文件系统中的当前工作目录（在本示例中，仅是<strong>server.py</strong> ）。 </li><li>  <strong>ENTRYPOINT</strong>定义用于启动容器的命令。 在我们的例子中，此命令与用于从源代码运行<strong>server.py的</strong>命令几乎相同。 </li><li>  <strong>EXPOSE</strong>命令指示<strong>服务器</strong>正在侦听端口<strong>8080</strong> 。 该命令不<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提供端口</a> 。 这是在容器启动时打开端口<strong>8080</strong>所需的某种文档。 </li></ul><br><h3 id="podgotovka-k-konteynerizacii-prilozheniya"> 准备应用程序容器化 </h3><br><p>  1）设置以下环境变量。 用您的GCP项目标识符替换<strong>PROJECT_ID</strong> 。 </p><br><pre> <code class="plaintext hljs">export PROJECT_ID="PROJECT_ID"</code> </pre> <br><pre> <code class="plaintext hljs">export GCR_REPO="preparing-istio"</code> </pre> <br><p> 使用<strong>PROJECT_ID</strong>和<strong>GCR_REPO值，</strong>您可以在收集Docker映像并将其发送到私有Container Registry时对其进行标记。 </p><br><p>  2）为<strong>gcloud</strong>命令行<strong>工具</strong>设置默认的GCP项目。 </p><br><pre> <code class="plaintext hljs">gcloud config set project $PROJECT_ID</code> </pre> <br><p>  3）设置<strong>gcloud</strong>命令行<strong>工具</strong>的默认区域。 </p><br><pre> <code class="plaintext hljs">gcloud config set compute/zone us-central1-b</code> </pre> <br><p>  4）确保GCP项目中包含Container Registry服务。 </p><br><pre> <code class="plaintext hljs">gcloud services enable containerregistry.googleapis.com</code> </pre> <br><h3 id="konteynerizaciya-server"> 集装箱化服务器 </h3><br><ol><li><p> 切换到<strong>服务器</strong>示例所在的目录： </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br></li><li><p> 使用先前定义的<strong>Dockerfile</strong>和环境变量构建映像： </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1 .</code> </pre> <br></li></ol><br><p>  <strong>-t选项</strong>代表Docker标签。 这是您在部署容器时使用的映像的名称。 </p><br><ol><li> 将图像发送到容器注册表： <br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1</code> </pre> </li></ol><br><h3 id="konteynerizaciya-loadgen"> 集装箱装载机 </h3><br><p>  1）转到<strong>loadgen</strong>示例所在的目录： </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  2）组装图片： </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1 .</code> </pre> <br><p>  3）将图片发送到Container Registry： </p><br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1</code> </pre> <br><h3 id="prosmotr-spiska-obrazov"> 查看图像列表 </h3><br><p> 浏览存储库中的图像列表，并确保已发送图像： </p><br><pre> <code class="plaintext hljs">gcloud container images list --repository gcr.io/$PROJECT_ID/preparing-istio</code> </pre> <br><p> 该命令显示刚发送的图像的名称： </p><br><pre> <code class="plaintext hljs">NAME gcr.io/PROJECT_ID/preparing-istio/helloserver gcr.io/PROJECT_ID/preparing-istio/loadgen</code> </pre> <br><h3 id="sozdanie-klastera-gke"> 创建一个GKE集群 </h3><br><p> 可以使用<strong>docker run命令</strong>在Cloud Shell虚拟机或计算机上运行这些容器。 但是在生产环境中，您需要一种对容器进行集中编排的方法。 例如，我们需要一个确保容器始终运行的系统，并且需要一种方法来在流量增加时放大并启动其他容器实例。 </p><br><p> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GKE</a>运行容器应用程序。  GKE是对虚拟机进行集群的容器编排平台。 每个虚拟机称为主机。  GKE集群基于开源集群管理系统Kubernetes。  Kubernetes提供了与集群交互的机制。 </p><br><p> 创建一个GKE集群： </p><br><p>  1）创建一个集群： </p><br><pre> <code class="plaintext hljs">gcloud container clusters create istioready \ --cluster-version latest \ --machine-type=n1-standard-2 \ --num-nodes 4</code> </pre> <br><p>  <strong>gcloud</strong>命令在GCP项目和您指定的默认区域中创建一个<strong>istioready</strong>群集。 要启动Istio，建议您至少有4个节点和一台<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">n1-standard-2</a>虚拟机。 </p><br><p> 该团队将创建一个集群几分钟。 集群就绪后，该命令将发出类似的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">消息</a> 。 </p><br><p>  2）在<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubectl</a></strong>命令行<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工具中</a></strong>指定凭据以使用它来管理集群： </p><br><pre> <code class="plaintext hljs">gcloud container clusters get-credentials istioready</code> </pre> <br><p>  3）现在您可以通过<strong>kubectl</strong>与Kubernetes进行通信了。 例如，使用以下命令，您可以找到节点的状态： </p><br><pre> <code class="plaintext hljs">kubectl get nodes</code> </pre> <br><p> 该命令显示节点列表： </p><br><pre> <code class="plaintext hljs">NAME STATUS ROLES AGE VERSION gke-istoready-default-pool-dbeb23dc-1vg0 Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-36z5 Ready &lt;none&gt; 100s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-fj7s Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-wbjw Ready &lt;none&gt; 99s v1.13.6-gke.13</code> </pre> <br><h3 id="klyuchevye-ponyatiya-kubernetes">  Kubernetes的关键概念 </h3><br><p> 该图显示了GKE上的应用程序： </p><br><p><img src="https://habrastorage.org/webt/-s/x2/uj/-sx2ujtlifvzdtixzdqpnr9jzva.png"></p><br><p> 在将容器部署到GKE之前，请查看Kubernetes的关键概念。 如果您想了解更多信息，请在最后找到链接。 </p><br><ul><li>  <strong>节点和集群</strong> 。 在GKE中，节点是虚拟机。 在其他Kubernetes平台上，主机可以是计算机或虚拟机。 群集是节点的集合，可以将它们视为一个整体，并在其中部署容器化的应用程序。 </li><li>  <strong>豆荚</strong> 。 在Kubernetes中，容器在pod中运行。  Kubernetes中的Pod是不可分割的单元。 吊舱可容纳一个或多个容器。 您将服务器<strong>容器</strong>和<strong>loadgen容器</strong>部署在单独的<strong>容器</strong>中。 当Pod中有多个容器时（例如，应用程序服务器和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代理服务器</a> ），这些容器将作为单个对象进行管理并共享Pod的资源。 </li><li>  <strong>部署</strong> 。 在Kubernetes中，部署是一个对象，该对象是相同pod的集合。 部署运行分布在集群节点上的多个Pod副本。 部署会自动替换失败或不响应的Pod。 </li><li>  <strong>Kubernetes服务</strong> 。 在GKE中运行应用程序代码时， <strong>loadgen</strong>和<strong>服务器</strong>之间的连接会更改。 在Cloud Shell虚拟机或计算机上启动服务时，您向<strong>localhost：8080</strong>的<strong>服务器</strong>发送了请求。 部署到GKE后，pod将在可用节点上运行。 默认情况下，您无法控制正在运行的主机Pod，因此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pod</a>没有永久IP地址。 <br> 要获取<strong>服务器</strong>的IP地址，您需要在Pod顶部定义网络抽象。 这就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes服务</a> 。  Kubernetes服务为一组Pod提供了一个永久端点。 有几种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类型的服务</a> 。  <strong>服务器</strong>使用<strong>LoadBalancer</strong> ，该<strong>负载</strong>提供一个外部IP地址以从群集外部与<strong>服务器</strong>联系。 <br>  Kubernetes还具有一个集成的DNS系统，该系统为服务分配DNS名称（例如<strong>helloserver.default.cluster.local</strong> ）。 因此，群集中的Pod与群集中其他Pod在固定地址进行通信。 无法在群集外部（例如在Cloud Shell或计算机上）使用DNS名称。 </li></ul><br><h3 id="manifesty-kubernetes">  Kubernetes清单 </h3><br><p> 从源代码启动应用程序时，您使用了命令式<strong>python3</strong>命令 </p><br><p>  <strong>server.py</strong> </p><br><p> 命令式隐含了动词：“做”。 </p><br><p>  Kubernetes使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">声明性模型</a> 。 这意味着我们不会告诉Kubernetes到底需要做什么，而是要描述所需的状态。 例如，Kubernetes会根据需要启动和停止Pod，因此系统的实际状态是所需的。 </p><br><p> 您可以在清单或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">YAML</a>文件中指定所需的状态。  YAML文件包含一个或多个Kubernetes对象的规范。 </p><br><p> 该示例包含用于<strong>server</strong>和<strong>loadgen</strong>的YAML文件。 每个YAML文件都指示部署对象和Kubernetes服务的所需状态。 </p><br><p>  <strong>server.yaml</strong> </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: helloserver spec: selector: matchLabels: app: helloserver replicas: 1 template: metadata: labels: app: helloserver spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/helloserver:v0.0.1 imagePullPolicy: Always</code> </pre> <br><ul><li>  <strong>kind</strong>指示对象的类型。 </li><li>  <strong>metadata.name</strong>指示部署的名称。 </li><li> 第一字段<strong>规范</strong>包含对所需状态的描述。 </li><li>  <strong>spec.replicas</strong>指示所需的豆荚数量。 </li><li>  <strong>spec.template</strong>部分定义了<strong>pod</strong>模板。 在pod规范中，有一个<strong>image</strong>字段，其中指示要从Container Registry中提取的图像的名称。 </li></ul><br><p> 服务定义如下： </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: hellosvc spec: type: LoadBalancer selector: app: helloserver ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><ul><li>  <strong>LoadBalancer</strong> ：客户端将请求发送到负载平衡器的IP地址，该地址具有固定的IP地址，并且可以从群集外部访问。 </li><li>  <strong>targetPort</strong> ：您还记得， <strong>Dockerfile中的EXPOSE 8080</strong>命令没有提供端口。 您提供端口<strong>8080，</strong>以便可以从群集外部访问<strong>服务器</strong>容器。 在我们的例子中， <strong>hellosvc.default.cluster.local：80</strong> （短名称： <strong>hellosvc</strong> ）对应于<strong>helloserver</strong>容器IP地址的端口<strong>8080</strong> 。 </li><li>  <strong>port</strong> ：这是集群中其他服务将发送请求的端口号。 </li></ul><br><p>  <strong>loadgen.yaml</strong> </p><br><p>  <strong>loadgen.yaml中</strong>的部署对象类似于<strong>server.yaml</strong> 。 区别在于部署对象包含一个<strong>env</strong>部分。 它定义了<strong>loadgen</strong>所需的环境变量以及您从源代码启动应用程序时设置的环境变量。 </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: loadgenerator spec: selector: matchLabels: app: loadgenerator replicas: 1 template: metadata: labels: app: loadgenerator spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/loadgen:v0.0.1 imagePullPolicy: Always env: - name: SERVER_ADDR value: "http://hellosvc:80/" - name: REQUESTS_PER_SECOND value: "10" resources: requests: cpu: 300m memory: 256Mi limits: cpu: 500m memory: 512Mi</code> </pre> <br><p> 由于<strong>loadgen</strong>不接受传入请求， <strong>因此</strong>为<strong>type</strong>字段指定了<strong>ClusterIP</strong> 。 此类型提供了群集中的服务可以使用的固定IP地址，但是未向外部客户端提供此IP地址。 </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: loadgensvc spec: type: ClusterIP selector: app: loadgenerator ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><h3 id="razvertyvanie-konteynerov-v-gke"> 在GKE中部署容器 </h3><br><p>  1）转到<strong>服务器</strong>示例所在的目录： </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br><p>  2）在文本编辑器中打开<strong>server.yaml</strong> 。 <br>  3）将<strong>image</strong>字段中的名称替换为Docker映像的名称。 </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/helloserver:v0.0.1</code> </pre> <br><p> 将<strong>PROJECT_ID</strong>替换为GCP项目的标识符。 <br>  4）保存并关闭<strong>server.yaml</strong> 。 <br>  5）在Kubernetes中展开YAML文件： </p><br><pre> <code class="plaintext hljs">kubectl apply -f server.yaml</code> </pre> <br><p> 成功完成后，该命令将发出以下代码： </p><br><pre> <code class="plaintext hljs">deployment.apps/helloserver created service/hellosvc created</code> </pre> <br><p>  6）转到<strong>loadgen</strong>所在的目录： </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  7）在文本编辑器中打开<strong>loadgen.yaml</strong> 。 <br>  8）将<strong>image</strong>字段中的名称替换为Docker映像的名称。 </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/loadgenv0.0.1</code> </pre> <br><p> 将<strong>PROJECT_ID</strong>替换为GCP项目的标识符。 <br>  9）保存并关闭<strong>loadgen.yaml</strong> ，关闭文本编辑器。 <br>  10）在Kubernetes中展开YAML文件： </p><br><pre> <code class="plaintext hljs">kubectl apply -f loadgen.yaml</code> </pre> <br><p> 成功完成后，该命令将发出以下代码： </p><br><pre> <code class="plaintext hljs">deployment.apps/loadgenerator created service/loadgensvc created</code> </pre> <br><p>  11）检查炉膛状态： </p><br><pre> <code class="plaintext hljs">kubectl get pods</code> </pre> <br><p> 该命令显示状态： </p><br><pre> <code class="plaintext hljs">NAME READY STATUS RESTARTS AGE helloserver-69b9576d96-mwtcj 1/1 Running 0 58s loadgenerator-774dbc46fb-gpbrz 1/1 Running 0 57s</code> </pre> <br><p>  12）从<strong>loadgen</strong> pod中提取应用程序日志。  <strong>用上</strong>一个答案中的标识符替换<strong>POD_ID</strong> 。 </p><br><pre> <code class="plaintext hljs">kubectl logs loadgenerator-POD_ID</code> </pre> <br><p>  13）获取外部<strong>hellosvc IP</strong> ： </p><br><pre> <code class="plaintext hljs">kubectl get service</code> </pre> <br><p> 命令响应如下所示： </p><br><pre> <code class="plaintext hljs">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE hellosvc LoadBalancer 10.81.15.158 192.0.2.1 80:31127/TCP 33m kubernetes ClusterIP 10.81.0.1 &lt;none&gt; 443/TCP 93m loadgensvc ClusterIP 10.81.15.155 &lt;none&gt; 80/TCP 4m52s</code> </pre> <br><p>  14）向<strong>hellosvc</strong>发送请求：将<strong>EXTERNAL_IP</strong>替换为<strong>hellosvc</strong>的外部IP地址。 </p><br><pre> <code class="plaintext hljs">curl http://EXTERNAL_IP</code> </pre> <br><h3 id="beremsya-za-istio"> 抢劫伊斯蒂奥 </h3><br><p> 您已经有一个应用程序部署到GKE。  <strong>loadgen</strong>可以使用Kubernetes DNS（ <strong>hellosvc：80</strong> ）将请求发送到<strong>服务器</strong> ，并且您可以使用外部IP地址将请求发送到<strong>服务器</strong> 。 尽管Kubernetes具有许多功能，但是缺少有关服务的一些信息： </p><br><ul><li>  <strong>服务如何相互作用？</strong> 服务之间是什么关系？ 服务之间的流量如何？ 您知道<strong>loadgen</strong>将请求发送到<strong>服务器</strong> ，但可以想象您对应用程序一无所知。 为了回答这些问题，我们查看了GKE中运行的炉床清单。 </li><li>  <strong>指标</strong> 。  <strong>服务器</strong>对传入请求的响应时间为多长时间？ 每秒有多少个请求发送到服务器？ 它会给出错误消息吗？ </li><li>  <strong>安全信息</strong> 。  <strong>loadgen</strong>和<strong>服务器</strong>之间<strong>的</strong>通信<strong>是否</strong>仅通过<strong>HTTP</strong>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mTLS进行</a> ？ </li></ul><br><p>  Istio回答了所有这些问题。 为此，Istio在每个吊舱中放置一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Envoy</a>边车代理。  Envoy代理拦截到应用程序容器的所有传入和传出流量。 这意味着<strong>服务器</strong>和<strong>loadgen</strong>接收Envoy sidecar代理，并且从<strong>loadgen</strong>到<strong>服务器的</strong>所有流量都通过Envoy代理。 </p><br><p>  Envoy代理之间的连接形成服务网格。 服务网格体系结构提供了对Kubernetes的控制层。 </p><br><p><img src="https://habrastorage.org/webt/7n/sk/z-/7nskz-5os2onyoaaf5kz5x38ve4.png"></p><br><p> 一旦Envoy代理在其容器中执行，就可以在几乎不更改应用程序代码的情况下将Istio安装在GKE群集的顶部。 但是您做了一些工作来准备使用Istio进行管理的应用程序： </p><br><ul><li> 所有容器的服务。  <strong>服务器</strong>和<strong>loadgen部署</strong>由Kubernetes服务链接。 甚至不接收传入请求的<strong>loadgen</strong>都有服务。 </li><li> 服务中的端口必须具有名称。 尽管可以在GKE中保留服务端口的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">名称</a> ，但Istio仍需要根据其协议指定<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">端口名称</a> 。 在YAML文件中， <strong>服务器</strong>的端口称为<strong>http，</strong>因为服务器使用<strong>HTTP协议</strong> 。 如果<strong>服务</strong>使用<strong>gRPC</strong> ，则将端口命名为<strong>grpc</strong> 。 </li><li> 部署已标记。 因此，您可以使用Istio的流量管理功能，例如，在同一服务的各个版本之间共享流量。 </li></ul><br><h3 id="ustanovka-istio"> 安装Istio </h3><br><p> 有两种安装Istio的方法。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GKE扩展上启用Istio</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在群集上</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装Istio的开源版本</a> 。 使用GKE上的Istio，您可以在GKE集群生命周期中轻松管理Istio的安装和升级。 如果您需要最新版本的Istio或对Istio控制面板的配置进行更多控制，请安装开源版本，而不是GKE扩展上的Istio。 要决定采用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">哪种</a>方法，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GKE上</a>的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Istio吗？</a>  。 </p><br><p> 选择一个选项，研究适当的手册，然后按照说明在群集上安装Istio。 如果要在新部署的应用程序中使用Istio，请为<strong>默认</strong>名称空间<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启用sidecar嵌入</a> 。 </p><br><h3 id="ochistka"> 清洁用品 </h3><br><p> 为确保本指南中使用的资源不会从您的Google Cloud Platform帐户中扣除，请在安装Istio并使用示例应用程序时删除容器群集。 这将删除所有群集资源，例如计算实例，磁盘和网络资源。 </p><br><h3 id="chto-dalshe"> 接下来是什么？ </h3><br><ul><li><p> 了解以下技术： </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">码头工人</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">货柜</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">容器注册表</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">格克</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务网</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伊斯斯蒂奥</a> </li></ol><br></li><li><p> 了解以下工具： </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云SDK</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>Gcloud参考</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>Kubectl</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>码头工人</strong></a> </li></ol><br></li><li><p> 了解Kubernetes的概念： </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集群</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">豆荚</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务项目</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部署方式</a> </li></ol><br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469515/">https://habr.com/ru/post/zh-CN469515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469499/index.html">我们在Parallels征服了Apple的方式</a></li>
<li><a href="../zh-CN469503/index.html">网络安全：我们在2019年保护订户数据免受泄露</a></li>
<li><a href="../zh-CN469505/index.html">将业务推向国外市场的3种实用方法：实际公司的方法和技巧</a></li>
<li><a href="../zh-CN469507/index.html">第三个Steam Windows Client漏洞，但不是0day</a></li>
<li><a href="../zh-CN469509/index.html">角度示意图，或我如何编写角度cli模板</a></li>
<li><a href="../zh-CN469521/index.html">我买了摩托车骑，不摔倒</a></li>
<li><a href="../zh-CN469523/index.html">代码性能对JavaScript中变量声明上下文的依赖</a></li>
<li><a href="../zh-CN469525/index.html">矿用挖掘机的自动控制系统</a></li>
<li><a href="../zh-CN469527/index.html">对讲机是间谍的耳朵吗？</a></li>
<li><a href="../zh-CN469529/index.html">文字渲染讨厌你</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>