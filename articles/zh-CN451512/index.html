<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏼 🎖️ 🛋️ 如何解析移动MMORPG网络协议 🏜️ 🐅 🧔🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在玩一个移动MMORPG的多年中，我在反向工程方面积累了一些经验，我想在一系列文章中分享。 示例主题： 



1. 解析服务器和客户端之间的消息格式。 
2. 编写侦听应用程序以方便的方式查看游戏流量。 
3. 使用非HTTP代理服务器进行流量拦截及其修改。 
4. 到您自己的（“盗版”）服务器的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何解析移动MMORPG网络协议</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451512/"> 在玩一个移动MMORPG的多年中，我在反向工程方面积累了一些经验，我想在一系列文章中分享。 示例主题： <br><br><ol><li> 解析服务器和客户端之间的消息格式。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编写侦听应用程序以方便的方式查看游戏流量。</a> </li><li> 使用非HTTP代理服务器进行流量拦截及其修改。 </li><li> 到您自己的（“盗版”）服务器的第一步。 </li></ol><br> 在本文中，我将讨论<b>在服务器和客户端之间解析消息格式</b> 。 有兴趣的，我要猫。 <br><a name="habracut"></a><br><h3> 所需工具 </h3><br> 为了能够重复下面描述的步骤，您将需要： <br><br><ul><li>  PC（我在Windows 7/10上使用过，但如果有以下各项，MacOS也可以使用）； </li><li>  Wireshark用于数据包分析； </li><li>  010Editor用于按模板解析数据包（可选，但是允许您快速轻松地描述消息格式）； </li><li> 移动设备本身与游戏。 </li></ul><br> 另外，非常希望从手边的游戏中获得可读数据，例如带有其标识符的物体，生物等的列表。 这极大地简化了对包中关键点的搜索，有时它使您可以在恒定的数据流中过滤所需的消息。 <br><br><h3><anchor> 解析中 </anchor> 服务器和客户端之间的消息格式 </h3><br> 首先，我们需要查看移动设备的流量。 做到这一点非常简单（尽管我很长一段时间以来都做出了这个明显的决定）：在我们的PC上，我们创建了一个Wi-Fi接入点，从移动设备连接到它，在Wireshark中选择所需的接口-这样我们就可以看到所有的移动流量。 <br><br> 进入游戏并等待一段时间后，与游戏服务器本身无关的请求将停止，您可以观察以下图片： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/ye/61/inye619dyp2vh8iq8nvncdb25u0.png"></div><br> 在此阶段，我们已经可以使用Wireshark过滤器来仅查看游戏和服务器之间的数据包，以及仅包含有效负载的数据包： <br><br><pre><code class="plaintext hljs">tcp &amp;&amp; tcp.payload &amp;&amp; tcp.port == 44325</code> </pre> <br> 如果您站在一个安静的地方，远离其他播放器和NPC，却什么也不做，则可以看到服务器和客户端不断重复发送消息（分别为76和84字节）。 就我而言，在字符选择屏幕上发送了最少数量的不同软件包。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u-/n9/su/u-n9sutlnqod9lbgttfuon6g1ue.png"></div><br> 客户端发出请求的频率与ping非常相似。 让我们以几则消息进行验证（3组，上面是客户端的请求，下面是服务器的响应）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v3/z9/3e/v3z93eejzkii_hh6di5dwvbowfi.png"></div><br> 引起您注意的第一件事是包装的标识。 转换为十进制系统时，响应中的另外8个字节与以秒为单位的时间戳非常相似： <code>5CD008F8 <sub>16</sub> = 1557137656 <sub>10</sub></code> （来自第一对）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们检查时钟</a> -是的。 前4个字节与请求中的后4个字节匹配。 翻译时，我们得到： <code>A4BB <sub>16</sub> = 42171 <sub>10</sub></code> ，这也与时间非常相似，但以毫秒为单位。 它与游戏发布以来的时间大致吻合，很可能是这样。 <br><br> 仍然需要考虑请求和响应的前6个字节。 很容易注意到消息的前四个字节的值（我们称此参数<code>L</code> ）与消息的大小有关：服务器的响应超过8个字节， <code>L</code>的值也增​​加了8个，但是，在两种情况下，数据包的大小都比<code>L</code>的值大了6个字节。 您还可以注意到， <code>L</code>后面的两个字节在来自客户端和服务器的请求中都保留了它们的值，并且鉴于它们的值相差一个，我们可以确信地说这是消息代码<code>C</code> （相关的消息代码很可能会确定按顺序）。 总体结构很清晰，足以为010Editor编写一个最小的模板： <br><br><ul><li> 前4个字节<code>L</code>消息有效负载大小； </li><li> 接下来的2个字节-C-消息代码； </li><li> 有效载荷本身。 </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> {</span></span> uint payload_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0xFFFF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Payload Length"</span></span>&gt;; ushort event_code &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0xFF9988</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Event Code"</span></span>&gt;; byte payload[payload_length] &lt;name=<span class="hljs-string"><span class="hljs-string">"Event Payload"</span></span>&gt;; };</code> </pre><br> 因此，客户端ping消息的格式为：发送本地ping时间； 服务器响应格式：发送时间和发送响应的时间相同，以秒为单位。 似乎并不困难，对吧？ <br><br> 让我们尝试使示例更复杂。 站在一个安静的地方并隐藏ping数据包，您可以找到传送的消息并创建物品（工艺）。 让我们从第一个开始。 拥有游戏数据，我知道该寻找传送点的价值。 对于测试，我使用了值为<code>0x2B</code> ， <code>0x67</code>和<code>0x1AF</code> 。 与消息中的值进行比较： <code>0x2B</code> ， <code>0x67</code>和<code>0x3AF</code> ： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y7/7r/qs/y77rqsd0mxecueorqwdip3ow3r8.png"></div><br> 一团糟。 可见两个问题： <br><br><ol><li> 值不是4个字节，但是大小不同； </li><li> 并非所有值都与文件中的数据匹配，在这种情况下，差值为128。 </li></ol><br> 此外，与ping格式进行比较时，您会注意到一些区别： <br><br><ul><li> 预期值之前<code>0x08</code>理解的<code>0x08</code> ； </li><li> 一个4字节的值，比<code>L</code>小4（我们称它为<code>D</code>此字段并非出现在所有消息中，这有点奇怪，但在此位置，保留了<code>L - 4 = D</code>的依赖关系。一方面，对于具有一个简单的结构（例如ping）不是必需的，但另一方面-它看起来没用）。 </li></ul><br> 我想，有些人可能已经猜到了预期值不匹配的原因，但我会继续。 让我们看看工艺中正在发生什么： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8f/zk/vs/8fzkvsleifr5b1yodx6a77ggx_g.png"></div><br>  14183和14285的预期值也并不对应于实际的28391和28621，但是此处的差值已经比128大得多。经过多次测试（包括其他类型的消息），结果是预期数越大，数据包中的值差越大。 奇怪的是，它们自己最多保留128个值。 知道了，怎么了？ 显而易见的情况是对于那些已经遇到过这种情况的人，在不知不觉中，我不得不将这种“代码”分解了两天（最后，对二进制形式的值进行分析有助于“黑客”活动）。 上述行为称为<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可变长度数量</a></i> -表示使用不确定数量的字节的数字，其中字节的第八位（连续位）确定下一个字节的存在。 根据描述，很明显，仅以Little-Endian顺序读取VLQ是可能的。 巧合的是，数据包中的所有值都按该顺序排列。 <br><br> 现在我们知道如何获取初始值，我们可以为该类型编写一个模板： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VLQ</span></span></span><span class="hljs-class"> {</span></span> local <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> size = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { byte obf_byte; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((obf_byte &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80</span></span>) { size++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } FSeek(FTell() - size); byte bytes[size]; local uint64 _ = FromVLQ(bytes, size); };</code> </pre><br> 并将字节数组转换为整数值的函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint64 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromVLQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte bytes[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ local uint64 source = <span class="hljs-number"><span class="hljs-number">0</span></span>; local <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; local byte x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { x = bytes[i]; source |= (x &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>) * Pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, i * <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   &lt;&lt;   , ..     ,  uint32,        uint64 if ((x &amp; 0x80) != 0x80) { break; } } return source; };</span></span></code> </pre><br> 但是回到主题的创造。 再次出现<code>D</code>并再次在更改值前面出现<code>0x08</code> 。  <code>0x10 0x01</code>消息的最后两个字节可疑地类似于制作项目的数量，其中<code>0x10</code>的作用类似于<code>0x08</code>但仍然难以理解。 但是现在您可以为该事件编写模板： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CraftEvent</span></span></span><span class="hljs-class"> {</span></span> uint data_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Data Length"</span></span>&gt;; byte marker1; VLQ craft_id &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Craft ID"</span></span>&gt;; byte marker2; VLQ quantity &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Craft Quantity"</span></span>&gt;; };</code> </pre><br> 看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ex/sl/y1/exsly1e_f3_3dtj4mhyzryehzou.png"></div><br> 而且，这些只是简单的例子。 解析角色移动的事件将更加困难。 我们希望看到什么信息？ 角色的座标至少要包括他所处的位置，速度和状态（站立，奔跑，跳跃等）。 由于消息中没有可见的行，因此状态很可能通过<code>enum</code>描述。 通过枚举选项，同时将它们与游戏文件中的数据进行比较，以及通过大量测试，您可以使用此繁琐的模板找到三个XYZ向​​量： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveEvent</span></span></span><span class="hljs-class"> {</span></span> uint data_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Data Length"</span></span>&gt;; byte marker; VLQ move_time &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; FSkip(<span class="hljs-number"><span class="hljs-number">2</span></span>); byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; FSkip(<span class="hljs-number"><span class="hljs-number">2</span></span>); byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction_x &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction_y &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction_z &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; FSkip(<span class="hljs-number"><span class="hljs-number">2</span></span>); byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed_x &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed_y &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed_z &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; byte marker; VLQ character_state &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; };</code> </pre><br> 视觉效果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aw/wn/rz/awwnrzzruq2wtcnmwbpkho3q1x8.png"></div><br> 绿色三号是位置的坐标，黄色三号最有可能显示角色的位置和速度矢量，最后一个是角色的状态。 您会注意到坐标值（ <code>X</code>值之前的<code>0x0D</code> ， <code>Y</code>之前的<code>0x015</code>和<code>Z</code>之前的<code>0x1D</code> ）与状态（ <code>0x30</code> ）之前的常量字节（标记），这在含义上与<code>0x08</code>和<code>0x10</code>相似。 分析了来自其他事件的许多标记后，结果发现它确定了紧随其后的值的类型（前三个位）和语义含义，即 在上面的示例中，如果在保持向量标记（坐标前面的<code>0x120F</code>等）的情况下交换向量，则游戏（理论上）通常应解析该消息。 根据此信息，您可以添加几个新类型： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Packed</span></span></span><span class="hljs-class"> {</span></span> VLQ marker &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0xFFBB00</span></span>&gt;; <span class="hljs-comment"><span class="hljs-comment">//    VLQ! local uint size = marker.size; //       ( , )          switch (marker._ &amp; 0x7) { case 1: double v; size += 8; break; //     case 5: float v; size += 4; break; default: VLQ v; size += v.size; break; } }; struct PackedVector3 { Packed marker &lt;name="Marker"&gt;; Packed x &lt;name="X"&gt;; Packed y &lt;name="Y"&gt;; Packed z &lt;name="Z"&gt;; };</span></span></code> </pre><br> 现在，我们的运动消息模板已大大减少： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveEvent</span></span></span><span class="hljs-class"> {</span></span> uint data_length &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>, name=<span class="hljs-string"><span class="hljs-string">"Data Length"</span></span>&gt;; Packed move_time &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FFFF</span></span>&gt;; PackedVector3 position &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; PackedVector3 direction &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; PackedVector3 speed &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; Packed state &lt;bgcolor=<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>&gt;; };</code> </pre><br> 在下一篇文章中，我们可能需要的另一种类型是在其行的<code>Packed</code>值之前的行： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackedString</span></span></span><span class="hljs-class"> {</span></span> Packed length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> str[length.v._]; };</code> </pre><br> 现在，了解了示例消息格式，您可以编写侦听应用程序，以方便过滤和分析消息，但这是下一篇文章的主题。 <br><br>  <b>更新：</b>感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">aml</a>提示上述消息结构是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Protocol Buffer</a> ，也<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">感谢Tatikoma</a>链接到有用的相关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451512/">https://habr.com/ru/post/zh-CN451512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451502/index.html">5月13日至19日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN451504/index.html">网络上的图片2019</a></li>
<li><a href="../zh-CN451506/index.html">DNSCrypt如何通过输入24小时有效期来解决过期的证书问题</a></li>
<li><a href="../zh-CN451508/index.html">虚拟指南：使用开源工具创建DevOps链</a></li>
<li><a href="../zh-CN451510/index.html">JetBrains的一些有关C ++工具的技术歌词，以及独角兽与它有什么关系</a></li>
<li><a href="../zh-CN451514/index.html">CSS Subgrid新闻</a></li>
<li><a href="../zh-CN451516/index.html">Spring框架中使用的设计模式</a></li>
<li><a href="../zh-CN451518/index.html">我们精简的移动网站</a></li>
<li><a href="../zh-CN451520/index.html">VDI：便宜又开朗</a></li>
<li><a href="../zh-CN451522/index.html">我们在几个小时内部署自动化：TypeScript，Protractor，Jasmine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>