<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßÄ üèÜ üèùÔ∏è Manajemen memori python üë¥üèº üìµ ‚òπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Jadi akhir pekan panjang Maret berakhir. Kami ingin mendedikasikan publikasi pasca-liburan pertama untuk orang yang dicintai oleh banya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen memori python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443312/">  Halo semuanya!  Jadi akhir pekan panjang Maret berakhir.  Kami ingin mendedikasikan publikasi pasca-liburan pertama untuk orang yang dicintai oleh banyak kursus - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang Python"</a> , yang dimulai dalam waktu kurang dari 2 minggu.  Ayo pergi. <br><br>  <b>Isi</b> <br><br><ol><li>  Memori adalah buku kosong </li><li>  Manajemen Memori: Dari Perangkat Keras ke Perangkat Lunak </li><li>  Implementasi basis Python </li><li>  Konsep Global Interpreter Lock (GIL) </li><li>  Pengumpul sampah </li><li>  Manajemen Memori dalam CPython: <br><ul><li>  Kolam renang </li><li>  Blok </li><li>  Arena </li></ul></li><li>  Kesimpulan </li></ol><br><img src="https://habrastorage.org/webt/ww/vn/wj/wwvnwjqala4vtezc2ei4dx4ml_w.png"><br><br>  Pernahkah Anda bertanya-tanya bagaimana Python di belakang panggung memproses data Anda?  Bagaimana variabel Anda disimpan dalam memori?  Pada titik apa mereka dipindahkan? <br>  Pada artikel ini, kita akan mempelajari lebih dalam struktur internal Python untuk memahami cara kerja manajemen memori. <br><br>  Setelah membaca artikel ini, Anda: <br><br><ul><li>  Pelajari lebih lanjut tentang operasi tingkat rendah, terutama memori. </li><li>  Memahami bagaimana Python mengabstraksi operasi tingkat rendah. </li><li>  Pelajari tentang algoritma manajemen memori dengan Python. </li></ul><br>  Mengetahui struktur internal Python akan memberikan pemahaman yang lebih baik tentang prinsip-prinsip perilakunya.  Saya harap Anda dapat melihat Python dari perspektif baru.  Di balik layar, ada begitu banyak operasi logis untuk membuat program Anda berfungsi dengan baik. <a name="habracut"></a><br><br>  <b>Memori adalah buku kosong.</b> <br><br>  Anda dapat membayangkan memori komputer sebagai buku kosong, menunggunya menulis banyak cerita pendek.  Belum ada apa-apa di halamannya, tetapi penulis akan segera muncul yang ingin menulis cerita mereka di dalamnya.  Untuk melakukan ini, mereka akan membutuhkan tempat. <br>  Karena mereka tidak dapat menulis satu cerita di atas yang lain, mereka harus sangat berhati-hati tentang halaman yang mereka tulis.  Sebelum Anda mulai menulis, mereka berkonsultasi dengan manajer buku.  Manajer memutuskan di mana dalam buku itu penulis dapat menuliskan cerita mereka. <br><br>  Karena buku itu telah ada selama bertahun-tahun, banyak cerita di dalamnya menjadi ketinggalan zaman.  Ketika tidak ada yang membaca atau membahas sejarah, mereka menghapusnya untuk memberi jalan bagi cerita baru. <br>  Pada intinya, memori komputer seperti buku kosong.  Blok memori berkelanjutan dengan panjang tetap biasanya disebut halaman, jadi analogi ini berguna. <br><br>  Penulis dapat berbagai aplikasi atau proses yang perlu menyimpan data dalam memori.  Seorang manajer yang memutuskan di mana penulis dapat menulis cerita mereka memainkan peran manajer memori - penyortir.  Dan orang yang menghapus cerita lama adalah seorang pemulung. <br><br>  <b>Manajemen Memori: Dari Perangkat Keras ke Perangkat Lunak</b> <br><br>  Manajemen memori adalah proses di mana aplikasi perangkat lunak membaca dan menulis data.  Manajer memori menentukan tempat untuk meletakkan data program.  Karena jumlah memori tentu saja, seperti jumlah halaman dalam buku, maka, manajer perlu menemukan ruang kosong untuk menyediakannya untuk digunakan oleh aplikasi.  Proses ini disebut "alokasi memori". <br><br>  Di sisi lain, ketika data tidak lagi dibutuhkan, itu bisa dihapus.  Dalam hal ini, mereka berbicara tentang membebaskan memori.  Tapi dari mana itu dibebaskan dan dari mana asalnya? <br>  Di suatu tempat di dalam komputer ada perangkat fisik yang menyimpan data ketika Anda menjalankan program Python.  Kode python melewati banyak level abstraksi sebelum sampai ke perangkat ini. <br><br>  Salah satu level utama yang terletak di atas peralatan (RAM, hard disk, dll.) Adalah sistem operasi.  Ia mengelola permintaan baca dan tulis ke memori. <br>  Di atas sistem operasi ada lapisan aplikasi di mana ada salah satu implementasi Python (kabel ke OS Anda atau diunduh dari python.org).  Manajemen memori untuk kode dalam bahasa pemrograman ini diatur oleh alat Python khusus.  Algoritma dan struktur yang digunakan Python untuk mengelola memori adalah topik utama artikel ini. <br><br>  <b>Implementasi basis Python</b> <br><br>  Implementasi dasar dari Python, atau "pure Python", adalah CPython ditulis dalam C. <br>  Saya sangat terkejut ketika saya pertama kali mendengarnya.  Bagaimana bisa satu bahasa ditulis dalam bahasa lain ?!  Ya, tentu saja tidak secara harfiah, tetapi idenya kira-kira seperti ini. <br><br>  Bahasa Python dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual referensi khusus dalam bahasa Inggris</a> .  Namun, panduan ini saja tidak terlalu berguna.  Anda masih memerlukan alat untuk menafsirkan kode yang ditulis oleh aturan direktori. <br><br>  Anda juga akan memerlukan sesuatu untuk mengeksekusi kode di komputer Anda.  Implementasi Python dasar menyediakan kedua kondisi.  Itu mengubah kode Python menjadi instruksi yang dieksekusi di mesin virtual. <br><br><blockquote>  Catatan: Mesin virtual mirip dengan komputer fisik, tetapi mereka tertanam dalam perangkat lunak.  Mereka memproses instruksi dasar yang mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode perakitan</a> . </blockquote><br><br>  Python adalah bahasa pemrograman yang ditafsirkan.  Kode Python Anda dikompilasi menggunakan instruksi yang lebih mudah dipahami oleh komputer - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bytecode</a> .  Instruksi ini ditafsirkan oleh mesin virtual ketika Anda menjalankan kode. <br><br>  Pernahkah Anda melihat file dengan ekstensi <i>.pyc</i> atau folder <i>__pycache__</i> ?  Ini adalah bytecode yang sama yang ditafsirkan oleh mesin virtual. <br>  Penting untuk memahami bahwa ada implementasi lain selain CPython, misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IronPython</a> , yang mengkompilasi dan berjalan di Microsoft Common Language Runtime (CLR).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jython</a> mengkompilasi ke bytecode Java untuk dijalankan di mesin virtual Java.  Ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyPy</a> tentang yang Anda dapat menulis artikel terpisah, jadi saya hanya akan menyebutkannya secara sepintas. <br><br>  Pada artikel ini, kita akan fokus pada manajemen memori menggunakan alat CPython. <br>  Catatan: Versi Python diperbarui dan apa pun bisa terjadi di masa depan.  Pada saat penulisan, versi terbaru adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python 3.7</a> . <br><br>  Ok, kita memiliki CPython yang ditulis dalam C yang menginterpretasikan bytecode Python.  Bagaimana ini berhubungan dengan manajemen memori?  Untuk mulai dengan, algoritma dan struktur untuk mengelola memori ada dalam kode CPython, di C. Untuk memahami prinsip-prinsip ini di Python, Anda memerlukan pemahaman dasar tentang CPython. <br><br>  CPython ditulis dalam C, yang pada gilirannya tidak mendukung pemrograman berorientasi objek.  Karena itu, kode CPython memiliki struktur yang agak menarik. <br><br>  Anda pasti pernah mendengar bahwa segala sesuatu di Python adalah objek, bahkan tipe seperti int dan str, misalnya.  Ini berlaku di tingkat implementasi CPython.  Ada struktur yang disebut PyObject yang digunakan oleh setiap objek dalam CPython. <br><br>  Catatan: Struktur dalam C adalah tipe data yang ditentukan pengguna yang mengelompokkan berbagai jenis data itu sendiri.  Kita dapat menggambar analogi dengan bahasa berorientasi objek dan mengatakan bahwa struktur adalah kelas dengan atribut, tetapi tanpa metode. <br><br>  PyObject adalah nenek moyang semua objek dalam Python, hanya berisi dua hal: <br><br><ul><li>  <b>ob_refcnt</b> : penghitung referensi; </li><li>  <b>ob_type</b> : pointer ke tipe lain. </li></ul><br>  Penghitung referensi diperlukan untuk pengumpulan sampah.  Kami juga memiliki pointer ke tipe objek tertentu.  Jenis objek hanyalah struktur lain yang menjelaskan objek dengan Python (seperti dict atau int). <br><br>  Setiap objek memiliki pengalokasi memori berorientasi objek yang tahu bagaimana mengalokasikan memori dan menyimpan objek.  Setiap objek juga memiliki pembebas sumber daya berorientasi objek yang membersihkan memori jika isinya tidak lagi diperlukan. <br><br>  Ada satu faktor penting dalam berbicara tentang alokasi memori dan pembersihannya.  Memori adalah sumber daya bersama dari komputer, dan hal yang agak tidak menyenangkan dapat terjadi jika dua proses mencoba menulis data ke lokasi memori yang sama pada saat yang sama. <br><br>  <b>Global Interpretation Lock (GIL)</b> <br><br>  GIL adalah solusi untuk masalah umum memori bersama antara sumber daya bersama seperti memori komputer.  Ketika dua utas mencoba untuk mengubah sumber daya yang sama pada saat yang sama, mereka saling menginjak.  Akibatnya, kekacauan total terbentuk dalam memori dan tidak ada proses yang akan menyelesaikan pekerjaannya dengan hasil yang diinginkan. <br><br>  Kembali ke analogi dengan buku, anggaplah bahwa dari dua penulis, masing-masing memutuskan bahwa ia harus menulis ceritanya di halaman saat ini pada saat tertentu.  Masing-masing dari mereka mengabaikan upaya yang lain untuk menulis sebuah cerita dan mulai dengan keras kepala menulis di halaman.  Akibatnya, kami memiliki dua cerita, satu di atas yang lain, dan halaman yang sama sekali tidak dapat dibaca. <br><br>  Salah satu solusi untuk masalah ini adalah GIL, yang memblokir penerjemah sementara utas berinteraksi dengan sumber daya yang dialokasikan, sehingga memungkinkan satu dan hanya satu utas untuk menulis ke area memori yang dialokasikan.  Ketika CPython mengalokasikan memori, ia menggunakan GIL untuk memastikan bahwa itu benar. <br>  Pendekatan ini memiliki banyak kelebihan dan banyak kekurangan, itulah sebabnya GIL menyebabkan perselisihan di komunitas Python.  Untuk mempelajari lebih lanjut tentang GIL, saya sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> berikut. <br><br>  <b>Pengumpul sampah</b> <br><br>  Mari kita kembali ke analogi kita dengan buku itu dan membayangkan bahwa beberapa cerita di dalamnya sudah ketinggalan zaman.  Tidak ada yang membacanya dan mengatasinya.  Dalam hal ini, solusi alami adalah dengan menyingkirkan mereka sebagai tidak perlu, sehingga membebaskan ruang untuk cerita baru. <br>  Cerita lama yang tidak digunakan seperti itu dapat dibandingkan dengan objek dalam Python yang jumlah referensinya turun menjadi 0. Ingatlah bahwa setiap objek dalam Python memiliki jumlah referensi dan penunjuk ke suatu jenis. <br><br>  Jumlah referensi dapat bertambah karena beberapa alasan.  Misalnya, itu akan meningkat jika Anda menetapkan satu variabel ke variabel lain. <br><br><img src="https://habrastorage.org/webt/zv/me/dj/zvmedjrxhn3qqrac6tibjlrpnuu.png"><br><br>  Ini juga akan meningkat jika Anda melewatkan objek sebagai argumen. <br><br><img src="https://habrastorage.org/webt/kq/np/pm/kqnppmeqfhl4pg6-4atqz_nnhhq.png"><br><br>  Dalam contoh terakhir, jumlah referensi akan meningkat jika Anda memasukkan objek dalam daftar. <br><br><img src="https://habrastorage.org/webt/ql/ro/mj/qlromj2eg80jfhzykfkpzv8syfg.png"><br><br>  Python memberi tahu Anda nilai saat ini dari penghitung referensi menggunakan modul sys.  Anda dapat menggunakan <code>sys.getrefcount(numbers)</code> , tetapi ingat bahwa memanggil <code>getrefcount()</code> akan menambah penghitung referensi dengan yang lain. <br><br>  Bagaimanapun, jika objek dalam kode Anda masih diperlukan, nilainya untuk penghitung referensi akan lebih dari 0. Dan ketika turun ke nol, fungsi khusus akan dimulai untuk menghapus memori, yang akan membebaskannya dan membuatnya tersedia untuk objek lain. <br><br>  Tapi apa artinya "membebaskan memori" dan bagaimana benda lain menggunakannya?  Mari selami manajemen memori secara langsung dengan CPython. <br><br>  <b>Manajemen Memori dalam CPython</b> <br><br>  Pada bagian ini, kita akan menyelami arsitektur memori CPython dan algoritma yang digunakannya. <br><br>  Seperti disebutkan sebelumnya, ada yang namanya tingkat abstraksi antara peralatan fisik dan CPython.  Sistem operasi (OS) mengabstraksi memori fisik dan menciptakan tingkat memori virtual yang dapat diakses oleh aplikasi, termasuk Python. <br><br>  Manajer memori virtual berorientasi OS mengalokasikan area memori tertentu untuk proses Python.  Dalam gambar, area abu-abu gelap adalah ruang yang ditempati proses Python. <br><br><img src="https://habrastorage.org/webt/6k/-f/n6/6k-fn6hhelja1ilktfil1yzmaas.png"><br><br>  Python menggunakan bagian dari memori untuk penggunaan internal dan memori non-objek.  Bagian lainnya dibagi menjadi penyimpanan benda ( <i>int, dict</i> , dll.) Sekarang saya berbicara dalam bahasa yang sangat sederhana, tetapi Anda dapat melihat langsung di bawah tenda, yaitu, ke dalam <a href="">kode sumber CPython</a> dan melihat bagaimana semuanya terjadi dari sudut pandang praktis. . <br><br>  Di CPython, ada pengalokasi objek yang bertanggung jawab untuk mengalokasikan memori dalam area memori objek.  Di distributor benda inilah semua sihir dilakukan.  Disebut setiap kali ketika setiap objek baru perlu menempati atau membebaskan memori. <br><br>  Biasanya, menambah dan menghapus data dalam Python, seperti int atau daftar, misalnya, tidak menggunakan banyak data sekaligus.  Itulah sebabnya arsitektur dispenser berfokus pada bekerja dengan sejumlah kecil data per unit waktu.  Juga, dia tidak mengalokasikan memori di muka, yaitu, sampai saat itu sampai menjadi mutlak diperlukan. <br><br>  Komentar dalam kode sumber mendefinisikan pengalokasi sebagai "pengalokasi memori cepat tujuan khusus yang berfungsi seperti fungsi malloc universal."  Dengan demikian, dalam C, malloc digunakan untuk mengalokasikan memori. <br><br>  Sekarang mari kita lihat strategi alokasi memori CPython.  Pertama, mari kita bicara tentang tiga bagian utama dan bagaimana mereka saling berhubungan. <br><br>  Arena adalah area memori terbesar yang menempati ruang hingga batas halaman dalam memori.  Batas halaman (penyebaran halaman) adalah titik ekstrem dari blok memori terus menerus dengan panjang tetap yang digunakan oleh OS.  Python menetapkan batas halaman sistem ke 256 KB. <br><br><img src="https://habrastorage.org/webt/cu/t2/ta/cut2ta8lwor00zy8h5k8ogjjhgy.png"><br><br>  Di dalam arena adalah kolam (pool), yang dianggap sebagai satu halaman virtual memori (4 Kb).  Mereka tampak seperti halaman dalam analogi kami.  Kolam dibagi menjadi potongan memori yang lebih kecil. <br><br>  Semua blok di kolam ditemukan dalam satu "kelas ukuran".  Kelas ukuran menentukan ukuran blok, memiliki sejumlah data yang diminta.  Gradasi dalam tabel di bawah ini diambil langsung dari komentar di kode sumber: <br><br><img src="https://habrastorage.org/webt/n9/sk/55/n9sk55ex-esbcfdnnxhavivbeta.png"><br><br>  Misalnya, jika diperlukan 42 byte, maka data akan ditempatkan dalam blok 48 byte. <br><br>  <b>Kolam renang</b> <br><br>  Kolam terdiri dari balok dengan kelas ukuran yang sama.  Masing-masing kelompok bekerja berdasarkan prinsip daftar tertaut ganda dengan kelompok lain dengan kelas ukuran yang sama.  Oleh karena itu, algoritma dapat dengan mudah menemukan tempat yang diperlukan untuk ukuran blok yang diperlukan, bahkan di antara banyak kumpulan. <br><br>  Daftar <code>usedpools list</code> melacak semua pool yang memiliki semacam ruang kosong yang tersedia untuk data setiap kelas ukuran.  Ketika ukuran blok yang diminta diminta, algoritme memeriksa daftar kumpulan yang digunakan untuk menemukan kumpulan yang cocok untuknya. <br><br>  Kolam ada di tiga negara: digunakan, penuh, kosong.  Kumpulan yang digunakan berisi blok di mana beberapa informasi dapat ditulis.  Blok-blok kumpulan lengkap semuanya didistribusikan dan sudah berisi data.  Kolam kosong tidak mengandung data dan dapat dipecah menjadi kelas ukuran apa yang cocok jika perlu. <br><br>  Daftar kumpulan kosong ( <code>freepools list</code> ) masing-masing berisi semua kumpulan dalam keadaan kosong.  Tetapi pada titik apa mereka digunakan? <br><br>  Katakanlah kode Anda membutuhkan area memori 8 byte.  Jika tidak ada kolam dalam daftar kolam yang digunakan dengan ukuran kelas 8 byte, maka kolam kosong baru diinisialisasi sebagai menyimpan blok 8 byte.  Kemudian kolam kosong ditambahkan ke daftar kolam yang digunakan dan dapat digunakan dalam pertanyaan berikut. <br><br>  Kumpulan lengkap membebaskan beberapa blok saat informasi di dalamnya tidak lagi diperlukan.  Kumpulan ini akan ditambahkan ke daftar yang digunakan sesuai dengan kelas ukurannya.  Anda dapat mengamati bagaimana kumpulan mengubah status mereka dan bahkan kelas berdasarkan algoritma. <br><br>  <b>Blok</b> <br><br><img src="https://habrastorage.org/webt/p4/y1/_v/p4y1_v_kaiwweb9eut_gl3boybg.png"><br><br>  Seperti dapat dilihat dari gambar, kolam berisi pointer ke blok memori bebas.  Ada sedikit nuansa dalam pekerjaan mereka.  Menurut komentar dalam kode sumber, distributor "berusaha untuk tidak pernah menyentuh area memori di level mana pun (arena, kolam, blok) sampai diperlukan." <br><br>  Ini berarti bahwa satu blok dapat memiliki tiga status.  Mereka dapat didefinisikan sebagai berikut: <br><br><ul><li>  <b>Untouched</b> : area memori yang belum dialokasikan; </li><li>  <b>Gratis</b> : area memori yang dialokasikan tetapi kemudian dibebaskan oleh CPython karena tidak mengandung informasi yang relevan; </li><li>  <b>Terdistribusi</b> : area memori yang saat ini berisi informasi saat ini. </li></ul><br>  Pointer freeblock adalah daftar blok memori bebas yang ditautkan tunggal.  Dengan kata lain, ini adalah daftar tempat-tempat gratis tempat Anda dapat menulis informasi.  Jika lebih banyak memori diperlukan daripada yang ada di blok gratis, maka pengalokasi menggunakan blok yang tidak tersentuh di kumpulan. <br><br>  Segera setelah manajer memori membebaskan blok, blok ini ditambahkan ke bagian atas daftar blok gratis.  Daftar aktual mungkin tidak mengandung urutan terus menerus dari blok memori, seperti pada angka "sukses" pertama. <br><br><img src="https://habrastorage.org/webt/cj/7g/d-/cj7gd-xeci1k_d0qwexo8zarr5y.png"><br><br>  <b>Arena</b> <br><br>  Arena berisi kolam.  Arena, tidak seperti kolam renang, tidak memiliki divisi negara eksplisit. <br><br>  Mereka sendiri diatur ke dalam daftar yang ditautkan ganda yang disebut daftar arena yang dapat digunakan (usable_arenas).  Daftar ini diurutkan berdasarkan jumlah kolam gratis.  Semakin sedikit kolam gratis, semakin dekat arena ke atas daftar. <br><br><img src="https://habrastorage.org/webt/4e/1f/fl/4e1ffl6eisaila8c1zxsmh3fc_m.png"><br><br>  Ini berarti bahwa arena paling lengkap akan dipilih untuk merekam lebih banyak data.  Tapi mengapa tepatnya?  Mengapa tidak menulis data ke tempat di mana ruang paling bebas berada? <br><br>  Ini membawa kita pada gagasan membebaskan memori sepenuhnya.  Faktanya adalah bahwa dalam beberapa kasus, ketika memori dibebaskan, masih tetap tidak dapat diakses oleh sistem operasi.  Proses Python membuatnya tetap didistribusikan dan menggunakannya nanti untuk data baru.  Deallokasi memori penuh mengembalikan memori ke sistem operasi. <br><br>  Arena bukan satu-satunya area yang bisa dikosongkan sepenuhnya.  Dengan demikian, kami memahami bahwa arena-arena yang ada dalam daftar "lebih dekat dengan kosong" harus dibebaskan.  Dalam hal ini, area memori benar-benar dapat dibebaskan sepenuhnya, dan karenanya, total kapasitas memori program Python Anda berkurang. <br><br>  <b>Kesimpulan</b> <br><br>  Manajemen memori adalah salah satu bagian terpenting dalam bekerja dengan komputer.  Dengan satu atau lain cara, Python melakukan hampir semua operasinya dalam mode siluman. <br><br>  Dari artikel ini Anda belajar: <br><br><ul><li>  Apa manajemen memori dan mengapa itu penting? </li><li>  Apa itu CPython, implementasi dasar Python; </li><li>  Bagaimana struktur data dan algoritma bekerja dalam manajemen memori CPython dan menyimpan data Anda. </li></ul><br>  Python meringkas banyak nuansa bekerja dengan komputer.  Hal ini memungkinkan untuk bekerja pada level yang lebih tinggi dan menghilangkan sakit kepala pada topik di mana dan bagaimana byte dari program Anda disimpan. <br><br>  Jadi kami belajar tentang manajemen memori dengan Python.  Secara tradisional, kami menunggu komentar Anda, dan kami juga mengundang Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hari terbuka</a> di kursus Pengembang Python, yang akan berlangsung pada 13 Maret </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443312/">https://habr.com/ru/post/id443312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443300/index.html">Bagaimana perkembangannya di United Traders</a></li>
<li><a href="../id443302/index.html">Bagaimana Apple mempersiapkan era setelah iPhone</a></li>
<li><a href="../id443306/index.html">Delapan Hukum Penamaan dalam Desain UX (Bagian 1)</a></li>
<li><a href="../id443308/index.html">Mitos fisika modern. Hukum konservasi</a></li>
<li><a href="../id443310/index.html">Ulasan Gadget Kesehatan Wanita Bellabeat</a></li>
<li><a href="../id443316/index.html">Pengujian ReactJS: Seberapa Dalam Lubang Kelinci itu</a></li>
<li><a href="../id443318/index.html">Menulis loader wasm untuk Ghidra. Bagian 1: Pernyataan masalah dan pengaturan lingkungan</a></li>
<li><a href="../id443320/index.html">Sistem manajemen dokumen elektronik "Wazir"</a></li>
<li><a href="../id443322/index.html">GitLab 11.8 dirilis dengan SAST untuk JavaScript, GitLab Pages untuk subkelompok dan pelacakan bug</a></li>
<li><a href="../id443324/index.html">Python vs. Scala for Apache Spark - benchmark yang diharapkan dengan hasil yang tidak terduga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>