<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍝 🌺 👲🏼 Solicitação de API com ganchos de reação, HOC ou prop de renderização 👨🏾‍🔧 👩🏿‍🚀 👨‍👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Considere a implementação de solicitar dados à API usando o novo amigo React Hooks e os bons velhos amigos Render Prop e HOC (Higher Order Component)....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solicitação de API com ganchos de reação, HOC ou prop de renderização</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453866/"><p><img src="https://habrastorage.org/webt/s8/xs/sy/s8xssyovbjdd26lj5n-4sbi5obu.jpeg"></p><br><p>  Considere a implementação de solicitar dados à API usando o novo amigo React Hooks e os bons velhos amigos Render Prop e HOC (Higher Order Component).  Descubra se um novo amigo é realmente melhor que os dois antigos. </p><a name="habracut"></a><br><p>  A vida não pára, o React está mudando para melhor.  Em fevereiro de 2019, o React Hooks apareceu no React 16.8.0.  Agora, nos componentes funcionais, você pode trabalhar com o estado local e executar efeitos colaterais.  Ninguém acreditava que era possível, mas todos sempre queriam.  Se você não estiver atualizado com os detalhes, clique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> para obter detalhes. </p><br><p>  Os React Hooks possibilitam finalmente abandonar padrões como HOC e Render Prop.  Porque durante o uso, várias reivindicações foram acumuladas contra elas: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  RProp </th><th>  Hoc </th></tr></thead><tbody><tr><td>  1. Muitos componentes do wrapper que são difíceis de entender no React DevTools e no código. </td><td>  (◕︵◕) </td><td>  (◕︵◕) </td></tr><tr><td>  2. É difícil digitar (Flow, TypeScript). </td><td></td><td>  (◕︵◕) </td></tr><tr><td>  3. Não é óbvio de qual HOC que sustenta o componente recebe, o que complica o processo de depuração e a compreensão de como o componente funciona. </td><td></td><td>  (◕︵◕) </td></tr><tr><td>  4. O Render Prop na maioria das vezes não adiciona layout, embora seja usado dentro do JSX. </td><td>  (◕︵◕) </td><td></td></tr><tr><td>  5. Adereços de colisão principais.  Ao transmitir adereços dos pais, as mesmas chaves podem ser substituídas pelos valores do HOC. </td><td></td><td>  (◕︵◕) </td></tr><tr><td>  6. É difícil ler o git diff, pois todo o recuo no JSX é alterado ao agrupar o JSX no Render Prop. </td><td>  (◕︵◕) </td><td></td></tr><tr><td>  7. Se houver vários HOCs, você poderá cometer um erro com a sequência da composição.  A ordem correta nem sempre é óbvia, pois a lógica está oculta dentro do HOC.  Por exemplo, quando verificamos primeiro se o usuário está autorizado e somente depois solicitamos dados pessoais. </td><td></td><td>  (◕︵◕) </td></tr></tbody></table></div><br><p>  Para não ser infundado, vejamos um exemplo de como o React Hooks é melhor (ou talvez pior) Render Prop.  Vamos considerar o Render Prop, não o HOC, pois na implementação eles são muito semelhantes e o HOC tem mais desvantagens.  Vamos tentar escrever um utilitário que processa a solicitação de dados na API.  Tenho certeza de que muitos escreveram isso em suas vidas centenas de vezes, bem, vamos ver se é possível ainda melhor e mais fácil. </p><br><p>  Para isso, usaremos a popular biblioteca axios.  No cenário mais simples, você precisa processar os seguintes estados: </p><br><ul><li>  processo de aquisição de dados (isFetching) </li><li>  dados recebidos com sucesso (responseData) </li><li>  erro ao receber dados (erro) </li><li>  cancelamento da solicitação, se no curso de sua execução os parâmetros da solicitação tiverem sido alterados e um novo </li><li>  cancelando uma solicitação se este componente não estiver mais no DOM </li></ul><br><p>  <strong>1. Cenário simples</strong> </p><br><p>  Escreveremos o estado padrão e uma função (redutor) que muda de estado dependendo do resultado da solicitação: sucesso / erro. </p><br><div class="spoiler">  <b class="spoiler_title">O que é redutor?</b> <div class="spoiler_text"><p>  Para referência.  O redutor chegou até nós da programação funcional e para a maioria dos desenvolvedores de JS do Redux.  Essa é uma função que executa um estado e ação anteriores e retorna o próximo estado. </p></div></div><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultState = { <span class="hljs-attr"><span class="hljs-attr">responseData</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"fetched"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">responseData</span></span>: action.payload }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"error"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: action.payload }; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  Reutilizamos essa função em duas abordagens. </p><br><p>  <strong>Render prop</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RenderProp1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = defaultState; axiosSource = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; tryToCancel() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.axiosSource) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.axiosSource.cancel(); } } dispatch(action) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prevState</span></span></span><span class="hljs-function"> =&gt;</span></span> reducer(prevState, action)); } fetch = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tryToCancel(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.axiosSource = axios.CancelToken.source(); axios .get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.url, { <span class="hljs-attr"><span class="hljs-attr">cancelToken</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.axiosSource.token }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"fetched"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: response.data }); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"error"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: error }); }); }; componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fetch(); } componentDidUpdate(prevProps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevProps.url !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.url) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fetch(); } } componentWillUnmount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tryToCancel(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.children(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state); }</code> </pre><br><p>  <strong>Ganchos de reação</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> useRequest1 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, dispatch] = React.useReducer(reducer, defaultState); React.useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> source = axios.CancelToken.source(); axios .get(url, { <span class="hljs-attr"><span class="hljs-attr">cancelToken</span></span>: source.token }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"fetched"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: response.data }); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"error"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: error }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source.cancel; }, [url]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [state]; };</code> </pre> <br><p>  Por url, do componente usado, obtemos os dados - axios.get ().  Processamos sucesso e erro, mudando de estado por meio de despacho (ação).  Retorne o estado ao componente.  E não esqueça de cancelar a solicitação se o URL mudar ou se o componente for removido do DOM.  É simples, mas você pode escrever de maneiras diferentes.  Destacamos os prós e os contras das duas abordagens: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Hooks </th><th>  RProp </th></tr></thead><tbody><tr><td>  1. Menos código. </td><td>  (◑‿◐) </td><td></td></tr><tr><td>  2. Chamar o efeito colateral (solicitar dados na API) é mais fácil de ler, pois está escrito linearmente, e não se espalha pelos ciclos de vida do componente. </td><td>  (◑‿◐) </td><td></td></tr><tr><td>  3. O cancelamento da solicitação é gravado imediatamente após a solicitação.  Tudo em um só lugar. </td><td>  (◑‿◐) </td><td></td></tr><tr><td>  4. Código simples que descreve os parâmetros de rastreamento para desencadear efeitos colaterais. </td><td>  (◑‿◐) </td><td></td></tr><tr><td>  5. Obviamente, em qual ciclo de vida do componente nosso código será executado. </td><td></td><td>  (◑‿◐) </td></tr></tbody></table></div><br><p>  O React Hooks permite que você escreva menos código, e esse é um fato indiscutível.  Portanto, a eficácia de você como desenvolvedor está aumentando.  Mas você tem que dominar um novo paradigma. </p><br><p>  Quando existem nomes de ciclos de vida dos componentes, tudo fica muito claro.  Primeiro, obtemos os dados depois que o componente apareceu na tela (componentDidMount) e, em seguida, obtemos novamente se props.url mudou e, antes disso, não esquecemos de cancelar a solicitação anterior (componentDidUpdate), se o componente foi removido do DOM, cancelamos a solicitação (componentWillUnmount) . </p><br><p>  Mas agora, como causamos um efeito colateral diretamente na renderização, fomos ensinados que isso não é possível.  Embora pare, não realmente na renderização.  E dentro da função useEffect, que executará algo de forma assíncrona após cada renderização, ou melhor, confirmar e renderizar o novo DOM. </p><br><p>  Mas não precisamos depois de cada renderização, mas apenas na primeira renderização e no caso de alterar a URL, que indicamos como o segundo argumento para usar o Effect. </p><br><div class="spoiler">  <b class="spoiler_title">Novo paradigma</b> <div class="spoiler_text"><p>  Para entender como o React Hooks funciona, é preciso ter consciência de coisas novas.  Por exemplo, a diferença entre as fases: confirmar e renderizar.  Na fase de renderização, o React calcula quais alterações serão aplicadas no DOM comparando com o resultado da renderização anterior.  E na fase de confirmação, o React aplica essas alterações ao DOM.  É na fase de consolidação que os métodos são chamados: componentDidMount e componentDidUpdate.  Mas o que está escrito em useEffect será chamado após a confirmação de forma assíncrona e, portanto, não bloqueará a renderização do DOM se você decidir acidentalmente acidentalmente sincronizar muitas coisas no efeito colateral. </p><br><p>  Conclusão - use useEffect.  Escrever menos e mais seguro. </p><br><p>  E mais um ótimo recurso: useEffect pode limpar após o efeito anterior e após remover o componente do DOM.  Agradecemos a Rx, que inspirou a equipe React para essa abordagem. </p></div></div><br><p>  O uso do nosso utilitário com React Hooks também é muito mais conveniente. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AvatarRenderProp1 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ username }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">RenderProp</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">url</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">https:</span></span></span></span><span class="xml"><span class="hljs-tag">//</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">api.github.com</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">users</span></span></span></span><span class="xml"><span class="hljs-tag">/${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">username</span></span></span></span><span class="xml"><span class="hljs-tag">}`}&gt;</span></span></span><span class="xml"> {state =&gt; { if (state.isFetching) { return "Loading"; } if (state.error) { return "Error"; } return </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{state.responseData.avatar_url}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"avatar"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; }} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">RenderProp</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> );</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AvatarWithHook1 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ username }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state] = useRequest(<span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${username}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.isFetching) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Loading"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Error"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{state.responseData.avatar_url}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"avatar"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; };</span></span></code> </pre> <br><p>  A opção React Hooks novamente parece mais compacta e óbvia. </p><br><p>  Contras Render Prop: </p><br><p>  1) não está claro se o layout foi adicionado ou apenas a lógica <br>  2) se você precisar processar o estado do Render Prop no estado local ou nos ciclos de vida do componente filho, será necessário criar um novo componente </p><br><p>  Adicione uma nova funcionalidade - recebimento de dados com novos parâmetros por ação do usuário.  Eu queria, por exemplo, um botão que receba um avatar do seu desenvolvedor favorito. </p><br><p>  <strong>2) Atualizando dados de ação do usuário</strong> </p><br><p>  Adicione um botão que envia uma solicitação com um novo nome de usuário.  A solução mais simples é armazenar o nome de usuário no estado local do componente e transferir o novo nome de usuário do estado, não props como é agora.  Mas teremos copiar e colar sempre que precisarmos de funcionalidade semelhante.  Então, colocamos essa funcionalidade em nosso utilitário. </p><br><p>  Vamos usá-lo assim: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Avatar2 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ username }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... &lt;button onClick={() =&gt; update(<span class="hljs-string"><span class="hljs-string">"https://api.github.com/users/NewUsername"</span></span>)} &gt; Update avatar <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> New Username &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; ... };</span></span></code> </pre> <br><p>  Vamos escrever uma implementação.  Abaixo estão escritas apenas as alterações comparadas com a versão original. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { ... case <span class="hljs-string"><span class="hljs-string">"update url"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: action.payload, <span class="hljs-attr"><span class="hljs-attr">defaultUrl</span></span>: action.payload }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"update url manually"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: action.payload, <span class="hljs-attr"><span class="hljs-attr">defaultUrl</span></span>: state.defaultUrl }; ... } }</code> </pre> <br><p>  <strong>Render prop</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RenderProp2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">responseData</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.url, <span class="hljs-attr"><span class="hljs-attr">defaultUrl</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.url, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.defaultUrl !== props.url) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reducer(state, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"update url"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: props.url }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } ... componentDidUpdate(prevProps, prevState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevState.url !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.url) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fetch(); } } ... update = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"update url manually"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: url }); }; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.children(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update); } }</code> </pre> <br><p>  <strong>Ganchos de reação</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> useRequest2 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, dispatch] = React.useReducer(reducer, { url, <span class="hljs-attr"><span class="hljs-attr">defaultUrl</span></span>: url, <span class="hljs-attr"><span class="hljs-attr">responseData</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url !== state.defaultUrl) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"update url"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: url }); } React.useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { …(fetch data); }, [state.url]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> update = React.useCallback( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"update url manually"</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: url }); }, [dispatch] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [state, update]; };</code> </pre> <br><p>  Se você analisou cuidadosamente o código, notou: </p><br><ul><li>  O URL começou a ser armazenado dentro do nosso utilitário; </li><li>  defaultUrl pareceu identificar que o URL foi atualizado por meio de adereços.  Precisamos monitorar a alteração de props.url, caso contrário, uma nova solicitação não será enviada; </li><li>  adicionou a função de atualização, que retornamos ao componente para enviar uma nova solicitação clicando no botão </li></ul><br><p>  Observe que, com o Render Prop, tivemos que usar getDerivedStateFromProps para atualizar o estado local, caso as alterações de props.url.  E com React Hooks sem novas abstrações, você pode chamar imediatamente a atualização de estado na renderização - viva, camaradas, finalmente! </p><br><p>  A única complicação com o React Hooks foi memorizar a função de atualização para que ela não mudasse entre as atualizações de componentes.  Quando, como no Render Prop, a função de atualização é um método de classe. </p><br><p>  <strong>3) Polling da API no mesmo intervalo ou Polling</strong> </p><br><p>  Vamos adicionar outro recurso popular.  Às vezes, você precisa consultar constantemente a API.  Você nunca sabe que seu desenvolvedor favorito alterou a imagem do perfil e não sabe disso.  Adicione o parâmetro interval. </p><br><p>  Uso: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AvatarRenderProp3 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ username }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">RenderProp</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">url</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">https:</span></span></span></span><span class="xml"><span class="hljs-tag">//</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">api.github.com</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">users</span></span></span></span><span class="xml"><span class="hljs-tag">/${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">username</span></span></span></span><span class="xml"><span class="hljs-tag">}`} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pollInterval</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{1000}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ...</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AvatarWithHook3 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ username }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, update] = useRequest( <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${username}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span> ); ...</code> </pre> <br><p>  Implementação: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { ... case <span class="hljs-string"><span class="hljs-string">"poll"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">requestId</span></span>: state.requestId + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; ... } }</code> </pre> <br><p>  <strong>Render prop</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RenderProp3</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { ... requestId: <span class="hljs-number"><span class="hljs-number">1</span></span>, } ... timeoutId = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ... tryToClearTimeout() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeoutId) { clearTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeoutId); } } poll = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tryToClearTimeout(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'poll'</span></span> }); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.pollInterval); }; ... componentDidUpdate(prevProps, prevState) { ... if (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.pollInterval) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( prevState.isFetching !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.isFetching &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.isFetching ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.poll(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevState.requestId !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.requestId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fetch(); } } } componentWillUnmount() { ... this.tryToClearTimeout(); } ...</code> </pre><br><p>  <strong>Ganchos de reação</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> useRequest3 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, pollInterval</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, dispatch] = React.useReducer(reducer, { ... requestId: <span class="hljs-number"><span class="hljs-number">1</span></span>, }); React.useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { …(fetch data) }, [state.url, state.requestId]); React.useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pollInterval || state.isFetching) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"poll"</span></span> }); }, pollInterval); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearTimeout(timeoutId); }; }, [pollInterval, state.isFetching]); ... }</code> </pre> <br><p>  Um novo suporte apareceu - pollInterval.  Após a conclusão da solicitação anterior via setTimeout, incrementamos requestId.  Com ganchos, temos outro useEffect, no qual chamamos setTimeout.  E nosso antigo useEffect, que envia uma solicitação, começou a monitorar outra variável - requestId, que nos diz que setTimeout funcionou, e é hora de enviar a solicitação para um novo avatar. </p><br><p>  No Render Prop, eu tinha que escrever: </p><br><ol><li>  comparando os valores requestId e isFetching anteriores e novos </li><li>  limpar timeoutId em dois lugares </li><li>  adicione a propriedade timeoutId à classe </li></ol><br><p>  Os React Hooks permitem que você escreva de forma breve e clara o que costumávamos descrever com mais detalhes e nem sempre é claro. </p><br><p>  <strong>4) O que vem depois?</strong> <br>  Podemos continuar expandindo a funcionalidade do nosso utilitário: aceitando diferentes configurações de parâmetros de consulta, armazenando em cache dados, convertendo uma resposta e erros, atualizando à força os dados com os mesmos parâmetros - operações de rotina em qualquer aplicativo da Web grande.  Em nosso projeto, há muito tempo levamos isso para um componente (atenção!) Separado.  Sim, porque era um suporte de renderização.  Mas com o lançamento do Hooks, reescrevemos a função (useAxiosRequest) e até encontramos alguns erros na implementação antiga.  Você pode ver e tentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453866/">https://habr.com/ru/post/pt453866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453850/index.html">Sistema de crédito social chinês - o diabo é tão terrível?</a></li>
<li><a href="../pt453852/index.html">Microbiota. Como cuidar de bactérias intestinais</a></li>
<li><a href="../pt453860/index.html">AMD apresentou seus novos processadores personalizados de 7 nm Ryzen terceira geração</a></li>
<li><a href="../pt453862/index.html">Por que você deve usar o pathlib</a></li>
<li><a href="../pt453864/index.html">Usar um mouse e teclado em consoles é trapaça?</a></li>
<li><a href="../pt453868/index.html">Mini interruptor sensível ao toque com painel de vidro no nRF52832</a></li>
<li><a href="../pt453870/index.html">Escrevemos o proxy reverso socks5 no PowerShell.</a></li>
<li><a href="../pt453872/index.html">Restaurando fotos usando redes neurais</a></li>
<li><a href="../pt453874/index.html">Da roleta russa ao LOTO seguro: como proteger o pessoal do data center</a></li>
<li><a href="../pt453876/index.html">Como no Yandex.Practicum, o front-end desync venceu: um número acrobático com Redux-Saga, postMessage e Jupyter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>