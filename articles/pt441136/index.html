<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêµ üñºÔ∏è üßñüèª Armazenamento de longo prazo das m√©tricas do Prometheus (Alexey Palazhchenko, Percona) üñïüèº üåæ üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em pouco tempo, o Prometheus se tornou uma das ferramentas de monitoramento mais populares. Obrigado, em particular, e a alta velocidade de seu trabal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Armazenamento de longo prazo das m√©tricas do Prometheus (Alexey Palazhchenko, Percona)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441136/"><p>  Em pouco tempo, o Prometheus se tornou uma das ferramentas de monitoramento mais populares.  Obrigado, em particular, e a alta velocidade de seu trabalho.  Seu armazenamento local √© √≥timo para armazenamento de m√©tricas de curto prazo e trabalho com elas.  √Äs vezes, voc√™ deseja manter as m√©tricas distribu√≠das por meses e anos, cortando automaticamente os dados antigos, mas sem alterar a interface para trabalhar com eles. </p><br><p>  Sobre isso, a decodifica√ß√£o do relat√≥rio de Alexey Palazhchenko no RootConf 2018. No relat√≥rio: Prometheus, TSDB de armazenamento local, Prometheus de armazenamento remoto, PromQL, TSDB, Clickhouse, PromHouse, um pouco de InfluxDB. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LXllYmb0RTk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Quem se importa, por favor, debaixo do gato. </p><a name="habracut"></a><br><p>  Amigos!  Ol√° pessoal!  Meu nome √© Alexey Palazhchenko.  Eu trabalho na Percona.  Gostaria de falar sobre o armazenamento a longo prazo de m√©tricas no Prometheus. </p><br><p><img src="https://habrastorage.org/webt/rw/vv/4v/rwvv4v4zpjhn5tlmrclgeii9mkq.png"></p><br><p>  Trabalho na Percona e fa√ßo um produto chamado monitoramento e gerenciamento percona.  Esta √© a solu√ß√£o em caixa que nossos clientes definem para si mesmos.  O PMM √© totalmente de c√≥digo aberto.  Ele consiste em Prometheus, Grafana para gr√°ficos, software de an√°lise de consultas personalizadas e nosso pr√≥prio inv√≥lucro que permite que voc√™ fa√ßa algum gerenciamento.  Por exemplo, voc√™ pode adicionar um destino de raspar ao Prometheus.  Essas s√£o novas fontes de onde ele coletar√° m√©tricas sem precisar inserir manualmente um cont√™iner ou m√°quina virtual e editar o arquivo de configura√ß√£o. </p><br><p>  √â importante entender que esses n√£o s√£o SaaS.  N√≥s n√£o temos produ√ß√£o.  Nossa produ√ß√£o est√° localizada com nossos clientes.  Experimentar isso n√£o √© muito bom.  Temos a coisa mais pr√≥xima que poderia ser chamada de produ√ß√£o - √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://pmmdemo.percona.com/</a> .  No momento do relat√≥rio, o pmmdemo.percona.com precisava ser desligado devido ao RGPD. </p><br><p>  Entregamos PMM aos clientes - uma solu√ß√£o in a box: um cont√™iner de encaixe ou uma m√°quina virtual.  Todos eles gostam de Prometeu.  Algumas pessoas que est√£o olhando para Prometheus pela primeira vez se deparam com um modelo pull.  Para iniciantes, isso √© inconveniente.  Geralmente uma grande conversa separada.  Voc√™ pode discutir sobre m√©todos de puxar ou empurrar.  Em m√©dia, isso √© a mesma coisa. </p><br><p>  Algumas coisas em Prometeu s√£o muito legais. </p><br><ul><li><p>  A linguagem de consulta do Prometheus √© realmente uma coisa interessante que n√£o tem anal√≥gico em lugar algum. </p><br></li><li><p>  A segunda coisa que voc√™ gosta √© de descoberta de servi√ßo.  Se voc√™ tiver algum tipo de infraestrutura din√¢mica, kubernetes, automaticamente n√£o precisar√° adicionar todos os destinos para monitoramento com as m√£os.  Se est√°tico - isso tamb√©m pode ser feito de maneira simples.  Voc√™ precisa usar o arquivo de configura√ß√£o. </p><br></li></ul><br><p>  Os clientes do Prometheus gostam.  Eles querem manter as m√©tricas cada vez mais longas.  Algu√©m usa o Prometheus apenas para monitoramento operacional.  Mas algu√©m quer manter as m√©tricas por mais tempo, observar a din√¢mica, comparar com os gr√°ficos de um ano atr√°s.  Ao mesmo tempo, o objetivo do armazenamento de m√©tricas a longo prazo n√£o √© o objetivo do projeto Prometheus.  Inicialmente, ele foi criado para armazenar m√©tricas por um curto per√≠odo de tempo.  O SoundCloud armazena m√©tricas em apenas alguns dias.  Existem mecanismos no Prometheus que permitem fazer isso por mais tempo, mas eles est√£o dispostos um pouco ao lado.  Portanto, podemos tomar uma decis√£o para o ecossistema do Prometheus sem alterar o n√∫cleo do pr√≥prio sistema.  Com base neles, podemos tomar nossa pr√≥pria decis√£o dentro do mesmo ecossistema. </p><br><p><img src="https://habrastorage.org/webt/ws/1n/7k/ws1n7kpa7ohpkxwpxuli5dcpwuc.png"></p><br><p>  Este n√£o √© um relat√≥rio sobre solu√ß√µes prontas.  Este √© um relat√≥rio sobre nossa experi√™ncia, nossa dor, nossas tentativas.  Se voc√™ esperava que, ap√≥s este relat√≥rio, baixasse o cont√™iner do reposit√≥rio ou docker, execute-o e ele funcionar√°, ent√£o n√£o √© assim.  Mas, ao mesmo tempo, est√° perto o suficiente para ser assim.  Temos algumas bases.  Eles s√£o todos de c√≥digo aberto.  Voc√™ pode tentar.  Eles ainda n√£o est√£o prontos para produ√ß√£o.  Mas com as informa√ß√µes contidas neste relat√≥rio, voc√™ pode entender o porqu√™ e o que pode ser feito melhor.  Voc√™ pode tomar sua pr√≥pria decis√£o que melhor lhe convier. </p><br><p><img src="https://habrastorage.org/webt/ej/4j/sm/ej4jsmldkwk-bsme40kqehzilqc.png"></p><br><p>  Como as m√©tricas s√£o armazenadas no Prometheus?  H√° armazenamento local.  H√° armazenamento remoto.  Estes s√£o realmente dois mundos diferentes.  Eles se cruzam fracamente.  Portanto, o relat√≥rio tamb√©m √© dividido em 2 partes. </p><br><p><img src="https://habrastorage.org/webt/jm/ic/81/jmic81mrsu49j-zxv6spn9aopac.png"></p><br><p>  Se voc√™ estava em um relat√≥rio anterior no sal√£o principal, onde houve uma boa introdu√ß√£o no Prometheus, voc√™ sabe que o armazenamento local √© uma biblioteca separada chamada TSDB.  O TSDB n√£o tem nada a ver com o OpenTSDB.  O TSDB √© um pacote Go separado que voc√™ pode usar no seu programa Go.  No n√≠vel da biblioteca TSDB, n√£o h√° cliente ou servidor. </p><br><p>  Essa biblioteca √© otimizada para trabalhar com dados de s√©ries temporais.  Por exemplo, o TSDB possui codifica√ß√£o delta, que permite armazenar n√£o os n√∫meros em si, mas as altera√ß√µes entre esses n√∫meros.  Isso permite que voc√™ armazene 1 byte em vez de 16 bytes.  1 byte por hora e 1 byte por valor.  Ou seja, voc√™ armazena em m√©dia 1 ou 2 bytes precisamente devido a essa boa compacta√ß√£o. </p><br><p>  O TSDB √© otimizado para modelos pull.  Os dados s√£o adicionados apenas l√°.  Prometheus n√£o pode gravar dados hist√≥ricos.  N√£o h√° API para isso.  O delta m√°ximo √© de aproximadamente 5 minutos.  Se os dados forem mais antigos, eles n√£o ser√£o aceitos. </p><br><p>  N√£o h√° downsampling <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">embutido tsdb # 313</a> no TSDB.  Existe uma quest√£o em aberto na qual houve uma discuss√£o sobre o fato de que, em geral, existem projetos que prometem algo e que h√° uma redu√ß√£o de amostragem l√°.  At√© agora, a solu√ß√£o √© que o TSDB n√£o adicionar√° downsampling. </p><br><p><img src="https://habrastorage.org/webt/5q/pb/vt/5qpbvtptau3gz7ygcxb9cl3nmzg.png"></p><br><p>  Como obter√≠amos dados do TSDB?  TSDB √© um banco de dados em disco.  Voc√™ pode trabalhar com ele se estiver escrevendo um programa Go.  Mas se voc√™ n√£o escrever um programa no Go, haver√° uma API JSON que permite fazer consultas.  Se voc√™ j√° usou o Prometheus e pelo menos uma vez criou um gr√°fico, conhece a API de consulta padr√£o, na qual existe um par√¢metro de consulta no qual √© poss√≠vel executar qualquer consulta do PromQL e, opcionalmente, o tempo.  Se n√£o houver tempo, a hora atual √© tomada. </p><br><p>  Uma consulta espec√≠fica √© destacada no slide, que voc√™ raramente v√™ na vida real.  Isso √© um truque.  Isso nos permite extrair todas as m√©tricas que o Prometheus possui.  Como isso funciona?  No n√≠vel do PromQL, diz-se que √© imposs√≠vel escrever uma express√£o que capte seriados o tempo todo.  Isso est√° escrito diretamente nas regras.  Outra regra diz que voc√™ n√£o pode fazer um comparador em que todos os valores estejam vazios.  Se voc√™ simplesmente escrever chaves, isso n√£o funcionar√°.  Se voc√™ escrever o nome n√£o for igual a nada (n√£o um valor vazio), ele n√£o funcionar√°.  Mas este √© um truque real que permite que voc√™ fa√ßa isso.  No entanto, isso nem √© particularmente documentado.  Existem coment√°rios no pr√≥prio c√≥digo de que isso funciona. </p><br><p>  A segunda consulta √© query_range, que faz a mesma coisa, mas retorna os dados em um intervalo e com alguma etapa.  Essencialmente, ele faz uma consulta v√°rias vezes para cada etapa, do come√ßo ao fim.  Esta √© a API usada para desenhar gr√°ficos.  A primeira API usa para obter valores instant√¢neos. </p><br><p><img src="https://habrastorage.org/webt/nc/cm/cs/nccmcsyofzxubtca8yoyas7p6ag.png"></p><br><p>  Temos uma API para recuperar metadados.  Se queremos obter todos os nomes das m√©tricas, fazemos uma consulta como esta, em que match √© uma matriz de m√©tricas.  Pode haver v√°rios argumentos, mas, neste caso, passamos a mesma correspond√™ncia, que tudo retorna para n√≥s. </p><br><p>  A segunda meta API, que retorna o valor de todos os r√≥tulos.  Se queremos ver uma lista de todos os trabalhos, em vez de label_name, escrevemos job e obtemos essa lista.  Essas APIs retornam JSON para n√≥s. </p><br><p><img src="https://habrastorage.org/webt/qe/ku/j4/qekuj4lgm4zp-x07kvhoorux_w0.png"></p><br><p>  H√° outra API que retorna todas as m√©tricas do pr√≥prio Prometheus em um formato nativo dos exportadores.  O formato √© chamado expfmt.  No pr√≥prio Prometheus, h√° uma API de federa√ß√£o que permite fazer essa solicita√ß√£o.  Para que √© isso?  A op√ß√£o mais f√°cil, se voc√™ tiver algum c√≥digo que j√° funcione com expfmt, n√£o ser√° necess√°rio trein√°-lo novamente para trabalhar com alguma API JSON customizada.  Esse formato √© muito mais f√°cil de transmitir, porque se voc√™ tiver o JSON em algum lugar no n√≠vel superior do objeto, geralmente precisar√° analisar esse objeto como um todo.  Aqui pode ser feito linha por linha. </p><br><p>  O mais importante √© que √© uma API separada.  Funciona como uma exporta√ß√£o real.  Voc√™ pode pegar o outro Prometeu para raspar.  Este √© um trabalho regular com os par√¢metros usuais.  Voc√™ precisa passar o par√¢metro - URL da consulta.  Se voc√™ fizer uma solicita√ß√£o de ondula√ß√£o, obter√° o mesmo aqui.  Obtemos todas as m√©tricas para o valor de tempo atual.  A √∫nica ressalva: voc√™ deve definir honor_labels para que o Prometheus, que eliminar√° outro Prometheus por meio dessa API, n√£o atrapalhe o valor do trabalho e do r√≥tulo da inst√¢ncia.  Usando esta API de federa√ß√£o, voc√™ pode carregar todos os dados de um Prometheus para outro. </p><br><p><img src="https://habrastorage.org/webt/64/lc/yy/64lcyynloe47gbkjlelzyddss60.png"></p><br><p>  Como isso pode ser usado? </p><br><p>  Primeiro, a coisa mais importante a dizer √© que voc√™ n√£o precisa fazer isso.  O TSDB √© otimizado para diferentes modos de opera√ß√£o.  Se voc√™ tem um Prometheus que coleta muitos dados, ele realiza muitas E / S.  Se voc√™ usar a API de federa√ß√£o, a quantidade de sa√≠da de entrada aumentar√° cerca de 2 vezes.  Existem nuances.  Dependendo da frequ√™ncia com que voc√™ raspa no federado e da frequ√™ncia com que raspa os destinos.  Se o tempo n√£o foi alterado, isso realmente dobra a carga.  Portanto, se voc√™ quiser escalar seu Prometheus e ativar a federa√ß√£o, voc√™ o matar√°.  A carga dobrar√°. </p><br><p>  Segundo momento.  Voc√™ estar√° pulando dados.  Voc√™ ter√° um conflito de dados.  Porque  Essa API, como quase qualquer API do Prometheus, n√£o √© at√¥mica.  Se novos dados chegarem, uma nova raspagem ser√° finalizada no momento em que sua solicita√ß√£o de federa√ß√£o ainda estiver em andamento, voc√™ poder√° obter um dado para uma s√©rie temporal e novos para outro.  Se √© uma s√©rie temporal n√£o relacionada, geralmente n√£o √© assustador.  Mas se voc√™ tiver um resumo ou um histograma, que no n√≠vel expfmt √© representado por v√°rias m√©tricas b√°sicas, haver√° inconsist√™ncia entre elas. </p><br><p><img src="https://habrastorage.org/webt/_0/5h/lk/_05hlkpn57b8klhjwborhup4bds.png"></p><br><p>  Como podemos resolver esse problema at√¥mico?  O Prometheus possui regras de grava√ß√£o que permitem criar uma nova s√©rie temporal a partir de uma s√©rie temporal existente.  Isso pode ser feito com menos frequ√™ncia.  Essa √© uma maneira de reduzir a amostragem.  Por exemplo, descarte o destino a cada segundo, mas queremos fazer a agrega√ß√£o node_cpu em um minuto.  O agrupamento no Prometheus 2.0 permite que voc√™ fa√ßa essas agrega√ß√µes sequencialmente.  As regras que est√£o no mesmo grupo s√£o executadas estritamente em sequ√™ncia.  Neste ponto, n√£o h√° problema de atomicidade, n√£o h√° problema de que os dados ser√£o alterados no processo.  Mas isso n√£o resolve o problema do fato de que s√£o admiss√≠veis alguns outros dados que est√£o logicamente conectados com isso, mas n√£o est√£o conectados do ponto de vista do modelo de dados.  Ainda n√£o existe atomicidade pura.  H√° uma quest√£o em aberto sobre esse t√≥pico.  Voc√™ pode fazer instant√¢neos.  Voc√™ pode fazer uma consulta PromQL ao banco de dados TSDB e eliminar todas as amostras com menos de algum valor do tempo iniciado na avalia√ß√£o a partir dos valores obtidos.  Essa seria a maneira mais f√°cil, mas at√© agora n√£o foi feita. </p><br><p>  √â importante entender que as regras de grava√ß√£o precisam ser feitas no Prometheus inferior, e n√£o no que a federa√ß√£o faz.  Caso contr√°rio, voc√™ pular√° picos, seu monitoramento n√£o funcionar√° corretamente. </p><br><p><img src="https://habrastorage.org/webt/kp/jf/hd/kpjfhdz8boamndunerhcx2vgebq.png"></p><br><p>  Como podemos usar essa combina√ß√£o dessas coisas para reduzir a amostragem e o armazenamento a longo prazo. </p><br><p>  O primeiro.  Acabamos de configurar a federa√ß√£o e baixar todos os dados desse Prometheus.  Essa estranha express√£o regular √© como um zoidberg - na verdade, √© apenas dois pontos.  Um asterisco √† esquerda e √† direita do c√≥lon.  Usamos o nome padr√£o para regras de grava√ß√£o, o que adiciona dois pontos ao meio.  Ao dividir o nome original, haver√° um n√≠vel de agrega√ß√£o √† esquerda e uma fun√ß√£o √† direita.  Uma m√©trica normal de dois pontos n√£o.  Se houver dois pontos, isso √© um sinal de que √© agrega√ß√£o.  Depois disso, usamos esse nome de m√©trica em nosso gr√°fico.  Se quisermos que nossa programa√ß√£o, nosso painel em grafana funcione com o Prometheus principal e com os mais altos, podemos usar a express√£o <strong>ou</strong> .  Adotamos uma m√©trica ou outra, dependendo de qual seja.  Podemos trapacear e usar a remarca√ß√£o para renomear a nova m√©trica para o nome antigo.  Esta √© uma abordagem bastante perigosa.  Voc√™ pode soletrar anexos regulares incorretamente e ter√° um conflito de s√©ries temporais.  Prometeu gravar√° muitos avisos no log.  Voc√™ ver√° isso, mas encontrar o motivo pode ser bastante dif√≠cil.  Mas, se feito com cuidado, por exemplo, gerando essas express√µes regulares programaticamente, isso funcionar√°.  Em seguida, voc√™ ter√° um painel regular em que apenas o node_cpu √© usado.  Dependendo de qual Prometheus √© usado, voc√™ receber√° dados brutos ou dados agregados. </p><br><p><img src="https://habrastorage.org/webt/hd/ft/1x/hdft1xwgw_61j7tab_3feehhsgy.png"></p><br><p>  Como eu disse, as regras de grava√ß√£o podem ser geradas de maneira bastante simples.  Acabamos de receber todas as s√©ries temporais atrav√©s da API que eu j√° mostrei.  Criamos regras e essas regras devem usar as fun√ß√µes e operadores corretos.  N√£o h√° necessidade de usar a taxa com medidor l√°.  Isso n√£o funcionar√° corretamente.  Deve ser usado apenas com contagem.  No n√≠vel em que voc√™ trabalha, voc√™ pode n√£o ter informa√ß√µes sobre tipos de dados.  Por exemplo, se voc√™ usar expfmt.  H√° informa√ß√µes sobre os tipos.  Se a API JSON n√£o estiver l√°.  Como resultado, a express√£o que voc√™ gera automaticamente pode n√£o ter nenhum significado f√≠sico.  Portanto, voc√™ pode usar uma lista branca ou uma lista negra l√°.  Dependendo disso, gere a regra que voc√™ precisa ou jogue fora as regras que n√£o fazem sentido.  Existe uma ferramenta promtool que permite verificar se as regras que voc√™ gerou, a configura√ß√£o que voc√™ gerou, faz sentido.  Tem a sintaxe correta. </p><br><p><img src="https://habrastorage.org/webt/om/wc/fv/omwcfvvh7mc8bky3zkble7vimqm.png"></p><br><p>  Se temos Grafana e existem v√°rios Prometheus, precisamos saber para qual Prometheus enviar a solicita√ß√£o.  Como far√≠amos isso? </p><br><p>  Uma maneira √© colocar um proxy especial que analise o hor√°rio da solicita√ß√£o e, dependendo disso, selecione Prometheus.  As consultas t√™m um hor√°rio de in√≠cio e um hor√°rio de t√©rmino.  Dependendo disso, voc√™ pode fazer o roteamento com as m√£os.  Algu√©m poderia escrever algum tipo de programa que fa√ßa isso.  Na pr√°tica, isso √© feito pelo nginx com o m√≥dulo lua ou um pequeno programa. </p><br><p><img src="https://habrastorage.org/webt/ff/ve/vz/ffvevzimxzpnrjrqirbkuqssiqm.png"></p><br><p>  N√≥s realmente precisamos de uma API?  Podemos trabalhar diretamente com o TSDB?  H√° uma nuance.  Primeiro, se tentarmos usar o TSDB, que agora √© usado pelo Prometheus, n√£o conseguiremos fazer isso.  H√° um arquivo de bloqueio especial que impede isso.  Se escrevermos um c√≥digo que ignorar√° isso e tentarmos ler ou gravar dados, estamos garantidos para danific√°-los.  Al√©m disso, mesmo lendo.  O que pode ser feito?  Podemos ler dados atrav√©s da API e criar TSDB lado a lado.  Em seguida, pare o Prometheus e substitua-o pelo TSDB.  Mas, ao mesmo tempo, podemos prejudicar o desempenho se lermos todos os dados por meio da API.  Eu vou falar sobre isso um pouco mais tarde. </p><br><p>  A segunda op√ß√£o  Voc√™ pode copiar (fazer backup a quente) desses arquivos, ou seja, copiar como est√°.  Sim, eles ser√£o danificados.  Ao abrir, voc√™ receber√° um aviso de que os dados est√£o corrompidos.  Eles precisam ser consertados.  Voc√™ pode perder novos dados.  Mas isso n√£o importa para n√≥s.  Queremos reduzir a amostragem de dados antigos.  A redu√ß√£o da amostragem pode ser feita usando o PromQL.  Mas h√° uma nuance.  √â muito mais dif√≠cil retir√°-lo do Prometheus do que o TSDB.  Se voc√™ est√° um pouco familiarizado com o Go e o gerenciamento de depend√™ncias, o fornecedor PromQL √© uma grande dor.  Eu n√£o aconselharia voc√™.  Evite isso, se poss√≠vel. </p><br><p><img src="https://habrastorage.org/webt/2z/ii/fs/2ziifscme6pqm1ppf1n9ripipuq.png"></p><br><p>  Passamos para o armazenamento remoto.  Algu√©m j√° trabalhou com armazenamento remoto no Prometheus?  Algumas m√£os.  O armazenamento remoto √© uma API que existe h√° muito tempo.  Agora na vers√£o 2.2 Armazenamento Remoto - marcado como experimental.  Al√©m disso, sabe-se que a API de armazenamento remoto mudar√° definitivamente. </p><br><p>  O armazenamento remoto permite que voc√™ trabalhe apenas com dados brutos.  N√£o h√° PromQL na entrada ou na sa√≠da.  Quando voc√™ l√™, n√£o pode usar todo o poder do PromQL.  Essencialmente, ele bombeia todos os dados do armazenamento remoto que correspondem √† condi√ß√£o.  Al√©m disso, o PromQL j√° trabalha com eles.  Isso tem uma sobrecarga bastante grande.  Voc√™ precisa bombear muitos dados pela rede.  Portanto, no Prometheus 2.3, que ainda n√£o foi lan√ßado, mas j√° foi adiado, haver√° uma dica de leitura.  Falaremos sobre isso um pouco mais tarde. </p><br><p>  Ainda n√£o h√° API para metadados.  Voc√™ n√£o pode criar uma API que retorne todas as s√©ries temporais do Armazenamento Remoto.  Se voc√™ fizer uma solicita√ß√£o √† API do Prometheus, ela n√£o ser√° direcionada ao armazenamento remoto.  Ele retornar√° a s√©rie temporal, que est√° em seu banco de dados local.  Se seu banco de dados local estiver desativado, ele retornar√° 0. O que pode ser um pouco inesperado.  Agora, essa API usa o ProtoBuf e, definitivamente, ser√° alterada para gRPC no futuro.  Eles ainda n√£o o fizeram, porque o gRPC requer HTTP2.  E na pr√°tica eles tiveram problemas com ele. </p><br><p><img src="https://habrastorage.org/webt/lc/7v/ij/lc7vijvha-gtzs_oj74xszwk488.png"></p><br><p> A API de grava√ß√£o se parece com isso.  A solicita√ß√£o possui um conjunto de r√≥tulos.  O conjunto de r√≥tulos identifica exclusivamente as s√©ries temporais.  <code>__name__</code> √© realmente apenas um r√≥tulo com um nome especial.  E as amostras s√£o um conjunto de tempo e valores - int64 e float64.  Ao gravar, o pedido n√£o √© importante.  Sup√µe-se que o banco de dados que escreve isso sozinho far√° tudo certo.  Prometeu pode fazer alguma otimiza√ß√£o e n√£o classific√°-la novamente.  Assim, uma solicita√ß√£o de grava√ß√£o √© apenas algumas s√©ries temporais. </p><br><p><img src="https://habrastorage.org/webt/xd/qr/ud/xdqrudjh5lpomcepkdmkjcfegt0.png"></p><br><p>  A configura√ß√£o de grava√ß√£o possui uma configura√ß√£o bastante flex√≠vel.  Existem muitas op√ß√µes para configurar a simultaneidade de grava√ß√£o.  O que Prometheus chama de shards s√£o essencialmente solicita√ß√µes competitivas.  Voc√™ pode limitar o n√∫mero m√°ximo de amostras em uma solicita√ß√£o, o m√°ximo de solicita√ß√µes paralelas, tempo limite, como repetir, qual retorno.  Para muitos bancos de dados, 100 amostras de cada vez - isso pode ser muito pequeno.  Se voc√™ usa o ClickHouse, como n√≥s, √© claro que o valor precisa ser bastante aumentado.  Caso contr√°rio, ser√° muito ineficiente. </p><br><p><img src="https://habrastorage.org/webt/eb/gk/ew/ebgkewr7k-i2yho9mh7dbogcipm.png"></p><br><p>  A API de leitura remota se parece com isso.  √â apenas um intervalo de tempo do in√≠cio ao fim e um conjunto de partidas. </p><br><p><img src="https://habrastorage.org/webt/hv/kn/jo/hvknjowgf6h9pebjvvhbspe7jac.png"></p><br><p>  A correspond√™ncia √© essencialmente uma cole√ß√£o de pares de nome e valor - um tipo regular de r√≥tulo e condi√ß√£o.  Em compara√ß√£o, existem igualdades, desigualdades ou express√µes regulares.  Este √© o seletor de s√©ries temporais usual que voc√™ v√™ no PromQL.  N√£o h√° recursos aqui. </p><br><p><img src="https://habrastorage.org/webt/ri/hu/ap/rihuap_py_s_hrp0oywqnyx6yee.png"></p><br><p>  A resposta √© algumas s√©ries temporais que correspondem a essa consulta.  Aqui as amostras devem ser classificadas por tempo.  mais uma vez, isso ajuda Prometheus a economizar um pouco de CPU - n√£o √© necess√°rio classificar.  Mas sup√µe-se que seu banco de dados fa√ßa isso.  Na maioria dos casos, ser√° assim, porque, muito provavelmente, haver√° um √≠ndice no prazo. </p><br><p><img src="https://habrastorage.org/webt/zu/yd/fx/zuydfxti6mozpsz5v60f_i1laic.png"></p><br><p>  Prometheus 2.3 introduziu dica de leitura.  O que √© isso  Esta √© uma oportunidade de informar ao Prometheus qual fun√ß√£o interna que trabalha com a s√©rie temporal que est√° sendo solicitada ser√° aplicada.  Isso pode ser uma fun√ß√£o ou um operador de agrega√ß√£o.  Pode ser taxa.  Ou seja, √© chamado de func, mas na verdade pode ser uma soma, que, do ponto de vista do PromQL, na verdade n√£o √© uma fun√ß√£o.  Este √© o operador.  E um passo.  No exemplo anterior, houve uma taxa de 1 minuto.  Aqui a taxa √© uma fun√ß√£o e um minuto em milissegundos como uma etapa.  Essa dica pode ser ignorada pelo banco de dados remoto.  Ao mesmo tempo, n√£o h√° indica√ß√£o na resposta se foi ou n√£o ignorada. </p><br><p><img src="https://habrastorage.org/webt/6_/ms/9_/6_ms9_zh9txqwdafxjoenbdn8so.png"></p><br><p>  Qual √© a configura√ß√£o de leitura? </p><br><p>  Em primeiro lugar, existe essa configura√ß√£o required_matchers.  Isso permite que voc√™ envie uma solicita√ß√£o de armazenamento remoto que corresponda √† express√£o.  Para ler dados agregados do armazenamento remoto, voc√™ deve usar uma consulta que contenha dois pontos. </p><br><p>  Existe uma op√ß√£o que permite ler ou n√£o dados recentes do armazenamento remoto, que est√° no TSDB.  Geralmente, na configura√ß√£o padr√£o, h√° um pequeno TSDB local que √© gravado no disco local.  Ela armazena l√° por v√°rias horas ou v√°rios dias.  Os dados que voc√™ usa agora, que s√£o usados ‚Äã‚Äãpara alertas, que s√£o usados ‚Äã‚Äãpara criar o painel, s√£o somente leitura do TSDB local.  √â r√°pido, mas n√£o nos permite armazenar muitos dados. </p><br><p>  Dados hist√≥ricos antigos ser√£o lidos no Armazenamento Remoto.  Isso deixa claro como o armazenamento local e o armazenamento remoto se comunicam.  N√£o h√° desduplica√ß√£o. </p><br><p>  Essencialmente o que est√° acontecendo.  Os dados s√£o obtidos do armazenamento local, dados s√£o obtidos do armazenamento remoto se o read_recent estiver ativado.  Eles simplesmente se fundem.  Parece que isso n√£o √© um problema.  Se for assumido que n√£o reduzimos a amostra dos dados recentes, esses s√£o exatamente os mesmos dados, eles coincidem completamente com os dados locais, teremos o dobro de amostras, n√£o devemos afetar nenhuma fun√ß√£o.  Na verdade n√£o.  H√° uma fun√ß√£o irate () e um par para ela para medidor, que nos retorna a diferen√ßa entre os dois √∫ltimos valores.  Ela olha para o intervalo de tempo indicado, mas usa apenas os dois √∫ltimos valores.  Se os dois √∫ltimos valores tiverem o mesmo tempo, a diferen√ßa ser√° zero.  Isso √© um bug e √© quase imposs√≠vel encontr√°-lo.  Foi reparado h√° apenas quatro dias.  Este √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ingresso para</a> qualquer pessoa interessada. </p><br><p><img src="https://habrastorage.org/webt/-q/3w/dw/-q3wdw3czygpvkk009lrnhumska.png"></p><br><p>  Curiosamente, a leitura remota foi implementada pelo Prometheus desde a vers√£o 1.8.  √â dessa maneira que voc√™ pode ler os dados do Prometheus antigo ao migrar para a vers√£o 2.x.  A maneira oficial aconselha conect√°-lo como leitura remota.  Os dados ser√£o subtra√≠dos conforme necess√°rio. </p><br><p>  A leitura remota pode ser usada para fazer o roteamento de consultas sem um proxy.  Em um dos slides anteriores, mostrei que, dependendo do tempo, podemos fazer o roteamento em um Prometheus ou outro.  Da mesma maneira, podemos evitar isso.  Basta conectar o Prometheus abaixo da leitura remota - e os dados ser√£o lidos a partir da√≠.  Mas h√° uma altera√ß√£o no fato de que, √© claro, muitos dados ser√£o bombeados.  Especialmente se voc√™ n√£o estiver usando a dica de consulta. </p><br><p><img src="https://habrastorage.org/webt/gq/op/fz/gqopfzpgoe3kidpqufnedn5gfrk.png"></p><br><p>  Porqu√™ clickhouse? </p><br><ul><li><p>  Para nossa solu√ß√£o de pesquisa, escolhemos o ClickHouse, porque j√° o analisamos h√° muito tempo.  Temos pessoas que est√£o constantemente envolvidas no desempenho do banco de dados, verificando constantemente novos bancos de dados.  Nossa empresa est√° envolvida em bancos de dados de c√≥digo aberto. </p><br></li><li><p>  N√≥s realmente gostamos do seu desempenho bruto.  Seu poder em termos de CPU, tempo e assim por diante, √© muito bom.  A maioria desses sistemas fala sobre escalabilidade infinita, mas fala pouco sobre efici√™ncia para um √∫nico servidor.  Muitos de nossos clientes armazenam m√©tricas em um par de servidores. </p><br></li><li><p>  Replica√ß√£o interna, sharding. </p><br></li><li><p>  O GraphiteMergeTree √© um mecanismo especial para armazenar dados de grafite.  No come√ßo, ele estava muito interessado em n√≥s. </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/ot/nk/sn/otnksno5uhhcgn7j5-fp5xnxneq.png"></p><br><p>  O mecanismo √© destinado ao rollup (afinamento e agrega√ß√£o / m√©dia) dos dados de grafite. </p><br><p>  O Graphite armazena os dados completos no ClickHouse, e pode receb√™-los, e afirma ainda que, com o desbaste GraphiteMergeTree √© usado, o MergeTree √© usado sem desbaste.  A sensa√ß√£o √© de que os dados est√£o sempre cheios, eles n√£o s√£o substitu√≠dos, √© apenas uma otimiza√ß√£o da leitura.  Mas no geral n√£o √© ruim.  Quando fazemos a leitura, n√£o coletamos os dados, eles s√£o agregados automaticamente, obtemos poucos dados - isso √© bom.  A desvantagem para n√≥s √© que todos os dados s√£o armazenados. </p><br><p>  Eu estava me preparando no come√ßo do m√™s para o relat√≥rio.  Algu√©m entra em um bate-papo por telegrama e pergunta: "Dados menores do GraphiteMergeTree"?  Eu j√° escrevo n√£o.  A documenta√ß√£o diz que n√£o.  Mas a outra pessoa no bate-papo responde "sim, voc√™ precisa ligar para otimizar".  Corra, verifique - sim a verdade.  A documenta√ß√£o √© essencialmente um bug.  Ent√£o eu li o c√≥digo fonte, verificado, verifica-se l√° √© otimizar, otimizar final.  O Optimize Optimize foi originalmente criado especificamente para o GraphiteMergeTree.  Na verdade, ele reduz a amostragem.  Mas deve ser chamado com as m√£os. </p><br><p>  GraphiteMergeTree tem um modelo de dados diferente.  Ele n√£o tem r√≥tulos.  Escrever tudo de forma eficaz em nome das m√©tricas n√£o funciona muito bem. </p><br><p>  As m√©tricas de nome s√£o armazenadas em uma tabela.  O nome das m√©tricas tem um comprimento diferente.  Isso leva ao fato de que, se fizermos uma pesquisa de √≠ndice pelo nome da m√©trica, porque o comprimento √© diferente, esse √≠ndice n√£o ser√° t√£o eficaz como se esse √≠ndice tivesse um valor de comprimento fixo.  Porque voc√™ precisa fazer uma pesquisa de arquivo.  √â imposs√≠vel especificar exatamente onde pousar para fazer uma pesquisa bin√°ria. </p><br><p><img src="https://habrastorage.org/webt/c3/v4/zf/c3v4zfriducmhoahjwujmp1zdga.png"></p><br><p>  Portanto, eles fizeram seu pr√≥prio esquema.  O slide mostra como armazenamos s√©ries temporais no banco de dados.  A data que o ClickHouse precisa √© de uma impress√£o digital.  Se voc√™ consultou as fontes do Prometheus ou do TSDB, sabe que a impress√£o digital √© essencialmente uma soma de verifica√ß√£o r√°pida e curta da s√©rie temporal do nome completo.  Impress√£o digital √© uma combina√ß√£o de todas as etiquetas, chaves e valores.  Um nome √© um r√≥tulo comum.  Usamos o mesmo algoritmo para compatibilidade.  Debitar algo pode ser conveniente.  A impress√£o digital √© a mesma e pode ser verificada no TSDB e em nosso armazenamento que s√£o iguais.  Os r√≥tulos s√£o armazenados em um JSON especial, que permite ao ClickHouse trabalhar com ele com suas fun√ß√µes padr√£o.  Este √© um JSON compacto, sem espa√ßos, com nomes levemente simplificados.  Esta tabela n√£o √© usada durante a opera√ß√£o.  Ele √© sempre armazenado na mem√≥ria da nossa solu√ß√£o real, chamada PromHouse.  √â usado apenas quando iniciamos o servidor para descobrir quais s√£o as s√©ries temporais.  Ela √© subtra√≠da.  √Ä medida que novas s√©ries temporais chegam, as gravamos l√°.  Todas as v√°rias inst√¢ncias do PromHouse podem ler a mesma tabela.  ReplacingMergeTree nos diz que essas s√©ries temporais - existem v√°rias inst√¢ncias diferentes - escrevem as mesmas s√©ries temporais.  Eles v√£o lutar - e n√£o haver√° nenhum problema aqui. </p><br><p><img src="https://habrastorage.org/webt/ms/lg/1t/mslg1tnbc97nrlauwcr9ekj-p3k.png"></p><br><p>  Armazenamos amostras em uma tabela separada com muita efici√™ncia.  Com um valor de comprimento fixo, essa impress√£o digital √© a mesma, tempo e valor.  Temos 24 bytes por amostra.  Tem um comprimento estritamente fixo.  Cada coluna √© armazenada separadamente.  Uma pesquisa de impress√µes digitais √© eficaz porque sabemos que o tamanho √© fixo.  N√£o existe um problema como o GraphitmergeTree quando √© uma string.  Usamos particionamento personalizado.  √çndice prim√°rio de impress√µes digitais e por tempo. </p><br><p>  24 bytes √© uma vers√£o simplificada.  De fato, comprime bem.  De fato, usa menos espa√ßo.  Em nossos testes mais recentes, a taxa de compacta√ß√£o √© de aproximadamente 1 a 42. </p><br><p><img src="https://habrastorage.org/webt/wu/5y/24/wu5y2499vjvrcm37ct1gudfrpym.png"></p><br><p>  Como podemos reduzir a amostragem manual se tivermos o GraphiteMergeTree, mas n√£o o mesmo que gostar√≠amos.  De fato, podemos faz√™-lo manualmente.  Como fragmenta√ß√£o feita anteriormente, particionamento, quando n√£o havia nada embutido.  Fazemos uma nova mesa com as m√£os.  Quando uma amostra de tempo chega at√© n√≥s, determinamos em qual tabela estamos escrevendo. </p><br><p>  Selecionamos o hor√°rio da consulta na qual tabela ler.  Se a leitura ocorrer na borda, lemos v√°rias tabelas.  Em seguida, mantemos esses dados.  Pode-se usar o view para isso.  Por exemplo, fa√ßa uma visualiza√ß√£o de v√°rias tabelas, o que permite que ela seja lida em uma √∫nica consulta.  Mas h√° um erro no ClickHouse: o predicado da visualiza√ß√£o n√£o √© substitu√≠do nas consultas.  Portanto, se voc√™ fizer uma solicita√ß√£o em exibi√ß√£o, ela ser√° exibida em todas as tabelas.  Vista que n√£o podemos usar. </p><br><p>  Como fazemos downsampling?  Criamos uma tabela tempor√°ria.  Copie a inser√ß√£o nos dados selecionados usando as fun√ß√µes corretas. </p><br><p>  Renomeamos o que √© at√¥mico sob o bloqueio global.  Estamos renomeando a tabela existente para a antiga.  Novo no existente.  Largamos a mesa velha.  J√° temos dados de 148 dias para redu√ß√£o da amostra.  Qual √© o problema aqui?  Inserir em parece bonito.  De fato, precisamos aplicar as fun√ß√µes corretas, a agrega√ß√£o correta a ser executada.  Na pr√°tica, isso n√£o pode ser feito com uma grande solicita√ß√£o.  Mesmo alguns pedidos grandes n√£o podem ser feitos.  Isso tem que ser feito a partir do c√≥digo.  O c√≥digo envia um grande n√∫mero de solicita√ß√µes pequenas.  Tentamos o nosso melhor para fazer isso com grandes solicita√ß√µes, mas isso n√£o √© muito eficaz.  A redu√ß√£o da amostragem de dados de um dia at√© o momento leva menos de um dia.  Dependendo da quantidade de dados, pode demorar muito tempo. </p><br><p><img src="https://habrastorage.org/webt/7c/94/h4/7c94h4t2bbvk5x-3acoftonomxa.png"></p><br><p>  O ClickHouse ter√° atualiza√ß√£o / exclus√£o.  Excluir j√° recebeu a primeira vers√£o.  Se a atualiza√ß√£o / exclus√£o funcionar, nosso esquema de dados de amostragem reduzida poder√° ser simplificado. </p><br><p>  Em segundo lugar, o ClickHouse tem a tarefa de fazer a compacta√ß√£o personalizada (delta, delta para delta).  √â isso que o TSDB faz.  Isso √© adequado para dados de s√©ries temporais.  Isso √© especialmente √∫til se pudermos escolher o tipo de compacta√ß√£o, dependendo dos tipos de dados.  Por exemplo, o contador, que est√° crescendo apenas - para isso, a compacta√ß√£o delta-delta √© adequada.  Um medidor que flutua em torno da magnitude, para que o delta funcione bem. </p><br><p><img src="https://habrastorage.org/webt/od/mv/hx/odmvhxcnnite5wum9k9gwfifbec.png"></p><br><p>  Existem outros armazenamentos que funcionam.  Existe o InfluxDB que funciona imediatamente.  √â costume repreend√™-lo por velocidade, mas o que funciona imediatamente e voc√™ n√£o precisa fazer nada √© bom. </p><br><p>  Existem OpenTSDB e Graphite, que s√£o somente grava√ß√£o.  O adaptador padr√£o do Prometheus realmente n√£o funciona. </p><br><p>  Existe um CrateDB.  Existe um TimescaleDB que bifurca o PostgreSQL para bancos de dados de s√©ries temporais.  Dizem que funciona bem, mas n√≥s mesmos ainda n√£o tentamos. </p><br><p>  Existe o Cortex, tamb√©m conhecido como projeto Frankenstein.  Isso o descreve muito bem.  Este √© o pessoal que est√° tentando tomar uma decis√£o com base na federa√ß√£o de Prometheus.  Eles armazenam dados no S3. </p><br><p>  H√° Thanos. </p><br><ul><li>  Ele tem uma arquitetura muito interessante.  H√° o Prometheus que usa o TSDB local.  Um cluster √© criado entre eles.  Ao lado de cada Prometheus, h√° um carro lateral especial, que aceita solicita√ß√µes via API de leitura e grava√ß√£o remota.  Ele redireciona esses pedidos para o Prometheus.  O Prometheus pode usar suas APIs de leitura e grava√ß√£o remotas.  Todos os carros laterais s√£o interconectados e, entre mestres de API personalizados via gRPC, a replica√ß√£o est√° dispon√≠vel, h√° re-shading. </li><li>  Arquitetura sofisticada. </li><li>  Est√° bem √∫mido.  Alguns meses atr√°s, ele estava se desfazendo de meio chute quando come√ßou. </li></ul><br><p><img src="https://habrastorage.org/webt/a9/rc/zm/a9rczmkse4viit4vvr4hgqfcuts.png"></p><br><p>  O uso do modelo pull n√£o grava muitos dados.  Voc√™ precisa esperar um ano inteiro para preencher os dados anuais.  Estamos tentando escrev√™-los de alguma forma l√°. </p><br><p>  N√£o h√° grava√ß√£o remota no Prometheus; portanto, a grava√ß√£o de muitos dados no TSDB local n√£o funcionar√°. </p><br><p>  O segundo problema.  Se gerarmos dados para testes de estresse, eles geralmente tremem bem.  Por exemplo, se pegarmos os dados existentes e gerarmos 100 inst√¢ncias, e esses forem os mesmos, o coeficiente de compacta√ß√£o ser√° t√£o bonito que, na realidade, eles n√£o acontecem. </p><br><p><img src="https://habrastorage.org/webt/fy/mc/uk/fymcukkdoo3hi78gkw1eb2ipvsk.png"></p><br><p>  Escrevemos um exportador falso que se parece com um exportador regular que Prometheus pode manter: </p><br><ul><li>  Quando a sucata chega, ele vai a algum exportador a montante.  Obt√©m dados dele. </li><li>  Gera muitas inst√¢ncias.  Digamos que 1 seja um scrapie e recebemos 100 na sa√≠da. </li><li>  Altera ligeiramente os dados: mais menos 10% para o contador e o medidor. </li><li>  Ele n√£o altera os valores simples 0 ou 1. Porque, se houver uma m√©trica UP que responda, ela mostra se o servi√ßo est√° em execu√ß√£o: sim - 1 ou n√£o - 0. E n√£o est√° muito claro o que 098 UP significa. </li><li>  N√£o mudamos n√∫meros inteiros para reais e vice-versa. </li><li>  Apenas fornece dados no formato expfmt usual. </li></ul><br><p><img src="https://habrastorage.org/webt/c0/ja/hc/c0jahc5ryn-oxhwxnke_vaj1mia.png"></p><br><p>  Uma ferramenta de promload que carrega dados.  Lendo dados: </p><br><ul><li>  Pode ler arquivos em seu pr√≥prio formato </li><li>  Talvez a partir da leitura remota </li><li>  Pode ler de algum exportador </li></ul><br><p>  Grava em diferentes formatos.  Incluindo em / dev / null, se quisermos testar exatamente como a leitura funciona rapidamente. </p><br><p>  Agora √© uma ferramenta de teste de carga, n√£o apenas para o PromHouse, mas tamb√©m para qualquer solu√ß√£o que use leitura remota ou Prometheus. </p><br><p><img src="https://habrastorage.org/webt/qr/xa/-2/qrxa-2wg58troaskuqhqowwicq4.png"></p><br><p>  Queremos adicionar o cache de leitura, porque em nossos testes o gargalo costumava ser o exportador falso, que gerava dados por um longo tempo.  N√≥s poder√≠amos armazen√°-los em cache.  Que eles sejam irrealisticamente bons.  Mas n√£o vamos desacelerar.  N√£o tivemos que esperar dias pelo teste de estresse. </p><br><p>  Algum tipo de filtragem em tempo real, algum tipo de modifica√ß√£o em tempo real. </p><br><p>  Suporte nativo para TSDB.  Para trabalhar com o banco de dados em disco, e n√£o atrav√©s da API. </p><br><p>  Concentre-se na precis√£o da migra√ß√£o.  Uma vez eu pmmdemo.percona.com colocar: conectado, recebeu todas as m√©tricas.  Se voc√™ fizer isso de uma maneira nativa, o Prometheus abrir√° o TSDB, aumentar√° todas as s√©ries temporais do disco, aumentar√° √≠ndices e depois rastrear√° para arquivos de partes, e perceber√° que eles realmente existem.  Neste ponto, tudo pode simplesmente se deitar. </p><br><p>  A abordagem ing√™nua √© levar toda a s√©rie temporal e ler os dados antigos para os novos.  Nesse momento ele se deitar√°.  Voc√™ precisa fazer o oposto.  Primeiro, voc√™ precisa obter a lista de s√©ries temporais com algumas consultas com express√µes regulares.  Por exemplo, uma s√©rie temporal que come√ßa em A. Em seguida, me d√™ uma s√©rie temporal que come√ßa em B. Em seguida, carregue-as exatamente por m√©tricas, n√£o por tempo.  Isso √© il√≥gico, mas √© assim que funciona.  Esta √© uma nuance se voc√™ fizer algo assim.  Se voc√™ perceber que o OOM Killer aconteceu l√°, saber√° que √© por sua causa. </p><br><p><img src="https://habrastorage.org/webt/mz/z9/kh/mzz9khnykox-3r2wlp_lpgphil4.png"></p><br><p>  Os resultados do teste de carga, n√£o haver√° gr√°ficos.  O teste de carga leva muito tempo e, infelizmente, devido a um erro de configura√ß√£o, tudo deu errado.  Portanto, os resultados n√£o deram certo. </p><br><p>  Escreveremos no blog da Percona quando fizermos o teste de carregamento. </p><br><p>  Eu posso dizer os resultados sem gr√°ficos.  A grava√ß√£o foi linear.  A leitura saltou e n√£o foi muito r√°pida.  Ler os dados atuais n√£o √© muito importante para n√≥s.  Eles podem ser acelerados atrav√©s de dicas de leitura.  Voc√™ pode ativar o read_recent para melhorar a leitura.  E para dados antigos, isso funciona bem. </p><br><p><img src="https://habrastorage.org/webt/b6/7f/4w/b67f4wmgkuzi6zyqnitxlwuv2t8.png"></p><br><p>  As pessoas querem armazenamento a longo prazo.  Existe essa demanda.  Conversamos sobre a PromHouse na PromCon.  L√° estava um t√≥pico muito quente.  Thanos est√° se desenvolvendo ativamente. </p><br><p>  J√° √© poss√≠vel agora.  Existe uma solu√ß√£o para isso.  Existe uma API.  Existem algumas integra√ß√µes.  Mas tudo isso precisa ser finalizado com um arquivo.  N√£o h√° solu√ß√µes prontas para produ√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/ms/qk/ec/msqkechijgscjucb7sx8knkzwx0.png"></p><br><p>  Links para onde procurar.  O primeiro link √© o reposit√≥rio PromHouse.  O segundo link √© para onde ele provavelmente se mover√°.  Agora em um reposit√≥rio h√° v√°rias coisas diferentes?  n√£o muito estreitamente relacionado.  Portanto, voc√™ precisar√° transferi-los. </p><br><p>  Nosso blog conter√° informa√ß√µes sobre desempenho e algumas novidades. </p><br><p>  Perguntas: </p><br><p>  Pergunta: Voc√™ checou os rumores sobre o InfluxDB? </p><br><p>  Resposta: Ele n√£o era muito bom.  Ele ficou muito melhor.  Todas essas hist√≥rias sobre o fato de o InfluxDB ser lento e desmoronar - s√£o sobre a vers√£o antiga.  A vers√£o atual √© est√°vel.  Eu n√£o diria?  que funciona r√°pido.  Mas funciona de forma est√°vel.  Profissionais do InfluxDB na minha opini√£o: </p><br><ul><li>  Primeiro, n√£o h√° necessidade de fazer algo pr√≥ximo, porque o InfluxDB funciona imediatamente. </li><li>  Em segundo lugar, no ClickHouse, como em outras solu√ß√µes baseadas em banco de dados, mas n√£o no TSDB, voc√™ pode usar uma linguagem de consulta mais familiar para voc√™.  A linguagem de consulta do InfluxDB √© semelhante ao SQL.  Voc√™ pode fazer an√°lises, o que √© dif√≠cil de fazer no PromQL.  Se voc√™ usar o TimeScaleDB - h√° SQL real. </li></ul><br><p>  Pergunta: O mecanismo GraphiteMergeTree apenas para grava√ß√£o funciona?  Se quisermos mostrar gr√°ficos, o Grafana precisa ser configurado no Graphite para mostrar armazenamento a longo prazo? </p><br><p>  Resposta: Sim.  A integra√ß√£o que est√° no pr√≥prio Prometheus funciona apenas para grava√ß√£o.  Ele escreve apenas dados.  Ent√£o, da Grafana, voc√™ vai para a Grafite. </p><br><p>  Pergunta: E ele perde r√≥tulos quando escreve? </p><br><p>  Resposta: H√° uma configura√ß√£o que diz o que fazer com eles, como inseri-los, onde inseri-los. </p><br><p>  Informa√ß√µes da plat√©ia: Avito disse que est√° escrevendo sua solu√ß√£o para grava√ß√µes de Prometheus a Graphite. </p><br><p>  Pergunta: houve uma conclus√£o de que, com a grava√ß√£o, tudo est√° bem em um servidor de armazenamento de longo prazo. </p><br><p><img src="https://habrastorage.org/webt/mz/z9/kh/mzz9khnykox-3r2wlp_lpgphil4.png">     (5-  15-).   raid 6 sata      ? </p><br><p> :  PMM      ‚Äî  .   downsampling    c 14   1 .  ,       .          .    .     . </p><br><p> :   IOPS  ? </p><br><p> :     . </p><br><p> :      </p><br><p> :        .  ,        .  , ,  . </p><br><p> :     InfluxDB,        InfluxDB? </p><br><p> :    read_recent.    ,      remote storage.    InfluxDB .    .  read_recent ,   . </p><br><p> : ,     Prometheus.     InfluxDB. Grafana   Prometheus. Prometheus   PromQL     ,    InfluxDB? </p><br><p> : . </p><br><p> : Prometheus     InfluxDB      Grafana? </p><br><p> : .    Prometheus  2.2        ,    . </p><br><p> PS       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">valyala</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">gecube</a> <br>   ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441136/">https://habr.com/ru/post/pt441136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441126/index.html">Falsos positivos no PVS-Studio: qu√£o profunda √© a toca do coelho</a></li>
<li><a href="../pt441128/index.html">A escolha certa: um estudo pr√°tico das habilidades cognitivas dos macacos antrop√≥ides</a></li>
<li><a href="../pt441130/index.html">Desempenho equilibrado do site. Parte 1: Estrat√©gia</a></li>
<li><a href="../pt441132/index.html">Para que Roskomnadzor n√£o venha de repente</a></li>
<li><a href="../pt441134/index.html">Emo√ß√µes, trabalho independente</a></li>
<li><a href="../pt441138/index.html">Solu√ß√µes de bate-papo em tempo real versus plataformas de bate-papo - fa√ßa sua escolha</a></li>
<li><a href="../pt441140/index.html">Desenvolvimento WebAssembly: rake real e exemplos</a></li>
<li><a href="../pt441142/index.html">12 pontos de crescimento de convers√µes ou conte√∫do que realmente vende</a></li>
<li><a href="../pt441146/index.html">Redes sem fio industriais: qual escolher?</a></li>
<li><a href="../pt441148/index.html">Como lidar com os erros corretamente: o sil√™ncio nem sempre √© bom</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>