<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📚 💒 🏳️ Struktur Data Eksotis: Modifikasi Merkle Patricia Trie 🖼️ 🗝️ 🤵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Setan macam apa yang harus kuingat dengan hafal semua algoritma dan struktur data sialan ini?" 


 Tentang ini bermuara pada komentar dari sebagian b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Struktur Data Eksotis: Modifikasi Merkle Patricia Trie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>"Setan macam apa yang harus kuingat dengan hafal semua algoritma dan struktur data sialan ini?"</em> </p><br><p>  Tentang ini bermuara pada komentar dari sebagian besar artikel tentang perjalanan wawancara teknis.  Tesis utama, sebagai suatu peraturan, adalah bahwa segala sesuatu yang digunakan dengan satu atau lain cara telah dilaksanakan sepuluh kali dan sangat tidak mungkin bahwa programmer biasa harus berurusan dengan.  Ya, sampai taraf tertentu ini benar.  Tetapi, ternyata, tidak semuanya dilaksanakan, dan saya, sayangnya (atau untungnya?) Masih harus membuat Struktur Data. </p><br><p>  Merkle Patricia Trie Yang Dimodifikasi Secara Misterius. </p><br><p>  Karena tidak ada informasi tentang pohon ini sama sekali tentang habr, dan pada medium - sedikit lagi, saya ingin memberi tahu Anda jenis hewan apa itu dan dengan apa ia dimakan. </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto">  Apa ini </h2><br><p>  <em>Penafian: sumber utama informasi untuk implementasi bagi saya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kertas Kuning</a> , serta kode sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parity-ethereum</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-ethereum</a> .</em>  <em>Ada sedikit informasi teoretis tentang pembenaran keputusan tertentu, jadi semua kesimpulan tentang alasan pengambilan keputusan tertentu adalah milik saya.</em>  <em>Jika saya salah dalam sesuatu - saya akan senang untuk koreksi di komentar.</em> </p><br><p>  <em>Pohon</em> adalah struktur data yang merupakan grafik asiklik yang terhubung.  Semuanya sederhana di sini, semua orang akrab dengan ini. </p><br><p>  <em>Pohon awalan</em> adalah <em>pohon</em> akar di mana pasangan kunci-nilai dapat disimpan karena fakta bahwa node dibagi menjadi dua jenis: yang berisi bagian dari jalur (awalan), dan simpul daun yang berisi nilai yang disimpan.  Nilai ada di pohon jika dan hanya jika, menggunakan kunci, kita bisa pergi jauh-jauh dari akar pohon dan menemukan sebuah simpul dengan nilai di akhir. </p><br><p>  <em>Pohon PATRICIA</em> adalah <em>pohon</em> awalan di mana awalannya adalah biner - yaitu, setiap simpul kunci menyimpan informasi tentang satu bit. </p><br><p>  Pohon <em>Merkle</em> adalah pohon hash yang dibangun di atas semacam rantai data, yang menggabungkan hash yang sama ini menjadi satu (root), menyimpan informasi tentang keadaan semua blok data.  Artinya, hash root adalah semacam "tanda tangan digital" dari keadaan rantai blok.  Hal ini digunakan secara aktif di blockchain, dan lebih lanjut tentang hal ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="Kerja keras adalah ..."></p><br><p>  Total: Merkle Patricia Trie yang Dimodifikasi (selanjutnya disingkat MPT) adalah pohon hash yang menyimpan pasangan nilai kunci, dan kunci-kunci tersebut disajikan dalam bentuk biner.  Dan apa sebenarnya "Dimodifikasi" tentang, kita akan mencari tahu nanti ketika kita membahas implementasi. </p><br><h2 id="zachem-eto">  Kenapa ini? </h2><br><p>  MPT digunakan dalam proyek Ethereum untuk menyimpan data tentang akun, transaksi, hasil eksekusi dan data lain yang diperlukan untuk berfungsinya sistem. <br>  Tidak seperti Bitcoin, di mana statusnya implisit dan dihitung oleh setiap node secara independen, saldo setiap akun (serta data yang terkait dengannya) disimpan langsung di blockchain di udara.  Selain itu, lokasi dan kekekalan data harus disediakan secara kriptografis - beberapa orang akan menggunakan mata uang kripto di mana saldo akun acak dapat berubah tanpa alasan obyektif. </p><br><p>  Masalah utama yang dihadapi oleh pengembang Ethereum adalah penciptaan struktur data yang secara efektif dapat menyimpan pasangan nilai kunci dan pada saat yang sama memberikan verifikasi data yang disimpan.  Jadi MPT muncul. </p><br><h2 id="kak-eto">  Bagaimana itu? </h2><br><p>  MPT adalah pohon PATRICIA awalan di mana kunci adalah urutan byte. </p><br><p>  Tepi di pohon ini adalah urutan gigitan (setengah byte).  Dengan demikian, satu simpul dapat memiliki hingga enam belas keturunan (sesuai dengan cabang dari 0x0 hingga 0xF). </p><br><p>  Node dibagi menjadi 3 jenis: </p><br><ul><li>  Simpul cabang.  Node yang digunakan untuk bercabang.  Berisi hingga 1 hingga 16 tautan ke simpul anak.  Mungkin juga mengandung nilai. </li><li>  Simpul ekstensi.  Node bantu yang menyimpan beberapa bagian dari jalur yang umum untuk beberapa simpul anak, serta tautan ke simpul cabang, yang terletak di bawah. </li><li>  Simpul daun.  Node yang berisi bagian dari jalur dan nilai yang disimpan.  Itu adalah akhir dari rantai. </li></ul><br><p> Seperti yang telah disebutkan, MPT dibangun di atas repositori kv lain, yang menyimpan node dalam bentuk "link" =&gt; " <code>RLP</code> encoded node". </p><br><p>  <em>Dan di sini kita datang dengan konsep baru: RLP.</em>  <em>Singkatnya, ini adalah metode pengkodean data yang mewakili urutan daftar atau byte.</em>  <em>Contoh: <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> .</em>  <em>Saya tidak akan membahas secara rinci, dan dalam implementasi saya menggunakan perpustakaan yang sudah jadi, karena cakupan topik ini juga akan mengembang artikel yang sudah agak besar.</em>  <em>Jika Anda masih tertarik, Anda dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</em>  <em>Kami membatasi diri pada fakta bahwa kami dapat menyandikan data dalam <code>RLP</code> dan men-dekode kembali.</em> </p><br><p>  Tautan ke sebuah simpul didefinisikan sebagai berikut: jika panjang simpul yang dikodekan <code>RLP</code> adalah 32 atau lebih byte, maka tautan tersebut adalah <code>keccak</code> dari representasi <code>RLP</code> dari simpul tersebut.  Jika panjangnya kurang dari 32 byte, maka tautannya adalah representasi <code>RLP</code> dari simpul itu sendiri. </p><br><p>  Jelas, dalam kasus kedua, Anda tidak perlu menyimpan node ke database, karena  itu akan disimpan sepenuhnya di dalam simpul induk. </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="Node berbeda"></p><br><p>  Kombinasi tiga jenis node memungkinkan Anda untuk secara efektif menyimpan data dalam kasus ketika ada beberapa kunci (maka sebagian besar jalur akan disimpan dalam ekstensi dan simpul daun, dan akan ada beberapa simpul cabang), dan dalam kasus ketika ada banyak node (jalur tidak akan disimpan secara eksplisit, tetapi mereka akan "mengumpulkan" selama bagian melalui node cabang). </p><br><p>  Contoh lengkap pohon menggunakan semua jenis node: </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="Pohon itu penuh tetapi tidak tebal"></p><br><p>  Seperti yang mungkin Anda perhatikan, bagian jalur yang disimpan memiliki awalan.  Diperlukan awalan untuk beberapa tujuan: </p><br><ol><li>  Untuk membedakan node ekstensi dari node daun. </li><li>  Untuk menyelaraskan urutan jumlah aneh camilan. </li></ol><br><p>  Aturan untuk membuat awalan sangat sederhana: </p><br><ul><li>  Awalan membutuhkan 1 nibble.  Jika panjang jalur (tidak termasuk awalan) ganjil, maka jalur dimulai segera setelah awalan.  Jika panjang lintasan genap, untuk menyelaraskan setelah awalan, nibble 0x0 ditambahkan terlebih dahulu. </li><li>  Awalan awalnya 0x0. </li><li>  Jika panjang jalurnya ganjil, maka 0x1 ditambahkan ke awalan, jika genap - 0x0. </li><li>  Jika jalur mengarah ke simpul daun, maka 0x2 ditambahkan ke awalan, jika 0x0 ditambahkan ke simpul ekstensi. </li></ul><br><p>  Pada beatiks, saya pikir, akan lebih jelas: </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie">  Penghapusan itu bukan penghapusan </h3><br><p>  Terlepas dari kenyataan bahwa pohon memiliki operasi menghapus node, pada kenyataannya, semua yang pernah ditambahkan tetap berada di pohon selamanya. </p><br><p>  Ini diperlukan agar tidak membuat pohon lengkap untuk setiap blok, tetapi hanya menyimpan perbedaan antara versi pohon yang lama dan yang baru. </p><br><p>  Oleh karena itu, dengan menggunakan hash root yang berbeda sebagai titik masuk, kita bisa mendapatkan salah satu dari keadaan di mana pohon itu berada. </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="Apa yang ditulis dengan pena ..."></p><br><p>  Ini tidak semua optimasi.  Ada lebih banyak, tetapi kami tidak akan membicarakannya - dan artikelnya besar.  Namun, Anda bisa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca</a> sendiri. </p><br><h2 id="realizaciya">  Implementasi </h2><br><p>  Teorinya sudah berakhir, mari kita beralih ke praktik.  Kami akan menggunakan lingua franca dari dunia IT, yaitu <code>python</code> . </p><br><p>  Karena akan ada banyak kode, dan untuk format artikel, banyak yang harus dikurangi dan dibagi, saya akan segera meninggalkan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . <br>  Jika perlu, di sana Anda dapat melihat seluruh gambar. </p><br><p>  Pertama, kita mendefinisikan antarmuka pohon yang ingin kita dapatkan sebagai hasilnya: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Antarmukanya sangat sederhana.  Operasi yang tersedia adalah mendapatkan, menghapus, memasukkan dan mengubah (digabung dalam pembaruan), serta mendapatkan hash root. </p><br><p>  Penyimpanan akan ditransfer ke metode <code>__init__</code> - struktur data seperti <code>dict</code> di mana kita akan menyimpan node, serta <code>root</code> - "atas" pohon.  Jika <code>None</code> yang dilewatkan sebagai <code>root</code> , kami menganggap bahwa pohon itu kosong dan bekerja dari awal. </p><br><p>  _Remark: Anda mungkin bertanya-tanya mengapa variabel dalam metode ini dinamai <code>encoded_key</code> dan <code>encoded_value</code> , dan bukan hanya <code>key</code> / <code>value</code> .  Jawabannya sederhana: sesuai dengan spesifikasi, semua kunci dan nilai harus dikodekan dalam <code>RLP</code> .  Kami tidak akan menyusahkan diri dengan hal ini dan meninggalkan pekerjaan ini di pundak pengguna perpustakaan._ </p><br><p>  Namun, sebelum kita mulai menerapkan pohon itu sendiri, dua hal penting harus dilakukan: </p><br><ol><li>  Menerapkan kelas <code>NibblePath</code> , yang merupakan rantai nibbles, agar tidak menyandikannya secara manual. </li><li>  Untuk mengimplementasikan kelas <code>Node</code> dalam kerangka kerja kelas ini - <code>Extension</code> , <code>Leaf</code> dan <code>Branch</code> . </li></ol><br><h3 id="nibblepath">  Nibblepath </h3><br><p>  Jadi, <code>NibblePath</code> .  Karena kita akan secara aktif bergerak di sekitar pohon, dasar dari fungsi kelas kita haruslah kemampuan untuk mengatur "offset" dari awal jalan, serta menerima menggigit tertentu.  Mengetahui hal ini, kami mendefinisikan dasar kelas kami (serta beberapa konstanta yang berguna untuk bekerja dengan awalan di bawah): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p>  Cukup sederhana, bukan? </p><br><p>  Masih menulis fungsi hanya untuk encoding dan decoding urutan camilan. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p>  Pada prinsipnya, ini adalah minimum yang diperlukan untuk pekerjaan yang nyaman dengan camilan.  Tentu saja, dalam implementasi saat ini ada sejumlah metode tambahan (seperti <code>combine</code> , menggabungkan dua jalur menjadi satu), tetapi implementasinya sangat sepele.  Jika tertarik, versi lengkapnya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h3 id="node">  Node </h3><br><p>  Seperti yang sudah kita ketahui, node kita dibagi menjadi tiga jenis: Leaf, Extension dan Branch.  Semuanya dapat dikodekan dan didekodekan, dan satu-satunya perbedaan adalah data yang disimpan di dalamnya.  Sejujurnya, ini adalah tipe data aljabar yang diminta, dan di <code>Rust</code> , misalnya, saya akan menulis sesuatu dengan semangat: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p>  Namun, tidak ada ADT dalam python seperti itu, jadi kami akan mendefinisikan kelas <code>Node</code> , dan di dalamnya ada tiga kelas yang sesuai dengan jenis simpul.  Kami menerapkan pengkodean langsung di kelas node, dan decoding di kelas <code>Node</code> . </p><br><p>  Implementasinya, bagaimanapun, adalah dasar: </p><br><p>  Daun: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p>  Ekstensi: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p>  Cabang: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p>  Semuanya sangat sederhana.  Satu-satunya hal yang dapat menimbulkan pertanyaan adalah fungsi <code>_prepare_reference_for_encoding</code> . </p><br><p>  <em>Kemudian saya akui, saya harus menggunakan tongkat kecil.</em>  <em>Faktanya adalah bahwa pustaka <code>rlp</code> mendekode data secara rekursif, dan tautan ke simpul lain, seperti yang kita ketahui, dapat berupa data <code>rlp</code> (jika simpul yang disandikan kurang dari 32 karakter).</em>  <em>Bekerja dengan tautan dalam dua format - byte hash dan simpul yang didekodekan - sangat merepotkan.</em>  <em>Oleh karena itu, saya menulis dua fungsi yang, setelah mendekode simpul, mengembalikan tautan dalam format byte, dan menerjemahkannya jika perlu, sebelum menyimpan.</em>  <em>Fungsi-fungsi ini adalah:</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p>  Akhiri dengan node dengan menulis kelas <code>Node</code> .  Hanya akan ada 2 metode di dalamnya: decode simpul dan ubah simpul menjadi tautan. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv">  Istirahat </h2><br><p>  Fuh!  Ada banyak informasi.  Saya pikir sudah waktunya untuk bersantai.  Ini kucing lain untuk Anda: </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="Anda dapat makan selama istirahat"></p><br><p>  Milota, kan?  Oke, kembali ke pohon kita. </p><br><h2 id="merklepatriciatrie">  MerklePatriciaTrie </h2><br><p>  Hore - elemen tambahan siap, kami sampaikan yang paling lezat.  Untuk jaga-jaga, saya akan mengingatkan antarmuka pohon kami.  Pada saat yang sama, kami menerapkan metode <code>__init__</code> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Tetapi dengan metode yang tersisa kita akan berurusan satu per satu. </p><br><h3 id="get">  dapatkan </h3><br><p>  Metode <code>get</code> (seperti, pada prinsipnya, metode lain) akan terdiri dari dua bagian.  Metode itu sendiri akan menyiapkan data dan membawa hasilnya ke bentuk yang diharapkan, sementara pekerjaan nyata akan terjadi di dalam metode tambahan. </p><br><p>  Metode dasar sangat sederhana: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p>  Namun, <code>_get</code> tidak jauh lebih rumit: untuk mencapai node yang diinginkan, kita perlu beralih dari root ke seluruh path yang disediakan.  Jika pada akhirnya kami menemukan sebuah simpul dengan data (Daun atau Cabang) - hore, data diterima.  Jika tidak memungkinkan untuk lulus, maka kunci yang diperlukan tidak ada di pohon. </p><br><p>  Implementasi: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p>  Nah, pada saat yang sama, kami akan menulis metode untuk menyimpan dan memuat node.  Mereka sederhana: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update">  pembaruan </h3><br><p>  Metode <code>update</code> sudah lebih menarik.  Langsung saja sampai akhir dan masukkan node Leaf tidak akan selalu berhasil.  Kemungkinan titik pemisahan kunci akan berada di suatu tempat di dalam simpul Leaf atau Extension yang sudah disimpan.  Dalam hal ini, Anda harus memisahkannya dan membuat beberapa node baru. </p><br><p>  Secara umum, semua logika dapat dijelaskan dengan aturan berikut: </p><br><ol><li>  Sementara path sepenuhnya bertepatan dengan node yang ada, kami secara rekursif turun pohon. </li><li>  Jika jalur selesai dan kami berada di simpul Cabang atau Daun, itu berarti <code>update</code> hanya memperbarui nilai yang sesuai dengan kunci ini. </li><li>  Jika jalur dibagi (artinya, kami tidak memperbarui nilai, tetapi menyisipkan yang baru), dan kami berada di simpul Cabang - membuat simpul Daun dan menentukan tautan ke sana di cabang cabang cabang yang sesuai. </li><li>  Jika jalur dibagi dan kita berada di simpul Leaf atau Extension, kita perlu membuat simpul Cabang yang memisahkan jalur, dan, jika perlu, simpul Ekstensi untuk bagian umum dari jalur. </li></ol><br><p>  Mari secara bertahap ungkapkan ini dalam kode.  Kenapa bertahap?  Karena metodenya besar dan akan sulit untuk memahaminya secara massal. <br>  Namun, saya akan meninggalkan tautan ke metode lengkap di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p>  Tidak ada cukup logika umum, semua yang paling menarik adalah di dalam <code>if</code> s. </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p>  Pertama, mari kita berurusan dengan Leaf node.  Hanya 2 skenario yang memungkinkan untuk itu: </p><br><ol><li><p>  Sisa lintasan yang kita ikuti persis sama dengan lintasan yang disimpan dalam simpul Daun.  Dalam hal ini, kita hanya perlu mengubah nilainya, menyimpan simpul baru dan mengembalikan tautan ke sana. </p><br></li><li><p>  Jalannya berbeda. <br>  Dalam hal ini, Anda perlu membuat simpul Cabang yang memisahkan dua jalur. <br>  Jika salah satu path kosong, maka nilainya akan ditransfer langsung ke simpul-cabang. <br>  Jika tidak, kita harus membuat dua node Leaf yang dipersingkat oleh panjang bagian umum dari path + 1 nibble (nibble ini akan ditunjukkan oleh indeks cabang yang sesuai dari node Branch). </p><br></li></ol><br><p>  Anda juga perlu memeriksa apakah ada bagian umum dari jalur untuk memahami apakah kita perlu membuat simpul ekstensi juga. </p><br><p>  Dalam kode tersebut, akan terlihat seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  Prosedur <code>_create_branch_node</code> adalah sebagai berikut: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p>  Dalam kasus simpul ekstensi, semuanya tampak seperti simpul daun. </p><br><ol><li><p>  Jika jalur dari simpul Ekstensi adalah awalan untuk jalur kami, kami cukup beralih secara rekursif. </p><br></li><li><p>  Kalau tidak, kita perlu melakukan pemisahan menggunakan simpul Cabang, seperti dalam kasus yang dijelaskan di atas. </p><br></li></ol><br><p>  Dengan demikian, kodenya: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  Prosedur <code>_create_branch_extension</code> secara logis setara dengan prosedur <code>_create_branch_leaf</code> , tetapi bekerja dengan node Extension. </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p>  Tetapi dengan simpul Cabang, semuanya sederhana.  Jika path kosong, kami cukup menyimpan nilai baru di simpul Cabang saat ini.  Jika jalan tidak kosong, kita “gigit” satu gigitan dari sana dan secara rekursif turun lebih rendah. </p><br><p>  Kode, saya pikir, tidak perlu komentar. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete">  hapus </h3><br><p>  Fuh!  Metode terakhir tetap.  Dia yang paling ceria.  Kompleksitas dari penghapusan adalah bahwa kita perlu mengembalikan struktur ke keadaan seperti seharusnya jika kita telah melakukan seluruh rantai <code>update</code> , kecuali hanya kunci yang dihapus. </p><br><p>   ,       ,     ,      ,    .   "",   ,      . </p><br><p>         .  ,   N-        ,    N+1 .      enum — <code>DeleteAction</code> ,    . </p><br><p>    <code>delete</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      —     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" —    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   —    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    —   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     … </p><br><p>  Mengapa   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    —     Leaf-.          —      Extension-.         ,    ,    2   —  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> — <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    — Leaf  Extension,           ,   . </p><br><p>     — Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe">  Sisanya </h3><br><p>      .  , …    <code>root</code> . </p><br><p>  Di sini: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  …  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> —  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="Itu semua orang!"></p><br><h2 id="rezultaty">  Hasil </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    —  ,       . </p><br><p> -,   ,  ,            — .  ,        skip list  interval tree,     — , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     —   . </p><br><p>   ,  ,        —    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446558/">https://habr.com/ru/post/id446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446546/index.html">Microsoft Memperluas Azure IP Advantage dengan Manfaat IP Baru untuk Inovator dan Startup Azure IoT</a></li>
<li><a href="../id446548/index.html">Analisis statistik tentang kampanye iklan - buat metrik baru di DataFrame (python)</a></li>
<li><a href="../id446550/index.html">Masalah pola koordinator dan apa yang harus dilakukan RouteComposer dengannya</a></li>
<li><a href="../id446552/index.html">Bekerja dengan Perintah APDU Menggunakan Contoh EToken</a></li>
<li><a href="../id446554/index.html">Program residen Yandex, atau How to back-end yang berpengalaman menjadi insinyur-ML</a></li>
<li><a href="../id446560/index.html">"Courtesy Exchange": inti dari konflik antara dua perusahaan streaming paling terkenal</a></li>
<li><a href="../id446562/index.html">Asynchrony dalam pemrograman</a></li>
<li><a href="../id446566/index.html">Project Zero. Bagaimana Amazon ingin berurusan dengan pemalsuan</a></li>
<li><a href="../id446568/index.html">Umbraco 8 pembaruan CMS skala besar: apa yang baru</a></li>
<li><a href="../id446570/index.html">Kisah GPU pertama: Rendition Vérité 1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>