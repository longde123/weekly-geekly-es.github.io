<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚒 🏩 ☑️ Zurück zu Microservices mit Istio. Teil 2 👍🏽 🔍 👐🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Der erste Teil dieser Reihe war der Einführung von Istio und seiner Demonstration in Aktion gewidmet. Jetzt werden wir über komplexer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zurück zu Microservices mit Istio. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/440378/"><img src="https://habrastorage.org/webt/bj/j4/oy/bjj4oyjxqshrbjf5eks9sgsvbeg.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> dieser Reihe war der Einführung von Istio und seiner Demonstration in Aktion gewidmet.</i>  <i>Jetzt werden wir über komplexere Aspekte der Konfiguration und Verwendung dieses Dienstnetzes sprechen, insbesondere über fein abgestimmtes Routing und Netzwerkverkehrsmanagement.</i> <i><br><br></i>  <i>Wir erinnern Sie auch daran, dass der Artikel Konfigurationen (Manifeste für Kubernetes und Istio) aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Istio-Mastery-</a> Repository verwendet.</i> <i><a name="habracut"></a></i> <br><br><h2>  Verkehrsmanagement </h2><br>  Mit Istio werden im Cluster neue Funktionen angezeigt, die Folgendes bieten: <br><br><ul><li>  <b>Dynamisches Abfrage-Routing</b> : Kanarische Rollouts, A / B-Tests; </li><li>  <b>Lastausgleich</b> : einfach und konsistent, basierend auf Hashes; </li><li>  <b>Wiederherstellung im Herbst</b> : Zeitüberschreitungen, Wiederholungsversuche, Leistungsschalter; </li><li>  <b>Fehlereingabe</b> : Verzögerungen, Unterbrechung von Anforderungen usw. </li></ul><br>  In der Fortsetzung des Artikels werden diese Funktionen als Beispiel für die ausgewählte Anwendung gezeigt und neue Konzepte werden vorgestellt.  Das erste derartige Konzept sind <code>DestinationRules</code> <i>(d. H. Regeln über den Empfänger von Verkehr / Anfragen - ca. Übersetzung)</i> , mit denen wir A / B-Tests aktivieren. <br><br><h2>  A / B-Tests: Zielregeln in der Praxis </h2><br>  A / B-Tests werden in Fällen verwendet, in denen es zwei Versionen der Anwendung gibt (normalerweise unterscheiden sie sich optisch) und wir nicht 100% sicher sind, welche die Benutzerinteraktion verbessern wird.  Daher starten wir beide Versionen gleichzeitig und sammeln Metriken. <br><br>  Führen Sie den folgenden Befehl aus, um die zweite Version des Frontends bereitzustellen, die zum Demonstrieren von A / B-Tests erforderlich ist: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/kube/ab-testing/sa-frontend-green-deployment.yaml deployment.extensions/sa-frontend-green created</code> </pre> <br>  Das Bereitstellungsmanifest für die "grüne Version" unterscheidet sich in zwei Punkten: <br><br><ol><li>  Das Bild basiert auf einem anderen Tag - <code>istio-green</code> , </li><li>  Pods haben eine <code>version: green</code> Etikett. </li></ol><br>  Da beide Bereitstellungen über die Bezeichnung <code>app: sa-frontend</code> verfügen, werden Anforderungen, die vom virtuellen Dienst <code>sa-external-services</code> an den <code>sa-frontend</code> Dienst weitergeleitet werden, an alle seine Instanzen umgeleitet und die Last mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Round-Robin-Algorithmus verteilt</a> . Dies führt zu folgender Situation: <br><br><img src="https://habrastorage.org/webt/p-/bi/mj/p-bimjrw8ywosk5q020d3loefsy.png"><br>  <i>Angeforderte Dateien nicht gefunden</i> <br><br>  Diese Dateien wurden nicht gefunden, da sie in verschiedenen Versionen der Anwendung unterschiedlich aufgerufen werden.  Stellen wir sicher, dass: <br><br><pre> <code class="bash hljs">$ curl --silent http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/ | tr <span class="hljs-string"><span class="hljs-string">'"'</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> | grep main /static/css/main.c7071b22.css /static/js/main.059f8e9c.js $ curl --silent http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/ | tr <span class="hljs-string"><span class="hljs-string">'"'</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> | grep main /static/css/main.f87cd8c9.css /static/js/main.f7659dbb.js</code> </pre> <br>  Dies bedeutet, dass <code>index.html</code> , in dem eine Version statischer Dateien angefordert wird, vom Load Balancer an Pods mit einer anderen Version gesendet werden kann, in denen solche Dateien aus offensichtlichen Gründen nicht vorhanden sind.  Damit die Anwendung funktioniert, müssen wir daher eine Einschränkung <b>festlegen</b> : " <b>Dieselbe Version der Anwendung, die index.html angegeben hat, muss auch nachfolgende Anforderungen bedienen</b> ." <br><br>  Wir werden das Ziel mit einem konsistenten Hash-basierten Lastausgleich <i>(Consistent Hash Loadbalancing) erreichen</i> .  In diesem Fall werden <b>Anforderungen von einem Client an dieselbe Backend-Instanz gesendet</b> , für die eine vordefinierte Eigenschaft verwendet wird, z. B. ein HTTP-Header.  Implementiert mit DestinationRules. <br><br><h2>  Zielregeln </h2><br>  Nachdem <b>VirtualService</b> eine Anforderung an den gewünschten Dienst gesendet <b>hat</b> , können wir mithilfe von DestinationRules die Richtlinien festlegen, die auf den für Instanzen dieses Dienstes bestimmten Datenverkehr angewendet werden: <br><br><img src="https://habrastorage.org/webt/sd/be/iy/sdbeiy6vndddkdjifebk9a7-q2m.png"><br>  <i>Istio Resource Traffic Management</i> <br><br>  <b>Hinweis</b> : Die Auswirkungen von Istio-Ressourcen auf den Netzwerkverkehr werden hier vereinfacht dargestellt.  Um genau zu sein, trifft Envoy die Entscheidung, an welche Instanz die Anforderung gesendet werden soll, in dem in CRD konfigurierten Ingress Gateway. <br><br>  Mithilfe der Zielregeln können wir den Lastenausgleich so konfigurieren, dass konsistente Hashes verwendet werden und Antworten von derselben Dienstinstanz für denselben Benutzer garantiert werden.  Die folgende Konfiguration ermöglicht dies ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">destinationrule-sa-frontend.yaml</a> ), um dies zu erreichen: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: sa-frontend spec: host: sa-frontend trafficPolicy: loadBalancer: consistentHash: httpHeaderName: version # 1</code> </pre> <br>  1 - Der Hash wird basierend auf dem Inhalt des HTTP- <code>version</code> generiert. <br><br>  Wenden Sie die Konfiguration mit dem folgenden Befehl an: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/ab-testing/destinationrule-sa-frontend.yaml destinationrule.networking.istio.io/sa-frontend created</code> </pre> <br>  Führen Sie nun den folgenden Befehl aus und stellen Sie sicher, dass Sie die Dateien erhalten, die Sie benötigen, wenn Sie den <code>version</code> angeben: <br><br><pre> <code class="bash hljs">$ curl --silent -H <span class="hljs-string"><span class="hljs-string">"version: yogo"</span></span> http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/ | tr <span class="hljs-string"><span class="hljs-string">'"'</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> | grep main</code> </pre> <br>  <b>Hinweis</b> : Um dem Titel verschiedene Werte hinzuzufügen und die Ergebnisse direkt im Browser zu testen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Erweiterung</a> für Chrome verwenden <i>(oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> für Firefox - ca. Transl.)</i> . <br><br>  Im Allgemeinen bietet DestinationRules mehr Optionen im Bereich des Lastausgleichs. Weitere Informationen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> . <br><br>  Bevor wir VirtualService weiter untersuchen, entfernen wir die „grüne Version“ der Anwendung und die entsprechende Regel in Verkehrsrichtung, indem wir die folgenden Befehle ausführen: <br><br><pre> <code class="bash hljs">$ kubectl delete -f resource-manifests/kube/ab-testing/sa-frontend-green-deployment.yaml deployment.extensions “sa-frontend-green” deleted $ kubectl delete -f resource-manifests/istio/ab-testing/destinationrule-sa-frontend.yaml destinationrule.networking.istio.io “sa-frontend” deleted</code> </pre> <br><h2>  Spiegeln: Virtuelle Dienste in der Praxis </h2><br>  Shadowing <i>("Shielding")</i> oder Mirroring <i>("Mirroring")</i> wird in den Fällen verwendet, in denen wir eine Änderung in der Produktion testen möchten, ohne die Endbenutzer zu beeinträchtigen. Dazu duplizieren wir ("Mirror") Anforderungen für die zweite Instanz, in der die erforderlichen Änderungen vorgenommen werden. und schauen Sie sich die Konsequenzen an.  <i>Einfach ausgedrückt, dies ist der Zeitpunkt, an dem Ihr (a) Kollege das kritischste Problem auswählt und eine Pull-Anfrage in Form eines so großen Schmutzklumpens stellt, dass niemand ihm tatsächlich eine Bewertung geben kann.</i> <br><br>  Um dieses Szenario in Aktion zu testen, erstellen Sie eine zweite Instanz von SA-Logic mit Fehlern ( <code>buggy</code> ), indem Sie den folgenden Befehl ausführen: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/kube/shadowing/sa-logic-service-buggy.yaml deployment.extensions/sa-logic-buggy created</code> </pre> <br>  Und jetzt führen wir den Befehl aus, um sicherzustellen, dass alle Instanzen mit <code>app=sa-logic</code> Beschriftungen mit den entsprechenden Versionen haben: <br><br><pre> <code class="bash hljs">$ kubectl get pods -l app=sa-logic --show-labels NAME READY LABELS sa-logic-568498cb4d-2sjwj 2/2 app=sa-logic,version=v1 sa-logic-568498cb4d-p4f8c 2/2 app=sa-logic,version=v1 sa-logic-buggy-76dff55847-2fl66 2/2 app=sa-logic,version=v2 sa-logic-buggy-76dff55847-kx8zz 2/2 app=sa-logic,version=v2</code> </pre> <br>  Der <code>sa-logic</code> zielt auf Pods mit der Bezeichnung <code>app=sa-logic</code> , sodass alle Anforderungen auf alle Instanzen verteilt werden: <br><br><img src="https://habrastorage.org/webt/6d/po/v8/6dpov8tnmom1j_sr7tcedj7bufo.png"><br><br>  ... aber wir möchten, dass Anfragen an Instanzen mit Version v1 gerichtet und an Instanzen mit Version v2 gespiegelt werden: <br><br><img src="https://habrastorage.org/webt/7u/n6/aj/7un6aj7gerw57imbzmwgkwgjajw.png"><br><br>  Dies erreichen wir durch den VirtualService in Kombination mit der DestinationRule, wobei die Regeln die Teilmengen und Routen des VirtualService zu einer bestimmten Teilmenge bestimmen. <br><br><h2>  Definieren von Teilmengen in Zielregeln </h2><br>  <i>Teilmengen werden</i> durch die folgende Konfiguration definiert ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sa-Logik-Teilmengen-</a> <i>Zielregel.yaml</i> ): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: sa-logic spec: host: sa-logic # 1 subsets: - name: v1 # 2 labels: version: v1 # 3 - name: v2 labels: version: v2</code> </pre> <br><ol><li>  Der <code>host</code> fest, dass diese Regel nur für Fälle gilt, in denen die Route zum <code>sa-logic</code> . </li><li>  Die Namen der Teilmengen werden beim Weiterleiten an Instanzen der Teilmenge verwendet. </li><li>  Eine Bezeichnung definiert die Schlüssel-Wert-Paare, mit denen Instanzen übereinstimmen müssen, um Teil einer Teilmenge zu werden. </li></ol><br>  Wenden Sie die Konfiguration mit dem folgenden Befehl an: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/shadowing/sa-logic-subsets-destinationrule.yaml destinationrule.networking.istio.io/sa-logic created</code> </pre> <br>  Nachdem die Teilmengen definiert sind, können Sie VirtualService so konfigurieren, dass die Regeln auf Anforderungen an sa-logic angewendet werden, sodass: <br><br><ol><li>  Weitergeleitet an eine Teilmenge von <code>v1</code> , </li><li>  In eine Teilmenge von <code>v2</code> gespiegelt. </li></ol><br>  Das folgende Manifest ermöglicht es Ihnen, Ihren Plan zu erreichen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sa-Logik-Teilmengen-Shadowing-vs. Yaml</a> ): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: sa-logic spec: hosts: - sa-logic http: - route: - destination: host: sa-logic subset: v1 mirror: host: sa-logic subset: v2</code> </pre> <br>  Hier ist keine Erklärung erforderlich. Schauen Sie sich also die Aktion an: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/shadowing/sa-logic-subsets-shadowing-vs.yaml virtualservice.networking.istio.io/sa-logic created</code> </pre> <br>  Fügen Sie die Last hinzu, indem Sie diesen Befehl aufrufen: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> curl -v http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/sentiment \ -H <span class="hljs-string"><span class="hljs-string">"Content-type: application/json"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{"sentence": "I love yogobella"}'</span></span>; \ sleep .8; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Schauen wir uns die Ergebnisse in Grafana an, wo wir sehen können, dass die fehlerhafte Version bei ~ 60% der Anfragen abstürzt, aber keiner dieser Abstürze betrifft Endbenutzer, da sie einen funktionierenden Dienst haben. <br><br><img src="https://habrastorage.org/webt/x3/g6/so/x3g6so65q5jmyjj48-_kjf254de.png"><br>  <i>Erfolg der Antworten verschiedener Versionen des Sa-Logic-Dienstes</i> <br><br>  Hier haben wir zum ersten Mal gesehen, wie VirtualService auf die Gesandten unserer Dienste angewendet wird: Wenn die <code>sa-web-app</code> eine Anfrage an <code>sa-logic</code> , durchläuft sie den Sidecar Envoy, der über VirtualService so konfiguriert ist, dass die Anfrage an die Teilmenge v1 und den Spiegel weitergeleitet wird eine Anforderung an eine Teilmenge von v2 des <code>sa-logic</code> . <br><br>  Ich weiß: Sie hatten bereits Zeit zu denken, dass virtuelle Dienste einfach sind.  Im nächsten Abschnitt erweitern wir diese Ansicht durch die Tatsache, dass sie auch wirklich großartig sind. <br><br><h2>  Kanarische Brötchen </h2><br>  Canary Deployment ist der Prozess der Einführung einer neuen Version einer Anwendung für eine kleine Anzahl von Benutzern.  Es wird verwendet, um sicherzustellen, dass es keine Probleme bei der Veröffentlichung gibt, und erst danach, da es bereits von seiner ausreichenden (Veröffentlichungs-) Qualität überzeugt ist, um es <i>einem</i> größeren Publikum zugänglich zu machen. <br><br>  Um die Einführung von Kanarienvögeln zu demonstrieren, werden wir weiterhin mit einer Teilmenge von <code>buggy</code> in <code>sa-logic</code> . <br><br>  Verschwenden wir keine Zeit damit und senden Sie sofort 20% der Benutzer mit Fehlern an die Version (dies wird unseren kanarischen Rollout darstellen) und die restlichen 80% an den normalen Service.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wenden Sie dazu</a> den folgenden VirtualService an ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sa-Logik-Teilmengen-Kanarienvogel-vs.yaml</a> ): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: sa-logic spec: hosts: - sa-logic http: - route: - destination: host: sa-logic subset: v1 weight: 80 # 1 - destination: host: sa-logic subset: v2 weight: 20 # 1</code> </pre> <br>  1 ist das Gewicht, das den Prozentsatz der Anforderungen bestimmt, die an den Empfänger oder eine Teilmenge des Empfängers gesendet werden. <br><br>  Aktualisieren Sie die vorherige VirtualService-Konfiguration für <code>sa-logic</code> folgenden Befehl: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/canary/sa-logic-subsets-canary-vs.yaml virtualservice.networking.istio.io/sa-logic configured</code> </pre> <br>  ... und sofort sehen, dass ein Teil der Anfragen abstürzt: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ curl -i http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/sentiment \ -H <span class="hljs-string"><span class="hljs-string">"Content-type: application/json"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{"sentence": "I love yogobella"}'</span></span> \ --silent -w <span class="hljs-string"><span class="hljs-string">"Time: %{time_total}s \t Status: %{http_code}\n"</span></span> \ -o /dev/null; sleep .1; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Time: 0.153075s Status: 200 Time: 0.137581s Status: 200 Time: 0.139345s Status: 200 Time: 30.291806s Status: 500</code> </pre> <br>  VirtualServices aktivieren kanarische Rollouts: In diesem Fall haben wir die möglichen Folgen von Problemen auf 20% der Benutzer reduziert.  Großartig!  In jedem Fall können wir, wenn wir uns unseres Codes nicht sicher sind (mit anderen Worten, immer ...), Spiegelung und kanarische Rollouts verwenden. <br><br><h2>  Zeitüberschreitungen und Wiederholungen </h2><br>  Aber nicht immer sind Fehler im Code.  In der Liste der " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8 Fehler beim verteilten Rechnen</a> " erscheint in erster Linie die falsche Meinung, dass "das Netzwerk zuverlässig ist".  In Wirklichkeit ist das Netzwerk <b>nicht</b> zuverlässig, und aus diesem Grund benötigen wir Zeitüberschreitungen und <i>Wiederholungsversuche</i> . <br><br>  Zur Demonstration werden wir weiterhin dieselbe Version von <code>sa-logic</code> ( <code>buggy</code> ) verwenden und die Unzuverlässigkeit des Netzwerks mit zufälligen Fehlern simulieren. <br><br>  Lassen Sie unseren Service mit Fehlern eine Chance von 1/3 für eine zu lange Antwort haben, 1/3 für einen Abschluss mit einem internen Serverfehler und 1/3 für eine erfolgreiche Seitenrückgabe. <br><br>  Um die Folgen solcher Probleme zu mildern und das Leben der Benutzer zu verbessern, können wir: <br><br><ol><li>  Fügen Sie eine Zeitüberschreitung hinzu, wenn der Dienst länger als 8 Sekunden antwortet. </li><li>  Wiederholen Sie den Vorgang, wenn die Anforderung fehlschlägt. </li></ol><br>  Für die Implementierung verwenden wir die folgende Ressourcendefinition ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sa-Logik-Wiederholungs-Timeouts-vs.yaml</a> ): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: sa-logic spec: hosts: - sa-logic http: - route: - destination: host: sa-logic subset: v1 weight: 50 - destination: host: sa-logic subset: v2 weight: 50 timeout: 8s # 1 retries: attempts: 3 # 2 perTryTimeout: 3s # 3</code> </pre> <br><ol><li>  Das Zeitlimit für die Anforderung ist auf 8 Sekunden festgelegt. </li><li>  Wiederholte Anforderungsversuche werden dreimal durchgeführt. </li><li>  Und jeder Versuch wird als erfolglos angesehen, wenn die Antwortzeit 3 ​​Sekunden überschreitet. </li></ol><br>  Wir haben also eine Optimierung erreicht, da der Benutzer nicht länger als 8 Sekunden warten muss und wir drei neue Versuche unternehmen werden, um bei Fehlern eine Antwort zu erhalten, was die Wahrscheinlichkeit einer erfolgreichen Antwort erhöht. <br><br>  Wenden Sie die aktualisierte Konfiguration mit dem folgenden Befehl an: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/retries/sa-logic-retries-timeouts-vs.yaml virtualservice.networking.istio.io/sa-logic configured</code> </pre> <br>  Und überprüfen Sie in den Grafiken von Grafana, ob die Anzahl der erfolgreichen Antworten abgelaufen ist: <br><br><img src="https://habrastorage.org/webt/ee/l_/qs/eel_qsg8z2vwzjwi35xmqg6eiko.png"><br>  <i>Verbesserungen in der Statistik erfolgreicher Antworten nach dem Hinzufügen von Zeitüberschreitungen und Wiederholungsversuchen</i> <br><br>  Bevor Sie mit dem nächsten Abschnitt fortfahren <i>(oder besser gesagt mit dem nächsten Teil des Artikels, da in diesem praktischen</i> Abschnitt <i>keine weiteren Experimente durchgeführt werden - ca. Übersetzen)</i> , löschen Sie <code>sa-logic-buggy</code> und VirtualService, indem Sie die folgenden Befehle ausführen: <br><br><pre> <code class="bash hljs">$ kubectl delete deployment sa-logic-buggy deployment.extensions “sa-logic-buggy” deleted $ kubectl delete virtualservice sa-logic virtualservice.networking.istio.io “sa-logic” deleted</code> </pre> <br><h2>  Leistungsschalter- und Schottmuster </h2><br>  Wir sprechen über zwei wichtige Muster in der Microservice-Architektur, mit denen Sie <i>Selbstheilungsdienste</i> erzielen können. <br><br>  <b>Der</b> <i>Leistungsschalter („Leistungsschalter“) wird</i> verwendet, um Anforderungen an eine als fehlerhaft eingestufte Instanz eines Dienstes zu stoppen und wiederherzustellen, während Clientanforderungen an fehlerfreie Instanzen dieses Dienstes umgeleitet werden (wodurch sich der Prozentsatz erfolgreicher Antworten erhöht).  <i>(Hinweis: Eine detailliertere Beschreibung des Musters finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .)</i> <br><br>  <b>Bulkhead</b> <i>("Partition")</i> isoliert Servicefehler von der Niederlage des gesamten Systems.  Beispielsweise ist Dienst B unterbrochen, und ein anderer Dienst (der Client von Dienst B) stellt eine Anforderung an Dienst B, wodurch er seinen Thread-Pool verbraucht und andere Anforderungen nicht bedienen kann (selbst wenn sie nicht mit Dienst B zusammenhängen).  <i>(Hinweis: Eine detailliertere Beschreibung des Musters finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .)</i> <br><br>  Ich werde die Details zur Implementierung dieser Muster weglassen, da sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> leicht zu finden sind, und ich möchte wirklich die Authentifizierung und Autorisierung zeigen, die im nächsten Teil des Artikels erörtert werden. <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  „Zurück zu Microservices mit Istio“: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 (Vertrautheit mit den Hauptfunktionen)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3 (Authentifizierung und Autorisierung)</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conduit - ein leichtes Service-Mesh für Kubernetes</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein Service-Mesh und warum brauche ich es [für eine Cloud-Anwendung mit Microservices]?</a>  ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440378/">https://habr.com/ru/post/de440378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440366/index.html">Lebenszyklus eines Artikels über Habré: Wir schreiben einen Habraparser</a></li>
<li><a href="../de440370/index.html">Nutzungsbedingungen: 99% der Benutzer verstehen sie einfach nicht</a></li>
<li><a href="../de440372/index.html">Mein Pascal-Compiler und polnische zeitgenössische Kunst</a></li>
<li><a href="../de440374/index.html">Yandex-Funktionen senden E-Mails</a></li>
<li><a href="../de440376/index.html">20 Spiele, um Ihrem Kind das Programmieren beizubringen</a></li>
<li><a href="../de440382/index.html">Ist 200 gut oder schlecht?</a></li>
<li><a href="../de440386/index.html">Fehlerbehebung durch Fehlerbehebung</a></li>
<li><a href="../de440388/index.html">Intervalle: Die bevorstehende C ++ - Evolution</a></li>
<li><a href="../de440390/index.html">Die vielfältige Welt der eingebetteten Systeme und der Platz von Embox darin</a></li>
<li><a href="../de440392/index.html">WebRTC auf Ihrer Website - keine Fehler und kein Budget</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>