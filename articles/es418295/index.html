<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèΩ üíÑ üë®üèª‚Äçüî¨ Casi todo lo que quer√≠a saber sobre punto flotante en ARM, pero ten√≠a miedo de preguntar üêò üêÉ üë©üèæ‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! En este art√≠culo quiero hablar sobre el trabajo de punto flotante para procesadores con arquitectura ARM. Creo que este art√≠culo ser√° √∫til ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Casi todo lo que quer√≠a saber sobre punto flotante en ARM, pero ten√≠a miedo de preguntar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/418295/"><img src="https://habrastorage.org/webt/uz/l3/0w/uzl30wgy6ecwi5eg7gmrtrdbzd4.jpeg" align="right" width="320">  Hola Habr!  En este art√≠culo quiero hablar sobre el trabajo de punto flotante para procesadores con arquitectura ARM.  Creo que este art√≠culo ser√° √∫til principalmente para aquellos que portan su sistema operativo a la arquitectura ARM y al mismo tiempo necesitan soporte para punto flotante de hardware (lo que hicimos para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> , que anteriormente usaba una implementaci√≥n de software de operaciones de punto flotante). <br><br>  Entonces comencemos. <br><a name="habracut"></a><br><h2>  Banderas del compilador </h2><br>  Para admitir coma flotante, debe pasar los indicadores correctos al compilador.  Una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda</a> r√°pida en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Google</a> lleva a la idea de que dos opciones son especialmente importantes: -mfloat-abi y -mfpu.  La opci√≥n -mfloat-abi establece el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ABI</a> para operaciones de punto flotante y puede tener uno de tres valores: 'soft', 'softfp' y 'hard'.  La opci√≥n 'soft', como su nombre lo indica, le dice al compilador que use las llamadas de funci√≥n incorporadas para programar el punto flotante (esta opci√≥n se us√≥ antes).  Los dos 'softfp' y 'hard' restantes se considerar√°n un poco m√°s tarde, despu√©s de considerar la opci√≥n -mfpu. <br><br><h2>  -Mfpu flag y versi√≥n VFP </h2><br>  La opci√≥n -mfpu, tal como est√° escrita en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n en l√≠nea de gcc</a> , le permite especificar el tipo de hardware y puede tomar las siguientes opciones: <br><blockquote>  'auto', 'vfpv2', 'vfpv3', 'vfpv3-fp16', 'vfpv3-d16', 'vfpv3-d16-fp16', 'vfpv3xd', 'vfpv3xd-fp16', 'neon-vfpv3', 'neon -fp16 ',' vfpv4 ',' vfpv4-d16 ',' fpv4-sp-d16 ',' neon-vfpv4 ',' fpv5-d16 ',' fpv5-sp-d16 ',' fp-armv8 ',' neon -fp-armv8 'y' crypto-neon-fp-armv8 '.  Y 'neon' es lo mismo que 'neon-vfpv3', y 'vfp' es 'vfpv2'. </blockquote>  Mi compilador (arm-none-eabi-gcc (15: 5.4.1 + svn241155-1) 5.4.1 20160919) produce una lista ligeramente diferente, pero esto no cambia la esencia del asunto.  En cualquier caso, debemos entender c√≥mo esta o aquella bandera afecta al compilador y, por supuesto, qu√© bandera se debe usar cuando. <br><br>  Comenc√© a entender la plataforma basada en el procesador imx6, pero la pospondremos por un tiempo, ya que el coprocesador de ne√≥n tiene caracter√≠sticas que analizar√© m√°s adelante, y comenzaremos con un caso m√°s simple: desde la plataforma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integrador / cp</a> , <br>  No tengo la placa en s√≠, por lo que la depuraci√≥n se realiz√≥ en el emulador qemu.  En qemu, la plataforma Interator / cp se basa en el procesador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ARM926EJ-S</a> , que a su vez admite el coprocesador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VFP9-S</a> .  Este coprocesador cumple con la versi√≥n 2 de Vector Floating-point Architecture (VFPv2).  En consecuencia, debe establecer -mfpu = vfpv2, pero esta opci√≥n no estaba en la lista de opciones de mi compilador.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Internet,</a> encontr√© una opci√≥n de compilaci√≥n con los indicadores -mcpu = arm926ej-s -mfpu = vfpv3-d16, lo instal√© y todo lo compil√© para m√≠.  Cuando comenc√©, recib√≠ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excepci√≥n de instrucci√≥n indefinida</a> , que era predecible, porque el coprocesador estaba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">apagado</a> . <br><br>  Para permitir que el coprocesador funcione, debe establecer el bit EN [30] en el registro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FPEXC</a> .  Esto se hace usando el comando VMSR. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enable FPU extensions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"VMSR FPEXC, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">);</span></span></span></span></code> </pre> <br>  De hecho, el comando VMSR es procesado por el coprocesador y genera una excepci√≥n si el coprocesador no est√° encendido, pero el acceso a este registro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no lo causa</a> .  Es cierto que, a diferencia de los dem√°s, el acceso a este registro solo es posible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo privilegiado</a> . <br><br>  Despu√©s de que se permiti√≥ que el coprocesador funcionara, nuestras pruebas de funciones matem√°ticas comenzaron a pasar.  Pero cuando activ√© la optimizaci√≥n (-O2), surgi√≥ la excepci√≥n de instrucci√≥n indefinida mencionada anteriormente.  Y surgi√≥ en la instrucci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vmov</a> que se llam√≥ en el c√≥digo anteriormente, pero se ejecut√≥ con √©xito (sin una excepci√≥n).  Finalmente, encontr√© al final de la p√°gina la frase "Las instrucciones que copian las constantes inmediatas est√°n disponibles en VFPv3" (es decir, las operaciones con constantes son compatibles a partir de VFPv3).  Y decid√≠ verificar qu√© versi√≥n se lanza en mi emulador.  La versi√≥n se registra en el registro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FPSID</a> .  De la documentaci√≥n se deduce que el valor del registro debe ser 0x41011090.  Esto corresponde a 1 en el campo de la arquitectura [19..16], es decir, VFPv2.  En realidad, despu√©s de haber hecho una copia impresa al inicio, obtuve esto <br><br><pre> <code class="hljs pgsql"> unit: initializing embox.arch.arm.fpu.vfp9_s: VPF <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: Hardware FP support Implementer = <span class="hljs-number"><span class="hljs-number">0x41</span></span> (ARM) Subarch: VFPv2 Part number = <span class="hljs-number"><span class="hljs-number">0x10</span></span> Variant = <span class="hljs-number"><span class="hljs-number">0x09</span></span> Revision = <span class="hljs-number"><span class="hljs-number">0x00</span></span></code> </pre> <br>  Despu√©s de leer cuidadosamente que 'vfp' es alias 'vfpv2', configur√© el indicador correcto, funcion√≥.  Volviendo a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina</a> donde vi la combinaci√≥n de banderas -mcpu = arm926ej-s -mfpu = vfpv3-d16, noto que no tuve el cuidado suficiente, porque -mfloat-abi = soft aparece en la lista de banderas.  Es decir, no hay soporte de hardware en este caso.  M√°s precisamente, -mfpu solo importa si un valor que no sea 'soft' se establece en -mfloat-abi. <br><br><h2>  Ensamblador </h2><br>  Es hora de hablar sobre ensamblador.  Despu√©s de todo, necesitaba hacer soporte en tiempo de ejecuci√≥n y, por ejemplo, el compilador, por supuesto, no sabe sobre el cambio de contexto. <br><br><h3>  Registros </h3><br>  Comencemos con la descripci√≥n de los registros.  VFP le permite realizar operaciones con n√∫meros de coma flotante de 32 bits (s0..s31) y 64 bits (d0..d15). La correspondencia entre estos registros se muestra en la imagen a continuaci√≥n. <br><br><img src="https://habrastorage.org/webt/jr/lo/w0/jrlow0oljuvwjd0y5bb-qkxlyh4.png"><br><br>  Q0-Q15 son registros de 128 bits de versiones anteriores para trabajar con SIMD, m√°s sobre ellos m√°s adelante. <br><br><h3>  Sistema de mando </h3><br>  Por supuesto, la mayor√≠a de las veces el trabajo con los registros de VFP debe entregarse al compilador, pero al menos debe escribir el cambio de contexto manualmente.  Si ya tiene una comprensi√≥n aproximada de la sintaxis de las instrucciones del ensamblador para trabajar con registros de uso general, tratar con nuevas instrucciones no deber√≠a ser dif√≠cil.  Muy a menudo, el prefijo "v" simplemente se agrega. <br><br><pre> <code class="hljs powershell">vmov d0, r0, r1 /*  r0  r1, ..  d0 <span class="hljs-number"><span class="hljs-number">64</span></span> ,   r0<span class="hljs-literal"><span class="hljs-literal">-1</span></span>  <span class="hljs-number"><span class="hljs-number">32</span></span> */ vmov r0, r1, d0 vadd d0, d1, d2 vldr d0, r0 vstm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>} vldm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>}</code> </pre> <br>  Y as√≠ sucesivamente.  Se puede encontrar una lista completa de comandos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web de ARM</a> . <br><br>  Y, por supuesto, no te olvides de la versi√≥n VFP para que no haya situaciones como la descrita anteriormente. <br><br><h2>  Marcar -mfloat-abi 'softfp' y 'hard' </h2><br>  Volver a -mfloat-abi.  Si lee la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> , veremos: <br><blockquote>  'softfp' permite la generaci√≥n de c√≥digo usando instrucciones de coma flotante de hardware, pero a√∫n usa las convenciones de llamada de flotaci√≥n suave.  'hard' permite la generaci√≥n de instrucciones de punto flotante y utiliza convenciones de llamadas espec√≠ficas de FPU. </blockquote>  Es decir, estamos hablando de pasar argumentos a una funci√≥n.  Pero al menos no estaba muy claro para m√≠ cu√°l es la diferencia entre las convenciones de llamadas de "flotaci√≥n suave" y "espec√≠ficas de FPU".  Suponiendo que el estuche r√≠gido usa registros de coma flotante y el caso softfp usa registros enteros, encontr√© confirmaci√≥n en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki de Debian</a> .  Y aunque esto es para coprocesadores NEON, pero no importa.  Otro punto interesante es que con la opci√≥n softfp, el compilador puede, pero no est√° obligado a usar soporte de hardware: <br><blockquote>  "El compilador puede tomar decisiones inteligentes sobre cu√°ndo y si genera instrucciones de FPU emuladas o reales dependiendo del tipo de FPU elegido (-mfpu =)" </blockquote>  Para mayor claridad, decid√≠ experimentar, y me sorprendi√≥ mucho, porque con la optimizaci√≥n de -O0 desactivada, la diferencia era muy leve y no se aplicaba a los lugares donde realmente se usaba el punto flotante.  Adivinando que el compilador simplemente empuja todo en la pila, en lugar de usar registros, encend√≠ la optimizaci√≥n -O2 y nuevamente me sorprend√≠, porque con la optimizaci√≥n el compilador comenz√≥ a usar registros de coma flotante de hardware para las opciones hard y sotffp, y la diferencia es c√≥mo y en el caso de -O0 fue muy insignificante.  Como resultado, para m√≠ mismo, expliqu√© esto por el hecho de que el compilador resuelve el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema</a> asociado con el hecho de que si copia datos entre registros de punto flotante y enteros, el rendimiento disminuir√° significativamente.  Y el compilador, al optimizar, comienza a usar todos los recursos a su disposici√≥n. <br><br>  Cuando me preguntaron qu√© bandera usar 'softfp' o 'hard', respond√≠ por m√≠ mismo de la siguiente manera: siempre que haya partes compiladas con la bandera 'softfp', debe usar 'hard'.  Si hay alguno, entonces necesita usar 'softfp'. <br><br><h2>  Cambio de contexto </h2><br>  Como Embox admite la multitarea preventiva, para que funcione correctamente en tiempo de ejecuci√≥n, naturalmente, se necesitaba una implementaci√≥n de cambio de contexto.  Para esto, es necesario guardar los registros del coprocesador.  Hay un par de matices.  Primero: result√≥ que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los comandos de operaci√≥n de pila para puntos flotantes (vstm / vldm) no son compatibles con todos los modos</a> .  Segundo: estas operaciones no admiten el trabajo con m√°s de diecis√©is registros de 64 bits.  Si necesita cargar / guardar m√°s registros a la vez, debe usar dos instrucciones. <br><br>  Dar√© una peque√±a optimizaci√≥n m√°s.  De hecho, no es necesario guardar y restaurar 256 bytes de registros VFP cada vez (los registros de prop√≥sito general ocupan solo 64 bytes, por lo que la diferencia es significativa).  La optimizaci√≥n obvia realizar√° estas operaciones solo si el proceso utiliza estos registros en principio. <br><br>  Como ya mencion√©, cuando el coprocesador VFP est√° apagado, un intento de ejecutar la instrucci√≥n correspondiente dar√° como resultado una excepci√≥n de "Instrucci√≥n no definida".  En el controlador de esta excepci√≥n, debe verificar cu√°l es la causa de la excepci√≥n, y si se trata de usar un coprocesador VPF, el proceso se marca como el uso del coprocesador VFP. <br><br>  Como resultado, el contexto de guardar / restaurar ya escrito se complement√≥ con macros <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmrs tmp, FPEXC ; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>stmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_save_inc: #define ARM_FPU_CONTEXT_LOAD_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmsr FPEXC, tmp; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_load_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vldmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_load_inc:</code> </pre> <br>  Para verificar la correcci√≥n de la operaci√≥n de cambio de contexto en condiciones de punto flotante, escribimos una prueba en la que multiplicamos en un hilo en un bucle y dividimos en otro, luego comparamos los resultados. <br><br><pre> <code class="cpp hljs">EMBOX_TEST_SUITE(<span class="hljs-string"><span class="hljs-string">"FPU context consistency test. Must be compiled with -02"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_COUNT 10 static float res_out[2][TICK_COUNT]; static void *fpu_context_thr1_hnd(void *arg) { float res = 1.0f; int i; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; TICK_COUNT; ) { res_out[0][i] = res; if (i == 0 || res_out[1][i - 1] &gt; 0) { i++; } if (res &gt; 0.000001f) { res /= 1.01f; } sleep(0); } return NULL; } static void *fpu_context_thr2_hnd(void *arg) { float res = 1.0f; int i = 0; for (i = 0; i &lt; TICK_COUNT; ) { res_out[1][i] = res; if (res_out[0][i] != 0) { i++; } if (res &lt; 1000000.f) { res *= 1.01f; } sleep(0); } return NULL; } TEST_CASE("Test FPU context consistency") { pthread_t threads[2]; pthread_t tid = 0; int status; status = pthread_create(&amp;threads[0], NULL, fpu_context_thr1_hnd, &amp;tid); if (status != 0) { test_assert(0); } status = pthread_create(&amp;threads[1], NULL, fpu_context_thr2_hnd, &amp;tid); if (status != 0) { test_assert(0); } pthread_join(threads[0], (void**)&amp;status); pthread_join(threads[1], (void**)&amp;status); test_assert(res_out[0][0] != 0 &amp;&amp; res_out[1][0] != 0); for (int i = 1; i &lt; TICK_COUNT; i++) { test_assert(res_out[0][i] &lt; res_out[0][i - 1]); test_assert(res_out[1][i] &gt; res_out[1][i - 1]); } }</span></span></span></span></code> </pre> <br>  La prueba pas√≥ con √©xito cuando se desactiv√≥ la optimizaci√≥n, por lo que indicamos en la descripci√≥n de la prueba que debe compilarse con la optimizaci√≥n, EMBOX_TEST_SUITE ("Prueba de coherencia de contexto FPU. Debe compilarse con -02");  aunque sabemos que las pruebas no deber√≠an basarse en esto. <br><br><h2>  Coprocesador NEON y SIMD </h2><br>  Es hora de decir por qu√© pospuse la historia sobre imx6.  El hecho es que se basa en el n√∫cleo Cortex-A9 y contiene el coprocesador NEON m√°s avanzado (https://developer.arm.com/technologies/neon).  NEON no solo es VFPv3, sino que tambi√©n es un coprocesador SIMD.  VFP y NEON usan los mismos registros.  VFP usa registros de 32 bits y 64 bits para la operaci√≥n, y NEON usa registros de 64 bits y 128 bits, estos √∫ltimos fueron designados Q0-Q16.  Adem√°s de los valores enteros y los n√∫meros de coma flotante, NEON tambi√©n puede trabajar con un anillo polinomial de m√≥dulo 2 de 16 ¬∞ u 8 ¬∞ grado. <br><br>  El modo vfp para NEON casi no es diferente del coprocesador vfp9-s desmontado.  Por supuesto, es mejor especificar las opciones vfpv3 o vfpv3-d32 para -mfpu para una mejor optimizaci√≥n, ya que tiene 32 registros de 64 bits.  Y para habilitar el coprocesador, debe dar acceso a los coprocesadores c10 y c11.  esto se hace usando comandos <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Allow access to c10 &amp; c11 coprocessors */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrc p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val) :)</span></span></span></span>; val |= <span class="hljs-number"><span class="hljs-number">0xf</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mcr p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val))</span></span></span></span>;</code> </pre> <br>  pero no hay otras diferencias fundamentales. <br><br>  Otra cosa si especifica -mfpu = neon, en este caso el compilador puede usar instrucciones SIMD. <br><br><h2>  Usando SIMD en C </h2><br>  Para &lt;&lt; registrar &gt;&gt; valores manualmente por registro, puede incluir "arm_neon.h" y usar los tipos de datos correspondientes: <br>  float32x4_t para cuatro flotantes de 32 bits en un registro, uint8x8_t para ocho enteros de 8 bits y as√≠ sucesivamente.  Para acceder a un solo valor, nos referimos a √©l como una matriz, suma, multiplicaci√≥n, asignaci√≥n, etc.  En cuanto a las variables ordinarias, por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> a = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, b = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> c = a * b; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚ÄúResult=[%d, %d, %d, %d]\n‚Äù, c[<span class="hljs-number"><span class="hljs-number">0</span></span>], c[<span class="hljs-number"><span class="hljs-number">1</span></span>], c[<span class="hljs-number"><span class="hljs-number">2</span></span>], c[<span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br>  Por supuesto, usar la vectorizaci√≥n autom√°tica es m√°s f√°cil.  Para la vectorizaci√≥n autom√°tica, agregue el indicador -ftree-vectorize a GCC. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simd_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[LEN], b[LEN], c[LEN]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { a[i] = i; b[i] = LEN - i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { c[i] = a[i] + b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"c[i] = %d\n"</span></span>, c[i]); } }</code> </pre> <br>  El ciclo de adici√≥n genera el siguiente c√≥digo: <br><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">600059</span></span>a0: f4610adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d16-d17}</span></span>, [r1 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>a4: e2833010 add r3, r3, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>a8: e28d0a03 add r0, sp, <span class="hljs-string"><span class="hljs-string">#12288</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3000 <span class="hljs-number"><span class="hljs-number">600059</span></span>ac: e2811010 add r1, r1, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b0: f4622adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d18-d19}</span></span>, [r2 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>b4: e2822010 add r2, r2, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b8: f26008e2 vadd.i32 q8, q8, q9 <span class="hljs-number"><span class="hljs-number">600059</span></span>bc: ed430b04 vstr d16, [r3, #-<span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c0: ed431b02 vstr d17, [r3, #-<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c4: e1530000 cmp r3, r0 <span class="hljs-number"><span class="hljs-number">600059</span></span>c8: <span class="hljs-number"><span class="hljs-number">1</span></span>afffff4 bne <span class="hljs-number"><span class="hljs-number">600059</span></span>a0 &lt;foo+<span class="hljs-number"><span class="hljs-number">0</span></span>x58&gt; <span class="hljs-number"><span class="hljs-number">600059</span></span>cc: e28d5dbf add r5, sp, <span class="hljs-string"><span class="hljs-string">#12224</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x2fc0 <span class="hljs-number"><span class="hljs-number">600059</span></span>d0: e2444004 sub r4, r4, <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>d4: e285503c add r5, r5, <span class="hljs-string"><span class="hljs-string">#60</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3c</code> </pre> <br>  Despu√©s de realizar pruebas para c√≥digo paralelo, descubrimos que la simple adici√≥n en un bucle, siempre que las variables sean independientes, da una aceleraci√≥n de hasta 7 veces.  Adem√°s, decidimos ver cu√°nto paralelismo afecta las tareas reales, tomamos MESA3d con su emulaci√≥n de software y medimos el n√∫mero de fps con diferentes indicadores, obtuvimos una ganancia de 2 cuadros por segundo (15 frente a 13), es decir, la aceleraci√≥n es de aproximadamente 15-20% . <br><br>  Dar√© otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo de aceleraci√≥n usando los comandos NEON</a> , no los nuestros, sino de ARM. <br><br>  La copia de memoria es hasta un 50 por ciento m√°s r√°pida de lo normal.  Los verdaderos ejemplos est√°n ah√≠ en ensamblador. <br><br>  Ciclo de copia normal: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r1]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">STR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r0]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SUBS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BGE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span></code> </pre> <br>  bucle con comandos y registros de ne√≥n: <br><br><pre> <code class="hljs erlang-repl">NEONCopyPLD PLD [r1, #<span class="hljs-number"><span class="hljs-number">0</span></span>xC0] VLDM r1!,{d0-d7} VSTM r0!,{d0-d7} SUBS r2,r2,#<span class="hljs-number"><span class="hljs-number">0</span></span>x40 BGE NEONCopyPLD</code> </pre> <br>  Est√° claro que la copia de 64 bytes es m√°s r√°pida que 4 bytes, y dicha copia dar√° un aumento del 10%, pero el 40% restante parece dar el trabajo del coprocesador. <br><br><h2>  Cortex-m </h2><br>  Trabajar con FPU en Cortex-M no es muy diferente del descrito anteriormente.  Por ejemplo, as√≠ es como se ve la macro anterior para guardar el contexto fpu-shny <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, =CPACR; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, [tmp]; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>tst tmp, #0xF00000; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {s0-s31}; fpu_out_save_inc:</code> </pre> <br>  Adem√°s, el comando vstmia usa solo los registros s0-s31 y se accede a los registros de control de manera diferente.  Por lo tanto, no entrar√© en demasiados detalles, solo explicar√© diff.  Entonces, hicimos soporte para STM32F7discovery con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cortex-m7</a> para ello, respectivamente, necesitamos establecer el indicador -mfpu = fpv5-sp-d16.  Tenga en cuenta que en las versiones m√≥viles, debe mirar m√°s de cerca la versi√≥n del coprocesador, ya que el mismo cortex-m puede tener diferentes opciones.  Entonces, si su opci√≥n no es con doble precisi√≥n, sino con una sola, entonces puede que no haya registros D0-D16, como lo hemos hecho en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">stm32f4discovery</a> , por lo que se utiliza la variante con registros S0-S31.  Para este controlador usamos -mfpu = fpv4-sp-d16. <br><br>  La principal diferencia es el acceso a los registros de control del controlador, est√°n ubicados directamente en el espacio de direcciones del n√∫cleo principal, y para diferentes tipos son diferentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cortex-m4</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cortex-m7</a> . <br><br><h2>  Conclusi√≥n </h2><br>  Con esto terminar√© mi cuento sobre punto flotante para ARM.  Observo que los microcontroladores modernos son muy potentes y adecuados no solo para el control, sino tambi√©n para procesar se√±ales o diversos tipos de informaci√≥n multimedia.  Para utilizar eficazmente todo este poder, debe comprender c√≥mo funciona.  Espero que este art√≠culo haya ayudado a resolver esto un poco mejor. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418295/">https://habr.com/ru/post/es418295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418285/index.html">Los climat√≥logos han demostrado c√≥mo la humanidad afecta las variaciones estacionales de la temperatura atmosf√©rica.</a></li>
<li><a href="../es418287/index.html">Lista de verificaci√≥n obligatoria para el desarrollo del dise√±o UX de una aplicaci√≥n m√≥vil</a></li>
<li><a href="../es418289/index.html">C√≥mo las soluciones de TI ayudan a organizar los precios din√°micos en la tienda</a></li>
<li><a href="../es418291/index.html">DEFCON 19. Conferencia "Robar todo, matar a todos, causar un colapso financiero completo"! Jason E. Street</a></li>
<li><a href="../es418293/index.html">Pruebas automatizadas de interfaz web en Virto Commerce</a></li>
<li><a href="../es418297/index.html">Revisi√≥n de tel√©fono inteligente Neffos N1</a></li>
<li><a href="../es418301/index.html">La gran confrontaci√≥n de Marte en 2018: c√≥mo observar y qu√© esperar</a></li>
<li><a href="../es418303/index.html">Vanessa-Automation: una herramienta para probar soluciones de aplicaciones en la plataforma 1C: Enterprise</a></li>
<li><a href="../es418305/index.html">¬øCu√°ntos objetos emite Python al ejecutar scripts?</a></li>
<li><a href="../es418307/index.html">Herramientas de Apple Machine Learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>