<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìå üìº üí± OpenSceneGraph: principes de base de la g√©om√©trie de sc√®ne üë©üèΩ‚Äç‚öñÔ∏è üçÖ üö∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 OpenGL, qui est le backend d'OpenSceneGraph, utilise des primitives g√©om√©triques (telles que des points, des lignes, des triangles et d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: principes de base de la g√©om√©trie de sc√®ne</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430212/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><br><h1>  Pr√©sentation </h1><br>  OpenGL, qui est le backend d'OpenSceneGraph, utilise des primitives g√©om√©triques (telles que des points, des lignes, des triangles et des faces polygonales) pour construire tous les objets dans le monde tridimensionnel. <br><br>  Ces primitives sont d√©finies par des donn√©es sur leurs sommets, qui incluent les coordonn√©es des sommets, les composants normaux, les donn√©es de couleur et les coordonn√©es de texture.  Ces donn√©es sont stock√©es dans des tableaux sp√©ciaux.  Les primitives peuvent √™tre form√©es, par exemple, en sp√©cifiant pour les objets qui les d√©crivent une liste d'indices de vertex.  Cette m√©thode est appel√©e la m√©thode des sommets, elle √©limine le stockage des sommets redondants en m√©moire et a de bonnes performances. <br><br>  En outre, OpenGL peut utiliser le m√©canisme des <i>listes</i> dites d' <i>affichage</i> , lorsque les primitives pr√©par√©es dans la m√©moire vid√©o peuvent √™tre r√©utilis√©es, ce qui acc√©l√®re consid√©rablement l'affichage des objets statiques. <br><br>  Par d√©faut, OSG utilise la m√©thode de tableau de sommets et la m√©thode de liste d'affichage pour rendre la g√©om√©trie.  Cependant, la strat√©gie de rendu peut √™tre modifi√©e, selon la fa√ßon dont les donn√©es de g√©om√©trie sont pr√©sent√©es.  Dans cet article, nous couvrirons les techniques de base pour travailler avec la g√©om√©trie dans OSG. <br><a name="habracut"></a><br><h1>  1. Classes Geode et Drawable </h1><br>  La classe osg :: Geode est un terminal, le n≈ìud dit "feuille" de l'arbre de la sc√®ne.  Il ne peut pas avoir de n≈ìuds enfants, mais il contient toutes les informations n√©cessaires au rendu de la g√©om√©trie.  Son nom, Geode, est l'abr√©viation de n≈ìud de g√©om√©trie. <br><br>  Les donn√©es g√©om√©triques √† traiter par le moteur sont stock√©es dans l'ensemble d'objets de la classe osg :: Drawable, g√©r√© par la classe osg :: Geode.  La classe osg :: Drawable est une classe purement virtuelle.  Un certain nombre de sous-classes en sont h√©rit√©es, qui sont des mod√®les tridimensionnels, des images et du texte trait√©s par le pipeline OpenGL.  OSG d√©signe dessinable comme tous les √©l√©ments pouvant √™tre dessin√©s par le moteur. <br><br>  La classe osg :: Geode fournit un certain nombre de m√©thodes pour attacher et d√©tacher des drawables: <br><br><ul><li>  M√©thode publique addDrawable () - passe un pointeur sur un √©l√©ment dessinable dans une instance de la classe osg :: Geode.  Tous ces √©l√©ments sont contr√¥l√©s par des pointeurs intelligents osg :: ref_ptr &lt;&gt;. <br></li><li>  La m√©thode publique removeDrawable () et removeDrawables () supprime l'objet d'osg :: Geode et diminue le nombre de r√©f√©rences pour lui.  La m√©thode removeDrawable () prend comme param√®tre unique un pointeur sur un √©l√©ment d'int√©r√™t, et la m√©thode removeDrawables () prend deux param√®tres: l'index initial et le nombre d'√©l√©ments √† supprimer du tableau d'objets osg :: Geode. <br></li><li>  La m√©thode getDrawable () renvoie un pointeur sur un √©l√©ment de l'index pass√© en param√®tre. <br></li><li>  La m√©thode getNumDrawables () renvoie le nombre total d'√©l√©ments attach√©s √† osg :: Geode.  Par exemple, pour supprimer tous les √©l√©ments d'osg :: Geode, vous pouvez utiliser ce code <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2. Dessiner des formes simples </h1><br>  OSG fournit la classe osg :: ShapeDrawable, qui est la descendante de la classe osg :: Drawable et con√ßue pour cr√©er des primitives tridimensionnelles simples.  Cette classe comprend un objet osg :: Shape qui stocke des informations sur une g√©om√©trie sp√©cifique et d'autres param√®tres.  Les primitives sont g√©n√©r√©es √† l'aide de la m√©thode setShape (), par exemple <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br>  cr√©e une bo√Æte rectangulaire avec un centre g√©om√©trique au point (1.0, 0.0, 0.0) avec une largeur et une hauteur de 10 et une profondeur de 5 unit√©s.  La classe osg :: Vec3 d√©finit un vecteur dans un espace tridimensionnel (en outre, les classes osg :: Vec2 et osg :: Vec4 d√©crivant des vecteurs de la dimension correspondante sont √©galement pr√©sent√©es). <br><br>  Les primitives les plus populaires sont repr√©sent√©es dans OSG par les classes osg :: Box, osg :: Capsule, osg :: Cone, osg :: Cylinder et osg :: Sphere. <br><br>  Prenons un exemple d'application de ce m√©canisme. <br><br>  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Cet exemple n'a surtout pas besoin de commentaires: dans le programme trois formes simples sont cr√©√©es, apr√®s compilation et lancement nous verrons un tel r√©sultat <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br>  Le m√©canisme montr√© dans l'exemple est simple et direct, mais ce n'est pas le moyen le plus efficace pour cr√©er une g√©om√©trie et peut √™tre utilis√© exclusivement pour des tests.  La classe osg :: Geometry est utilis√©e pour cr√©er une g√©om√©trie dans des applications OSG hautes performances. <br><br><h1>  3. Stockage des donn√©es de g√©om√©trie: classes osg :: Array et osg :: Geometry </h1><br>  La classe osg :: Array est une classe abstraite de base, dont plusieurs descendants sont h√©rit√©s, con√ßue pour stocker des donn√©es transmises aux fonctions OpenGL.  Travailler avec cette classe est similaire √† travailler avec std :: vector de la biblioth√®que standard C ++.  Le code suivant illustre l'ajout d'un vecteur √† un tableau de sommets √† l'aide de la m√©thode push_back () <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Les tableaux OSG sont allou√©s sur le tas et g√©r√©s par des pointeurs intelligents.  Cependant, cela ne s'applique pas aux √©l√©ments de tableau, tels que osg :: Vec3 ou osg :: Vec2, qui peuvent √©galement √™tre cr√©√©s sur la pile. <br><br>  La classe osg :: Geometry est un wrapper sur les fonctions OpenGL qui fonctionnent avec les tableaux de vertex.  Il est d√©riv√© de la classe osg :: Drawable et peut √™tre facilement ajout√© √† la liste d'objets osg :: Geode.  Cette classe prend en entr√©e les tableaux d√©crits ci-dessus et les utilise pour g√©n√©rer une g√©om√©trie √† l'aide d'OpenGL. <br><br><h1>  4. Sommets et leurs attributs </h1><br>  Un sommet est une unit√© atomique de primitives de g√©om√©trie.  Il poss√®de un certain nombre d'attributs qui d√©crivent un point dans un espace √† deux ou trois dimensions.  Les attributs incluent: position, couleur, vecteur normal, coordonn√©es de texture, coordonn√©es de brouillard, etc.  Le sommet doit toujours avoir une position dans l'espace, comme pour les autres attributs, ils peuvent √™tre pr√©sents en option.  OpenGL prend en charge 16 attributs de sommet de base et peut utiliser diff√©rents tableaux pour les stocker.  Tous les tableaux d'attributs sont pris en charge par la classe osg :: Geometry et peuvent √™tre d√©finis √† l'aide des m√©thodes du formulaire set * Array (). <br><br>  <b>Attributs de sommet dans OpenSceneGraph</b> <br><table><tbody><tr><th>  Attribut </th><th>  Type de donn√©es </th><th>  Osg :: M√©thode de g√©om√©trie </th><th>  Appel OpenGL √©quivalent </th></tr><tr><td>  Poste </td><td>  3 vecteurs </td><td>  setVertexArray () </td><td>  glVertexPointer () </td></tr><tr><td>  Normal </td><td>  3 vecteurs </td><td>  setNormalArray () </td><td>  glNormalPointer () </td></tr><tr><td>  La couleur </td><td>  4 vecteurs </td><td>  setColorArray () </td><td>  glColorPointer () </td></tr><tr><td>  Couleur secondaire </td><td>  4 vecteurs </td><td>  setSecondaryColorArray () </td><td>  glSecondaryColorPointerEXT () </td></tr><tr><td>  Coordonn√©es de brouillard </td><td>  flotter </td><td>  setFogCoordArray () </td><td>  glFogCoordPointerEXT () </td></tr><tr><td>  Coordonn√©es de texture </td><td>  2 ou 3 vecteurs </td><td>  setTexCoordArray () </td><td>  glTexCoordPointer () </td></tr><tr><td>  Autres attributs </td><td>  D√©fini par l'utilisateur </td><td>  setVertexArribArray () </td><td>  glVertexAttribPointerARB () </td></tr></tbody></table><br>  En principe, il est n√©cessaire de d√©finir vos propres attributs pour chacun des sommets, ce qui conduit √† la formation de plusieurs tableaux d'attributs de m√™me taille - sinon un d√©calage dans les tailles des tableaux peut conduire √† un comportement ind√©fini du moteur.  OSG prend en charge diverses m√©thodes pour lier les attributs de sommet, par exemple <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  signifie que chaque sommet et chaque couleur du sommet sont corr√©l√©s l'un √† l'autre.  Cependant, si vous regardez ce code <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  puis il applique une couleur √† toute la g√©om√©trie.  De m√™me, les relations entre d'autres attributs peuvent √™tre configur√©es en appelant les m√©thodes setNormalBinding (), setSecondaryColorBinding (), setFogCoordBinding () et setVertexAttribBinding (). <br><br><h1>  5. Ensembles de primitives de g√©om√©trie </h1><br>  L'√©tape suivante apr√®s avoir d√©fini les tableaux d'attributs de sommet est de d√©crire comment les donn√©es de sommet seront rendues.  La classe virtuelle osg :: PrimitiveSet est utilis√©e pour contr√¥ler les primitives g√©om√©triques g√©n√©r√©es par le moteur de rendu √† partir de l'ensemble de sommets.  La classe osg :: Geometry fournit plusieurs m√©thodes pour travailler avec des ensembles de primitives de g√©om√©trie: <br><br><ul><li>  addPrimitiveSet () - passe un pointeur vers un ensemble de primitives dans un objet osg :: Geometry. <br></li><li>  removePrimitiveSet () - supprime un ensemble de primitives.  Comme param√®tres, il prend l'index initial des ensembles et le nombre d'ensembles √† supprimer. <br></li><li>  getPrimitiveSet () - retourne un ensemble de primitives √† l'index pass√© en param√®tre. <br></li><li>  getNumPrimitiveSets () - renvoie le nombre total d'ensembles de primitives associ√©s √† cette g√©om√©trie. <br></li></ul><br>  La classe osg :: PrimitiveSet est abstraite et ne peut pas √™tre instanci√©e, mais plusieurs classes d√©riv√©es qui encapsulent les ensembles de primitives avec lesquelles OpenGL fonctionne, telles que osg :: DrawArrays et osg :: DrawElementsUInt, en h√©ritent. <br><br>  La classe osg :: DrawArrays utilise plusieurs √©l√©ments cons√©cutifs d'un tableau de sommets pour construire une primitive g√©om√©trique.  Il peut √™tre cr√©√© et attach√© √† la g√©om√©trie en appelant une m√©thode. <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br>  Le premier mode de param√®tre d√©finit le type primitif sur les types primitifs OpenGL correspondants: GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS et GL_POLY. <br><br>  Les premier et deuxi√®me param√®tres sp√©cifient le premier index du tableau de sommets et le nombre de sommets √† partir desquels la g√©om√©trie doit √™tre g√©n√©r√©e.  <strong>De plus, OSG ne v√©rifie pas si le nombre de sommets sp√©cifi√© est suffisant pour construire la g√©om√©trie sp√©cifi√©e par le mode, ce qui peut conduire au crash de l'application!</strong> <br><br><h1>  6. Exemple - dessiner un carr√© peint </h1><br>  Nous mettons en ≈ìuvre tout ce qui pr√©c√®de comme un exemple simple <br><br><div class="spoiler">  <b class="spoiler_title">Le code source complet pour l'exemple quad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Apr√®s compilation et ex√©cution, nous obtenons un r√©sultat similaire √† celui-ci <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br>  Cet exemple doit √™tre clarifi√©.  Donc, tout d'abord, nous cr√©ons un tableau de sommets du carr√©, dans lequel leurs coordonn√©es sont stock√©es <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Ensuite, nous d√©finissons le tableau de normales.  Dans notre cas simple, nous n'avons pas besoin de cr√©er une normale pour chaque sommet - il suffit de d√©crire un vecteur unitaire dirig√© perpendiculairement au plan du carr√© <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  D√©finissez une couleur pour chaque sommet <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Cr√©ez maintenant un objet g√©om√©trique o√π la description de notre carr√© sera stock√©e, qui sera trait√©e par le rendu.  Nous passons un tableau de sommets √† cette g√©om√©trie <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br>  En passant un tableau de normales, nous informons le moteur qu'une seule normale sera utilis√©e pour tous les sommets, en sp√©cifiant la m√©thode de liaison ("binding") des normales BIND_OVAERALL <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  En passant les couleurs des sommets, au contraire, nous indiquons que chaque sommet aura sa propre couleur <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  Cr√©ez maintenant un ensemble de primitives pour la g√©om√©trie.  Nous indiquons que les faces carr√©es (GL_QUADS) doivent √™tre g√©n√©r√©es √† partir du tableau de sommets, en prenant le sommet avec l'index 0 comme premier sommet, et le nombre total de sommets sera de 4 <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Eh bien, je pense que √ßa ne vaut pas la peine d'expliquer le transfert de g√©om√©trie et le lancement du rendu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Le code ci-dessus est √©quivalent √† la conception suivante en OpenGL pur <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { ‚Ä¶ }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7. Indexation des sommets dans les primitives </h1><br>  La classe osg :: DrawArrays fonctionne bien lors de la lecture de donn√©es de vertex directement √† partir de tableaux, sans lacunes.  Cependant, cela n'est pas aussi efficace lorsqu'un m√™me sommet peut appartenir √† plusieurs faces d'un objet.  Regardons un exemple. <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br>  Le cube a huit sommets.  Cependant, comme on peut le voir sur la figure (nous regardons le d√©roulement du cube sur le plan), certains sommets appartiennent √† plus d'une face.  Si vous construisez un cube de 12 faces triangulaires, alors ces sommets seront r√©p√©t√©s, et au lieu d'un tableau de 8 sommets, nous obtenons un tableau de 36 sommets, dont la plupart sont en fait le m√™me sommet! <br><br>  Les classes OSG osg :: DrawElementsUInt, osg :: DrawElementsUByte et osg :: DrawElementsUShort, qui utilisent des tableaux d'index de sommets comme donn√©es, sont con√ßues pour r√©soudre le probl√®me d√©crit.  Les tableaux d'index stockent des index de sommets de primitives qui d√©crivent des faces et d'autres √©l√©ments de la g√©om√©trie.  Lors de l'application de ces classes √† un cube, il suffit de stocker un tableau de huit sommets associ√©s √† des faces via des tableaux d'indices. <br><br>  Les classes de type osg :: DrawElements * sont construites de la m√™me mani√®re que la classe standard std :: vector.  Un tel code peut √™tre utilis√© pour ajouter des indices. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Ce code d√©finit la face avant du cube illustr√© dans la figure. <br><br>  Prenons un autre exemple illustratif - un octa√®dre <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br>  C'est int√©ressant car il ne contient que six sommets, mais chaque sommet entre jusqu'√† quatre faces triangulaires!  Nous pouvons cr√©er un tableau de 24 sommets pour afficher les huit faces en utilisant osg :: DrawArrays.  Cependant, nous ferons autrement - nous stockerons les sommets dans un tableau de six √©l√©ments, et nous g√©n√©rerons des faces en utilisant la classe osg :: DrawElementsUInt. <br><br><div class="spoiler">  <b class="spoiler_title">Source compl√®te pour l'exemple octa√®dre</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Analysons ce code plus en d√©tail.  Bien s√ªr, la premi√®re chose que nous faisons est de cr√©er un tableau de six sommets <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br>  Nous initialisons chaque sommet directement en acc√©dant au vecteur de ses coordonn√©es en utilisant l'op√©ration de d√©r√©f√©rencement du pointeur et de l'op√©rateur operator [] (nous nous souvenons que osg :: Array est similaire dans son dispositif √† std :: vector). <br><br>  Cr√©ez maintenant des faces sous forme de liste d'index de sommets <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br>  Les faces seront triangulaires, il y en aura 8, ce qui signifie que la liste des indices doit contenir 24 √©l√©ments.  Les indices des faces vont s√©quentiellement dans ce tableau: par exemple, la face 0 est form√©e par les sommets 0, 1 et 2;  face 1 - sommets 0, 4 et 1;  face 2 - sommets 4, 5 et 1 et ainsi de suite.  Les sommets sont r√©pertori√©s dans le sens antihoraire si vous regardez le visage du visage (voir la figure ci-dessus). <br><br>  √âtapes suppl√©mentaires pour cr√©er la g√©om√©trie que nous avons effectu√©e dans les exemples pr√©c√©dents.  La seule chose que nous n'avons pas faite est la g√©n√©ration automatique de normales liss√©es (moyenn√©es), que nous effectuons dans cet exemple en appelant <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>  En effet, si les sommets d'une face sont donn√©s, alors il est facile de calculer la normale √† celle-ci.  Aux sommets o√π plusieurs faces convergent, une certaine normale moyenne est calcul√©e - les normales des faces convergentes sont additionn√©es et la somme r√©sultante est √† nouveau normalis√©e.  Ces op√©rations (ainsi que bien d'autres!) Peuvent √™tre effectu√©es par le moteur lui-m√™me √† l'aide des classes de la biblioth√®que osgUtil.  Par cons√©quent, dans notre exemple, nous allons ajouter une instruction √† l'√©diteur de liens pour construire notre programme avec cette biblioth√®que dans le fichier * .pro <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octahedron.pro</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br>  En cons√©quence, nous obtenons le r√©sultat suivant <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br>  Pour comprendre comment cela fonctionne, consid√©rez le pipeline OpenGL <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br>  Le m√©canisme de tableau de vertex r√©duit le nombre d'appels OpenGL.  Il stocke les donn√©es de sommet dans la m√©moire de l'application, qui est utilis√©e c√¥t√© client.  Le pipeline OpenGL c√¥t√© serveur a acc√®s √† diff√©rents tableaux de vertex.  Comme le montre le diagramme, OpenGL re√ßoit des donn√©es de la m√©moire tampon vertex c√¥t√© client et, de mani√®re ordonn√©e, effectue l'assemblage des primitives.  C'est ainsi que les donn√©es sont trait√©es √† l'aide des m√©thodes set * Array () de la classe osg :: Geometry.  La classe osg :: DrawArrays passe directement par ces tableaux et les affiche. <br><br>  Lorsque vous utilisez osg :: DrawElements *, la dimension des tableaux de sommets est r√©duite et le nombre de sommets transf√©r√©s vers le pipeline est r√©duit.  Un tableau d'index vous permet de cr√©er un cache de vertex c√¥t√© serveur.  OpenGL lit les donn√©es de vertex dans le cache, au lieu de lire dans le tampon de vertex c√¥t√© client.  Cela augmente consid√©rablement les performances globales de rendu. <br><br><h1>  8. Techniques de traitement du maillage polygonal </h1><br>  OpenSceneGraph prend en charge diverses techniques de traitement du maillage polygonal d'objets de g√©om√©trie de sc√®ne.  Ces m√©thodes de pr√©traitement, telles que la r√©duction et la tessellation des polygones, sont souvent utilis√©es pour cr√©er et optimiser des mod√®les polygonaux.  Ils ont une interface simple, mais dans le processus, ils effectuent beaucoup de calculs complexes et ne sont pas tr√®s adapt√©s √† une ex√©cution √† la vol√©e. <br><br>  Les techniques d√©crites comprennent: <br><br><ol><li>  osgUtil :: Simplifier - r√©duire le nombre de triangles dans la g√©om√©trie.  La m√©thode publique simplify () est utilis√©e pour simplifier la g√©om√©trie du mod√®le. <br></li><li>  osgUtil :: SmootingVisitor - calcul des normales.  La m√©thode smooth () peut √™tre utilis√©e pour g√©n√©rer des normales liss√©es pour le mod√®le, au lieu de les calculer ind√©pendamment et de les d√©finir explicitement via un tableau de normales. <br></li><li>  osgUtil :: TangentSpaceGenerator - g√©n√©ration de vecteurs de base tangents pour les sommets du mod√®le.  Il est lanc√© en appelant la m√©thode generate () et enregistre le r√©sultat renvoy√© par les m√©thodes getTangentArray (), getNormalArray () et getBinormalArray ().  Ces r√©sultats peuvent √™tre utilis√©s pour divers attributs de sommet lors de l'√©criture de shaders dans GLSL. <br></li><li>  osgUtil :: Tesselator - effectue la tessellation d'un maillage polygonal - divise des primitives complexes en une s√©quence de primitives simples (m√©thode retesselatePolygons ()) <br></li><li>  osgUtil :: TriStripVisitor - convertit une surface g√©om√©trique en un ensemble de bandes de faces triangulaires, ce qui permet un rendu avec une consommation de m√©moire efficace.  La m√©thode stripify () convertit un ensemble de primitives de mod√®le en g√©om√©trie bas√©e sur l'ensemble GL_TRIANGLE_STRIP. <br></li></ol><br>  Toutes les m√©thodes acceptent la g√©om√©trie de l'objet en tant que param√®tre transmis par osg :: Geometry &amp; link, par exemple comme ceci <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br>  o√π geom fait r√©f√©rence √† une instance de g√©om√©trie d√©crite par un pointeur intelligent. <br><br>  Les classes osg :: Simplifier, osg :: SmoothingVisitor et osg :: TriStripVisitor peuvent fonctionner directement avec les n≈ìuds du graphe de sc√®ne, par exemple <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  La m√©thode accept () traite tous les n≈ìuds enfants jusqu'√† ce que l'op√©ration sp√©cifi√©e soit appliqu√©e √† tous les n≈ìuds terminaux de cette partie de l'arborescence de sc√®nes stock√©s dans des n≈ìuds de type osg :: Geode. <br><br>  Essayons la technique de pavage en pratique. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code complet de navire</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Sur la base de la position spatiale des sommets dans cet exemple, nous voyons que nous essayons de cr√©er un polygone non convexe de huit sommets, en utilisant la g√©n√©ration d'une face de type GL_POLYGON.  L'assemblage et l'ex√©cution de cet exemple montrent que le r√©sultat que nous attendons ne fonctionne pas - l'exemple n'est pas affich√© correctement <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br>  Pour r√©soudre ce probl√®me, la g√©om√©trie construite doit √™tre tessell√©e avant de la transmettre au visualiseur <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br>  apr√®s quoi nous obtenons le bon r√©sultat <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br>  Comment √ßa marche?  Un polygone non convexe, sans l'utilisation d'une tessellation correcte, ne sera pas affich√© comme nous l'attendons, car OpenGL, cherchant √† optimiser les performances, le consid√©rera comme un polygone convexe simple ou l'ignorera simplement, ce qui peut donner des r√©sultats compl√®tement inattendus. <br><br>  La classe osgUtil :: Tessellator utilise des algorithmes pour transformer un polygone convexe en une s√©rie de polygones non convexes - dans notre cas, elle transforme la g√©om√©trie en GL_TRIANGLE_STRIP. <br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette classe peut g√©rer les polygones de trous et les polygones auto-entrecrois√©s. √Ä l'aide de la m√©thode publique setWindingType (), vous pouvez d√©finir diverses r√®gles de traitement, telles que GLU_TESS_WINDING_ODD ou GLU_TESS_WINDING_NONZERO, qui sp√©cifient les r√©gions int√©rieure et ext√©rieure d'un polygone complexe.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, nous avons acquis une compr√©hension de base de la fa√ßon dont la g√©om√©trie des objets tridimensionnels est stock√©e et trait√©e dans le moteur OSG. </font><font style="vertical-align: inherit;">Ne pensez pas que ces exemples simples et pas trop impressionnants qui sont consid√©r√©s dans l'article sont la limite des capacit√©s du moteur. </font><font style="vertical-align: inherit;">Juste ces exemples peuvent aider le d√©veloppeur √† comprendre la m√©canique d'OpenSceneGraph, et sans cette compr√©hension, il est difficile d'imaginer le travail de choses plus complexes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet article est bas√© sur la traduction et le traitement du texte des chapitres correspondants du livre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0. </font><font style="vertical-align: inherit;">Guide du d√©butant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tous les exemples sont v√©rifi√©s par moi personnellement et leur code source est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disponible ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä suivre ...</font></font></a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430212/">https://habr.com/ru/post/fr430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430202/index.html">√âcriture d'un syst√®me de particules interagissant par paire en C ++ √† l'aide de DirectX 11</a></li>
<li><a href="../fr430204/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 18: ¬´Navigation Internet priv√©e¬ª, partie 1</a></li>
<li><a href="../fr430206/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 18: Navigation priv√©e sur Internet, partie 2</a></li>
<li><a href="../fr430208/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 18: ¬´Navigation Internet priv√©e¬ª, partie 3</a></li>
<li><a href="../fr430210/index.html">Testez ma patience par la Check Point Security Academy</a></li>
<li><a href="../fr430216/index.html">Si je comprends bien, je mange beaucoup de bonbons, ou le classement des marchandises par ch√®que dans l'application</a></li>
<li><a href="../fr430218/index.html">Optimisation √©nerg√©tique STM32: un guide pratique</a></li>
<li><a href="../fr430220/index.html">Comment transformer un hub USB ¬´centenaire¬ª en un smart managed et √©conomiser 300 $</a></li>
<li><a href="../fr430222/index.html">Ing√©nieur senior en recherche de travail. Comment j'ai v√©cu 20 entretiens avec les RH et ce que j'en pense</a></li>
<li><a href="../fr430224/index.html">Trouble schizotypique: un regard int√©rieur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>