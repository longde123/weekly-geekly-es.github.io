<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😏 👆🏿 👨🏽‍🎓 了解Moleculer微服务框架 🚵🏻 👵🏿 🧘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨％habrauser％！ 

 今天，我想向您介绍一个很好的Moleculer微服务框架。 



 最初，该框架是用Node.js编写的，但后来以Java，Go，Python和.NET等其他语言出现在端口上，并且很可能在不久的将来出现其他实现。 大约一年以来，我们已经将它用于多种产品的生产中，很...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>了解Moleculer微服务框架</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439810/">嗨％habrauser％！ <br><br> 今天，我想向您介绍一个很好的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Moleculer</a>微服务框架。 <br><br><img src="https://habrastorage.org/webt/n1/8a/ew/n18aewfs_oj6ndbonuakkyjfwte.png"><br><br> 最初，该框架是用Node.js编写的，但后来以Java，Go，Python和.NET等其他语言出现在端口上，并且很可能在不久的将来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出现</a>其他实现。 大约一年以来，我们已经将它用于多种产品的生产中，很难用言语描述他在使用Seneca和我们的自行车后对我们的幸福程度。 我们开箱即用地提供了我们需要的一切：收集指标，缓存，平衡，容错，选择传输，参数验证，日志记录，简洁的方法声明，多种服务间交互方式，mixin等。 现在按顺序。 <br><a name="habracut"></a><br><h2> 引言 </h2><br> 实际上，该框架由三个组件组成（实际上，没有，但是您将在下面了解更多信息）。 <br><br><h4> 运输者 </h4><br> 负责发现服务和它们之间的通信。 这个接口非常需要您可以实现自己，也可以使用框架本身一部分的现成实现。 包装盒中提供7种传输方式：TCP，Redis，AMQP，MQTT，NATS，NATS Streaming，Kafka。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>您可以看到更多。 我们使用Redis传输，但是我们计划从实验状态退出时切换到TCP。 <br><br> 实际上，在编写代码时，我们不会与此组件进行交互。 您只需要知道他是什么。 使用的传输在配置中指定。 因此，要从一种传输方式切换到另一种传输方式，只需更改配置即可。 仅此而已。 像这样： <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./moleculer.config.js module.exports = { transporter: 'redis://:pa$$w0rd@127.0.0.1:6379', // ...   }</span></span></code> </pre> <br> 数据默认为JSON格式。 但是您可以使用任何东西：Avro，MsgPack，Notepack，ProtoBuf，Thrift等。 <br><br><h4> 服务专区 </h4><br> 我们在编写微服务时从中继承的类。 <br><br> 这是没有方法的最简单的服务，但是，其他服务会检测到该方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./services/telemetry/telemetry.service.js const { Service } = require('moleculer'); module.exports = class TelemetryService extends Service { constructor(broker) { super(broker); this.parseServiceSchema({ name: 'telemetry', }); } };</span></span></code> </pre><br><br><h4> 服务经纪人 </h4><br> 框架的核心。 <br><br><img src="https://habrastorage.org/webt/t7/wp/qo/t7wpqorpz4zhmczcvir_fs9cems.png"><br><br> 夸张地说，我们可以说这是运输和服务之间的一层。 当一个服务想要以某种方式与另一个服务交互时，它通过代理进行操作（下面将给出示例）。 代理从事负载平衡（支持几种策略，默认情况下包括自定义策略-循环），同时考虑实时服务，这些服务中的可用方法等。 为此，ServiceBroker在幕后使用了另一个组件-注册表，但是我不会在此赘述，因为我们不需要相识。 <br><br> 拥有经纪人给我们带来了极为方便的事情。 现在，我将尝试解释，但我不得不稍稍退后一步。 在框架的上下文中，存在诸如节点之类的东西。 简单来说，节点是操作系统中的一个进程（例如，当我们在控制台中输入“ node index.js”时会发生什么）。 每个节点都是具有一组一个或多个微服务的ServiceBroker。 是的，您没听错。 我们可以按照自己的意愿建立服务堆栈。 为什么这样方便？ 为了进行开发，我们启动了一个节点，在该节点中一次启动所有微服务（每个微服务一个），例如，系统中只有一个进程能够非常轻松地连接hotreload。 在生产中-每个服务实例的单独节点。 好吧，或者混合使用，当一部分服务在一个节点中，一部分在另一节点中，依此类推（尽管我不知道为什么这样做，只是为了了解您也可以这样做）。 <br><br><div class="spoiler">  <b class="spoiler_title">这就是我们的index.js的样子</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { resolve } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ServiceBroker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moleculer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./moleculer.config.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { SERVICES, NODE_ENV, } = process.env; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> broker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceBroker(config); broker.loadServices( resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'services'</span></span>), SERVICES ? <span class="hljs-string"><span class="hljs-string">`*/@(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVICES.split(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">','</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).map(i =&gt; i.trim()).join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'|'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">).service.js`</span></span> : <span class="hljs-string"><span class="hljs-string">'*/*.service.js'</span></span>, ); broker.start().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NODE_ENV === <span class="hljs-string"><span class="hljs-string">'development'</span></span>) { broker.repl(); } });</code> </pre><br></div></div><br> 在没有环境变量的情况下，将加载目录中的所有服务，否则将通过掩码加载。 顺便说一句，broker.repl（）是框架的另一个便捷功能。 在开发模式下启动时，我们在控制台中在那里有一个用于调用方法的接口（例如，您将通过微服务中的邮递员通过http进行通信），这在这里更加方便：该接口位于同一控制台中他们在npm开始的地方。 <br><br><h2> 服务间交互 </h2><br> 它以三种方式执行： <br><br><h4> 叫 </h4><br> 最常用的。 发出请求，收到响应（或错误）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   "report",     "csv". async getCsvReport({ jobId }) { const rows = []; // ... return this.broker.call('csv.stringify', { rows }); }</span></span></code> </pre><br> 如上所述，通话会自动平衡。 我们只增加了所需的服务实例数，框架本身将进行平衡。 <br><br><img src="https://habrastorage.org/webt/jl/nj/r4/jlnjr4zxz943pfzpc9epoxpbgw8.gif"><br><br><h4> 发射 </h4><br> 当我们只想通知其他服务某个事件但不需要结果时使用。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   "user"    . async registerUser({ email, password }) { // ... this.broker.emit('user_registered', { email }); return true; }</span></span></code> </pre><br> 其他服务可以订阅此事件，并做出相应的响应。  （可选）第三个参数，您可以显式设置可用于接收此事件的服务。 <br><br> 重要的一点是，该事件将仅接收每种服务类型的一个实例，即 如果我们有10个“邮件”和5个“订阅”服务订阅了此事件，那么实际上只有2个副本将收到它-一个“邮件”和一个“订阅”。 示意图如下所示： <br><br><img src="https://habrastorage.org/webt/yf/fg/oj/yffgoj5ce8pzhcfdl_rdian6hpg.gif"><br><br><h4> 广播的 </h4><br> 与发出相同，但没有限制。 所有10个邮件和5个订阅服务都将捕获此事件。 <br><br><h2> 参数验证 </h2><br> 默认情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最快验证器</a>用于验证参数，这似乎非常快。 但是，如果您需要更高级的验证，则没有其他方法可以阻止使用其他任何方法，例如使用同一个joi。 <br><br> 当我们编写服务时，我们继承自Service基类，在其中声明带有业务逻辑的方法，但是这些方法是“私有的”，除非我们明确地想要在内部声明它们，否则不能从外部（从另一个服务）调用它们。服务初始化期间的特殊操作部分（在框架上下文中，服务的公共方法称为操作）。 <br><br><div class="spoiler">  <b class="spoiler_title">带有验证的方法声明的示例</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'job'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">update</span></span>: { <span class="hljs-attr"><span class="hljs-attr">params</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">convert</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">empty</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">optional</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">optional</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update(ctx.params); }, }, }, }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> update({ id, name, data }) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br></div></div><br><h2> 混合蛋白 </h2><br> 例如，用于初始化数据库连接。 避免服务之间的代码重复。 <br><br><div class="spoiler">  <b class="spoiler_title">示例mixin初始化与Redis的连接</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ioredis'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ key = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'redis'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, options } = {}</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">settings</span></span>: { [key]: options, }, created() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Redis(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.settings[key]); }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> started() { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key].connect(); }, stopped() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key].disconnect(); }, });</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">在服务中使用mixin</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Service, Errors } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moleculer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../mixins/redis'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../mixins/server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, } = process.env; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redisOpts = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: REDIS_HOST, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: REDIS_PORT, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: REDIS_PASSWORD, <span class="hljs-attr"><span class="hljs-attr">lazyConnect</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'auth'</span></span>, <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [redis({ <span class="hljs-attr"><span class="hljs-attr">options</span></span>: redisOpts }), server({ router })], }); } }</code> </pre> <br></div></div><br><h2> 快取 </h2><br> 方法调用（动作）可以通过几种方式进行缓存：LRU，内存，Redis。  （可选）您可以指定将缓存哪些键调用（默认情况下，对象哈希用作缓存键）以及使用哪个TTL。 <br><br><div class="spoiler">  <b class="spoiler_title">缓存方法声明示例</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InventoryService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'inventory'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">getInventory</span></span>: { <span class="hljs-attr"><span class="hljs-attr">params</span></span>: { <span class="hljs-attr"><span class="hljs-attr">steamId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">pattern</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^76\d{15}$/</span></span> }, <span class="hljs-attr"><span class="hljs-attr">appId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">integer</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">contextId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">integer</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, }, <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [<span class="hljs-string"><span class="hljs-string">'steamId'</span></span>, <span class="hljs-string"><span class="hljs-string">'appId'</span></span>, <span class="hljs-string"><span class="hljs-string">'contextId'</span></span>], <span class="hljs-attr"><span class="hljs-attr">ttl</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, }, }, }); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br></div></div><br> 缓存方法是通过ServiceBroker配置设置的。 <br><br><h2> 记录中 </h2><br> 但是，这里的一切也非常简单。 有一个相当不错的内置记录器，可以写入控制台，可以指定自定义格式。 没有什么可以阻止窃取任何其他流行的记录器了，无论是温斯顿还是本扬。 详细的手册在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a> 。 就个人而言，我们使用内置的记录器，将垃圾邮件进入JSON控制台的几行代码的自定义格式化程序在产品中截断，然后使用docker日志驱动程序进入Graylog。 <br><br><h2> 指标 </h2><br> 如果需要，您可以收集每种方法的指标，并使用zipkin进行跟踪。 这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是</a>可用的出口商<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>完整列表。 当前有五个：Zipkin，Jaeger，Prometheus，Elastic和Console。 声明方法（动作）时，它与缓存一样配置。 <br><br> 可以在Github中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此链接</a>上查看使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">elastic-apm-node</a>模块的elasticsearch + kibana捆绑包的可视化示例。 <br><br> 当然，最简单的方法是使用console选项。 看起来像这样： <br><br><img src="https://habrastorage.org/webt/eu/dq/20/eudq20mgo7wtbqmstlp_aiidicy.png"><br><br><h2> 容错能力 </h2><br> 该框架具有内置的断路器，可通过ServiceBroker设置进行控制。 如果任何服务失败，并且这些失败的次数超过特定阈值，那么它将被标记为不正常，对它的请求将受到严格限制，直到不再出错为止。 <br><br> 另外，如果我们假设该方法可能会失败，例如，发送缓存的数据或存根，则每个方法（操作）还可以分别进行调整。 <br><br><h2> 结论 </h2><br> 对我来说，这个框架的引入使人呼吸新鲜，节省了大量的代码（除了微服务架构是一个大的事实）和循环，使编写下一个微服务变得简单而透明。 它没有多余的内容，它既简单又非常灵活，您可以在阅读文档后一两个小时内编写第一个服务。 如果这些材料对您有用，我将很高兴，并且在您的下一个项目中，您将像我们一样尝试这个奇迹（并且从未后悔）。 对所有人都好！ <br><br> 另外，如果您对此框架感兴趣，请加入Telegram中的聊天室- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@moleculerchat</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439810/">https://habr.com/ru/post/zh-CN439810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439794/index.html">背痛-从现代医学的角度理解</a></li>
<li><a href="../zh-CN439796/index.html">Spring Boot 2：他们在发行说明中没有写的内容</a></li>
<li><a href="../zh-CN439804/index.html">单元测试之禅</a></li>
<li><a href="../zh-CN439806/index.html">本地Docker容器的有效SSL域名</a></li>
<li><a href="../zh-CN439808/index.html">最大的望远镜。 从笔记本电脑和眼睛到340万像素相机和数据中心。 第一部分</a></li>
<li><a href="../zh-CN439812/index.html">Kaggle在产品中实现CV的方法：您无法实施削减</a></li>
<li><a href="../zh-CN439818/index.html">实际制造业中设计方法的特点</a></li>
<li><a href="../zh-CN439822/index.html">为Ensoniq EPS16 +和ASR10合成器/采样器创建替代显示</a></li>
<li><a href="../zh-CN439824/index.html">JavaScript框架何时会消失？</a></li>
<li><a href="../zh-CN439826/index.html">禁用模拟。 电视会怎样？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>