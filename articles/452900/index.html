<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñäÔ∏è üîß üïó √çndices en PostgreSQL - 9 (BRIN) üë©üèº‚Äç‚öïÔ∏è ‚óÄÔ∏è üö∂üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los art√≠culos anteriores discutimos el motor de indexaci√≥n PostgreSQL, la interfaz de los m√©todos de acceso y los siguientes m√©todos: √≠ndices hash ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices en PostgreSQL - 9 (BRIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452900/">  En los art√≠culos anteriores discutimos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexaci√≥n</a> PostgreSQL, la interfaz de los m√©todos de acceso y los siguientes m√©todos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√≠ndices hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rboles B</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GIN</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RUM</a> .  El tema de este art√≠culo son los √≠ndices BRIN. <br><br><h1>  Brin </h1><br><h2>  Concepto general </h2><br>  A diferencia de los √≠ndices con los que ya nos hemos reunido, la idea de BRIN es evitar mirar filas definitivamente inadecuadas en lugar de encontrar r√°pidamente las que coincidan.  Este es siempre un √≠ndice inexacto: no contiene TID de filas de tabla en absoluto. <br><br>  Simpl√≠sticamente, BRIN funciona bien para columnas donde los valores se correlacionan con su ubicaci√≥n f√≠sica en la tabla.  En otras palabras, si una consulta sin la cl√°usula ORDER BY devuelve los valores de la columna pr√°cticamente en orden creciente o decreciente (y no hay √≠ndices en esa columna). <br><br>  Este m√©todo de acceso se cre√≥ en el √°mbito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Axle</a> , el proyecto europeo para bases de datos anal√≠ticas extremadamente grandes, con un ojo puesto en tablas de varios terabytes o docenas de terabytes de gran tama√±o.  Una caracter√≠stica importante de BRIN que nos permite crear √≠ndices en tales tablas es un tama√±o peque√±o y costos generales m√≠nimos de mantenimiento. <br><br>  Esto funciona de la siguiente manera.  La tabla se divide en <em>rangos de</em> varias p√°ginas (o varios bloques, que es lo mismo); de ah√≠ el nombre: √çndice de rango de bloques, BRIN.  El √≠ndice almacena <em>informaci√≥n resumida</em> sobre los datos en cada rango.  Como regla, estos son los valores m√≠nimos y m√°ximos, pero resulta ser diferente, como se muestra m√°s adelante.  Suponga que se realiza una consulta que contiene la condici√≥n para una columna;  si los valores buscados no entran en el intervalo, se puede omitir todo el rango;  pero si se obtienen, todas las filas en todos los bloques deber√°n revisarse para elegir las que coincidan entre ellas. <br><br>  No ser√° un error tratar a BRIN no como un √≠ndice, sino como un acelerador de la exploraci√≥n secuencial.  Podemos considerar BRIN como una alternativa a la partici√≥n si consideramos cada rango como una partici√≥n "virtual". <br><br>  Ahora analicemos la estructura del √≠ndice con m√°s detalle. <br><a name="habracut"></a><br><h2>  Estructura </h2><br>  La primera p√°gina (m√°s exactamente, cero) contiene los metadatos. <br><br>  Las p√°ginas con la informaci√≥n de resumen se encuentran en un cierto desplazamiento de los metadatos.  Cada fila de √≠ndice en esas p√°ginas contiene informaci√≥n de resumen en un rango. <br><br>  Entre la meta p√°gina y los datos de resumen, se encuentran las p√°ginas con el <em>mapa de rango inverso</em> (abreviado como "revmap").  En realidad, esta es una matriz de punteros (TID) a las filas de √≠ndice correspondientes. <br><br><img src="https://habrastorage.org/webt/nr/pm/s9/nrpms932o5clzubwymywxtud6q4.png"><br><br>  Para algunos rangos, el puntero en "revmap" puede conducir a una fila sin √≠ndice (una est√° marcada en gris en la figura).  En tal caso, se considera que el rango a√∫n no tiene informaci√≥n de resumen. <br><br><h2>  Escaneando el √≠ndice </h2><br>  ¬øC√≥mo se usa el √≠ndice si no contiene referencias a las filas de la tabla?  Este m√©todo de acceso ciertamente no puede devolver las filas TID por TID, pero puede construir un mapa de bits.  Puede haber dos tipos de p√°ginas de mapa de bits: precisas, en la fila, e imprecisas, en la p√°gina.  Se utiliza un mapa de bits inexacto. <br><br>  El algoritmo es simple.  El mapa de rangos se escanea secuencialmente (es decir, los rangos se procesan en el orden de su ubicaci√≥n en la tabla).  Los punteros se utilizan para determinar filas de √≠ndice con informaci√≥n de resumen en cada rango.  Si un rango no contiene el valor buscado, se omite y si puede contener el valor (o la informaci√≥n de resumen no est√° disponible), todas las p√°ginas del rango se agregan al mapa de bits.  El mapa de bits resultante se usa como de costumbre. <br><br><h2>  Actualizando el √≠ndice </h2><br>  Es m√°s interesante c√≥mo se actualiza el √≠ndice cuando se cambia la tabla. <br><br>  Al <strong>agregar</strong> una nueva versi√≥n de una fila a una p√°gina de tabla, determinamos en qu√© rango est√° contenido y utilizamos el mapa de rangos para encontrar la fila de √≠ndice con la informaci√≥n de resumen.  Todas estas son operaciones aritm√©ticas simples.  Deje, por ejemplo, que el tama√±o de un rango sea cuatro y en la p√°gina 13, se produce una versi√≥n de fila con el valor de 42.  El n√∫mero del rango (comenzando con cero) es 13/4 = 3, por lo tanto, en "revmap" tomamos el puntero con el desplazamiento de 3 (su n√∫mero de orden es cuatro). <br><br>  El valor m√≠nimo para este rango es 31, y el m√°ximo es 40. Dado que el nuevo valor de 42 est√° fuera del intervalo, actualizamos el valor m√°ximo (ver la figura).  Pero si el nuevo valor a√∫n est√° dentro de los l√≠mites almacenados, el √≠ndice no necesita actualizarse. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/6ce/e4c/ba76cee4c3d40e9f428954d0478ecee0.png"><br><br>  Todo esto se relaciona con la situaci√≥n cuando la nueva versi√≥n de la p√°gina ocurre en un rango para el cual la informaci√≥n de resumen est√° disponible.  Cuando se crea el √≠ndice, la informaci√≥n de resumen se calcula para todos los rangos disponibles, pero mientras la tabla se expande a√∫n m√°s, pueden aparecer nuevas p√°ginas que caen fuera de los l√≠mites.  Hay dos opciones disponibles aqu√≠: <br><br><ol><li>  Por lo general, el √≠ndice no se actualiza de inmediato.  Esto no es un gran problema: como ya se mencion√≥, al escanear el √≠ndice, se examinar√° todo el rango.  La actualizaci√≥n real se realiza durante el "vac√≠o", o se puede hacer manualmente llamando a la funci√≥n "brin_summarize_new_values". </li><li> Si creamos el √≠ndice con el par√°metro "autosummarize", la actualizaci√≥n se realizar√° de inmediato.  Pero cuando las p√°ginas del rango se rellenan con nuevos valores, las actualizaciones pueden ocurrir con demasiada frecuencia, por lo tanto, este par√°metro est√° desactivado de forma predeterminada. </li></ol><br>  Cuando ocurren nuevos rangos, el tama√±o de "revmap" puede aumentar.  Siempre que el mapa, ubicado entre la meta p√°gina y los datos de resumen, necesite ser extendido por otra p√°gina, las versiones de fila existentes se mueven a otras p√°ginas.  Por lo tanto, el mapa de rangos siempre se encuentra entre la meta p√°gina y los datos de resumen. <br><br>  Cuando se <strong>elimina</strong> una fila, ... no pasa nada.  Podemos notar que a veces se eliminar√° el valor m√≠nimo o m√°ximo, en cuyo caso el intervalo podr√≠a reducirse.  Pero para detectar esto, tendr√≠amos que leer todos los valores en el rango, y esto es costoso. <br><br>  La exactitud del √≠ndice no se ve afectada, pero la b√∫squeda puede requerir examinar m√°s rangos de los que realmente se necesitan.  En general, la informaci√≥n resumida puede recalcularse manualmente para dicha zona (llamando a las funciones "brin_desummarize_range" y "brin_summarize_new_values"), pero ¬øc√≥mo podemos detectar tal necesidad?  De todos modos, no hay un procedimiento convencional disponible para este fin. <br><br>  Finalmente, <strong>actualizar una fila</strong> es solo una eliminaci√≥n de la versi√≥n desactualizada y la adici√≥n de una nueva. <br><br><h2>  Ejemplo </h2><br>  Intentemos construir nuestro propio mini almac√©n de datos para los datos de las tablas de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de demostraci√≥n</a> .  Supongamos que, para los informes de BI, se necesita una tabla desnormalizada para reflejar los vuelos que partieron de un aeropuerto o aterrizaron en el aeropuerto con la precisi√≥n de un asiento en la cabina.  Los datos de cada aeropuerto se agregar√°n a la tabla una vez al d√≠a, cuando sea medianoche en la zona horaria correspondiente.  Los datos no ser√°n actualizados ni eliminados. <br><br>  La tabla tendr√° el siguiente aspecto: <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> flights_bi( airport_code <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>), airport_coord <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- geo coordinates of airport airport_utc_offset interval, -- time zone flight_no char(6), -- flight number flight_type text. -- flight type: departure / arrival scheduled_time timestamptz, -- scheduled departure/arrival time of flight actual_time timestamptz, -- actual time of flight aircraft_code char(3), seat_no varchar(4), -- seat number fare_conditions varchar(10), -- travel class passenger_id varchar(20), passenger_name text );</span></span></code> </pre> <br>  Podemos simular el procedimiento de cargar los datos usando bucles anidados: uno externo por d√≠as (consideraremos <a href="">una base de datos grande</a> , por lo tanto 365 d√≠as) y un bucle interno por zonas horarias (de UTC + 02 a UTC + 12) .  La consulta es bastante larga y no es de particular inter√©s, as√≠ que la esconder√© debajo del spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Simulaci√≥n de cargar los datos al almacenamiento.</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-symbol"><span class="pgsql"><span class="hljs-symbol">&lt;&lt;local&gt;&gt;</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">DECLARE</span></span></span><span class="pgsql"> curdate </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql"> := (</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> min(scheduled_departure) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> flights); utc_offset </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (curdate &lt;= bookings.now()::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> utc_offset := </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'12 hours'</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (utc_offset &gt;= </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'2 hours'</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> flights_bi </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WITH</span></span></span><span class="pgsql"> flight ( airport_code, airport_coord, flight_id, flight_no, scheduled_time, actual_time, aircraft_code, flight_type ) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ( </span><span class="hljs-comment"><span class="pgsql"><span class="hljs-comment">--  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_departure, f.actual_departure, f.aircraft_code, 'departure' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.departure_airport AND f.actual_departure IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_departure)::date = curdate UNION ALL --  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_arrival, f.actual_arrival, f.aircraft_code, 'arrival' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.arrival_airport AND f.actual_arrival IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_arrival)::date = curdate ) SELECT f.airport_code, f.airport_coord, local.utc_offset, f.flight_no, f.flight_type, f.scheduled_time, f.actual_time, f.aircraft_code, s.seat_no, s.fare_conditions, t.passenger_id, t.passenger_name FROM flight f JOIN seats s ON s.aircraft_code = f.aircraft_code LEFT JOIN boarding_passes bp ON bp.flight_id = f.flight_id AND bp.seat_no = s.seat_no LEFT JOIN ticket_flights tf ON tf.ticket_no = bp.ticket_no AND tf.flight_id = bp.flight_id LEFT JOIN tickets t ON t.ticket_no = tf.ticket_no; RAISE NOTICE '%, %', curdate, utc_offset; utc_offset := utc_offset - interval '1 hour'; END LOOP; curdate := curdate + 1; END LOOP; END; $$</span></span></span></span>;</code> </pre><br></div></div><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi;</code> </pre><pre> <code class="plaintext hljs"> count ---------- 30517076 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 4127 MB (1 row)</code> </pre><br>  Tenemos 30 millones de filas y 4 GB.  No es un tama√±o tan grande, pero lo suficientemente bueno para una computadora port√°til: el escaneo secuencial me llev√≥ unos 10 segundos. <br><br><h3>  ¬øEn qu√© columnas debemos crear el √≠ndice? </h3><br>  Dado que los √≠ndices BRIN tienen un tama√±o peque√±o y los costos generales moderados y las actualizaciones ocurren con poca frecuencia, si es que hay alguna, surge una rara oportunidad de construir muchos √≠ndices "por si acaso", por ejemplo, en todos los campos en los que los usuarios analistas pueden crear sus consultas ad-hoc .  No ser√° √∫til, no importa, pero incluso un √≠ndice que no sea muy eficiente funcionar√° mejor que la exploraci√≥n secuencial con seguridad.  Por supuesto, hay campos en los que es absolutamente in√∫til construir un √≠ndice;  El sentido com√∫n puro los impulsar√°. <br><br>  Pero deber√≠a ser extra√±o limitarnos a este consejo, por lo tanto, tratemos de establecer un criterio m√°s preciso. <br><br>  Ya hemos mencionado que los datos deben estar algo correlacionados con su ubicaci√≥n f√≠sica.  Aqu√≠ tiene sentido recordar que PostgreSQL re√∫ne estad√≠sticas de columna de tabla, que incluyen el valor de correlaci√≥n.  El planificador usa este valor para seleccionar entre un escaneo de √≠ndice regular y un escaneo de mapa de bits, y podemos usarlo para estimar la aplicabilidad del √≠ndice BRIN. <br><br>  En el ejemplo anterior, los datos se ordenan evidentemente por d√≠as (por "horario_programado", as√≠ como por "tiempo_real", no hay mucha diferencia).  Esto se debe a que cuando se agregan filas a la tabla (sin eliminaciones ni actualizaciones), se presentan en el archivo una tras otra.  En la simulaci√≥n de la carga de datos, ni siquiera utilizamos la cl√°usula ORDER BY, por lo tanto, las fechas dentro de un d√≠a pueden, en general, mezclarse de manera arbitraria, pero el orden debe estar en su lugar.  Vamos a ver esto: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nulls last</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation --------------------+------------- scheduled_time | 0.999994 actual_time | 0.999994 fare_conditions | 0.796719 flight_type | 0.495937 airport_utc_offset | 0.438443 aircraft_code | 0.172262 airport_code | 0.0543143 flight_no | 0.0121366 seat_no | 0.00568042 passenger_name | 0.0046387 passenger_id | -0.00281272 airport_coord | (12 rows)</code> </pre><br>  El valor que no est√° demasiado cerca de cero (idealmente, cerca de m√°s menos menos, como en este caso), nos dice que el √≠ndice BRIN ser√° apropiado. <br><br>  La clase de viaje "fare_condition" (la columna contiene tres valores √∫nicos) y el tipo de vuelo "flight_type" (dos valores √∫nicos) aparecieron inesperadamente en el segundo y tercer lugar.  Esto es una ilusi√≥n: formalmente, la correlaci√≥n es alta, mientras que en varias p√°ginas sucesivas se encontrar√°n todos los valores posibles, lo que significa que BRIN no servir√° de nada. <br><br>  La zona horaria "airport_utc_offset" va a continuaci√≥n: en el ejemplo considerado, dentro de un ciclo de un d√≠a, los aeropuertos se ordenan por zonas horarias "por construcci√≥n". <br><br>  Son estos dos campos, hora y zona horaria, con los que experimentaremos m√°s. <br><br><h3>  Posible debilitamiento de la correlaci√≥n. </h3><br>  La correlaci√≥n que se coloca "por construcci√≥n" se puede debilitar f√°cilmente cuando se modifican los datos.  Y el asunto aqu√≠ no est√° en un cambio a un valor particular, sino en la estructura del control de concurrencia de varias versiones: la versi√≥n de fila obsoleta se elimina en una p√°gina, pero se puede insertar una nueva versi√≥n siempre que haya espacio libre disponible.  Debido a esto, las filas enteras se mezclan durante las actualizaciones. <br><br>  Podemos controlar parcialmente este efecto reduciendo el valor del par√°metro de almacenamiento "factor de relleno" y de esta manera dejando espacio libre en una p√°gina para futuras actualizaciones.  ¬øPero queremos aumentar el tama√±o de una mesa ya enorme?  Adem√°s, esto no resuelve el problema de las eliminaciones: tambi√©n "establecen trampas" para las nuevas filas al liberar el espacio en alg√∫n lugar dentro de las p√°ginas existentes.  Debido a esto, las filas que de otro modo llegar√≠an al final del archivo, se insertar√°n en alg√∫n lugar arbitrario. <br><br>  Por cierto, este es un hecho curioso.  Dado que el √≠ndice BRIN no contiene referencias a las filas de la tabla, su disponibilidad no deber√≠a obstaculizar las actualizaciones HOT, pero lo hace. <br><br>  Por lo tanto, BRIN est√° dise√±ado principalmente para tablas de tama√±os grandes e incluso enormes que no se actualizan en absoluto o se actualizan muy ligeramente.  Sin embargo, se adapta perfectamente a la adici√≥n de nuevas filas (al final de la tabla).  Esto no es sorprendente, ya que este m√©todo de acceso se cre√≥ con miras a almacenes de datos e informes anal√≠ticos. <br><br><h3>  ¬øQu√© tama√±o de rango necesitamos seleccionar? </h3><br>  Si tratamos con una tabla de terabytes, nuestra principal preocupaci√≥n al seleccionar el tama√±o de un rango probablemente no sea hacer que el √≠ndice BRIN sea demasiado grande.  Sin embargo, en nuestra situaci√≥n, podemos permitirnos analizar los datos con mayor precisi√≥n. <br><br>  Para hacer esto, podemos seleccionar valores √∫nicos de una columna y ver en cu√°ntas p√°ginas aparecen.  La localizaci√≥n de los valores aumenta las posibilidades de √©xito en la aplicaci√≥n del √≠ndice BRIN.  Adem√°s, el n√∫mero de p√°ginas encontradas indicar√° el tama√±o de un rango.  Pero si el valor se "extiende" por todas las p√°ginas, BRIN es in√∫til. <br><br>  Por supuesto, debemos usar esta t√©cnica vigilando la estructura interna de los datos.  Por ejemplo, no tiene sentido considerar cada fecha (m√°s exactamente, una marca de tiempo, que tambi√©n incluye la hora) como un valor √∫nico: necesitamos redondearlo a d√≠as. <br><br>  T√©cnicamente, este an√°lisis se puede hacer mirando el valor de la columna oculta "ctid", que proporciona el puntero a una versi√≥n de fila (TID): el n√∫mero de la p√°gina y el n√∫mero de la fila dentro de la p√°gina.  Desafortunadamente, no existe una t√©cnica convencional para descomponer TID en sus dos componentes, por lo tanto, tenemos que emitir tipos a trav√©s de la representaci√≥n de texto: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> min(numblk), round(avg(numblk)) avg, max(numblk) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> scheduled_time::<span class="hljs-type"><span class="hljs-type">date</span></span> ) t;</code> </pre><pre> <code class="plaintext hljs"> min | avg | max ------+------+------ 1192 | 1500 | 1796 (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname = <span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 528172 (1 row)</code> </pre><br>  Podemos ver que cada d√≠a se distribuye en las p√°ginas de manera bastante uniforme, y los d√≠as est√°n ligeramente mezclados entre s√≠ (1500 y veces 365 = 547500, que es solo un poco m√°s grande que el n√∫mero de p√°ginas en la tabla 528172).  De todos modos, esto est√° claro "por construcci√≥n". <br><br>  La informaci√≥n valiosa aqu√≠ es un n√∫mero espec√≠fico de p√°ginas.  Con un tama√±o de rango convencional de 128 p√°ginas, cada d√≠a ocupar√° 9-14 rangos.  Esto parece realista: con una consulta para un d√≠a espec√≠fico, podemos esperar un error de alrededor del 10%. <br><br>  Probemos <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(scheduled_time);</code> </pre><br>  El tama√±o del √≠ndice es tan peque√±o como 184 KB: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 184 kB (1 row)</code> </pre><br>  En este caso, apenas tiene sentido aumentar el tama√±o de un rango a costa de perder la precisi√≥n.  Pero podemos reducir el tama√±o si es necesario, y la precisi√≥n, por el contrario, aumentar√° (junto con el tama√±o del √≠ndice). <br><br>  Ahora veamos las zonas horarias.  Aqu√≠ tampoco podemos utilizar un enfoque de fuerza bruta.  Todos los valores deben dividirse por el n√∫mero de ciclos de d√≠a, ya que la distribuci√≥n se repite dentro de cada d√≠a.  Adem√°s, dado que solo hay algunas zonas horarias, podemos ver toda la distribuci√≥n: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_utc_offset, count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>])/<span class="hljs-number"><span class="hljs-number">365</span></span> numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> airport_utc_offset <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_utc_offset | numblk --------------------+-------- 12:00:00 | 6 06:00:00 | 8 02:00:00 | 10 11:00:00 | 13 08:00:00 | 28 09:00:00 | 29 10:00:00 | 40 04:00:00 | 47 07:00:00 | 110 05:00:00 | 231 03:00:00 | 932 (11 rows)</code> </pre><br>  En promedio, los datos para cada zona horaria ocupan 133 p√°ginas por d√≠a, pero la distribuci√≥n es altamente no uniforme: Petropavlovsk-Kamchatskiy y Anadyr se ajustan a tan solo seis p√°ginas, mientras que Mosc√∫ y su vecindario requieren cientos de ellas.  El tama√±o predeterminado de un rango no es bueno aqu√≠;  establezcamos, por ejemplo, cuatro p√°ginas. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(airport_utc_offset) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">4</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_airport_utc_offset_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 6528 kB (1 row)</code> </pre><br><h2>  Plan de ejecucion </h2><br>  Veamos c√≥mo funcionan nuestros √≠ndices.  Seleccionemos alg√∫n d√≠a, digamos, hace una semana (en la base de datos de demostraci√≥n, "hoy" est√° determinado por la funci√≥n "booking.now"): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=10.282..94.328 rows=83954 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 12045 Heap Blocks: lossy=1664 -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=3.013..3.013 rows=16640 loops=1) Index Cond: ... Planning time: 0.375 ms Execution time: 97.805 ms</code> </pre><br>  Como podemos ver, el planificador utiliz√≥ el √≠ndice creado.  ¬øQu√© tan exacto es?  La relaci√≥n entre el n√∫mero de filas que cumplen las condiciones de consulta ("filas" del nodo Bitmap Heap Scan) y el n√∫mero total de filas devueltas usando el √≠ndice (el mismo valor m√°s las filas eliminadas por la comprobaci√≥n de √≠ndice) nos informa sobre esto.  En este caso 83954 / (83954 + 12045), que es aproximadamente el 90%, como se esperaba (este valor cambiar√° de un d√≠a para otro). <br><br>  ¬øDe d√≥nde se origina el n√∫mero 16640 en las "filas reales" del nodo Escaneo de √≠ndice de mapa de bits?  La cuesti√≥n es que este nodo del plan construye un mapa de bits inexacto (p√°gina por p√°gina) y desconoce por completo cu√°ntas filas tocar√° el mapa de bits, mientras que algo debe mostrarse.  Por lo tanto, en la desesperaci√≥n se supone que una p√°gina contiene 10 filas.  El mapa de bits contiene 1664 p√°ginas en total (este valor se muestra en "Heap Blocks: lossy = 1664");  entonces, obtenemos 16640. En total, este es un n√∫mero sin sentido, al que no debemos prestarle atenci√≥n. <br><br>  ¬øQu√© hay de los aeropuertos?  Por ejemplo, tomemos la zona horaria de Vladivostok, que ocupa 28 p√°ginas al d√≠a: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=75.151..192.210 rows=587353 loops=1) Recheck Cond: (airport_utc_offset = '08:00:00'::interval) Rows Removed by Index Recheck: 191318 Heap Blocks: lossy=13380 -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=74.999..74.999 rows=133800 loops=1) Index Cond: (airport_utc_offset = '08:00:00'::interval) Planning time: 0.168 ms Execution time: 212.278 ms</code> </pre><br>  El planificador nuevamente utiliza el √≠ndice BRIN creado.  La precisi√≥n es peor (alrededor del 75% en este caso), pero esto se espera ya que la correlaci√≥n es menor. <br><br>  Varios √≠ndices BRIN (como cualquiera de los otros) ciertamente se pueden unir a nivel de mapa de bits.  Por ejemplo, los siguientes son los datos en la zona horaria seleccionada durante un mes (observe el nodo "BitmapAnd"): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">60</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 days'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=62.046..113.849 rows=48154 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 18856 Heap Blocks: lossy=1152 -&gt; BitmapAnd (actual time=61.777..61.777 rows=0 loops=1) -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=5.490..5.490 rows=435200 loops=1) Index Cond: ... -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=55.068..55.068 rows=133800 loops=1) Index Cond: ... Planning time: 0.408 ms Execution time: 115.475 ms</code> </pre><br><h3>  Comparaci√≥n con b-tree </h3><br>  ¬øQu√© sucede si creamos un √≠ndice B-tree regular en el mismo campo que BRIN? <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_scheduled_time_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi(scheduled_time); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_btree'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 654 MB (1 row)</code> </pre><br>  ¬°Parec√≠a ser <em>varios miles de veces m√°s grande</em> que nuestro BRIN!  Sin embargo, la consulta se realiza un poco m√°s r√°pido: el planificador utiliz√≥ estad√≠sticas para descubrir que los datos est√°n ordenados f√≠sicamente y no es necesario para construir un mapa de bits y, principalmente, que no es necesario volver a verificar la condici√≥n del √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------- Index Scan using flights_bi_scheduled_time_btree on flights_bi (actual time=0.099..79.416 rows=83954 loops=1) Index Cond: ... Planning time: 0.500 ms Execution time: 85.044 ms</code> </pre><br>  Eso es lo maravilloso de BRIN: sacrificamos la eficiencia, pero ganamos mucho espacio. <br><br><h2>  Clases de operador </h2><br><h3>  minmax </h3><br>  Para los tipos de datos cuyos valores se pueden comparar entre s√≠, la informaci√≥n resumida consta de <em>los valores m√≠nimos y m√°ximos</em> .  Los nombres de las clases de operador correspondientes contienen "minmax", por ejemplo, "date_minmax_ops".  En realidad, estos son tipos de datos que est√°bamos considerando hasta ahora, y la mayor√≠a de los tipos son de este tipo. <br><br><h3>  inclusivo </h3><br>  Los operadores de comparaci√≥n se definen no para todos los tipos de datos.  Por ejemplo, no est√°n definidos para puntos (tipo "punto"), que representan las coordenadas geogr√°ficas de los aeropuertos.  Por cierto, es por esta raz√≥n que las estad√≠sticas no muestran la correlaci√≥n para esta columna. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> attname = <span class="hljs-string"><span class="hljs-string">'airport_coord'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------------+------------- airport_coord | (1 row)</code> </pre><br>  Pero muchos de estos tipos nos permiten introducir un concepto de "√°rea delimitadora", por ejemplo, un rect√°ngulo delimitador para formas geom√©tricas.  Discutimos en detalle c√≥mo el √≠ndice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> usa esta caracter√≠stica.  De manera similar, BRIN tambi√©n permite recopilar informaci√≥n de resumen en columnas que tienen tipos de datos como estos: <em>el √°rea delimitadora para todos los valores dentro de un rango</em> es solo el valor de resumen. <br><br>  A diferencia de GiST, el valor de resumen para BRIN debe ser del mismo tipo que los valores que se indexan.  Por lo tanto, no podemos construir el √≠ndice para los puntos, aunque est√° claro que las coordenadas podr√≠an funcionar en BRIN: la longitud est√° estrechamente relacionada con la zona horaria.  Afortunadamente, nada impide la creaci√≥n del √≠ndice en una expresi√≥n despu√©s de transformar puntos en rect√°ngulos degenerados.  Al mismo tiempo, estableceremos el tama√±o de un rango en una p√°gina, solo para mostrar el caso l√≠mite: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin (box(airport_coord)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  El tama√±o del √≠ndice es tan peque√±o como 30 MB incluso en una situaci√≥n tan extrema: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 30 MB (1 row)</code> </pre><br>  Ahora podemos inventar consultas que limitan los aeropuertos por coordenadas.  Por ejemplo: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_code, airport_name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> airports <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(coordinates) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_code | airport_name --------------+----------------- KHV | Khabarovsk-Novyi VVO | Vladivostok (2 rows)</code> </pre><br>  Sin embargo, el planificador se negar√° a usar nuestro √≠ndice. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Seq Scan on flights_bi (cost=0.00..985928.14 rows=30517 width=111) Filter: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Por qu√©  Desactivemos el an√°lisis secuencial y veamos qu√© sucede: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (cost=14079.67..1000007.81 rows=30517 width=111) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) -&gt; Bitmap Index Scan on flights_bi_box_idx (cost=0.00..14072.04 rows=30517076 width=0) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Parece que <em>se puede</em> usar el √≠ndice, pero el planificador supone que el mapa de bits tendr√° que construirse en toda la tabla (observe las "filas" del nodo Escaneo de √≠ndice de mapa de bits), y no es de extra√±ar que el planificador elija el escaneo secuencial en este caso  El problema aqu√≠ es que para los tipos geom√©tricos, PostgreSQL no recopila ninguna estad√≠stica, y el planificador tiene que ir a ciegas: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------+------------------- schemaname | bookings tablename | flights_bi_box_idx attname | box inherited | f null_frac | 0 avg_width | 32 n_distinct | 0 most_common_vals | most_common_freqs | histogram_bounds | correlation | most_common_elems | most_common_elem_freqs | elem_count_histogram |</code> </pre><br>  Por desgracia  Pero no hay quejas sobre el √≠ndice: funciona y funciona bien: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=158.142..315.445 rows=781790 loops=1) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Rows Removed by Index Recheck: 70726 Heap Blocks: lossy=14772 -&gt; Bitmap Index Scan on flights_bi_box_idx (actual time=158.083..158.083 rows=147720 loops=1) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Planning time: 0.137 ms Execution time: 340.593 ms</code> </pre><br>  La conclusi√≥n debe ser as√≠: se necesita PostGIS si se requiere algo no trivial de la geometr√≠a.  Puede recopilar estad√≠sticas de todos modos. <br><br><h2>  Internos </h2><br>  La extensi√≥n convencional "pageinspect" nos permite mirar dentro del √≠ndice BRIN. <br><br>  Primero, la metainformaci√≥n nos indicar√° el tama√±o de un rango y cu√°ntas p√°ginas se asignan para "revmap": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> magic | version | pagesperrange | lastrevmappage ------------+---------+---------------+---------------- 0xA8109CFA | 1 | 128 | 3 (1 row)</code> </pre><br>  Las p√°ginas 1-3 aqu√≠ est√°n asignadas para "revmap", mientras que el resto contiene datos de resumen.  Desde "revmap" podemos obtener referencias a datos de resumen para cada rango.  Digamos que la informaci√≥n sobre el primer rango, que incorpora las primeras 128 p√°ginas, se encuentra aqu√≠: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,197) (1 row)</code> </pre><br>  Y este es el resumen de datos en s√≠: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">197</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 02:45:00+03 .. 2016-08-15 17:15:00+03} (1 row)</code> </pre><br>  Siguiente rango: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,198) (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">198</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 06:00:00+03 .. 2016-08-15 18:55:00+03} (1 row)</code> </pre><br>  Y as√≠ sucesivamente. <br><br>  Para las clases de "inclusi√≥n", el campo "valor" mostrar√° algo como <br><br><pre> <code class="plaintext hljs"> {(94.4005966186523,69.3110961914062),(77.6600036621,51.6693992614746) .. f .. f}</code> </pre><br>  El primer valor es el rect√°ngulo de incrustaci√≥n, y las letras "f" al final denotan la falta de elementos vac√≠os (el primero) y los valores que no se pueden fusionar (el segundo).  En realidad, los √∫nicos valores no fusionables son las direcciones "IPv4" e "IPv6" (tipo de datos "inet"). <br><br><h2>  Propiedades </h2><br>  Recordando las consultas que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya se han proporcionado</a> . <br><br>  Las siguientes son las propiedades del m√©todo de acceso: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- brin | can_order | f brin | can_unique | f brin | can_multi_col | t brin | can_exclude | f</code> </pre><br>  Los √≠ndices se pueden crear en varias columnas.  En este caso, se recopilan sus propias estad√≠sticas de resumen para cada columna, pero se almacenan juntas para cada rango.  Por supuesto, este √≠ndice tiene sentido si el mismo tama√±o de un rango es adecuado para todas las columnas. <br><br>  Las siguientes propiedades de capa de √≠ndice est√°n disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Evidentemente, solo se admite el escaneo de mapa de bits. <br><br>  Sin embargo, la falta de agrupaci√≥n puede parecer confusa.  Aparentemente, dado que el √≠ndice BRIN es sensible al orden f√≠sico de las filas, ser√≠a l√≥gico poder agrupar los datos de acuerdo con el √≠ndice.  Pero esto no es as√≠.  Solo podemos crear un √≠ndice "regular" (√°rbol B o GiST, seg√∫n el tipo de datos) y agruparlo de acuerdo con √©l.  Por cierto, ¬ødesea agrupar una tabla supuestamente enorme teniendo en cuenta los bloqueos exclusivos, el tiempo de ejecuci√≥n y el consumo de espacio en disco durante la reconstrucci√≥n? <br><br>  Las siguientes son las propiedades de la capa de columna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | t</code> </pre><br>  La √∫nica propiedad disponible es la capacidad de manipular NULL. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452900/">https://habr.com/ru/post/452900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452886/index.html">Proyectos de Wiki y nombre de Noosphere en HACKNOWLEGE</a></li>
<li><a href="../452888/index.html">Cerca de M√∫nich comenz√≥ a probar el tiltrotor de cinco asientos de tama√±o completo Lilium Jet</a></li>
<li><a href="../452890/index.html">23 de mayo, 18:30 - transmisi√≥n en vivo de QIWI Kitchen</a></li>
<li><a href="../452892/index.html">¬øC√≥mo puede un no programador mudarse a los Estados Unidos? Instrucciones paso a paso.</a></li>
<li><a href="../452894/index.html">Face Anti-Spoofing o tecnol√≥gicamente reconoce a un tramposo de mil por cara</a></li>
<li><a href="../452902/index.html">Terminando 4 a√±os de entrenamiento como programador, entiendo que estoy lejos de ser un programador</a></li>
<li><a href="../452904/index.html">C√≥mo se comunican las m√°quinas: protocolo MQTT</a></li>
<li><a href="../452906/index.html">Motores JavaScript: ¬øc√≥mo funcionan? Desde la pila de llamadas hasta las promesas, (casi) todo lo que necesita saber</a></li>
<li><a href="../452908/index.html">Selenium WebDriver: m√©trica de prueba en tiempo real con Grafana e InfluxDB</a></li>
<li><a href="../452910/index.html">Hola Habr! Hola tercon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>