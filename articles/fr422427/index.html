<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧦 🔱 🏣 Dagaz: Hors du brouillard ☃️ ☠️ 👵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout cela est la reine du Queen Mab. 
 Elle tisse dans les écuries d'une crinière 
 Et les cheveux font tomber un enchevêtrement ... 

 William Shakes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: Hors du brouillard</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422427/"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>Tout cela est la reine du Queen Mab.</i></b> <b><i><br></i></b>  <b><i>Elle tisse dans les écuries d'une crinière</i></b> <b><i><br></i></b>  <b><i>Et les cheveux font tomber un enchevêtrement ...</i></b> <b><i><br><br></i></b>  <b><i>William Shakespeare</i></b> <br><br>  Ce fut une longue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sortie</a> , mais beaucoup a été fait.  Un <a href="">gestionnaire de session est apparu</a> , vous permettant d'annuler les mouvements effectués par erreur.  À certains endroits, la conception sonore a été ajoutée.  Et pourtant, j'ai trouvé un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moyen</a> cool de proposer plusieurs options alternatives pour le placement initial dans un jeu.  Et le plus important - je suis finalement arrivé aux jeux avec des informations incomplètes. <br><a name="habracut"></a><br>  Je vais vous expliquer ce qui est en jeu.  Dans les jeux de société habituels, tels que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">échecs</a> ou les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dames</a> , les joueurs, à tout moment du jeu, ont des informations complètes sur l'emplacement des pièces (les leurs et celles de l'adversaire), les règles de déplacement, les objectifs du jeu, etc.  Ces jeux sont assez bien étudiés et entrent dans la catégorie des " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeux avec informations complètes</a> ".  Maintenant, imaginez que certaines de ces informations puissent être cachées au lecteur. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/1h/hd/xl/1hhdxlqk7btnosi-jpow5azj-xy.png"></a> </div><br>  Le brouillard de guerre est une excellente illustration du thème.  Selon les règles de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blind Chess</a> ", les joueurs ne peuvent pas voir toutes les pièces de l'ennemi, mais seulement celles qui sont placées sur les champs, qui peuvent être atteintes en un seul mouvement de l'une de leurs pièces.  J'ai fait deux ajouts à cette règle: <br><br><ol><li>  Bien sûr, le joueur voit toujours <b>ses</b> pièces, mais par la façon dont elles sont affichées - sous forme normale ou translucide, il peut juger si l'adversaire les voit. </li><li>  À des fins décoratives uniquement, j'ai placé des «nuages» sur des zones actuellement invisibles. </li></ol><br>  Ayant maîtrisé le <a href="">principe</a> général, je me suis un peu emporté et j'ai fait un très grand nombre de jeux avec le "brouillard de guerre".  En plus des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">échecs</a> , j'ai des options «sombres» pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Xiang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Changi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shatrange</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sittuyin</a> et bien d'autres jeux.  Il y a même un " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blind Guns</a> "!  Tous ces jeux ont une chose en commun: <br><br><div class="spoiler">  <b class="spoiler_title">L'ordinateur triche!</b> <div class="spoiler_text">  Je n'ai même pas essayé de modifier les algorithmes des bots pour ces jeux, car j'ai fait un pari que des conditions inégales compensent au moins partiellement leur jeu extrêmement faible par rapport aux humains.  Comme je l'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit</a> plus tôt, le développement d'une IA de haute qualité pour les jeux de société est une tâche très difficile.  Bien sûr, les règles ont des exceptions.  Même avec un jeu de bot très faible, il sera difficile pour une personne de jouer à un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu</a> inconnu, littéralement bourré de pièges.  Que dire de sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version</a> "sombre" <br></div></div><br>  Cependant, en général, ce n'est pas une approche très correcte.  Je veux voir un bot qui peut faire exactement avec les données de son adversaire - l'homme.  Pourquoi est-ce important?  Tout est très simple - par la façon dont le bot joue, il est parfois très facile de deviner s'il a accès à des informations cachées (peeps) ou non.  Et bien sûr, il est beaucoup plus intéressant pour une personne de jouer avec ce bot qui <b>ne</b> lorgne <b>pas</b> (jouer avec une autre personne est encore plus intéressant, mais c'est une autre histoire). <br><br>  Et ici, cela vaut la peine de choisir un jeu légèrement différent des échecs (puisque je ne suis pas prêt à développer un bot "honnête" jouant aux échecs "à l'aveugle").  Il y a beaucoup de ces jeux et on ne peut pas dire qu'ils sont plus simples que les échecs ou les dames.  Ils sont juste différents et nécessitent une approche individuelle. <br><br><div class="spoiler">  <b class="spoiler_title">Par exemple</b> <div class="spoiler_text">  Il y a un jeu pour enfants avec lequel je n'ai pas encore réussi à développer un bot.  On l'appelle la "Jungle" ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dou Shou Qi</a> .  Le but du jeu est de pénétrer en territoire ennemi.  Chacun des joueurs a un «repaire» - un champ central sur la première ligne.  Si l'une des figures ennemies entre dans l'antre, il a gagné (vous ne pouvez pas occuper l'antre avec vos propres figures). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/rz/cb/l_rzcbk0dmvj5ul8m1e4wdefrny.png"></div><br>  Les chiffres sont classés par ancienneté.  L'éléphant bat tous les personnages, suivi par: Lion, Tigre, Léopard, Chien, Loup, Chat et Rat.  Un rat ne peut battre qu'un éléphant et un autre rat, en plus, c'est la seule figure qui peut se déplacer dans l'eau (au milieu du plateau il y a deux réservoirs).  Un tigre et un lion peuvent sauter au-dessus de l'eau, mais seulement si le rat ne bloque pas l'eau.  À l'exception des sauts, toutes les figures se déplacent de la même manière - vers un champ adjacent verticalement ou horizontalement.  Le repaire est entouré de pièges.  La figure dans le piège est vulnérable à <b>toute</b> figure ennemie. <br><br>  Comme vous pouvez le voir, les règles sont assez simples.  Qu'est-ce qui empêche le développement d'un bot pour ce jeu?  Tout d'abord, les chiffres à basse vitesse.  S'il y a des menaces, je peux apprécier les avantages des échanges, mais pour la majeure partie du jeu, les pièces tournent simplement les unes après les autres sur des distances assez longues.  Je ne peux pas me permettre de voir le jeu pour un grand nombre de mouvements vers l'avant (en raison de restrictions sur la durée du calcul du mouvement), à la suite de quoi les changements se situent en dehors de l'horizon de visualisation et tous les mouvements deviennent équivalents pour moi. <br></div></div><br>  Pour commencer, j'ai décidé de m'attarder sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BanQi</a> - Chinese Blind Chess.  Il s'agit d'un jeu très original avec des informations cachées, semblable à la "Jungle".  Il est important pour moi que les développements, liés à la création d'un bot pour ce jeu, puissent être utilisés dans d'autres jeux, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dou Shou Qi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Luzhan Qi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stratego</a> ou même (éventuellement) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tafl</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bG11at_PKxA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Je vais vous parler des règles.  Le jeu se déroule sur la moitié du plateau pour "Chinese Chess" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Xiang Qi</a> ), tandis que la disposition d'origine du plateau ne joue aucun rôle.  Les pièces sont placées à l'intérieur des cellules (comme dans les cellules traditionnelles), et non aux intersections des lignes (comme dans les échecs chinois).  Au début du jeu, toutes les pièces sont soigneusement mélangées et placées face cachée sur le plateau (puisque les pièces traditionnelles de Syants sont une sorte de barils, et leur nombre coïncide avec le nombre de champs sur la moitié du plateau, il n'y a aucune difficulté). <br><br>  Ensuite, les joueurs alternent leurs mouvements.  En effectuant un mouvement, le joueur peut retourner n'importe laquelle des pièces fermées ou déplacer une pièce précédemment ouverte de sa couleur.  Les couleurs des joueurs sont déterminées par le tout premier mouvement.  Si la première pièce noire est ouverte, le joueur qui l'a ouverte jouera noir.  Toutes les figures du jeu vont de la même manière (à l'exception du «canon» dans la version taïwanaise, dont je parlerai plus tard) - sur une cellule adjacente verticalement ou horizontalement.  La possibilité de prendre est déterminée par l'ordre d'ancienneté des chiffres: <br><br>  <b>Général&gt; Conseiller&gt; Éléphant&gt; Wagon&gt; Cheval&gt; Canon&gt; Soldat</b> <br><br>  Les personnages plus âgés les battent plus jeunes ou égaux, à une exception près: un soldat frappe le général (une sorte de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rock-Paper-Scissors</a> ").  Reste à dire quelques mots sur le BanQi taïwanais: <br><br><ol><li>  Contrairement à la version chinoise, à Taiwan BanQi, un général ne <b>peut</b> pas battre un soldat. </li><li>  Le pistolet se déplace selon les règles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XiangQi</a> , c'est-à-dire vers n'importe quel nombre de champs le long de la basse vitesse orthogonale (comme un char) ou frappe n'importe quelle figure ennemie, avec un saut à travers le "chariot", lors d'un mouvement d'attaque. </li></ol><br>  Il existe également une version hongkongaise, mais elle n'est pratiquement pas différente de la version chinoise, sauf que l'ordre d'ancienneté des chiffres a été modifié.  J'ai décidé de me concentrer sur la version taiwanaise des règles, la plus intéressante tactiquement. <br><br><div class="spoiler">  <b class="spoiler_title">Que dois-je rechercher lors du développement d'un bot?</b> <div class="spoiler_text">  Premièrement, le jeu semble très simple, mais ce n'est pas le cas.  Même si vous ne considérez pas les nuances associées aux armes taiwanaises, le coût des chiffres est contre-intuitif.  Bien que le «conseiller» puisse battre moins de chiffres que le «général», il est le principal protagoniste du jeu.  Premièrement, le joueur a deux conseillers.  De plus, un seul général ennemi est supérieur en force à chaque conseiller, tandis que le général peut être attaqué par jusqu'à cinq soldats!  Pour la même raison, le coût d'un soldat dans un jeu est plus élevé que celui d'un général.  Au final, il peut battre le chiffre le plus fort!  La deuxième considération importante suggère l'une des énigmes "Canterbury" de Henry Dudeney. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v9/jd/ax/v9jdaxvmdjxuvp-gw6sr9h7_i8a.png"></div><br>  C'est plus une tâche de plaisanterie qu'un puzzle complet.  Toutes les figures peuvent aller dans un champ adjacent verticalement ou horizontalement.  Les blancs se déplacent en premier, tandis que les blancs et les noirs font toujours deux mouvements (dans des pièces différentes)!  Dans ces conditions, le bouffon gauche ne peut jamais attraper l'âne gauche, et le buff droit ne peut jamais attraper le bon (vous pouvez le vérifier vous-même).  Bien sûr, le bouffon droit peut attraper l'âne gauche sans aucune difficulté.  Tout est question de parité! <br><br>  Ce problème m'a donné quelques réflexions.  Premièrement, la tâche du bot, dans des jeux comme BanQi ou DouShouQi, est tout d'abord de trouver le chemin le plus court.  A partir de chacune des pièces actives (la sienne ou son adversaire), il est nécessaire de construire des chaînes de mouvements vers tous les objectifs possibles (y compris leurs propres pièces, pour calculer les échanges possibles).  Après cela, les chaînes doivent être évaluées et les options suivantes sont possibles ici. <br><br><ol><li>  La figure attaquante bat l'attaquant - une chaîne rentable (bonus) estimée par le coût de la figure attaquée (moins le coût de l'attaquant, si celui-ci est protégé), en tenant compte de la longueur de la chaîne. </li><li>  La figure attaquante bat l'attaquant - pas une chaîne (de pénalité) rentable, estimée par la valeur de la figure attaquante. </li><li>  Les pièces se battent (par exemple, elles sont égales) - ici tout dépend de la parité, les chaînes impaires sont avantageuses, et les paires doivent être considérées comme pénales (s'il n'y avait pas d'autres chiffres sur le terrain, la parité déterminerait complètement le résultat du jeu). </li></ol><br>  Bien sûr, tout n'est pas si simple.  À tout le moins, vous devez vous souvenir du parcours spécifique des canons dans le BanQi de Taïwan (Quant à la «Jungle», il y a des cas encore plus spéciaux), mais c'est là que vous pouvez commencer.  Avec un ensemble complet de chaînes évaluées, vous pouvez évaluer les mouvements.  Le coût du mouvement doit être composé du coût des chaînes (à la fois bonus et gratuit), dont la durée diminue. <br></div></div><br>  Tout d'abord, il est important de comprendre qu'il est peu probable qu'il puisse utiliser efficacement les algorithmes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">minimax</a> ici.  Les mouvements qui révèlent des pièces précédemment cachées changent trop radicalement l'estimation de la position.  N'ayant aucune information sur les pièces cachées, il est presque impossible de visualiser une position que de nombreux mouvements avancent.  Mais chaque nuage a une doublure argentée, mais nous pouvons utiliser des heuristiques beaucoup plus complexes (en termes de calcul) pour évaluer les mouvements eux-mêmes! <br><br>  J'ai déjà <a href="">un</a> bot qui évalue les mouvements par leur heuristique (nécessaire pour un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu</a> amusant).  Il s'agit d'un algorithme très simple.  Tous les mouvements sont triés par ordre décroissant par heuristique (les mouvements avec une valeur heuristique négative sont généralement rejetés), après quoi ils sont analysés dans l'ordre.  Si le coup suivant mène à une position à partir de laquelle aucune réponse ennemie ne mène à une victoire immédiate, le bot la considère comme la meilleure.  En utilisant cet algorithme, vous ne pouvez pas vous embêter avec l'estimation de position, mais vous devez transpirer sur l' <a href="">heuristique</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Tout d'abord, nous construisons des chaînes</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChains = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.chains)) { board.chains = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pieces = getGoals(design, board); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targets = getTargets(design, board, pieces); _.each(pieces.positions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> goals = pieces; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (piece.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { goals = targets; f = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> group = [ pos ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> level = []; level[pos] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; group.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(goals.positions, group[i]) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ... } if ((i &gt; 0) &amp;&amp; (board.getPiece(group[i]) !== null)) continue; _.each(design.allDirections(), function(dir) { p = design.navigate(board.player, group[i], dir); while (p !== null) { if (_.indexOf(group, p) &gt;= 0) break; group.push(p); level[p] = level[ group[i] ] + 1; if (f || (board.getPiece(p) !== null)) break; p = design.navigate(board.player, p, dir); } }); } }); } return board.chains; }</span></span></code> </pre> </div></div><br>  Bien sûr, je cache toutes les données intermédiaires dans l'état du jeu, afin de ne pas les lire plusieurs fois.  De plus, une astuce est utilisée ici, ce qui est très utile pour calculer les zones connectées.  J'itère le tableau de <b>groupe</b> , en y ajoutant des éléments supplémentaires dans la boucle, selon les besoins.  Toutes les difficultés sont liées aux armes à feu.  Pour eux, les buts des chaînes ne sont pas les figures elles-mêmes, mais les champs à partir desquels ces dernières peuvent être attaquées. <br><br><div class="spoiler">  <b class="spoiler_title">Les chaînes sont évaluées exactement comme je l'ai dit</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChainPrice = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, attacker, attacking, len</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacker == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacking === <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player == attacking.player) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacking = isAttacker(design, attacker.type, attacking.type); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacked = isAttacker(design, attacking.type, attacker.type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (attacker.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { isAttacking = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; isAttacked = (attacking.type == attacker.type) &amp;&amp; (len == <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = (len % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player != player) f = !f; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacking) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = f ? (len - design.price[attacker.type]) : (design.price[attacking.type] - len); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { price = design.price[attacking.type] - len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f) price = (price / <span class="hljs-number"><span class="hljs-number">2</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = len - design.price[attacker.type]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre></div></div><br>  ... en fonction de la longueur et de la parité de la chaîne, ainsi que de la prise en compte des coûts des personnages attaquants et attaqués.  Mais ce n'est que la moitié de la bataille!  Il est nécessaire d'évaluer chacun des mouvements possibles à l'aide des chaînes construites.  J'introduis une autre structure intermédiaire - souhaite agréger les données disponibles.  L'évaluation du cours consiste en des évaluations de souhaits, qu'il satisfait: <br><br><div class="spoiler">  <b class="spoiler_title">Quelque chose comme ça</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, comment, price, src, dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src])) { board.wish[src] = []; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(dst)) dst = src; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src][dst])) { board.wish[src][dst] = price; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.wish[src][dst] += price; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.wish; } Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wish = getWish(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.isSimpleMove() &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]) &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>  Quant à la fonction <b>getWish elle</b> - <b>même</b> , la magie commence ici (et c'est l'endroit où j'ai probablement labouré plus d'une fois).  Tout d'abord, je partage l'évaluation des mouvements basée sur des informations ouvertes et l'introduction de nouvelles pièces dans le jeu.  Ce n'est pas tout à fait exact, mais jusqu'à présent, je ne sais tout simplement pas comment concilier des opinions aussi diverses.  Si sur la base d'informations ouvertes aucun souhait n'a été formé, le bot essaie d'ouvrir de nouvelles figures (il y a aussi quelques astuces ici). <br><br><ol><li>  Si un canon ennemi est ouvert, entouré de figurines fermées, il est logique d'ouvrir l'une des figurines à côté de lui, car il est probable qu'il sera en mesure d'attaquer le canon, et le canon ne pourra en aucun cas le battre. </li><li>  Si une figurine autre qu'un canon est ouverte, vous pouvez essayer d'ouvrir une figurine située à travers le "chariot", car il y a une chance que ce soit un canon. </li><li>  S'il y a une chaîne attaquante du côté de l'ennemi, une des pièces peut être ouverte, à côté de la chaîne, pour intercepter l'attaque. </li><li>  Si vous ne pouvez pas protéger la figure, vous pouvez ouvrir la figure à côté de lui, en essayant de réduire la situation à un échange. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Bien sûr, il est utile d'évaluer la probabilité d'ouvrir une figure particulière.</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getShadow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.shadow)) { board.shadow = []; _.each(design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.type &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = piece.type + <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player != player) { value = -value; } board.shadow.push(value); } }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.shadow; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isFriend = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isPiece = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == y; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacker = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x == <span class="hljs-number"><span class="hljs-number">13</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">7</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">13</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt;= enemy; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDefender = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy, friend</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isAttacker(design, x, enemy)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> design.price[friend] &lt;= design.price[enemy]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> estimate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, p, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadow = getShadow(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shadow.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(shadow, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(design, x, y, z)) r++; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">100</span></span> * r) / shadow.length; }</code> </pre></div></div><br>  Le joueur peut évaluer les probabilités en gardant une trace des chiffres qui ont abandonné le jeu.  En principe, le bot peut faire la même chose, mais il existe un moyen plus simple - d'examiner les chiffres encore non ouverts en vrac et d'évaluer la probabilité d'ouvrir celui souhaité en fonction des informations collectées.  De plus, le succès du mouvement sélectionné n'est pas garanti, mais si la probabilité d'un résultat favorable est faible, le mouvement ne sera pas sélectionné du tout. <br><br><div class="spoiler">  <b class="spoiler_title">En principe, l'approche a porté ses fruits, mais il reste du travail à faire.</b> <div class="spoiler_text">  Alors que les mouvements défensifs ne sont pas très bons.  Certaines figures rencontrent courageusement l'ennemi le plus fort, au lieu de s'enfuir (bien que s'enfuir dans leur cas, en règle générale, soit déjà inutile).  De plus, il est difficile de coordonner les actions de différentes figures (cela peut être utile pour «chasser» les restes de figures ennemies).  L'approche elle-même semble très prometteuse, mais l'heuristique reste à considérer. <br><br>  L'heuristique basée sur des «chaînes» de mouvements peut être utile non seulement dans BanQi, mais aussi dans de nombreux autres jeux, avec une prédominance de morceaux «lents» (sinon comme critère déterminant, puis pour une évaluation préliminaire de la qualité des mouvements dans des algorithmes plus complexes, au moins moins).  Cette approche est particulièrement demandée dans les jeux pour lesquels l'utilisation d'algorithmes minimax est difficile voire impossible (comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yonin Shogi</a> par exemple). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k_/x3/dq/k_x3dqvxu3swinw7qkgmvo__6km.png"></div><br>  Bien sûr, je vais continuer à travailler sur des jeux avec des informations incomplètes.  La photo montre le " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu des généraux</a> " philippin, pas encore prêt.  C'est le jeu le plus simple d'une grande famille, y compris des jeux tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LuzhanQi</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stratego</a> .  Et bien sûr, je m'attends toujours à faire un bot fonctionnel pour la " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jungle</a> "! <br></div></div><br>  Et pour ceux qui me lisent encore, je peux offrir un autre jeu de puzzle amusant avec des informations cachées: <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/bm/aa/4p/bmaa4p2ctbqb_9k_oz1wjoulx9c.png"></a> </div><br>  Je l'ai joué dans mon enfance, sur une calculatrice programmable appelée Fox Hunt.  Huit renards sont cachés au hasard sur le terrain, qui doivent être trouvés à l'aide de la «méthode poke».  Lorsque vous sélectionnez une zone vide, le nombre total de renards dans les huit directions s'affiche.  Il est impossible de perdre, mais vous pouvez rivaliser pour le nombre minimum de clics.  Et si vous jouez avec des écouteurs, baissez le son.  Je l'ai peut-être exagéré avec des effets sonores. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422427/">https://habr.com/ru/post/fr422427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422417/index.html">Slavik et GMT + 3 ou avantage pour les personnes</a></li>
<li><a href="../fr422419/index.html">Pas sans panique chez Go</a></li>
<li><a href="../fr422421/index.html">Microsoft va radicalement améliorer Skype</a></li>
<li><a href="../fr422423/index.html">Python et DataScience: explorer la puissance de la bibliothèque universelle Numpy</a></li>
<li><a href="../fr422425/index.html">Un aperçu des méthodes de post-traitement pour les modèles FDM imprimés en 3D</a></li>
<li><a href="../fr422429/index.html">Nous accélérons le processus de développement de projets complexes. Sans chaos ni nerfs</a></li>
<li><a href="../fr422431/index.html">Les fées japonaises montrent un déclencheur maître-esclave dans un nouveau manga sur l'électronique numérique</a></li>
<li><a href="../fr422433/index.html">Panneaux solaires et routes asphaltées. Symbiose de la technologie</a></li>
<li><a href="../fr422435/index.html">Minuterie - Démarrer</a></li>
<li><a href="../fr422437/index.html">Jeux d'expérience utilisateur et vitesse du site Web et des applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>