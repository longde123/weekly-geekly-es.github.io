<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏿 👒 👩🏾‍🌾 Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million Läufen nicht beschädigt 👨🏿 🍔 👩🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem ich die Erstellung der Webarchitektur für unseren neuen Webcomic Meow the Infinite abgeschlossen hatte , entschied ich, dass es Zeit war, eini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million Läufen nicht beschädigt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/">  Nachdem ich die Erstellung der Webarchitektur für unseren neuen Webcomic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meow the Infinite abgeschlossen hatte</a> , entschied ich, dass es Zeit war, einige überfällige technische Artikel zu schreiben.  Dieser Artikel konzentriert sich auf einen Filter, den ich vor einigen Jahren entwickelt habe.  Es wurde noch nie im Bereich der Videokomprimierung diskutiert, obwohl es mir scheint, dass es sich lohnt, dies zu tun. <br><br>  2011 habe ich den „Halbpel-Filter“ entwickelt.  Dies ist eine spezielle Art von Filter, der ein eingehendes Bild aufnimmt und am überzeugendsten anzeigt, wie das Bild aussehen würde, wenn es <i>genau um ein halbes Pixel</i> verschoben würde. <br><br>  Sie fragen sich wahrscheinlich, warum ein solcher Filter überhaupt benötigt wird.  Tatsächlich sind sie in modernen Video-Codecs weit verbreitet.  Videocodecs verwenden ähnliche Filter, um Fragmente früherer Frames zu nehmen und in nachfolgenden Frames zu verwenden.  Ältere Codecs haben Frame-Daten jeweils nur um ein ganzes Pixel verschoben, aber die neuen Codecs gingen noch weiter und ermöglichen eine Verschiebung von einem halben oder sogar einem Viertel Pixel, um kleine Bewegungen besser übertragen zu können. <br><br>  Bei der Analyse des Verhaltens von Bewegungskompensationsalgorithmen in herkömmlichen Halfpel-Filtern stellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jeff Roberts</a> fest, dass sie sich bei wiederholter Anwendung auf sequentielle Frames schnell verschlechtern und andere Teile des Videokompressors dazu zwingen, mehr Daten als erforderlich zur Korrektur von Artefakten zu verwenden.  Wenn Sie diese Korrekturen deaktivieren und die "rohen" Ergebnisse des Halfpel-Filters anzeigen, ist dies das Originalbild: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>  verwandelt sich in diese: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Nur eine Sekunde später das Video.  Wie es sollte, wird es zur Seite verschoben, da jedes Bild das Bild um ein halbes Pixel verschoben hat.  Das Ergebnis sieht jedoch nicht wie eine verschobene Version des Originalbilds aus, sondern ist stark verzerrt. <br><a name="habracut"></a><br>  Während des "Ein-Sekunden-Videos" wird der Filter tatsächlich viele Male angewendet - 60, wenn das Video mit einer Frequenz von 60 Bildern pro Sekunde abgespielt wird.  Idealerweise benötigen wir jedoch Filter, die gegen solche Verzerrungen beständig sind.  Wenn wir sie hätten, wären Videos mit reibungslosem Bildlauf nicht mit so vielen Artefaktkorrekturen codiert worden, was sie weniger oder besser oder beides gemacht hätte. <br><br>  Wenn Sie mit dem Bereich der Videokomprimierung vertraut sind, fragen Sie sich möglicherweise, warum wir den Halfpel-Filter überhaupt mehrmals verwenden müssen.  Wenn Sie den Halfpel-Filter am Ende zweimal anwenden, verschieben wir bereits ein ganzes Pixel. Warum also nicht einfach die Daten von <i>zwei</i> Frames zurück verwenden und sie einfach übernehmen? <br><br>  Die Antwort ist nicht so einfach.  Erstens, je mehr Daten wir zum Codieren der Daten benötigen, desto weniger Komprimierung erhalten wir.  Wenn wir mit dem Codieren beginnen, ohne dass zu viele Daten erforderlich sind, z. B. "Aus welchem ​​Frame sollen Daten aufgenommen werden", wird das Video daher nicht sehr gut komprimiert. <br><br>  Dies ist jedoch nicht das Wichtigste.  Das Hauptproblem ist, dass wir Informationen aus früheren Frames <i>speichern müssen</i> , wenn wir sie übernehmen <i>müssen</i> .  Um die vorherigen zwei Frames anstelle von einem beizubehalten, müssen Sie davon ausgehen, dass Sie doppelt so viel Speicher haben.  Für moderne CPUs ist dies kein besonderes Problem, sie haben viel Speicher und eine solche Kleinigkeit stört sie nicht.  Dies ist jedoch ein <i>Problem</i> für Sie, wenn Sie ein schnelles, tragbares und weit verbreitetes Videoformat erstellen möchten, das auf Geräten mit wenig Speicher (Mobiltelefone, integrierte Elektronik usw.) funktionieren sollte. <br><br>  Wir wollen wirklich nicht mehrere Frames speichern, um die Bewegung zu kompensieren, nur um keinen Halfpel-Filter zu verwenden.  Daher wurde ich angewiesen, herauszufinden, was genau hier passiert, und herauszufinden, ob ich einen Filter erstellen kann, der solche Probleme nicht hat. <br><br>  Vorher hatte ich noch nie mit Filtern gearbeitet und hatte keine Ahnung, wie sie normalerweise entwickelt werden.  Seltsamerweise stellte sich heraus, dass es zu meinen Gunsten war, weil ich dieses Problem ohne Vorurteile betrachten musste. <br><br><h2>  Die Grundlagen </h2><br>  Mir wurde schnell klar, dass die beliebtesten Halfpel-Filter eine ähnliche Struktur haben: Für jedes Pixel im Ausgabebild werden 2 bis 8 Pixel des Eingabebildes aufgenommen, die abgetastet und mit bestimmten Koeffizienten gemischt werden.  Unterschiedliche Filter unterscheiden sich nur in der Anzahl der abgetasteten Quellpixel (im Fachjargon der Filterentwickler werden sie häufig als Tap bezeichnet) und den Pixelmischungsfaktoren.  Diese Koeffizienten werden oft als "Filterkernel" bezeichnet. Dies ist alles, was zur vollständigen Beschreibung des Filters erforderlich ist. <br><br>  Wenn Sie mit dem Abtasten oder erneuten Abtasten von Bildern (z. B. Skalieren von Bildern) vertraut sind, sollte dies für Sie klar sein.  Im Wesentlichen machen Filter dasselbe.  Da die Videokomprimierung ein weites Feld ist, in dem verschiedene Studien durchgeführt werden, gibt es offensichtlich viele <i>andere</i> Möglichkeiten, um Bewegungen zu kompensieren, als die einfache Filterung.  Gängige Codecs verwenden jedoch normalerweise Bewegungskompensationsverfahren mit Halbpel-Filtern, die im Wesentlichen mit Bildskalierungsfiltern identisch sind: Sie nehmen nur die Originalpixel, multiplizieren sie mit einigen Gewichten, addieren sie und erhalten die Ausgabepixel. <br><br><h2>  Das Bedürfnis nach "Schärfe" </h2><br>  Wir müssen das Bild also um ein halbes Pixel verschieben.  Wenn Sie ein Grafikprogrammierer sind, aber mit dem Filtern nicht besonders vertraut sind, denken Sie vielleicht: "Ich habe auch ein Problem, verwenden Sie einfach einen bilinearen Filter."  Dies ist ein Standardprozess bei der Arbeit mit Grafiken, wenn wir wie hier Zwischenwerte zwischen zwei eingehenden Datenelementen berechnen müssen. <br><br>  Ein bilinearer Filter zum Verschieben von genau einem halben Pixel kann leicht durch den folgenden Filterkern beschrieben werden: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter BilinearKernel[] = {1.0/2.0, 1.0/2.0};</span></span></code> </pre> <br>  Dies wird funktionieren, aber nicht ohne Probleme.  Wenn Ihr Ziel qualitativ hochwertige Bilder sind und bei der Videokomprimierung genau das das Ziel ist, ist ein bilinearer Filter nicht die beste Lösung, da er dem Ergebnis mehr Unschärfe verleiht als erforderlich.  Es ist nicht so <i>viel</i> , aber <i>mehr</i> als andere Filter erstellen. <br><br>  Um dies klar zu zeigen, ist hier ein ungefähres Bild des Walrossauges vom Originalbild nach einmaliger Anwendung der gängigsten Filter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br>  Links ist das Original, rechts ist die bilineare Filterung.  Dazwischen befinden sich die am häufigsten verwendeten Halfpel-Filter von Video-Codecs.  Wenn Sie genau hinschauen, können Sie feststellen, dass fast alle Bilder ähnlich aussehen, mit <i>Ausnahme eines</i> bilinearen, das etwas verschwommener ist.  Obwohl es nicht viel Unschärfe gibt, reicht es aus, wenn Ihr Hauptziel die Bildqualität ist, einen anderen Filter einem bilinearen Filter vorzuziehen. <br><br>  Wie können andere Filter die Schärfe „beibehalten“ und Unschärfen vermeiden?  Erinnern wir uns, wie der Kern der bilinearen Unschärfe aussieht: <br><br><pre> <code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>};</code> </pre> <br>  Es ist sehr einfach.  Um das Bild um ein halbes Pixel zu verschieben, nehmen wir ein Pixel und mischen es zu 50% mit seinem Nachbarn.  Das ist alles.  Man kann sich vorstellen, wie dies das Bild „verwischt“, denn an den Stellen, an denen das hellweiße Pixel neben dem dunklen Schwarz liegt, werden diese beiden Pixel während der bilinearen Filterung gemittelt, wodurch ein graues Pixel entsteht, das den Rand „weicher“ macht.  Dies geschieht mit jedem Pixel, also buchstäblich mit jedem Bereich, in dem es einen deutlichen Unterschied in Farbe oder Helligkeit gibt.  geglättet. <br><br>  Aus diesem Grund wird in hochwertigen Codecs die bilineare Filterung nicht zur Bewegungskompensation verwendet (obwohl sie in anderen Fällen verwendet werden kann).  Stattdessen werden Filter verwendet, die die Schärfe beibehalten, z. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs h264Kernel[] = {1.0/32.0, -5.0/32.0, 20.0/32.0, 20.0/32.0, -5.0/32.0, 1.0/32.0}; HEVCKernel[] = {-1.0/64.0, 4.0/64.0, -11.0/64.0, 40.0/64.0, 40/64.0, -11.0/64.0, 4.0/64.0, -1.0/64.0};</span></span></code> </pre> <br>  Wie Sie sehen können, berücksichtigen diese Filter bei der bilinearen Filterung nur zwei Pixel sechs (h.264) oder sogar acht (HEVC) Pixel.  Außerdem berechnen sie nicht nur die üblichen gewichteten Durchschnittswerte dieser Pixel, sondern verwenden für einige Pixel <i>negative</i> Gewichte, um diese Pixel von anderen Werten zu <i>subtrahieren</i> . <br><br>  Warum machen sie das? <br><br>  Es ist eigentlich nicht schwer zu verstehen: Wenn sowohl positive als auch negative Werte verwendet werden und auch ein breiteres „Fenster“ berücksichtigt wird, kann der Filter den <i>Unterschied</i> zwischen benachbarten Pixeln berücksichtigen und die Schärfe der beiden nächsten Pixel relativ zu ihren entferntesten Nachbarn simulieren.  Auf diese Weise können Sie die Schärfe des Bildergebnisses an den Stellen beibehalten, an denen sich die Pixel erheblich von ihren Nachbarn unterscheiden, während die Mittelung weiterhin verwendet wird, um glaubwürdige Werte für "Halbpixel" -Verschiebungen zu erstellen, die notwendigerweise die Kombination von Pixeln aus dem eingehenden Bild widerspiegeln müssen. <br><br><h2>  Instabile Filterung </h2><br>  Ist das Problem also gelöst?  Ja, das ist möglich, aber wenn Sie nur einen halben Pixelversatz benötigen.  Diese "Schärfungs" -Filter (und ich verwende diesen Begriff hier absichtlich) bewirken jedoch tatsächlich etwas Gefährliches, das im <i>Wesentlichen</i> dem der bilinearen Filterung <i>ähnelt</i> .  Sie wissen einfach besser, wie man es versteckt. <br><br>  Wenn die bilineare Filterung <i>die</i> Bildschärfe <i>verringert</i> , <i>erhöhen</i> diese Standardfilter diese, wie beim Schärfen in einigen Grafikprogrammen.  Das Schärfen ist sehr gering. Wenn wir den Filter also nur einmal ausführen, werden wir dies nicht bemerken.  Wenn die Filterung jedoch mehrmals durchgeführt wird, kann dies sehr auffällig werden. <br><br>  Und da diese Schärfung prozedural ist und von der Differenz zwischen den Pixeln abhängt, wird leider <i>eine Rückkopplungsschleife erstellt</i> , die denselben Rand immer wieder schärft, bis das Bild zerstört wird.  Sie können dies anhand konkreter Beispiele zeigen. <br><br>  Oben - das Originalbild unten - mit bilinearer Filterung über 60 Frames: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>  Wie zu erwarten ist, verringert das Verwischen die Bildschärfe einfach weiter, bis es ziemlich unscharf wird.  Jetzt befindet sich das Original oben und der h.264-Codec-Halfpel-Filter, der unten für 60 Frames ausgeführt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Sehen Sie all diesen Müll?  Der Filter tat dasselbe wie der "Unschärfe" -Effekt der bilinearen Filterung, aber <i>umgekehrt</i> - er "erhöhte die Bildschärfe", so dass alle Teile, in denen die Details waren, in stark verzerrte Hell / Dunkel-Muster umgewandelt wurden. <br><br>  Verhält sich der HEVC-Codec mit 8 Pixeln besser?  Nun, es macht definitiv besser als h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Wenn wir jedoch die Zeit von 60 Bildern (1 Sekunde) auf 120 Bilder (2 Sekunden) erhöhen, werden wir immer noch feststellen, dass es eine Rückmeldung gibt und das Bild zerstört wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Für diejenigen, die die Signalverarbeitung mögen, füge ich als Referenz einen Fenster-Sinc-Filter (Lanczos-Filter genannt) hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter LanczosKernel[] = {0.02446, -0.13587, 0.61141, 0.61141, -0.13587, 0.02446};</span></span></code> </pre> <br>  Ich werde in diesem Artikel nicht erklären, warum sich jemand für "windowed sinc" interessiert, aber es genügt zu sagen, dass dieser Filter aus theoretischen Gründen beliebt ist. Schauen Sie also, wie er bei der Verarbeitung von 60 Frames (1 Sekunde) aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>  und bei der Verarbeitung von 120 Bildern (2 Sekunden): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>  Besser als h.264 und ungefähr das gleiche wie HEVC. <br><br><h2>  Stabile Filterung </h2><br>  Wie können wir bessere Ergebnisse erzielen als h.264, HEVC und windowed sinc?  Und wie viel besser können sie sein? <br><br>  Ich <i>würde erwarten,</i> ähnliche Fragen in der Literatur zur Videokomprimierung zu sehen, und sie sollten den Komprimierungsspezialisten bekannt sein, aber tatsächlich (zumindest für 2011) habe ich niemanden gefunden, der zumindest angegeben hat, dass dies ein Problem ist.  Also musste ich alleine eine Lösung finden. <br><br>  Glücklicherweise ist die Erklärung des Problems sehr einfach: Erstellen Sie einen Filter, der so oft wie möglich angewendet werden kann, damit das Bild ungefähr so ​​aussieht wie am Anfang. <br><br>  Ich nenne diese Definition "stabile Filterung", weil sie meiner Meinung nach als Filtereigenschaft betrachtet werden kann.  Ein Filter ist „stabil“, wenn er nicht in seine Rückkopplungsschleife fällt, dh er kann wiederholt angewendet werden, ohne Artefakte zu erzeugen.  Ein Filter ist "instabil", wenn er Artefakte erzeugt, die durch wiederholte Verwendung verstärkt werden und schließlich das Bild zerstören. <br><br>  Ich wiederhole, ich verstehe nicht, warum dieses Thema in der Literatur zu Videocodecs oder Bildverarbeitung nicht berücksichtigt wird.  Vielleicht verwendet es eine andere Terminologie, aber ich habe es nicht getroffen.  Das Konzept des "Feedbacks" ist im Bereich der Arbeit mit Klang gut etabliert.  aber kein wichtiges Thema in der Bildverarbeitung.  Vielleicht, weil Filter normalerweise nur einmal angewendet werden sollten? <br><br>  Wenn ich ein Spezialist auf diesem Gebiet wäre, hätte ich höchstwahrscheinlich eine Meinung zu diesem Thema, und vielleicht würde ich sogar jene Ecken der Fachliteratur kennen, in denen es bereits Lösungen für dieses Problem gibt, die nur wenigen bekannt sind.  Wie ich zu Beginn des Artikels sagte, konnte ich noch nie zuvor Filter erstellen. Deshalb habe ich nur in bekannten Artikeln gesucht (obwohl es erwähnenswert ist, dass es in der Literatur mindestens eine bekannte Person gibt, die so etwas auch noch nicht gehört hat ) <br><br>  Am Morgen sagten sie mir, dass wir diesen Filter brauchen, und ich habe den ganzen Tag versucht, ihn zu erstellen.  Mein Ansatz war einfach: Ich habe ein Programm erstellt, das den Filter hunderte Male ausgeführt und am Ende ein Bild erstellt hat, damit ich das Ergebnis langer Läufe sehen kann.  Dann habe ich mit verschiedenen Filterkoeffizienten experimentiert und die Ergebnisse beobachtet.  Es war buchstäblich ein richtungsweisender Versuch und Irrtum. <br><br>  Ungefähr eine Stunde später habe ich die besten Filterkoeffizienten ausgewählt, die für diese Aufgabe geeignet sind (aber sie hatten einen Fehler, den ich im zweiten Teil des Artikels diskutieren werde): <br><br><pre> <code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Dieser Kern steht kurz vor dem Schärfen und Verwischen.  Da das Schärfen immer zu Rückkopplungen führt, die lebendige und offensichtliche Artefakte erzeugen, bevorzugt dieser Filterkern ein wenig Unschärfe, damit das Bild nur ein wenig „langweiliger“ aussieht. <br><br>  So sieht es nach 60 Frames aus.  Als Referenz habe ich alle Filter in dieser Reihenfolge gezeigt: das Originalbild (ohne Filterung), mein Filter, bilinear, Lanczos, h.264, HEVC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Wie Sie sehen können, liefert mein Filter etwas mehr unscharfe Ergebnisse als Schärfungsfilter, weist jedoch nach 60 Bildern keine inakzeptablen Schärfeartefakte auf.  Möglicherweise bevorzugen Sie jedoch Unschärfeartefakte gegenüber Schärfungsartefakten, sodass Sie zwischen dem besten Schärfefilter (Lanczos) und meinem Filter wählen können.  Wenn wir jedoch die Anzahl auf 120 Frames erhöhen, ist mein Filter außer Konkurrenz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Nach 300 Bildern werden alle Filter außer meinen wie ein schlechter Witz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br>  Nach 600 Bildern wird der Witz noch grausamer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br>  Sie müssen nicht einmal sagen, was nach 900 Bildern passiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br><h2>  Wie stabil ist es? </h2><br>  In diesem Stadium wird sich natürlich fragen: Ist mein Filter <i>wirklich</i> stabil oder ist es nur eine sehr langsame Unschärfe, viel langsamer als die bilineare Filterung?  Vielleicht verwischt mein Filter nach Tausenden von Wiederholungen das Bild <i>allmählich</i> ? <br><br>  Überraschenderweise scheint die Antwort negativ zu sein.  Obwohl im Verlauf von etwa hundert der ersten Überlagerungen ein wenig Unschärfe hinzugefügt wird, sieht es so aus, als würde der Filter zu einer stabilen Darstellung des Bildes <i>konvergieren</i> , die sich dann <i>nie</i> verschlechtert.  Hier ist ein weiteres vergrößertes Bild eines Walrossauges: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br>  Von links nach rechts: Das Originalbild wurde von meinem Filter 60-mal, 120-mal, 300-mal, 600-mal und 900-mal angewendet.  Wie Sie sehen können, konvergiert die Unschärfe zu einem stabilen Zustand, der sich auch nach Hunderten von Filterüberlagerungen nicht mehr verschlechtert.  Vergleichen Sie dies im Gegensatz dazu mit der Fenstersynchronisierung für die gleiche Anzahl von Samples (Tippen) und sehen Sie, wie schlecht (und schnell!) Die Artefakte das Feedback bilden und ein nutzloses Ergebnis erzeugen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br>  Mein Filter scheint sehr stabil zu sein und erzielt im Vergleich zu allen Filtern, die ich gesehen habe, nach wiederholtem Gebrauch die besten Ergebnisse.  Es scheint, dass es eine bestimmte „asymptotische“ Eigenschaft hat, bei der die Daten schnell zu einem (begrenzten) geglätteten Bild konvergieren. Dieses geglättete Bild wird dann gespeichert und führt keine unbegrenzte Verschlechterung durch, um den Müll zu vervollständigen. <br><br>  Ich habe sogar <i>millionenfach</i> versucht, den Filter anzuwenden, und es scheint, dass er sich nach den ersten paar hundert Überlagerungen nicht weiter verschlechtert.  Ohne eine bessere mathematische Analyse (und ich habe noch keine mathematische Lösung gefunden, die dies genau beweisen kann, aber ich weiß sicher, dass es irgendwo ist) kann ich nicht mit Sicherheit sagen, dass irgendwo nach Milliarden oder Billionen von Überlagerungen dies der Fall ist -es wird nicht brechen.  Innerhalb vernünftiger Tests konnte ich keine weitere Verschlechterung feststellen. <br><br><h2>  Ist es der beste stabile Halfpel-Filter für sechs Zapfstellen? </h2><br>  In diesem Stadium wäre es logisch, die Frage zu stellen: Ist dies wirklich das Beste, was gefunden werden kann?  Die Intuition sagt uns, dass dies nicht der Fall ist, da ich absolut keine Kenntnisse über die Entwicklung von Filtern hatte und fast nicht in die Literatur geschaut habe. Ich habe diesen Filter in nur einer Stunde aufgenommen.  Zumindest kann davon <i>ausgegangen</i> werden <i>,</i> dass ich nach einer so kurzen Studie keinen endgültigen, besten, alles erobernden, großartigen Filter gefunden hätte. <br><br>  Ist diese Annahme wahr?  Und wenn ja, <i>was</i> ist der endgültig beste Filter?  Ich werde dies im zweiten Teil des Artikels genauer diskutieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468501/">https://habr.com/ru/post/de468501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468487/index.html">Was kann passieren (typische Angriffsvektoren)</a></li>
<li><a href="../de468489/index.html">HTTP Request Schmuggel - neue Ansätze</a></li>
<li><a href="../de468491/index.html">Hurras karmischer Fluch</a></li>
<li><a href="../de468493/index.html">Die Struktur der Luftaufnahme des Data Science-Projekts</a></li>
<li><a href="../de468497/index.html">Zeitgesteuerter 3-Minuten-Bürst-Timer</a></li>
<li><a href="../de468503/index.html">Mail geht nicht weiter 500 Meilen - FAQ</a></li>
<li><a href="../de468509/index.html">Unix-ähnliche Betriebssystementwicklung - Zeichengerätetreiber (8)</a></li>
<li><a href="../de468511/index.html">Veröffentlichen eines Servers über ein D-Link DFL-Gateway</a></li>
<li><a href="../de468515/index.html">Nützliche Tipps zur Integration in neue Projekte</a></li>
<li><a href="../de468517/index.html">2. Überblick über den technischen Support und die Garantie von Extreme Networks Switch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>