<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèø üëí üë©üèæ‚Äçüåæ Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million L√§ufen nicht besch√§digt üë®üèø üçî üë©üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem ich die Erstellung der Webarchitektur f√ºr unseren neuen Webcomic Meow the Infinite abgeschlossen hatte , entschied ich, dass es Zeit war, eini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million L√§ufen nicht besch√§digt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/">  Nachdem ich die Erstellung der Webarchitektur f√ºr unseren neuen Webcomic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meow the Infinite abgeschlossen hatte</a> , entschied ich, dass es Zeit war, einige √ºberf√§llige technische Artikel zu schreiben.  Dieser Artikel konzentriert sich auf einen Filter, den ich vor einigen Jahren entwickelt habe.  Es wurde noch nie im Bereich der Videokomprimierung diskutiert, obwohl es mir scheint, dass es sich lohnt, dies zu tun. <br><br>  2011 habe ich den ‚ÄûHalbpel-Filter‚Äú entwickelt.  Dies ist eine spezielle Art von Filter, der ein eingehendes Bild aufnimmt und am √ºberzeugendsten anzeigt, wie das Bild aussehen w√ºrde, wenn es <i>genau um ein halbes Pixel</i> verschoben w√ºrde. <br><br>  Sie fragen sich wahrscheinlich, warum ein solcher Filter √ºberhaupt ben√∂tigt wird.  Tats√§chlich sind sie in modernen Video-Codecs weit verbreitet.  Videocodecs verwenden √§hnliche Filter, um Fragmente fr√ºherer Frames zu nehmen und in nachfolgenden Frames zu verwenden.  √Ñltere Codecs haben Frame-Daten jeweils nur um ein ganzes Pixel verschoben, aber die neuen Codecs gingen noch weiter und erm√∂glichen eine Verschiebung von einem halben oder sogar einem Viertel Pixel, um kleine Bewegungen besser √ºbertragen zu k√∂nnen. <br><br>  Bei der Analyse des Verhaltens von Bewegungskompensationsalgorithmen in herk√∂mmlichen Halfpel-Filtern stellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jeff Roberts</a> fest, dass sie sich bei wiederholter Anwendung auf sequentielle Frames schnell verschlechtern und andere Teile des Videokompressors dazu zwingen, mehr Daten als erforderlich zur Korrektur von Artefakten zu verwenden.  Wenn Sie diese Korrekturen deaktivieren und die "rohen" Ergebnisse des Halfpel-Filters anzeigen, ist dies das Originalbild: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>  verwandelt sich in diese: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Nur eine Sekunde sp√§ter das Video.  Wie es sollte, wird es zur Seite verschoben, da jedes Bild das Bild um ein halbes Pixel verschoben hat.  Das Ergebnis sieht jedoch nicht wie eine verschobene Version des Originalbilds aus, sondern ist stark verzerrt. <br><a name="habracut"></a><br>  W√§hrend des "Ein-Sekunden-Videos" wird der Filter tats√§chlich viele Male angewendet - 60, wenn das Video mit einer Frequenz von 60 Bildern pro Sekunde abgespielt wird.  Idealerweise ben√∂tigen wir jedoch Filter, die gegen solche Verzerrungen best√§ndig sind.  Wenn wir sie h√§tten, w√§ren Videos mit reibungslosem Bildlauf nicht mit so vielen Artefaktkorrekturen codiert worden, was sie weniger oder besser oder beides gemacht h√§tte. <br><br>  Wenn Sie mit dem Bereich der Videokomprimierung vertraut sind, fragen Sie sich m√∂glicherweise, warum wir den Halfpel-Filter √ºberhaupt mehrmals verwenden m√ºssen.  Wenn Sie den Halfpel-Filter am Ende zweimal anwenden, verschieben wir bereits ein ganzes Pixel. Warum also nicht einfach die Daten von <i>zwei</i> Frames zur√ºck verwenden und sie einfach √ºbernehmen? <br><br>  Die Antwort ist nicht so einfach.  Erstens, je mehr Daten wir zum Codieren der Daten ben√∂tigen, desto weniger Komprimierung erhalten wir.  Wenn wir mit dem Codieren beginnen, ohne dass zu viele Daten erforderlich sind, z. B. "Aus welchem ‚Äã‚ÄãFrame sollen Daten aufgenommen werden", wird das Video daher nicht sehr gut komprimiert. <br><br>  Dies ist jedoch nicht das Wichtigste.  Das Hauptproblem ist, dass wir Informationen aus fr√ºheren Frames <i>speichern m√ºssen</i> , wenn wir sie √ºbernehmen <i>m√ºssen</i> .  Um die vorherigen zwei Frames anstelle von einem beizubehalten, m√ºssen Sie davon ausgehen, dass Sie doppelt so viel Speicher haben.  F√ºr moderne CPUs ist dies kein besonderes Problem, sie haben viel Speicher und eine solche Kleinigkeit st√∂rt sie nicht.  Dies ist jedoch ein <i>Problem</i> f√ºr Sie, wenn Sie ein schnelles, tragbares und weit verbreitetes Videoformat erstellen m√∂chten, das auf Ger√§ten mit wenig Speicher (Mobiltelefone, integrierte Elektronik usw.) funktionieren sollte. <br><br>  Wir wollen wirklich nicht mehrere Frames speichern, um die Bewegung zu kompensieren, nur um keinen Halfpel-Filter zu verwenden.  Daher wurde ich angewiesen, herauszufinden, was genau hier passiert, und herauszufinden, ob ich einen Filter erstellen kann, der solche Probleme nicht hat. <br><br>  Vorher hatte ich noch nie mit Filtern gearbeitet und hatte keine Ahnung, wie sie normalerweise entwickelt werden.  Seltsamerweise stellte sich heraus, dass es zu meinen Gunsten war, weil ich dieses Problem ohne Vorurteile betrachten musste. <br><br><h2>  Die Grundlagen </h2><br>  Mir wurde schnell klar, dass die beliebtesten Halfpel-Filter eine √§hnliche Struktur haben: F√ºr jedes Pixel im Ausgabebild werden 2 bis 8 Pixel des Eingabebildes aufgenommen, die abgetastet und mit bestimmten Koeffizienten gemischt werden.  Unterschiedliche Filter unterscheiden sich nur in der Anzahl der abgetasteten Quellpixel (im Fachjargon der Filterentwickler werden sie h√§ufig als Tap bezeichnet) und den Pixelmischungsfaktoren.  Diese Koeffizienten werden oft als "Filterkernel" bezeichnet. Dies ist alles, was zur vollst√§ndigen Beschreibung des Filters erforderlich ist. <br><br>  Wenn Sie mit dem Abtasten oder erneuten Abtasten von Bildern (z. B. Skalieren von Bildern) vertraut sind, sollte dies f√ºr Sie klar sein.  Im Wesentlichen machen Filter dasselbe.  Da die Videokomprimierung ein weites Feld ist, in dem verschiedene Studien durchgef√ºhrt werden, gibt es offensichtlich viele <i>andere</i> M√∂glichkeiten, um Bewegungen zu kompensieren, als die einfache Filterung.  G√§ngige Codecs verwenden jedoch normalerweise Bewegungskompensationsverfahren mit Halbpel-Filtern, die im Wesentlichen mit Bildskalierungsfiltern identisch sind: Sie nehmen nur die Originalpixel, multiplizieren sie mit einigen Gewichten, addieren sie und erhalten die Ausgabepixel. <br><br><h2>  Das Bed√ºrfnis nach "Sch√§rfe" </h2><br>  Wir m√ºssen das Bild also um ein halbes Pixel verschieben.  Wenn Sie ein Grafikprogrammierer sind, aber mit dem Filtern nicht besonders vertraut sind, denken Sie vielleicht: "Ich habe auch ein Problem, verwenden Sie einfach einen bilinearen Filter."  Dies ist ein Standardprozess bei der Arbeit mit Grafiken, wenn wir wie hier Zwischenwerte zwischen zwei eingehenden Datenelementen berechnen m√ºssen. <br><br>  Ein bilinearer Filter zum Verschieben von genau einem halben Pixel kann leicht durch den folgenden Filterkern beschrieben werden: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter BilinearKernel[] = {1.0/2.0, 1.0/2.0};</span></span></code> </pre> <br>  Dies wird funktionieren, aber nicht ohne Probleme.  Wenn Ihr Ziel qualitativ hochwertige Bilder sind und bei der Videokomprimierung genau das das Ziel ist, ist ein bilinearer Filter nicht die beste L√∂sung, da er dem Ergebnis mehr Unsch√§rfe verleiht als erforderlich.  Es ist nicht so <i>viel</i> , aber <i>mehr</i> als andere Filter erstellen. <br><br>  Um dies klar zu zeigen, ist hier ein ungef√§hres Bild des Walrossauges vom Originalbild nach einmaliger Anwendung der g√§ngigsten Filter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br>  Links ist das Original, rechts ist die bilineare Filterung.  Dazwischen befinden sich die am h√§ufigsten verwendeten Halfpel-Filter von Video-Codecs.  Wenn Sie genau hinschauen, k√∂nnen Sie feststellen, dass fast alle Bilder √§hnlich aussehen, mit <i>Ausnahme eines</i> bilinearen, das etwas verschwommener ist.  Obwohl es nicht viel Unsch√§rfe gibt, reicht es aus, wenn Ihr Hauptziel die Bildqualit√§t ist, einen anderen Filter einem bilinearen Filter vorzuziehen. <br><br>  Wie k√∂nnen andere Filter die Sch√§rfe ‚Äûbeibehalten‚Äú und Unsch√§rfen vermeiden?  Erinnern wir uns, wie der Kern der bilinearen Unsch√§rfe aussieht: <br><br><pre> <code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>};</code> </pre> <br>  Es ist sehr einfach.  Um das Bild um ein halbes Pixel zu verschieben, nehmen wir ein Pixel und mischen es zu 50% mit seinem Nachbarn.  Das ist alles.  Man kann sich vorstellen, wie dies das Bild ‚Äûverwischt‚Äú, denn an den Stellen, an denen das hellwei√üe Pixel neben dem dunklen Schwarz liegt, werden diese beiden Pixel w√§hrend der bilinearen Filterung gemittelt, wodurch ein graues Pixel entsteht, das den Rand ‚Äûweicher‚Äú macht.  Dies geschieht mit jedem Pixel, also buchst√§blich mit jedem Bereich, in dem es einen deutlichen Unterschied in Farbe oder Helligkeit gibt.  gegl√§ttet. <br><br>  Aus diesem Grund wird in hochwertigen Codecs die bilineare Filterung nicht zur Bewegungskompensation verwendet (obwohl sie in anderen F√§llen verwendet werden kann).  Stattdessen werden Filter verwendet, die die Sch√§rfe beibehalten, z. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs h264Kernel[] = {1.0/32.0, -5.0/32.0, 20.0/32.0, 20.0/32.0, -5.0/32.0, 1.0/32.0}; HEVCKernel[] = {-1.0/64.0, 4.0/64.0, -11.0/64.0, 40.0/64.0, 40/64.0, -11.0/64.0, 4.0/64.0, -1.0/64.0};</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, ber√ºcksichtigen diese Filter bei der bilinearen Filterung nur zwei Pixel sechs (h.264) oder sogar acht (HEVC) Pixel.  Au√üerdem berechnen sie nicht nur die √ºblichen gewichteten Durchschnittswerte dieser Pixel, sondern verwenden f√ºr einige Pixel <i>negative</i> Gewichte, um diese Pixel von anderen Werten zu <i>subtrahieren</i> . <br><br>  Warum machen sie das? <br><br>  Es ist eigentlich nicht schwer zu verstehen: Wenn sowohl positive als auch negative Werte verwendet werden und auch ein breiteres ‚ÄûFenster‚Äú ber√ºcksichtigt wird, kann der Filter den <i>Unterschied</i> zwischen benachbarten Pixeln ber√ºcksichtigen und die Sch√§rfe der beiden n√§chsten Pixel relativ zu ihren entferntesten Nachbarn simulieren.  Auf diese Weise k√∂nnen Sie die Sch√§rfe des Bildergebnisses an den Stellen beibehalten, an denen sich die Pixel erheblich von ihren Nachbarn unterscheiden, w√§hrend die Mittelung weiterhin verwendet wird, um glaubw√ºrdige Werte f√ºr "Halbpixel" -Verschiebungen zu erstellen, die notwendigerweise die Kombination von Pixeln aus dem eingehenden Bild widerspiegeln m√ºssen. <br><br><h2>  Instabile Filterung </h2><br>  Ist das Problem also gel√∂st?  Ja, das ist m√∂glich, aber wenn Sie nur einen halben Pixelversatz ben√∂tigen.  Diese "Sch√§rfungs" -Filter (und ich verwende diesen Begriff hier absichtlich) bewirken jedoch tats√§chlich etwas Gef√§hrliches, das im <i>Wesentlichen</i> dem der bilinearen Filterung <i>√§hnelt</i> .  Sie wissen einfach besser, wie man es versteckt. <br><br>  Wenn die bilineare Filterung <i>die</i> Bildsch√§rfe <i>verringert</i> , <i>erh√∂hen</i> diese Standardfilter diese, wie beim Sch√§rfen in einigen Grafikprogrammen.  Das Sch√§rfen ist sehr gering. Wenn wir den Filter also nur einmal ausf√ºhren, werden wir dies nicht bemerken.  Wenn die Filterung jedoch mehrmals durchgef√ºhrt wird, kann dies sehr auff√§llig werden. <br><br>  Und da diese Sch√§rfung prozedural ist und von der Differenz zwischen den Pixeln abh√§ngt, wird leider <i>eine R√ºckkopplungsschleife erstellt</i> , die denselben Rand immer wieder sch√§rft, bis das Bild zerst√∂rt wird.  Sie k√∂nnen dies anhand konkreter Beispiele zeigen. <br><br>  Oben - das Originalbild unten - mit bilinearer Filterung √ºber 60 Frames: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>  Wie zu erwarten ist, verringert das Verwischen die Bildsch√§rfe einfach weiter, bis es ziemlich unscharf wird.  Jetzt befindet sich das Original oben und der h.264-Codec-Halfpel-Filter, der unten f√ºr 60 Frames ausgef√ºhrt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Sehen Sie all diesen M√ºll?  Der Filter tat dasselbe wie der "Unsch√§rfe" -Effekt der bilinearen Filterung, aber <i>umgekehrt</i> - er "erh√∂hte die Bildsch√§rfe", so dass alle Teile, in denen die Details waren, in stark verzerrte Hell / Dunkel-Muster umgewandelt wurden. <br><br>  Verh√§lt sich der HEVC-Codec mit 8 Pixeln besser?  Nun, es macht definitiv besser als h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Wenn wir jedoch die Zeit von 60 Bildern (1 Sekunde) auf 120 Bilder (2 Sekunden) erh√∂hen, werden wir immer noch feststellen, dass es eine R√ºckmeldung gibt und das Bild zerst√∂rt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  F√ºr diejenigen, die die Signalverarbeitung m√∂gen, f√ºge ich als Referenz einen Fenster-Sinc-Filter (Lanczos-Filter genannt) hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter LanczosKernel[] = {0.02446, -0.13587, 0.61141, 0.61141, -0.13587, 0.02446};</span></span></code> </pre> <br>  Ich werde in diesem Artikel nicht erkl√§ren, warum sich jemand f√ºr "windowed sinc" interessiert, aber es gen√ºgt zu sagen, dass dieser Filter aus theoretischen Gr√ºnden beliebt ist. Schauen Sie also, wie er bei der Verarbeitung von 60 Frames (1 Sekunde) aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>  und bei der Verarbeitung von 120 Bildern (2 Sekunden): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>  Besser als h.264 und ungef√§hr das gleiche wie HEVC. <br><br><h2>  Stabile Filterung </h2><br>  Wie k√∂nnen wir bessere Ergebnisse erzielen als h.264, HEVC und windowed sinc?  Und wie viel besser k√∂nnen sie sein? <br><br>  Ich <i>w√ºrde erwarten,</i> √§hnliche Fragen in der Literatur zur Videokomprimierung zu sehen, und sie sollten den Komprimierungsspezialisten bekannt sein, aber tats√§chlich (zumindest f√ºr 2011) habe ich niemanden gefunden, der zumindest angegeben hat, dass dies ein Problem ist.  Also musste ich alleine eine L√∂sung finden. <br><br>  Gl√ºcklicherweise ist die Erkl√§rung des Problems sehr einfach: Erstellen Sie einen Filter, der so oft wie m√∂glich angewendet werden kann, damit das Bild ungef√§hr so ‚Äã‚Äãaussieht wie am Anfang. <br><br>  Ich nenne diese Definition "stabile Filterung", weil sie meiner Meinung nach als Filtereigenschaft betrachtet werden kann.  Ein Filter ist ‚Äûstabil‚Äú, wenn er nicht in seine R√ºckkopplungsschleife f√§llt, dh er kann wiederholt angewendet werden, ohne Artefakte zu erzeugen.  Ein Filter ist "instabil", wenn er Artefakte erzeugt, die durch wiederholte Verwendung verst√§rkt werden und schlie√ülich das Bild zerst√∂ren. <br><br>  Ich wiederhole, ich verstehe nicht, warum dieses Thema in der Literatur zu Videocodecs oder Bildverarbeitung nicht ber√ºcksichtigt wird.  Vielleicht verwendet es eine andere Terminologie, aber ich habe es nicht getroffen.  Das Konzept des "Feedbacks" ist im Bereich der Arbeit mit Klang gut etabliert.  aber kein wichtiges Thema in der Bildverarbeitung.  Vielleicht, weil Filter normalerweise nur einmal angewendet werden sollten? <br><br>  Wenn ich ein Spezialist auf diesem Gebiet w√§re, h√§tte ich h√∂chstwahrscheinlich eine Meinung zu diesem Thema, und vielleicht w√ºrde ich sogar jene Ecken der Fachliteratur kennen, in denen es bereits L√∂sungen f√ºr dieses Problem gibt, die nur wenigen bekannt sind.  Wie ich zu Beginn des Artikels sagte, konnte ich noch nie zuvor Filter erstellen. Deshalb habe ich nur in bekannten Artikeln gesucht (obwohl es erw√§hnenswert ist, dass es in der Literatur mindestens eine bekannte Person gibt, die so etwas auch noch nicht geh√∂rt hat ) <br><br>  Am Morgen sagten sie mir, dass wir diesen Filter brauchen, und ich habe den ganzen Tag versucht, ihn zu erstellen.  Mein Ansatz war einfach: Ich habe ein Programm erstellt, das den Filter hunderte Male ausgef√ºhrt und am Ende ein Bild erstellt hat, damit ich das Ergebnis langer L√§ufe sehen kann.  Dann habe ich mit verschiedenen Filterkoeffizienten experimentiert und die Ergebnisse beobachtet.  Es war buchst√§blich ein richtungsweisender Versuch und Irrtum. <br><br>  Ungef√§hr eine Stunde sp√§ter habe ich die besten Filterkoeffizienten ausgew√§hlt, die f√ºr diese Aufgabe geeignet sind (aber sie hatten einen Fehler, den ich im zweiten Teil des Artikels diskutieren werde): <br><br><pre> <code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Dieser Kern steht kurz vor dem Sch√§rfen und Verwischen.  Da das Sch√§rfen immer zu R√ºckkopplungen f√ºhrt, die lebendige und offensichtliche Artefakte erzeugen, bevorzugt dieser Filterkern ein wenig Unsch√§rfe, damit das Bild nur ein wenig ‚Äûlangweiliger‚Äú aussieht. <br><br>  So sieht es nach 60 Frames aus.  Als Referenz habe ich alle Filter in dieser Reihenfolge gezeigt: das Originalbild (ohne Filterung), mein Filter, bilinear, Lanczos, h.264, HEVC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Wie Sie sehen k√∂nnen, liefert mein Filter etwas mehr unscharfe Ergebnisse als Sch√§rfungsfilter, weist jedoch nach 60 Bildern keine inakzeptablen Sch√§rfeartefakte auf.  M√∂glicherweise bevorzugen Sie jedoch Unsch√§rfeartefakte gegen√ºber Sch√§rfungsartefakten, sodass Sie zwischen dem besten Sch√§rfefilter (Lanczos) und meinem Filter w√§hlen k√∂nnen.  Wenn wir jedoch die Anzahl auf 120 Frames erh√∂hen, ist mein Filter au√üer Konkurrenz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Nach 300 Bildern werden alle Filter au√üer meinen wie ein schlechter Witz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br>  Nach 600 Bildern wird der Witz noch grausamer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br>  Sie m√ºssen nicht einmal sagen, was nach 900 Bildern passiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br><h2>  Wie stabil ist es? </h2><br>  In diesem Stadium wird sich nat√ºrlich fragen: Ist mein Filter <i>wirklich</i> stabil oder ist es nur eine sehr langsame Unsch√§rfe, viel langsamer als die bilineare Filterung?  Vielleicht verwischt mein Filter nach Tausenden von Wiederholungen das Bild <i>allm√§hlich</i> ? <br><br>  √úberraschenderweise scheint die Antwort negativ zu sein.  Obwohl im Verlauf von etwa hundert der ersten √úberlagerungen ein wenig Unsch√§rfe hinzugef√ºgt wird, sieht es so aus, als w√ºrde der Filter zu einer stabilen Darstellung des Bildes <i>konvergieren</i> , die sich dann <i>nie</i> verschlechtert.  Hier ist ein weiteres vergr√∂√üertes Bild eines Walrossauges: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br>  Von links nach rechts: Das Originalbild wurde von meinem Filter 60-mal, 120-mal, 300-mal, 600-mal und 900-mal angewendet.  Wie Sie sehen k√∂nnen, konvergiert die Unsch√§rfe zu einem stabilen Zustand, der sich auch nach Hunderten von Filter√ºberlagerungen nicht mehr verschlechtert.  Vergleichen Sie dies im Gegensatz dazu mit der Fenstersynchronisierung f√ºr die gleiche Anzahl von Samples (Tippen) und sehen Sie, wie schlecht (und schnell!) Die Artefakte das Feedback bilden und ein nutzloses Ergebnis erzeugen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br>  Mein Filter scheint sehr stabil zu sein und erzielt im Vergleich zu allen Filtern, die ich gesehen habe, nach wiederholtem Gebrauch die besten Ergebnisse.  Es scheint, dass es eine bestimmte ‚Äûasymptotische‚Äú Eigenschaft hat, bei der die Daten schnell zu einem (begrenzten) gegl√§tteten Bild konvergieren. Dieses gegl√§ttete Bild wird dann gespeichert und f√ºhrt keine unbegrenzte Verschlechterung durch, um den M√ºll zu vervollst√§ndigen. <br><br>  Ich habe sogar <i>millionenfach</i> versucht, den Filter anzuwenden, und es scheint, dass er sich nach den ersten paar hundert √úberlagerungen nicht weiter verschlechtert.  Ohne eine bessere mathematische Analyse (und ich habe noch keine mathematische L√∂sung gefunden, die dies genau beweisen kann, aber ich wei√ü sicher, dass es irgendwo ist) kann ich nicht mit Sicherheit sagen, dass irgendwo nach Milliarden oder Billionen von √úberlagerungen dies der Fall ist -es wird nicht brechen.  Innerhalb vern√ºnftiger Tests konnte ich keine weitere Verschlechterung feststellen. <br><br><h2>  Ist es der beste stabile Halfpel-Filter f√ºr sechs Zapfstellen? </h2><br>  In diesem Stadium w√§re es logisch, die Frage zu stellen: Ist dies wirklich das Beste, was gefunden werden kann?  Die Intuition sagt uns, dass dies nicht der Fall ist, da ich absolut keine Kenntnisse √ºber die Entwicklung von Filtern hatte und fast nicht in die Literatur geschaut habe. Ich habe diesen Filter in nur einer Stunde aufgenommen.  Zumindest kann davon <i>ausgegangen</i> werden <i>,</i> dass ich nach einer so kurzen Studie keinen endg√ºltigen, besten, alles erobernden, gro√üartigen Filter gefunden h√§tte. <br><br>  Ist diese Annahme wahr?  Und wenn ja, <i>was</i> ist der endg√ºltig beste Filter?  Ich werde dies im zweiten Teil des Artikels genauer diskutieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468501/">https://habr.com/ru/post/de468501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468487/index.html">Was kann passieren (typische Angriffsvektoren)</a></li>
<li><a href="../de468489/index.html">HTTP Request Schmuggel - neue Ans√§tze</a></li>
<li><a href="../de468491/index.html">Hurras karmischer Fluch</a></li>
<li><a href="../de468493/index.html">Die Struktur der Luftaufnahme des Data Science-Projekts</a></li>
<li><a href="../de468497/index.html">Zeitgesteuerter 3-Minuten-B√ºrst-Timer</a></li>
<li><a href="../de468503/index.html">Mail geht nicht weiter 500 Meilen - FAQ</a></li>
<li><a href="../de468509/index.html">Unix-√§hnliche Betriebssystementwicklung - Zeichenger√§tetreiber (8)</a></li>
<li><a href="../de468511/index.html">Ver√∂ffentlichen eines Servers √ºber ein D-Link DFL-Gateway</a></li>
<li><a href="../de468515/index.html">N√ºtzliche Tipps zur Integration in neue Projekte</a></li>
<li><a href="../de468517/index.html">2. √úberblick √ºber den technischen Support und die Garantie von Extreme Networks Switch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>