<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏾 👨🏻‍⚖️ ✳️ Infer.NET代码中隐藏了哪些错误？ 🙋🏼 👳 #⃣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="微软发布其项目的源代码是验证它们的一个很好的理由。 这次也不例外，今天我们看一下在Infer.NET代码中发现的可疑位置。 向下注解-直达重点！ 

 关于项目和分析器的一些知识 
 Infer.NET是由Microsoft的专家开发的机器学习系统。 该项目的源代码最近已在GitHub上提供 ，这就...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infer.NET代码中隐藏了哪些错误？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/429578/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/18a/6a6/d3f18a6a6127aceeae10d53591e0ce65.png"></div><br> 微软发布其项目的源代码是验证它们的一个很好的理由。 这次也不例外，今天我们看一下在Infer.NET代码中发现的可疑位置。 向下注解-直达重点！ <br><a name="habracut"></a><br><h2> 关于项目和分析器的一些知识 </h2><br>  Infer.NET是由Microsoft的专家开发的机器学习系统。 该项目的源代码最近已在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上提供</a> ，这就是进行验证的原因。 例如，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>找到有关该项目的更多详细信息。 <br><br> 使用PVS-Studio版本6.26静态分析器检查了该项目。 让我提醒您，PVS-Studio正在Windows，Linux，macOS下的C \ C ++ \ C＃（以及Java中）中寻找代码错误。 到目前为止，我们仅在Windows下分析C＃代码。 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>分析仪<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并</a>在您的项目上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">试用</a> 。 <br><br> 检查本身非常简单，没有问题。 以前，我从GitHub上卸载了该项目，还原了所需的软件包（依赖项），并确保该项目已成功构建。 这是必需的，以便分析仪可以访问所有必要的信息以进行全面分析。 单击几下后，我通过用于Visual Studio的PVS-Studio插件启动了对解决方案的分析。 <br><br> 顺便说一下，这不是Microsoft使用PVS-Studio测试的第一个项目-还有其他项目： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Roslyn</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MSBuild</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PowerShell</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CoreFX</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等</a> 。 <br><br>  <b>注意事项</b> 如果您或您的熟人对分析Java代码感兴趣，可以通过选择“我想要Java分析器”来给我们写信以获取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持</a> 。 该分析器没有公开的Beta版本，但应尽快提供。 他们在秘密实验室的某个地方（穿过墙壁）正在积极地工作。 <br><br> 但是足够多的抽象讨论-让我们看一下代码中的问题。 <br><br><h2> 这是错误还是功能？ </h2><br> 我建议您自己尝试查找错误-完全可以解决的任务。 老实说，我不会以“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2017年C ++项目中的十大错误</a> ”一文<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为</a>笑。 因此，请勿急于阅读代码段后提供的分析器警告。 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeParallelTransitions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( transition1.DestinationStateIndex == transition2.DestinationStateIndex &amp;&amp; transition1.Group == transition2.Group) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transition1.IsEpsilon &amp;&amp; transition2.IsEpsilon) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!transition1.IsEpsilon &amp;&amp; !transition2.IsEpsilon) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.IsInfinity(transition1.Weight.Value) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.IsInfinity(transition1.Weight.Value)) { newElementDistribution.SetToSum( <span class="hljs-number"><span class="hljs-number">1.0</span></span>, transition1.ElementDistribution, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, transition2.ElementDistribution); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newElementDistribution.SetToSum( transition1.Weight.Value, transition1.ElementDistribution, transition2.Weight.Value, transition2.ElementDistribution); } .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3001</a>在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'double.IsInfinity（transition1.Weight.Value）'。 运行时自动机.Simplification.cs 479 <br><br> 从代码片段中可以看到，该方法正在使用一对变量<i>-transition1</i>和<i>transition2</i> 。 有时使用相似名称是合理的，但是值得记住的是，在这种情况下，使用该名称在某处意外犯错的可能性会增加。 <br><br> 这是检查数字的无穷大（ <i>double.IsInfinity</i> ）时发生的情况。 由于错误，我们两次检查了相同变量的值<i>-transition1.Weight.Value</i> 。 第二个子表达式中的检查值应为变量<i>transition2.Weight.Value</i> 。 <br><br> 另一个类似的可疑代码。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> MethodBase </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToMethodInternal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IMethodReference imr</span></span></span><span class="hljs-function">)</span></span> { .... bf |= BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance; .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3001</a>在'|'的左侧和右侧有相同的子表达式'BindingFlags.Public' 操作员。 编译器CodeBuilder.cs 194 <br><br> 形成<i>bf</i>变量的值时，将<i>BindingFlags.Public</i>枚举元素使用两次。 要么此代码包含额外的标记操作，要么代替第二次使用<i>BindingFlags.Public，</i>应该使用不同的枚举值。 <br><br> 顺便说一下，在源代码中，此代码写在一行上。 在我看来，如果将其格式化为表格样式（如此处所示），则更容易发现问题。 <br><br> 让我们继续前进。 我介绍了该方法的全部内容，并再次建议您自己发现错误（或者可能是错误）。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEachPrefix</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IExpression expr, Action&lt;IExpression&gt; action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// This method must be kept consistent with GetTargets. if (expr is IArrayIndexerExpression) ForEachPrefix(((IArrayIndexerExpression)expr).Target, action); else if (expr is IAddressOutExpression) ForEachPrefix(((IAddressOutExpression)expr).Expression, action); else if (expr is IPropertyReferenceExpression) ForEachPrefix(((IPropertyReferenceExpression)expr).Target, action); else if (expr is IFieldReferenceExpression) { IExpression target = ((IFieldReferenceExpression)expr).Target; if (!(target is IThisReferenceExpression)) ForEachPrefix(target, action); } else if (expr is ICastExpression) ForEachPrefix(((ICastExpression)expr).Expression, action); else if (expr is IPropertyIndexerExpression) ForEachPrefix(((IPropertyIndexerExpression)expr).Target, action); else if (expr is IEventReferenceExpression) ForEachPrefix(((IEventReferenceExpression)expr).Target, action); else if (expr is IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); else if (expr is IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action); else if (expr is IMethodInvokeExpression) ForEachPrefix(((IMethodInvokeExpression)expr).Method, action); else if (expr is IMethodReferenceExpression) ForEachPrefix(((IMethodReferenceExpression)expr).Target, action); else if (expr is IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); else if (expr is IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action); else if (expr is IDelegateInvokeExpression) ForEachPrefix(((IDelegateInvokeExpression)expr).Target, action); action(expr); }</span></span></code> </pre> <br> 找到了吗 我们正在检查！ <br><br>  <b>PVS-Studio警告</b> ： <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3003检测到</a>使用'if（A）{...} else if（A）{...}'模式。 存在逻辑错误的可能性。 检查行：1719、1727。编译器CodeRecognizer.cs 1719 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3003检测到</a>使用'if（A）{...} else if（A）{...}'模式。 存在逻辑错误的可能性。 检查行：1721，1729。编译器CodeRecognizer.cs 1721 </li></ul><br> 稍微简化代码以使问题更加明显。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEachPrefix</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IExpression expr, Action&lt;IExpression&gt; action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action); .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IUnaryExpression) ForEachPrefix(((IUnaryExpression)expr).Expression, action); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IAddressReferenceExpression) ForEachPrefix(((IAddressReferenceExpression)expr).Expression, action) .... }</code> </pre> <br> 条件表达式， <i>然后</i>复制多个<i>if语句的</i>分支。 也许这段代码是使用copy-paste方法编写的，这就是出现问题的原因。 现在事实证明，重复的<i>then</i>分支将永远不会执行，因为： <br><br><ul><li> 如果条件表达式为真，则执行相应对中的第一个<i>if语句</i>的主体； </li><li> 如果条件表达式在第一种情况下为false，则在第二种情况下为false。 </li></ul><br> 由于那么分支包含相同的动作，因此现在看起来像是令人困惑的冗余代码。 这可能是另一种问题-应该执行其他检查，而不是重复检查。 <br><br> 我们继续。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Pair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; x, Pair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.First &lt; y.First) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.Second &gt;= y.Second) { <span class="hljs-comment"><span class="hljs-comment">// y strictly contains x return 1; } else { // No containment - order by left bound return 1; } } else if (x.First &gt; y.First) { if (x.Second &lt;= y.Second) { // x strictly contains y return -1; } else { // No containment - order by left bound return -1; } } .... }</span></span></code> </pre> <br>  <b>PVS-Studio警告</b> ： <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3004'then</a> '语句等效于'else'语句。 运行时RegexpTreeBuilder.cs 1080 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3004'then</a> '语句等效于'else'语句。 运行时RegexpTreeBuilder.cs 1093 </li></ul><br> 该代码看起来非常可疑，因为它包含两个条件语句，它们具有相同的<i>then</i>和<i>else</i>分支主体。 在这两种情况下，可能值得返回不同的值。 或者，如果这是一种预期的行为，则删除多余的条件语句将很有用。 <br><br> 有有趣的周期。 下面的例子： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Set&lt;StochasticityPattern&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectPatterns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;StochasticityPattern&gt; patterns</span></span></span><span class="hljs-function">)</span></span> { Set&lt;StochasticityPattern&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Set&lt;StochasticityPattern&gt;(); result.AddRange(patterns); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> changed; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = result.Count; AddIntersections(result); changed = (result.Count != count); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (changed); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3020</a>循环内无条件的“中断”。 编译器DefaultFactorManager.cs 474 <br><br> 由于无条件的<i>break</i>语句，仅执行了循环的一次迭代，并且甚至没有使用<i>更改</i>的控制变量。 通常，该代码看起来很奇怪和可疑。 <br><br> 在另一个类中发现了相同的方法（完全相同的副本）。 相应的分析仪警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3020</a>循环内无条件的“中断”。  Visualizers.Windows FactorManagerView.cs 350 <br><br> 顺便说一句，一种方法在循环中遇到了无条件的<i>continue</i>语句（分析器使用相同的诊断程序发现了该方法），但是上面有一条注释，确认这是一个特殊的临时解决方案： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TEMPORARY continue;</span></span></code> </pre> <br> 我记得在无条件<i>中断</i>声明附近没有这样的评论。 <br><br> 让我们继续前进。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DependencyInformation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDependencyInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... IExpression resultIndex = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultIndex != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.IsDefined( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(SkipIfMatchingIndexIsUniformAttribute), <span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultIndex == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InferCompilerException( parameter.Name + <span class="hljs-string"><span class="hljs-string">" has SkipIfMatchingIndexIsUniformAttribute but "</span></span> + StringUtil.MethodNameToString(method) + <span class="hljs-string"><span class="hljs-string">" has no resultIndex parameter"</span></span>); .... } .... } .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">警告</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a>表达式'resultIndex == null'始终为false。 编译器FactorManager.cs 382 <br><br> 立即，我注意到在声明和上面的验证之间， <i>resultIndex</i>变量的值可以更改。 但是，在<i>两次</i>检查之间， <i>resultIndex！= Null</i>和<i>resultIndex == null，该</i>值无法更改。 因此，表达式<i>resultIndex == null</i>的结果将始终为<i>false</i> ，这意味着永远不会引发异常。 <br><br> 希望您有兴趣自己发现错误，没有我的建议，找到问题，但是为了以防万一，我建议您再做一次。 方法代码很小，我将完整介绍它。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Tuple&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeMovieGenre</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> feature</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] genres = feature.Split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (genres.Length &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; genres.Length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format( <span class="hljs-string"><span class="hljs-string">"Movies should have between 1 and 3 genres; given {0}."</span></span>, genres.Length)); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / genres.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format( <span class="hljs-string"><span class="hljs-string">"{0}:{1}"</span></span>, offset + MovieGenreBuckets[genres[<span class="hljs-number"><span class="hljs-number">0</span></span>]], <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; genres.Length; ++i) { result.Append( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format( <span class="hljs-string"><span class="hljs-string">"|{0}:{1}"</span></span>, offset + MovieGenreBuckets[genres[i].Trim()], <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(MovieGenreBucketCount, result.ToString()); }</code> </pre> <br> 让我们看看这里发生了什么。 输入字符串由字符“ |”解析。 如果数组的长度不符合预期，则必须引发异常。  <i>等待第二个流派</i> ... <i>Length &lt;1 &amp;&amp; genres.Length&gt; 3</i>吗？ 由于没有数字立即落入表达式<i>[[int.MinValue..1）</i>和<i>（3..int.MaxValue]</i>所需的值的范围内，所以表达式的结果将始终为<i>false</i> 。 因此，此检查不能防止任何事情，并且不会引发预期的异常。 <br><br> 这正是分析仪所警告的： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a>表达式'genres.Length &lt;1 &amp;&amp; genres.Length&gt; 3'始终为假。 可能是“ ||” 这里应该使用运算符。 评估器Features.cs 242 <br><br> 遇到可疑裂变术。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTrueThetaAndPhi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expectedRepeatOfTopicInDoc = averageDocLength / numUniqueTopicsPerDoc; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = Poisson.Sample(expectedRepeatOfTopicInDoc); .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3041</a>该表达式从'int'类型隐式转换为'double'类型。 考虑使用显式类型转换以避免丢失小数部分。 例如：double A =（double）（X）/ Y;。  LDA Utilities.cs 74 <br><br> 这是可疑的：执行了整数除法（变量<i>averageDocLength</i>和<i>numUniqueTopicsPerDoc</i>的类型为<i>int</i> ），并将结果写入<i>double</i>类型的变量。 问题是：这是专门完成的，还是仍然暗示着实数除法？ 如果<i>ExpectedRepeatOfTopicInDoc</i>变量的类型为<i>int</i> ，这将清除可能的问题。 <br><br> 在其他地方，例如，使用<i>Poisson.Sample</i>方法（其参数是可疑变量<i>ExpectedRepeatOfTopicInDoc）</i> ，如下所述。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numUniqueWordsPerTopic = Poisson.Sample((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)averageWordsPerTopic);</code> </pre> <br>  <i>averageWordsPerTopic</i>的类型为<i>int</i> ，已在使用位置转换为<i>double</i> 。 <br><br> 这是另一个使用地点： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expectedRepeatOfWordInTopic = ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)numDocs) * averageDocLength / numUniqueWordsPerTopic; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = Poisson.Sample(expectedRepeatOfWordInTopic);</code> </pre> <br> 请注意，变量的名称与原始示例中的名称相同，仅使用实数除法来初始化<i>ExpectedRepeatOfWordInTopic</i> （由于<i>numDocs</i>显式转换为<i>double</i> ）。 <br><br> 通常，值得一提的是分析仪发出警告的起始位置。 <br><br> 但是，对于是否值得编辑以及如何编辑的思考，让代码的作者（他们更好地了解），但是让我们走得更远。 到下一个可疑师。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NonconjugateGaussian </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BAverageLogarithm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_opt = <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> * (Math.Log(mx * mz / Ex2 / <span class="hljs-number"><span class="hljs-number">2</span></span>) - m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v_opt != v) { .... } .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3041</a>该表达式从'int'类型隐式转换为'double'类型。 考虑使用显式类型转换以避免丢失小数部分。 例如：double A =（double）（X）/ Y;。 运行时ProductExp.cs 137 <br><br> 分析仪再次检测到整数除法的可疑运算，如下  <i>2</i>和<i>3</i>是整数数字文字，并且表达式2/3的结果将为<i>0</i> 。 结果，整个表达式采用以下形式： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_opt = <span class="hljs-number"><span class="hljs-number">0</span></span> * expr;</code> </pre> <br> 同意，有点奇怪。 我几次返回到此警告，试图找到某种捕获，而不是尝试将其添加到文章中。 该方法充满了数学和各种公式（坦率地说，我并不想分解），但您永远不知道会发生什么。 此外，我尝试对本文中写出的警告尽可能地表示怀疑，并且只有在对警告进行了更好的研究之后，我才对它们进行描述。 <br><br> 但是后来我想到了-为什么我需要因子<i>0</i> ，写为<i>2/3</i> ？ 所以这个地方还是值得一看的。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TextWriter writer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> defaultValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; converter = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( defaultValue == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Equals(defaultValue)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> stringValue = converter == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ToString() : converter(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); writer.Write(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{name}</span></span></span><span class="hljs-string">=\"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stringValue}</span></span></span><span class="hljs-string">\" "</span></span>); }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>可能取消空引用。 考虑检查“价值”。 编译器WriteHelpers.cs 78 <br><br> 根据条件对分析器进行相当合理的断言。 空引用的解引用可以在表达式<i>value中</i>发生。如果<i>value == null，</i>则<i>等于</i> <i>（defaultValue）</i> 。 由于此表达式是||运算符的右操作数，因此要计算它，左操作数必须为<i>false</i> ，为此，至少一个<i>defaultValue</i> \ <i>value</i>变量不为<i>null</i>就足够了。 结果，如果<i>defaultValue！= Null</i> ，并且<i>value == null</i> ： <br><br><ul><li>  <i>defaultValue == null-</i> &gt; <i>false</i> ; </li><li>  <i>defaultValue == null &amp;&amp; value == null-</i> &gt; <i>false</i> ;  （未进行<i>价值</i>检查） </li><li>  <i>value.Equals（defaultValue）</i> -&gt; <i>NullReferenceException</i> ，因为<i>value</i>为<i>null</i> 。 </li></ul><br> 让我们看一个类似的情况： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FeatureParameterDistribution</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> GaussianMatrix traitFeatureWeightDistribution, GaussianArray biasFeatureWeightDistribution</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( (traitFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; biasFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || traitFeatureWeightDistribution.All( w =&gt; w != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; w.Count == biasFeatureWeightDistribution.Count), <span class="hljs-string"><span class="hljs-string">"The provided distributions should be valid and consistent in the number of features."</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>可能取消空引用。 考虑检查“ traitFeatureWeightDistribution”。 推荐FeatureParameterDistribution.cs 65 <br><br> 我们排除了多余的部分，仅保留了用于计算布尔值的逻辑，因此更容易找出： <br><br><pre> <code class="cs hljs">(traitFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; biasFeatureWeightDistribution == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || traitFeatureWeightDistribution.All( w =&gt; w != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; w.Count == biasFeatureWeightDistribution.Count)</code> </pre> <br> 同样，||的右操作数 仅当左计算的结果为<i>false</i>时才进行计算。 左操作数可以为<i>false</i> ，包括<i>traitFeatureWeightDistribution == null</i>和<i>biasFeatureWeightDistribution！= Null时</i> 。 然后，将计算||运算符的右操作数，并调用<i>traitFeatureWeightDistribution.All</i>将<i>引发</i> <i>ArgumentNullException</i> 。 <br><br> 另一段有趣的代码： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQuantile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> probability, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] quantiles</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = quantiles.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (quantiles == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(quantiles)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"quantiles array is empty"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(quantiles)); .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a>在验证是否为null之前，已使用“分位数”对象。 检查行：91、92。Runtime OuterQuantiles.cs 91 <br><br> 请注意， <i>首先访问</i>了<i>quantiles.Length</i>属性，然后检查了<i>分位数是否</i>为<i>空</i> 。 结果，如果<i>分位数== null</i> ，则该方法将引发异常，只是有一点点错误，而在不需要它的地方会抛出异常。 显然，他们弄乱了地方的线条。 <br><br> 如果您自己已经成功地解决了早期错误的检测问题，建议您冲泡一杯咖啡并尝试重复进行此操作，以下面的方法查找错误。 为了使它更有趣，我引用了该方法的全部代码。 <br><br>  （ <a href="">链接到完整尺寸</a> ） <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c2c/5ff/2d9/c2c5ff2d99aca64bbda4136acfa4b1d4.png" alt="图片2"></p><br><br> 好吧，好吧，那是个玩笑（或者你成功了吗？！）。 让我们简化一下任务： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample.Precision &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { precisionIsBetween = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; lowerBound = <span class="hljs-number"><span class="hljs-number">-1.0</span></span> / v; upperBound = -mean.Precision; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample.Precision &lt; -mean.Precision) { precisionIsBetween = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; lowerBound = <span class="hljs-number"><span class="hljs-number">0</span></span>; upperBound = -mean.Precision; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// in this case, the precision should NOT be in this interval. precisionIsBetween = false; lowerBound = -mean.Precision; lowerBound = -1.0 / v; }</span></span></code> </pre> <br> 变得更好了吗？ 分析仪对此代码发出以下警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3008</a> “ lowerBound”变量已连续两次分配值。 也许这是一个错误。 检查线：324，323。运行时GaussianOp.cs 324 <br><br> 实际上，在最后一个<i>else</i>分支中， <i>lowerBound</i>变量的值连续两次被分配。 显然（根据上面的代码判断），变量<i>upperBound</i>必须包含在其中一个分配中。 <br><br> 我们会进一步。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAucMatrix</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; c &lt; classLabelCount; c++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> labelWidth = labels[c].Length; columnWidths[c + <span class="hljs-number"><span class="hljs-number">1</span></span>] = labelWidth &gt; MaxLabelWidth ? MaxLabelWidth : labelWidth; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; r &lt; classLabelCount; r++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countWidth = MaxValueWidth; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countWidth &gt; columnWidths[c + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { columnWidths[c + <span class="hljs-number"><span class="hljs-number">1</span></span>] = countWidth; } } .... }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3081</a>在嵌套循环内未使用“ r”计数器。 考虑检查“ c”计数器的用法。 命令行ClassifierEvaluationModule.cs 459 <br><br> 请注意，在此循环的主体中未使用内部循环的计数器-r-。 因此，事实证明，在内循环的所有迭代期间，对相同元素执行相同的操作-因为索引还使用外循环的计数器（ <i>c</i> ），而不使用内循环的计数器（ <i>r</i> ）。 <br><br> 让我们看看还有什么有趣的地方。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegexpFormattingSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> putOptionalInSquareBrackets, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> showAnyElementAsQuestionMark, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ignoreElementDistributionDetails, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> truncationLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> escapeCharacters, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useLazyQuantifier</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PutOptionalInSquareBrackets = putOptionalInSquareBrackets; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ShowAnyElementAsQuestionMark = showAnyElementAsQuestionMark; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IgnoreElementDistributionDetails = ignoreElementDistributionDetails; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.TruncationLength = truncationLength; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.EscapeCharacters = escapeCharacters; }</code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3117</a>未使用构造函数参数'useLazyQuantifier'。 运行时RegexpFormattingSettings.cs 38 <br><br> 构造函数不使用一个参数<i>useLazyQuantifier</i> 。 对于在类<i>UseLazyQuantifier中</i>定义了具有相应名称和类型的属性这一事实的背景下，这尤其可疑。 显然，他们忘记了通过相应的参数对其进行初始化。 <br><br> 遇到了几个潜在的危险事件处理程序。 下面是其中之一的示例： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RecommenderRun</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Started; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Report that the run has been started if (this.Started != null) { this.Started(this, EventArgs.Empty); } .... } .... }</span></span></code> </pre> <br>  <b>PVS-Studio警告</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3083</a>对事件'Started'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。 评估程序RecommenderRun.cs 115 <br><br> 事实是，在检查<i>null</i>不等式和调用处理程序之间，可以取消预订事件，并且如果在检查<i>null</i>和处理程序调用之间该事件尚无订阅者，则将<i>抛出NullReferenceException</i> 。 例如，要避免此类问题，您可以将指向委托链的链接保存在局部变量中，或使用“？”运算符。 调用处理程序。 <br><br> 除了上面的代码片段外，还有35个这样的地方。 <br><br> 顺便说一下，还满足了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3024的</a> <b>785条</b>警告。 当使用运算符'！='或'=='比较实数时，会发出警告<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3024</a> 。 我不会在这里详细说明为什么这种比较并不总是正确的-有关此问题的更多信息写在文档中，还有指向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StackOverflow</a>的链接（就是这样）。 <br><br> 考虑到经常满足公式和计算的要求，这些警告也很重要，尽管它们被带到了第3级（因为它们在所有项目中都相去甚远）。 <br><br> 如果您确定这些警告无关紧要，则只需<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单击一下</a>即可将其删除，从而减少了分析仪操作的总数。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/77b/72d/47e77b72dbb716dadbd1623513150819.png"></div><br><br><h2> 结论 </h2><br> 不知何故，我很长一段时间都没有写关于检查项目的文章了，再次触摸这个过程是很愉快的。 希望您也从本文中学到了一些新的或有用的知识，或者至少有兴趣地阅读了一下。 <br><br> 我希望开发人员尽早纠正问题区域，并提醒您犯错误是正常现象，但我们是人。 为此，需要使用诸如静态分析仪之类的其他工具来查找某人错过的东西，对吗？ 无论如何-祝项目进展顺利，并感谢您的工作！ <br><br> 请记住，静态分析仪的最大好处是可以<i>正常使用</i> 。 <br><br> 祝一切顺利！ <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与讲英语的读者分享这篇文章，请使用以下链接：Sergey Vasiliev。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Infer.NET代码中存在什么错误？</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429578/">https://habr.com/ru/post/zh-CN429578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN429564/index.html">“我只是一个项目爱好者和Dart语言的使用者”-著名ng书的作者Ari Lerner访谈</a></li>
<li><a href="../zh-CN429568/index.html">使用Zextras Backup减少服务器崩溃期间的Zimbra停机时间</a></li>
<li><a href="../zh-CN429570/index.html">教特工玩带过滤器的马里奥赛车</a></li>
<li><a href="../zh-CN429572/index.html">使用Devicelock DLP拦截Skype中的私人对话</a></li>
<li><a href="../zh-CN429574/index.html">CheckMates的初学者课程免费检查站</a></li>
<li><a href="../zh-CN429580/index.html">iOS中的微交互。 Yandex讲座</a></li>
<li><a href="../zh-CN429582/index.html">计算机负载模拟指示器</a></li>
<li><a href="../zh-CN429586/index.html">如何确定在交易所进行交易的最佳时间</a></li>
<li><a href="../zh-CN429588/index.html">关于RTOS的全部真相。 第20条 信号量：辅助服务和数据结构</a></li>
<li><a href="../zh-CN429590/index.html">基于SOLR的呼叫中心的语音分析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>