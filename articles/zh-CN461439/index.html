<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕦 🤰🏿 🐧 启动React和TypeScript组件库 ✈️ 🤞🏼 🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我的大部分工作是写后端，但是前一天有一项任务要在React上启动组件库。 几年前，当React版本与我在前端开发中的经验一样小时，我已经对弹丸采取了一种方法，结果变得笨拙而笨拙。 考虑到当前React生态系统的成熟度以及我不断增长的经验，这次我受到启发，可以轻松便捷地完成所有工作。 结果，我对未来的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>启动React和TypeScript组件库</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461439/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nc/57/zc/nc57zcknvdousryimpgxxqsiz1i.jpeg"></div><br><p> 我的大部分工作是写后端，但是前一天有一项任务要在React上启动组件库。 几年前，当React版本与我在前端开发中的经验一样小时，我已经对弹丸采取了一种方法，结果变得笨拙而笨拙。 考虑到当前React生态系统的成熟度以及我不断增长的经验，这次我受到启发，可以轻松便捷地完成所有工作。 结果，我对未来的图书馆感到一片空白，并且为了避免忘记任何东西并将所有东西收集在一个地方，撰写了这篇备忘单文章，这也应该帮助那些不知道从哪里开始的人。 让我们看看我做了什么。 </p><a name="habracut"></a><br><p>  <strong><em>TL / DR：可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上查看准备启动的库的代码</em></strong> </p><br><p> 这个问题可以从两个方面解决： </p><br><ol><li> 查找现成的入门套件，样板或CLI生成器 </li><li> 自己收集一切 </li></ol><br><p> 当您绝对不想处理配置和连接必要的程序包时，第一种方法对于快速入门非常有用。 另外，此选项适用于不知道从哪里开始以及库与常规应用程序之间应该有什么区别的初学者。 </p><br><p> 最初，我采用第一种方法，但是后来我决定更新依赖关系，并固定几个其他的程序包，然后各种错误和不一致性逐渐减少。 结果，他卷起袖子，自己做了一切。 但是我会提到库生成器。 </p><br><h2 id="create-react-library"> 创建反应库 </h2><br><p> 大多数处理React的开发人员都听说过便捷的React应用程序启动器，该启动器可让您最小化项目配置并提供合理的默认值- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建React App</a> （CRA）。 原则上，它可以用于图书馆（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关Habré的文章</a> ）。 但是，ui-kit开发的项目结构和方法与通常的SPA略有不同。 我们需要一个单独的目录，其中包含组件的源代码（src），用于其开发和调试的沙箱（示例），文档和演示工具（“展示柜”）以及一个单独的目录，其中包含准备导出的文件（dist）。 同样，库组件不会添加到SPA应用程序中，而是通过索引文件导出。 考虑到这一点，我去搜索并迅速发现了一个类似的CRA软件包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Creat React Library</a> （CRL）。 </p><br><p> 与CRA一样，CRL是一个易于使用的CLI实用程序。 使用它，您可以生成一个项目。 它将包含： </p><br><ul><li> 配置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">汇总</a>以构建cjs和es模块以及具有对CSS模块的支持的源映射 </li><li> 在ES5中进行转译的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通天</a>塔 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开玩笑</a> </li><li> 我们希望使用TypeScript（TS）作为选项 </li></ul><br><p> 要生成库项目， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们</a>可以做到（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npx</a>允许我们不全局安装软件包）： </p><br><pre><code class="bash hljs">npx create-react-library</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">我们回答提出的问题。</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/wd/ql/qq/wdqlqqfmjrgntiqz6zphcdyccdw.png" alt="CLR问题"></p></div></div><br><p> 通过该实用程序，我们得到了一个已生成且可以立即使用的组件库项目。 </p><br><div class="spoiler">  <b class="spoiler_title">具有一定的结构</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/vs/d4/l2/vsd4l2o2g1wn3n0folb_yr30ui8.png" alt="Clr树"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">然后出了点问题...</b> <div class="spoiler_text"><p> 今天的依赖关系有些过时，因此我决定使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm-check</a>将所有依赖关系更新为最新版本： </p><br><pre> <code class="bash hljs">npx npm-check -u</code> </pre> <br><p> 另一个可悲的事实是， <code>example</code>目录中的沙箱应用程序是用js生成的。 您将必须手动将其重写为TypeScript，添加<code>tsconfig.json</code>和一些依赖项（例如， <code>@types</code>本身和基本的<code>@types</code> ）。 </p><br><p> 另外， <code>react-scripts-ts</code>包被声明为<code>deprecated</code> ，不再受支持。 相反，您应该安装<code>react-scripts</code> ，因为一段时间以来，CRA（其软件包为<code>react-scripts</code> ）从框中开始支持TypeScript（使用Babel 7）。 </p><br><p> 结果，我对库的想法没有掌握拉动<code>react-scripts</code> 。 据我所知，此程序包中的Jest需要<code>isolatedModules</code>编译器选项，这与我从库生成和导出<code>d.ts</code>愿望<code>d.ts</code> （所有这些都与Babel 7的局限性有关， <code>d.ts</code>和<code>react-scripts</code>使用Babel 7的局限性来编译TS ） 因此，我<code>eject</code>了<code>react-scripts</code> ，查看了结果并用手重做了所有内容，稍后将进行介绍。 </p></div></div><br><h2 id="tsdx">  tsdx </h2><br><p> 感谢用户<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">StanEgo</a> ，他谈到了创建React库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-tsdx</a>的绝佳替代方法。 此cli-utility也类似于CRA，并且在一个命令中将使用配置的Rollup，TS，Prettier，husky，Jest和React为您的库创建基础。  React是一个选项。 做起来很简单： </p><br><pre> <code class="bash hljs">npx tsdx create mytslib</code> </pre> <br><p> 因此，将安装软件包的必要新版本并进行所有设置。 获得一个类似CRL的项目。 与CRL的主要区别在于零配置。 也就是说，在tsdx中对我们隐藏了汇总配置（就像CRA一样）。 </p><br><p> 在快速浏览文档后，我没有找到推荐的方法来进行更精细的配置或在CRA中弹出之类的方法。 看了这个项目的问题之后，我发现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">到目前为止没有这种可能性</a> 。 对于某些项目，这可能很关键，在这种情况下，您将需要动手一点。 如果您不需要它，那么tsdx是快速入门的好方法。 </p><br><h2 id="beryom-upravlenie-v-svoi-ruki"> 掌握控制权 </h2><br><p> 但是，如果您走第二种方式自己收集所有东西，该怎么办？ 因此，让我们从头开始。 运行<code>npm init</code>并为该库生成<code>package.json</code> 。 在此处添加有关我们软件包的一些信息。 例如，我们在<code>engines</code>字段中编写node和npm的最低版本。 收集和导出的文件将放置在<code>dist</code>目录中。 我们在<code>files</code>字段中指出这一点。 我们正在创建一个React组件库，因此我们希望用户拥有必要的软件包-我们在<code>peerDependencies</code>字段中<code>peerDependencies</code> <code>react</code>和<code>react-dom</code> <code>peerDependencies</code>最低要求版本。 </p><br><p> 现在，将<code>react</code>和<code>react-dom</code>软件包以及必要的类型（因为我们将在TypeScript上看到组件）安装为devDependencies（类似于本文中的所有软件包）： </p><br><pre> <code class="bash hljs">npm install --save-dev react react-dom @types/react @types/react-dom</code> </pre> <br><p> 安装TypeScript： </p><br><pre> <code class="bash hljs">npm install --save-dev typescript</code> </pre> <br><p> 让我们为主要代码和测试创建配置文件： <code>tsconfig.json</code>和<code>tsconfig.test.json</code> 。 我们的<code>target</code>将在<code>es5</code> ，我们将生成<code>sourceMap</code>等。 可能的选项及其含义的完整列表可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>找到。 不要忘记在<code>include</code>源目录，并在<code>node_modules</code>添加<code>node_modules</code>和<code>dist</code>目录。 在<code>package.json</code>我们在类型字段中指示获取库类型的位置<code>dist/index</code> 。 </p><br><p> 为库的源组件创建<code>src</code>目录。 添加各种各样的小东西，例如<code>.gitignore</code> ， <code>.editorconfig</code> ，具有许可证的文件和<code>README.md</code> 。 </p><br><h3 id="rollup"> 汇总 </h3><br><p> 根据CRL的建议，我们将使用汇总进行组装。 必需的程序包和配置，我还监视了CRL。 总的来说，我听到这样的观点，即汇总对于库和Webpack对于应用程序都是有益的。 但是，我没有配置Webpack（CRA为我做了什么），但是Rollup确实非常好，简单且美观。 </p><br><p> 安装： </p><br><pre> <code class="bash hljs">npm install --save-dev rollup rollup-plugin-babel rollup-plugin-commonjs rollup-plugin-node-resolve rollup-plugin-peer-deps-external rollup-plugin-postcss rollup-plugin-typescript2 rollup-plugin-url @svgr/rollup</code> </pre> <br><p> 在<code>package.json</code>按照<code>rollup</code>推荐给我们的字段添加收集的库包分发的字段<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-pkg.module</a> ： </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/index.es.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"jsnext:main"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/index.es.js"</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">创建配置文件rollup.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typescript <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rollup-plugin-typescript2'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> commonjs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rollup-plugin-commonjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> external <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rollup-plugin-peer-deps-external'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> postcss <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rollup-plugin-postcss'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> resolve <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rollup-plugin-node-resolve'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rollup-plugin-url'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> svgr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@svgr/rollup'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pkg <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./package.json'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">input</span></span>: <span class="hljs-string"><span class="hljs-string">'src/index.tsx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">file</span></span>: pkg.main, <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">'cjs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exports</span></span>: <span class="hljs-string"><span class="hljs-string">'named'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sourcemap</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">file</span></span>: pkg.module, <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">'es'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exports</span></span>: <span class="hljs-string"><span class="hljs-string">'named'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sourcemap</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [ external(), postcss({ <span class="hljs-attr"><span class="hljs-attr">modules</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">extract</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">minimize</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">sourceMap</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }), url(), svgr(), resolve(), typescript({ <span class="hljs-attr"><span class="hljs-attr">rollupCommonJSResolveHack</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">clean</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }), commonjs() ] };</code> </pre> </div></div><br><p> 配置是一个js文件，或者是一个导出的对象。 在<code>input</code>字段中，指定用于注册我们的库导出文件的文件。  <code>output</code> -描述我们对<code>output</code>的期望-在哪个模块中以格式进行编译以及将其放置在何处。 </p><br><div class="spoiler">  <b class="spoiler_title">接下来是带有插件列表和配置的字段</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rollup-plugin-peer-deps-external-</a>允许您从<code>bundle</code>排除<code>peerDependencies</code>以减小其大小。 这是合理的，因为期望库用户使用<code>peerDependencies</code> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rollup-plugin-postcss-</a>集成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PostCss</a>和Rollup。 在这里，我们禁用css-modules，将css包含在库中的export包中，将其最小化并启用sourceMap的创建。 如果不导出库组件使用的CSS以外的任何CSS，则可以避免<code>extract</code> -组件中必要的CSS将根据需要最终添加到页面的head标签中。 但是，在我的情况下，有必要分发一些其他的CSS（网格，颜色等），并且客户端将必须将CSS捆绑库显式连接到其自身。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rollup-plugin-url-</a>允许您导出各种资源，例如图片 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">svgr-</a>将svg转换为React组件 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rollup-plugin-node-</a> resolve-定义第三方模块在node_modules中的位置 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rollup-plugin-typescript2-</a>连接TypeScript编译器并提供对其进行配置的功能 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rollup-plugin-commonjs-</a>将commonjs依赖项模块转换为es模块，以便可以将它们包含在bundle中 </li></ul></div></div><br><p> 在<code>scripts</code> <code>package.json</code>字段中添加一个命令以进行构建（ <code>"build": "rollup -c"</code> ）并在开发过程中以监视模式启动该程序集（ <code>"start": "rollup -c -w &amp;&amp; npm run prettier-watch"</code> ） 。 </p><br><h3 id="pervyy-komponent-i-eksportnyy-fayl"> 第一个组件和导出文件 </h3><br><p> 现在，我们将编写最简单的react组件来检查我们的程序集如何工作。 库中的每个组件都将放置在父目录<code>src/components/ExampleComponent</code>的单独目录中。 该目录将包含与组件相关的所有文件<code>test.tsx</code> ， <code>css</code> ， <code>test.tsx</code>等。 <br> 让我们为组件创建一些样式文件，并为组件本身创建<code>tsx</code>文件。 </p><br><div class="spoiler">  <b class="spoiler_title">ExampleComponent.tsx</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class ExampleComponent */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./ExampleComponent.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface Props { <span class="hljs-comment"><span class="hljs-comment">/** * Simple text prop **/</span></span> text: string; } <span class="hljs-comment"><span class="hljs-comment">/** My First component */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Props</span></span></span><span class="hljs-class">&gt; </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"test"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Example Component: {text} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Coool!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ExampleComponent;</code> </pre> </div></div><br><p> 同样在<code>src</code>您需要创建一个具有库通用类型的文件，其中将声明css和svg的类型（在CRL处窥视）。 </p><br><div class="spoiler">  <b class="spoiler_title">打字</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Default CSS definition for typescript, * will be overridden with file-specific definitions by rollup */</span></span> declare <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> <span class="hljs-string"><span class="hljs-string">'*.css'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content: { [className: string]: string }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> content; } interface SvgrComponent extends React.FunctionComponent&lt;React.SVGAttributes&lt;SVGElement&gt;&gt; {} declare <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> <span class="hljs-string"><span class="hljs-string">'*.svg'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svgUrl: string; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svgComponent: SvgrComponent; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> svgUrl; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { svgComponent <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ReactComponent }; }</code> </pre> </div></div><br><p> 必须在导出文件中指定所有导出的组件和CSS。 我们有<code>src/index.tsx</code> 。 如果项目中未使用某些css，并且未将其列为导入<code>src/index.tsx</code>的那些<code>src/index.tsx</code> ，那么它将被扔出程序集，这很好。 </p><br><div class="spoiler">  <b class="spoiler_title">src / index.tsx</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ExampleComponent, Props } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ExampleComponent'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./export.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { ExampleComponent, Props };</code> </pre> </div></div><br><p> 现在，您可以尝试构建库<code>npm run build</code> 。 结果， <code>rollup</code>开始，并将我们的库收集到包中，这些包将在<code>dist</code>目录中找到。 </p><br><p> 接下来，我们添加了一些工具来改善我们的开发过程及其结果的质量。 </p><br><h3 id="zabyvaem-o-formatirovanii-koda-s-prettier"> 忘记使用Prettier进行代码格式化 </h3><br><p> 我讨厌在代码审查中指出格式化对于项目来说是粗心的或非标准的，甚至对此争论不休。 这些缺陷自然应该得到修复，但是开发人员应该专注于代码的功能和方式，而不是外观。 这些修补程序是自动化的第一个候选对象。 这个漂亮的程序包非常<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">漂亮</a> 。 安装它： </p><br><pre> <code class="bash hljs">npm install --save-dev prettier</code> </pre> <br><p> 添加配置以略微完善格式设置规则。 </p><br><div class="spoiler">  <b class="spoiler_title">.prettierrc.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"tabWidth"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"singleQuote"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"jsxBracketSameLine"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"arrowParens"</span></span>: <span class="hljs-string"><span class="hljs-string">"always"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"printWidth"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">"semi"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bracketSpacing"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> </div></div><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>看到可用规则的​​含义。 创建配置文件本身后，WebStrom将在通过IDE开始格式化时建议使用<code>prettier</code>样式。 为避免格式化浪费时间，请使用<code>.prettierignore</code>文件（格式类似于<code>.gitignore</code> ）将<code>/node_modules</code>和<code>/dist</code>目录添加到异常中。 现在，您可以通过将格式化规则应用于源代码来<code>prettier</code>运行： </p><br><pre> <code class="bash hljs">prettier --write <span class="hljs-string"><span class="hljs-string">"**/*"</span></span></code> </pre> <br><p> 为了避免每次都用手动方式显式运行命令并确保其他项目开发人员的代码也将被格式化，请在<code>precommit-hook</code>为标记为<code>staged</code>的文件添加<code>prettier</code>运行（通过<code>git add</code> ）。 对于这样的事情，我们需要两个工具。 首先，它是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hasky</a> ，负责在提交，推送等之前执行任何命令。 其次，它是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">lint-staged的</a> ，可以在已<code>staged</code>文件上运行不同的linter。 我们只需要执行一行就可以交付这些软件包并将启动命令添加到<code>package.json</code> ： </p><br><pre> <code class="bash hljs">npx mrm lint-staged</code> </pre> <br><p> 我们不能在提交之前等待格式，但是请确保在我们的工作过程中， <code>prettier</code>文件在修改后的文件中始终有效。 是的，我们需要另一个package- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">onchange</a> 。 它使您可以监视项目中文件的更改，并立即对其执行必要的命令。 安装： </p><br><pre> <code class="bash hljs">npm install --save-dev --save-exact onchange</code> </pre> <br><p> 然后，在<code>package.json</code>添加到<code>scripts</code>字段命令： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"prettier-watch"</span></span>: <span class="hljs-string"><span class="hljs-string">"onchange 'src/**/*' -- prettier --write {{changed}}"</span></span></code> </pre> <br><p> 因此，有关项目格式的所有争议都可以视为已解决。 </p><br><h3 id="izbegaem-oshibok-s-eslint"> 避免ESLint错误 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ESLint</a>早已成为一种标准，几乎可以在所有js和ts项目中找到。 他也会帮助我们。 在ESLint配置中，我信任CRA，因此只需从CRA中获取必要的软件包并将其插入我们的库即可。 另外，为TS和<code>prettier</code>配置添加配置（以避免<code>ESLint</code>和<code>prettier</code>冲突）： </p><br><pre> <code class="bash hljs">npm install --save-dev eslint eslint-config-react-app eslint-loader eslint-plugin-flowtype eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser babel-eslint eslint-config-prettier eslint-plugin-prettier</code> </pre> <br><p> 使用配置文件<code>ESLint</code> 。 </p><br><div class="spoiler">  <b class="spoiler_title">.eslintrc.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extends"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"plugin:@typescript-eslint/recommended"</span></span>, <span class="hljs-string"><span class="hljs-string">"react-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"prettier"</span></span>, <span class="hljs-string"><span class="hljs-string">"prettier/@typescript-eslint"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"@typescript-eslint"</span></span>, <span class="hljs-string"><span class="hljs-string">"react"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@typescript-eslint/no-empty-interface"</span></span>: <span class="hljs-string"><span class="hljs-string">"off"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@typescript-eslint/explicit-function-return-type"</span></span>: <span class="hljs-string"><span class="hljs-string">"off"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"@typescript-eslint/explicit-member-accessibility"</span></span>: <span class="hljs-string"><span class="hljs-string">"off"</span></span> } }</code> </pre> </div></div><br><p> 将命令<code>lint</code> <code>eslint src/**/* --ext .ts,.tsx --fix</code>到<code>package.json</code>的<code>scripts</code>字段。 现在您可以通过<code>npm run lint</code>运行eslint。 </p><br><h3 id="testiruem-s-jest"> 用笑话测试 </h3><br><p> 要编写库组件的单元测试，请安装并配置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jest</a> （来自Facebook的测试库）。 但是，由于 我们不是通过babel 7而是通过tsc编译TS，那么我们也需要安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ts-jest</a>软件包： </p><br><pre> <code class="bash hljs">npm install --save-dev jest ts-jest @types/jest</code> </pre> <br><p> 为了使Jest正确接受css或其他文件的导入，您需要将其替换为mokami。 创建<code>__mocks__</code>目录，并在其中创建两个文件。 <br>  <code>styleMock.ts</code> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = {};</code> </pre> <br><p>  <code>fileMock.ts</code> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-string"><span class="hljs-string">'test-file-stub'</span></span>;</code> </pre> <br><p> 现在创建Jest配置。 </p><br><div class="spoiler">  <b class="spoiler_title">jest.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">preset</span></span>: <span class="hljs-string"><span class="hljs-string">'ts-jest'</span></span>, <span class="hljs-attr"><span class="hljs-attr">testEnvironment</span></span>: <span class="hljs-string"><span class="hljs-string">'node'</span></span>, <span class="hljs-attr"><span class="hljs-attr">moduleNameMapper</span></span>: { <span class="hljs-string"><span class="hljs-string">'\\.(css|less|sass|scss)$'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;rootDir&gt;/__mocks__/styleMock.ts'</span></span>, <span class="hljs-string"><span class="hljs-string">'\\.(gif|ttf|eot|svg)$'</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;rootDir&gt;/__mocks__/fileMock.ts'</span></span> } };</code> </pre> </div></div><br><p> 我们将在其目录中为<code>ExampleComponent</code>编写最简单的测试。 </p><br><div class="spoiler">  <b class="spoiler_title">ExampleComponent.test.tsx</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ExampleComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ExampleComponent'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'ExampleComponent'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'is truthy'</span></span>, () =&gt; { expect(ExampleComponent).toBeTruthy(); }); });</code> </pre> </div></div><br><p> 将<code>test</code> <code>npm run lint &amp;&amp; jest</code>命令添加到<code>package.json</code>的<code>scripts</code>字段。 为了提高可靠性，我们还将驾驶短绒。 现在，您可以运行我们的测试，并确保它们通过<code>npm run test</code> 。 为了使测试不会在汇编过程中掉入<code>dist</code> ，请将<code>Rollup</code> config插件中的<code>exclude</code>字段添加到<code>exclude</code>字段- <code>['src/**/*.test.(tsx|ts)']</code> 。 在运行<code>lint-staged</code>之前，在<code>husky pre-commit hook</code>指定运行测试- <code>"pre-commit": "npm run test &amp;&amp; lint-staged"</code> 。 </p><br><h3 id="razrabatyvaem-dokumentiruem-i-lyubuemsya-komponentami-s-storybook"> 使用故事书设计，记录和欣赏组件 </h3><br><p> 每个图书馆都需要良好的文档才能成功且富有成效地使用。 至于界面组件库，我不仅要阅读它们，而且要看它们的外观，最好触摸和更改它们。 为了支持这样的心愿单，有几种解决方案。 我曾经使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Styleguidist</a> 。 这个包允许您以markdown格式编写文档，并将所描述的React组件的示例插入其中。 此外，还收集了文档，并从中获得了site-showcase-catalog，您可以在其中找到该组件，阅读有关该组件的文档，了解其参数以及向其中戳入一根魔杖。 </p><br><p> 但是，这次我决定仔细看看他的竞争对手<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Storybook</a> 。 如今，其插件系统似乎更加强大。 此外，它不断发展，拥有一个庞大的社区，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不久</a>还将开始使用markdown文件生成其文档页面。 故事书的另一个优点是它是一个沙箱-用于隔离组件开发的环境。 这意味着我们不需要任何完整的示例应用程序来进行组件开发（如CRL所建议的）。 在故事书中，我们编写<code>stories</code> -ts文件，在其中将带有一些输入<code>props</code>组件转移到特殊功能（最好查看代码以使其更清楚）。 结果，从这些<code>stories</code>构建了一个展示应用程序。 </p><br><p> 运行初始化故事书的脚本： </p><br><pre> <code class="bash hljs">npx -p @storybook/cli sb init</code> </pre> <br><p> 现在与TS交朋友。 为此，我们需要更多软件包，同时，我们将添加几个有用的附加组件： </p><br><pre> <code class="bash hljs">npm install --save-dev awesome-typescript-loader @types/storybook__react @storybook/addon-info react-docgen-typescript-loader @storybook/addon-actions @storybook/addon-knobs @types/storybook__addon-info @types/storybook__addon-knobs webpack-blocks</code> </pre> <br><p> 该脚本创建了一个带有<code>storybook</code>配置的目录<code>.storybook</code>并创建了一个我们无情删除的示例目录。 在配置目录中，我们将扩展<code>addons</code>和<code>config</code>更改为<code>ts</code> 。 我们将addons添加到<code>addons.ts</code>文件： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/addon-actions/register'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/addon-links/register'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/addon-knobs/register'</span></span>;</code> </pre> <br><p> 现在，您需要使用<code>.storybook</code>目录中的webpack配置来帮助故事书。 </p><br><div class="spoiler">  <b class="spoiler_title">webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ config }</span></span></span><span class="hljs-function">) =&gt;</span></span> { config.module.rules.push({ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.(ts|tsx)$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'awesome-typescript-loader'</span></span>) }, <span class="hljs-comment"><span class="hljs-comment">// Optional { loader: require.resolve('react-docgen-typescript-loader') } ] }); config.resolve.extensions.push('.ts', '.tsx'); return config; };</span></span></code> </pre> </div></div><br><p> 让我们对<code>config.ts</code>配置进行一些调整，添加装饰器以将附加组件连接到我们所有的故事。 </p><br><div class="spoiler">  <b class="spoiler_title">配置文件</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { configure } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { addDecorator } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withInfo } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/addon-info'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withKnobs } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/addon-knobs'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// automatically import all files ending in *.stories.tsx const req = require.context('../src', true, /\.stories\.tsx$/); function loadStories() { req.keys().forEach(req); } configure(loadStories, module); addDecorator(withInfo); addDecorator(withKnobs);</span></span></code> </pre> </div></div><br><p> 我们将在组件目录<code>ExampleComponent</code>编写第一个<code>story</code> </p><br><div class="spoiler">  <b class="spoiler_title">ExampleComponent.stories.tsx</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { storiesOf } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ExampleComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ExampleComponent'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { text } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@storybook/addon-knobs/react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stories = storiesOf(<span class="hljs-string"><span class="hljs-string">'ExampleComponent'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); stories.add(<span class="hljs-string"><span class="hljs-string">'ExampleComponent'</span></span>, () =&gt; &lt;ExampleComponent text={text('text', 'Some text')} /&gt;, { info: { inline: true }, text: ` ### Notes Simple example component ### Usage ~~~js &lt;ExampleComponent text="Some text" /&gt; ~~~ ` });</code> </pre> <br><p> 我们使用了插件： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">旋钮</a> -可以实时更改故事书中显示的组件中的道具。 为此，将道具包装在故事的特殊功能中 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> -允许您向故事页面添加道具的文档和描述 </li></ul></div></div><br><p> 现在注意，故事书初始化脚本将storybook命令添加到了我们的<code>package.json</code> 。 使用它来运行<code>npm run storybook</code> 。 故事书将在<code>http://localhost:6006</code>处组装并运行。 不要忘记在<code>Rollup</code> config- <code>'src/**/*.stories.tsx'</code>为<code>typescript</code>模块添加例外。 </p><br><h3 id="razrabatyvaem"> 我们正在发展 </h3><br><p> 因此，在为自己准备了许多方便的工具并为工作做好准备之后，就可以开始开发新的组件了。 每个组件将以<code>src/components</code>名称放在<code>src/components</code>目录中。 它将包含与之关联的所有文件-css，tsx文件中的组件本身，测试，故事。 我们启动故事书，为组件创建故事，然后在其中编写文档。 我们创建测试并进行测试。 完成组件的进出口记录在<code>index.ts</code> 。 </p><br><p> 此外，您可以登录<code>npm</code>并将库作为新的npm软件包发布。 您可以直接从master和其他分支的git存储库中将其连接。 例如，对于我的工件，您可以执行以下操作： </p><br><pre> <code class="bash hljs">npm i -s git+https://github.com/jmorozov/react-library-example.git</code> </pre> <br><p> 因此，在库使用者应用程序的<code>node_modules</code>目录中，只有<code>dist</code>目录的内容处于组装状态，您需要在<code>scripts</code>字段中添加<code>"prepare": "npm run build"</code>命令<code>"prepare": "npm run build"</code> 。 </p><br><p> 另外，由于有了TS，IDE中的自动补全功能就可以使用了。 </p><br><h2 id="podvodim-itogi"> 总结一下 </h2><br><p> 在2019年中，您可以使用便捷的开发工具迅速开始在React和TypeScript上开发组件库。 借助自动化实用程序和手动模式均可获得此结果。 如果需要当前程序包和更多控制权，则首选第二种方法。 最主要的是要知道在哪里进行挖掘，并希望借助本文中的示例，这变得有些容易。 </p><br><p> 您也可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>取出生成的工件。 </p><br><p> 除其他外，我不假装是终极真理，并且通常来说，我从事前端工作。 您可以选择其他软件包和配置选项，也可以成功创建组件库。 如果您在评论中分享您的食谱，我会很高兴。 编码愉快！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461439/">https://habr.com/ru/post/zh-CN461439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461425/index.html">如何成为产品经理并进一步发展</a></li>
<li><a href="../zh-CN461431/index.html">“喜欢和不喜欢”：通过HTTPS进行DNS</a></li>
<li><a href="../zh-CN461433/index.html">在Net Core 3.0中使用Identity Server 4</a></li>
<li><a href="../zh-CN461435/index.html">使用卷积神经网络进行情感识别</a></li>
<li><a href="../zh-CN461437/index.html">370个灯泡</a></li>
<li><a href="../zh-CN461441/index.html">使用R.并行计算，图形，xlsx，电子邮件和所有这些报告存储状态</a></li>
<li><a href="../zh-CN461443/index.html">分析后：有关SKS Keyserver加密密钥服务器网络的最新攻击的已知信息</a></li>
<li><a href="../zh-CN461447/index.html">关于系统管理员是濒临灭绝的物种的史诗</a></li>
<li><a href="../zh-CN461449/index.html">PhpStorm 2019.2：PHP 7.4键入的属性，重复的Finder，EditorConfig，Shell脚本等</a></li>
<li><a href="../zh-CN461451/index.html">我与Haiku的第二天：很高兴，但还没准备好走</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>