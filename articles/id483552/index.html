<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏼 😔 🍧 MVVM dan pemilihan elemen dalam adaptor 👈🏽 👨🏼‍🏫 🖨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sudah setelah tentang adaptor 3 yang ditulis sendiri, di mana perlu untuk menerapkan logika mengingat elemen yang dipilih, saya punya pemikiran bahwa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVVM dan pemilihan elemen dalam adaptor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483552/"><p> Sudah setelah tentang adaptor 3 yang ditulis sendiri, di mana perlu untuk menerapkan logika mengingat elemen yang dipilih, saya punya pemikiran bahwa harus ada beberapa solusi yang sudah mencakup semua yang diperlukan.  Apalagi jika selama proses pengembangan Anda harus mengubah kemampuan untuk memilih hanya satu item untuk pilihan ganda. </p><br><p> Setelah mempelajari pendekatan MVVM dan sepenuhnya tenggelam di dalamnya, pertanyaan yang disebutkan di atas muncul jauh lebih nyata.  Selain itu, adaptor itu sendiri berada pada tingkat <code>View</code> , sedangkan informasi tentang elemen yang dipilih seringkali sangat diperlukan untuk <code>ViewModel</code> . </p><br><p>  Mungkin saya tidak menghabiskan cukup waktu untuk mencari jawaban di Internet, tetapi, bagaimanapun juga, saya tidak menemukan solusi yang sudah jadi.  Namun, di salah satu proyek saya datang dengan ide implementasi yang bisa universal, jadi saya ingin membaginya. <a name="habracut"></a></p><br><p>  <strong><em>Komentar</em></strong> .  Meskipun akan logis dan sesuai untuk MVVM di Android untuk membuat implementasi dengan <code>LiveData</code> , pada tahap ini saya tidak siap untuk menulis kode menggunakannya.  Jadi ini hanya untuk masa depan.  Tetapi solusi akhirnya ternyata tanpa ketergantungan <code>Android</code> , yang berpotensi memungkinkan untuk menggunakannya pada platform mana pun di mana kotlin dapat bekerja. </p><br><h2 id="selectionmanager">  Manajer Seleksi </h2><br><p>  Untuk mengatasi masalah ini, antarmuka <code>SelectionManager</code> umum dikompilasi: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectionManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearSelection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selectPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPositionSelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerSelectionChangeListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(listener: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">position</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, isSelected: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Disposable <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSelectedPositions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ArrayList&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAnySelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSelectionInterceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(interceptor: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">position</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, isSelected: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, callback: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Disposable }</code> </pre> <br><p>  Secara default, sudah ada 3 implementasi yang berbeda: </p><br><ul><li>  <code>MultipleSelection</code> - objek memungkinkan Anda untuk memilih elemen sebanyak yang Anda suka dari daftar; </li><li>  <code>SingleSelection</code> - sebuah objek memungkinkan Anda memilih hanya satu elemen; </li><li>  <code>NoneSelection</code> - objek tidak memungkinkan untuk memilih elemen sama sekali. </li></ul><br><p>  Mungkin, dengan yang terakhir akan ada sebagian besar dari semua pertanyaan, jadi saya akan mencoba menunjukkan pada contoh. </p><br><h2 id="adapter">  Adaptor </h2><br><p>  Seharusnya menambahkan objek <code>SelectionManager</code> ke adaptor sebagai ketergantungan melalui konstruktor. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestAdapter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectionManager: SelectionManager) : RecyclerView.Adapter&lt;TestHolder&gt;() { <span class="hljs-comment"><span class="hljs-comment">//class body }</span></span></code> </pre> <br><p>  Dalam contoh ini, saya tidak akan repot dengan logika pemrosesan mengklik suatu elemen, jadi kami hanya setuju bahwa pemegang (tanpa detail) sepenuhnya bertanggung jawab untuk menunjuk pendengar klik. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestHolder</span></span></span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">, onItemClick: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//all bind logic } }</span></span></code> </pre> <br><p>  Lebih lanjut, agar keajaiban ini bekerja, adaptor harus melakukan 3 langkah berikut: </p><br><h4 id="1-onbindviewholder"> <code>1. onBindViewHolder</code> </h4> <br><p>  Lewati panggilan balik ke metode <code>bind</code> pemegang, yang akan memanggil <code>selectionManager.selectPosition(position)</code> untuk elemen yang ditampilkan.  Juga di sini, Anda kemungkinan besar perlu mengubah tampilan (paling sering hanya latar belakang) tergantung pada apakah item saat ini dipilih - Anda dapat memanggil <code>selectionManager.isPositionSelected(position)</code> untuk ini. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TestHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isItemSelected = selectionManager.isPositionSelected(position) <span class="hljs-comment"><span class="hljs-comment">//do whatever you need depending on `isItemSelected` value val item = ... //get current item by `position` value holder.bind(item) { selectionManager.selectPosition(position) } }</span></span></code> </pre> <br><h4 id="2-registerselectionchangelistener"> <code>2. registerSelectionChangeListener</code> </h4> <br><p>  Agar adaptor dapat memperbarui elemen yang ditekan tepat waktu, Anda harus berlangganan ke tindakan yang sesuai.  Dan jangan lupa bahwa hasil yang dikembalikan oleh metode berlangganan harus disimpan. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectionDisposable = selectionManager.registerSelectionChangeListener { position, isSelected -&gt; notifyItemChanged(position) }</code> </pre> <br><p>  Saya perhatikan bahwa dalam hal ini nilai parameter <code>isSelected</code> tidak penting, karena dengan perubahan apa pun, perubahan elemen akan berubah.  Tetapi tidak ada yang mencegah Anda menambahkan pemrosesan tambahan, yang penting nilai ini. </p><br><h4 id="3-selectiondisposable"> <code>3. selectionDisposable</code> </h4> <br><p>  Pada langkah sebelumnya, saya tidak hanya mengatakan bahwa hasil dari metode ini harus disimpan - sebuah objek dikembalikan yang menghapus langganan untuk menghindari kebocoran.  Setelah menyelesaikan pekerjaan, objek ini harus dikonsultasikan. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { selectionDisposable.dispose() }</code> </pre> <br><h2 id="viewmodel">  ViewModel </h2><br><p>  Untuk adaptor sihir sudah cukup, kita akan beralih ke <code>ViewModel</code> .  Menginisialisasi <code>SelectionManager</code> sangat sederhana: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestViewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectionManager: SelectionManager = SingleSelection() }</code> </pre> <br><p>  Di sini, dengan analogi dengan adaptor, Anda dapat berlangganan perubahan (misalnya, untuk membuat tombol "Hapus" tidak dapat diakses ketika tidak ada item yang dipilih), tetapi Anda juga dapat mengklik tombol ringkasan (misalnya, "Unduh Terpilih") untuk mendapatkan daftar semua yang dipilih . </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDownloadClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedPositions: ArrayList&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; = selectionManager.getSelectedPositions() ... }</code> </pre> <br><p>  Dan di sini salah satu kekurangan solusi saya muncul: pada tahap saat ini, objek hanya dapat menyimpan posisi elemen.  Artinya, untuk mendapatkan objek yang dipilih secara tepat, dan bukan posisinya, logika tambahan akan diperlukan menggunakan sumber data yang terhubung ke adaptor (sayangnya, sejauh ini saja).  Tapi semoga Anda bisa mengatasinya. </p><br><p>  Selanjutnya hanya menghubungkan adaptor dengan model tampilan.  Ini sudah di tingkat aktivitas. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> adapter: TestAdapter <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewModel: TestViewModel <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//`TestViewModel` initialization adapter = TestAdapter(viewModel.selectionManager) } }</span></span></code> </pre> <br><h2 id="gibkost">  Fleksibilitas </h2><br><p>  Untuk beberapa orang, ini mungkin cukup dimengerti, tetapi saya juga ingin mencatat bahwa dengan implementasi ini ternyata mudah untuk mengontrol metode pemilihan pada adaptor.  Sekarang adaptor hanya dapat memilih satu elemen, tetapi jika <code>TestViewModel</code> mengubah inisialisasi properti <code>selectionManager</code> di <code>TestViewModel</code> , sisa kode akan bekerja "dengan cara baru" tanpa memerlukan perubahan apa pun.  Yaitu, atur <code>val selectionManager: SelectionManager = MultipleSelection()</code> , dan sekarang adaptor memungkinkan Anda untuk memilih elemen sebanyak yang Anda suka. </p><br><p>  Dan jika Anda memiliki semacam kelas adaptor dasar untuk seluruh aplikasi, Anda tidak perlu takut untuk memasukkan <code>SelectionManager</code> dengan cara yang sama.  Memang, terutama untuk adaptor yang tidak menyiratkan pilihan elemen sama sekali, ada implementasi <code>NoneSelection</code> - tidak peduli apa yang Anda lakukan dengannya, itu tidak akan pernah memiliki elemen yang dipilih dan tidak akan pernah memanggil salah satu pendengar.  Tidak, dia tidak melempar pengecualian - dia mengabaikan semua panggilan, tetapi adaptor tidak perlu mengetahui hal ini sama sekali. </p><br><h2 id="interceptor">  Pencegat </h2><br><p>  Ada juga kasus di mana perubahan dalam pemilihan elemen disertai dengan operasi tambahan (misalnya, memuat informasi terperinci), sebelum penyelesaian yang berhasil di mana penerapan perubahan mengarah ke keadaan yang salah.  Khusus untuk kasus-kasus ini, saya menambahkan mekanisme intersepsi. </p><br><p>  Untuk menambahkan interseptor, Anda perlu memanggil metode <code>addSelectionInterceptor</code> (sekali lagi, Anda perlu menyimpan hasilnya dan mengaksesnya setelah selesai).  Salah satu parameter pencegat dalam contoh <code>callback: () -&gt; Unit</code> - sampai dipanggil, perubahan tidak akan diterapkan.  Artinya, dengan tidak adanya jaringan, pemuatan informasi terperinci dari server tidak dapat diselesaikan dengan sukses, oleh karena itu, keadaan Manajer <code>selectionManager</code> digunakan tidak akan berubah.  Jika ini persis perilaku yang Anda perjuangkan - Anda perlu metode ini. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> interceptionDisposable = selectionManager.addSelectionInterceptor { position: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, isSelected: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, callback: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isSelected) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedItem = ... <span class="hljs-comment"><span class="hljs-comment">//get current item by `position` value val isDataLoadingSuccessful: Boolean = ... //download data for `selectedItem` if(isDataLoadingSuccessful) { callback() } } }</span></span></code> </pre> <br><p>  Jika perlu, Anda dapat menghubungkan pencegat sebanyak yang Anda suka.  Dalam hal ini, <code>callback()</code> dari pencegat pertama mulai memproses yang kedua.  Dan hanya <code>callback()</code> di yang terakhir yang pada akhirnya akan menyebabkan perubahan dalam status seleksiManager. </p><br><h2 id="perspektivy">  Prospek </h2><br><ol><li>  Menggunakan <code>Disposable</code> untuk menghapus langganan efektif, tetapi tidak <code>LiveData</code> .  Peningkatan pertama di telepon adalah menggunakan kemampuan <code>android.arch.lifecycle</code> untuk pekerjaan yang lebih nyaman.  Kemungkinan besar, ini akan menjadi proyek yang terpisah, sehingga tidak menambah ketergantungan platform ke yang sekarang. </li><li>  Seperti yang saya katakan, mendapatkan daftar objek yang dipilih ternyata tidak nyaman.  Saya juga ingin mencoba mengimplementasikan objek yang dapat bekerja dengan wadah data dengan cara yang sama.  Pada saat yang sama, itu bisa menjadi sumber data untuk adaptor. </li></ol><br><h2 id="ssylki">  Referensi </h2><br><p>  Anda dapat menemukan kode sumber di tautan - <a href="https://github.com/Ircover/SelectionManager">GitHub</a> <br>  Proyek ini juga tersedia untuk implementasi melalui gradle - <code>ru.ircover.selectionmanager:core:1.0.0</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483552/">https://habr.com/ru/post/id483552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483538/index.html">Menghubungkan Layar 10 "ER-TFT101-1 ke STM32F429 via FMC</a></li>
<li><a href="../id483540/index.html">ChaiScript - bahasa scripting untuk C ++</a></li>
<li><a href="../id483542/index.html">Intisari telekomunikasi - materi tentang pekerjaan penyedia</a></li>
<li><a href="../id483544/index.html">Data baru membantah asumsi utama energi gelap</a></li>
<li><a href="../id483550/index.html">Layanan dan Pengembangan IaaS: Kompilasi Awan, Penyimpanan, dan Evolusi 1cloud</a></li>
<li><a href="../id483554/index.html">Platform teknologi baru tahun 20-an. Kenapa saya tidak setuju dengan Zuckerberg</a></li>
<li><a href="../id483556/index.html">Laporan Bank of America: 5 tren yang akan mengubah ekonomi global dalam sepuluh tahun ke depan</a></li>
<li><a href="../id483558/index.html">Perpustakaan Webix JavaScript melalui mata seorang pemula</a></li>
<li><a href="../id483564/index.html">Copywriting di IT: bagaimana memulai menulis tentang teknologi</a></li>
<li><a href="../id483568/index.html">Membuat komputer primitif dari awal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>