<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚒 👨🏾‍⚖️ 👩🏻‍🎓 Überraschen Sie fsync () PostgreSQL 🔍 📧 🕵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="DBMS-Entwickler befürchten zwangsläufig, dass die Daten sicher dauerhaft gespeichert werden. Als die PostgreSQL-Community feststellte, dass die Art un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Überraschen Sie fsync () PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472684/"><img width="50%" align="left" src="https://habrastorage.org/webt/oz/ps/ut/ozpsutp44sz5dvmpfteszdiba5o.png">  DBMS-Entwickler befürchten zwangsläufig, dass die Daten sicher dauerhaft gespeichert werden.  Als die PostgreSQL-Community feststellte, dass die Art und Weise, wie der Kernel mit E / A-Fehlern umgeht, zu Datenverlust führen kann, ohne dass Fehler an den Benutzerbereich gemeldet werden, kam es zu großer Unzufriedenheit.  Das Problem, das durch die Tatsache verschlimmert wird, dass PostgreSQL gepufferte E / A ausführt, ist nicht nur unter Linux zu finden und wird auch dort nicht einfach zu lösen sein. <br><br>  Craig Ringer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meldete das Problem erstmals</a> Ende März an die Mailingliste von pgsql-hackers.  Kurz gesagt, PostgreSQL geht davon aus, dass ein erfolgreicher Aufruf von <code>fsync()</code> anzeigt, dass alle seit dem letzten erfolgreichen Aufruf aufgezeichneten Daten sicher in einen dauerhaften Speicher übertragen wurden.  Wenn gepufferte E / A-Schreibvorgänge aufgrund eines Hardwarefehlers fehlschlagen, reagieren Dateisysteme unterschiedlich. Bei diesem Verhalten werden jedoch normalerweise Daten auf den entsprechenden Seiten gelöscht und als sauber markiert.  Daher werden Leseblöcke, die gerade geschrieben wurden, höchstwahrscheinlich etwas anderes zurückgeben, jedoch keine aufgezeichneten Daten. <br><a name="habracut"></a><br>  Was ist mit der Fehlerberichterstattung?  Vor einem Jahr umfasste der Gipfel zum Linux-Dateisystem-, Speicher- und Speicherverwaltungsgipfel (LSFMM) eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sitzung zur</a> Fehlerberichterstattung, in der alles als „Chaos“ bezeichnet wurde.  Fehler können leicht verloren gehen, sodass sie von keiner Anwendung jemals gesehen werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einige</a> in 4.13 enthaltene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patches haben</a> die Situation während des Entwicklungszyklus etwas verbessert (und in 4.16 wurden einige Änderungen vorgenommen, um sie weiter zu verbessern). Es gibt jedoch Möglichkeiten, Fehlerbenachrichtigungen zu verlieren, wie unten beschrieben.  Wenn dies auf einem PostgreSQL-Server geschieht, kann dies zu einer automatischen Beschädigung der Datenbank führen. <br><br>  PostgreSQL-Entwickler waren unglücklich.  Tom Lane <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieb</a> dies als " <b>Hirnschädigung des Kerns</b> ", während Robert Haas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es</a> " <b>100% dumm</b> " nannte.  Zu Beginn der Diskussion haben die PostgreSQL-Entwickler ganz klar verstanden, wie der Kernel ihrer Meinung nach funktionieren sollte: Seiten, die nicht geschrieben werden konnten, sollten in einem "schmutzigen" Zustand gespeichert werden (für nachfolgende Versuche) und der entsprechende Dateideskriptor sollte übersetzt werden Permanenter Fehlerstatus, damit der PostgreSQL-Server das Problem nicht überspringen kann. <br><br><h4>  Wo ist etwas schief gelaufen? </h4><br>  Doch noch bevor die Kernel-Community in die Diskussion eintrat, wurde klar, dass die Situation nicht so einfach war, wie es scheinen mag.  Thomas Munro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte,</a> dass Linux in diesem Verhalten nicht einzigartig ist;  OpenBSD und NetBSD melden möglicherweise auch keine Schreibfehler im Benutzerbereich.  Und wie sich herausstellte, erschwert die Art und Weise, wie PostgreSQL mit gepufferten E / A-Operationen umgeht, das Bild erheblich. <br><br>  Dieser Mechanismus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>wurde von</u></a> Haas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>ausführlich beschrieben</u></a> .  Ein PostgreSQL-Server arbeitet als eine Reihe von Prozessen, von denen viele E / A für Datenbankdateien ausführen können.  Der <code>fsync()</code> wird jedoch in einem einzigen Checkpointer-Prozess ("Checkpointer" -Prozess) ausgeführt, bei dem der Festplattenspeicher in einem konsistenten Zustand gehalten wird, um Fehler zu beheben.  Checkpointer hält normalerweise nicht alle relevanten Dateien offen, daher muss die Datei häufig geöffnet werden, bevor <code>fsync()</code> .  Hier tritt das Problem auf: Selbst in Kernel 4.13 und späteren Versionen werden beim Checkpointer keine Fehler angezeigt, die vor dem Öffnen der Datei aufgetreten sind.  Wenn vor dem Aufruf von <code>open()</code> checkpointer-a etwas Schlimmes passiert, gibt der nächste Aufruf von <code>fsync()</code> Erfolg zurück.  Es gibt verschiedene Möglichkeiten, einen E / A-Fehler außerhalb von <code>fsync()</code> .  Beispielsweise kann der Kernel beim Zurückschreiben im Hintergrund auf einen von ihnen stoßen.  Jemand, der <code>sync()</code> aufruft, kann auch auf einen E / A-Fehler stoßen und den resultierenden Fehlerzustand „absorbieren“. <br><br>  Haas beschrieb dieses Verhalten als nicht in der Lage, die Erwartungen von PostgreSQL zu erfüllen: <br><blockquote>  Alles, was Sie (oder jemand) haben, ist im Grunde eine unbewiesene Annahme, dass <br>  Welche Dateideskriptoren für einen bestimmten Fehler relevant sein können, aber es kam vor, dass PostgreSQL nie mit ihm übereinstimmte.  Sie können weiterhin sagen, dass das Problem in unseren Vermutungen liegt, aber es scheint mir falsch anzunehmen, dass wir das einzige Programm sind, das sie jemals durchgeführt hat. </blockquote><br>  Infolgedessen hat Joshua Drake <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Konversation</a> in die Entwicklungsliste für ext4 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschoben</a> , einschließlich eines Teils der Kernel-Entwicklergemeinschaft.  Dave Chinner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieb</a> dieses Verhalten schnell als "ein <b>Rezept für eine Katastrophe, insbesondere bei plattformübergreifendem Code, bei dem sich jede Betriebssystemplattform anders verhält und fast nie den Erwartungen entspricht</b> ".  Stattdessen erklärte Ted Tso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> warum die betroffenen Seiten nach einem E / A-Fehler als sauber markiert werden.  Kurz gesagt, die häufigste Ursache für E / A-Fehler ist, dass der Benutzer das USB-Laufwerk zum falschen Zeitpunkt auswirft.  Wenn ein Prozess viele Daten auf diese Festplatte kopiert, führt dies dazu, dass sich schmutzige Seiten im Speicher ansammeln, möglicherweise bis zu dem Punkt, dass das System nicht über genügend Speicher für andere Aufgaben verfügt.  Daher können diese Seiten nicht gespeichert werden und werden gelöscht, wenn der Benutzer möchte, dass das System nach einem solchen Ereignis weiterhin verwendet werden kann. <br><br>  Sowohl Chinner als auch Tso und andere sagten, PostgreSQL habe die richtige Lösung - wechseln Sie zu Direct I / O (DIO).  Die Verwendung von DIO bietet eine bessere Kontrolle über das Zurückschreiben und die E / A im Allgemeinen.  Dies umfasst den Zugriff auf Informationen darüber, welche E / A-Vorgänge möglicherweise fehlgeschlagen sind.  Andres Freund hat wie eine Reihe anderer PostgreSQL-Entwickler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anerkannt,</a> dass DIO die beste langfristige Lösung ist.  Er merkte aber auch an, dass man nicht erwarten sollte, dass Entwickler tief in die Umsetzung dieser Aufgabe eintauchen.  In der Zwischenzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> dass es andere Programme gibt (er erwähnte dpkg), die ebenfalls für dieses Verhalten anfällig sind. <br><br><h4>  Auf dem Weg zu einer kurzfristigen Lösung </h4><br>  Während der Diskussion wurde der Idee große <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufmerksamkeit</a> geschenkt, dass ein Schreibfehler dazu führen sollte, dass die betroffenen Seiten in ihrem schmutzigen Zustand im Speicher gespeichert werden.  PostgreSQL-Entwickler haben sich jedoch schnell von dieser Idee entfernt und sie nicht gefordert.  Was sie wirklich brauchen, ist letztendlich ein zuverlässiger Weg, um herauszufinden, ob etwas schief gelaufen ist.  In diesem Sinne können die üblichen PostgreSQL-Fehlerbehandlungsmechanismen dies handhaben.  In seiner Abwesenheit kann jedoch wenig getan werden. <br><br>  Irgendwann in der Diskussion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwähnte</a> Tso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> dass Google über einen eigenen Mechanismus zur Behandlung von E / A-Fehlern verfügt.  Der Kernel wurde angewiesen, E / A-Fehler über den Netlink-Socket zu melden.  Der dedizierte Prozess erhält diese Benachrichtigungen und reagiert entsprechend.  Dieser Mechanismus hat dies jedoch nie am Eingang getan.  Freind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wies darauf hin,</a> dass dieser Mechanismus für PostgreSQL "ideal" wäre, so dass er in naher Zukunft gemeinfrei erscheinen könnte. <br><br>  In der Zwischenzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dachte</a> Jeff Leighton über eine andere Idee nach: ein Flag im Superblock des Dateisystems zu setzen, wenn ein E / A-Fehler auftritt.  Ein Aufruf von <code>syncfs()</code> dann dieses Flag und gibt einen Fehler zurück, wenn es gesetzt wurde.  Der PostgreSQL-Checkpointer kann regelmäßig <code>syncfs()</code> aufrufen, um nach Fehlern im Dateisystem zu <code>syncfs()</code> , das die Datenbank enthält.  Freund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stimmte zu,</a> dass dies eine praktikable Lösung für das Problem sein könnte. <br><br>  Natürlich wird ein solcher Mechanismus nur in neuen Kerneln auftreten.  In der Zwischenzeit werden PostgreSQL-Installationen normalerweise auf älteren Kerneln ausgeführt, die von Unternehmensdistributionen unterstützt werden.  In diesen Kerneln scheint es nicht einmal die Verbesserungen zu geben, die in 4.13 enthalten waren.  Für diese Systeme kann wenig getan werden, um PostgreSQL bei der Erkennung von E / A-Fehlern zu unterstützen.  Es kann ausreichen, einen Daemon zu starten, der das Systemprotokoll durchsucht und dort nach E / A-Fehlermeldungen sucht.  Nicht die eleganteste Lösung, und es wird durch die Tatsache erschwert, dass verschiedene Blocktreiber und Dateisysteme Fehler in der Regel auf unterschiedliche Weise melden. Dies ist jedoch möglicherweise die beste verfügbare Option. <br><br>  Der nächste Schritt dürfte eine Diskussion auf der LSFMM 2018 am 23. April sein.  Wenn Sie Glück haben, gibt es eine Lösung, die für Interessenten funktioniert.  Eine Sache, die sich jedoch nicht ändern wird, ist die einfache Tatsache, dass es schwierig ist, Fehler richtig zu behandeln. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472684/">https://habr.com/ru/post/de472684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472670/index.html">Limely Herbst, Limely Winter ...</a></li>
<li><a href="../de472672/index.html">Die Überschrift "Artikel für Sie lesen." Juli - September 2019</a></li>
<li><a href="../de472674/index.html">Umgebungsvariablen für Python-Projekte</a></li>
<li><a href="../de472676/index.html">Wir erstellen die Abteilung für Jones, um den Hauptteams zu helfen, indem wir nur Slack, Jira und das blaue Isolierband verwenden</a></li>
<li><a href="../de472682/index.html">Verlangsamung des Alterns mit Arzneimittelsynergien bei C. elegans</a></li>
<li><a href="../de472686/index.html">Videostudio basierend auf i486</a></li>
<li><a href="../de472688/index.html">So funktioniert das Rendern von 3D-Spielen: Vertex-Verarbeitung</a></li>
<li><a href="../de472690/index.html">Was ist neu in Zabbix 4.4?</a></li>
<li><a href="../de472694/index.html">Mehr als Ceph: MCS Block Cloud Storage</a></li>
<li><a href="../de472702/index.html">JH Regenwasser „Wie man Katzen weidet“: Rassen von Programmierern und Merkmale ihrer Zucht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>