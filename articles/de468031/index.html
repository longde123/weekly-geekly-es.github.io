<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêÔ∏è üë©üèª‚Äçü§ù‚Äçüë®üèæ ‚úçüèø Wir portieren ein Multiplayer-Spiel von C ++ mit Cheerp, WebRTC und Firebase ins Web üöõ üì¶ üßìüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Unser Unternehmen Leaning Technologies bietet L√∂sungen f√ºr die Portierung traditioneller Desktop-Anwendungen ins Web. Unser C ++ Cheerp-C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir portieren ein Multiplayer-Spiel von C ++ mit Cheerp, WebRTC und Firebase ins Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468031/"><h2>  Einf√ºhrung </h2><br>  Unser Unternehmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Leaning Technologies</a> bietet L√∂sungen f√ºr die Portierung traditioneller Desktop-Anwendungen ins Web.  Unser C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Cheerp-Compiler</a> generiert eine Kombination aus WebAssembly und JavaScript, die sowohl eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">einfache Browserinteraktion</a> als auch eine hohe Leistung bietet. <br><br>  Als Beispiel f√ºr seine Anwendung haben wir beschlossen, ein Multiplayer-Spiel f√ºr das Web zu portieren, und daf√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Teeworlds ausgew√§hlt</strong></a> .  Teeworlds ist ein zweidimensionales Retro-Spiel f√ºr mehrere Spieler mit einer kleinen, aber aktiven Community von Spielern (einschlie√ülich mir!).  Es ist klein in Bezug auf herunterladbare Ressourcen sowie CPU- und GPU-Anforderungen - ein idealer Kandidat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/70c/bb8/8bb70cbb863efd3e58cec7da962558a7.png" width="956" height="892"></div><br>  <i>Funktioniert im Teeworlds-Browser</i> <br><a name="habracut"></a><br>  Wir haben uns entschlossen, dieses Projekt zu verwenden, um mit <strong>allgemeinen L√∂sungen f√ºr die Portierung von Netzwerkcode ins Web</strong> zu experimentieren.  Dies geschieht normalerweise auf folgende Weise: <br><br><ul><li>  <strong>XMLHttpRequest / fetch,</strong> wenn der Netzwerkteil nur aus HTTP-Anforderungen besteht, oder </li><li>  <strong>WebSockets</strong> </li></ul><br>  Bei beiden L√∂sungen muss die Serverkomponente auf der Serverseite gehostet werden, und bei keiner von ihnen k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP</a> als Transportprotokoll verwenden.  Dies ist wichtig f√ºr Echtzeitanwendungen wie Videokonferenzen und Spielesoftware, da Zustellgarantien und die Bestellung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TCP-</a> Paketen die geringe Latenz beeintr√§chtigen k√∂nnen. <br><br>  Es gibt einen dritten Weg: Verwenden Sie das Netzwerk √ºber einen Browser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>WebRTC</strong></a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>RTCDataChannel</strong></a> unterst√ºtzt sowohl eine zuverl√§ssige als auch eine unzuverl√§ssige √úbertragung (im letzteren Fall wird nach M√∂glichkeit versucht, UDP als Transportprotokoll zu verwenden) und kann mit einem Remote-Server und zwischen Browsern verwendet werden.  <strong>Dies bedeutet, dass wir die gesamte Anwendung einschlie√ülich der Serverkomponente auf den Browser portieren k√∂nnen!</strong> <br><br>  Dies ist jedoch eine zus√§tzliche Schwierigkeit: Bevor zwei WebRTC-Peers Daten austauschen k√∂nnen, m√ºssen sie ein relativ kompliziertes Handshake-Verfahren f√ºr die Verbindung ausf√ºhren, f√ºr das mehrere Entit√§ten von Drittanbietern (ein Signalserver und ein oder mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">STUN</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">TURN-</a> Server) erforderlich sind. <br><br>  Im Idealfall m√∂chten wir eine Netzwerk-API intern mit WebRTC erstellen, jedoch so nah wie m√∂glich an der UDP Sockets-Schnittstelle, f√ºr die keine Verbindung hergestellt werden muss. <br><br>  Auf diese Weise k√∂nnen wir WebRTC nutzen, ohne komplexe Details im Anwendungscode offenlegen zu m√ºssen (den wir in unserem Projekt so wenig wie m√∂glich √§ndern wollten). <br><br><h1>  Minimum WebRTC </h1><br>  WebRTC ist eine in Browsern verf√ºgbare API-Suite, die Peer-to-Peer-Audio-, Video- und willk√ºrliche Daten√ºbertragung bietet. <br><br>  Die Verbindung zwischen den Peers wird √ºber die STUN- und / oder TURN-Server √ºber einen Mechanismus namens ICE hergestellt (auch wenn auf einer oder beiden Seiten NAT vorhanden ist).  Peers tauschen ICE-Informationen und Kanalparameter √ºber das SDP-Angebots- und Antwortprotokoll aus. <br><br>  Wow!  Wie viele Abk√ºrzungen gleichzeitig.  Lassen Sie uns kurz erkl√§ren, was diese Konzepte bedeuten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Session Traversal Utilities f√ºr NAT</strong> ( <strong>STUN</strong> )</a> - ein Protokoll zum Umgehen von NAT und zum Empfangen eines Paares (IP, Port) zum direkten Datenaustausch mit dem Host.  Wenn es ihm gelingt, seine Aufgabe zu erf√ºllen, k√∂nnen Peers unabh√§ngig voneinander Daten miteinander austauschen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Das Durchlaufen von Relays um NAT</strong> ( <strong>TURN</strong> ) wird</a> auch zum Umgehen von NAT verwendet. Dies erfolgt jedoch durch Umleiten von Daten √ºber einen Proxy, der f√ºr beide Peers sichtbar ist.  Es f√ºhrt zu Verz√∂gerungen und ist teurer in der Ausf√ºhrung als STUN (da es w√§hrend der gesamten Kommunikationssitzung verwendet wird), aber manchmal ist dies die einzig m√∂gliche Option. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Interactive Connectivity Establishment</strong> ( <strong>ICE</strong> ) wird</a> verwendet, um den bestm√∂glichen Weg zum Verbinden von zwei Peers auszuw√§hlen, basierend auf Informationen, die durch direkte Verbindung von Peers erhalten wurden, sowie Informationen, die von einer beliebigen Anzahl von STUN- und TURN-Servern empfangen wurden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Das Session Description Protocol</strong> ( <strong>SDP</strong> )</a> ist ein Format zur Beschreibung der Parameter des Verbindungskanals, z. B. ICE-Kandidaten, Multimedia-Codecs (im Fall eines Audio- / Videokanals) usw. Einer der Peers sendet ein SDP-Angebot ("Angebot") und der zweite antwortet mit SDP Antwort ("Antwort").  Danach wird ein Kanal erstellt. </li></ul><br>  Um eine solche Verbindung herzustellen, m√ºssen Peers die Informationen, die sie von den Servern STUN und TURN erhalten haben, sammeln und untereinander austauschen. <br><br>  Das Problem ist, dass sie noch nicht in der Lage sind, Daten direkt auszutauschen. Daher muss es einen Out-of-Band-Mechanismus f√ºr den Austausch dieser Daten geben: einen Signalserver. <br><br>  Ein Signalserver kann sehr einfach sein, da seine einzige Aufgabe darin besteht, Daten zwischen Peers in der Phase ‚ÄûHandshake‚Äú umzuleiten (wie in der folgenden Abbildung dargestellt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/972/ba0/5ac972ba057357540ffd749081dbdd3b.png" width="783" height="710"></div><br>  <i>Vereinfachte WebRTC-Handshake-Sequenz</i> <br><br><h1>  Teeworlds Netzwerkmodell√ºbersicht </h1><br>  Die Netzwerkarchitektur von Teeworlds ist sehr einfach: <br><br><ul><li>  Die Client- und Serverkomponenten sind zwei verschiedene Programme. </li><li>  Clients betreten das Spiel, indem sie eine Verbindung zu einem von mehreren Servern herstellen, auf denen jeweils nur ein Spiel gehostet wird. </li><li>  Die gesamte Daten√ºbertragung im Spiel erfolgt √ºber den Server. </li><li>  Ein spezieller Master-Server wird verwendet, um eine Liste aller √∂ffentlichen Server zu erfassen, die im Spielclient angezeigt werden. </li></ul><br>  Aufgrund der Verwendung von WebRTC f√ºr den Datenaustausch k√∂nnen wir die Serverkomponente des Spiels an den Browser √ºbertragen, in dem sich der Client befindet.  Es gibt uns eine gro√üartige Gelegenheit ... <br><br><h1>  Server loswerden </h1><br>  Das Fehlen der Serverlogik hat einen sch√∂nen Vorteil: Wir k√∂nnen die gesamte Anwendung als statischen Inhalt auf Github Pages oder auf unseren eigenen Ger√§ten hinter Cloudflare bereitstellen und so schnelle Downloads und hohe Verf√ºgbarkeit kostenlos sicherstellen.  Tats√§chlich k√∂nnen wir sie vergessen, und wenn wir Gl√ºck haben und das Spiel popul√§r wird, muss die Infrastruktur nicht modernisiert werden. <br><br>  Damit das System funktioniert, m√ºssen wir jedoch noch eine externe Architektur verwenden: <br><br><ul><li>  Ein oder mehrere STUN-Server: Wir haben die Wahl zwischen mehreren kostenlosen Optionen. </li><li>  Mindestens ein TURN-Server: Hier gibt es keine kostenlosen Optionen, sodass wir entweder unsere eigenen einrichten oder f√ºr den Service bezahlen k√∂nnen.  Gl√ºcklicherweise k√∂nnen Sie die meiste Zeit eine Verbindung √ºber die STUN-Server herstellen (und echtes p2p bereitstellen), aber TURN wird als Fallback ben√∂tigt. </li><li>  Signalserver: Im Gegensatz zu den beiden anderen Aspekten ist die Signalisierung nicht standardisiert.  Wof√ºr der Signalserver tats√§chlich verantwortlich ist, h√§ngt in gewisser Weise von der Anwendung ab.  In unserem Fall ist es vor dem Herstellen einer Verbindung erforderlich, eine kleine Datenmenge auszutauschen. </li><li>  Teeworlds Master-Server: Er wird von anderen Servern verwendet, um √ºber seine Existenz zu informieren, und von Clients, um nach √∂ffentlichen Servern zu suchen.  Obwohl dies nicht erforderlich ist (Clients k√∂nnen jederzeit eine Verbindung zu einem Server herstellen, den sie manuell kennen), w√§re es sch√∂n, ihn zu haben, damit Spieler an Spielen mit zuf√§lligen Personen teilnehmen k√∂nnen. </li></ul><br>  Wir haben uns f√ºr die Verwendung der kostenlosen STUN-Server von Google entschieden und einen TURN-Server selbst bereitgestellt. <br><br>  F√ºr die letzten beiden Punkte haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Firebase verwendet</a> : <br><br><ul><li>  Der Teeworlds-Masterserver ist sehr einfach zu implementieren: als Liste von Objekten, die Informationen (Name, IP, Karte, Modus, ...) jedes aktiven Servers enthalten.  Die Server ver√∂ffentlichen und aktualisieren ihr eigenes Objekt, und die Clients nehmen die gesamte Liste und zeigen sie dem Player an.  Wir zeigen die Liste auf der Homepage auch als HTML an, sodass die Spieler einfach auf den Server klicken und direkt zum Spiel gehen k√∂nnen. </li><li>  Die Signalisierung h√§ngt eng mit unserer Socket-Implementierung zusammen, die im n√§chsten Abschnitt beschrieben wird. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d6/ae6/72d/3d6ae672db99216dabcf0a792d008f5e.png" width="1697" height="513"></div><br>  <i>Liste der Server im Spiel und auf der Homepage</i> <br><br><h1>  Socket-Implementierung </h1><br>  Wir m√∂chten eine API erstellen, die so nah wie m√∂glich an Posix UDP Sockets liegt, um die Anzahl der erforderlichen √Ñnderungen zu minimieren. <br><br>  Wir wollen auch das notwendige Minimum realisieren, das f√ºr den einfachsten Datenaustausch √ºber das Netzwerk erforderlich ist. <br><br>  Zum Beispiel ben√∂tigen wir kein echtes Routing: Alle Peers befinden sich im selben ‚Äûvirtuellen LAN‚Äú, das einer bestimmten Instanz der Firebase-Datenbank zugeordnet ist. <br><br>  Daher ben√∂tigen wir keine eindeutigen IP-Adressen: F√ºr die eindeutige Identifizierung von Peers ist es ausreichend, eindeutige Werte von Firebase-Schl√ºsseln (√§hnlich wie Dom√§nennamen) zu verwenden, und jeder Peer weist jedem Schl√ºssel, der konvertiert werden muss, lokal ‚Äûgef√§lschte‚Äú IP-Adressen zu.  Dadurch entf√§llt die Notwendigkeit einer globalen IP-Adresszuweisung vollst√§ndig, was keine triviale Aufgabe ist. <br><br>  Hier ist die Mindest-API, die wir implementieren m√ºssen: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create and destroy a socket int socket(); int close(int fd); // Bind a socket to a port, and publish it on Firebase int bind(int fd, AddrInfo* addr); // Send a packet. This lazily create a WebRTC connection to the // peer when necessary int sendto(int fd, uint8_t* buf, int len, const AddrInfo* addr); // Receive the packets destined to this socket int recvfrom(int fd, uint8_t* buf, int len, AddrInfo* addr); // Be notified when new packets arrived int recvCallback(Callback cb); // Obtain a local ip address for this peer key uint32_t resolve(client::String* key); // Get the peer key for this ip String* reverseResolve(uint32_t addr); // Get the local peer key String* local_key(); // Initialize the library with the given Firebase database and // WebRTc connection options void init(client::FirebaseConfig* fb, client::RTCConfiguration* ice);</span></span></code> </pre> <br>  Die API ist einfach und √§hnelt der Posix Sockets-API, weist jedoch einige wichtige Unterschiede auf: <strong>Registrieren von R√ºckrufen, Zuweisen lokaler IPs und eine verz√∂gerte Verbindung</strong> . <br><br><h2>  R√ºckrufregistrierung </h2><br>  Selbst wenn das Quellprogramm nicht blockierende E / A verwendet, muss der Code √ºberarbeitet werden, damit er in einem Webbrowser ausgef√ºhrt werden kann. <br><br>  Der Grund daf√ºr ist, dass die Ereignisschleife im Browser vor dem Programm verborgen ist (sei es JavaScript oder WebAssembly). <br><br>  In einer nativen Umgebung k√∂nnen wir auf diese Weise Code schreiben <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { select(...); <span class="hljs-comment"><span class="hljs-comment">// wait for I/O events while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }</span></span></code> </pre> <br>  Wenn die Ereignisschleife f√ºr uns verborgen ist, m√ºssen wir daraus etwas machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cb = []() { <span class="hljs-comment"><span class="hljs-comment">// this will be called when new data is available while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }; recvCallback(cb); // register the callback</span></span></code> </pre> <br><h2>  Lokale IP-Zuweisung </h2><br>  Die Kennungen der Knoten in unserem ‚ÄûNetzwerk‚Äú sind keine IP-Adressen, sondern Firebase-Schl√ºssel (dies sind Zeilen, die folgenderma√üen aussehen: <code>-LmEC50PYZLCiCP-vqde</code> ). <br><br>  Dies ist praktisch, da wir keinen Mechanismus zum Zuweisen von IP und zum √úberpr√ºfen ihrer Eindeutigkeit (sowie ihrer Entsorgung nach dem Trennen des Clients) ben√∂tigen. Es ist jedoch h√§ufig erforderlich, Peers anhand eines numerischen Werts zu identifizieren. <br><br>  Hierzu werden die Funktionen <code>resolve</code> und <code>reverseResolve</code> verwendet: Die Anwendung erh√§lt irgendwie den Zeichenfolgenwert des Schl√ºssels (durch Benutzereingabe oder √ºber den Master-Server) und kann ihn f√ºr den internen Gebrauch in eine IP-Adresse konvertieren.  Der Rest der API erh√§lt der Einfachheit halber auch diesen Wert anstelle einer Zeichenfolge. <br><br>  Dies √§hnelt einer DNS-Suche, die nur lokal auf dem Client durchgef√ºhrt wird. <br><br>  Das hei√üt, IP-Adressen k√∂nnen nicht von verschiedenen Clients gemeinsam genutzt werden. Wenn Sie eine globale Kennung ben√∂tigen, m√ºssen Sie diese auf andere Weise generieren. <br><br><h2>  Faule Mischung </h2><br>  UDP ben√∂tigt keine Verbindung, aber wie wir gesehen haben, erfordert WebRTC vor dem Starten der Daten√ºbertragung zwischen zwei Peers einen langen Verbindungsprozess. <br><br>  Wenn wir dieselbe Abstraktionsebene <code>sendto</code> <code>recvfrom</code> ( <code>sendto</code> / <code>recvfrom</code> mit beliebigen Peers, ohne zuvor eine Verbindung herzustellen), m√ºssen wir innerhalb der API eine "faule" (verz√∂gerte) Verbindung herstellen. <br><br>  Folgendes passiert w√§hrend des normalen Datenaustauschs zwischen dem ‚ÄûServer‚Äú und dem ‚ÄûClient‚Äú bei Verwendung von UDP und was unsere Bibliothek tun sollte: <br><br><ul><li>  Der Server ruft <code>bind()</code> auf, um dem Betriebssystem mitzuteilen, dass es Pakete an den angegebenen Port empfangen m√∂chte. </li></ul><br>  Stattdessen ver√∂ffentlichen wir den offenen Port in Firebase unter dem Serverschl√ºssel und h√∂ren Ereignisse in seinem Teilbaum ab. <br><br><ul><li>  Der Server ruft <code>recvfrom()</code> und akzeptiert Pakete von einem beliebigen Host an diesen Port. </li></ul><br>  In unserem Fall m√ºssen wir die eingehende Warteschlange der an diesen Port gesendeten Pakete √ºberpr√ºfen. <br><br>  Jeder Port hat eine eigene Warteschlange, und wir f√ºgen die Quell- und Zielports am Anfang der WebRTC-Datagramme hinzu, um zu wissen, welche Warteschlange umgeleitet werden soll, wenn ein neues Paket eintrifft. <br><br>  Der Aufruf ist nicht blockierend. Wenn also keine Pakete vorhanden sind, geben wir einfach -1 zur√ºck und setzen <code>errno=EWOULDBLOCK</code> . <br><br><ul><li>  Der Client empf√§ngt die IP und den Port des Servers auf externe Weise und ruft <code>sendto()</code> .  Au√üerdem wird ein interner Aufruf von <code>bind()</code> ausgef√ºhrt, sodass nachfolgendes <code>recvfrom()</code> eine Antwort erh√§lt, ohne bind explizit auszuf√ºhren. </li></ul><br>  In unserem Fall empf√§ngt der Client den Zeichenfolgenschl√ºssel extern und verwendet die Funktion <code>resolve()</code> , um die IP-Adresse abzurufen. <br><br>  An diesem Punkt beginnen wir mit dem ‚ÄûHandshake‚Äú von WebRTC, wenn die beiden Peers noch nicht miteinander verbunden sind.  Verbindungen zu verschiedenen Ports desselben Peers verwenden denselben DataRannel-WebRTC. <br><br>  Wir f√ºhren auch indirekt <code>bind()</code> damit der Server beim n√§chsten <code>sendto()</code> falls er aus irgendeinem Grund geschlossen wird. <br><br>  Der Server wird √ºber die Verbindung des Clients benachrichtigt, wenn der Client sein SDP-Angebot unter den Serverportinformationen in Firebase schreibt, und der Server antwortet mit seiner eigenen Antwort. <br><br><hr><br>  Das folgende Diagramm zeigt ein Beispiel f√ºr die Verschiebung von Nachrichten f√ºr ein Socket-Schema und die √úbertragung der ersten Nachricht vom Client zum Server: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/03a/024/b4e03a0246a77f74034c3b823bc7a1a6.png" width="787" height="1656"></div><br>  <i>Vollst√§ndiges Verbindungsschrittdiagramm zwischen Client und Server</i> <br><br><h1>  Fazit </h1><br>  Wenn Sie bis zum Ende gelesen haben, sind Sie wahrscheinlich daran interessiert, die Theorie in Aktion zu betrachten.  Das Spiel kann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">teeworlds.leaningtech.com gespielt werden</a> , probieren Sie es aus! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Freundschaftsspiel zwischen Kollegen</i> <br><br>  Der Netzwerkbibliothekscode ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Github</a> frei verf√ºgbar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Chatten Sie</a> auf unserem Kanal in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Gitter</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468031/">https://habr.com/ru/post/de468031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468019/index.html">Website-Entwicklung in WebAssembly mit NetCore 3 und Blazor</a></li>
<li><a href="../de468021/index.html">PHP, wie viel Abstraktion f√ºr die Menschen?</a></li>
<li><a href="../de468023/index.html">K√ºnstliche Intelligenz im Kampfspiel Shadow Fight 3</a></li>
<li><a href="../de468025/index.html">Wie konfiguriere ich SNI in Zimbra OSE?</a></li>
<li><a href="../de468027/index.html">Codeoptimierungsmethoden f√ºr Redd. Teil 2: Nicht zwischenspeicherbarer Speicher und paralleler Busbetrieb</a></li>
<li><a href="../de468035/index.html">Laden Sie die Presse mit einem Gamecontroller oder 8 ungew√∂hnlichen Patenten f√ºr Eingabeger√§te herunter</a></li>
<li><a href="../de468039/index.html">Moskau Kubernetes Meetup # 6 bei Acronis (Fiztehpark) 10/03/2019</a></li>
<li><a href="../de468041/index.html">Ank√ºndigung der Kubernetes Web View-Weboberfl√§che (und eine kurze √úbersicht √ºber andere Web-Benutzeroberfl√§chen f√ºr Kubernetes)</a></li>
<li><a href="../de468043/index.html">So erstellen Sie ein UI-Kit, das zum Verkauf steht. Entwicklungsstadien eines kommerziellen Designsystems</a></li>
<li><a href="../de468047/index.html">Arbeiten mit Hierarchien in lsFusion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>