<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐️ 👩🏻‍🤝‍👨🏾 ✍🏿 Wir portieren ein Multiplayer-Spiel von C ++ mit Cheerp, WebRTC und Firebase ins Web 🚛 📦 🧓🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Unser Unternehmen Leaning Technologies bietet Lösungen für die Portierung traditioneller Desktop-Anwendungen ins Web. Unser C ++ Cheerp-C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir portieren ein Multiplayer-Spiel von C ++ mit Cheerp, WebRTC und Firebase ins Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468031/"><h2>  Einführung </h2><br>  Unser Unternehmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Leaning Technologies</a> bietet Lösungen für die Portierung traditioneller Desktop-Anwendungen ins Web.  Unser C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Cheerp-Compiler</a> generiert eine Kombination aus WebAssembly und JavaScript, die sowohl eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">einfache Browserinteraktion</a> als auch eine hohe Leistung bietet. <br><br>  Als Beispiel für seine Anwendung haben wir beschlossen, ein Multiplayer-Spiel für das Web zu portieren, und dafür <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Teeworlds ausgewählt</strong></a> .  Teeworlds ist ein zweidimensionales Retro-Spiel für mehrere Spieler mit einer kleinen, aber aktiven Community von Spielern (einschließlich mir!).  Es ist klein in Bezug auf herunterladbare Ressourcen sowie CPU- und GPU-Anforderungen - ein idealer Kandidat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/70c/bb8/8bb70cbb863efd3e58cec7da962558a7.png" width="956" height="892"></div><br>  <i>Funktioniert im Teeworlds-Browser</i> <br><a name="habracut"></a><br>  Wir haben uns entschlossen, dieses Projekt zu verwenden, um mit <strong>allgemeinen Lösungen für die Portierung von Netzwerkcode ins Web</strong> zu experimentieren.  Dies geschieht normalerweise auf folgende Weise: <br><br><ul><li>  <strong>XMLHttpRequest / fetch,</strong> wenn der Netzwerkteil nur aus HTTP-Anforderungen besteht, oder </li><li>  <strong>WebSockets</strong> </li></ul><br>  Bei beiden Lösungen muss die Serverkomponente auf der Serverseite gehostet werden, und bei keiner von ihnen können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP</a> als Transportprotokoll verwenden.  Dies ist wichtig für Echtzeitanwendungen wie Videokonferenzen und Spielesoftware, da Zustellgarantien und die Bestellung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TCP-</a> Paketen die geringe Latenz beeinträchtigen können. <br><br>  Es gibt einen dritten Weg: Verwenden Sie das Netzwerk über einen Browser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>WebRTC</strong></a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>RTCDataChannel</strong></a> unterstützt sowohl eine zuverlässige als auch eine unzuverlässige Übertragung (im letzteren Fall wird nach Möglichkeit versucht, UDP als Transportprotokoll zu verwenden) und kann mit einem Remote-Server und zwischen Browsern verwendet werden.  <strong>Dies bedeutet, dass wir die gesamte Anwendung einschließlich der Serverkomponente auf den Browser portieren können!</strong> <br><br>  Dies ist jedoch eine zusätzliche Schwierigkeit: Bevor zwei WebRTC-Peers Daten austauschen können, müssen sie ein relativ kompliziertes Handshake-Verfahren für die Verbindung ausführen, für das mehrere Entitäten von Drittanbietern (ein Signalserver und ein oder mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">STUN</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">TURN-</a> Server) erforderlich sind. <br><br>  Im Idealfall möchten wir eine Netzwerk-API intern mit WebRTC erstellen, jedoch so nah wie möglich an der UDP Sockets-Schnittstelle, für die keine Verbindung hergestellt werden muss. <br><br>  Auf diese Weise können wir WebRTC nutzen, ohne komplexe Details im Anwendungscode offenlegen zu müssen (den wir in unserem Projekt so wenig wie möglich ändern wollten). <br><br><h1>  Minimum WebRTC </h1><br>  WebRTC ist eine in Browsern verfügbare API-Suite, die Peer-to-Peer-Audio-, Video- und willkürliche Datenübertragung bietet. <br><br>  Die Verbindung zwischen den Peers wird über die STUN- und / oder TURN-Server über einen Mechanismus namens ICE hergestellt (auch wenn auf einer oder beiden Seiten NAT vorhanden ist).  Peers tauschen ICE-Informationen und Kanalparameter über das SDP-Angebots- und Antwortprotokoll aus. <br><br>  Wow!  Wie viele Abkürzungen gleichzeitig.  Lassen Sie uns kurz erklären, was diese Konzepte bedeuten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Session Traversal Utilities für NAT</strong> ( <strong>STUN</strong> )</a> - ein Protokoll zum Umgehen von NAT und zum Empfangen eines Paares (IP, Port) zum direkten Datenaustausch mit dem Host.  Wenn es ihm gelingt, seine Aufgabe zu erfüllen, können Peers unabhängig voneinander Daten miteinander austauschen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Das Durchlaufen von Relays um NAT</strong> ( <strong>TURN</strong> ) wird</a> auch zum Umgehen von NAT verwendet. Dies erfolgt jedoch durch Umleiten von Daten über einen Proxy, der für beide Peers sichtbar ist.  Es führt zu Verzögerungen und ist teurer in der Ausführung als STUN (da es während der gesamten Kommunikationssitzung verwendet wird), aber manchmal ist dies die einzig mögliche Option. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Interactive Connectivity Establishment</strong> ( <strong>ICE</strong> ) wird</a> verwendet, um den bestmöglichen Weg zum Verbinden von zwei Peers auszuwählen, basierend auf Informationen, die durch direkte Verbindung von Peers erhalten wurden, sowie Informationen, die von einer beliebigen Anzahl von STUN- und TURN-Servern empfangen wurden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><strong>Das Session Description Protocol</strong> ( <strong>SDP</strong> )</a> ist ein Format zur Beschreibung der Parameter des Verbindungskanals, z. B. ICE-Kandidaten, Multimedia-Codecs (im Fall eines Audio- / Videokanals) usw. Einer der Peers sendet ein SDP-Angebot ("Angebot") und der zweite antwortet mit SDP Antwort ("Antwort").  Danach wird ein Kanal erstellt. </li></ul><br>  Um eine solche Verbindung herzustellen, müssen Peers die Informationen, die sie von den Servern STUN und TURN erhalten haben, sammeln und untereinander austauschen. <br><br>  Das Problem ist, dass sie noch nicht in der Lage sind, Daten direkt auszutauschen. Daher muss es einen Out-of-Band-Mechanismus für den Austausch dieser Daten geben: einen Signalserver. <br><br>  Ein Signalserver kann sehr einfach sein, da seine einzige Aufgabe darin besteht, Daten zwischen Peers in der Phase „Handshake“ umzuleiten (wie in der folgenden Abbildung dargestellt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/972/ba0/5ac972ba057357540ffd749081dbdd3b.png" width="783" height="710"></div><br>  <i>Vereinfachte WebRTC-Handshake-Sequenz</i> <br><br><h1>  Teeworlds Netzwerkmodellübersicht </h1><br>  Die Netzwerkarchitektur von Teeworlds ist sehr einfach: <br><br><ul><li>  Die Client- und Serverkomponenten sind zwei verschiedene Programme. </li><li>  Clients betreten das Spiel, indem sie eine Verbindung zu einem von mehreren Servern herstellen, auf denen jeweils nur ein Spiel gehostet wird. </li><li>  Die gesamte Datenübertragung im Spiel erfolgt über den Server. </li><li>  Ein spezieller Master-Server wird verwendet, um eine Liste aller öffentlichen Server zu erfassen, die im Spielclient angezeigt werden. </li></ul><br>  Aufgrund der Verwendung von WebRTC für den Datenaustausch können wir die Serverkomponente des Spiels an den Browser übertragen, in dem sich der Client befindet.  Es gibt uns eine großartige Gelegenheit ... <br><br><h1>  Server loswerden </h1><br>  Das Fehlen der Serverlogik hat einen schönen Vorteil: Wir können die gesamte Anwendung als statischen Inhalt auf Github Pages oder auf unseren eigenen Geräten hinter Cloudflare bereitstellen und so schnelle Downloads und hohe Verfügbarkeit kostenlos sicherstellen.  Tatsächlich können wir sie vergessen, und wenn wir Glück haben und das Spiel populär wird, muss die Infrastruktur nicht modernisiert werden. <br><br>  Damit das System funktioniert, müssen wir jedoch noch eine externe Architektur verwenden: <br><br><ul><li>  Ein oder mehrere STUN-Server: Wir haben die Wahl zwischen mehreren kostenlosen Optionen. </li><li>  Mindestens ein TURN-Server: Hier gibt es keine kostenlosen Optionen, sodass wir entweder unsere eigenen einrichten oder für den Service bezahlen können.  Glücklicherweise können Sie die meiste Zeit eine Verbindung über die STUN-Server herstellen (und echtes p2p bereitstellen), aber TURN wird als Fallback benötigt. </li><li>  Signalserver: Im Gegensatz zu den beiden anderen Aspekten ist die Signalisierung nicht standardisiert.  Wofür der Signalserver tatsächlich verantwortlich ist, hängt in gewisser Weise von der Anwendung ab.  In unserem Fall ist es vor dem Herstellen einer Verbindung erforderlich, eine kleine Datenmenge auszutauschen. </li><li>  Teeworlds Master-Server: Er wird von anderen Servern verwendet, um über seine Existenz zu informieren, und von Clients, um nach öffentlichen Servern zu suchen.  Obwohl dies nicht erforderlich ist (Clients können jederzeit eine Verbindung zu einem Server herstellen, den sie manuell kennen), wäre es schön, ihn zu haben, damit Spieler an Spielen mit zufälligen Personen teilnehmen können. </li></ul><br>  Wir haben uns für die Verwendung der kostenlosen STUN-Server von Google entschieden und einen TURN-Server selbst bereitgestellt. <br><br>  Für die letzten beiden Punkte haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Firebase verwendet</a> : <br><br><ul><li>  Der Teeworlds-Masterserver ist sehr einfach zu implementieren: als Liste von Objekten, die Informationen (Name, IP, Karte, Modus, ...) jedes aktiven Servers enthalten.  Die Server veröffentlichen und aktualisieren ihr eigenes Objekt, und die Clients nehmen die gesamte Liste und zeigen sie dem Player an.  Wir zeigen die Liste auf der Homepage auch als HTML an, sodass die Spieler einfach auf den Server klicken und direkt zum Spiel gehen können. </li><li>  Die Signalisierung hängt eng mit unserer Socket-Implementierung zusammen, die im nächsten Abschnitt beschrieben wird. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d6/ae6/72d/3d6ae672db99216dabcf0a792d008f5e.png" width="1697" height="513"></div><br>  <i>Liste der Server im Spiel und auf der Homepage</i> <br><br><h1>  Socket-Implementierung </h1><br>  Wir möchten eine API erstellen, die so nah wie möglich an Posix UDP Sockets liegt, um die Anzahl der erforderlichen Änderungen zu minimieren. <br><br>  Wir wollen auch das notwendige Minimum realisieren, das für den einfachsten Datenaustausch über das Netzwerk erforderlich ist. <br><br>  Zum Beispiel benötigen wir kein echtes Routing: Alle Peers befinden sich im selben „virtuellen LAN“, das einer bestimmten Instanz der Firebase-Datenbank zugeordnet ist. <br><br>  Daher benötigen wir keine eindeutigen IP-Adressen: Für die eindeutige Identifizierung von Peers ist es ausreichend, eindeutige Werte von Firebase-Schlüsseln (ähnlich wie Domänennamen) zu verwenden, und jeder Peer weist jedem Schlüssel, der konvertiert werden muss, lokal „gefälschte“ IP-Adressen zu.  Dadurch entfällt die Notwendigkeit einer globalen IP-Adresszuweisung vollständig, was keine triviale Aufgabe ist. <br><br>  Hier ist die Mindest-API, die wir implementieren müssen: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create and destroy a socket int socket(); int close(int fd); // Bind a socket to a port, and publish it on Firebase int bind(int fd, AddrInfo* addr); // Send a packet. This lazily create a WebRTC connection to the // peer when necessary int sendto(int fd, uint8_t* buf, int len, const AddrInfo* addr); // Receive the packets destined to this socket int recvfrom(int fd, uint8_t* buf, int len, AddrInfo* addr); // Be notified when new packets arrived int recvCallback(Callback cb); // Obtain a local ip address for this peer key uint32_t resolve(client::String* key); // Get the peer key for this ip String* reverseResolve(uint32_t addr); // Get the local peer key String* local_key(); // Initialize the library with the given Firebase database and // WebRTc connection options void init(client::FirebaseConfig* fb, client::RTCConfiguration* ice);</span></span></code> </pre> <br>  Die API ist einfach und ähnelt der Posix Sockets-API, weist jedoch einige wichtige Unterschiede auf: <strong>Registrieren von Rückrufen, Zuweisen lokaler IPs und eine verzögerte Verbindung</strong> . <br><br><h2>  Rückrufregistrierung </h2><br>  Selbst wenn das Quellprogramm nicht blockierende E / A verwendet, muss der Code überarbeitet werden, damit er in einem Webbrowser ausgeführt werden kann. <br><br>  Der Grund dafür ist, dass die Ereignisschleife im Browser vor dem Programm verborgen ist (sei es JavaScript oder WebAssembly). <br><br>  In einer nativen Umgebung können wir auf diese Weise Code schreiben <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { select(...); <span class="hljs-comment"><span class="hljs-comment">// wait for I/O events while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }</span></span></code> </pre> <br>  Wenn die Ereignisschleife für uns verborgen ist, müssen wir daraus etwas machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cb = []() { <span class="hljs-comment"><span class="hljs-comment">// this will be called when new data is available while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }; recvCallback(cb); // register the callback</span></span></code> </pre> <br><h2>  Lokale IP-Zuweisung </h2><br>  Die Kennungen der Knoten in unserem „Netzwerk“ sind keine IP-Adressen, sondern Firebase-Schlüssel (dies sind Zeilen, die folgendermaßen aussehen: <code>-LmEC50PYZLCiCP-vqde</code> ). <br><br>  Dies ist praktisch, da wir keinen Mechanismus zum Zuweisen von IP und zum Überprüfen ihrer Eindeutigkeit (sowie ihrer Entsorgung nach dem Trennen des Clients) benötigen. Es ist jedoch häufig erforderlich, Peers anhand eines numerischen Werts zu identifizieren. <br><br>  Hierzu werden die Funktionen <code>resolve</code> und <code>reverseResolve</code> verwendet: Die Anwendung erhält irgendwie den Zeichenfolgenwert des Schlüssels (durch Benutzereingabe oder über den Master-Server) und kann ihn für den internen Gebrauch in eine IP-Adresse konvertieren.  Der Rest der API erhält der Einfachheit halber auch diesen Wert anstelle einer Zeichenfolge. <br><br>  Dies ähnelt einer DNS-Suche, die nur lokal auf dem Client durchgeführt wird. <br><br>  Das heißt, IP-Adressen können nicht von verschiedenen Clients gemeinsam genutzt werden. Wenn Sie eine globale Kennung benötigen, müssen Sie diese auf andere Weise generieren. <br><br><h2>  Faule Mischung </h2><br>  UDP benötigt keine Verbindung, aber wie wir gesehen haben, erfordert WebRTC vor dem Starten der Datenübertragung zwischen zwei Peers einen langen Verbindungsprozess. <br><br>  Wenn wir dieselbe Abstraktionsebene <code>sendto</code> <code>recvfrom</code> ( <code>sendto</code> / <code>recvfrom</code> mit beliebigen Peers, ohne zuvor eine Verbindung herzustellen), müssen wir innerhalb der API eine "faule" (verzögerte) Verbindung herstellen. <br><br>  Folgendes passiert während des normalen Datenaustauschs zwischen dem „Server“ und dem „Client“ bei Verwendung von UDP und was unsere Bibliothek tun sollte: <br><br><ul><li>  Der Server ruft <code>bind()</code> auf, um dem Betriebssystem mitzuteilen, dass es Pakete an den angegebenen Port empfangen möchte. </li></ul><br>  Stattdessen veröffentlichen wir den offenen Port in Firebase unter dem Serverschlüssel und hören Ereignisse in seinem Teilbaum ab. <br><br><ul><li>  Der Server ruft <code>recvfrom()</code> und akzeptiert Pakete von einem beliebigen Host an diesen Port. </li></ul><br>  In unserem Fall müssen wir die eingehende Warteschlange der an diesen Port gesendeten Pakete überprüfen. <br><br>  Jeder Port hat eine eigene Warteschlange, und wir fügen die Quell- und Zielports am Anfang der WebRTC-Datagramme hinzu, um zu wissen, welche Warteschlange umgeleitet werden soll, wenn ein neues Paket eintrifft. <br><br>  Der Aufruf ist nicht blockierend. Wenn also keine Pakete vorhanden sind, geben wir einfach -1 zurück und setzen <code>errno=EWOULDBLOCK</code> . <br><br><ul><li>  Der Client empfängt die IP und den Port des Servers auf externe Weise und ruft <code>sendto()</code> .  Außerdem wird ein interner Aufruf von <code>bind()</code> ausgeführt, sodass nachfolgendes <code>recvfrom()</code> eine Antwort erhält, ohne bind explizit auszuführen. </li></ul><br>  In unserem Fall empfängt der Client den Zeichenfolgenschlüssel extern und verwendet die Funktion <code>resolve()</code> , um die IP-Adresse abzurufen. <br><br>  An diesem Punkt beginnen wir mit dem „Handshake“ von WebRTC, wenn die beiden Peers noch nicht miteinander verbunden sind.  Verbindungen zu verschiedenen Ports desselben Peers verwenden denselben DataRannel-WebRTC. <br><br>  Wir führen auch indirekt <code>bind()</code> damit der Server beim nächsten <code>sendto()</code> falls er aus irgendeinem Grund geschlossen wird. <br><br>  Der Server wird über die Verbindung des Clients benachrichtigt, wenn der Client sein SDP-Angebot unter den Serverportinformationen in Firebase schreibt, und der Server antwortet mit seiner eigenen Antwort. <br><br><hr><br>  Das folgende Diagramm zeigt ein Beispiel für die Verschiebung von Nachrichten für ein Socket-Schema und die Übertragung der ersten Nachricht vom Client zum Server: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/03a/024/b4e03a0246a77f74034c3b823bc7a1a6.png" width="787" height="1656"></div><br>  <i>Vollständiges Verbindungsschrittdiagramm zwischen Client und Server</i> <br><br><h1>  Fazit </h1><br>  Wenn Sie bis zum Ende gelesen haben, sind Sie wahrscheinlich daran interessiert, die Theorie in Aktion zu betrachten.  Das Spiel kann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">teeworlds.leaningtech.com gespielt werden</a> , probieren Sie es aus! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Freundschaftsspiel zwischen Kollegen</i> <br><br>  Der Netzwerkbibliothekscode ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Github</a> frei verfügbar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Chatten Sie</a> auf unserem Kanal in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Gitter</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468031/">https://habr.com/ru/post/de468031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468019/index.html">Website-Entwicklung in WebAssembly mit NetCore 3 und Blazor</a></li>
<li><a href="../de468021/index.html">PHP, wie viel Abstraktion für die Menschen?</a></li>
<li><a href="../de468023/index.html">Künstliche Intelligenz im Kampfspiel Shadow Fight 3</a></li>
<li><a href="../de468025/index.html">Wie konfiguriere ich SNI in Zimbra OSE?</a></li>
<li><a href="../de468027/index.html">Codeoptimierungsmethoden für Redd. Teil 2: Nicht zwischenspeicherbarer Speicher und paralleler Busbetrieb</a></li>
<li><a href="../de468035/index.html">Laden Sie die Presse mit einem Gamecontroller oder 8 ungewöhnlichen Patenten für Eingabegeräte herunter</a></li>
<li><a href="../de468039/index.html">Moskau Kubernetes Meetup # 6 bei Acronis (Fiztehpark) 10/03/2019</a></li>
<li><a href="../de468041/index.html">Ankündigung der Kubernetes Web View-Weboberfläche (und eine kurze Übersicht über andere Web-Benutzeroberflächen für Kubernetes)</a></li>
<li><a href="../de468043/index.html">So erstellen Sie ein UI-Kit, das zum Verkauf steht. Entwicklungsstadien eines kommerziellen Designsystems</a></li>
<li><a href="../de468047/index.html">Arbeiten mit Hierarchien in lsFusion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>