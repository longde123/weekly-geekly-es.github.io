<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍚 🐺 🚣🏾 Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client 👩🏾‍🎤 🧙 ⛹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem der vorherigen Artikel haben wir Technologien besprochen, die in unserem neuen Projekt verwendet werden - einem schnellen Shooter für mobile ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/415959/">  In einem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen</a> Artikel haben wir Technologien besprochen, die in unserem neuen Projekt verwendet werden - einem schnellen Shooter für mobile Geräte.  Jetzt möchte ich mitteilen, wie der Client-Teil des Netzwerkcodes des zukünftigen Spiels angeordnet ist, auf welche Schwierigkeiten wir gestoßen sind und wie sie gelöst werden können. <br><br><img src="https://habrastorage.org/webt/va/gz/nl/vagznl64ylol9qhxysj5ti1akpy.jpeg"><br><a name="habracut"></a><br><br>  Im Allgemeinen haben sich die Ansätze zur Erstellung schneller Multiplayer-Spiele in den letzten 20 Jahren nicht wesentlich geändert.  In der Netzwerkcodearchitektur können verschiedene Methoden unterschieden werden: <br><br><ol><li>  Fehleinschätzung des Zustands der Welt auf dem Server und Anzeige der Ergebnisse auf dem Client ohne Vorhersage für den lokalen Spieler und mit der Möglichkeit, Spielereingaben (Eingaben) zu verlieren.  Dieser Ansatz wird übrigens bei unserem anderen Projekt in der Entwicklung verwendet - Sie können hier darüber lesen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lockstep</a> </li><li>  Synchronisation des Weltzustands ohne deterministische Logik mit Vorhersage für einen lokalen Spieler. </li><li>  Eingangssynchronisation mit vollständig deterministischer Logik und Vorhersage für einen lokalen Spieler. </li></ol><br>  Die Besonderheit liegt in der Tatsache, dass bei Schützen die Reaktionsfähigkeit der Kontrolle am wichtigsten ist - der Spieler drückt einen Knopf (oder bewegt den Joystick) und möchte sofort das Ergebnis seiner Aktion sehen.  Erstens, weil sich der Zustand der Welt in solchen Spielen sehr schnell ändert und es notwendig ist, sofort auf die Situation zu reagieren. <br><br>  Infolgedessen waren Ansätze ohne einen Mechanismus zur Vorhersage der Aktionen eines lokalen Spielers (Vorhersage) für das Projekt nicht geeignet, und wir entschieden uns für eine Methode zur Synchronisierung des Weltzustands ohne deterministische Logik. <br><br>  <b>Vorteil des Ansatzes:</b> Weniger Komplexität bei der Implementierung im Vergleich zur Synchronisationsmethode beim Austausch von Eingaben. <br>  <b>Minus:</b> eine Zunahme des Datenverkehrs, wenn der gesamte Zustand der Welt an den Kunden gesendet wird.  Wir mussten verschiedene Techniken zur Verkehrsoptimierung anwenden, damit das Spiel in einem Mobilfunknetz stabil funktioniert. <br><br>  Im Zentrum der Gameplay-Architektur steht ECS, über das wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesprochen haben</a> .  Mit dieser Architektur können Sie Daten über die Spielwelt bequem speichern, serialisieren, kopieren und über das Netzwerk übertragen.  Und auch, um den gleichen Code sowohl auf dem Client als auch auf dem Server auszuführen. <br><br>  Die Simulation der Spielwelt erfolgt mit einer festen Frequenz von 30 Ticks pro Sekunde.  Auf diese Weise können Sie die Verzögerung der Spielereingabe verringern und fast keine Interpolation verwenden, um den Zustand der Welt visuell anzuzeigen.  Bei der Entwicklung eines solchen Systems sollte jedoch ein wesentlicher Nachteil berücksichtigt werden: Damit das Vorhersagesystem des lokalen Spielers ordnungsgemäß funktioniert, muss der Client die Welt mit derselben Häufigkeit wie der Server simulieren.  Und wir haben viel Zeit darauf verwendet, die Simulation ausreichend für die Zielgeräte zu optimieren. <br><br><h2>  Vorhersagemechanismus für lokale Spieleraktionen (Vorhersage) </h2><br>  Der Client-Vorhersagemechanismus wird auf der Basis von ECS implementiert, da dieselben Systeme sowohl auf dem Client als auch auf dem Server ausgeführt werden.  Es werden jedoch nicht alle Systeme auf dem Client ausgeführt, sondern nur diejenigen, die für den lokalen Spieler verantwortlich sind und keine relevanten Daten über andere Spieler benötigen. <br><br>  Beispiel für Listen von Systemen, die auf dem Client und Server ausgeführt werden: <br><br><img src="https://habrastorage.org/webt/sm/jl/wc/smjlwcvyu5mv2omhgnggu9zbbnc.png"><br><br>  Derzeit laufen auf dem Client etwa 30 Systeme, die die Vorhersage des Players liefern, und auf dem Server etwa 80 Systeme.  Wir sagen jedoch keine Dinge voraus, wie Schaden zuzufügen, Fähigkeiten einzusetzen oder Verbündete zu heilen.  Bei dieser Mechanik gibt es zwei Probleme: <br><br><ol><li>  Der Client weiß nichts über das Betreten anderer Spieler und die Vorhersage von Schäden oder Heilung weicht fast immer von den Daten auf dem Server ab. </li><li>  Das lokale Erstellen neuer Entitäten (Schüsse, Muscheln, einzigartige Fähigkeiten), die von einem Spieler generiert werden, birgt das Problem der Übereinstimmung mit auf dem Server erstellten Entitäten. </li></ol><br>  Für einen solchen Mechaniker verbirgt sich die Verzögerung auf andere Weise vor dem Spieler. <br><br>  <i>Beispiel: Wir ziehen den Effekt des Treffens sofort aus dem Schuss und aktualisieren das Leben des Feindes erst, nachdem wir vom Server eine Bestätigung des Treffers erhalten haben.</i> <br><br><h2>  Das allgemeine Schema des Netzwerkcodes im Projekt </h2><br><br><img src="https://habrastorage.org/webt/so/vq/gw/sovqgwxy7gc2rxtsqedxdlkpdew.png"><br>  Der Client und der Server synchronisieren die Zeit anhand von Tick-Nummern.  Aufgrund der Tatsache, dass die Datenübertragung über das Netzwerk einige Zeit in Anspruch nimmt, ist der Client dem Server immer um die Hälfte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTT</a> + der Größe des Eingabepuffers auf dem Server voraus.  Das obige Diagramm zeigt, dass der Client eine Eingabe für Tick 20 (a) sendet.  Gleichzeitig wird Häkchen 15 (b) auf dem Server verarbeitet.  Wenn die Eingabe des Clients den Server erreicht, wird das Häkchen 20 auf dem Server verarbeitet. <br><br>  Der gesamte Prozess besteht aus den folgenden Schritten: Der Client sendet die Eingabe des Players an den Server (a) → Diese Eingabe wird auf dem Server verarbeitet, nachdem HRTT + Eingabepuffergröße (b) → der Server den resultierenden Weltstatus an den / die Client (s) gesendet hat → Der Client wendet den bestätigten Weltstatus mit an Serverzeit RTT + Eingabepuffergröße + Spielstatus-Interpolationspuffergröße (d). <br><br>  Nachdem der Client vom Server (d) einen neuen bestätigten Status der Welt erhalten hat, muss er den Abstimmungsprozess abschließen.  Tatsache ist, dass der Client eine Weltvorhersage nur auf der Grundlage der Eingaben des lokalen Spielers durchführt.  Die Eingaben anderer Spieler sind ihm nicht bekannt.  Bei der Berechnung des Weltzustands auf dem Server befindet sich der Player möglicherweise in einem anderen Zustand als vom Client vorhergesagt.  Dies kann passieren, wenn ein Spieler betäubt oder getötet wird. <br><br>  Das Genehmigungsverfahren besteht aus zwei Teilen: <br><br><ol><li>  Vergleiche des vorhergesagten Zustands der Welt für vom Server empfangenes Häkchen N.  An dem Vergleich sind nur die Daten beteiligt, die sich auf den lokalen Spieler beziehen.  Die restlichen Daten der Welt werden immer aus dem Serverstatus entnommen und nehmen nicht an der Koordination teil. </li><li>  Während des Vergleichs können zwei Fälle auftreten: </li></ol><br>  - Wenn der vorhergesagte Zustand der Welt mit dem vom Server bestätigten übereinstimmt, simuliert der Client unter Verwendung der vorhergesagten Daten für den lokalen Spieler und der neuen Daten für den Rest der Welt die Welt weiterhin im normalen Modus. <br>  - Wenn der vorhergesagte Status nicht übereinstimmt, verwendet der Client den gesamten Serverstatus der Welt und den Verlauf der Eingaben vom Client und gibt den neuen vorhergesagten Status der Welt des Spielers wieder. <br><br><div class="spoiler">  <b class="spoiler_title">Im Code sieht es ungefähr so ​​aus:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">GameState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconcile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentTick, ServerGameStateData serverStateData, GameState currentState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverState = serverStateData.GameState; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverTick = serverState.Time; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> predictedState = _localStateHistory.Get(serverTick); <span class="hljs-comment"><span class="hljs-comment">//if predicted state matches server last state use server predicted state with predicted player if (_gameStateComparer.IsSame(predictedState, serverState, playerID)) { _tempState.Copy(serverState); _gameStateCopier.CopyPlayerEntities(currentState, _tempState, playerID); return _localStateHistory.Put(_tempState); // replace predicted state with correct server state } //if predicted state doesn't match server state, reapply local inputs to server state var last = _localStateHistory.Put(serverState); // replace wrong predicted state with correct server state for (var i = serverTick; i &lt; currentTick; i++) { last = _prediction.Predict(last); // resimulate all wrong states } return last; }</span></span></code> </pre> <br></div></div><br>  Der Vergleich zweier Weltzustände erfolgt nur für diejenigen Daten, die sich auf den lokalen Spieler beziehen und am Vorhersagesystem teilnehmen.  Die Daten werden anhand der Spieler-ID abgetastet. <br><br><div class="spoiler">  <b class="spoiler_title">Vergleichsmethode:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState s1, GameState s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || s1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity1 = s1.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity2 = s2.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Time != s2.Time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Weapon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s1.WorldState.Weapon) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value.Owner.Id != avatarId) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Weapon = s2.WorldState.Weapon[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value != s2Weapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Ammo = s1.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Ammo = s2.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Ammo != s2Ammo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Reload = s1.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Reload = s2.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Reload != s2Reload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.Aiming != entity2.Aiming) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.ChangeWeapon != entity2.ChangeWeapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Vergleichsoperatoren für bestimmte Komponenten werden zusammen mit der gesamten EC-Struktur generiert, die speziell von einem Codegenerator geschrieben wurde.  Zum Beispiel gebe ich den generierten Code des Transformationskomponenten-Vergleichsoperators an: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Es ist zu beachten, dass unsere Float-Werte mit einem ziemlich hohen Fehler verglichen werden.  Dies geschieht, um die Desynchronisierung zwischen Client und Server zu verringern.  Für den Spieler ist ein solcher Fehler unsichtbar, dies spart jedoch erheblich die Rechenressourcen des Systems. <br><br>  Die Komplexität des Koordinierungsmechanismus besteht darin, dass im Falle einer Fehlersynchronisation der Client- und Serverzustände (falsche Vorhersage) alle vorhergesagten Clientzustände, für die keine Bestätigung vom Server vorliegt, bis zum aktuellen Tick in einem Frame wiederholt simuliert werden müssen.  Je nach Ping des Spielers können dies 5 bis 20 Simulations-Ticks sein.  Wir mussten den Simulationscode deutlich optimieren, um in den Zeitrahmen zu passen: 30 fps. <br><br>  Um den Genehmigungsprozess abzuschließen, müssen zwei Arten von Daten auf dem Client gespeichert werden: <br><br><ol><li>  Eine Geschichte vorhergesagter Spielerzustände. </li><li>  Und die Geschichte der Eingabe. </li></ol><br>  Für diese Zwecke verwenden wir einen Ringpuffer.  Die Puffergröße beträgt 32 Ticks.  Dies ergibt bei einer Frequenz von 30 Hz etwa 1 Sekunde Echtzeit.  Der Client kann sicher weiter am Vorhersagemechanismus arbeiten, ohne neue Daten vom Server zu erhalten, bis dieser Puffer gefüllt ist.  Wenn der Unterschied zwischen der Zeit des Clients und des Servers mehr als eine Sekunde beträgt, muss der Client die Verbindung trennen, um erneut eine Verbindung herzustellen.  Wir haben eine solche Puffergröße aufgrund der Kosten des Koordinierungsprozesses im Falle einer Diskrepanz zwischen den Staaten der Welt.  Wenn der Unterschied zwischen dem Client und dem Server jedoch mehr als eine Sekunde beträgt, ist es billiger, eine vollständige Wiederverbindung mit dem Server durchzuführen. <br><br><h2>  Reduzierung der Verzögerungszeit </h2><br>  Das obige Diagramm zeigt, dass das Datenübertragungsschema im Spiel zwei Puffer enthält: <br><br><ul><li>  Eingabepuffer auf dem Server; </li><li>  ein Puffer von Weltzuständen auf dem Client. </li></ul><br>  Der Zweck dieser Puffer ist der gleiche - Netzwerksprünge (Jitter) zu kompensieren.  Tatsache ist, dass die Paketübertragung über das Netzwerk ungleichmäßig ist.  Und da die Netzwerk-Engine mit einer festen Frequenz von 30 Hz arbeitet, müssen der Engine Daten mit derselben Frequenz zugeführt werden.  Wir haben nicht die Möglichkeit, einige ms zu "warten", bis das nächste Paket den Empfänger erreicht.  Wir verwenden Puffer für Eingabedaten und Weltzustände, um einen Zeitrahmen für die Jitterkompensation zu haben.  Wir verwenden den Gamestate-Puffer auch zur Interpolation, wenn eines der Pakete verloren geht. <br><br>  Zu Beginn des Spiels beginnt der Client erst dann mit der Synchronisierung mit dem Server, wenn er mehrere Weltzustände vom Server empfangen hat und der Gamestate-Puffer voll ist.  Normalerweise beträgt die Größe dieses Puffers 3 Ticks (100 ms). <br><br>  Wenn der Client mit dem Server synchronisiert wird, wird er gleichzeitig vor der Serverzeit um den Wert des Eingabepuffers auf dem Server "ausgeführt".  Das heißt,  Der Client selbst steuert, wie weit er dem Server voraus ist.  Die Startgröße des Eingabepuffers beträgt ebenfalls 3 Ticks (100 ms). <br><br>  Zunächst haben wir die Größe dieser Puffer als Konstanten implementiert.  Das heißt,  Unabhängig davon, ob der Jitter tatsächlich im Netzwerk vorhanden war oder nicht, gab es eine feste Verzögerung von 200 ms (Eingabepuffergröße + Spielstatuspuffergröße) für die Aktualisierung der Daten.  Wenn wir den durchschnittlichen geschätzten Ping auf Mobilgeräten um 200 ms hinzufügen, betrug die tatsächliche Verzögerung zwischen der Verwendung der Eingabe auf dem Client und der Bestätigung der Anwendung vom Server 400 ms! <br><br>  Das passte nicht zu uns. <br><br>  Tatsache ist, dass einige Systeme nur auf dem Server ausgeführt werden - beispielsweise die Berechnung der HP des Players.  Mit dieser Verzögerung schießt der Spieler und sieht erst nach 400 ms, wie er den Gegner tötet.  Wenn dies in Bewegung geschah, gelang es dem Spieler normalerweise, hinter die Mauer oder in Deckung zu rennen und dort bereits zu sterben.  Spieletests innerhalb des Teams haben gezeigt, dass eine solche Verzögerung das gesamte Gameplay vollständig beeinträchtigt. <br><br>  Die Lösung für dieses Problem war die Implementierung dynamischer Größen von Eingabepuffern und Spielzuständen: <br><ul><li>  Bei einem Gamestate-Puffer kennt der Client immer den aktuellen Pufferinhalt.  Zum Zeitpunkt der Berechnung des nächsten Ticks prüft der Client, wie viele Zustände sich bereits im Puffer befinden. </li><li>  für den Eingabepuffer - Der Server hat zusätzlich zum Spielstatus begonnen, den Wert der aktuellen Füllung des Eingabepuffers für einen bestimmten Client an den Client zu senden.  Der Kunde analysiert wiederum diese beiden Werte. </li></ul><br>  Der Algorithmus zur Größenänderung des Gamestate-Puffers lautet ungefähr wie folgt: <br><br><ol><li>  Der Client berücksichtigt den Durchschnittswert der Puffergröße über einen Zeitraum und eine Varianz. </li><li>  Wenn die Varianz innerhalb normaler Grenzen liegt (d. H. Für einen bestimmten Zeitraum gab es keine großen Sprünge beim Füllen und Lesen aus dem Puffer), überprüft der Client den Wert der durchschnittlichen Puffergröße für diesen Zeitraum. </li><li>  Wenn die durchschnittliche Pufferfüllung größer als die obere Randbedingung war (dh der Puffer würde mehr als erforderlich gefüllt), „reduziert“ der Client die Puffergröße durch Ausführen eines zusätzlichen Simulationsticks. </li><li>  Wenn die durchschnittliche Pufferfüllung geringer war als die untere Randbedingung (dh der Puffer hatte keine Zeit zum Füllen, bevor der Client mit dem Lesen begann), erhöht der Client in diesem Fall die Puffergröße, indem er einen Tick der Simulation überspringt. </li><li>  In dem Fall, in dem die Varianz über dem Normalwert lag, können wir uns nicht auf diese Daten verlassen, weil  Die Netzwerkstöße für einen bestimmten Zeitraum waren zu groß.  Anschließend verwirft der Client alle aktuellen Daten und beginnt erneut mit der Erfassung von Statistiken. </li></ol><br><h2>  Kompensation der Serververzögerung </h2><br>  Aufgrund der Tatsache, dass der Client mit einer Verzögerung (Verzögerung) Weltaktualisierungen vom Server empfängt, sieht der Spieler die Welt ein wenig anders als auf dem Server.  Der Spieler sieht sich in der Gegenwart und im Rest der Welt - in der Vergangenheit.  Auf dem Server existiert die ganze Welt auf einmal. <br><br><img src="https://habrastorage.org/webt/jo/ca/5d/joca5d_dhigvw1i9gjlpcd-tgqa.png"><br>  Aus diesem Grund schießt der Spieler lokal auf ein Ziel, das sich auf dem Server an einem anderen Ort befindet. <br><br>  Um die Verzögerung auszugleichen, verwenden wir den Zeitrücklauf auf dem Server.  Der Operationsalgorithmus ist ungefähr der folgende: <br><br><ol><li>  Der Client sendet mit jeder Eingabe zusätzlich die Tick-Zeit an den Server, in der er den Rest der Welt sieht. </li><li>  Der Server überprüft diese Zeit: ist die Differenz zwischen der aktuellen Zeit und der sichtbaren Zeit der Client-Welt im Konfidenzintervall. </li><li>  Wenn die Zeit gültig ist, verlässt der Server den Spieler in der aktuellen Zeit und der Rest der Welt kehrt in den Zustand zurück, in dem der Spieler das Ergebnis des Schusses gesehen und berechnet hat. </li><li>  Wenn ein Spieler trifft, wird der Schaden in der aktuellen Serverzeit verursacht. </li></ol><br>  Die Rückspulzeit auf einem Server funktioniert wie folgt: Die Geschichte der Welt (in ECS) und die Geschichte der Physik (unterstützt von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Volatile Physics</a> Engine) werden im Norden gespeichert.  Zum Zeitpunkt der Berechnung des Schusses wurden die Daten des Spielers aus dem aktuellen Zustand der Welt und die verbleibenden Spieler aus der Geschichte entnommen. <br><br><div class="spoiler">  <b class="spoiler_title">Der Code für das Schussvalidierungssystem sieht ungefähr so ​​aus:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shotPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Shot) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shot = shotPair.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooter = gs.WorldState[shotPair.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooterTransform = shooter.Transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weaponStats = gs.WorldState.WeaponStats[shot.WeaponId]; <span class="hljs-comment"><span class="hljs-comment">// DeltaTime shouldn't exceed physics history size var shootDeltaTime = (int) (gs.Time - shot.ShotPlayerWorldTime); if (shootDeltaTime &gt; PhysicsWorld.HistoryLength) { continue; } // Get the world at the time of shooting. var oldState = _immutableHistory.Get(shot.ShotPlayerWorldTime); var potentialTarget = oldState.WorldState[shot.Target.Id]; var hitTargetId = _singleShotValidator.ValidateTargetAvailabilityInLine(oldState, potentialTarget, shooter, shootDeltaTime, weaponStats.ShotDistance, shooter.Transform.Angle.GetDirection()); if (hitTargetId != 0) { gs.WorldState.CreateEntity().AddDamage(gs.WorldState[hitTargetId], shooter, weaponStats.ShotDamage); } } }</span></span></code> </pre> <br></div></div><br>  Ein wesentlicher Nachteil des Ansatzes besteht darin, dass wir dem Kunden die Daten zum Zeitpunkt des Ticks anvertrauen, den er sieht.  Potenziell kann ein Spieler einen Vorteil erzielen, indem er den Ping künstlich erhöht.  Weil  Je mehr Ping ein Spieler hat, desto weiter schießt er in der Vergangenheit. <br><br><h2>  Einige Probleme, auf die wir gestoßen sind </h2><br>  Während der Implementierung dieser Netzwerk-Engine sind wir auf viele Probleme gestoßen, von denen einige einen separaten Artikel wert sind, aber hier werde ich nur einige davon ansprechen. <br><br><h4>  Simulation der ganzen Welt in einem Vorhersagesystem und Kopieren </h4><br>  Anfangs hatten alle Systeme in unserem ECS nur eine Methode: void Execute (GameState gs).  Bei dieser Methode wurden normalerweise Komponenten verarbeitet, die sich auf alle Spieler beziehen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel für ein Bewegungssystem in der ersten Implementierung:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[movementPair.Key]; transform.Position += movementPair.Value.Velocity * GameState.TickDuration; } } }</code> </pre> <br></div></div><br>  Im lokalen Spielervorhersagesystem mussten wir jedoch nur die Komponenten verarbeiten, die sich auf einen bestimmten Spieler beziehen.  Zunächst haben wir dies mit copy implementiert. <br><br>  Der Vorhersageprozess war wie folgt: <br><br><ol><li>  Eine Kopie des Spielstatus wurde erstellt. </li><li>  Eine Kopie wurde an den ECS-Eingang geliefert. </li><li>  In ECS gab es eine Simulation der ganzen Welt. </li><li>  Alle Daten, die sich auf den lokalen Spieler beziehen, wurden aus dem neu empfangenen Spielstatus kopiert. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Die Vorhersagemethode sah folgendermaßen aus:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _tempGameState.Copy(state); _ecsExecutor.Execute(_tempGameState, input); _playerEntitiesCopier.Copy(_tempGameState, newState); }</code> </pre> <br></div></div><br>  Bei dieser Implementierung gab es zwei Probleme: <br><br><ol><li>  Weil  Wir verwenden Klassen, keine Strukturen - das Kopieren ist für uns eine ziemlich teure Operation (ca. 0,1-0,15 ms auf dem iPhone 5S). </li><li>  Die Simulation der ganzen Welt nimmt ebenfalls viel Zeit in Anspruch (ca. 1,5-2 ms auf dem iPhone 5S). </li></ol><br>  Wenn wir berücksichtigen, dass es während des Koordinierungsprozesses notwendig ist, 5 bis 15 Weltstaaten in einem Rahmen neu zu berechnen, dann war bei einer solchen Implementierung alles furchtbar langsam. <br><br>  Die Lösung war ganz einfach: zu lernen, die Welt in Teilen zu simulieren, nämlich nur einen bestimmten Spieler zu simulieren.  Wir haben alle Systeme neu geschrieben, damit Sie die ID des Spielers übertragen und nur ihn simulieren können. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel für ein Bewegungssystem nach einer Änderung:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { Move(gs.WorldState.Transform[movementPair.Key], movementPair.Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[playerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Move(gs.WorldState.Transform[playerId], movement); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform, Movement movement</span></span></span><span class="hljs-function">)</span></span> { transform.Position += movement.Velocity * GameState.TickDuration; } }</code> </pre> <br></div></div><br>  Nach den Änderungen konnten wir unnötige Kopien im Vorhersagesystem entfernen und die Belastung des Matching-Systems verringern. <br><br><div class="spoiler">  <b class="spoiler_title">Code:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _ecsExecutor.Execute(newState, input, playerId); }</code> </pre> <br></div></div><br><h4>  Erstellen und Löschen von Entitäten in einem Vorhersagesystem </h4><br>  In unserem System erfolgt der Abgleich von Entitäten auf dem Server und dem Client durch eine Ganzzahlkennung (ID).  Für alle Entitäten verwenden wir die End-to-End-Nummerierung von Bezeichnern. Jede neue Entität hat den Wert id = oldID + 1. <br><br>  Dieser Ansatz ist sehr praktisch zu implementieren, hat jedoch einen wesentlichen Nachteil: Die Reihenfolge der Erstellung neuer Entitäten auf dem Client und dem Server kann unterschiedlich sein, und infolgedessen unterscheiden sich die Kennungen der Entitäten. <br><br>  Dieses Problem trat auf, als wir ein System zur Vorhersage von Spielerschüssen implementierten.  Jeder Schuss bei uns ist eine separate Einheit mit der Schusskomponente.  Für jeden Client war die ID der Schussentitäten im Vorhersagesystem sequentiell.  Wenn jedoch im selben Moment ein anderer Spieler schoss, unterschied sich auf dem Server die ID aller Schüsse vom Client. <br><br>  Die Aufnahmen auf dem Server wurden in einer anderen Reihenfolge erstellt: <br><br><img src="https://habrastorage.org/webt/gl/dg/fy/gldgfykw7m30fuwspkra-xytgqe.png"><br><br>  Bei Schüssen haben wir diese Einschränkung umgangen, basierend auf den Gameplay-Funktionen des Spiels.  Schüsse sind schnell lebende Wesen, die im Bruchteil einer Sekunde nach ihrer Erstellung im System zerstört werden.  Auf dem Client haben wir einen separaten Bereich von IDs hervorgehoben, die sich nicht mit Server-IDs überschneiden und Aufnahmen im Koordinationssystem nicht mehr berücksichtigen.  Das heißt,  Die Schüsse lokaler Spieler werden im Spiel immer nur gemäß dem Vorhersagesystem gezogen und berücksichtigen nicht die Daten vom Server. <br><br>  Bei diesem Ansatz werden dem Spieler keine Artefakte auf dem Bildschirm angezeigt (Löschen, Neuerstellen, Zurücksetzen von Aufnahmen), und die Diskrepanzen mit dem Server sind gering und wirken sich nicht auf das gesamte Gameplay aus. <br><br>  Diese Methode ermöglichte es, das Problem mit Aufnahmen zu lösen, jedoch nicht das gesamte Problem der Erstellung von Entitäten auf dem gesamten Client.  Wir arbeiten noch an möglichen Methoden, um den Vergleich der auf dem Client und dem Server erstellten Objekte zu lösen. <br><br>  Es sollte auch beachtet werden, dass dieses Problem nur die Erstellung neuer Entitäten (mit neuen IDs) betrifft.  Das Hinzufügen und Entfernen von Komponenten zu bereits erstellten Entitäten erfolgt problemlos: Komponenten haben keine Bezeichner, und jede Entität kann nur eine Komponente eines bestimmten Typs haben.  Daher erstellen wir normalerweise Entitäten auf dem Server und fügen in Vorhersagesystemen nur Komponenten hinzu / entfernen diese. <br><br>  Abschließend möchte ich sagen, dass die Implementierung von Multiplayer nicht die einfachste und schnellste ist, aber es gibt viele Informationen dazu. <br><br><h2>  Was zu lesen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiplayer in schnellen Spielen</a> - Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fast-Paced Multiplayer (Teil I): Einführung</a> (meiner Meinung nach ist dies der beste Artikel über Netzwerkinteraktion in Spielen auf Habré). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDC Vault Overwatch Gameplay-Architektur und Netcode</a> - eine Vorlesung mit GDC 17 über ECS und Netzwerkcode in Overwatch (der Zugriff ist leider kostenpflichtig). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDC Vault: 8 Frames in 16 ms: Rollback-Networking in Mortal Kombat und Injustice 2</a> - wie dies in Kampfspielen gemacht wird. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quell-Multiplayer-Netzwerk</a> - Wie funktioniert Multiplayer in Counter Strike? </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bei Gaffer on Games</a> geht es im Allgemeinen um Netzwerkcode in Spielen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP in Game Engines</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDC Vault: Ich habe dich zum ersten Mal beim Networking erschossen</a> - wie Multiplayer in Halo: Reach funktioniert. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415959/">https://habr.com/ru/post/de415959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415947/index.html">Fehlerkompensationssystem für die Installation von optischen Fasern während der Verarbeitung durch Laserstrahlung während der Rotation</a></li>
<li><a href="../de415949/index.html">High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem „51% -Angriff“.</a></li>
<li><a href="../de415951/index.html">Mitap Sberbank und IBM auf HyperLedger Fabric</a></li>
<li><a href="../de415953/index.html">Wie blutiges Unternehmen Open Source gewinnt: der Kampf um BPMS</a></li>
<li><a href="../de415957/index.html">Wir brauchen mehr Rucksäcke: Bobby XL von XD Design</a></li>
<li><a href="../de415961/index.html">Russischer verteilter Speicher. Wie es funktioniert</a></li>
<li><a href="../de415963/index.html">Naive Bayes oder wie Sie mit Mathematik Spam filtern können</a></li>
<li><a href="../de415965/index.html">Was im Juli zu lesen ist: 19 neue Bücher für Digitalprofis</a></li>
<li><a href="../de415967/index.html">SolidFire - Speicher für diejenigen, die Hassspeicher haben</a></li>
<li><a href="../de415969/index.html">HyperX Pulsefire Surge RGB - ein natürlich geborener Killer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>