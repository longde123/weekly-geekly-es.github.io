<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçö üê∫ üö£üèæ Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client üë©üèæ‚Äçüé§ üßô ‚õπüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem der vorherigen Artikel haben wir Technologien besprochen, die in unserem neuen Projekt verwendet werden - einem schnellen Shooter f√ºr mobile ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/415959/">  In einem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen</a> Artikel haben wir Technologien besprochen, die in unserem neuen Projekt verwendet werden - einem schnellen Shooter f√ºr mobile Ger√§te.  Jetzt m√∂chte ich mitteilen, wie der Client-Teil des Netzwerkcodes des zuk√ºnftigen Spiels angeordnet ist, auf welche Schwierigkeiten wir gesto√üen sind und wie sie gel√∂st werden k√∂nnen. <br><br><img src="https://habrastorage.org/webt/va/gz/nl/vagznl64ylol9qhxysj5ti1akpy.jpeg"><br><a name="habracut"></a><br><br>  Im Allgemeinen haben sich die Ans√§tze zur Erstellung schneller Multiplayer-Spiele in den letzten 20 Jahren nicht wesentlich ge√§ndert.  In der Netzwerkcodearchitektur k√∂nnen verschiedene Methoden unterschieden werden: <br><br><ol><li>  Fehleinsch√§tzung des Zustands der Welt auf dem Server und Anzeige der Ergebnisse auf dem Client ohne Vorhersage f√ºr den lokalen Spieler und mit der M√∂glichkeit, Spielereingaben (Eingaben) zu verlieren.  Dieser Ansatz wird √ºbrigens bei unserem anderen Projekt in der Entwicklung verwendet - Sie k√∂nnen hier dar√ºber lesen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lockstep</a> </li><li>  Synchronisation des Weltzustands ohne deterministische Logik mit Vorhersage f√ºr einen lokalen Spieler. </li><li>  Eingangssynchronisation mit vollst√§ndig deterministischer Logik und Vorhersage f√ºr einen lokalen Spieler. </li></ol><br>  Die Besonderheit liegt in der Tatsache, dass bei Sch√ºtzen die Reaktionsf√§higkeit der Kontrolle am wichtigsten ist - der Spieler dr√ºckt einen Knopf (oder bewegt den Joystick) und m√∂chte sofort das Ergebnis seiner Aktion sehen.  Erstens, weil sich der Zustand der Welt in solchen Spielen sehr schnell √§ndert und es notwendig ist, sofort auf die Situation zu reagieren. <br><br>  Infolgedessen waren Ans√§tze ohne einen Mechanismus zur Vorhersage der Aktionen eines lokalen Spielers (Vorhersage) f√ºr das Projekt nicht geeignet, und wir entschieden uns f√ºr eine Methode zur Synchronisierung des Weltzustands ohne deterministische Logik. <br><br>  <b>Vorteil des Ansatzes:</b> Weniger Komplexit√§t bei der Implementierung im Vergleich zur Synchronisationsmethode beim Austausch von Eingaben. <br>  <b>Minus:</b> eine Zunahme des Datenverkehrs, wenn der gesamte Zustand der Welt an den Kunden gesendet wird.  Wir mussten verschiedene Techniken zur Verkehrsoptimierung anwenden, damit das Spiel in einem Mobilfunknetz stabil funktioniert. <br><br>  Im Zentrum der Gameplay-Architektur steht ECS, √ºber das wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesprochen haben</a> .  Mit dieser Architektur k√∂nnen Sie Daten √ºber die Spielwelt bequem speichern, serialisieren, kopieren und √ºber das Netzwerk √ºbertragen.  Und auch, um den gleichen Code sowohl auf dem Client als auch auf dem Server auszuf√ºhren. <br><br>  Die Simulation der Spielwelt erfolgt mit einer festen Frequenz von 30 Ticks pro Sekunde.  Auf diese Weise k√∂nnen Sie die Verz√∂gerung der Spielereingabe verringern und fast keine Interpolation verwenden, um den Zustand der Welt visuell anzuzeigen.  Bei der Entwicklung eines solchen Systems sollte jedoch ein wesentlicher Nachteil ber√ºcksichtigt werden: Damit das Vorhersagesystem des lokalen Spielers ordnungsgem√§√ü funktioniert, muss der Client die Welt mit derselben H√§ufigkeit wie der Server simulieren.  Und wir haben viel Zeit darauf verwendet, die Simulation ausreichend f√ºr die Zielger√§te zu optimieren. <br><br><h2>  Vorhersagemechanismus f√ºr lokale Spieleraktionen (Vorhersage) </h2><br>  Der Client-Vorhersagemechanismus wird auf der Basis von ECS implementiert, da dieselben Systeme sowohl auf dem Client als auch auf dem Server ausgef√ºhrt werden.  Es werden jedoch nicht alle Systeme auf dem Client ausgef√ºhrt, sondern nur diejenigen, die f√ºr den lokalen Spieler verantwortlich sind und keine relevanten Daten √ºber andere Spieler ben√∂tigen. <br><br>  Beispiel f√ºr Listen von Systemen, die auf dem Client und Server ausgef√ºhrt werden: <br><br><img src="https://habrastorage.org/webt/sm/jl/wc/smjlwcvyu5mv2omhgnggu9zbbnc.png"><br><br>  Derzeit laufen auf dem Client etwa 30 Systeme, die die Vorhersage des Players liefern, und auf dem Server etwa 80 Systeme.  Wir sagen jedoch keine Dinge voraus, wie Schaden zuzuf√ºgen, F√§higkeiten einzusetzen oder Verb√ºndete zu heilen.  Bei dieser Mechanik gibt es zwei Probleme: <br><br><ol><li>  Der Client wei√ü nichts √ºber das Betreten anderer Spieler und die Vorhersage von Sch√§den oder Heilung weicht fast immer von den Daten auf dem Server ab. </li><li>  Das lokale Erstellen neuer Entit√§ten (Sch√ºsse, Muscheln, einzigartige F√§higkeiten), die von einem Spieler generiert werden, birgt das Problem der √úbereinstimmung mit auf dem Server erstellten Entit√§ten. </li></ol><br>  F√ºr einen solchen Mechaniker verbirgt sich die Verz√∂gerung auf andere Weise vor dem Spieler. <br><br>  <i>Beispiel: Wir ziehen den Effekt des Treffens sofort aus dem Schuss und aktualisieren das Leben des Feindes erst, nachdem wir vom Server eine Best√§tigung des Treffers erhalten haben.</i> <br><br><h2>  Das allgemeine Schema des Netzwerkcodes im Projekt </h2><br><br><img src="https://habrastorage.org/webt/so/vq/gw/sovqgwxy7gc2rxtsqedxdlkpdew.png"><br>  Der Client und der Server synchronisieren die Zeit anhand von Tick-Nummern.  Aufgrund der Tatsache, dass die Daten√ºbertragung √ºber das Netzwerk einige Zeit in Anspruch nimmt, ist der Client dem Server immer um die H√§lfte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTT</a> + der Gr√∂√üe des Eingabepuffers auf dem Server voraus.  Das obige Diagramm zeigt, dass der Client eine Eingabe f√ºr Tick 20 (a) sendet.  Gleichzeitig wird H√§kchen 15 (b) auf dem Server verarbeitet.  Wenn die Eingabe des Clients den Server erreicht, wird das H√§kchen 20 auf dem Server verarbeitet. <br><br>  Der gesamte Prozess besteht aus den folgenden Schritten: Der Client sendet die Eingabe des Players an den Server (a) ‚Üí Diese Eingabe wird auf dem Server verarbeitet, nachdem HRTT + Eingabepuffergr√∂√üe (b) ‚Üí der Server den resultierenden Weltstatus an den / die Client (s) gesendet hat ‚Üí Der Client wendet den best√§tigten Weltstatus mit an Serverzeit RTT + Eingabepuffergr√∂√üe + Spielstatus-Interpolationspuffergr√∂√üe (d). <br><br>  Nachdem der Client vom Server (d) einen neuen best√§tigten Status der Welt erhalten hat, muss er den Abstimmungsprozess abschlie√üen.  Tatsache ist, dass der Client eine Weltvorhersage nur auf der Grundlage der Eingaben des lokalen Spielers durchf√ºhrt.  Die Eingaben anderer Spieler sind ihm nicht bekannt.  Bei der Berechnung des Weltzustands auf dem Server befindet sich der Player m√∂glicherweise in einem anderen Zustand als vom Client vorhergesagt.  Dies kann passieren, wenn ein Spieler bet√§ubt oder get√∂tet wird. <br><br>  Das Genehmigungsverfahren besteht aus zwei Teilen: <br><br><ol><li>  Vergleiche des vorhergesagten Zustands der Welt f√ºr vom Server empfangenes H√§kchen N.  An dem Vergleich sind nur die Daten beteiligt, die sich auf den lokalen Spieler beziehen.  Die restlichen Daten der Welt werden immer aus dem Serverstatus entnommen und nehmen nicht an der Koordination teil. </li><li>  W√§hrend des Vergleichs k√∂nnen zwei F√§lle auftreten: </li></ol><br>  - Wenn der vorhergesagte Zustand der Welt mit dem vom Server best√§tigten √ºbereinstimmt, simuliert der Client unter Verwendung der vorhergesagten Daten f√ºr den lokalen Spieler und der neuen Daten f√ºr den Rest der Welt die Welt weiterhin im normalen Modus. <br>  - Wenn der vorhergesagte Status nicht √ºbereinstimmt, verwendet der Client den gesamten Serverstatus der Welt und den Verlauf der Eingaben vom Client und gibt den neuen vorhergesagten Status der Welt des Spielers wieder. <br><br><div class="spoiler">  <b class="spoiler_title">Im Code sieht es ungef√§hr so ‚Äã‚Äãaus:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">GameState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconcile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentTick, ServerGameStateData serverStateData, GameState currentState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverState = serverStateData.GameState; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverTick = serverState.Time; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> predictedState = _localStateHistory.Get(serverTick); <span class="hljs-comment"><span class="hljs-comment">//if predicted state matches server last state use server predicted state with predicted player if (_gameStateComparer.IsSame(predictedState, serverState, playerID)) { _tempState.Copy(serverState); _gameStateCopier.CopyPlayerEntities(currentState, _tempState, playerID); return _localStateHistory.Put(_tempState); // replace predicted state with correct server state } //if predicted state doesn't match server state, reapply local inputs to server state var last = _localStateHistory.Put(serverState); // replace wrong predicted state with correct server state for (var i = serverTick; i &lt; currentTick; i++) { last = _prediction.Predict(last); // resimulate all wrong states } return last; }</span></span></code> </pre> <br></div></div><br>  Der Vergleich zweier Weltzust√§nde erfolgt nur f√ºr diejenigen Daten, die sich auf den lokalen Spieler beziehen und am Vorhersagesystem teilnehmen.  Die Daten werden anhand der Spieler-ID abgetastet. <br><br><div class="spoiler">  <b class="spoiler_title">Vergleichsmethode:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState s1, GameState s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || s1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity1 = s1.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity2 = s2.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Time != s2.Time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Weapon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s1.WorldState.Weapon) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value.Owner.Id != avatarId) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Weapon = s2.WorldState.Weapon[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value != s2Weapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Ammo = s1.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Ammo = s2.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Ammo != s2Ammo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Reload = s1.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Reload = s2.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Reload != s2Reload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.Aiming != entity2.Aiming) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.ChangeWeapon != entity2.ChangeWeapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Vergleichsoperatoren f√ºr bestimmte Komponenten werden zusammen mit der gesamten EC-Struktur generiert, die speziell von einem Codegenerator geschrieben wurde.  Zum Beispiel gebe ich den generierten Code des Transformationskomponenten-Vergleichsoperators an: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Es ist zu beachten, dass unsere Float-Werte mit einem ziemlich hohen Fehler verglichen werden.  Dies geschieht, um die Desynchronisierung zwischen Client und Server zu verringern.  F√ºr den Spieler ist ein solcher Fehler unsichtbar, dies spart jedoch erheblich die Rechenressourcen des Systems. <br><br>  Die Komplexit√§t des Koordinierungsmechanismus besteht darin, dass im Falle einer Fehlersynchronisation der Client- und Serverzust√§nde (falsche Vorhersage) alle vorhergesagten Clientzust√§nde, f√ºr die keine Best√§tigung vom Server vorliegt, bis zum aktuellen Tick in einem Frame wiederholt simuliert werden m√ºssen.  Je nach Ping des Spielers k√∂nnen dies 5 bis 20 Simulations-Ticks sein.  Wir mussten den Simulationscode deutlich optimieren, um in den Zeitrahmen zu passen: 30 fps. <br><br>  Um den Genehmigungsprozess abzuschlie√üen, m√ºssen zwei Arten von Daten auf dem Client gespeichert werden: <br><br><ol><li>  Eine Geschichte vorhergesagter Spielerzust√§nde. </li><li>  Und die Geschichte der Eingabe. </li></ol><br>  F√ºr diese Zwecke verwenden wir einen Ringpuffer.  Die Puffergr√∂√üe betr√§gt 32 Ticks.  Dies ergibt bei einer Frequenz von 30 Hz etwa 1 Sekunde Echtzeit.  Der Client kann sicher weiter am Vorhersagemechanismus arbeiten, ohne neue Daten vom Server zu erhalten, bis dieser Puffer gef√ºllt ist.  Wenn der Unterschied zwischen der Zeit des Clients und des Servers mehr als eine Sekunde betr√§gt, muss der Client die Verbindung trennen, um erneut eine Verbindung herzustellen.  Wir haben eine solche Puffergr√∂√üe aufgrund der Kosten des Koordinierungsprozesses im Falle einer Diskrepanz zwischen den Staaten der Welt.  Wenn der Unterschied zwischen dem Client und dem Server jedoch mehr als eine Sekunde betr√§gt, ist es billiger, eine vollst√§ndige Wiederverbindung mit dem Server durchzuf√ºhren. <br><br><h2>  Reduzierung der Verz√∂gerungszeit </h2><br>  Das obige Diagramm zeigt, dass das Daten√ºbertragungsschema im Spiel zwei Puffer enth√§lt: <br><br><ul><li>  Eingabepuffer auf dem Server; </li><li>  ein Puffer von Weltzust√§nden auf dem Client. </li></ul><br>  Der Zweck dieser Puffer ist der gleiche - Netzwerkspr√ºnge (Jitter) zu kompensieren.  Tatsache ist, dass die Paket√ºbertragung √ºber das Netzwerk ungleichm√§√üig ist.  Und da die Netzwerk-Engine mit einer festen Frequenz von 30 Hz arbeitet, m√ºssen der Engine Daten mit derselben Frequenz zugef√ºhrt werden.  Wir haben nicht die M√∂glichkeit, einige ms zu "warten", bis das n√§chste Paket den Empf√§nger erreicht.  Wir verwenden Puffer f√ºr Eingabedaten und Weltzust√§nde, um einen Zeitrahmen f√ºr die Jitterkompensation zu haben.  Wir verwenden den Gamestate-Puffer auch zur Interpolation, wenn eines der Pakete verloren geht. <br><br>  Zu Beginn des Spiels beginnt der Client erst dann mit der Synchronisierung mit dem Server, wenn er mehrere Weltzust√§nde vom Server empfangen hat und der Gamestate-Puffer voll ist.  Normalerweise betr√§gt die Gr√∂√üe dieses Puffers 3 Ticks (100 ms). <br><br>  Wenn der Client mit dem Server synchronisiert wird, wird er gleichzeitig vor der Serverzeit um den Wert des Eingabepuffers auf dem Server "ausgef√ºhrt".  Das hei√üt,  Der Client selbst steuert, wie weit er dem Server voraus ist.  Die Startgr√∂√üe des Eingabepuffers betr√§gt ebenfalls 3 Ticks (100 ms). <br><br>  Zun√§chst haben wir die Gr√∂√üe dieser Puffer als Konstanten implementiert.  Das hei√üt,  Unabh√§ngig davon, ob der Jitter tats√§chlich im Netzwerk vorhanden war oder nicht, gab es eine feste Verz√∂gerung von 200 ms (Eingabepuffergr√∂√üe + Spielstatuspuffergr√∂√üe) f√ºr die Aktualisierung der Daten.  Wenn wir den durchschnittlichen gesch√§tzten Ping auf Mobilger√§ten um 200 ms hinzuf√ºgen, betrug die tats√§chliche Verz√∂gerung zwischen der Verwendung der Eingabe auf dem Client und der Best√§tigung der Anwendung vom Server 400 ms! <br><br>  Das passte nicht zu uns. <br><br>  Tatsache ist, dass einige Systeme nur auf dem Server ausgef√ºhrt werden - beispielsweise die Berechnung der HP des Players.  Mit dieser Verz√∂gerung schie√üt der Spieler und sieht erst nach 400 ms, wie er den Gegner t√∂tet.  Wenn dies in Bewegung geschah, gelang es dem Spieler normalerweise, hinter die Mauer oder in Deckung zu rennen und dort bereits zu sterben.  Spieletests innerhalb des Teams haben gezeigt, dass eine solche Verz√∂gerung das gesamte Gameplay vollst√§ndig beeintr√§chtigt. <br><br>  Die L√∂sung f√ºr dieses Problem war die Implementierung dynamischer Gr√∂√üen von Eingabepuffern und Spielzust√§nden: <br><ul><li>  Bei einem Gamestate-Puffer kennt der Client immer den aktuellen Pufferinhalt.  Zum Zeitpunkt der Berechnung des n√§chsten Ticks pr√ºft der Client, wie viele Zust√§nde sich bereits im Puffer befinden. </li><li>  f√ºr den Eingabepuffer - Der Server hat zus√§tzlich zum Spielstatus begonnen, den Wert der aktuellen F√ºllung des Eingabepuffers f√ºr einen bestimmten Client an den Client zu senden.  Der Kunde analysiert wiederum diese beiden Werte. </li></ul><br>  Der Algorithmus zur Gr√∂√üen√§nderung des Gamestate-Puffers lautet ungef√§hr wie folgt: <br><br><ol><li>  Der Client ber√ºcksichtigt den Durchschnittswert der Puffergr√∂√üe √ºber einen Zeitraum und eine Varianz. </li><li>  Wenn die Varianz innerhalb normaler Grenzen liegt (d. H. F√ºr einen bestimmten Zeitraum gab es keine gro√üen Spr√ºnge beim F√ºllen und Lesen aus dem Puffer), √ºberpr√ºft der Client den Wert der durchschnittlichen Puffergr√∂√üe f√ºr diesen Zeitraum. </li><li>  Wenn die durchschnittliche Pufferf√ºllung gr√∂√üer als die obere Randbedingung war (dh der Puffer w√ºrde mehr als erforderlich gef√ºllt), ‚Äûreduziert‚Äú der Client die Puffergr√∂√üe durch Ausf√ºhren eines zus√§tzlichen Simulationsticks. </li><li>  Wenn die durchschnittliche Pufferf√ºllung geringer war als die untere Randbedingung (dh der Puffer hatte keine Zeit zum F√ºllen, bevor der Client mit dem Lesen begann), erh√∂ht der Client in diesem Fall die Puffergr√∂√üe, indem er einen Tick der Simulation √ºberspringt. </li><li>  In dem Fall, in dem die Varianz √ºber dem Normalwert lag, k√∂nnen wir uns nicht auf diese Daten verlassen, weil  Die Netzwerkst√∂√üe f√ºr einen bestimmten Zeitraum waren zu gro√ü.  Anschlie√üend verwirft der Client alle aktuellen Daten und beginnt erneut mit der Erfassung von Statistiken. </li></ol><br><h2>  Kompensation der Serververz√∂gerung </h2><br>  Aufgrund der Tatsache, dass der Client mit einer Verz√∂gerung (Verz√∂gerung) Weltaktualisierungen vom Server empf√§ngt, sieht der Spieler die Welt ein wenig anders als auf dem Server.  Der Spieler sieht sich in der Gegenwart und im Rest der Welt - in der Vergangenheit.  Auf dem Server existiert die ganze Welt auf einmal. <br><br><img src="https://habrastorage.org/webt/jo/ca/5d/joca5d_dhigvw1i9gjlpcd-tgqa.png"><br>  Aus diesem Grund schie√üt der Spieler lokal auf ein Ziel, das sich auf dem Server an einem anderen Ort befindet. <br><br>  Um die Verz√∂gerung auszugleichen, verwenden wir den Zeitr√ºcklauf auf dem Server.  Der Operationsalgorithmus ist ungef√§hr der folgende: <br><br><ol><li>  Der Client sendet mit jeder Eingabe zus√§tzlich die Tick-Zeit an den Server, in der er den Rest der Welt sieht. </li><li>  Der Server √ºberpr√ºft diese Zeit: ist die Differenz zwischen der aktuellen Zeit und der sichtbaren Zeit der Client-Welt im Konfidenzintervall. </li><li>  Wenn die Zeit g√ºltig ist, verl√§sst der Server den Spieler in der aktuellen Zeit und der Rest der Welt kehrt in den Zustand zur√ºck, in dem der Spieler das Ergebnis des Schusses gesehen und berechnet hat. </li><li>  Wenn ein Spieler trifft, wird der Schaden in der aktuellen Serverzeit verursacht. </li></ol><br>  Die R√ºckspulzeit auf einem Server funktioniert wie folgt: Die Geschichte der Welt (in ECS) und die Geschichte der Physik (unterst√ºtzt von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Volatile Physics</a> Engine) werden im Norden gespeichert.  Zum Zeitpunkt der Berechnung des Schusses wurden die Daten des Spielers aus dem aktuellen Zustand der Welt und die verbleibenden Spieler aus der Geschichte entnommen. <br><br><div class="spoiler">  <b class="spoiler_title">Der Code f√ºr das Schussvalidierungssystem sieht ungef√§hr so ‚Äã‚Äãaus:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shotPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Shot) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shot = shotPair.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooter = gs.WorldState[shotPair.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooterTransform = shooter.Transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weaponStats = gs.WorldState.WeaponStats[shot.WeaponId]; <span class="hljs-comment"><span class="hljs-comment">// DeltaTime shouldn't exceed physics history size var shootDeltaTime = (int) (gs.Time - shot.ShotPlayerWorldTime); if (shootDeltaTime &gt; PhysicsWorld.HistoryLength) { continue; } // Get the world at the time of shooting. var oldState = _immutableHistory.Get(shot.ShotPlayerWorldTime); var potentialTarget = oldState.WorldState[shot.Target.Id]; var hitTargetId = _singleShotValidator.ValidateTargetAvailabilityInLine(oldState, potentialTarget, shooter, shootDeltaTime, weaponStats.ShotDistance, shooter.Transform.Angle.GetDirection()); if (hitTargetId != 0) { gs.WorldState.CreateEntity().AddDamage(gs.WorldState[hitTargetId], shooter, weaponStats.ShotDamage); } } }</span></span></code> </pre> <br></div></div><br>  Ein wesentlicher Nachteil des Ansatzes besteht darin, dass wir dem Kunden die Daten zum Zeitpunkt des Ticks anvertrauen, den er sieht.  Potenziell kann ein Spieler einen Vorteil erzielen, indem er den Ping k√ºnstlich erh√∂ht.  Weil  Je mehr Ping ein Spieler hat, desto weiter schie√üt er in der Vergangenheit. <br><br><h2>  Einige Probleme, auf die wir gesto√üen sind </h2><br>  W√§hrend der Implementierung dieser Netzwerk-Engine sind wir auf viele Probleme gesto√üen, von denen einige einen separaten Artikel wert sind, aber hier werde ich nur einige davon ansprechen. <br><br><h4>  Simulation der ganzen Welt in einem Vorhersagesystem und Kopieren </h4><br>  Anfangs hatten alle Systeme in unserem ECS nur eine Methode: void Execute (GameState gs).  Bei dieser Methode wurden normalerweise Komponenten verarbeitet, die sich auf alle Spieler beziehen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel f√ºr ein Bewegungssystem in der ersten Implementierung:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[movementPair.Key]; transform.Position += movementPair.Value.Velocity * GameState.TickDuration; } } }</code> </pre> <br></div></div><br>  Im lokalen Spielervorhersagesystem mussten wir jedoch nur die Komponenten verarbeiten, die sich auf einen bestimmten Spieler beziehen.  Zun√§chst haben wir dies mit copy implementiert. <br><br>  Der Vorhersageprozess war wie folgt: <br><br><ol><li>  Eine Kopie des Spielstatus wurde erstellt. </li><li>  Eine Kopie wurde an den ECS-Eingang geliefert. </li><li>  In ECS gab es eine Simulation der ganzen Welt. </li><li>  Alle Daten, die sich auf den lokalen Spieler beziehen, wurden aus dem neu empfangenen Spielstatus kopiert. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Die Vorhersagemethode sah folgenderma√üen aus:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _tempGameState.Copy(state); _ecsExecutor.Execute(_tempGameState, input); _playerEntitiesCopier.Copy(_tempGameState, newState); }</code> </pre> <br></div></div><br>  Bei dieser Implementierung gab es zwei Probleme: <br><br><ol><li>  Weil  Wir verwenden Klassen, keine Strukturen - das Kopieren ist f√ºr uns eine ziemlich teure Operation (ca. 0,1-0,15 ms auf dem iPhone 5S). </li><li>  Die Simulation der ganzen Welt nimmt ebenfalls viel Zeit in Anspruch (ca. 1,5-2 ms auf dem iPhone 5S). </li></ol><br>  Wenn wir ber√ºcksichtigen, dass es w√§hrend des Koordinierungsprozesses notwendig ist, 5 bis 15 Weltstaaten in einem Rahmen neu zu berechnen, dann war bei einer solchen Implementierung alles furchtbar langsam. <br><br>  Die L√∂sung war ganz einfach: zu lernen, die Welt in Teilen zu simulieren, n√§mlich nur einen bestimmten Spieler zu simulieren.  Wir haben alle Systeme neu geschrieben, damit Sie die ID des Spielers √ºbertragen und nur ihn simulieren k√∂nnen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel f√ºr ein Bewegungssystem nach einer √Ñnderung:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { Move(gs.WorldState.Transform[movementPair.Key], movementPair.Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[playerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Move(gs.WorldState.Transform[playerId], movement); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform, Movement movement</span></span></span><span class="hljs-function">)</span></span> { transform.Position += movement.Velocity * GameState.TickDuration; } }</code> </pre> <br></div></div><br>  Nach den √Ñnderungen konnten wir unn√∂tige Kopien im Vorhersagesystem entfernen und die Belastung des Matching-Systems verringern. <br><br><div class="spoiler">  <b class="spoiler_title">Code:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _ecsExecutor.Execute(newState, input, playerId); }</code> </pre> <br></div></div><br><h4>  Erstellen und L√∂schen von Entit√§ten in einem Vorhersagesystem </h4><br>  In unserem System erfolgt der Abgleich von Entit√§ten auf dem Server und dem Client durch eine Ganzzahlkennung (ID).  F√ºr alle Entit√§ten verwenden wir die End-to-End-Nummerierung von Bezeichnern. Jede neue Entit√§t hat den Wert id = oldID + 1. <br><br>  Dieser Ansatz ist sehr praktisch zu implementieren, hat jedoch einen wesentlichen Nachteil: Die Reihenfolge der Erstellung neuer Entit√§ten auf dem Client und dem Server kann unterschiedlich sein, und infolgedessen unterscheiden sich die Kennungen der Entit√§ten. <br><br>  Dieses Problem trat auf, als wir ein System zur Vorhersage von Spielersch√ºssen implementierten.  Jeder Schuss bei uns ist eine separate Einheit mit der Schusskomponente.  F√ºr jeden Client war die ID der Schussentit√§ten im Vorhersagesystem sequentiell.  Wenn jedoch im selben Moment ein anderer Spieler schoss, unterschied sich auf dem Server die ID aller Sch√ºsse vom Client. <br><br>  Die Aufnahmen auf dem Server wurden in einer anderen Reihenfolge erstellt: <br><br><img src="https://habrastorage.org/webt/gl/dg/fy/gldgfykw7m30fuwspkra-xytgqe.png"><br><br>  Bei Sch√ºssen haben wir diese Einschr√§nkung umgangen, basierend auf den Gameplay-Funktionen des Spiels.  Sch√ºsse sind schnell lebende Wesen, die im Bruchteil einer Sekunde nach ihrer Erstellung im System zerst√∂rt werden.  Auf dem Client haben wir einen separaten Bereich von IDs hervorgehoben, die sich nicht mit Server-IDs √ºberschneiden und Aufnahmen im Koordinationssystem nicht mehr ber√ºcksichtigen.  Das hei√üt,  Die Sch√ºsse lokaler Spieler werden im Spiel immer nur gem√§√ü dem Vorhersagesystem gezogen und ber√ºcksichtigen nicht die Daten vom Server. <br><br>  Bei diesem Ansatz werden dem Spieler keine Artefakte auf dem Bildschirm angezeigt (L√∂schen, Neuerstellen, Zur√ºcksetzen von Aufnahmen), und die Diskrepanzen mit dem Server sind gering und wirken sich nicht auf das gesamte Gameplay aus. <br><br>  Diese Methode erm√∂glichte es, das Problem mit Aufnahmen zu l√∂sen, jedoch nicht das gesamte Problem der Erstellung von Entit√§ten auf dem gesamten Client.  Wir arbeiten noch an m√∂glichen Methoden, um den Vergleich der auf dem Client und dem Server erstellten Objekte zu l√∂sen. <br><br>  Es sollte auch beachtet werden, dass dieses Problem nur die Erstellung neuer Entit√§ten (mit neuen IDs) betrifft.  Das Hinzuf√ºgen und Entfernen von Komponenten zu bereits erstellten Entit√§ten erfolgt problemlos: Komponenten haben keine Bezeichner, und jede Entit√§t kann nur eine Komponente eines bestimmten Typs haben.  Daher erstellen wir normalerweise Entit√§ten auf dem Server und f√ºgen in Vorhersagesystemen nur Komponenten hinzu / entfernen diese. <br><br>  Abschlie√üend m√∂chte ich sagen, dass die Implementierung von Multiplayer nicht die einfachste und schnellste ist, aber es gibt viele Informationen dazu. <br><br><h2>  Was zu lesen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiplayer in schnellen Spielen</a> - √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fast-Paced Multiplayer (Teil I): Einf√ºhrung</a> (meiner Meinung nach ist dies der beste Artikel √ºber Netzwerkinteraktion in Spielen auf Habr√©). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDC Vault Overwatch Gameplay-Architektur und Netcode</a> - eine Vorlesung mit GDC 17 √ºber ECS und Netzwerkcode in Overwatch (der Zugriff ist leider kostenpflichtig). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDC Vault: 8 Frames in 16 ms: Rollback-Networking in Mortal Kombat und Injustice 2</a> - wie dies in Kampfspielen gemacht wird. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quell-Multiplayer-Netzwerk</a> - Wie funktioniert Multiplayer in Counter Strike? </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bei Gaffer on Games</a> geht es im Allgemeinen um Netzwerkcode in Spielen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP in Game Engines</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDC Vault: Ich habe dich zum ersten Mal beim Networking erschossen</a> - wie Multiplayer in Halo: Reach funktioniert. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415959/">https://habr.com/ru/post/de415959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415947/index.html">Fehlerkompensationssystem f√ºr die Installation von optischen Fasern w√§hrend der Verarbeitung durch Laserstrahlung w√§hrend der Rotation</a></li>
<li><a href="../de415949/index.html">High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem ‚Äû51% -Angriff‚Äú.</a></li>
<li><a href="../de415951/index.html">Mitap Sberbank und IBM auf HyperLedger Fabric</a></li>
<li><a href="../de415953/index.html">Wie blutiges Unternehmen Open Source gewinnt: der Kampf um BPMS</a></li>
<li><a href="../de415957/index.html">Wir brauchen mehr Rucks√§cke: Bobby XL von XD Design</a></li>
<li><a href="../de415961/index.html">Russischer verteilter Speicher. Wie es funktioniert</a></li>
<li><a href="../de415963/index.html">Naive Bayes oder wie Sie mit Mathematik Spam filtern k√∂nnen</a></li>
<li><a href="../de415965/index.html">Was im Juli zu lesen ist: 19 neue B√ºcher f√ºr Digitalprofis</a></li>
<li><a href="../de415967/index.html">SolidFire - Speicher f√ºr diejenigen, die Hassspeicher haben</a></li>
<li><a href="../de415969/index.html">HyperX Pulsefire Surge RGB - ein nat√ºrlich geborener Killer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>