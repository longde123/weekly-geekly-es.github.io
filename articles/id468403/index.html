<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔊 👇🏼 🐳 Kontrol runtime aplikasi perangkat lunak internal 🕋 🤾🏼 🦂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publikasi ini menyajikan implementasi perangkat lunak dari alat bawaan untuk mengumpulkan dan mengumpulkan informasi metrik pada runtime aplikasi yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontrol runtime aplikasi perangkat lunak internal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468403/"><img src="https://habrastorage.org/webt/k1/xf/-b/k1xf-b3txxrnnl3dlfn6htckrmm.jpeg" align="right" width="40%">  Publikasi ini menyajikan implementasi perangkat lunak dari alat bawaan untuk mengumpulkan dan mengumpulkan informasi metrik pada runtime aplikasi yang ditulis dalam C / C ++ / C #. <br><br>  Inti dari pendekatan yang dideskripsikan didasarkan pada dimasukkannya "titik kontrol" dalam kode program aplikasi untuk mengekstraksi data pada waktu eksekusi komponen struktural: metode, fungsi, dan blok {}.  Informasi metrik yang diekstrak diakumulasikan dalam basis data internal, yang isinya di akhir aplikasi dikonversi menjadi bentuk laporan teks yang disimpan dalam file.  Ketepatan menggunakan sarana kontrol bawaan waktu eksekusi adalah karena kebutuhan untuk mengidentifikasi area masalah kode, menganalisis penyebab degradasi sementara aplikasi: penuh atau sebagian, atau muncul pada set tertentu dari sumber data. <br><br>  Contoh kode sumber C ++ / C # yang diberikan menunjukkan kemungkinan implementasi dari pendekatan yang dijelaskan. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Pengembangan aplikasi perangkat lunak pada setiap iterasi (misalnya, rilis rilis berikutnya) pengembangan evolusionernya meliputi langkah-langkah dasar berikut: <br><br><ul><li>  pengembangan dan pengujian fungsionalitas; </li><li>  optimalisasi sumber daya RAM yang dikonsumsi; </li><li>  stabilisasi metrik runtime. </li></ul><br>  Langkah-langkah ini membutuhkan sejumlah besar pengembang tidak hanya kreatif (seperti pengembangan dan implementasi algoritma yang efektif, membangun arsitektur perangkat lunak yang fleksibel, dll), tetapi juga pekerjaan rutin.  Kategori yang terakhir mencakup kegiatan yang bertujuan untuk menstabilkan metrik waktu untuk eksekusi aplikasi.  Dalam banyak kasus, ini adalah prosedur yang agak menyakitkan ketika pengembang dihadapkan pada degradasi, yang merupakan konsekuensi dari perluasan fungsionalitas produk perangkat lunak, pembangunan kembali arsitektur perangkat lunak dan munculnya utas baru dalam aplikasi.  Pada saat yang sama, sumber-sumber degradasi memerlukan upaya tertentu untuk mendeteksinya, yang dicapai tidak hanya dengan tekun dan tanggung jawab pengembang yang tinggi (kondisi yang diperlukan), tetapi juga oleh komposisi alat yang digunakan untuk tujuan ini (kondisi yang memadai). <br><br>  Salah satu pendekatan yang efektif untuk memecahkan masalah menganalisis metrik waktu aplikasi adalah penggunaan produk perangkat lunak khusus, misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i><b>gprof</b></i></a> GNU.  Analisis laporan yang dihasilkan oleh alat-alat tersebut memungkinkan Anda untuk mengidentifikasi "hambatan" (metode dan fungsi kelas), yang merupakan jumlah waktu yang dihabiskan untuk menjalankan aplikasi secara keseluruhan.  Pada saat yang sama, validitas waktu yang dihabiskan untuk pelaksanaan metode dan prosedur tentu memenuhi syarat oleh pengembang. <br><br>  Perlu juga dicatat bahwa produk perangkat lunak dari kelas ini, sebagai suatu peraturan, melakukan analisis metrik dari waktu eksekusi kode program pada level metode kelas dan fungsi, mengabaikan level yang lebih rendah (namun tetap signifikan dari sudut pandang analisis masalah): <i>{...}, untuk, sementara, lakukan-sampai, jika - selain itu, coba-tangkap</i> blok, yang di dalamnya pengeluaran pengeluaran waktu eksekusi tidak kurang signifikan terjadi. <br><br>  Selanjutnya, konten utama dari salah satu solusi yang mungkin untuk penerapan alat kontrol runtime built-in yang ditujukan untuk mengekstraksi dan mengumpulkan informasi terperinci tentang metrik waktu dari blok perangkat lunak yang dikontrol dengan pembuatan laporan berikutnya untuk pengembang dipertimbangkan. <br><br><h3>  Metode untuk Mengambil Data Runtime </h3><br>  Fungsionalitas aplikasi perangkat lunak apa pun dapat diartikan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin abstrak</a> dengan seperangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">status</a> unik <b><i>{St}</i></b> dan transisi <b><i>{Tr} di</i></b> antaranya. <br><br>  Dalam kerangka pendekatan ini, setiap aliran eksekusi dalam aplikasi harus diinterpretasikan sebagai urutan urutan negara dan transisi di antara mereka.  Dalam hal ini, estimasi biaya waktu eksekusi dilakukan dengan menjumlahkan metrik waktu pada seluruh rangkaian negara yang disahkan dengan mengabaikan biaya transisi dari satu kondisi ke kondisi lainnya - sebagai nilai yang dapat diabaikan. <br><br>  Ekstraksi dan akumulasi data pada waktu eksekusi aplikasi pada titik kontrol yang ditentukan adalah tugas utama yang diselesaikan oleh alat kontrol bawaan yang dijelaskan di bawah ini. <br><br>  Untuk setiap breakpoint dideklarasikan dalam kode sumber dengan menempatkan <br>  <b>PROFILE_ENTRY</b> C ++ makro, jumlah pass-nya selama eksekusi aplikasi dicatat, serta metrik waktu - total waktu aplikasi berada dalam status dari saat checkpoint melewati ke level berikutnya dari hirarki program (termasuk blok, metode kelas, fungsi, dll.) seperti yang diilustrasikan dalam diagram di bawah ini. <br><br>  Kontrol titik kontrol (pendaftaran awal dan perhitungan metrik waktu mereka) dilakukan oleh objek <b><i>'timeManager'</i></b> , yang dibuat dalam satu instance.  Setiap peristiwa melewati pos pemeriksaan ditetapkan oleh objek <b><i>'timeManager',</i></b> dan selama pass pertama terdaftar olehnya sebagai diamati sebagai <b><i>'registerEntry'</i></b> . <br><br>  Pada saat setiap bagian dari titik kontrol, <b><i>timerObject</i></b> dibuat, menetapkan waktu pembuatannya.  Waktu eksekusi ditetapkan pada pos pemeriksaan ketika aplikasi keluar dari level hirarki perangkat lunak saat ini.  Pada saat ini, timerObject dari objek secara otomatis dihancurkan, yang disertai dengan perhitungan "seumur hidupnya" T. Sebagai hasilnya, <b><i>manajer waktu</i></b> meningkatkan jumlah kali melewati pos pemeriksaan dan waktu yang dihabiskan di dalamnya oleh <b><i>T.</i></b>  Untuk semua titik kontrol yang ditetapkan, <b><i>timeManager</i></b> mengumpulkan data dengan rilis laporan berikutnya saat aplikasi berakhir. <br><br><img src="https://habrastorage.org/webt/eq/ze/7e/eqze7eww_flgezgdi08ncstlz7m.jpeg"><br><br>  Di bawah ini adalah kode sumber C ++ yang mengimplementasikan alat bawaan untuk mengendalikan waktu eksekusi aplikasi. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     #include &lt;vector&gt; #include &lt;map&gt; #include &lt;algorithm&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; typedef unsigned long LONGEST_INT; // ,    //     //     //  ( )   // ()   //    #define PROFILER_ENABLED // CREATE_PROFILER  timeManager , //     // 'main()' #ifdef PROFILER_ENABLED #define CREATE_PROFILER timeManager tManager; #else #define CREATE_PROFILER //   CREATE_PROFILER. #endif //INITIALIZE_PROFILER    timeManager  //       //   'main()' #ifdef PROFILER_ENABLED #define INITIALIZE_PROFILER bool timeManager::object = false;\ std::vector&lt;registerEntry&gt; timeManager::entries; #else #define INITIALIZE_PROFILER //   INITIALIZE_PROFILER. #endif //DELAY(_SECONDS)   '_SECONDS' . //    ,  //     //  #ifdef PROFILER_ENABLED #define DELAY(_SECONDS) {clock_t clk_wait=clock()+((double)_ARG)*CLOCKS_PER_SEC;\ while(clock()&lt;clk_wait) {}} #else #define DELAY(_SECONDS) //    DELAY. #endif //     , //     UNIX  WINDOWS //      #ifdef PROFILER_ENABLED #define MERGE2(x,y) x##y #define MERGE1(_X,_Y) MERGE2(_X,_Y) #if WIN32 #define UNIQUENAME prefix,postfix) MERGE1(prefix,postfix) #else #define UNIQUENAME(prefix,postfix) MERGE2(prefix,postfix) #endif #define GEN_SRC(_ARG1,_ARG2) static int UNIQUENAME(ind,_ARG2)=-1;\ if(UNIQUENAME(ind,_ARG2)&lt;0)\ UNIQUENAME(ind,_ARG2)=timeManager::add_entry(_ARG1);\ timeManager::incr_counter(UNIQUENAME(ind,_ARG2));\ timerObject UNIQUENAME(tm,_ARG2)(UNIQUENAME(ind,_ARG2)); //PROFILE_ENTRY      #ifdef PROFILER_ENABLED #if WIN32 #define PROFILE_ENTRY(_TITLE) GEN_SRC(_TITLE,__COUNTER__) #else #define PROFILE_ENTRY(_TITLE) GEN_SRC(_TITLE,__LINE__) #endif #else #define PROFILE_ENTRY(_TITLE) //    PROFILE_ENTRY. #endif //        //    //    ,   timeManager struct registerEntry { //     (  ) std::string entry_name; //     //     LONGEST_INT covers_counter; //      //     (ticks) LONGEST_INT elapsed_time; // registerEntry(const char * title):entry_name(title), covers_counter(0), elapsed_time(0) {} }; //     class timerObject { //   ,     int index; //    clock_t start_time; public: //       timerObject(int ind):index(ind),start_time(clock()) {} //    “ ”  //       //   ~timerObject(void) { timeManager::incr_timer(index,(LONGEST_INT)(clock()-start_time)); } }; //     class timeManager { private: //     static std::vector&lt;registerEntry&gt; entries; // ,     //    static bool object; public: //     //  ,    //     static int add_entry(const char * title) { entries.push_back(registerEntry(title)); return (((int)entries.size())-1); } //       //      static void incr_counter(int profile_entry_id) { entries[profile_entry_id].covers_counter++; } //  'value'     //      static void incr_timer(int profile_entry_id, LONGEST_INT value) { entries[profile_entry_id].elapsed_time += val; } //       //   static void report(void); //  timeManager(void) { if(!object) object = true; else { printf("\n&lt;&lt;&gt;&gt;:    'timeManager' .\n"); throw; } } //        //   virtual ~timeManager(void) {report();} }; //      bool cmp_entries(registerEntry &amp; first, registerEntry &amp; second) { if(first.entry_name.compare(second.entry_name)&gt;0) return false; return true; } //      //    void timeManager::report(void) { const std::string bar(72,'*'); //        const char * REPORT_FILE = "C:\\tmProfile.txt"; FILE * fp = fopen(REPORT_FILE,"w"); if(!fp) { printf("\n&lt;&lt;&gt;&gt;:       (%s)",REPORT_FILE); return; } fprintf(fp,"\n#%s",bar.c_str()); fprintf(fp,"\n#\n#      "); fprintf(fp,"\n#\n#%s",bar.c_str()); fprintf(fp,"\n#\n# %-35s %-15s %-20s", " ",""," ()"); fprintf(fp,"\n# %-35s %-15s %-20s", "------------------","-------------","---------------\n#"); //         std::sort(entries.begin(),entries.end(),cmp_entries); for(unsigned jj = 0; jj&lt; entries.size(); jj++) { fprintf(fp,"\n# %-35s %-16d", entries[jj].entry_name.c_str(), entries[jj].covers_counter); if(entries[jj].covers_counter == 0) fprintf(fp,"%-20d",0); else fprintf(fp,"%-20.0f", static_cast&lt;double&gt;(entries[jj].elapsed_time)/ static_cast&lt;double&gt;(CLOCKS_PER_SEC)); } if(entries.size() == 0) fprintf(fp,"\n# No covered profile entries found\n"); fprintf(fp,"\n#\n#%s\n",bar.c_str()); fclose(fp); }</span></span></code> </pre> <br>  Struktur aplikasi demo diilustrasikan di bawah ini, mengilustrasikan penggunaan alat kontrol runtime built-in sebagai contoh, serta tabel hasil yang diperoleh (untuk detail, lihat <b><i>Lampiran 1. Kode sumber aplikasi demo</i></b> ). <br><br><img src="https://habrastorage.org/webt/bg/ds/cg/bgdscgwtg66sw9cdwo1kacjeryy.jpeg"><br><br><img src="https://habrastorage.org/webt/oi/sw/kk/oiswkkxofhegr5uokrld8ttpdmg.jpeg"><br><br>  Bagian <b><i>Adendum 2. Kode sumber alat kontrol bawaan untuk waktu eksekusi aplikasi C #</i></b> menyajikan implementasi yang serupa dari kontrol bawaan di C #. <br><br>  Penulis menggunakan pasangan <b>TimeWatcher.StartWatch ()</b> dan <b>TimeWatcher.StopWatch ()</b> ketika membuat profil waktu pelaksanaan metode dan prosedur yang melelahkan (dari sudut pandang komputasi) sebagai bagian dari produk perangkat lunak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Delta Design yang</b></a> dikembangkan oleh <b>EREMEX</b> - sistem desain berbantuan komputer untuk peralatan elektronik. <br><br>  Di bawah ini adalah contoh laporan singkat tentang metrik waktu dari salah satu fungsi produk yang disebutkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5_/ka/r-/5_kar-gqi4xmd2p9bfrtlqae3vc.jpeg"></div><br><h3>  Kesimpulan singkat </h3><br>  Alat yang dijelaskan dapat digunakan untuk mengumpulkan data tentang waktu eksekusi aplikasi di berbagai bagian kode programnya, khususnya, mereka memungkinkan: <br><br><ul><li>  mengumpulkan dan mengumpulkan data tentang metrik waktu utas eksekusi dalam aplikasi; </li><li>  melakukan perkiraan waktu pelaksanaan kode program yang akurat untuk konstruksi bahasa dasar; </li><li>  mengelola volume data yang diekstraksi dengan menghidupkan dan mematikan alat kontrol bawaan pada bagian yang sesuai dari aliran eksekusi aplikasi; </li><li>  mengembangkan dan menerapkan tes regresi yang memantau stabilitas (dan mendeteksi degradasi) dari metrik waktu aplikasi. </li></ul><br>  Sebagai kesimpulan, harus dicatat bahwa di luar ruang lingkup publikasi ini ada pertanyaan tentang penggunaan alat kontrol bawaan yang dijelaskan dalam konteks aplikasi <i>multithreading</i> dan tidak ada analisis keakuratan data yang diperoleh dengan metrik waktu disajikan dalam bentuk apa pun.  Yang terakhir ini disebabkan oleh kenyataan bahwa dalam praktiknya, ketika mengidentifikasi penyebab degradasi sementara suatu aplikasi, data pada <font color="blue"><b><i>distribusi relatif</i></b> <font color="black">dari biaya waktu eksekusi antara komponen perangkat lunak dari aplikasi tersebut</font></font> terutama relevan <font color="blue"><font color="black">.</font></font>  <font color="blue"><font color="black">Dalam hal ini, pertanyaan tentang keakuratan data yang diperoleh memudar ke latar belakang.</font></font> <font color="blue"><font color="black"><br><br></font></font> <h3>  <font color="blue"><font color="black">Lampiran 1. Kode sumber untuk aplikasi demo</font></font> </h3> <font color="blue"><font color="black"><br></font></font> <pre> <font color="blue"><font color="black"><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">INITIALIZE_PROFILER </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//create profile manager CREATE_PROFILER PROFILE_ENTRY("1 Main context") f11(); for(unsigned jj = 0;jj&lt;4;jj++) f12(); f13 (); f14 (); f15 (); f16 (); f17(); return 0; } void f11(void)///////////////////////////////////////// { PROFILE_ENTRY ("2 f11()........................") for (unsigned jj = 0; jj&lt;5; jj++) { PROFILE_ENTRY ("2 f11()::for(...){...} iterat-ing") DELAY(1) } //profile entry for repeating int nn(3); while(nn &gt; 0) { PROFILE_ENTRY("2 f11()::while(...){...} iterat-ing") DELAY(1) nn--; } } void f12(void)///////////////////////////////////////// { PROFILE_ENTRY("3 f12()........................") goto ending; { PROFILE_ENTRY("3 f12()::ignored code part") DELAY(1) } ending: PROFILE_ENTRY("3 f12()::ending code part") DELAY(2) } void f13(void) ///////////////////////////////////////// { PROFILE_ENTRY("4 f13()........................") srand((unsigned) time(NULL)/2); for(unsigned jj = 0; jj &lt; 200; jj++) { if(rand()%2 == 0) { PROFILE_ENTRY("4 f13()::even branch") DELAY(0.01) } else { PROFILE_ENTRY("4 f13()::od branch") DELAY(0.02) } } } void f14(void)///////////////////////////////////////// { static int depth = 10; { PROFILE_ENTRY("5 f14() recursion") depth--; DELAY(0.5) if(depth == 0) return; } f14(); } void f15(void)///////////////////////////////////////// { PROFILE_ENTRY("7 f15()........................") for(unsigned jj = 0; jj &lt; 10; jj++) { demo_class obj; obj.method1(); obj.method2(); obj.method3(); } } void f16(void)///////////////////////////////////////// { PROFILE_ENTRY("8 f16()........................") try { for(int jj = 10; jj &gt;= 0; jj--) { PROFILE_ENTRY("81 f16() try clause") DELAY(1) int rr = 200/jj; } } catch(...) { PROFILE_ENTRY("81 f16() catch clause") DELAY(2) return; } } void f17(void)///////////////////////////////////////// { PROFILE_ENTRY("9 f17()........................") f21(); f22(); f23(); f24(); f25(); } void f22(void)///////////////////////////////////////// { PROFILE_ENTRY("91 f22()........................") DELAY(1) f221(); f222(); f223(); } void f23(void) {PROFILE_ENTRY("91 f23()") DELAY(1) } void f24(void) {PROFILE_ENTRY("91 f24()") DELAY(1) } void f25(void) {PROFILE_ENTRY("91 f25()") DELAY(1) } void f221(void) {PROFILE_ENTRY("91 f221()") DELAY(3) } void f222(void) {PROFILE_ENTRY("91 f222()") DELAY(4) } void f223(void) {PROFILE_ENTRY("91 f223()") DELAY(5) }</span></span></code></font></font> </pre> <font color="blue"><font color="black"><br></font></font> <h3>  <font color="blue"><font color="black">Tambahan 2. Kode sumber aplikasi kontrol C # runtime bawaan</font></font> </h3> <font color="blue"><font color="black"><br></font></font> <pre> <font color="blue"><font color="black"><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; ///             /// &lt;/summary&gt; public class TimeWatcher { /// &lt;summary&gt; ///            /// &lt;/summary&gt; internal class TimeEntry { //     public Stopwatch timeWatch; //       public long elapsedTime; //  public TimeEntry() { timeWatch = new Stopwatch(); elapsedTime = 0; } } //       //    private static bool enableTimeWatcher = false; //            private static Dictionary&lt;string, TimeEntry&gt; entryDictionary = new Dictionary&lt;string, TimeEntry&gt;(); //         public static void StartWatch(string postfix = "") { if (!enableTimeWatcher) return; string entryName = GetCurrentMethod(); if (postfix != "") { entryName += postfix; } //    ,      //         if (!entryDictionary.ContainsKey(entryName)) { entryDictionary.Add(entryName, new TimeEntry()); entryDictionary[entryName].timeWatch.Start(); } else { if (entryDictionary[entryName].timeWatch.IsRunning) { throw new System.InvalidOperationException(":    '" + entryName + "'  ."); } else entryDictionary[entryName].timeWatch.Restart(); } } //        public static void StopWatch(string postfix = "") { if (!enableTimeWatcher) return; string entryName = GetCurrentMethod(); if (postfix != "") { entryName += postfix; } //    ,      if (!entryDictionary.ContainsKey(entryName)) { throw new System.InvalidOperationException(":     -    '" + entryName + "'."); } if (!entryDictionary[entryName].timeWatch.IsRunning) { throw new System.InvalidOperationException ":        '" + entryName + "'."); } entryDictionary[entryName].timeWatch.Stop(); entryDictionary[entryName].elapsedTime += entryDictionary[entryName].timeWatch.ElapsedMilliseconds; } //        //     public static void TimeWatchReport() { const string bar = "============================================="; if (!enableTimeWatcher) return; Console.WriteLine(""); Console.WriteLine(bar); Console.WriteLine("     (): "); Console.WriteLine(""); int maxLen = 0; foreach (var timeEntry in entryDictionary) { if(timeEntry.Key.Length &gt; maxLen) maxLen = timeEntry.Key.Length; } maxLen++; string strFormat = "{0," + maxLen + "} ... {1,-10}"; foreach (var timeEntry in entryDictionary) { Console.WriteLine(strFormat, timeEntry.Key, timeEntry.Value.elapsedTime); } Console.WriteLine(bar); Console.WriteLine(""); entryDictionary.Clear(); enableTimeWatcher = false; } //          //      /tmw    //   public static void InitTimeWatch() { if (Environment.GetCommandLineArgs().Any(v =&gt; v == "/tmw")) { if (entryDictionary.Count &gt; 0) { TimeWatchReport(); } entryDictionary.Clear(); enableTimeWatcher = true; } } //        private static string GetCurrentMethod() { StackTrace st = new StackTrace(); StackFrame sf = st.GetFrame(2); return sf.GetMethod().Name; } }</span></span></code></font></font> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468403/">https://habr.com/ru/post/id468403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468393/index.html">Dengan mikrokontroler yang baik dan waktu berlalu dengan cepat atau osiloskop akhir pekan</a></li>
<li><a href="../id468395/index.html">Pemantauan Keamanan Cloud. Bagian 2</a></li>
<li><a href="../id468397/index.html">Berita dari dunia OpenStreetMap No. 477 (09/03/2019 - 09.09.2019)</a></li>
<li><a href="../id468399/index.html">C / C ++. Cara menggunakan sumber daya aplikasi tertanam saat bekerja di GCC di Linux</a></li>
<li><a href="../id468401/index.html">Cara aman untuk bertukar JWT di ASP.NET Core + SPA</a></li>
<li><a href="../id468405/index.html">Dua browser masuk entah ke mana scrollbar ...</a></li>
<li><a href="../id468407/index.html">5G - teknologi yang cenderung memperlambat web</a></li>
<li><a href="../id468409/index.html">Pekerja Layanan dalam Klien Slack: Pada Percepatan Unduhan dan Mode Offline</a></li>
<li><a href="../id468411/index.html">Sebuah Cerita Tentang Memecahkan Masalah Kinerja Moment.js</a></li>
<li><a href="../id468413/index.html">Akselerasi instagram.com. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>