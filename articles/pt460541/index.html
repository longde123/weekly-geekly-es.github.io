<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé® üßëüèΩ‚Äçü§ù‚Äçüßëüèª üë®üèæ‚Äçüöí Procure contornos faciais em um milissegundo usando um conjunto de √°rvores de regress√£o üë®‚Äçüîß üë®üèª‚Äçüåæ üë®‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A tradu√ß√£o do artigo foi preparada para os alunos do curso "Matem√°tica para Ci√™ncia de Dados" 

 Anota√ß√£o 


 Este artigo discute a tarefa de encontra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Procure contornos faciais em um milissegundo usando um conjunto de √°rvores de regress√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/460541/"><p><img src="https://habrastorage.org/webt/eb/rn/3a/ebrn3a_ugfcxc9tuhkdmwgnrut8.png"></p><br><p>  <em>A tradu√ß√£o do artigo foi preparada para os alunos do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Matem√°tica para Ci√™ncia de Dados"</a></em> </p><br><hr><br><h1 id="annotaciya">  Anota√ß√£o </h1><br><p>  <em>Este artigo discute a tarefa de encontrar contornos faciais para uma √∫nica imagem.</em>  <em>Mostramos como o conjunto de √°rvores de regress√£o pode ser usado para prever a posi√ß√£o dos contornos faciais diretamente de um subconjunto disperso de intensidades de pixels, obtendo super desempenho em tempo real com previs√µes de alta qualidade.</em>  <em>Apresentamos uma estrutura geral baseada no aumento de gradiente para estudar um conjunto de √°rvores de regress√£o que otimiza a soma das perdas quadr√°ticas e, naturalmente, processa dados ausentes ou parcialmente marcados.</em>  <em>Mostraremos como o uso de distribui√ß√µes apropriadas que levam em considera√ß√£o a estrutura dos dados da imagem ajuda na sele√ß√£o eficiente de contornos.</em>  <em>V√°rias estrat√©gias de regulariza√ß√£o e sua import√¢ncia na luta contra a reciclagem tamb√©m est√£o sendo investigadas.</em>  <em>Al√©m disso, analisamos o efeito da quantidade de dados de treinamento na precis√£o das previs√µes e examinamos o efeito de aumentar os dados usando dados sintetizados.</em> <a name="habracut"></a></p><br><h1 id="1-vvedenie">  1. Introdu√ß√£o </h1><br><p>  Neste artigo, apresentamos um novo algoritmo que procura contornos faciais em milissegundos e obt√©m uma precis√£o superior ou compar√°vel aos m√©todos modernos em conjuntos de dados padr√£o.  O aumento da velocidade em compara√ß√£o aos m√©todos anteriores √© uma consequ√™ncia da identifica√ß√£o dos principais componentes dos algoritmos anteriores para a busca de contornos faciais e sua subsequente inclus√£o de forma otimizada na cascata de modelos de regress√£o com alta largura de banda, sintonizados com o aumento de gradiente. </p><br><p>  Demonstramos, como j√° fizemos antes [8, 2], que a busca por contornos faciais pode ser realizada usando uma cascata de modelos de regress√£o.  No nosso caso, cada modelo de regress√£o em cascata prediz efetivamente o formato da face com base na previs√£o inicial e a intensidade do conjunto esparso de pixels indexados em rela√ß√£o a essa previs√£o inicial.  Nosso trabalho se baseia em um grande n√∫mero de estudos realizados na √∫ltima d√©cada, que levaram a um progresso significativo na tarefa de encontrar contornos faciais [9, 4, 13, 7, 15, 1, 16, 18, 3, 6, 19].  Em particular, inclu√≠mos em nossos modelos de regress√£o sintonizados dois elementos-chave presentes em v√°rios algoritmos bem-sucedidos abaixo, e agora estamos detalhando esses elementos. </p><br><p><img src="https://habrastorage.org/webt/xe/fn/ux/xefnuxzvuozcmpu5xjzvwwm3kq4.png"></p><br><p>  <em>Figura 1. Resultados selecionados no conjunto de dados HELEN.</em>  <em>Para detectar 194 pontos-chave (pontos de refer√™ncia) na face em uma imagem em um milissegundo, √© utilizado um conjunto de √°rvores de regress√£o aleat√≥ria.</em> </p><br><p>  O primeiro gira em torno da indexa√ß√£o da intensidade de pixel em rela√ß√£o √† previs√£o atual do formato da face.  Os recursos distintos na representa√ß√£o vetorial da imagem da face podem variar bastante devido √† deforma√ß√£o da forma e devido a fatores interferentes como altera√ß√µes nas condi√ß√µes de ilumina√ß√£o.  Isso dificulta a previs√£o precisa da forma usando essas fun√ß√µes.  O dilema √© que precisamos de sinais confi√°veis ‚Äã‚Äãpara prever com precis√£o a forma e, por outro lado, precisamos de uma previs√£o precisa da forma para extrair sinais confi√°veis.  No trabalho anterior [4, 9, 5, 8], bem como neste trabalho, uma abordagem iterativa (cascata) √© usada para resolver esse problema.  Em vez de regredir os par√¢metros de forma com base nos recursos extra√≠dos no sistema de coordenadas da imagem global, a imagem √© convertida em um sistema de coordenadas normalizado com base na previs√£o de forma atual e, em seguida, s√£o extra√≠dos sinais para prever o vetor de atualiza√ß√£o dos par√¢metros de forma.  Esse processo geralmente √© repetido v√°rias vezes at√© a converg√™ncia. </p><br><p>  O segundo examina como lidar com a complexidade do problema de explica√ß√£o / previs√£o.  Durante o teste, o algoritmo de busca de contorno deve prever o formato da face - um vetor de alta dimens√£o que est√° em melhor concord√¢ncia com os dados da imagem e nosso modelo de formato.  O problema √© n√£o-convexo com muitas √≥timas locais.  Algoritmos de sucesso [4, 9] resolvem esse problema, assumindo que a forma prevista deve estar em um subespa√ßo linear que pode ser detectado, por exemplo, encontrando os principais componentes das formas de treinamento.  Essa suposi√ß√£o reduz significativamente o n√∫mero de poss√≠veis formul√°rios considerados durante a explica√ß√£o e pode ajudar a evitar √≥timos locais. </p><br><p>  Um trabalho recente [8, 11, 2] explora o fato de que certa classe de regressores √© garantida para criar previs√µes que se encontram no subespa√ßo linear definido pelas formas de aprendizado, e n√£o h√° necessidade de restri√ß√µes adicionais.  √â importante que nossos modelos de regress√£o tenham esses dois elementos. <br>  Esses dois fatores est√£o associados ao nosso treinamento efetivo no modelo de regress√£o.  Otimizamos a fun√ß√£o de perda correspondente e executamos a sele√ß√£o de recursos com base nos dados.  Em particular, treinamos cada regressor usando o aumento de gradiente [10] usando a fun√ß√£o de perda quadr√°tica, a mesma fun√ß√£o de perda que queremos minimizar durante o teste.  O conjunto de pixels esparsos usados ‚Äã‚Äãcomo entrada para o regressor √© selecionado usando uma combina√ß√£o do algoritmo de aumento de gradiente e a probabilidade a priori das dist√¢ncias entre pares de pixels de entrada.  Uma distribui√ß√£o a priori permite que o algoritmo de refor√ßo investigue eficientemente um grande n√∫mero de recursos relevantes.  O resultado √© uma cascata de regressores que podem localizar pontos de refer√™ncia faciais quando inicializados de frente. </p><br><p>  As principais contribui√ß√µes deste artigo s√£o: </p><br><ol><li>  Um novo m√©todo para encontrar contornos faciais, com base em um conjunto de √°rvores de regress√£o (√°rvores de decis√£o), que executa a sele√ß√£o de recursos invariantes do formul√°rio, minimizando a mesma fun√ß√£o de perda durante o treinamento que queremos minimizar durante o teste. </li><li>  Apresentamos uma extens√£o natural do nosso m√©todo que processa r√≥tulos ausentes ou indefinidos. </li><li>  S√£o apresentados resultados quantitativos e qualitativos, que confirmam que nosso m√©todo fornece previs√µes de alta qualidade, sendo muito mais eficazes que o melhor m√©todo anterior (Figura 1). </li><li>  √â analisada a influ√™ncia da quantidade de dados de treinamento, o uso de dados parcialmente rotulados e dados generalizados na qualidade das previs√µes. </li></ol><br><h1 id="2-metod">  2. M√©todo </h1><br><p>  Este artigo apresenta um algoritmo para avaliar com precis√£o a posi√ß√£o dos pontos de refer√™ncia faciais (pontos-chave) em termos de efici√™ncia computacional.  Como em trabalhos anteriores [8, 2], a cascata de regressores √© usada em nosso m√©todo.  No restante desta se√ß√£o, descrevemos os detalhes da forma dos componentes individuais da cascata e como conduzimos o treinamento. </p><br><h4 id="21-kaskad-regressorov">  2.1  Cascata de regress√£o </h4><br><p>  Primeiro, introduzimos alguma nota√ß√£o.  Vamos <img src="https://habrastorage.org/getpro/habr/post_images/96b/8a8/cd3/96b8a8cd39c5f39cf67191c499d17a36.svg">  , coordenadas y do i-√©simo marco da face na imagem I. Em seguida, o vetor <img src="https://habrastorage.org/getpro/habr/post_images/bd9/f10/315/bd9f10315460922e284cfe03581f1e91.svg">  denota as coordenadas de todas as faces p em I. Muitas vezes, neste artigo, chamamos o vetor S de forma.  N√≥s usamos <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  para indicar nossa classifica√ß√£o atual S. Cada regressor <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  (¬∑, ¬∑) Na cascata prev√™ o vetor de atualiza√ß√£o da imagem e <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  que √© adicionado √† avalia√ß√£o do formul√°rio atual <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  Para melhorar a classifica√ß√£o: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/813/e90/80c/813e9080c1daa94987bfd323fcf05d75.svg">  ) <em>(1)</em> </p><br><p>  O ponto chave da cascata √© que o regressor <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  faz suas previs√µes com base em atributos como intensidades de pixel calculados por I e indexados em rela√ß√£o √† estimativa de forma atual <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  .  Isso introduz algum tipo de invari√¢ncia geom√©trica no processo e, √† medida que voc√™ avan√ßa na cascata, pode ter mais certeza de que a localiza√ß√£o sem√¢ntica exata na face √© indexada.  Mais adiante, descreveremos como essa indexa√ß√£o √© realizada. </p><br><p>  Observe que a faixa de sa√≠da estendida pelo conjunto est√° garantida no subespa√ßo linear dos dados de treinamento se a estimativa inicial <img src="https://habrastorage.org/getpro/habr/post_images/f0d/6ae/457/f0d6ae4573955eb6abc901db0a68bc4a.svg">  pertence a este espa√ßo.  Portanto, n√£o precisamos introduzir restri√ß√µes adicionais nas previs√µes, o que simplifica bastante nosso m√©todo.  O formul√°rio inicial pode ser simplesmente selecionado como o meio dos dados de treinamento, centralizado e dimensionado de acordo com a sa√≠da da caixa delimitadora do detector de faces geral. </p><br><p>  Educar a todos <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  usamos o algoritmo de aumento de gradiente para √°rvores com a soma das perdas quadr√°ticas, conforme descrito em [10].  Agora, forneceremos detalhes detalhados desse processo. </p><br><h4 id="22-obuchenie-kazhdogo-regressora-v-kaskade">  2.2  Treinando cada regressor em cascata </h4><br><p>  Suponha que tenhamos dados de treinamento <img src="https://habrastorage.org/getpro/habr/post_images/a81/786/c9b/a81786c9b9d6dc27492f55b19afb5055.svg">  onde todo mundo <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg">  √© uma imagem de rosto e <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg">  seu vetor de forma.  Para descobrir a primeira fun√ß√£o de regress√£o <img src="https://habrastorage.org/getpro/habr/post_images/0ac/302/657/0ac302657b1d8e45efa7f7b9b2557268.svg">  na cascata, criamos a partir de nossos trig√™meos de dados de treinamento da imagem da face, a previs√£o inicial da forma e a etapa de atualiza√ß√£o da meta, ou seja, <img src="https://habrastorage.org/getpro/habr/post_images/6a1/450/b9e/6a1450b9ea40a582ec2794d9df7afd31.svg">  ) onde </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f29/a62/581/f29a625813ba6c6cd00aea30a8cfe019.svg">  <em>2)</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c3/a0d/468/6c3a0d468f609ada0672c0f473c589ec.svg">  <em>(3)</em> e </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/691/50d/5cf/69150d5cfe48125a51002916c28453e8.svg">  <em>4)</em> </p><br><p>  para i = 1, ..., N. </p><br><p>  Definimos o n√∫mero total desses trig√™meos como N = nR, onde R √© o n√∫mero de inicializa√ß√µes usadas na imagem Ii.  Cada previs√£o inicial de forma para a imagem √© selecionada igualmente <img src="https://habrastorage.org/getpro/habr/post_images/d1c/fb5/092/d1cfb5092f0e598893288582f2114b37.svg">  sem substitui√ß√£o. </p><br><p>  Com esses dados, treinamos a fun√ß√£o de regress√£o <img src="https://habrastorage.org/getpro/habr/post_images/bcb/830/694/bcb83069438bb8a2d3e1e51f76a276f4.svg">  (veja Algoritmo 1) usando o aumento gradiente de √°rvores com a soma das perdas quadr√°ticas.  O conjunto de trig√™meos de treinamento √© atualizado para fornecer dados de treinamento. <img src="https://habrastorage.org/getpro/habr/post_images/f56/e5c/4a8/f56e5c4a803f2c95ebe20dae215895cf.svg">  % 20) para o pr√≥ximo regressor <img src="https://habrastorage.org/getpro/habr/post_images/dc5/512/a85/dc5512a85c881619a2c05faa3c2a2806.svg">  na cascata, definindo (com t = 0). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/146/29d/692/14629d6922ca89d70fed70bbeb3287bd.svg">  % 20) <em>(5)</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/17d/8a5/44a/17d8a544a843aa72dc68d79ab9c2236d.svg">  <em>(6)</em> </p><br><p>  Esse processo √© repetido at√© que uma cascata de regressores T seja treinada. <img src="https://habrastorage.org/getpro/habr/post_images/ee6/6a5/503/ee66a5503085c7bbaa7a616585c4ae2e.svg">  que em combina√ß√£o fornecem um n√≠vel suficiente de precis√£o. </p><br><p>  Conforme indicado, cada regressor <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  aprende usando o algoritmo de aumento de √°rvore de gradiente.  Deve-se lembrar que a fun√ß√£o de perda quadr√°tica √© usada e os res√≠duos calculados no loop interno correspondem ao gradiente dessa fun√ß√£o de perda estimada em cada amostra de treinamento.  A formula√ß√£o do algoritmo inclui o par√¢metro de taxa de aprendizado 0 &lt;ŒΩ ‚â§ 1, tamb√©m conhecido como coeficiente de regulariza√ß√£o.  Definir ŒΩ &lt;1 ajuda a combater a reconfigura√ß√£o e geralmente leva a regressores que generalizam muito melhor do que aqueles treinados com ŒΩ = 1 [10]. </p><br><hr><br><p>  <strong>Algoritmo de Aprendizagem 1</strong> <strong><img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg"></strong>  <strong>em cascata</strong> </p><br><p>  Temos dados de treinamento <img src="https://habrastorage.org/getpro/habr/post_images/2d4/805/43a/2d480543a349544ead268291984b1e6a.svg">  e taxa de aprendizagem (coeficiente de regulariza√ß√£o) 0 &lt;ŒΩ &lt;1 </p><br><ol><li>  Inicializar <br><img src="https://habrastorage.org/getpro/habr/post_images/e54/d75/bae/e54d75bae7a82091f8d5c1f04a92cc22.svg"></li><li>  para k = 1, ..., K: <br>  a) definimos para i = 1, ..., <br><img src="https://habrastorage.org/getpro/habr/post_images/759/573/b03/759573b032b3bb95986dfe5d42d8e5d8.svg"><br>  b) Ajustamos a √°rvore de regress√£o ao alvo <img src="https://habrastorage.org/getpro/habr/post_images/683/2f3/54e/6832f354e8f4ecad8283cc1be6a6899a.svg">  com fun√ß√£o de regress√£o fraca <img src="https://habrastorage.org/getpro/habr/post_images/425/db2/33f/425db233f09794bfe60e62a49da89a98.svg">  . <br>  c) Atualiza√ß√£o <img src="https://habrastorage.org/getpro/habr/post_images/376/5d0/ac3/3765d0ac3de75d838ad520821c141c21.svg"></li><li>  Conclus√£o <br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/9c4/2b9/7c09c42b9cc35b3225f89435a9d4ce22.svg"></li></ol><br><hr><br><h4 id="23-drevovidnyy-regressor">  2.3  Regressor em √°rvore </h4><br><p>  No centro de cada fun√ß√£o de regress√£o rt est√£o os regressores do tipo √°rvore, adequados para alvos residuais durante o algoritmo de aumento de gradiente.  Agora, examinaremos os detalhes de implementa√ß√£o mais importantes para o treinamento de cada √°rvore de regress√£o. </p><br><h4 id="231-invariantnye-split-testy-formy">  2.3.1 Testes invari√°veis ‚Äã‚Äãde formul√°rios divididos </h4><br><p>  Em cada n√≥ de separa√ß√£o na √°rvore de regress√£o, tomamos uma decis√£o com base no valor limite da diferen√ßa entre as intensidades de dois pixels.  Os pixels usados ‚Äã‚Äãno teste est√£o nas posi√ß√µes u e v quando s√£o definidos no sistema de coordenadas da forma intermedi√°ria.  Para uma imagem de uma face com uma forma arbitr√°ria, gostar√≠amos de indexar pontos que tenham a mesma posi√ß√£o em rela√ß√£o √† sua forma que u e v, para a forma m√©dia.  Para fazer isso, antes de extrair os elementos, a imagem pode ser deformada na forma do meio, com base na estimativa da forma atual.  Como usamos apenas uma representa√ß√£o muito esparsa da imagem, √© muito mais eficiente deformar o arranjo de pontos do que toda a imagem.  Al√©m disso, uma aproxima√ß√£o aproximada da deforma√ß√£o pode ser feita usando apenas a transforma√ß√£o de similaridade global, al√©m dos deslocamentos locais, conforme proposto em [2]. </p><br><p>  Os detalhes exatos s√£o os seguintes.  Vamos <img src="https://habrastorage.org/getpro/habr/post_images/482/2f7/60f/4822f760fdf061f414f323d30d0c14cd.svg">  O √≠ndice do ponto de refer√™ncia na face, na forma do meio, √© o mais pr√≥ximo de u e define seu deslocamento de u como <img src="https://habrastorage.org/getpro/habr/post_images/0fa/bbb/f81/0fabbbf8125f80b9f31e3b5ce093bc3c.svg">  . </p><br><p>  Em seguida, para o formul√°rio Si definido na imagem <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg">  posi√ß√£o em <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg">  , que √© qualitativamente semelhante a u na imagem de forma m√©dia, √© definido como <br><img src="https://habrastorage.org/getpro/habr/post_images/e2d/e8d/0d4/e2de8d0d461e2ef6e76642d39a803b27.svg">  <em>(7)</em> </p><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg">  e <img src="https://habrastorage.org/getpro/habr/post_images/8f6/b4a/913/8f6b4a913e518f22483a28148144b54e.svg">  - matriz de escala e rota√ß√£o da transformada de similaridade que transforma <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg">  em <img src="https://habrastorage.org/getpro/habr/post_images/919/800/718/919800718f235e7487c36b01db6739e1.svg">  , forma do meio. </p><br><p>  Escala e rota√ß√£o minimizam </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cf0/581/e89/cf0581e890e027fcaf3327e3be6f194c.svg">  <em>(8)</em> </p><br><p>  a soma dos quadrados entre os pontos de refer√™ncia da forma do meio, <img src="https://habrastorage.org/getpro/habr/post_images/c73/942/e7f/c73942e7f47a9adb6091e024085fc1bb.svg">  e apontar urdidura. <img src="https://habrastorage.org/getpro/habr/post_images/b2d/a25/52e/b2da2552e44457f6bcbf5d1aab251267.svg">  definido da mesma forma. </p><br><p>  Formalmente, cada divis√£o √© uma solu√ß√£o que inclui 3 par√¢metros Œ∏ = (œÑ, u, v) e √© aplicada a cada exemplo de treinamento e teste como </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfe/6ee/9c7/bfe6ee9c7e9da21fb2b81caca3d8abad.svg">  <em>(9)</em> </p><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/ff8/c77/429/ff8c77429402ff15260663452a693e8d.svg">  e <img src="https://habrastorage.org/getpro/habr/post_images/b2d/a25/52e/b2da2552e44457f6bcbf5d1aab251267.svg">  s√£o determinados usando a matriz de escala e rota√ß√£o que melhor deforma <img src="https://habrastorage.org/getpro/habr/post_images/5ac/ad7/803/5acad7803f7a79cc10fa8c714205eeab.svg">  em <img src="https://habrastorage.org/getpro/habr/post_images/919/800/718/919800718f235e7487c36b01db6739e1.svg">  de acordo com a equa√ß√£o (7).  Na pr√°tica, tarefas e deslocamentos locais s√£o determinados na fase de treinamento.  O c√°lculo da transforma√ß√£o de similaridade, durante o teste da parte mais cara desse processo, √© realizado apenas uma vez em cada n√≠vel da cascata. </p><br><h4 id="232-vybor-uzlovyh-razbieniy">  2.3.2 Sele√ß√£o de parti√ß√µes nodais </h4><br><p>  Para cada √°rvore de regress√£o, aproximamos a fun√ß√£o b√°sica por uma fun√ß√£o linear por partes, onde um vetor constante √© adequado para cada n√≥ finito.  Para treinar a √°rvore de regress√£o, geramos aleatoriamente um conjunto de parti√ß√µes adequadas, ou seja, Œ∏, em cada n√≥.  Em seguida, selecionamos ansiosamente Œ∏ * desses candidatos, o que minimiza a soma do erro quadr√°tico.  Se Q √© um conjunto de √≠ndices de exemplos de treinamento em um n√≥, isso corresponde √† minimiza√ß√£o </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b2/8f1/e02/8b28f1e02ab50c802525c5ded6aaeeaf.svg">  <em>(10)</em> </p><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/fd5/fa1/737/fd5fa1737973ecd7a303b2862a32f8ec.svg">  - √≠ndices de exemplos que s√£o enviados para o n√≥ esquerdo devido √† decis√£o Œ∏, <img src="https://habrastorage.org/getpro/habr/post_images/ab1/ee0/4fb/ab1ee04fb1210c9352cc942823f6dcd1.svg">  √â o vetor de todos os res√≠duos calculados para a imagem <em>i</em> no algoritmo de aumento de gradiente e </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c7f/e61/cc7/c7fe61cc7d441d07443317d12fc860c4.svg">  para <img src="https://habrastorage.org/getpro/habr/post_images/e17/6e7/ece/e176e7ece99e70aeee6c4ffe2949bb2f.svg">  <em>(11)</em> </p><br><p>  A parti√ß√£o ideal pode ser encontrada com muita efici√™ncia, porque se transformarmos a equa√ß√£o (10) e omitir fatores independentes de Œ∏, podemos ver que </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/517/57c/a5c/51757ca5c227156f25de32c995a6c1eb.svg"></p><br><p>  Aqui s√≥ precisamos calcular <img src="https://habrastorage.org/getpro/habr/post_images/88d/4eb/4bb/88d4eb4bb69acbcbbbf4ad0e10098a80.svg">  ao avaliar v√°rios Œ∏'s, j√° que <img src="https://habrastorage.org/getpro/habr/post_images/ba2/1c8/eeb/ba21c8eeb00ef767cf6f5bd5297f986e.svg">  pode ser calculado a partir das metas m√©dias no n√≥ pai ¬µ e <img src="https://habrastorage.org/getpro/habr/post_images/88d/4eb/4bb/88d4eb4bb69acbcbbbf4ad0e10098a80.svg">  da seguinte maneira: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b0a/e76/10a/b0ae7610afe1aa13d10de797871193c6.svg"></p><br><h4 id="233-vybor-priznakov">  2.3.3 Sele√ß√£o de caracter√≠sticas </h4><br><p>  A solu√ß√£o em cada n√≥ √© baseada em um valor limite da diferen√ßa nos valores de intensidade em um par de pixels.  Este √© um teste bastante simples, mas √© muito mais eficaz que um valor limite com uma √∫nica intensidade, devido √† sua insensibilidade relativa √†s mudan√ßas na ilumina√ß√£o global.  Infelizmente, a desvantagem do uso de diferen√ßas de pixel √© que o n√∫mero de poss√≠veis candidatos √† separa√ß√£o (recurso) √© quadr√°tico em rela√ß√£o ao n√∫mero de pixels na imagem m√©dia.  Isso torna dif√≠cil encontrar bons Œ∏ sem procurar um n√∫mero muito grande deles.  No entanto, esse fator limitante pode ser um pouco enfraquecido, levando em considera√ß√£o a estrutura dos dados da imagem. </p><br><p>  Introduzimos a distribui√ß√£o exponencial </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f30/6b8/6c4/f306b86c47bfa440c1d1c716e3c9d6b8.svg">  <em>(12)</em> </p><br><p>  pela dist√¢ncia entre os pixels usados ‚Äã‚Äãna divis√£o para incentivar a sele√ß√£o de pares mais pr√≥ximos de pixels. </p><br><p>  Descobrimos que o uso dessa distribui√ß√£o simples reduz o erro de previs√£o para v√°rios conjuntos de dados de face.  A Figura 4 compara os recursos selecionados com e sem ele, em que o tamanho do conjunto de objetos nos dois casos √© definido como 20. </p><br><h1 id="24-obrabotka-propuschennyh-metok">  2.4  Manipula√ß√£o de tags ausentes </h1><br><p>  O problema da equa√ß√£o (10) pode ser facilmente estendido para lidar com o caso quando alguns pontos de refer√™ncia n√£o s√£o marcados em algumas imagens de treinamento (ou temos uma medida de incerteza para cada ponto de refer√™ncia).  Inserir vari√°vel <img src="https://habrastorage.org/getpro/habr/post_images/7e0/805/7ed/7e08057ed464a0c8c2af586f05a009aa.svg">  [0, 1] para cada imagem de treinamento <em>ie</em> cada marco <em>j</em> .  Instala√ß√£o <img src="https://habrastorage.org/getpro/habr/post_images/260/ce8/a6b/260ce8a6b696864e07aaa5de561923e6.svg">  um valor 0 indica que o marco <em>j</em> n√£o <em>est√°</em> marcado na <em>i-</em> √©sima imagem e uma configura√ß√£o 1 indica que est√° marcado.  Ent√£o a equa√ß√£o (10) pode ser representada da seguinte forma </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7e5/183/d89/7e5183d8955912640ff62a62fd8913de.svg"></p><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/07f/821/26e/07f82126e42fc56123ae1a571fcaac7b.svg">  - matriz diagonal com vetor <img src="https://habrastorage.org/getpro/habr/post_images/a77/988/515/a779885154cabacbcccfb17d823fd818.svg">  na diagonal e </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/975/451/7a79754517a719b74cff33c43743171f.svg">  para <img src="https://habrastorage.org/getpro/habr/post_images/e17/6e7/ece/e176e7ece99e70aeee6c4ffe2949bb2f.svg">  <em>(13)</em> </p><br><p>  O algoritmo de aumento de gradiente tamb√©m deve ser modificado para levar em considera√ß√£o esses pesos.  Isso pode ser feito simplesmente inicializando o modelo de conjunto com o valor m√©dio ponderado dos alvos e ajustando as √°rvores de regress√£o aos res√≠duos ponderados no algoritmo 1 da seguinte maneira </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/396/468/7a9/3964687a9c8c905316ef8d6b69d73888.svg">  <em>(14)</em> </p><br><h1 id="3-eksperimenty">  3. Experi√™ncias </h1><br><p>  <strong>Bases:</strong> para avaliar com precis√£o o desempenho do nosso m√©todo proposto, conjunto de √°rvores de regress√£o (ERT), criamos mais duas bases.  O primeiro √© baseado em samambaias aleat√≥rias (samambaias aleat√≥rias) com uma sele√ß√£o aleat√≥ria de caracter√≠sticas (EF), e a outra √© uma vers√£o mais avan√ßada dessa abordagem com a sele√ß√£o de caracter√≠sticas baseadas na correla√ß√£o (EF + CB), que √© a nossa nova implementa√ß√£o [2].  Todos os par√¢metros s√£o fixos para as tr√™s abordagens. </p><br><p>  A EF usa a implementa√ß√£o direta de samambaias aleat√≥rias como regressores fracos no conjunto e √© a mais r√°pida para o treinamento.  Utilizamos o mesmo m√©todo de regulariza√ß√£o sugerido em [2] para regulariza√ß√£o de samambaias. </p><br><p>  O EF + CB usa um m√©todo de sele√ß√£o de objetos baseado em correla√ß√£o que projeta valores de sa√≠da, <img src="https://habrastorage.org/getpro/habr/post_images/ab1/ee0/4fb/ab1ee04fb1210c9352cc942823f6dcd1.svg">  , para uma dire√ß√£o aleat√≥ria we seleciona pares de sinais (u, v) para os quais <img src="https://habrastorage.org/getpro/habr/post_images/dcf/e8f/3cc/dcfe8f3ccb1ca1095fc35db5b623abc0.svg">  tem a maior correla√ß√£o de amostra para dados de treinamento com metas previstas <img src="https://habrastorage.org/getpro/habr/post_images/b63/418/2d8/b634182d884088b10405bc691e479fd8.svg">  . </p><br><p>  <strong>Par√¢metros</strong> <br>  Salvo indica√ß√£o em contr√°rio, todas as experi√™ncias s√£o realizadas com as seguintes configura√ß√µes de par√¢metros fixos.  O n√∫mero de regressores fortes rt na cascata √© T = 10, e cada <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  consiste em K = 500 regressores fracos <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">  .  Profundidade das √°rvores (ou samambaias) usadas para representar <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">  , defina igual a F = 5. Em cada n√≠vel da cascata, P = 400 pixels s√£o selecionados na imagem.  Para treinar regressores fracos, selecionamos aleatoriamente um par desses pixels P de acordo com nossa distribui√ß√£o e selecionamos um limite aleat√≥rio para criar uma separa√ß√£o de potencial, conforme descrito na equa√ß√£o (9).  A melhor separa√ß√£o √© obtida repetindo esse processo S = 20 vezes e escolhendo aquele que otimiza nosso objetivo.        ,   R = 20      . </p><br><p><img src="https://habrastorage.org/webt/7j/we/fs/7jwefsr7puidwxuehw6owexel8k.png"></p><br><p> <em> 2.       ,             Viola &amp; Jones [17].        .</em> </p><br><p> <strong></strong> <br>          O (TKF).          O (NDTKF S),  N ‚Äî   ,  D ‚Äî  .                HELEN [12],           . </p><br><p> <strong> </strong> <br>   ,   ,      HELEN [12], ,   ,      .    2330 ,     194 .      2000    ,    . </p><br><p>           LFPW [1],    1432 .  ,     778    216   ,         ,      . </p><br><p>  <strong>Compara√ß√£o</strong> <br>  1         .                  (Active Shape Models) ‚Äî STASM [14]  CompASM [12]. </p><br><p><img src="https://habrastorage.org/webt/89/fk/kc/89fkkczbo119vyy4oo7hhu7cmno.png"></p><br><p> <em> 1.        HELEN.  ‚Äî          .       .      ,        .    ,       .              .</em> </p><br><p>   ,    ,        .   3       ,  ,  ERT     ,   .  ,        EF + CB     .  ,      EF + CB       ,     . </p><br><p>          LFPW [1] ( 2).    EF + CB     ,   [2]. (     ,        .)              ,      ,     . </p><br><p><img src="https://habrastorage.org/webt/ef/uu/nz/efuunznz_ljfv_sr1v1vi5fujoy.png"></p><br><p> <em> 2.        LFPW.       1.</em> </p><br><p> <strong> </strong> <br>  4     (12)       ,   ,      .  Œª               0,1   .            <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">         .  4          . </p><br><p><img src="https://habrastorage.org/webt/do/pm/v4/dopmv4u-mj6pa5tcaioawlcvegs.png"></p><br><p> <em> 3.           .         ,  , .  (12).</em> </p><br><p> <strong></strong> <br>        ,   .     ,     .    ‚Äî .        ŒΩ      1 (   ŒΩ = 0.1).           .  , <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">   ,    ,    ŒΩ = 1.                   (10   )   . (      .) </p><br><p><img src="https://habrastorage.org/webt/lp/hv/hv/lphvhvclakdn02mzwrfe5rtt28w.png"></p><br><p> <em> 3.       HELEN (a)  LFPW (b). EF ‚Äî    ,  EF + CB ‚Äî      ,   .          (5  10),    [2].  ,      (ERT),     ,     ,             .</em> </p><br><p><img src="https://habrastorage.org/webt/xm/3y/pp/xm3yppxdejbgcglidfb-ecofaza.png"></p><br><p> <em> 4.   ,    .       ,      .</em> </p><br><p>             ,   .         ,    . </p><br><p><img src="https://habrastorage.org/webt/0r/hv/l0/0rhvl0mowqozwdscxpkc-lp-w7e.png"></p><br><p> <em> 4.      HELEN     .                .</em> </p><br><p>    ,          .   ,        ,    ,        ,       . </p><br><p> <strong></strong> <br>                 .              .  5          .    ,    ,      [8, 2] (           10 √ó 400 .) </p><br><p><img src="https://habrastorage.org/webt/rt/sa/n3/rtsan3fkhl6houggpnk8zyiwqie.png"></p><br><p> <em> 5.             .</em> </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dados de treinamento</font></font></strong> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para testar a efic√°cia de nosso m√©todo em termos de n√∫mero de imagens de treinamento, treinamos v√°rios modelos de diferentes subconjuntos de dados de treinamento. </font><font style="vertical-align: inherit;">A Tabela 6 resume os resultados finais e a Figura 5 mostra um gr√°fico de erros em cada n√≠vel da cascata. </font><font style="vertical-align: inherit;">Usar muitos n√≠veis de regressores √© mais √∫til quando temos um grande n√∫mero de exemplos de treinamento.</font></font></p><br><p> Repetimos as mesmas experi√™ncias com um n√∫mero total fixo de exemplos estendidos, mas alteramos a combina√ß√£o dos formul√°rios iniciais usados ‚Äã‚Äãpara criar o exemplo de treinamento a partir de um exemplo marcado da face e de um n√∫mero de imagens anotadas usadas para estudar a cascata (Tabela 7). </p><br><p><img src="https://habrastorage.org/webt/8p/-8/bb/8p-8bbob2qvordp1hhebxruts38.png"></p><br><p>  <em>Tabela 6. A taxa de erro final para o n√∫mero de exemplos de treinamento.</em>  <em>Ao criar dados de treinamento para o estudo de regressores em cascata, cada imagem de face etiquetada gerou 20 exemplos de treinamento, usando 20 faces etiquetadas diferentes como uma suposi√ß√£o inicial sobre o formato da face.</em> </p><br><p><img src="https://habrastorage.org/webt/0o/ft/7s/0oft7ss-mbxhjnln3wje3hqzxau.png"></p><br><p>  <em>Figura 5. O erro m√©dio em cada n√≠vel da cascata √© apresentado dependendo do n√∫mero de exemplos de treinamento usados.</em>  <em>O uso de muitos n√≠veis de regressores √© mais √∫til quando o n√∫mero de exemplos de treinamento √© grande.</em> </p><br><p><img src="https://habrastorage.org/webt/am/mj/aq/ammjaqyvpgnzjynmk0ychb7lnw8.png"></p><br><p>  <em>Tabela 7. Aqui, o n√∫mero efetivo de exemplos de treinamento √© fixo, mas usamos v√°rias combina√ß√µes do n√∫mero de imagens de treinamento e o n√∫mero de formul√°rios iniciais usados ‚Äã‚Äãpara cada imagem de rosto marcada.</em> </p><br><p>  Aumentar os dados de treinamento usando uma variedade de formul√°rios iniciais expande o conjunto de dados em termos de formul√°rio.  Nossos resultados mostram que esse tipo de suplemento n√£o compensa completamente a aus√™ncia de imagens de treinamento anotadas.  Embora a taxa de melhoria obtida pelo aumento do n√∫mero de imagens de treinamento esteja diminuindo rapidamente ap√≥s as primeiras centenas de imagens. </p><br><p>  <strong>Anota√ß√µes parciais</strong> <br>  A Tabela 8 mostra os resultados do uso de dados parcialmente anotados.  200 estudos de caso s√£o anotados completamente, e o restante apenas parcialmente. </p><br><p><img src="https://habrastorage.org/webt/iu/j9/7q/iuj97qa3-awn35lf8z3yibbuzhw.png"></p><br><p>  <em>Tabela 8. Resultados usando dados parcialmente rotulados.</em>  <em>200 exemplos s√£o sempre completamente anotados.</em>  <em>Os valores entre par√™nteses indicam a porcentagem de pontos de refer√™ncia observados.</em> </p><br><p>  Os resultados mostram que podemos obter melhorias significativas usando dados parcialmente rotulados.  No entanto, a melhoria exibida pode n√£o estar saturada, porque sabemos que o tamanho da base dos par√¢metros de forma √© muito menor que o tamanho dos pontos de refer√™ncia (194 √ó 2).  Conseq√ºentemente, existe o potencial de melhorias mais significativas com marcas parciais, se voc√™ usar explicitamente a correla√ß√£o entre a posi√ß√£o dos pontos de refer√™ncia.  Observe que o procedimento de aumento de gradiente descrito neste artigo n√£o usa correla√ß√£o entre pontos de refer√™ncia.  Esse problema pode ser resolvido em trabalhos futuros. </p><br><h1 id="4-vyvod">  4. Conclus√£o </h1><br><p>  Descrevemos como um conjunto de √°rvores de regress√£o pode ser usado para regredir a localiza√ß√£o dos pontos de refer√™ncia faciais a partir de um subconjunto disperso de valores de intensidade extra√≠dos da imagem de entrada.  A estrutura apresentada reduz o erro mais rapidamente do que o trabalho anterior e tamb√©m pode processar marcas parciais ou indefinidas.  Embora os principais componentes de nosso algoritmo considerem v√°rias medidas de destino como vari√°veis ‚Äã‚Äãindependentes, a continua√ß√£o natural deste trabalho ser√° o uso da correla√ß√£o de par√¢metros de forma para um treinamento mais eficaz e melhor uso de r√≥tulos parciais. </p><br><p><img src="https://habrastorage.org/webt/am/cu/xs/amcuxsbdkp6du3rohxpnoey0r2q.png"></p><br><p>  <em>Figura 6. Resultados finais no banco de dados HELEN.</em> </p><br><p>  <strong>Agradecimentos</strong> <br>  Este trabalho foi financiado pela Swedish Strategic Research Foundation como parte do projeto VINST. </p><br><h1 id="ispolzovannaya-literatura">  Literatura usada </h1><br><p>  [1] PN Belhumeur, DW Jacobs, DJ Kriegman e N. Kumar.  Localizando partes das faces usando um consenso de exemplos.  No CVPR, p√°ginas 545‚Äì552, 2011. 1, 5 <br>  [2] X. Cao, Y. Wei, F. Wen e J. Sun.  Alinhamento da face por regress√£o expl√≠cita da forma.  No CVPR, p√°ginas 2887‚Äì2894, 2012. 1, 2, 3, 4, 5, 6 <br>  [3] TF Cootes, M. Ionita, C. Lindner e P. Sauer.  Ajuste de modelo de forma robusto e preciso usando vota√ß√£o por regress√£o aleat√≥ria da floresta.  No ECCV, 2012.1 <br>  [4] TF Cootes, CJ Taylor, DH Cooper e J. Graham.  Modelos de formas ativas - seu treinamento e aplica√ß√£o.  Computer Vision and Image Understanding, 61 (1): 38‚Äì59, 1995.1, 2 <br>  [5] D. Cristinacce e TF Cootes.  Modelos de forma ativa de regress√£o refor√ßada.  Na BMVC, p√°ginas 79.1‚Äì79.10, 2007.1 <br>  [6] M. Dantone, J. Gall, G. Fanelli e LV Gool.  Detec√ß√£o de recursos faciais em tempo real usando florestas de regress√£o condicional.  No CVPR, 2012.1 <br>  [7] L. Ding e AM Mart√≠nez.  Detec√ß√£o precisa e precisa de rostos e caracter√≠sticas faciais.  No CVPR, 2008.1 <br>  [8] P. Dollar, P. Welinder e P. Perona.  Regress√£o em pose em cascata.  No CVPR, p√°ginas 1078-1085, 2010. 1, 2, 6 <br>  [9] GJ Edwards, TF Cootes e CJ Taylor.  Avan√ßos nos modelos de apar√™ncia ativa.  No ICCV, p√°ginas 137-142, 1999. 1, 2 <br>  [10] T. Hastie, R. Tibshirani e JH Friedman.  Os elementos do aprendizado estat√≠stico: minera√ß√£o de dados, infer√™ncia e previs√£o.  Nova York: Springer-Verlag, 2001.2,3 <br>  [11] V. Kazemi e J. Sullivan.  Alinhamento da face com modelagem baseada em pe√ßas.  Na BMVC, p√°ginas 27.1‚Äì27.10, 2011.2 <br>  [12] V. Le, J. Brandt, Z. Lin, LD Bourdev e TS Huang.  Localiza√ß√£o interativa de recursos faciais.  Em [13] L. Liang, R. Xiao, F. Wen e J. Sun.  Alinhamento de rosto por meio de pesquisa discriminativa baseada em componentes.  No ECCV, p√°ginas 72‚Äì85, 2008. 1ECCV, p√°ginas 679‚Äì 692, 2012.5 <br>  [14] S. Milborrow e F. Nicolls.  Localizando recursos faciais com um modelo de formato ativo estendido.  No ECCV, p√°ginas 504-513, 2008.5 <br>  [15] J. Saragih, S. Lucey e J. Cohn.  Ajuste de modelo deform√°vel por meio de marca√ß√µes regulares de refer√™ncia.  International Journal of Computer Vision, 91: 200‚Äì215, 2010.1 <br>  [16] BM Smith e L. Zhang.  Alinhamento de face de junta com modelos de formato n√£o param√©tricos.  No ECCV, p√°ginas 43‚Äì56, 2012.1 <br>  [17] PA Viola e MJ Jones.  Detec√ß√£o de rosto robusta em tempo real.  No ICCV, p√°gina 747, 2001.5 <br>  [18] X. Zhao, X. Chai e S. Shan.  Alinhamento da face da junta: Resgate alinhamentos ruins com os bons, mediante reajustamento regular.  No ECCV, 2012.1 <br>  [19] X. Zhu e D. Ramanan.  Detec√ß√£o de rosto, estimativa de pose e localiza√ß√£o de marcos na natureza.  No CVPR, p√°ginas 2879‚Äì2886, 2012.1 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460541/">https://habr.com/ru/post/pt460541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460531/index.html">Pervers√µes curiosas do mundo da TI - 5</a></li>
<li><a href="../pt460533/index.html">Voc√™ teve a ideia de um produto de TI, o que vem a seguir</a></li>
<li><a href="../pt460535/index.html">Criando um cont√™iner Docker m√≠nimo para aplicativos Go</a></li>
<li><a href="../pt460537/index.html">ZuriHac: praticando programa√ß√£o funcional</a></li>
<li><a href="../pt460539/index.html">Tratamento de erros no Vue</a></li>
<li><a href="../pt460543/index.html">Novas certifica√ß√µes para desenvolvedores da Cisco. Vis√£o geral da certifica√ß√£o do setor</a></li>
<li><a href="../pt460547/index.html">Antiguidades: Psion 5MX e Vida Aposentada</a></li>
<li><a href="../pt460551/index.html">Portugal As melhores praias e mil startups por ano</a></li>
<li><a href="../pt460553/index.html">Tecnologia, terceiriza√ß√£o e mentalidade: como implementamos o Microsoft Dynamics 365 no escrit√≥rio alem√£o da Lamoda</a></li>
<li><a href="../pt460555/index.html">Relat√≥rio do PyDaCon meetup no Mail.ru Group, 22 de junho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>