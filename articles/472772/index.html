<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬇️ 🎴 🚴🏼 Busque incidentes y reclamos similares. Métricas y Optimización 👔 🤾🏻 🤲🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un artículo anterior, hablé sobre nuestro motor de búsqueda para aplicaciones similares . Después de su lanzamiento, comenzamos a recibir las prime...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Busque incidentes y reclamos similares. Métricas y Optimización</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472772/"><p>  En un artículo anterior, hablé sobre nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de búsqueda para aplicaciones similares</a> .  Después de su lanzamiento, comenzamos a recibir las primeras críticas.  A los analistas les gustaron y recomendaron algunas recomendaciones, otras no. </p><br><p>  Para seguir adelante y encontrar mejores modelos, fue necesario evaluar primero el rendimiento del modelo actual.  También fue necesario seleccionar criterios por los cuales los dos modelos pudieran compararse entre sí. </p><br><p>  Debajo del corte, hablaré sobre: </p><br><ul><li>  Recopilación de comentarios sobre las recomendaciones </li><li>  Desarrollo de métricas para evaluar la calidad de las recomendaciones. </li><li>  construyendo un ciclo de optimización del modelo </li><li>  recibió ideas y un nuevo modelo </li></ul><a name="habracut"></a><br><h2 id="sbor-otzyvov">  Recolección de comentarios </h2><br><p>  Sería ideal recopilar comentarios explícitos de los analistas: qué tan relevante es la recomendación de cada uno de los incidentes propuestos.  Esto nos permitirá comprender la situación actual y continuar mejorando el sistema basado en indicadores cuantitativos. </p><br><p>  Se decidió recopilar reseñas en un formato extremadamente simple: </p><br><ul><li>  número de incidentes que estamos analizando </li><li>  número de incidente recomendado </li><li>  revisión de recomendaciones: bueno / malo </li></ul><br><p>  El "voto" (un pequeño proyecto que aceptaba solicitudes GET con parámetros y colocaba la información en un archivo) se colocó directamente en el bloque de recomendaciones para que los analistas pudieran dejar sus comentarios de inmediato simplemente haciendo clic en uno de los enlaces: "bueno" o "malo". </p><br><p>  Además, para una revisión retrospectiva de la recomendación, se hizo una solución muy simple: </p><br><ul><li>  para una gran porción de datos históricos, se lanzó un modelo; </li><li>  Las recomendaciones recopiladas se presentaron en forma de varios archivos HTML independientes, en los que se utilizó la misma "votación"; </li><li>  Se entregaron archivos preparados a los analistas para ver los resultados de 50-100 incidentes. </li></ul><br><p>  Por lo tanto, fue posible recopilar datos sobre aproximadamente 4000+ pares de recomendación de incidentes. </p><br><h2 id="pervichnyy-analiz-otzyvov">  Análisis de revisión inicial </h2><br><p>  Las métricas iniciales fueron "más o menos": la proporción de recomendaciones "buenas", según los colegas, fue de solo alrededor del 25%. </p><br><p>  Los principales problemas del primer modelo: </p><br><ol><li>  los incidentes sobre "nuevos" problemas recibieron recomendaciones irrelevantes del sistema;  Resultó que en ausencia de coincidencias en el contenido de la apelación, el sistema seleccionó incidentes cerca del departamento del empleado en contacto. </li><li>  Las recomendaciones para un incidente en un sistema afectaron incidentes de otros sistemas.  Las palabras utilizadas en la apelación fueron similares, pero describieron los problemas de otros sistemas y fueron diferentes. </li></ol><br><p>  Se seleccionaron posibles formas de mejorar la calidad de las recomendaciones: </p><br><ul><li>  ajuste de la composición y el peso de los atributos de tratamiento que se incluyen en el vector final </li><li> selección de configuraciones de vectorización <code>TfidfVectorizer</code> </li><li>  selección de las recomendaciones de distancia de "corte" </li></ul><br><h2 id="vyrabotka-kriteriev-kachestva-i-metodiki-ocenki">  Desarrollo de criterios de calidad y métodos de evaluación. </h2><br><p>  Para buscar una versión mejorada del modelo, es necesario determinar el principio de evaluar la calidad de los resultados del modelo.  Esto le permitirá comparar cuantitativamente los dos modelos y elegir el mejor. </p><br><h3 id="chto-mozhno-poluchit-iz-sobrannyh-otzyvov">  Lo que se puede obtener de las revisiones recopiladas </h3><br><p>  Tenemos muchas <strong>m</strong> tuplas de la forma: "Incidente", "Incidente recomendado", "Evaluación de recomendación". </p><br><ul><li>  "Clasificación de recomendación" ( <strong>v</strong> ) - se establece en binario: "Bueno" |  Pobre (1 / -1); </li><li>  "Incidente" e "Incidente recomendado" son simplemente números de incidentes.  En ellos puedes encontrar el incidente en la base de datos. </li></ul><br><p>  Teniendo tales datos, puede calcular: </p><br><ul><li>  <code>n_inc_total</code> - El número total de incidentes para los cuales hay recomendaciones </li><li>  <code>n_inc_good</code> - El número de incidentes para los cuales hay recomendaciones "buenas" </li><li>  <code>avg_inc_good</code> - El número promedio de recomendaciones "buenas" para incidentes </li><li>  <code>n_rec_total</code> - Número total de recomendaciones </li><li>  <code>n_rec_good</code> - El número total de recomendaciones "buenas" </li><li>  <code>pct_inc_good</code> : porcentaje de incidentes para los que hay recomendaciones "buenas" <br> <code>pct_inc_good = n_inc_good / n_inc_total</code> </li> <li>  <code>pct_rec_good</code> : porcentaje total de recomendaciones "buenas" <br> <code>pct_rec_good = n_rec_good / n_rec_total</code> </li> </ul><br><p>  Estos indicadores, calculados sobre la base de estimaciones de los usuarios, pueden considerarse como "indicadores básicos" del modelo original.  Con él compararemos indicadores similares de nuevas versiones del modelo. </p><br><p>  Tome todos los "incidentes" únicos de <strong>m</strong> y guíelos a través del nuevo modelo. </p><br><p>  Como resultado, obtenemos muchas <strong>m *</strong> tuplas: "Incidente", "Incidente recomendado", "Distancia". <br>  Aquí, "distancia" es la métrica definida en NearestNeighbor.  En nuestro modelo, esta es la distancia del coseno.  El valor "0" corresponde a la coincidencia completa de los vectores. </p><br><h3 id="podbor-rasstoyaniya-otsechki">  Selección de "distancia de corte" </h3><br><p>  Complementando el conjunto de recomendaciones <strong>m * con</strong> información sobre la estimación verdadera de <strong>v</strong> del conjunto inicial de estimaciones de <strong>m</strong> , obtenemos la correspondencia entre la distancia <strong>d</strong> y la estimación verdadera de <strong>v</strong> para este modelo. </p><br><p>  Con el conjunto ( <strong>d</strong> , <strong>v</strong> ), es posible elegir el nivel de corte óptimo <strong>t</strong> , que para d &lt;= t la recomendación será "buena" y para d&gt; t - "mala".  La selección de t se puede lograr optimizando el clasificador binario más simple <code>v = -1 if d&gt;t else 1</code> respecto al hiperparámetro t, y utilizando, por ejemplo, AUC ROC como métrica. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     class BinarizerClassifier(Binarizer): def transform(self, x): return np.array([-1 if _x &gt; self.threshold else 1 for _x in np.array(x, dtype=float)]).reshape(-1, 1) def predict_proba(self, x): z = self.transform(x) return np.array([[0 if _x &gt; 0 else 1, 1 if _x &gt; 0 else 0] for _x in z.ravel()]) def predict(self, x): return self.transform(x) # #   : # -  , # -    m* # -   (d,v)  z_data_for_t # #   t b = BinarizerClassifier() z_x = z_data_for_t[['distance']] z_y = z_data_for_t['TYPE'] cv = GridSearchCV(b, param_grid={'threshold': np.arange(0.1, 0.7, 0.01)}, scoring='roc_auc', cv=5, iid=False, n_jobs=-1) cv.fit(z_x, z_y) score = cv.best_score_ t = cv.best_params_['threshold'] best_b = cv.best_estimator_</span></span></code> </pre> <br><p>  El valor <strong>t</strong> obtenido se puede usar para filtrar recomendaciones. </p><br><p>  Por supuesto, este enfoque puede omitir las recomendaciones "malas" y cortar las "buenas".  Por lo tanto, en esta etapa siempre mostramos las recomendaciones "Top 5", pero marcamos especialmente aquellas que se consideran "buenas", teniendo en cuenta la <strong>t</strong> encontrada. <br>  Alternativa: si se encuentra al menos una recomendación "buena", muestre solo "buena".  De lo contrario, muestre todos los disponibles (también - "Top N"). </p><br><h3 id="predpolozhenie-dlya-sravneniya-modeley">  Suposición para comparar modelos </h3><br><p>  Para los modelos de entrenamiento, se usa el mismo caso de incidente. <br>  Suponga que si se encontró previamente una "buena" recomendación, entonces el nuevo modelo también debería encontrar una "buena" recomendación para el mismo incidente.  En particular, el nuevo modelo puede encontrar las mismas recomendaciones "buenas" que el anterior.  Sin embargo, con el nuevo modelo, esperamos que el número de recomendaciones "malas" sea menor. </p><br><p>  Luego, considerando los mismos indicadores para las recomendaciones <strong>m * del</strong> nuevo modelo, se pueden comparar con los indicadores correspondientes para <strong>m</strong> .  Según la comparación, puede elegir el mejor modelo. </p><br><p>  Hay dos formas de tener en cuenta las recomendaciones "buenas" para el conjunto <strong>m *</strong> : </p><br><ol><li>  basado en el <strong>t</strong> encontrado: considere que todas las recomendaciones de <strong>m *</strong> con <strong>d</strong> &lt; <strong>t</strong> son "buenas" y tómelas en cuenta para calcular las métricas </li><li>  sobre la base de las estimaciones verdaderas correspondientes del conjunto <strong>m</strong> : de las recomendaciones <strong>m *,</strong> seleccione solo aquellas para las que haya una estimación verdadera en <strong>m</strong> , y descarte el resto. </li></ol><br><p>  En el primer caso, los indicadores "absolutos" ( <code>n_inc_good</code> , <code>n_rec_good</code> ) del nuevo modelo deberían ser mayores que los del modelo base.  En el segundo caso, los indicadores deben acercarse a los indicadores del modelo base. <br>  El problema del segundo método: si el nuevo modelo es mejor que el original y encuentra algo previamente desconocido, dicha recomendación no se tendrá en cuenta en el cálculo. </p><br><h3 id="vybor-parametrov-sravneniya-modeley">  Seleccionar opciones de comparación de modelos </h3><br><p>  Al elegir un nuevo modelo, quiero que los indicadores mejoren en comparación con el modelo existente: </p><br><ul><li>  número promedio de recomendaciones "buenas" por incidente ( <code>avg_inc_good</code> ) </li><li>  cantidad de incidentes para los que hay recomendaciones "buenas" ( <code>n_inc_good</code> ). </li></ul><br><p>  Para comparar con el modelo original, utilizaremos las relaciones de estos parámetros del nuevo modelo y el original.  Por lo tanto, si la relación del parámetro del nuevo modelo y el antiguo es superior a 1, el nuevo modelo es mejor. </p><br><pre> <code class="plaintext hljs">benchmark_agv_inc_good = avg_inc_good* / avg_inc_good benchmark_n_inc_good = n_inc_good* / n_inc_good</code> </pre> <br><p>  Para simplificar la selección, es mejor usar un solo parámetro.  Tomamos la media armónica de los indicadores relativos individuales y la usamos como el único criterio de calidad compuesto para el nuevo modelo. </p><br><pre> <code class="plaintext hljs">composite = 2 / ( 1/benchmark_agv_inc_good + 1/benchmark_n_inc_good)</code> </pre> <br><h2 id="novaya-model-i-ee-optimizaciya">  Nuevo modelo y su optimización. </h2><br><p>  Para el nuevo modelo, en el vector final que representa el incidente, agregue los componentes responsables del "área del incidente" (uno de varios sistemas atendidos por nuestro equipo). <br>  La información sobre la unidad y la ubicación del empleado que creó el incidente también se coloca en un componente vectorial separado.  Todos los componentes tienen su peso en el vector final. </p><br><pre> <code class="python hljs">p = Pipeline( steps=[ (<span class="hljs-string"><span class="hljs-string">'grp'</span></span>, ColumnTransformer( transformers=[ (<span class="hljs-string"><span class="hljs-string">'text'</span></span>, Pipeline(steps=[ (<span class="hljs-string"><span class="hljs-string">'pp'</span></span>, CommentsTextTransformer(n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>)), (<span class="hljs-string"><span class="hljs-string">"tfidf"</span></span>, TfidfVectorizer(stop_words=get_stop_words(), ngram_range=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), max_features=<span class="hljs-number"><span class="hljs-number">10000</span></span>, min_df=<span class="hljs-number"><span class="hljs-number">0</span></span>)) ]), [<span class="hljs-string"><span class="hljs-string">'short_description'</span></span>, <span class="hljs-string"><span class="hljs-string">'comments'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'area'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'area'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'dept'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_department'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'loc'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_location'</span></span>] ) ], transformer_weights={<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span> )), (<span class="hljs-string"><span class="hljs-string">'norm'</span></span>, Normalizer()), (<span class="hljs-string"><span class="hljs-string">"nn"</span></span>, NearestNeighborsTransformer(n_neighbors=<span class="hljs-number"><span class="hljs-number">10</span></span>, metric=<span class="hljs-string"><span class="hljs-string">'cosine'</span></span>)) ], memory=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Se espera que los hiperparámetros del modelo afecten a los objetivos del modelo.  En la arquitectura del modelo seleccionado, consideraremos como hiperparámetros: </p><br><ul><li>  Parámetros de vectorización TF-IDF: n-gramas usados ​​(ngram_range), tamaño del diccionario (max_features), mínimo plazo de conducción (min_df) </li><li>  contribución de componentes al vector final - transformer_weights. </li></ul><br><p>  Los valores iniciales de los hiperparámetros de vectorización de texto se toman del modelo anterior.  Los pesos de los componentes iniciales se seleccionan en base al juicio de expertos. </p><br><h3 id="cikl-podbora-parametrov">  Ciclo de selección de parámetros </h3><br><p>  Cómo comparar, seleccionar el nivel de falla de encendido y comparar modelos entre ellos ya han sido determinados.  Ahora podemos proceder a la optimización mediante la selección de hiperparámetros. </p><br><p><img src="https://habrastorage.org/webt/zy/zy/kb/zyzykbygrls9ca0bjscn3usfqby.png" alt="Ciclo de optimización"></p><br><pre> <code class="python hljs">param_grid = { <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__ngram_range'</span></span>: [(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__max_features'</span></span>: [<span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__min_df'</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>, <span class="hljs-number"><span class="hljs-number">0.0005</span></span>, <span class="hljs-number"><span class="hljs-number">0.001</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__transformer_weights'</span></span>: [{<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>}], } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ParameterGrid(param_grid=param_grid): p.set_params(**param) p.fit(x) ...</code> </pre> <br><h3 id="rezultaty-optimizacii">  Resultados de optimización </h3><br><p>  La tabla muestra los resultados de experimentos en los que se lograron resultados interesantes: los 5 mejores y peores valores para los indicadores controlados. </p><br><p><img src="https://habrastorage.org/webt/bi/l2/tj/bil2tj8dbqexqtezwmxealh3imq.png"></p><br><p>  Las celdas con indicadores en la tabla están marcadas como: </p><br><ul><li>  el verde oscuro es el mejor indicador entre todos los experimentos </li><li>  verde pálido: el valor del indicador está entre los 5 primeros </li><li>  rojo oscuro: el peor indicador entre todos los experimentos </li><li>  rojo pálido: el indicador está en el peor 5 </li></ul><br><p>  El mejor indicador compuesto se obtuvo para un modelo con parámetros: </p><br><pre> <code class="plaintext hljs">ngram_range = (1,2) min_df = 0.0001 max_features = 20000 transformer_weights = {'text': 1, 'area': 1, 'dept': 0.1, 'loc': 0.1}</code> </pre> <br><p>  Un modelo con estos parámetros mostró una mejora en el indicador compuesto en comparación con el modelo original 24% </p><br><h2 id="nekotorye-nablyudeniya-i-vyvody">  Algunas observaciones y conclusiones. </h2><br><p>  Según los resultados de optimización: </p><br><ol><li><p>  El uso de trigramas ( <code>ngram_range = (1,3)</code> ) no parece estar justificado.  Inflan el diccionario y aumentan ligeramente la precisión en comparación con bigrams. </p><br></li><li><p>  Un comportamiento interesante cuando se construye un diccionario usando solo bigrams ( <code>ngram_range = (2,2)</code> ): la "precisión" de las recomendaciones aumenta, y el número de recomendaciones encontradas disminuye.  Al igual que un equilibrio de precisión / recuperación en clasificadores.  Se observa un comportamiento similar en la selección del nivel de corte <strong>t</strong> : el "cono" de corte más estrecho y la mejor separación de las recomendaciones "buenas" y "malas" son características de las bigrams. </p><br></li><li><p>  El parámetro no cero min_df, junto con bigrams, aumenta la precisión de las recomendaciones.  Comienzan a basarse en términos que ocurren al menos varias veces.  A medida que aumenta el parámetro, el diccionario comienza a reducirse rápidamente.  Para muestras pequeñas, como en nuestro caso, probablemente será más comprensible operar con el número de documentos (valor entero min_df) que la fracción de documentos (valor fraccional min_df) que contiene el término. </p><br></li><li><p>  Se obtienen buenos resultados cuando el atributo incidente responsable de la "región" se incluye en el vector final con un peso igual o cercano al componente de texto.  Los valores bajos conducen a un aumento en la proporción de recomendaciones "malas" debido a la búsqueda de palabras similares en documentos de otras áreas.  Pero los signos de la ubicación del cliente no afectan tan bien los resultados de las recomendaciones en nuestro caso. </p><br></li></ol><br><p>  Han surgido algunas ideas nuevas: </p><br><ul><li>  agregue un componente de "tiempo" para que los incidentes recientes tengan prioridad sobre incidentes similares. </li><li>  vea cómo influirá la introducción del parámetro max_df, aunque con tf-idf las palabras demasiado generales para el corpus no deberían tener un peso significativo, por definición. </li><li>  finalmente, intente otras formas de vectorizar contenido, por ejemplo, basado en palabra a vector, o en convolución de vistas tf-idf usando redes. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472772/">https://habr.com/ru/post/472772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472760/index.html">Reduzca el tiempo de computación de unos pocos años a minutos. Comprender el aprendizaje automático cuántico</a></li>
<li><a href="../472762/index.html">Análisis técnico del exploit checkm8</a></li>
<li><a href="../472766/index.html">Parametrización desde archivo en py.test</a></li>
<li><a href="../472768/index.html">Cómo contratar, despedir y regresar de la administración al desarrollo: video de Badoo Techleads Meetup # 5</a></li>
<li><a href="../472770/index.html">Organización de la interfaz en Unity con UI Canvas</a></li>
<li><a href="../472776/index.html">Copia de seguridad Parte 7: Conclusiones</a></li>
<li><a href="../472778/index.html">5 maneras de usar la Raspberry Pi</a></li>
<li><a href="../472780/index.html">¿Por qué evitar amigos o cómo perdí todas mis ventajas?</a></li>
<li><a href="../472782/index.html">Por qué 3D Dolor de cabeza / Parte 8 Desenfoque y el futuro de 3D</a></li>
<li><a href="../472790/index.html">Antigüedades: i-Mate Jasjar, un comunicador para empresas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>