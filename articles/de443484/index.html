<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüíº ‚ù§Ô∏è ‚õ±Ô∏è 6 unerwartete M√§nner von Julia üî° üëèüèø üë®üèæ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schlie√ülich erschien ein russischsprachiger Leitfaden zur Julia-Sprache . Es bietet eine vollst√§ndige Einf√ºhrung in die Sprache f√ºr diejenigen, die we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>6 unerwartete M√§nner von Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443484/"><p><img src="https://habrastorage.org/webt/kk/lq/li/kklqliklumioy9-vmupwuq9afpc.png"></p><br><p>  Schlie√ülich erschien ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachiger Leitfaden zur Julia-Sprache</a> .  Es bietet eine vollst√§ndige Einf√ºhrung in die Sprache f√ºr diejenigen, die wenig Erfahrung in der Programmierung haben (der Rest wird f√ºr die allgemeine Entwicklung n√ºtzlich sein), eine Einf√ºhrung in das maschinelle Lernen und eine Reihe von Aufgaben zur Konsolidierung des Materials. </p><br><p>  W√§hrend der Suche bin ich auf einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmierkurs f√ºr Wirtschaftswissenschaftler gesto√üen</a> (neben Julia gibt es auch Python).  Erfahrene k√∂nnen einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kurzen Kurs belegen</a> oder das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man wie ein Informatiker denkt</a> lesen </p><br><p> Das Folgende ist eine √úbersetzung von Material aus dem Blog von Christopher Rackauckas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7 Julia Gotchas und wie man mit ihnen umgeht</a> </p><a name="habracut"></a><br><p> Lassen Sie mich zun√§chst sagen, dass Julia eine wunderbare Sprache ist.  Ich liebe sie, das ist meine Meinung nach die m√§chtigste und intuitivste Sprache, die ich je benutzt habe.  Dies ist zweifellos meine Lieblingssprache.  Es gibt jedoch einige "Fallstricke", knifflige Kleinigkeiten, √ºber die Sie Bescheid wissen m√ºssen.  Jede Sprache hat sie, und eines der ersten Dinge, die Sie tun m√ºssen, um die Sprache zu beherrschen, ist herauszufinden, was sie sind und wie Sie sie vermeiden k√∂nnen.  In diesem Beitrag m√∂chten wir Ihnen helfen, diesen Prozess zu beschleunigen, indem Sie einige der h√§ufigsten <code></code> , die alternative Programmiermethoden vorschlagen. </p><br><p>  Julia ist eine gute Sprache, um zu verstehen, was passiert, weil es keine Magie gibt.  Julia-Entwickler wollten klar definierte Verhaltensregeln.  Dies bedeutet, dass jedes Verhalten erkl√§rt werden kann.  Dies kann jedoch bedeuten, dass Sie Ihren Kopf anstrengen m√ºssen, um zu verstehen, warum dies und nicht das andere geschieht.  Deshalb werde ich nicht nur einige h√§ufig auftretende Probleme skizzieren, sondern auch erkl√§ren, warum sie auftreten.  Sie werden sehen, dass es einige sehr √§hnliche Muster gibt, und sobald Sie sich ihrer bewusst werden, werden Sie keines von ihnen mehr vermasseln.  Aus diesem Grund hat Julia eine etwas steilere Lernkurve im Vergleich zu einfacheren Sprachen wie <em>MATLAB / R / Python</em> .  Sobald Sie dies jedoch gemeistert haben, k√∂nnen Sie Julias Lakonismus voll ausnutzen, um <em>C / Fortran-</em> Leistung zu erzielen.  Jetzt tiefer graben. </p><br><h2 id="nezhdanchik-raz-repl-terminal-imeet-globalnuyu-oblast-vidimosti">  Unerwartet: REPL (Terminal) hat einen globalen Geltungsbereich </h2><br><p>  Dies ist bei weitem das h√§ufigste Problem, das von neuen Julia-Benutzern gemeldet wird.  Jemand wird sagen: "Ich habe geh√∂rt, Julia ist schnell!", √ñffnen Sie REPL, schreiben Sie schnell einen bekannten Algorithmus auf und f√ºhren Sie dieses Skript aus.  Nach der Ausf√ºhrung schauen sie auf die Zeit und sagen: "Warte eine Sekunde, warum ist es langsam, wie in Python?"  Da dies ein so wichtiges und h√§ufiges Problem ist, lassen Sie uns einige Zeit damit verbringen, die Gr√ºnde zu untersuchen, warum dies passiert, um herauszufinden, wie dies vermieden werden kann. </p><br><h3 id="nebolshoe-otstuplenie-pochemu-dzhuliya-bystra">  Ein kleiner Exkurs: Warum Julia schnell ist </h3><br><p>  Sie m√ºssen verstehen, dass Julia nicht nur eine Zusammenstellung von Code ist, sondern auch eine Spezialisierung von Typen (dh eine Zusammenstellung von Code, der f√ºr diese Typen spezifisch ist).  Lassen Sie mich noch einmal wiederholen: Julia ist nicht schnell, weil der Code mit dem JIT-Compiler kompiliert wird. Das Geheimnis der Geschwindigkeit ist vielmehr, dass typspezifischer Code kompiliert wird. </p><br><p>  Wenn Sie eine vollst√§ndige Geschichte ben√∂tigen, lesen Sie einige der Notizen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich f√ºr das bevorstehende Seminar geschrieben habe</a> .  Die Typenspezifit√§t wird durch das Grundprinzip von Julias Design bestimmt: <strong>Mehrfachversand</strong> .  Wenn Sie den Code schreiben: </p><br><pre> <code class="plaintext hljs">function f(a,b) return 2a+b end</code> </pre> <br><p>  Es scheint, dass dies nur eine <code></code> , aber tats√§chlich wird hier eine gro√üe Anzahl von <code></code> erstellt.  In Julias Sprache ist eine Funktion eine Abstraktion, und was eigentlich genannt wird, ist eine Methode.  Wenn Sie <code>f(2.0,3.0)</code> , f√ºhrt Julia den kompilierten Code aus, der zwei Gleitkommazahlen verwendet und <code>2a + b</code> zur√ºckgibt.  Wenn Sie <code>f(2,3)</code> aufrufen, f√ºhrt Julia einen weiteren kompilierten Code aus, der zwei Ganzzahlen akzeptiert und <code>2a + b</code> zur√ºckgibt.  Die Funktion <code>f</code> ist eine Abstraktion oder Abk√ºrzung f√ºr viele verschiedene Methoden, die dieselbe Form haben, und ein solches Schema der Verwendung des Symbols <em>f</em> zum Aufrufen all dieser verschiedenen Methoden wird als Mehrfachversand bezeichnet.  Und das gilt √ºberall: Der Operator <code>+</code> ist eine Funktion, die abh√§ngig von den angezeigten Typen Methoden aufruft.  Julia erh√§lt tats√§chlich seine Geschwindigkeit, weil der von ihr kompilierte Code seine Typen kennt und daher der kompilierte Code, der f (2.0,3.0) aufruft, genau der kompilierte Code ist, den Sie erhalten, wenn Sie dieselbe Funktion in <em>C / Fortran definieren</em> .  Sie k√∂nnen dies mit dem Makro <code>code_native</code> √ºberpr√ºfen, um die kompilierte Assembly <code>code_native</code> : </p><br><pre> <code class="plaintext hljs">@code_native f(2.0,3.0)</code> </pre> <br><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp Source line: 2 vaddsd %xmm0, %xmm0, %xmm0 vaddsd %xmm1, %xmm0, %xmm0 popq %rbp retq nop</code> </pre> <br><p>  Dies ist dieselbe kompilierte Assembly, die Sie von einer Funktion in <em>C / Fortran</em> erwarten, und sie unterscheidet sich vom Assemblycode f√ºr Ganzzahlen: </p><br><pre> <code class="plaintext hljs">@code_native f(2,3) pushq %rbp movq %rsp, %rbp Source line: 2 leaq (%rdx,%rcx,2), %rax popq %rbp retq nopw (%rax,%rax)</code> </pre> <br><h4 id="sut-repl--global-scope-ne-dopuskaet-specifiku-tipov">  Essenz: REPL / Global Scope erlaubt keine Typspezifit√§t </h4><br><p>  Dies bringt uns zum Hauptpunkt: REPL / Global Scope ist langsam, da es keine Typspezifikation zul√§sst.  Beachten Sie zun√§chst, dass REPL ein globaler Bereich ist, da Julia einen verschachtelten Bereich f√ºr Funktionen zul√§sst.  Zum Beispiel, wenn wir definieren </p><br><pre> <code class="plaintext hljs">function outer() a = 5 function inner() return 2a end b = inner() return 3a+b end</code> </pre> <br><p>  Wir werden sehen, dass dieser Code funktioniert.  Dies liegt daran, dass Sie mit Julia <code></code> von einer externen Funktion zu einer internen Funktion erfassen k√∂nnen.  Wenn Sie diese Idee rekursiv anwenden, werden Sie feststellen, dass der h√∂chste Bereich der Bereich ist, der direkt <strong>REPL ist</strong> (dies ist der globale Bereich des Hauptmoduls).  Aber jetzt √ºberlegen wir uns, wie die Funktion in dieser Situation kompiliert wird.  Wir implementieren dasselbe, verwenden jedoch globale Variablen: </p><br><pre> <code class="plaintext hljs">a=2.0; b=3.0 function linearcombo() return 2a+b end ans = linearcombo()</code> </pre> <br><p>  und </p><br><pre> <code class="plaintext hljs">a = 2; b = 3 ans2= linearcombo()</code> </pre> <br><p>  Frage: Welche Typen sollte der Compiler f√ºr <code>a</code> und <code>b</code> akzeptieren?  Beachten Sie, dass wir in diesem Beispiel die Typen ge√§ndert und trotzdem dieselbe Funktion aufgerufen haben.  Es kann mit allen Typen umgehen, die wir hinzuf√ºgen: Floating, Ganzzahlen, Arrays, seltsame Benutzertypen usw. In der Julia-Sprache bedeutet dies, dass die Variablen eingerahmt werden m√ºssen und die Typen bei jeder Verwendung √ºberpr√ºft werden.  Wie sieht der kompilierte Code aus? </p><br><div class="spoiler">  <b class="spoiler_title">Sperrig</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $96, %rsp movl $2147565792, %edi # imm = 0x800140E0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, %rsi leaq -72(%rbp), %r14 movq $0, -88(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -72(%rbp) movq $0, -56(%rbp) movq $10, -104(%rbp) movq (%rsi), %rax movq %rax, -96(%rbp) leaq -104(%rbp), %rax movq %rax, (%rsi) Source line: 3 movq pcre2_default_compile_context_8(%rdi), %rax movq %rax, -56(%rbp) movl $2154391480, %eax # imm = 0x806967B8 vmovq %rax, %xmm0 vpslldq $8, %xmm0, %xmm0 # xmm0 = zero,zero,zero,zero,zero,zero,zero,zero,xmm0[0,1,2,3,4,5,6,7] vmovdqu %xmm0, -80(%rbp) movq %rdi, -64(%rbp) movabsq $jl_apply_generic, %r15 movl $3, %edx movq %r14, %rcx callq *%r15 movq %rax, %rbx movq %rbx, -88(%rbp) movabsq $586874896, %r12 # imm = 0x22FB0010 movq (%r12), %rax testq %rax, %rax jne L198 leaq 98096(%rdi), %rcx movabsq $jl_get_binding_or_error, %rax movl $122868360, %edx # imm = 0x752D288 callq *%rax movq %rax, (%r12) L198: movq 8(%rax), %rax testq %rax, %rax je L263 movq %rax, -80(%rbp) addq $5498232, %rdi # imm = 0x53E578 movq %rdi, -72(%rbp) movq %rbx, -64(%rbp) movq %rax, -56(%rbp) movl $3, %edx movq %r14, %rcx callq *%r15 movq -96(%rbp), %rcx movq %rcx, (%rsi) addq $96, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r14 popq %r15 popq %rbp retq L263: movabsq $jl_undefined_var_error, %rax movl $122868360, %ecx # imm = 0x752D288 callq *%rax ud2 nopw (%rax,%rax)</code> </pre> </div></div><br><p>  F√ºr dynamische Sprachen ohne Typenspezialisierung ist dieser aufgebl√§hte Code mit allen zus√§tzlichen Anweisungen so gut wie m√∂glich, sodass Julia langsamer wird.  Um zu verstehen, warum dies so wichtig ist, beachten Sie, dass jeder Code, den Sie in Julia schreiben, kompiliert wird.  Angenommen, Sie schreiben eine Schleife in Ihr Skript: </p><br><pre> <code class="plaintext hljs">a = 1 for i = 1:100 a += a + f(a) end</code> </pre> <br><p>  Der Compiler muss diese Schleife kompilieren. Da er jedoch nicht garantieren kann, dass sich die Typen nicht √§ndern, wird alle Typen konservativ mit einem Fu√ütuch umwickelt, was zu einer langsamen Ausf√ºhrung f√ºhrt. </p><br><h4 id="kak-izbezhat-problemy">  So vermeiden Sie ein Problem </h4><br><p>  Es gibt verschiedene M√∂glichkeiten, um dieses Problem zu vermeiden.  Am einfachsten ist es, Ihre Skripte immer in Funktionen zu verpacken.  Der vorherige Code hat beispielsweise die Form: </p><br><pre> <code class="plaintext hljs">function geta(a) # can also just define a=1 here for i = 1:100 a += a + f(a) end return a end a = geta(1)</code> </pre> <br><p>  Dies f√ºhrt zu demselben Ergebnis. Da sich der Compiler jedoch auf Typ <code>a</code> spezialisieren kann, wird der gew√ºnschte kompilierte Code bereitgestellt.  Sie k√∂nnen Ihre Variablen auch als Konstanten definieren. </p><br><pre> <code class="plaintext hljs">const b = 5</code> </pre> <br><p>  Auf diese Weise teilen Sie dem Compiler mit, dass sich die Variable nicht √§ndert, und k√∂nnen so den gesamten Code, der sie verwendet, auf den aktuellen Typ spezialisieren.  Es gibt eine kleine Eigenart, dass Julia es Ihnen tats√§chlich erlaubt, den Wert einer Konstante zu √§ndern, aber keinen Typ.  Daher k√∂nnen Sie <code>const</code> , um dem Compiler mitzuteilen, dass Sie den Typ nicht √§ndern werden.  Beachten Sie jedoch, dass es einige kleine Macken gibt: </p><br><pre> <code class="plaintext hljs">const a = 5 f() = a println(f()) # Prints 5 a = 6 println(f()) # Prints 5 # WARNING: redefining constant a</code> </pre> <br><p>  Dies funktioniert nicht wie erwartet, da der Compiler, der erkennt, dass er die Antwort auf <code>f () = a</code> kennt (da <code>a</code> eine Konstante ist), einfach den Funktionsaufruf durch die Antwort ersetzt und ein anderes Verhalten ergibt, als wenn <code>a</code> nicht konstant w√§re. </p><br><p>  <strong>Moral: Schreiben Sie Ihre Skripte nicht direkt in REPL, sondern verpacken Sie sie immer in eine Funktion.</strong> </p><br><h2 id="nezhdanchik-dva-nestabilnost-tipov">  Nezhdanchik zwei: Typinstabilit√§t </h2><br><p>  Daher habe ich gerade eine Meinung dazu ge√§u√üert, wie wichtig die Codespezialisierung f√ºr Datentypen ist.  Lassen Sie mich eine Frage stellen, was passiert, wenn sich Ihre Typen √§ndern k√∂nnen?  Wenn Sie vermutet haben: ‚ÄûIn diesem Fall k√∂nnen Sie den kompilierten Code nicht spezialisieren‚Äú, haben Sie Recht.  Ein solches Problem ist als Typinstabilit√§t bekannt.  Sie k√∂nnen unterschiedlich aussehen, aber ein h√§ufiges Beispiel ist, dass Sie den Wert mit dem einfachen, aber nicht unbedingt dem Typ initialisieren, der er sein sollte.  Schauen wir uns zum Beispiel an: </p><br><pre> <code class="plaintext hljs">function g() x=1 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  Beachten Sie, dass <code>1/2</code> eine Gleitkommazahl in Julia ist.  Wenn wir also mit <code>x = 1</code> , √§ndert sich die Ganzzahl in eine Gleitkommazahl, und daher sollte die Funktion die innere Schleife so kompilieren, als ob sie von einem beliebigen Typ sein k√∂nnte.  Wenn wir stattdessen h√§tten: </p><br><pre> <code class="plaintext hljs">function h() x=1.0 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  Dann kann die gesamte Funktion optimal kompiliert werden, da <code>x</code> eine Gleitkommazahl bleibt (diese F√§higkeit des Compilers, Typen zu bestimmen, wird als Typinferenz bezeichnet).  Wir k√∂nnen den kompilierten Code √ºberpr√ºfen, um den Unterschied festzustellen: </p><br><div class="spoiler">  <b class="spoiler_title">Einheimisches Fu√ütuch</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r13 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $136, %rsp movl $2147565728, %ebx # imm = 0x800140A0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, -152(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -80(%rbp) movq $0, -64(%rbp) vxorps %ymm0, %ymm0, %ymm0 vmovups %ymm0, -128(%rbp) movq $0, -96(%rbp) movq $18, -144(%rbp) movq (%rax), %rcx movq %rcx, -136(%rbp) leaq -144(%rbp), %rcx movq %rcx, (%rax) movq $0, -88(%rbp) Source line: 4 movq %rbx, -104(%rbp) movl $10, %edi leaq 477872(%rbx), %r13 leaq 10039728(%rbx), %r15 leaq 8958904(%rbx), %r14 leaq 64(%rbx), %r12 leaq 10126032(%rbx), %rax movq %rax, -160(%rbp) nopw (%rax,%rax) L176: movq %rbx, -128(%rbp) movq -8(%rbx), %rax andq $-16, %rax movq %r15, %rcx cmpq %r13, %rax je L272 movq %rbx, -96(%rbp) movq -160(%rbp), %rcx cmpq $2147419568, %rax # imm = 0x7FFF05B0 je L272 movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %edx leaq -80(%rbp), %rcx movabsq $jl_apply_generic, %rax vzeroupper callq *%rax movq %rax, -88(%rbp) jmp L317 nopw %cs:(%rax,%rax) L272: movq %rcx, -120(%rbp) movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %r8d leaq -80(%rbp), %rdx movabsq $jl_invoke, %rax vzeroupper callq *%rax movq %rax, -112(%rbp) L317: movq (%rax), %rsi movl $1488, %edx # imm = 0x5D0 movl $16, %r8d movq -152(%rbp), %rcx movabsq $jl_gc_pool_alloc, %rax callq *%rax movq %rax, %rbx movq %r13, -8(%rbx) movq %rsi, (%rbx) movq %rbx, -104(%rbp) Source line: 3 addq $-1, %rdi jne L176 Source line: 6 movq -136(%rbp), %rax movq -152(%rbp), %rcx movq %rax, (%rcx) movq %rbx, %rax addq $136, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r13 popq %r14 popq %r15 popq %rbp retq nop</code> </pre> </div></div><br><p>  gegen </p><br><div class="spoiler">  <b class="spoiler_title">Ordentlicher Assembler-Zauber</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp movabsq $567811336, %rax # imm = 0x21D81D08 Source line: 6 vmovsd (%rax), %xmm0 # xmm0 = mem[0],zero popq %rbp retq nopw %cs:(%rax,%rax)</code> </pre> </div></div><br><p>  Solch ein Unterschied in der Anzahl der Berechnungen, um den gleichen Wert zu erhalten! </p><br><h4 id="kak-nayti-i-spravitsya-s-nestabilnostyu-tipov">  Wie man Typinstabilit√§t findet und damit umgeht </h4><br><p><img src="https://habrastorage.org/webt/92/l8/sn/92l8sno_8hd-dho0limmkwerezs.jpeg"></p><br><p>  An dieser Stelle k√∂nnten Sie fragen: "Warum nicht einfach <strong>C verwenden,</strong> damit Sie nicht nach diesen Instabilit√§ten suchen m√ºssen?"  Die Antwort lautet: </p><br><ol><li>  Leicht zu finden </li><li>  Sie k√∂nnen hilfreich sein. </li><li><p>  Sie k√∂nnen mit Instabilit√§t mit Funktionsbarrieren umgehen </p><br><p>  Julia gibt Ihnen das Makro <code>code_warntype</code> zu zeigen, wo sich <code>code_warntype</code> befinden.  Wenn wir dies beispielsweise in der von uns erstellten <code>g</code> Funktion verwenden: </p><br><pre> <code class="plaintext hljs">@code_warntype g()</code> </pre> <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">Holen Sie sich die Analyse</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Variables: #self#::#g x::ANY #temp#@_3::Int64 i::Int64 #temp#@_5::Core.MethodInstance #temp#@_6::Float64 Body: begin x::ANY = 1 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#@_3::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#@_3::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 30 SSAValue(3) = #temp#@_3::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#@_3::Int64,1)) i::Int64 = SSAValue(3) #temp#@_3::Int64 = SSAValue(4) # line 4: unless (Core.isa)(x::UNION{FLOAT64,INT64},Float64)::ANY goto 15 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Float64, ::Int64) goto 24 15: unless (Core.isa)(x::UNION{FLOAT64,INT64},Int64)::ANY goto 19 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Int64, ::Int64) goto 24 19: goto 21 21: #temp#@_6::Float64 = (x::UNION{FLOAT64,INT64} / 2)::Float64 goto 26 24: #temp#@_6::Float64 = $(Expr(:invoke, :(#temp#@_5), :(Main./), :(x::Union{Float64,Int64}), 2)) 26: x::ANY = #temp#@_6::Float64 28: goto 5 30: # line 6: return x::UNION{FLOAT64,INT64} end::UNION{FLOAT64,INT64}</code> </pre> </div></div><br><p>  Beachten Sie, dass wir am Anfang sagen, dass Typ x <code>Any</code> .  Es wird jeder Typ verwendet, der nicht als <code>strict type</code> bezeichnet ist, dh es handelt sich um einen abstrakten Typ, der bei jedem Schritt eingerahmt / aktiviert werden muss.  Wir sehen, dass wir am Ende <code>x</code> als <code>UNION {FLOAT64, INT64}</code> , was ein weiterer nicht strenger Typ ist.  Dies sagt uns, dass sich Typ <code></code> ge√§ndert hat, was zu Schwierigkeiten f√ºhrt.  Wenn wir stattdessen <code>code_warntype</code> f√ºr <code>h</code> , erhalten wir alle strengen Typen: </p><br><pre> <code class="plaintext hljs">@code_warntype h() Variables: #self#::#h x::Float64 #temp#::Int64 i::Int64 Body: begin x::Float64 = 1.0 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 15 SSAValue(3) = #temp#::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#::Int64,1)) i::Int64 = SSAValue(3) #temp#::Int64 = SSAValue(4) # line 4: x::Float64 = (Base.box)(Base.Float64,(Base.div_float)(x::Float64,(Base.box)(Float64,(Base.sitofp)(Float64,2)))) 13: goto 5 15: # line 6: return x::Float64 end::Float64</code> </pre> <br><p>  Dies zeigt an, dass die Funktion typstabil ist und im Wesentlichen zu einem optimalen <em>C-Code kompiliert wird</em> .  Daher ist eine Typinstabilit√§t nicht schwer zu finden.  Schwieriger ist es, das richtige Design zu finden.  Warum Typinstabilit√§t beheben?  Dies ist ein langj√§hriges Problem, das dazu gef√ºhrt hat, dass dynamisch typisierte Sprachen das Spielfeld von Skripten dominieren.  Die Idee ist, dass Sie in vielen F√§llen einen Kompromiss zwischen Leistung und Zuverl√§ssigkeit finden m√∂chten. </p><br><p>  Sie k√∂nnen beispielsweise eine Tabelle von einer Webseite lesen, auf der Ganzzahlen mit Gleitkommazahlen gemischt sind.  In Julia k√∂nnen Sie Ihre Funktion so schreiben, dass sie gut kompiliert wird, wenn alle Ganzzahlen sind, und wenn alle Gleitkommazahlen sind, auch gut kompiliert.  Und wenn sie gemischt sind?  Dies wird immer noch funktionieren.  Dies ist die Flexibilit√§t / Bequemlichkeit, die wir aus einer Sprache wie <em>Python / R</em> kennen und lieben <em>.</em>  Aber Julia wird Ihnen direkt ( <em>√ºber code_warntype</em> ) <em>mitteilen,</em> wann Sie die Leistung opfern. </p><br><h3 id="kak-spravitsya-s-nestabilnostyami-tipov">  Umgang mit Typinstabilit√§ten </h3><br><p><img src="https://habrastorage.org/webt/2s/9h/xg/2s9hxgty3fsdvuqf3a6ey05dxzs.png"></p><br><p>  Es gibt verschiedene M√∂glichkeiten, mit Typinstabilit√§ten umzugehen.  Wenn Sie etwas wie <em>C / Fortran</em> m√∂gen, bei dem Ihre Typen deklariert sind und sich nicht √§ndern k√∂nnen (was die Typstabilit√§t gew√§hrleistet), k√∂nnen Sie dies zun√§chst in Julia tun: </p><br><pre> <code class="plaintext hljs">local a::Int64 = 5</code> </pre> <br><p>  Dies ergibt <code>a</code> 64-Bit-Ganzzahl. Wenn zuk√ºnftiger Code versucht, sie zu √§ndern, wird eine Fehlermeldung generiert (oder die korrekte Konvertierung wird durchgef√ºhrt. Da die Konvertierung jedoch nicht automatisch gerundet wird, f√ºhrt dies h√∂chstwahrscheinlich zu Fehlern).  Streuen Sie sie um Ihren Code und Sie erhalten Typstabilit√§t, ala, <em>C / Fortran</em> .  Eine weniger komplizierte M√∂glichkeit, dies zu handhaben, sind Typanweisungen.  Hier setzen Sie die gleiche Syntax auf die andere Seite des Gleichheitszeichens.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">a = (b/c)::Float64</code> </pre> <br><p>  Es scheint zu sagen: "Berechnen Sie b / c und stellen Sie sicher, dass die Ausgabe Float64 ist. Wenn dies nicht der Fall ist, versuchen Sie, eine automatische Konvertierung durchzuf√ºhren. Wenn die Konvertierung nicht einfach durchgef√ºhrt werden kann, geben Sie einen Fehler aus."  Durch das Platzieren solcher Designs k√∂nnen Sie sicherstellen, dass Sie wissen, um welche Typen es sich handelt.  In einigen F√§llen ist jedoch eine Typinstabilit√§t erforderlich.  Nehmen wir zum Beispiel an, Sie m√∂chten zuverl√§ssigen Code haben, aber der Benutzer gibt Ihnen etwas Verr√ºcktes, wie: </p><br><pre> <code class="plaintext hljs">arr = Vector{Union{Int64,Float64}}(undef, 4) arr[1]=4 arr[2]=2.0 arr[3]=3.2 arr[4]=1</code> </pre> <br><p>  Dies ist ein Array von 4x1-Ganzzahlen und Gleitkommazahlen.  Der eigentliche Elementtyp f√ºr das Array ist <code>Union {Int64, Float64}</code> , was, wie wir bereits gesehen haben, nicht streng war, was zu Problemen f√ºhren kann.  Der Compiler wei√ü nur, dass jeder Wert eine Ganzzahl oder eine Gleitkommazahl sein kann, nicht jedoch welches Element von welchem ‚Äã‚ÄãTyp.  Dies bedeutet, dass es naiv ist, mit diesem Array zu rechnen, zum Beispiel: </p><br><pre> <code class="plaintext hljs">function foo{T,N}(array::Array{T,N}) for i in eachindex(array) val = array[i] # do algorithm X on val end end</code> </pre> <br><p>  wird langsam sein, da die Operationen boxed werden.  Wir k√∂nnen jedoch mehrere Versendungen verwenden, um Codes auf spezielle Weise auszuf√ºhren.  Dies wird als Verwendung von Funktionsbarrieren bezeichnet.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">function inner_foo{T&lt;:Number}(val::T) # Do algorithm X on val end function foo2{T,N}(array::Array{T,N}) for i in eachindex(array) inner_foo(array[i]) end end</code> </pre> <br><p>  Beachten Sie, dass beim Aufrufen von <code>inner_foo</code> aufgrund des Mehrfachversands entweder eine speziell f√ºr Gleitkommazahlen kompilierte Methode oder eine speziell f√ºr Ganzzahlen kompilierte Methode <code>inner_foo</code> .  Auf diese Weise k√∂nnen Sie eine lange Berechnung in <code>inner_foo</code> und trotzdem daf√ºr sorgen, dass sie gut funktioniert, was der strengen Typisierung, die Ihnen die funktionale Barriere bietet, nicht unterlegen ist. </p><br><p>  Daher hoffe ich, dass Sie sehen, dass Julia eine gute Kombination aus starker Tippleistung und dem Komfort des dynamischen Tippens bietet.  Eine gute Programmiererin, Julia, hat beide M√∂glichkeiten, um die Produktivit√§t und / oder Produktivit√§t bei Bedarf zu maximieren. </p><br><h3 id="nezhdanchik-3-eval-rabotaet-na-globalnom-urovne">  √úberraschung 3: Eval funktioniert global </h3><br><p><img src="https://habrastorage.org/webt/vs/5d/p2/vs5dp2t9wel5mbje-ewldc3fxne.jpeg"></p><br><p>  Eine der gr√∂√üten St√§rken von Julia ist ihre Metaprogrammierf√§higkeit.  Auf diese Weise k√∂nnen Sie problemlos Programme zur Codegenerierung schreiben und so die Menge an Code reduzieren, die Sie schreiben und warten m√ºssen.  Ein Makro ist eine Funktion, die zur Kompilierungszeit ausgef√ºhrt wird und (normalerweise) Code ausspuckt.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">macro defa() :(a=5) end</code> </pre> <br><p>  ersetzt jede <code>defa</code> Instanz durch den Code <code>a = 5</code> ( <code>:(a = 5)</code> ist ein <em>Ausdruck in Anf√ºhrungszeichen</em> . Julias Code besteht aus Ausdr√ºcken, und daher ist die Metaprogrammierung eine Sammlung von Ausdr√ºcken). </p><br><p>  Sie k√∂nnen dies verwenden, um ein beliebiges komplexes Julia-Programm zu erstellen und es in eine Funktion als eine Art wirklich intelligente Verkn√ºpfung einzuf√ºgen.  Manchmal m√ºssen Sie den generierten Code jedoch direkt auswerten.  Julia gibt Ihnen dazu eine <code>@eval</code> oder ein <code>@eval</code> <code>eval</code> Makro.  Im Allgemeinen sollten Sie versuchen, eine <code>eval</code> zu vermeiden, aber es gibt einige Codes, in denen dies erforderlich ist, z. B. <a href="">meine neue Bibliothek zum √úbertragen von Daten zwischen verschiedenen Prozessen f√ºr die parallele Programmierung</a> .  Beachten Sie jedoch Folgendes, wenn Sie es verwenden: </p><br><pre> <code class="plaintext hljs">@eval :(a=5)</code> </pre> <br><p>        (REPL).    ,      / .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) return 2a+5 end</code> </pre> <br><p>     ,   <code>a</code>      REPL.   , ,       : </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) b = a::Int64 return 2b+5 end</code> </pre> <br><p>  <code>b</code> ‚Äî   ,     ,     , ,  ,          .     <code>eval</code>  ,    ,     <code>REPL</code> . </p><br><h3 id="nezhdanchik-4-kak-razbivat-vyrazheniya">  4:    </h3><br><p>  Julia   ,     .        :    ,    . </p><br><p>  , ?  ,   ,   .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 +8 + 9 + 10+ 11+ 12+ 13 a</code> </pre> <br><p> ,      90,     27. ?  <code>a = 2 + 3 + 4 + 5 + 6 + 7</code>   ,      <code>a = 27</code> ,     <code>+8 + 9 + 10+ 11+ 12+ 13</code> ,   ,    ,    : </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10+ 11+ 12+ 13</code> </pre> <br><p>   90,   .         ,   . </p><br><blockquote>              .   ‚Äî     ,       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">rssdev10</a> </blockquote><p>       .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">x = rand(2,2) a = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)] b = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) - sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)]</code> </pre> <br><p>     ,  a  b ‚Äî     ,    !    (2,2) ,   ‚Äî (1-)   2.  ,   ,    : </p><br><pre> <code class="plaintext hljs">a = [1 -2] b = [1 - 2]</code> </pre> <br><p>      : <code>1</code>  <code>-2</code> .    : <code>1-2</code> .  -     .    : </p><br><pre> <code class="plaintext hljs">a = [1 2 3 -4 2 -3 1 4]</code> </pre> <br><p>    2x4.   ,    .      :        <code>hcat</code> : </p><br><pre> <code class="plaintext hljs">a = hcat(cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi),-sin(2.*x[:,1]).*sin(2.*x[:,2])./(4))</code> </pre> <br><p>  ! </p><br><h3 id="podvodnyy-kamen-5-predstavleniya-kopirovanie-i-glubokaya-kopiya">   ‚Ññ5: ,     </h3><br><p><img src="https://habrastorage.org/webt/wh/xj/8f/whxj8fg_es5hmuoky6ixtzneat0.jpeg"></p><br><blockquote> <strong> (View)</strong> ‚Äî  () ,     (  ),        . <br><br>       ,       ,   .       ,    .            ,     . </blockquote><p>         ‚Äî   "". ""     <code></code>    ,     . ""  ‚Äî      (    ).    (  <em>()</em> ) . ,     : </p><br><pre> <code class="plaintext hljs">a = [3;4;5] b = a b[1] = 1</code> </pre> <br><p>     ,  <code>a</code> ‚Äî   <code>[1; 4; 5]</code> , . .  <code>b</code>  <code>a</code> .   ,  <code>b = a</code>   <code>b</code>   <code>a</code> .         , ,    <code>b</code> ,    ,          (   <code>b</code>  <code>a</code> ).   ,            . ,        , : </p><br><pre> <code class="plaintext hljs">a = rand(2,2) # Makes a random 2x2 matrix b = vec(a) # Makes a view to the 2x2 matrix which is a 1-dimensional array</code> </pre> <br><p>  <code>b</code>  ,   <code>b</code>    <code>a</code> ,  <code>b</code>    .  ,       ,        ( ,         ).   .  ,          .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">c = a[1:2,1]</code> </pre> <br><p>        <code></code> ( ,  <code>c</code>   <code>a</code> ).     ,   ,      ,   ,   .  ,        , : </p><br><pre> <code class="plaintext hljs">d = @view a[1:2,1] e = view(a,1:2,1)</code> </pre> <br><p>  <code>d</code> ,  <code>e</code> ‚Äî     ,   <code>d</code>  <code>e</code>  <code>a</code> ,       ,     ,       <code></code> . ( ,   , ‚Äî  <code>reshape</code> ,     .)     ,   .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">a[1:2,1] = [1;2]</code> </pre> <br><p>  <code>a</code> ,      <code>a[1:2,1]</code>   <code>view (a, 1:2,1)</code> ,      ,   <code>a</code> .   -? ,     : </p><br><pre> <code class="plaintext hljs">b = copy(a)</code> </pre> <br><p> ,  <code>b</code>   <code>a</code> ,   ,  <code>b</code>   <code>a</code> .     <code>a</code> ,    <code>copy! (B, a)</code>  ,           <code>a</code>   <code>a</code> (   ,  <code>b</code>       ).        . , <code>Vector {Vector}</code> : </p><br><pre> <code class="plaintext hljs">a = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ]</code> </pre> <br><p>   <code></code>  .  ,   ? </p><br><pre> <code class="plaintext hljs">b = copy(a) b[1][1] = 10 a</code> </pre> <br><pre> <code class="plaintext hljs">3-element Array{Array{Int64,1},1}: [10, 2, 3] [4, 5] [6, 7, 8, 9]</code> </pre> <br><p>  ,     <code>a[1][1]</code>  10!   ?   <code>copy</code>    <code>a</code> .   <code>a</code>  ,         <code>b</code> ,  <code>b</code>      .   ,  <code>deepcopy</code> : </p><br><pre> <code class="plaintext hljs">b = deepcopy(a)</code> </pre> <br><p>      ,     .  ,         ,      . </p><br><h3 id="golovnaya-bol-6-vremennye-raspredeleniya-vektorizaciya-i-funkcii-in-place">   ‚Ññ6:  ,    In-Place </h3><br><p>  <em>MATLAB / Python / R</em>    .  Julia , , ,  "  ".    <code> </code> (. .    ,   , ,   ,        ).               (in-place),   .       ?  in-place ( <em>mutable function</em> ) ‚Äî  ,   ,    .       ,                 . ,   : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x = x + inner(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>   ,   <code>inner</code> ,     ,    <code>2x</code> . ,       .  ,       - <code>y</code> ,      : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] y = Vector{Int64}(3) for i = 1:10 inner(y,x) for i in 1:3 x[i] = x[i] + y[i] end copy!(y,x) end return x end function inner!(y,x) for i=1:3 y[i] = 2*x[i] end nothing end</code> </pre> <br><p>  . <code>inner!(y, x)</code>   ,   <code>y</code> .  <code>y</code>  ,  <code>y</code>     , ,       , <code>inner! (y, x)</code>  <code></code>   <code></code> . ,   ,  mutable (,  "").     <code>!</code>      (   ). </p><br><p>  ,   <code>inner!(y, x)</code>   .    <code>copy!(y, x)</code> ‚Äî   ,    <code>x</code>  <code>y</code> ,  .  ,  ,       .    :    <code>x</code>     <code>y</code> .       ,   <code>x + inner(x)</code> , ,  ,      11 .     ,     . </p><br><p> ,     ,    ,     .  -     ( <em>loop-fusion</em> ).   Julia v0.5    <code>.</code>      (    ( <em>broadcast</em> ),         <code></code> ).  ,  <code>f.(x)</code> ‚Äî    ,   <code>f</code>    <code>x</code> ,   ,   .     <code>f</code>  <code>x</code>    ,  <code>x = x + f. (x)</code>   .          : </p><br><pre> <code class="plaintext hljs">x .= x .+ f.(x)</code> </pre> <br><p> <code>.=</code>    ,   ,  ,   </p><br><pre> <code class="plaintext hljs">for i = 1:length(x) x[i] = x[i] + f(x[i]) end</code> </pre> <br><p>  ,       : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x .= x .+ inner.(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>         <em>MATLAB / R / Python</em> ,        , ,  .      <code>  </code> ,     ,  <em>C / Fortran</em> . </p><br><h3 id="vyvod-vyuchite-pravila-poymite-ih-i-kataytes-kak-syr-v-masle"> :  ,         </h3><br><p>   :     ,   .   ,      .  ,        .   ,     ,     .     ,    . </p><br><p>    -   ,      <em>C / Fortran</em> ,           .    -  ,        ,   ! </p><br><p>   :     ?  ,       .  ,  ,       ? [    ,   Javascript   <code>var x = 3</code>  <code>x</code> ,  <code>x = 3</code>  <code>x</code> .    ?     , -       Javascript!] </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443484/">https://habr.com/ru/post/de443484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443472/index.html">M√ºssen Sie in die Cloud gehen? 7 Tipps, wie man nichts vermasselt</a></li>
<li><a href="../de443476/index.html">Wie SimCity eine ganze Generation von Stadtplanern inspirierte</a></li>
<li><a href="../de443478/index.html">Synthetische und reale Testdaten: Vor- und Nachteile, Fallstricke</a></li>
<li><a href="../de443480/index.html">Kryptografische Token von PKCS # 11: Anzeigen und Exportieren von Zertifikaten, √úberpr√ºfen ihrer G√ºltigkeit</a></li>
<li><a href="../de443482/index.html">AIOps in der Praxis - was kann Huawei FabricInsight</a></li>
<li><a href="../de443486/index.html">ReLEx SMILE: Wie man keine Fehler in Prognosen macht</a></li>
<li><a href="../de443488/index.html">Funktionskomponenten mit React Hooks. Warum sind sie besser?</a></li>
<li><a href="../de443492/index.html">Ein Spiel f√ºr Liebhaber und Experten unter Linux</a></li>
<li><a href="../de443494/index.html">Anleitung: Starten des SaaS-Produkts unter AppSumo - Erfolge und einige Fehler</a></li>
<li><a href="../de443498/index.html">Flightradar24 - wie geht das? Teil 2, ADS-B-Protokoll</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>