<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💼 ❤️ ⛱️ 6 unerwartete Männer von Julia 🔡 👏🏿 👨🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schließlich erschien ein russischsprachiger Leitfaden zur Julia-Sprache . Es bietet eine vollständige Einführung in die Sprache für diejenigen, die we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>6 unerwartete Männer von Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443484/"><p><img src="https://habrastorage.org/webt/kk/lq/li/kklqliklumioy9-vmupwuq9afpc.png"></p><br><p>  Schließlich erschien ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachiger Leitfaden zur Julia-Sprache</a> .  Es bietet eine vollständige Einführung in die Sprache für diejenigen, die wenig Erfahrung in der Programmierung haben (der Rest wird für die allgemeine Entwicklung nützlich sein), eine Einführung in das maschinelle Lernen und eine Reihe von Aufgaben zur Konsolidierung des Materials. </p><br><p>  Während der Suche bin ich auf einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmierkurs für Wirtschaftswissenschaftler gestoßen</a> (neben Julia gibt es auch Python).  Erfahrene können einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kurzen Kurs belegen</a> oder das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man wie ein Informatiker denkt</a> lesen </p><br><p> Das Folgende ist eine Übersetzung von Material aus dem Blog von Christopher Rackauckas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7 Julia Gotchas und wie man mit ihnen umgeht</a> </p><a name="habracut"></a><br><p> Lassen Sie mich zunächst sagen, dass Julia eine wunderbare Sprache ist.  Ich liebe sie, das ist meine Meinung nach die mächtigste und intuitivste Sprache, die ich je benutzt habe.  Dies ist zweifellos meine Lieblingssprache.  Es gibt jedoch einige "Fallstricke", knifflige Kleinigkeiten, über die Sie Bescheid wissen müssen.  Jede Sprache hat sie, und eines der ersten Dinge, die Sie tun müssen, um die Sprache zu beherrschen, ist herauszufinden, was sie sind und wie Sie sie vermeiden können.  In diesem Beitrag möchten wir Ihnen helfen, diesen Prozess zu beschleunigen, indem Sie einige der häufigsten <code></code> , die alternative Programmiermethoden vorschlagen. </p><br><p>  Julia ist eine gute Sprache, um zu verstehen, was passiert, weil es keine Magie gibt.  Julia-Entwickler wollten klar definierte Verhaltensregeln.  Dies bedeutet, dass jedes Verhalten erklärt werden kann.  Dies kann jedoch bedeuten, dass Sie Ihren Kopf anstrengen müssen, um zu verstehen, warum dies und nicht das andere geschieht.  Deshalb werde ich nicht nur einige häufig auftretende Probleme skizzieren, sondern auch erklären, warum sie auftreten.  Sie werden sehen, dass es einige sehr ähnliche Muster gibt, und sobald Sie sich ihrer bewusst werden, werden Sie keines von ihnen mehr vermasseln.  Aus diesem Grund hat Julia eine etwas steilere Lernkurve im Vergleich zu einfacheren Sprachen wie <em>MATLAB / R / Python</em> .  Sobald Sie dies jedoch gemeistert haben, können Sie Julias Lakonismus voll ausnutzen, um <em>C / Fortran-</em> Leistung zu erzielen.  Jetzt tiefer graben. </p><br><h2 id="nezhdanchik-raz-repl-terminal-imeet-globalnuyu-oblast-vidimosti">  Unerwartet: REPL (Terminal) hat einen globalen Geltungsbereich </h2><br><p>  Dies ist bei weitem das häufigste Problem, das von neuen Julia-Benutzern gemeldet wird.  Jemand wird sagen: "Ich habe gehört, Julia ist schnell!", Öffnen Sie REPL, schreiben Sie schnell einen bekannten Algorithmus auf und führen Sie dieses Skript aus.  Nach der Ausführung schauen sie auf die Zeit und sagen: "Warte eine Sekunde, warum ist es langsam, wie in Python?"  Da dies ein so wichtiges und häufiges Problem ist, lassen Sie uns einige Zeit damit verbringen, die Gründe zu untersuchen, warum dies passiert, um herauszufinden, wie dies vermieden werden kann. </p><br><h3 id="nebolshoe-otstuplenie-pochemu-dzhuliya-bystra">  Ein kleiner Exkurs: Warum Julia schnell ist </h3><br><p>  Sie müssen verstehen, dass Julia nicht nur eine Zusammenstellung von Code ist, sondern auch eine Spezialisierung von Typen (dh eine Zusammenstellung von Code, der für diese Typen spezifisch ist).  Lassen Sie mich noch einmal wiederholen: Julia ist nicht schnell, weil der Code mit dem JIT-Compiler kompiliert wird. Das Geheimnis der Geschwindigkeit ist vielmehr, dass typspezifischer Code kompiliert wird. </p><br><p>  Wenn Sie eine vollständige Geschichte benötigen, lesen Sie einige der Notizen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich für das bevorstehende Seminar geschrieben habe</a> .  Die Typenspezifität wird durch das Grundprinzip von Julias Design bestimmt: <strong>Mehrfachversand</strong> .  Wenn Sie den Code schreiben: </p><br><pre> <code class="plaintext hljs">function f(a,b) return 2a+b end</code> </pre> <br><p>  Es scheint, dass dies nur eine <code></code> , aber tatsächlich wird hier eine große Anzahl von <code></code> erstellt.  In Julias Sprache ist eine Funktion eine Abstraktion, und was eigentlich genannt wird, ist eine Methode.  Wenn Sie <code>f(2.0,3.0)</code> , führt Julia den kompilierten Code aus, der zwei Gleitkommazahlen verwendet und <code>2a + b</code> zurückgibt.  Wenn Sie <code>f(2,3)</code> aufrufen, führt Julia einen weiteren kompilierten Code aus, der zwei Ganzzahlen akzeptiert und <code>2a + b</code> zurückgibt.  Die Funktion <code>f</code> ist eine Abstraktion oder Abkürzung für viele verschiedene Methoden, die dieselbe Form haben, und ein solches Schema der Verwendung des Symbols <em>f</em> zum Aufrufen all dieser verschiedenen Methoden wird als Mehrfachversand bezeichnet.  Und das gilt überall: Der Operator <code>+</code> ist eine Funktion, die abhängig von den angezeigten Typen Methoden aufruft.  Julia erhält tatsächlich seine Geschwindigkeit, weil der von ihr kompilierte Code seine Typen kennt und daher der kompilierte Code, der f (2.0,3.0) aufruft, genau der kompilierte Code ist, den Sie erhalten, wenn Sie dieselbe Funktion in <em>C / Fortran definieren</em> .  Sie können dies mit dem Makro <code>code_native</code> überprüfen, um die kompilierte Assembly <code>code_native</code> : </p><br><pre> <code class="plaintext hljs">@code_native f(2.0,3.0)</code> </pre> <br><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp Source line: 2 vaddsd %xmm0, %xmm0, %xmm0 vaddsd %xmm1, %xmm0, %xmm0 popq %rbp retq nop</code> </pre> <br><p>  Dies ist dieselbe kompilierte Assembly, die Sie von einer Funktion in <em>C / Fortran</em> erwarten, und sie unterscheidet sich vom Assemblycode für Ganzzahlen: </p><br><pre> <code class="plaintext hljs">@code_native f(2,3) pushq %rbp movq %rsp, %rbp Source line: 2 leaq (%rdx,%rcx,2), %rax popq %rbp retq nopw (%rax,%rax)</code> </pre> <br><h4 id="sut-repl--global-scope-ne-dopuskaet-specifiku-tipov">  Essenz: REPL / Global Scope erlaubt keine Typspezifität </h4><br><p>  Dies bringt uns zum Hauptpunkt: REPL / Global Scope ist langsam, da es keine Typspezifikation zulässt.  Beachten Sie zunächst, dass REPL ein globaler Bereich ist, da Julia einen verschachtelten Bereich für Funktionen zulässt.  Zum Beispiel, wenn wir definieren </p><br><pre> <code class="plaintext hljs">function outer() a = 5 function inner() return 2a end b = inner() return 3a+b end</code> </pre> <br><p>  Wir werden sehen, dass dieser Code funktioniert.  Dies liegt daran, dass Sie mit Julia <code></code> von einer externen Funktion zu einer internen Funktion erfassen können.  Wenn Sie diese Idee rekursiv anwenden, werden Sie feststellen, dass der höchste Bereich der Bereich ist, der direkt <strong>REPL ist</strong> (dies ist der globale Bereich des Hauptmoduls).  Aber jetzt überlegen wir uns, wie die Funktion in dieser Situation kompiliert wird.  Wir implementieren dasselbe, verwenden jedoch globale Variablen: </p><br><pre> <code class="plaintext hljs">a=2.0; b=3.0 function linearcombo() return 2a+b end ans = linearcombo()</code> </pre> <br><p>  und </p><br><pre> <code class="plaintext hljs">a = 2; b = 3 ans2= linearcombo()</code> </pre> <br><p>  Frage: Welche Typen sollte der Compiler für <code>a</code> und <code>b</code> akzeptieren?  Beachten Sie, dass wir in diesem Beispiel die Typen geändert und trotzdem dieselbe Funktion aufgerufen haben.  Es kann mit allen Typen umgehen, die wir hinzufügen: Floating, Ganzzahlen, Arrays, seltsame Benutzertypen usw. In der Julia-Sprache bedeutet dies, dass die Variablen eingerahmt werden müssen und die Typen bei jeder Verwendung überprüft werden.  Wie sieht der kompilierte Code aus? </p><br><div class="spoiler">  <b class="spoiler_title">Sperrig</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $96, %rsp movl $2147565792, %edi # imm = 0x800140E0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, %rsi leaq -72(%rbp), %r14 movq $0, -88(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -72(%rbp) movq $0, -56(%rbp) movq $10, -104(%rbp) movq (%rsi), %rax movq %rax, -96(%rbp) leaq -104(%rbp), %rax movq %rax, (%rsi) Source line: 3 movq pcre2_default_compile_context_8(%rdi), %rax movq %rax, -56(%rbp) movl $2154391480, %eax # imm = 0x806967B8 vmovq %rax, %xmm0 vpslldq $8, %xmm0, %xmm0 # xmm0 = zero,zero,zero,zero,zero,zero,zero,zero,xmm0[0,1,2,3,4,5,6,7] vmovdqu %xmm0, -80(%rbp) movq %rdi, -64(%rbp) movabsq $jl_apply_generic, %r15 movl $3, %edx movq %r14, %rcx callq *%r15 movq %rax, %rbx movq %rbx, -88(%rbp) movabsq $586874896, %r12 # imm = 0x22FB0010 movq (%r12), %rax testq %rax, %rax jne L198 leaq 98096(%rdi), %rcx movabsq $jl_get_binding_or_error, %rax movl $122868360, %edx # imm = 0x752D288 callq *%rax movq %rax, (%r12) L198: movq 8(%rax), %rax testq %rax, %rax je L263 movq %rax, -80(%rbp) addq $5498232, %rdi # imm = 0x53E578 movq %rdi, -72(%rbp) movq %rbx, -64(%rbp) movq %rax, -56(%rbp) movl $3, %edx movq %r14, %rcx callq *%r15 movq -96(%rbp), %rcx movq %rcx, (%rsi) addq $96, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r14 popq %r15 popq %rbp retq L263: movabsq $jl_undefined_var_error, %rax movl $122868360, %ecx # imm = 0x752D288 callq *%rax ud2 nopw (%rax,%rax)</code> </pre> </div></div><br><p>  Für dynamische Sprachen ohne Typenspezialisierung ist dieser aufgeblähte Code mit allen zusätzlichen Anweisungen so gut wie möglich, sodass Julia langsamer wird.  Um zu verstehen, warum dies so wichtig ist, beachten Sie, dass jeder Code, den Sie in Julia schreiben, kompiliert wird.  Angenommen, Sie schreiben eine Schleife in Ihr Skript: </p><br><pre> <code class="plaintext hljs">a = 1 for i = 1:100 a += a + f(a) end</code> </pre> <br><p>  Der Compiler muss diese Schleife kompilieren. Da er jedoch nicht garantieren kann, dass sich die Typen nicht ändern, wird alle Typen konservativ mit einem Fußtuch umwickelt, was zu einer langsamen Ausführung führt. </p><br><h4 id="kak-izbezhat-problemy">  So vermeiden Sie ein Problem </h4><br><p>  Es gibt verschiedene Möglichkeiten, um dieses Problem zu vermeiden.  Am einfachsten ist es, Ihre Skripte immer in Funktionen zu verpacken.  Der vorherige Code hat beispielsweise die Form: </p><br><pre> <code class="plaintext hljs">function geta(a) # can also just define a=1 here for i = 1:100 a += a + f(a) end return a end a = geta(1)</code> </pre> <br><p>  Dies führt zu demselben Ergebnis. Da sich der Compiler jedoch auf Typ <code>a</code> spezialisieren kann, wird der gewünschte kompilierte Code bereitgestellt.  Sie können Ihre Variablen auch als Konstanten definieren. </p><br><pre> <code class="plaintext hljs">const b = 5</code> </pre> <br><p>  Auf diese Weise teilen Sie dem Compiler mit, dass sich die Variable nicht ändert, und können so den gesamten Code, der sie verwendet, auf den aktuellen Typ spezialisieren.  Es gibt eine kleine Eigenart, dass Julia es Ihnen tatsächlich erlaubt, den Wert einer Konstante zu ändern, aber keinen Typ.  Daher können Sie <code>const</code> , um dem Compiler mitzuteilen, dass Sie den Typ nicht ändern werden.  Beachten Sie jedoch, dass es einige kleine Macken gibt: </p><br><pre> <code class="plaintext hljs">const a = 5 f() = a println(f()) # Prints 5 a = 6 println(f()) # Prints 5 # WARNING: redefining constant a</code> </pre> <br><p>  Dies funktioniert nicht wie erwartet, da der Compiler, der erkennt, dass er die Antwort auf <code>f () = a</code> kennt (da <code>a</code> eine Konstante ist), einfach den Funktionsaufruf durch die Antwort ersetzt und ein anderes Verhalten ergibt, als wenn <code>a</code> nicht konstant wäre. </p><br><p>  <strong>Moral: Schreiben Sie Ihre Skripte nicht direkt in REPL, sondern verpacken Sie sie immer in eine Funktion.</strong> </p><br><h2 id="nezhdanchik-dva-nestabilnost-tipov">  Nezhdanchik zwei: Typinstabilität </h2><br><p>  Daher habe ich gerade eine Meinung dazu geäußert, wie wichtig die Codespezialisierung für Datentypen ist.  Lassen Sie mich eine Frage stellen, was passiert, wenn sich Ihre Typen ändern können?  Wenn Sie vermutet haben: „In diesem Fall können Sie den kompilierten Code nicht spezialisieren“, haben Sie Recht.  Ein solches Problem ist als Typinstabilität bekannt.  Sie können unterschiedlich aussehen, aber ein häufiges Beispiel ist, dass Sie den Wert mit dem einfachen, aber nicht unbedingt dem Typ initialisieren, der er sein sollte.  Schauen wir uns zum Beispiel an: </p><br><pre> <code class="plaintext hljs">function g() x=1 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  Beachten Sie, dass <code>1/2</code> eine Gleitkommazahl in Julia ist.  Wenn wir also mit <code>x = 1</code> , ändert sich die Ganzzahl in eine Gleitkommazahl, und daher sollte die Funktion die innere Schleife so kompilieren, als ob sie von einem beliebigen Typ sein könnte.  Wenn wir stattdessen hätten: </p><br><pre> <code class="plaintext hljs">function h() x=1.0 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  Dann kann die gesamte Funktion optimal kompiliert werden, da <code>x</code> eine Gleitkommazahl bleibt (diese Fähigkeit des Compilers, Typen zu bestimmen, wird als Typinferenz bezeichnet).  Wir können den kompilierten Code überprüfen, um den Unterschied festzustellen: </p><br><div class="spoiler">  <b class="spoiler_title">Einheimisches Fußtuch</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r13 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $136, %rsp movl $2147565728, %ebx # imm = 0x800140A0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, -152(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -80(%rbp) movq $0, -64(%rbp) vxorps %ymm0, %ymm0, %ymm0 vmovups %ymm0, -128(%rbp) movq $0, -96(%rbp) movq $18, -144(%rbp) movq (%rax), %rcx movq %rcx, -136(%rbp) leaq -144(%rbp), %rcx movq %rcx, (%rax) movq $0, -88(%rbp) Source line: 4 movq %rbx, -104(%rbp) movl $10, %edi leaq 477872(%rbx), %r13 leaq 10039728(%rbx), %r15 leaq 8958904(%rbx), %r14 leaq 64(%rbx), %r12 leaq 10126032(%rbx), %rax movq %rax, -160(%rbp) nopw (%rax,%rax) L176: movq %rbx, -128(%rbp) movq -8(%rbx), %rax andq $-16, %rax movq %r15, %rcx cmpq %r13, %rax je L272 movq %rbx, -96(%rbp) movq -160(%rbp), %rcx cmpq $2147419568, %rax # imm = 0x7FFF05B0 je L272 movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %edx leaq -80(%rbp), %rcx movabsq $jl_apply_generic, %rax vzeroupper callq *%rax movq %rax, -88(%rbp) jmp L317 nopw %cs:(%rax,%rax) L272: movq %rcx, -120(%rbp) movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %r8d leaq -80(%rbp), %rdx movabsq $jl_invoke, %rax vzeroupper callq *%rax movq %rax, -112(%rbp) L317: movq (%rax), %rsi movl $1488, %edx # imm = 0x5D0 movl $16, %r8d movq -152(%rbp), %rcx movabsq $jl_gc_pool_alloc, %rax callq *%rax movq %rax, %rbx movq %r13, -8(%rbx) movq %rsi, (%rbx) movq %rbx, -104(%rbp) Source line: 3 addq $-1, %rdi jne L176 Source line: 6 movq -136(%rbp), %rax movq -152(%rbp), %rcx movq %rax, (%rcx) movq %rbx, %rax addq $136, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r13 popq %r14 popq %r15 popq %rbp retq nop</code> </pre> </div></div><br><p>  gegen </p><br><div class="spoiler">  <b class="spoiler_title">Ordentlicher Assembler-Zauber</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp movabsq $567811336, %rax # imm = 0x21D81D08 Source line: 6 vmovsd (%rax), %xmm0 # xmm0 = mem[0],zero popq %rbp retq nopw %cs:(%rax,%rax)</code> </pre> </div></div><br><p>  Solch ein Unterschied in der Anzahl der Berechnungen, um den gleichen Wert zu erhalten! </p><br><h4 id="kak-nayti-i-spravitsya-s-nestabilnostyu-tipov">  Wie man Typinstabilität findet und damit umgeht </h4><br><p><img src="https://habrastorage.org/webt/92/l8/sn/92l8sno_8hd-dho0limmkwerezs.jpeg"></p><br><p>  An dieser Stelle könnten Sie fragen: "Warum nicht einfach <strong>C verwenden,</strong> damit Sie nicht nach diesen Instabilitäten suchen müssen?"  Die Antwort lautet: </p><br><ol><li>  Leicht zu finden </li><li>  Sie können hilfreich sein. </li><li><p>  Sie können mit Instabilität mit Funktionsbarrieren umgehen </p><br><p>  Julia gibt Ihnen das Makro <code>code_warntype</code> zu zeigen, wo sich <code>code_warntype</code> befinden.  Wenn wir dies beispielsweise in der von uns erstellten <code>g</code> Funktion verwenden: </p><br><pre> <code class="plaintext hljs">@code_warntype g()</code> </pre> <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">Holen Sie sich die Analyse</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Variables: #self#::#g x::ANY #temp#@_3::Int64 i::Int64 #temp#@_5::Core.MethodInstance #temp#@_6::Float64 Body: begin x::ANY = 1 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#@_3::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#@_3::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 30 SSAValue(3) = #temp#@_3::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#@_3::Int64,1)) i::Int64 = SSAValue(3) #temp#@_3::Int64 = SSAValue(4) # line 4: unless (Core.isa)(x::UNION{FLOAT64,INT64},Float64)::ANY goto 15 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Float64, ::Int64) goto 24 15: unless (Core.isa)(x::UNION{FLOAT64,INT64},Int64)::ANY goto 19 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Int64, ::Int64) goto 24 19: goto 21 21: #temp#@_6::Float64 = (x::UNION{FLOAT64,INT64} / 2)::Float64 goto 26 24: #temp#@_6::Float64 = $(Expr(:invoke, :(#temp#@_5), :(Main./), :(x::Union{Float64,Int64}), 2)) 26: x::ANY = #temp#@_6::Float64 28: goto 5 30: # line 6: return x::UNION{FLOAT64,INT64} end::UNION{FLOAT64,INT64}</code> </pre> </div></div><br><p>  Beachten Sie, dass wir am Anfang sagen, dass Typ x <code>Any</code> .  Es wird jeder Typ verwendet, der nicht als <code>strict type</code> bezeichnet ist, dh es handelt sich um einen abstrakten Typ, der bei jedem Schritt eingerahmt / aktiviert werden muss.  Wir sehen, dass wir am Ende <code>x</code> als <code>UNION {FLOAT64, INT64}</code> , was ein weiterer nicht strenger Typ ist.  Dies sagt uns, dass sich Typ <code></code> geändert hat, was zu Schwierigkeiten führt.  Wenn wir stattdessen <code>code_warntype</code> für <code>h</code> , erhalten wir alle strengen Typen: </p><br><pre> <code class="plaintext hljs">@code_warntype h() Variables: #self#::#h x::Float64 #temp#::Int64 i::Int64 Body: begin x::Float64 = 1.0 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 15 SSAValue(3) = #temp#::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#::Int64,1)) i::Int64 = SSAValue(3) #temp#::Int64 = SSAValue(4) # line 4: x::Float64 = (Base.box)(Base.Float64,(Base.div_float)(x::Float64,(Base.box)(Float64,(Base.sitofp)(Float64,2)))) 13: goto 5 15: # line 6: return x::Float64 end::Float64</code> </pre> <br><p>  Dies zeigt an, dass die Funktion typstabil ist und im Wesentlichen zu einem optimalen <em>C-Code kompiliert wird</em> .  Daher ist eine Typinstabilität nicht schwer zu finden.  Schwieriger ist es, das richtige Design zu finden.  Warum Typinstabilität beheben?  Dies ist ein langjähriges Problem, das dazu geführt hat, dass dynamisch typisierte Sprachen das Spielfeld von Skripten dominieren.  Die Idee ist, dass Sie in vielen Fällen einen Kompromiss zwischen Leistung und Zuverlässigkeit finden möchten. </p><br><p>  Sie können beispielsweise eine Tabelle von einer Webseite lesen, auf der Ganzzahlen mit Gleitkommazahlen gemischt sind.  In Julia können Sie Ihre Funktion so schreiben, dass sie gut kompiliert wird, wenn alle Ganzzahlen sind, und wenn alle Gleitkommazahlen sind, auch gut kompiliert.  Und wenn sie gemischt sind?  Dies wird immer noch funktionieren.  Dies ist die Flexibilität / Bequemlichkeit, die wir aus einer Sprache wie <em>Python / R</em> kennen und lieben <em>.</em>  Aber Julia wird Ihnen direkt ( <em>über code_warntype</em> ) <em>mitteilen,</em> wann Sie die Leistung opfern. </p><br><h3 id="kak-spravitsya-s-nestabilnostyami-tipov">  Umgang mit Typinstabilitäten </h3><br><p><img src="https://habrastorage.org/webt/2s/9h/xg/2s9hxgty3fsdvuqf3a6ey05dxzs.png"></p><br><p>  Es gibt verschiedene Möglichkeiten, mit Typinstabilitäten umzugehen.  Wenn Sie etwas wie <em>C / Fortran</em> mögen, bei dem Ihre Typen deklariert sind und sich nicht ändern können (was die Typstabilität gewährleistet), können Sie dies zunächst in Julia tun: </p><br><pre> <code class="plaintext hljs">local a::Int64 = 5</code> </pre> <br><p>  Dies ergibt <code>a</code> 64-Bit-Ganzzahl. Wenn zukünftiger Code versucht, sie zu ändern, wird eine Fehlermeldung generiert (oder die korrekte Konvertierung wird durchgeführt. Da die Konvertierung jedoch nicht automatisch gerundet wird, führt dies höchstwahrscheinlich zu Fehlern).  Streuen Sie sie um Ihren Code und Sie erhalten Typstabilität, ala, <em>C / Fortran</em> .  Eine weniger komplizierte Möglichkeit, dies zu handhaben, sind Typanweisungen.  Hier setzen Sie die gleiche Syntax auf die andere Seite des Gleichheitszeichens.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">a = (b/c)::Float64</code> </pre> <br><p>  Es scheint zu sagen: "Berechnen Sie b / c und stellen Sie sicher, dass die Ausgabe Float64 ist. Wenn dies nicht der Fall ist, versuchen Sie, eine automatische Konvertierung durchzuführen. Wenn die Konvertierung nicht einfach durchgeführt werden kann, geben Sie einen Fehler aus."  Durch das Platzieren solcher Designs können Sie sicherstellen, dass Sie wissen, um welche Typen es sich handelt.  In einigen Fällen ist jedoch eine Typinstabilität erforderlich.  Nehmen wir zum Beispiel an, Sie möchten zuverlässigen Code haben, aber der Benutzer gibt Ihnen etwas Verrücktes, wie: </p><br><pre> <code class="plaintext hljs">arr = Vector{Union{Int64,Float64}}(undef, 4) arr[1]=4 arr[2]=2.0 arr[3]=3.2 arr[4]=1</code> </pre> <br><p>  Dies ist ein Array von 4x1-Ganzzahlen und Gleitkommazahlen.  Der eigentliche Elementtyp für das Array ist <code>Union {Int64, Float64}</code> , was, wie wir bereits gesehen haben, nicht streng war, was zu Problemen führen kann.  Der Compiler weiß nur, dass jeder Wert eine Ganzzahl oder eine Gleitkommazahl sein kann, nicht jedoch welches Element von welchem ​​Typ.  Dies bedeutet, dass es naiv ist, mit diesem Array zu rechnen, zum Beispiel: </p><br><pre> <code class="plaintext hljs">function foo{T,N}(array::Array{T,N}) for i in eachindex(array) val = array[i] # do algorithm X on val end end</code> </pre> <br><p>  wird langsam sein, da die Operationen boxed werden.  Wir können jedoch mehrere Versendungen verwenden, um Codes auf spezielle Weise auszuführen.  Dies wird als Verwendung von Funktionsbarrieren bezeichnet.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">function inner_foo{T&lt;:Number}(val::T) # Do algorithm X on val end function foo2{T,N}(array::Array{T,N}) for i in eachindex(array) inner_foo(array[i]) end end</code> </pre> <br><p>  Beachten Sie, dass beim Aufrufen von <code>inner_foo</code> aufgrund des Mehrfachversands entweder eine speziell für Gleitkommazahlen kompilierte Methode oder eine speziell für Ganzzahlen kompilierte Methode <code>inner_foo</code> .  Auf diese Weise können Sie eine lange Berechnung in <code>inner_foo</code> und trotzdem dafür sorgen, dass sie gut funktioniert, was der strengen Typisierung, die Ihnen die funktionale Barriere bietet, nicht unterlegen ist. </p><br><p>  Daher hoffe ich, dass Sie sehen, dass Julia eine gute Kombination aus starker Tippleistung und dem Komfort des dynamischen Tippens bietet.  Eine gute Programmiererin, Julia, hat beide Möglichkeiten, um die Produktivität und / oder Produktivität bei Bedarf zu maximieren. </p><br><h3 id="nezhdanchik-3-eval-rabotaet-na-globalnom-urovne">  Überraschung 3: Eval funktioniert global </h3><br><p><img src="https://habrastorage.org/webt/vs/5d/p2/vs5dp2t9wel5mbje-ewldc3fxne.jpeg"></p><br><p>  Eine der größten Stärken von Julia ist ihre Metaprogrammierfähigkeit.  Auf diese Weise können Sie problemlos Programme zur Codegenerierung schreiben und so die Menge an Code reduzieren, die Sie schreiben und warten müssen.  Ein Makro ist eine Funktion, die zur Kompilierungszeit ausgeführt wird und (normalerweise) Code ausspuckt.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">macro defa() :(a=5) end</code> </pre> <br><p>  ersetzt jede <code>defa</code> Instanz durch den Code <code>a = 5</code> ( <code>:(a = 5)</code> ist ein <em>Ausdruck in Anführungszeichen</em> . Julias Code besteht aus Ausdrücken, und daher ist die Metaprogrammierung eine Sammlung von Ausdrücken). </p><br><p>  Sie können dies verwenden, um ein beliebiges komplexes Julia-Programm zu erstellen und es in eine Funktion als eine Art wirklich intelligente Verknüpfung einzufügen.  Manchmal müssen Sie den generierten Code jedoch direkt auswerten.  Julia gibt Ihnen dazu eine <code>@eval</code> oder ein <code>@eval</code> <code>eval</code> Makro.  Im Allgemeinen sollten Sie versuchen, eine <code>eval</code> zu vermeiden, aber es gibt einige Codes, in denen dies erforderlich ist, z. B. <a href="">meine neue Bibliothek zum Übertragen von Daten zwischen verschiedenen Prozessen für die parallele Programmierung</a> .  Beachten Sie jedoch Folgendes, wenn Sie es verwenden: </p><br><pre> <code class="plaintext hljs">@eval :(a=5)</code> </pre> <br><p>        (REPL).    ,      / .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) return 2a+5 end</code> </pre> <br><p>     ,   <code>a</code>      REPL.   , ,       : </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) b = a::Int64 return 2b+5 end</code> </pre> <br><p>  <code>b</code> —   ,     ,     , ,  ,          .     <code>eval</code>  ,    ,     <code>REPL</code> . </p><br><h3 id="nezhdanchik-4-kak-razbivat-vyrazheniya">  4:    </h3><br><p>  Julia   ,     .        :    ,    . </p><br><p>  , ?  ,   ,   .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 +8 + 9 + 10+ 11+ 12+ 13 a</code> </pre> <br><p> ,      90,     27. ?  <code>a = 2 + 3 + 4 + 5 + 6 + 7</code>   ,      <code>a = 27</code> ,     <code>+8 + 9 + 10+ 11+ 12+ 13</code> ,   ,    ,    : </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10+ 11+ 12+ 13</code> </pre> <br><p>   90,   .         ,   . </p><br><blockquote>              .   —     ,       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">rssdev10</a> </blockquote><p>       .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">x = rand(2,2) a = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)] b = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) - sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)]</code> </pre> <br><p>     ,  a  b —     ,    !    (2,2) ,   — (1-)   2.  ,   ,    : </p><br><pre> <code class="plaintext hljs">a = [1 -2] b = [1 - 2]</code> </pre> <br><p>      : <code>1</code>  <code>-2</code> .    : <code>1-2</code> .  -     .    : </p><br><pre> <code class="plaintext hljs">a = [1 2 3 -4 2 -3 1 4]</code> </pre> <br><p>    2x4.   ,    .      :        <code>hcat</code> : </p><br><pre> <code class="plaintext hljs">a = hcat(cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi),-sin(2.*x[:,1]).*sin(2.*x[:,2])./(4))</code> </pre> <br><p>  ! </p><br><h3 id="podvodnyy-kamen-5-predstavleniya-kopirovanie-i-glubokaya-kopiya">   №5: ,     </h3><br><p><img src="https://habrastorage.org/webt/wh/xj/8f/whxj8fg_es5hmuoky6ixtzneat0.jpeg"></p><br><blockquote> <strong> (View)</strong> —  () ,     (  ),        . <br><br>       ,       ,   .       ,    .            ,     . </blockquote><p>         —   "". ""     <code></code>    ,     . ""  —      (    ).    (  <em>()</em> ) . ,     : </p><br><pre> <code class="plaintext hljs">a = [3;4;5] b = a b[1] = 1</code> </pre> <br><p>     ,  <code>a</code> —   <code>[1; 4; 5]</code> , . .  <code>b</code>  <code>a</code> .   ,  <code>b = a</code>   <code>b</code>   <code>a</code> .         , ,    <code>b</code> ,    ,          (   <code>b</code>  <code>a</code> ).   ,            . ,        , : </p><br><pre> <code class="plaintext hljs">a = rand(2,2) # Makes a random 2x2 matrix b = vec(a) # Makes a view to the 2x2 matrix which is a 1-dimensional array</code> </pre> <br><p>  <code>b</code>  ,   <code>b</code>    <code>a</code> ,  <code>b</code>    .  ,       ,        ( ,         ).   .  ,          .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">c = a[1:2,1]</code> </pre> <br><p>        <code></code> ( ,  <code>c</code>   <code>a</code> ).     ,   ,      ,   ,   .  ,        , : </p><br><pre> <code class="plaintext hljs">d = @view a[1:2,1] e = view(a,1:2,1)</code> </pre> <br><p>  <code>d</code> ,  <code>e</code> —     ,   <code>d</code>  <code>e</code>  <code>a</code> ,       ,     ,       <code></code> . ( ,   , —  <code>reshape</code> ,     .)     ,   .  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">a[1:2,1] = [1;2]</code> </pre> <br><p>  <code>a</code> ,      <code>a[1:2,1]</code>   <code>view (a, 1:2,1)</code> ,      ,   <code>a</code> .   -? ,     : </p><br><pre> <code class="plaintext hljs">b = copy(a)</code> </pre> <br><p> ,  <code>b</code>   <code>a</code> ,   ,  <code>b</code>   <code>a</code> .     <code>a</code> ,    <code>copy! (B, a)</code>  ,           <code>a</code>   <code>a</code> (   ,  <code>b</code>       ).        . , <code>Vector {Vector}</code> : </p><br><pre> <code class="plaintext hljs">a = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ]</code> </pre> <br><p>   <code></code>  .  ,   ? </p><br><pre> <code class="plaintext hljs">b = copy(a) b[1][1] = 10 a</code> </pre> <br><pre> <code class="plaintext hljs">3-element Array{Array{Int64,1},1}: [10, 2, 3] [4, 5] [6, 7, 8, 9]</code> </pre> <br><p>  ,     <code>a[1][1]</code>  10!   ?   <code>copy</code>    <code>a</code> .   <code>a</code>  ,         <code>b</code> ,  <code>b</code>      .   ,  <code>deepcopy</code> : </p><br><pre> <code class="plaintext hljs">b = deepcopy(a)</code> </pre> <br><p>      ,     .  ,         ,      . </p><br><h3 id="golovnaya-bol-6-vremennye-raspredeleniya-vektorizaciya-i-funkcii-in-place">   №6:  ,    In-Place </h3><br><p>  <em>MATLAB / Python / R</em>    .  Julia , , ,  "  ".    <code> </code> (. .    ,   , ,   ,        ).               (in-place),   .       ?  in-place ( <em>mutable function</em> ) —  ,   ,    .       ,                 . ,   : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x = x + inner(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>   ,   <code>inner</code> ,     ,    <code>2x</code> . ,       .  ,       - <code>y</code> ,      : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] y = Vector{Int64}(3) for i = 1:10 inner(y,x) for i in 1:3 x[i] = x[i] + y[i] end copy!(y,x) end return x end function inner!(y,x) for i=1:3 y[i] = 2*x[i] end nothing end</code> </pre> <br><p>  . <code>inner!(y, x)</code>   ,   <code>y</code> .  <code>y</code>  ,  <code>y</code>     , ,       , <code>inner! (y, x)</code>  <code></code>   <code></code> . ,   ,  mutable (,  "").     <code>!</code>      (   ). </p><br><p>  ,   <code>inner!(y, x)</code>   .    <code>copy!(y, x)</code> —   ,    <code>x</code>  <code>y</code> ,  .  ,  ,       .    :    <code>x</code>     <code>y</code> .       ,   <code>x + inner(x)</code> , ,  ,      11 .     ,     . </p><br><p> ,     ,    ,     .  -     ( <em>loop-fusion</em> ).   Julia v0.5    <code>.</code>      (    ( <em>broadcast</em> ),         <code></code> ).  ,  <code>f.(x)</code> —    ,   <code>f</code>    <code>x</code> ,   ,   .     <code>f</code>  <code>x</code>    ,  <code>x = x + f. (x)</code>   .          : </p><br><pre> <code class="plaintext hljs">x .= x .+ f.(x)</code> </pre> <br><p> <code>.=</code>    ,   ,  ,   </p><br><pre> <code class="plaintext hljs">for i = 1:length(x) x[i] = x[i] + f(x[i]) end</code> </pre> <br><p>  ,       : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x .= x .+ inner.(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>         <em>MATLAB / R / Python</em> ,        , ,  .      <code>  </code> ,     ,  <em>C / Fortran</em> . </p><br><h3 id="vyvod-vyuchite-pravila-poymite-ih-i-kataytes-kak-syr-v-masle"> :  ,         </h3><br><p>   :     ,   .   ,      .  ,        .   ,     ,     .     ,    . </p><br><p>    -   ,      <em>C / Fortran</em> ,           .    -  ,        ,   ! </p><br><p>   :     ?  ,       .  ,  ,       ? [    ,   Javascript   <code>var x = 3</code>  <code>x</code> ,  <code>x = 3</code>  <code>x</code> .    ?     , -       Javascript!] </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443484/">https://habr.com/ru/post/de443484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443472/index.html">Müssen Sie in die Cloud gehen? 7 Tipps, wie man nichts vermasselt</a></li>
<li><a href="../de443476/index.html">Wie SimCity eine ganze Generation von Stadtplanern inspirierte</a></li>
<li><a href="../de443478/index.html">Synthetische und reale Testdaten: Vor- und Nachteile, Fallstricke</a></li>
<li><a href="../de443480/index.html">Kryptografische Token von PKCS # 11: Anzeigen und Exportieren von Zertifikaten, Überprüfen ihrer Gültigkeit</a></li>
<li><a href="../de443482/index.html">AIOps in der Praxis - was kann Huawei FabricInsight</a></li>
<li><a href="../de443486/index.html">ReLEx SMILE: Wie man keine Fehler in Prognosen macht</a></li>
<li><a href="../de443488/index.html">Funktionskomponenten mit React Hooks. Warum sind sie besser?</a></li>
<li><a href="../de443492/index.html">Ein Spiel für Liebhaber und Experten unter Linux</a></li>
<li><a href="../de443494/index.html">Anleitung: Starten des SaaS-Produkts unter AppSumo - Erfolge und einige Fehler</a></li>
<li><a href="../de443498/index.html">Flightradar24 - wie geht das? Teil 2, ADS-B-Protokoll</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>