<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîå üö≥ ‚úä Protokollorientierte Programmierung, Teil 3 üë©üèæ‚Äçüéì üë®üèæ‚Äçüíª ü§¥üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abschlussartikel zur protokollorientierten Programmierung. 


 In diesem Teil werden wir uns ansehen, wie generische Typvariablen gespeichert und kopi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokollorientierte Programmierung, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474830/"><p>  Abschlussartikel zur protokollorientierten Programmierung. </p><br><p>  In diesem Teil werden wir uns ansehen, wie generische Typvariablen gespeichert und kopiert werden und wie die Versandmethode damit arbeitet. </p><a name="habracut"></a><br><h2 id="neobobschennaya-versiya">  Nicht freigegebene Version </h2><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line = <span class="hljs-type"><span class="hljs-type">Line</span></span>() drawACopy(line) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>() drawACopy(point)</code> </pre> <br><p>  Sehr einfacher Code.  <code>drawACopy</code> einen Parameter vom Typ Drawable und ruft dessen Zeichenmethode auf - das ist alles. </p><br><h2 id="obobschennaya-versiya">  Generalisierte Version </h2><br><p>  Schauen wir uns die verallgemeinerte Version des obigen Codes an: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } ...</code> </pre> <br><p>  Nichts scheint sich ge√§ndert zu haben.  Wir k√∂nnen die <code>drawACopy</code> Funktion immer noch als <code>drawACopy</code> Version bezeichnen und nichts weiter, als die interessanteste wie immer unter der Haube. <br>  Generalisierter Code weist zwei wichtige Merkmale auf: </p><br><ol><li>  statischer Polymorphismus (auch als parametrisch bezeichnet) </li><li>  definierter und eindeutiger Typ im Kontext des Aufrufs (generischer Typ T wird zur Kompilierungszeit definiert) </li></ol><br><p>  Betrachten Sie dies mit einem Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { bar(local) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo(point)</code> </pre> <br><p>  Der interessanteste Teil beginnt mit dem Aufruf der Funktion <code>foo</code> .  Der Compiler kennt den Typ des variablen <code>point</code> genau - es ist nur Punkt.  Au√üerdem kann der Compiler auf den Typ T: Drawable in der Funktion <code>foo</code> frei schlie√üen, sobald wir eine Variable des bekannten Point-Typs an diese Funktion √ºbergeben: T = Point.  Alle Typen sind zur Kompilierungszeit bekannt und der Compiler kann all seine wunderbaren Optimierungen durchf√ºhren - das Wichtigste ist, den <code>foo</code> Aufruf inline zu setzen. </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">This</span></span>: ```swift <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point) <span class="hljs-type"><span class="hljs-type">Becomes</span></span> this: ```swift bar&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point)</code> </pre> <br><p>  Der Compiler bettet den <code>foo</code> Aufruf mit seiner Implementierung einfach ein und zeigt auch den generischen Typ des T: Drawable-Balkens an.  Mit anderen Worten, der Compiler bettet zuerst einen Aufruf der foo-Methode mit dem Typ T = Point und dann das Ergebnis der vorherigen Einbettung ein - die Balkenmethode mit dem Typ T = Point. </p><br><h2 id="realizaciya-obobschennyh-metodov">  Implementierung generischer Methoden </h2><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  Intern verwendet <code>drawACopy</code> Swift eine Protokoll-Methodentabelle (die alle Implementierungen der T-Methode enth√§lt) und eine Lebenszyklus-Tabelle (die alle Lebenszyklus-Methoden f√ºr die T-Instanz enth√§lt).  Im Pseudocode sieht das so aus: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T, pwt: T.PWT, vwt: T.VWT)</span></span></span></span> {...} drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>.pwt, <span class="hljs-type"><span class="hljs-type">Point</span></span>.vwt)</code> </pre> <br><p>  VWT und PWT sind assoziierte Typen (AssociatedType) in T - als Typ-Aliase (Typealias) nur besser.  Point.pwt und Point.vwt sind statische Eigenschaften. </p><br><p>  Da in unserem Beispiel T Punkt ist, ist T gut definiert, daher ist die Erstellung eines Containers nicht erforderlich.  In der vorherigen <code>drawACopy</code> Version von <code>drawACopy</code> (local: Drawable) wurde die Erstellung eines existenziellen Containers nach Bedarf durchgef√ºhrt - wir haben dies im zweiten Teil des Artikels untersucht. </p><br><p>  In Funktionen ist aufgrund der Erstellung eines Arguments eine Lebenszyklustabelle erforderlich.  Wie wir wissen, werden Argumente in Swift √ºber Werte und nicht √ºber Verkn√ºpfungen √ºbergeben. Sie m√ºssen daher kopiert werden, und die Kopiermethode f√ºr dieses Argument geh√∂rt wie dieses Argument zur Lebenszyklustabelle.  Dort gibt es auch andere Lifecycle-Methoden: Zuweisen, Zerst√∂ren und Freigeben. </p><br><p>  In generischen Funktionen ist aufgrund der Verwendung von Methoden f√ºr generische Codeparameter eine Lebensdauertabelle erforderlich. </p><br><h2 id="obobschennyy-ili-neobobschennyy">  Verallgemeinert oder nicht verallgemeinert? </h2><br><p>  Stimmt es, dass die Verwendung generischer Typen die Codeausf√ºhrung schneller macht als die Verwendung nur von Protokolltypen?  Ist die generalisierte Funktion <code>func foo&lt;T: Drawable&gt;(arg: T)</code> schneller als ihr protokollartiges Gegenst√ºck <code>fun foo(arg: Drawable)</code> ? </p><br><p>  Wir haben festgestellt, dass generischer Code eine statischere Form des Polymorphismus ergibt.  Es enth√§lt auch Compiler-Optimierungen, die als "Generic Code Specialization" bezeichnet werden.  Mal sehen: </p><br><p>  Wieder haben wir den gleichen Code: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Durch die Spezialisierung einer generischen Funktion wird eine Kopie mit speziellen generischen Typen dieser Funktion erstellt.  Wenn wir beispielsweise <code>drawACopy</code> mit einer Variablen vom Typ Point aufrufen, <code>drawACopy</code> der Compiler eine spezielle Version dieser Funktion - <code>drawACopyOfPoint</code> (local: Point), und wir erhalten: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Point)</span></span></span></span> { local.draw() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Line)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Was kann durch grobe Compileroptimierung davor reduziert werden: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Point</span></span>(...).draw() <span class="hljs-type"><span class="hljs-type">Line</span></span>(...).draw()</code> </pre> <br><p>  Alle diese Tricks sind verf√ºgbar, da generische Funktionen nur aufgerufen werden k√∂nnen, wenn alle generischen Typen definiert sind. In der <code>drawACopy</code> Methode <code>drawACopy</code> generische Typ (T) genau definiert. </p><br><h2 id="obobschennye-hranimye-svoystva">  Generische gespeicherte Eigenschaften </h2><br><p>  Betrachten Sie ein einfaches Strukturpaar: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(fst: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...), snd: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Wenn wir dies auf diese Weise verwenden, erhalten wir 2 Zuordnungen auf dem Heap (die genauen Speicherbedingungen in diesem Szenario wurden im zweiten Teil beschrieben), aber wir k√∂nnen dies mit Hilfe eines verallgemeinerten Codes vermeiden. </p><br><p>  Die generische Version von Pair sieht folgenderma√üen aus: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre> <br><p>  Ab dem Zeitpunkt, an dem der Typ T in der verallgemeinerten Version definiert ist, sind die Eigenschaftstypen <code>fst</code> und <code>snd</code> identisch und werden ebenfalls definiert.  Da der Typ definiert ist, kann der Compiler diesen beiden Eigenschaften eine spezielle Menge an Speicher <code>fst</code> - <code>fst</code> und <code>snd</code> . </p><br><p>  Ausf√ºhrlicher √ºber die spezialisierte Speichermenge: </p><br><p>  Wenn wir mit einer <code>fst</code> Version von <code>Pair</code> , k√∂nnen die Eigenschaftstypen <code>fst</code> und <code>snd</code> gezeichnet werden.  Jeder Typ kann Drawable entsprechen, auch wenn er 10 KB Speicher ben√∂tigt.  Das hei√üt, Swift kann keine Schlussfolgerung √ºber die Gr√∂√üe dieses Typs ziehen und verwendet einen universellen Speicherort, z. B. einen existenziellen Container.  In diesem Container kann jeder Typ aufbewahrt werden.  Im Fall von generischem Code ist der Typ gut erkannt, die tats√§chliche Gr√∂√üe der Eigenschaften ist ebenfalls erkennbar, und Swift kann einen speziellen Speicherort erstellen.  Zum Beispiel (verallgemeinerte Version): </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  Typ T ist jetzt Punkt.  Point ben√∂tigt N Bytes Speicher und in Pair erhalten wir zwei davon.  Swift weist 2 * N Speicher zu und legt dort ein <code>pair</code> . </p><br><p>  Mit der generischen Version von Pair werden unn√∂tige Zuordnungen auf dem Heap vermieden, da Typen leicht erkennbar sind und spezifisch lokalisiert werden k√∂nnen - ohne dass universelle Speichervorlagen erstellt werden m√ºssen, da alles bekannt ist. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><h3 id="1-specializirovannyy-obobschennyy-kod---tipy-znacheniy">  1. Spezialisierter generischer Code - Werttypen </h3><br><p>  hat die beste Ausf√ºhrungsgeschwindigkeit, da: </p><br><ul><li>  Keine Heap-Zuordnung beim Kopieren </li><li>  generischer Code - Sie schreiben eine Funktion f√ºr einen speziellen Typ </li><li>  keine Referenzz√§hlung </li><li>  statische Methode Versand </li></ul><br><h3 id="2-specializirovannyy-obobschennyy-kod---ssylochnye-tipy">  2. Spezialisierter verallgemeinerter Code - Referenztypen </h3><br><p>  Es hat eine durchschnittliche Ausf√ºhrungsgeschwindigkeit, da: </p><br><ul><li>  Zuweisungen pro Heap beim Instanziieren </li><li>  Es gibt eine Referenzz√§hlung </li><li>  dynamische Methoden√ºbermittlung √ºber virtuelle Tabelle </li></ul><br><h3 id="3-nespecializirovannyy-obobschennyy-kod---malenkie-znacheniya">  3. Nicht spezialisierter verallgemeinerter Code - kleine Werte </h3><br><ul><li>  Keine Heap-Zuordnung - Der Wert wird in den Wertpuffer des existenziellen Containers gestellt </li><li>  keine Referenzz√§hlung (da nichts auf den Haufen gelegt wird) </li><li>  dynamischer Methodenversand √ºber Protokoll-Methodentabelle </li></ul><br><h3 id="4-nespecializirovannyy-obobschennyy-kod---bolshie-znacheniya">  4. Nicht spezialisierter verallgemeinerter Code - gro√üe Werte </h3><br><ul><li>  Platzierung auf dem Heap - Der Wert wird in den Wertepuffer gestellt </li><li>  Es gibt eine Referenzz√§hlung </li><li>  dynamischer Versand √ºber Protokoll-Methodentabelle </li></ul><br><p>  Dieses Material bedeutet nicht, dass Klassen schlecht sind, Strukturen gut sind und Strukturen in Kombination mit verallgemeinertem Code die besten sind.  Wir m√∂chten sagen, dass Sie als Programmierer die Verantwortung haben, ein Werkzeug f√ºr Ihre Aufgaben auszuw√§hlen.  Klassen sind wirklich gut, wenn Sie gro√üe Werte behalten m√ºssen und wenn es eine Semantik von Links gibt.  Strukturen eignen sich am besten f√ºr kleine Werte und wenn Sie deren Semantik ben√∂tigen.  Protokolle eignen sich am besten f√ºr generischen Code und Strukturen usw.  Alle Tools sind spezifisch f√ºr die zu l√∂sende Aufgabe und haben positive und negative Seiten. </p><br><p>  Und <strong>zahlen Sie</strong> auch <strong>nicht f√ºr Dynamik, wenn Sie sie nicht brauchen</strong> .  Finden Sie die richtige Abstraktion mit den geringsten Laufzeitanforderungen. </p><br><ul><li>  Strukturtypen - Bedeutungssemantik </li><li>  Klassenarten - Identit√§t </li><li>  verallgemeinerter Code - statischer Polymorphismus </li><li>  Protokolltypen - dynamischer Polymorphismus </li></ul><br><p>  Verwenden Sie den indirekten Speicher, um mit gro√üen Werten zu arbeiten. </p><br><p>  Und vergessen Sie nicht - es liegt in Ihrer Verantwortung, das richtige Werkzeug auszuw√§hlen. <br>  Vielen Dank f√ºr Ihre Aufmerksamkeit zu diesem Thema.  Wir hoffen, dass diese Artikel Ihnen geholfen haben und interessant waren. </p><br><p>  <strong>Viel gl√ºck</strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474830/">https://habr.com/ru/post/de474830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474814/index.html">Altert√ºmer: der Botschafter des Verfalls oder der ungeplanten Veralterung</a></li>
<li><a href="../de474816/index.html">Haustierprojekte - kleines Leben</a></li>
<li><a href="../de474818/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474822/index.html">WISE-PaaS - eine Cloud-Plattform f√ºr das industrielle Internet der Dinge</a></li>
<li><a href="../de474826/index.html">Normale Tabellen in Markdown</a></li>
<li><a href="../de474832/index.html">Funktionsweise der Kryptographie mit elliptischen Kurven in TLS 1.3</a></li>
<li><a href="../de474838/index.html">SIBUR Challenge 2019 - Wettbewerb f√ºr industrielle Datenanalyse</a></li>
<li><a href="../de474840/index.html">Was studieren sie im Fach Data Science an ausl√§ndischen Universit√§ten?</a></li>
<li><a href="../de474842/index.html">Fall: Autoservice. Entwicklung von Werbekampagnen und Implementierung von Bitrix24</a></li>
<li><a href="../de474844/index.html">Dell XPS 13 7390: Ein sehr kompakter Laptop f√ºr alle, die h√§ufig au√üerhalb des B√ºros arbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>