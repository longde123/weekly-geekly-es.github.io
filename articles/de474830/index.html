<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔌 🚳 ✊ Protokollorientierte Programmierung, Teil 3 👩🏾‍🎓 👨🏾‍💻 🤴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abschlussartikel zur protokollorientierten Programmierung. 


 In diesem Teil werden wir uns ansehen, wie generische Typvariablen gespeichert und kopi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokollorientierte Programmierung, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474830/"><p>  Abschlussartikel zur protokollorientierten Programmierung. </p><br><p>  In diesem Teil werden wir uns ansehen, wie generische Typvariablen gespeichert und kopiert werden und wie die Versandmethode damit arbeitet. </p><a name="habracut"></a><br><h2 id="neobobschennaya-versiya">  Nicht freigegebene Version </h2><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line = <span class="hljs-type"><span class="hljs-type">Line</span></span>() drawACopy(line) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>() drawACopy(point)</code> </pre> <br><p>  Sehr einfacher Code.  <code>drawACopy</code> einen Parameter vom Typ Drawable und ruft dessen Zeichenmethode auf - das ist alles. </p><br><h2 id="obobschennaya-versiya">  Generalisierte Version </h2><br><p>  Schauen wir uns die verallgemeinerte Version des obigen Codes an: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } ...</code> </pre> <br><p>  Nichts scheint sich geändert zu haben.  Wir können die <code>drawACopy</code> Funktion immer noch als <code>drawACopy</code> Version bezeichnen und nichts weiter, als die interessanteste wie immer unter der Haube. <br>  Generalisierter Code weist zwei wichtige Merkmale auf: </p><br><ol><li>  statischer Polymorphismus (auch als parametrisch bezeichnet) </li><li>  definierter und eindeutiger Typ im Kontext des Aufrufs (generischer Typ T wird zur Kompilierungszeit definiert) </li></ol><br><p>  Betrachten Sie dies mit einem Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { bar(local) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo(point)</code> </pre> <br><p>  Der interessanteste Teil beginnt mit dem Aufruf der Funktion <code>foo</code> .  Der Compiler kennt den Typ des variablen <code>point</code> genau - es ist nur Punkt.  Außerdem kann der Compiler auf den Typ T: Drawable in der Funktion <code>foo</code> frei schließen, sobald wir eine Variable des bekannten Point-Typs an diese Funktion übergeben: T = Point.  Alle Typen sind zur Kompilierungszeit bekannt und der Compiler kann all seine wunderbaren Optimierungen durchführen - das Wichtigste ist, den <code>foo</code> Aufruf inline zu setzen. </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">This</span></span>: ```swift <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point) <span class="hljs-type"><span class="hljs-type">Becomes</span></span> this: ```swift bar&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point)</code> </pre> <br><p>  Der Compiler bettet den <code>foo</code> Aufruf mit seiner Implementierung einfach ein und zeigt auch den generischen Typ des T: Drawable-Balkens an.  Mit anderen Worten, der Compiler bettet zuerst einen Aufruf der foo-Methode mit dem Typ T = Point und dann das Ergebnis der vorherigen Einbettung ein - die Balkenmethode mit dem Typ T = Point. </p><br><h2 id="realizaciya-obobschennyh-metodov">  Implementierung generischer Methoden </h2><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  Intern verwendet <code>drawACopy</code> Swift eine Protokoll-Methodentabelle (die alle Implementierungen der T-Methode enthält) und eine Lebenszyklus-Tabelle (die alle Lebenszyklus-Methoden für die T-Instanz enthält).  Im Pseudocode sieht das so aus: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T, pwt: T.PWT, vwt: T.VWT)</span></span></span></span> {...} drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>.pwt, <span class="hljs-type"><span class="hljs-type">Point</span></span>.vwt)</code> </pre> <br><p>  VWT und PWT sind assoziierte Typen (AssociatedType) in T - als Typ-Aliase (Typealias) nur besser.  Point.pwt und Point.vwt sind statische Eigenschaften. </p><br><p>  Da in unserem Beispiel T Punkt ist, ist T gut definiert, daher ist die Erstellung eines Containers nicht erforderlich.  In der vorherigen <code>drawACopy</code> Version von <code>drawACopy</code> (local: Drawable) wurde die Erstellung eines existenziellen Containers nach Bedarf durchgeführt - wir haben dies im zweiten Teil des Artikels untersucht. </p><br><p>  In Funktionen ist aufgrund der Erstellung eines Arguments eine Lebenszyklustabelle erforderlich.  Wie wir wissen, werden Argumente in Swift über Werte und nicht über Verknüpfungen übergeben. Sie müssen daher kopiert werden, und die Kopiermethode für dieses Argument gehört wie dieses Argument zur Lebenszyklustabelle.  Dort gibt es auch andere Lifecycle-Methoden: Zuweisen, Zerstören und Freigeben. </p><br><p>  In generischen Funktionen ist aufgrund der Verwendung von Methoden für generische Codeparameter eine Lebensdauertabelle erforderlich. </p><br><h2 id="obobschennyy-ili-neobobschennyy">  Verallgemeinert oder nicht verallgemeinert? </h2><br><p>  Stimmt es, dass die Verwendung generischer Typen die Codeausführung schneller macht als die Verwendung nur von Protokolltypen?  Ist die generalisierte Funktion <code>func foo&lt;T: Drawable&gt;(arg: T)</code> schneller als ihr protokollartiges Gegenstück <code>fun foo(arg: Drawable)</code> ? </p><br><p>  Wir haben festgestellt, dass generischer Code eine statischere Form des Polymorphismus ergibt.  Es enthält auch Compiler-Optimierungen, die als "Generic Code Specialization" bezeichnet werden.  Mal sehen: </p><br><p>  Wieder haben wir den gleichen Code: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Durch die Spezialisierung einer generischen Funktion wird eine Kopie mit speziellen generischen Typen dieser Funktion erstellt.  Wenn wir beispielsweise <code>drawACopy</code> mit einer Variablen vom Typ Point aufrufen, <code>drawACopy</code> der Compiler eine spezielle Version dieser Funktion - <code>drawACopyOfPoint</code> (local: Point), und wir erhalten: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Point)</span></span></span></span> { local.draw() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Line)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Was kann durch grobe Compileroptimierung davor reduziert werden: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Point</span></span>(...).draw() <span class="hljs-type"><span class="hljs-type">Line</span></span>(...).draw()</code> </pre> <br><p>  Alle diese Tricks sind verfügbar, da generische Funktionen nur aufgerufen werden können, wenn alle generischen Typen definiert sind. In der <code>drawACopy</code> Methode <code>drawACopy</code> generische Typ (T) genau definiert. </p><br><h2 id="obobschennye-hranimye-svoystva">  Generische gespeicherte Eigenschaften </h2><br><p>  Betrachten Sie ein einfaches Strukturpaar: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(fst: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...), snd: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Wenn wir dies auf diese Weise verwenden, erhalten wir 2 Zuordnungen auf dem Heap (die genauen Speicherbedingungen in diesem Szenario wurden im zweiten Teil beschrieben), aber wir können dies mit Hilfe eines verallgemeinerten Codes vermeiden. </p><br><p>  Die generische Version von Pair sieht folgendermaßen aus: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre> <br><p>  Ab dem Zeitpunkt, an dem der Typ T in der verallgemeinerten Version definiert ist, sind die Eigenschaftstypen <code>fst</code> und <code>snd</code> identisch und werden ebenfalls definiert.  Da der Typ definiert ist, kann der Compiler diesen beiden Eigenschaften eine spezielle Menge an Speicher <code>fst</code> - <code>fst</code> und <code>snd</code> . </p><br><p>  Ausführlicher über die spezialisierte Speichermenge: </p><br><p>  Wenn wir mit einer <code>fst</code> Version von <code>Pair</code> , können die Eigenschaftstypen <code>fst</code> und <code>snd</code> gezeichnet werden.  Jeder Typ kann Drawable entsprechen, auch wenn er 10 KB Speicher benötigt.  Das heißt, Swift kann keine Schlussfolgerung über die Größe dieses Typs ziehen und verwendet einen universellen Speicherort, z. B. einen existenziellen Container.  In diesem Container kann jeder Typ aufbewahrt werden.  Im Fall von generischem Code ist der Typ gut erkannt, die tatsächliche Größe der Eigenschaften ist ebenfalls erkennbar, und Swift kann einen speziellen Speicherort erstellen.  Zum Beispiel (verallgemeinerte Version): </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  Typ T ist jetzt Punkt.  Point benötigt N Bytes Speicher und in Pair erhalten wir zwei davon.  Swift weist 2 * N Speicher zu und legt dort ein <code>pair</code> . </p><br><p>  Mit der generischen Version von Pair werden unnötige Zuordnungen auf dem Heap vermieden, da Typen leicht erkennbar sind und spezifisch lokalisiert werden können - ohne dass universelle Speichervorlagen erstellt werden müssen, da alles bekannt ist. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><h3 id="1-specializirovannyy-obobschennyy-kod---tipy-znacheniy">  1. Spezialisierter generischer Code - Werttypen </h3><br><p>  hat die beste Ausführungsgeschwindigkeit, da: </p><br><ul><li>  Keine Heap-Zuordnung beim Kopieren </li><li>  generischer Code - Sie schreiben eine Funktion für einen speziellen Typ </li><li>  keine Referenzzählung </li><li>  statische Methode Versand </li></ul><br><h3 id="2-specializirovannyy-obobschennyy-kod---ssylochnye-tipy">  2. Spezialisierter verallgemeinerter Code - Referenztypen </h3><br><p>  Es hat eine durchschnittliche Ausführungsgeschwindigkeit, da: </p><br><ul><li>  Zuweisungen pro Heap beim Instanziieren </li><li>  Es gibt eine Referenzzählung </li><li>  dynamische Methodenübermittlung über virtuelle Tabelle </li></ul><br><h3 id="3-nespecializirovannyy-obobschennyy-kod---malenkie-znacheniya">  3. Nicht spezialisierter verallgemeinerter Code - kleine Werte </h3><br><ul><li>  Keine Heap-Zuordnung - Der Wert wird in den Wertpuffer des existenziellen Containers gestellt </li><li>  keine Referenzzählung (da nichts auf den Haufen gelegt wird) </li><li>  dynamischer Methodenversand über Protokoll-Methodentabelle </li></ul><br><h3 id="4-nespecializirovannyy-obobschennyy-kod---bolshie-znacheniya">  4. Nicht spezialisierter verallgemeinerter Code - große Werte </h3><br><ul><li>  Platzierung auf dem Heap - Der Wert wird in den Wertepuffer gestellt </li><li>  Es gibt eine Referenzzählung </li><li>  dynamischer Versand über Protokoll-Methodentabelle </li></ul><br><p>  Dieses Material bedeutet nicht, dass Klassen schlecht sind, Strukturen gut sind und Strukturen in Kombination mit verallgemeinertem Code die besten sind.  Wir möchten sagen, dass Sie als Programmierer die Verantwortung haben, ein Werkzeug für Ihre Aufgaben auszuwählen.  Klassen sind wirklich gut, wenn Sie große Werte behalten müssen und wenn es eine Semantik von Links gibt.  Strukturen eignen sich am besten für kleine Werte und wenn Sie deren Semantik benötigen.  Protokolle eignen sich am besten für generischen Code und Strukturen usw.  Alle Tools sind spezifisch für die zu lösende Aufgabe und haben positive und negative Seiten. </p><br><p>  Und <strong>zahlen Sie</strong> auch <strong>nicht für Dynamik, wenn Sie sie nicht brauchen</strong> .  Finden Sie die richtige Abstraktion mit den geringsten Laufzeitanforderungen. </p><br><ul><li>  Strukturtypen - Bedeutungssemantik </li><li>  Klassenarten - Identität </li><li>  verallgemeinerter Code - statischer Polymorphismus </li><li>  Protokolltypen - dynamischer Polymorphismus </li></ul><br><p>  Verwenden Sie den indirekten Speicher, um mit großen Werten zu arbeiten. </p><br><p>  Und vergessen Sie nicht - es liegt in Ihrer Verantwortung, das richtige Werkzeug auszuwählen. <br>  Vielen Dank für Ihre Aufmerksamkeit zu diesem Thema.  Wir hoffen, dass diese Artikel Ihnen geholfen haben und interessant waren. </p><br><p>  <strong>Viel glück</strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474830/">https://habr.com/ru/post/de474830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474814/index.html">Altertümer: der Botschafter des Verfalls oder der ungeplanten Veralterung</a></li>
<li><a href="../de474816/index.html">Haustierprojekte - kleines Leben</a></li>
<li><a href="../de474818/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474822/index.html">WISE-PaaS - eine Cloud-Plattform für das industrielle Internet der Dinge</a></li>
<li><a href="../de474826/index.html">Normale Tabellen in Markdown</a></li>
<li><a href="../de474832/index.html">Funktionsweise der Kryptographie mit elliptischen Kurven in TLS 1.3</a></li>
<li><a href="../de474838/index.html">SIBUR Challenge 2019 - Wettbewerb für industrielle Datenanalyse</a></li>
<li><a href="../de474840/index.html">Was studieren sie im Fach Data Science an ausländischen Universitäten?</a></li>
<li><a href="../de474842/index.html">Fall: Autoservice. Entwicklung von Werbekampagnen und Implementierung von Bitrix24</a></li>
<li><a href="../de474844/index.html">Dell XPS 13 7390: Ein sehr kompakter Laptop für alle, die häufig außerhalb des Büros arbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>