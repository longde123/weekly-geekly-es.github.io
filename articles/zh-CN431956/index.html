<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏻 👶 👌 逻辑，可解释性和未来理解 🖲️ 🐁 👩🏻‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="与逻辑有关的发现 
 逻辑是许多事物的基础。 但是逻辑本身的基础是什么？ 

 在符号逻辑中，引入了诸如p和q之类的符号来表示“这是一篇有趣的文章”类型的陈述（或“命题”）。 仍然存在某些逻辑规则，例如，对于任何p和任何q，表达式NOT（p AND q）类似于（NOT p）或（NOT q）。 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>逻辑，可解释性和未来理解</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431956/"><h3> 与逻辑有关的发现 </h3><br> 逻辑是许多事物的基础。 但是逻辑本身的基础是什么？ <br><br> 在符号逻辑中，引入了诸如p和q之类的符号来表示“这是一篇有趣的文章”类型的陈述（或“命题”）。 仍然存在某些逻辑规则，例如，对于任何p和任何q，表达式NOT（p AND q）类似于（NOT p）或（NOT q）。 <br><br> 但是这些“逻辑规则”从何而来？ 逻辑是一个形式系统。 像欧几里得几何一样，它可以在公理上构建。 但是什么是公理？ 您可以从诸如p AND q = q AND p或NOT NOT p = p之类的语句开始。 但是需要多少个公理？ 它们有多简单？ <br><br> 这个问题长期以来一直很痛苦。 但是，在2000年1月29日星期日20:31，唯一的公理出现在我的计算机屏幕上。 我已经表明，没有什么比这更简单了，但是我很快就确定，这个单一的小公理足以创建所有逻辑： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/426/b76/8a5426b76ec6ff73e4b9f521f1e66764.png"></div><a name="habracut"></a><br> 我怎么知道她是真的？ 因为我让计算机证明了这一点。 这是我在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新型科学</a> ”一书（已在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram数据存储库中提供</a> ）中打印的证明： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/d9f/11e/9c7d9f11e1cb651d7bfbe6b4edad66dd.png"></div><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最新版本的</a> Wolfram语言，任何人都可以在不超过一分钟的时间内<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生成</a>此证明。 而且他的每一步都很容易<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">验证</a> 。 但是，为什么结果是正确的呢？ 怎么解释呢？ <br><br> 关于与机器学习和AI相关的各种计算系统和应用程序的类似问题正日益被提出。 是的，我们看到正在发生的事情。 但是我们能理解吗？ <br><br> 我认为这个问题具有内在的深刻意义-对于科学技术的未来以及所有智力发展的未来至关重要。 <br><br> 但是在谈论这个之前，让我们讨论一下我发现的公理。 <br><br><h2> 故事 </h2><br> 作为正式学科的逻辑来自生活在公元前4世纪的亚里斯多德。 作为对事物（动物，原因等）进行分类的一生工作的一部分，亚里斯多德汇编了允许的参数形式目录，并为它们创建了符号模板，从本质上讲，这提供了两千年来逻辑学的主要内容。 <br><br> 但是，到了15世纪，代数才被发明出来，随之而来的是事物的清晰画面。 但是直到1847年，乔治·布尔终于以与代数相同的方式制定了逻辑，并进行了诸如“与”或“或”之类的逻辑运算，并根据与代数规则相似的规则进行运算。 <br><br> 几年后，人们已经在为逻辑编写公理系统。 一个典型的例子是： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/f83/b05/1b7f83b053013cbb17e8a3e3f9734097.png"></div><br> 但是逻辑上是否真的需要AND，OR和逻辑吗？ 在20世纪的前十年之后，几个人发现我们现在称为NAND的唯一运算就足够了，例如，p OR q可以计算为（p NAND p）NAND（q NAND q）。 如果不是为了半导体技术的发展，NAND的“功能完整性”将永远是奇怪的-它使用仅执行NAND功能或相关NOR的晶体管的组合，在现代微处理器中实现了数十亿个逻辑运算。 <br><br> 好吧，那么关于NAND的逻辑公理是什么样的呢？ 这是它们的第一个已知版本，由Henry Schaeffer在1913年记录（此处的点表示NAND）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fd/af7/5d1/2fdaf75d1c346bb2d8c3c4d470ffcd68.png"></div><br>  1910年，阿尔弗雷德·怀特黑德（Alfred North Whitehead）和贝特朗·罗素（Bertrand Russell）撰写的有关逻辑逻辑和哲学的三卷著作《原理数学》（Principia Mathematica）推广了一种思想，即所有数学都可以从逻辑推论得出。 鉴于此，研究逻辑公理可以多么简单的问题非常有趣。 该领域最重要的工作是在利沃夫和华沙（当时这些城市是波兰的一部分）进行的，特别是扬·卢卡塞维奇（由于他在1920年所做的工作，他发明了不需要支架的“波兰”唱片）。  1944年，年仅66岁的卢卡斯维奇（Lukasevich）从前进的苏联军队逃离，并于1947年到达爱尔兰。 <br><br> 同时，在温彻斯特和剑桥学习并在剑桥成为数学老师的爱尔兰人卡鲁·梅雷迪思（Caure Meredith）在1939年因其和平主义而被迫返回爱尔兰。  1947年，Meredith参加了在都柏林举行的Lukasevich演讲，这启发了他寻找简单的公理，这是他一生中大部分时间都做的。 <br><br> 到1949年，梅勒迪斯（Meredith）发现了两个公理系统： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/237/0cf/7a8/2370cf7a8b94b221152f17f905223919.png"></div><br> 将近20年后的1967年，他能够将其简化为： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/ba1/89c/245ba189c20baf7290fde8e6164b1050.png"></div><br> 有可能进一步简化吗？ 梅雷迪思（Meredith）多年来一直在进行修改，以找出其他可以删除多余NAND的地方。 但是在1967年之后，他不再前进（并于1976年去世），尽管在1969年他发现了一个三公理系统： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/552/dcd/650552dcd498bb69a243af9ca9373091.png"></div><br> 当我开始研究逻辑公理系统时，我对Meredith的工作一无所知。 我对这个主题很感兴趣，这是尝试理解简单规则可能会导致的行为的一部分。 在1980年代，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">意外地发现</a> ，即使具有最简单的规则（例如，我最喜欢的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规则30）的元</a>胞自动机也可能导致难以置信的复杂行为。 <br><br> 在1990年代尝试理解这种现象的普遍性之后，我最终想知道如何将其应用于数学。 实际上，在数学中，我们开始使用公理（例如，在算术，几何，逻辑中），然后在它们的基础上尝试证明整套复杂的定理。 <br><br> 但是，公理有多简单？ 那就是我想在1999年建立的。 作为第一个示例，我决定研究逻辑（或者等效地，布尔代数）。 驳斥我的所有期望，我在元胞自动机，图灵机和其他系统（甚至包括偏微分方程）上的经验表明，您可以简单地列出最简单的情况，并在某些时候看到一些东西。有趣。 <br><br> 但是有可能以这种方式“开放逻辑”吗？ 只有一种说法。 在1999年底，我安排了一切，从最简单的开始，开始探索所有可能的公理系统的空间。 <br><br> 从某种意义上说，任何公理系统都定义一组约束，例如，在p·q上。 她没有说p·q是什么，她只给出p·q必须满足的属性（例如，她可以说q·p = p·q）。 接下来的问题是，是否有可能从这些性质中推导当p·q为Nand [p，q]时成立的所有逻辑定理：不多也不少。 <br><br> 可以直接验证某些内容。 我们可以采用公理系统，看看如果p和q为真和假，则p·q满足哪种形式的公理。 如果公理系统是q·p = p·q，则可以，p·q可以是Nand [p，q]-但不一定。 它也可以是And [p，q]或Equal [p，q]，或其他不满足与NAND功能逻辑相同级别的其他选项。 但是到了到达公理系统{{（（p·p）·q）·（q·p）= q}时，我们到达了Nand [p，q]（和Nor [p ，q]）仍然是唯一有效的p·q模型-至少在我们假设q和p只有两个可能值的情况下。 <br><br> 那么这是一个逻辑公理系统吗？ 不行 因为这意味着例如存在一个变体，其中p和q具有三个值，但这在逻辑上不存在。 但是，这个来自一个公理的公理体系与我们所需要的体系很接近，这一事实表明，有必要寻找一个可以从中复制逻辑的公理。 这正是我在2000年1月所做的（由于Wolfram语言分组功能相当新且非常方便，在我们这个时代，这项任务得到了简化。） <br><br> 验证3个或更少的NAND（或“点运算符”）的公理不起作用是很容易的。 在1月29日星期日凌晨5点（是的，那时我是一只猫头鹰），我发现包含4个NAND的公理也不起作用。 当我早上6点左右停止工作时，我手中有14位候选人和五个NAND。 但是在星期天晚上继续工作并进行其他测试，我不得不全部放弃。 <br><br> 不用说，下一步就是检查具有6 NAND的公理。 其中有288,684个，但是我的代码有效地工作了，并且在屏幕上出现以下内容之前没花太多时间（是的，来自Mathematica版本4）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb1/eb6/b59/cb1eb6b59aa53f1cc55cc91c2ec76271.png"></div><br> 起初我不明白自己做了什么。 我只知道我有6个NAND的25个非等价公理，比5个NAND的公理更进一步。 但是其中是否存在产生逻辑的公理？ 我有一种经验方法能够丢弃不必要的公理。 但是，要确定一个特定公理的正确性的唯一方法是证明它能够成功复制例如Schaeffer的逻辑公理。 <br><br> 这些程序花了点时间，但是几天后，我发现收到的25个公理中的大多数都无效。 结果，有两个幸存下来： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f1/a4a/5e0/6f1a4a5e040e1acbd2e14406b8a05eff.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/311/20f/394/31120f394c33c0d1c95c0d22ee9caf45.png"></div><br> 令我高兴的是，我能够使用一台计算机证明这两者都是逻辑公理。 使用的技术保证了没有简单的逻辑公理。 因此，我知道我已经达到了目标：经过一个世纪（或几千年）的搜索，我们终于可以说我们找到了最简单的逻辑公理。 <br><br> 不久之后，我发现了两个带有6个NAND的公理的系统，正如我证明的那样，它们能够重现逻辑： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/311/d22/7b9311d22392f15be81d05b43df9861c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/920/f41/3e1/920f413e173d5e9c859b580d27eb3819.png"></div><br> 如果将交换性p·​​q = q·p视为理所当然，则可以从仅包含4个NAND的公理中获得逻辑。 <br><br><h2> 为什么这很重要 </h2><br> 好吧，可以说有人“完成了亚里斯多德开始的工作”（或者至少是布尔），并且发现了最简单的逻辑公理系统，这很酷。 这仅仅是a头，还是这个事实会产生重要的后果？ <br><br> 在我以“新型科学”开发平台之前，我认为很难将这一事实视为好奇心。 但是现在应该清楚的是，它与各种各样的基本问题有关，例如数学应该被认为是发现还是发明。 <br><br> 人们所做的数学基于少数几个公理系统-每个公理定义一个特定的数学领域（逻辑，组论，几何，集合论）。 但是抽象地讲，存在着无数个公理系统-每个公理都定义了一个数学领域，即使人们还没有学习，也可以进行研究。 <br><br> 在《新科学》一书之前，我显然是说，计算宇宙中“某个地方”存在的一切都应该比人们创造和研究的东西“有趣”。 但是我对简单程序的发现表明，简单地“在某个地方”的系统比人们精心选择的系统具有更多的可能性。 <br><br> 那么数学公理系统呢？ 为了将现有的“某个地方”与人们研究的内容进行比较，您需要知道公理系统是否适合我们研究的数学领域。 而且，基于人们创建的传统系统，我们可以得出结论，它们必须位于非常非常远的地方-通常，只有在您已经知道自己在哪里的情况下，才能找到它们。 <br><br> 但是我对公理系统的发现回答了一个问题：“逻辑有多远？” 对于像细胞自动机这样的事物，很容易就可以对所有可能的细胞自动机进行编号（就像我在1980年代所做的那样）。 使用公理系统很难做到这一点-但不是很多。 在一种方法中，我的公理可以表示为411; 3; 7; 118-或用Wolfram语言表示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/315/5d5/ef0/3155d5ef0d85da9df2a25e407c617625.png"></div><br> 并且，至少在可能的函数形式（不考虑变量标记）的空间中，有一个关于该公理位置的直观表示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/e6c/eb2/bb2e6ceb2b5a36d51e32d16727e89ef9.png"></div><br> 考虑到逻辑对于人们研究的大量形式系统的根本重要性，人们会认为逻辑以任何合理的表示形式都对应于最简单的公理系统之一。 但是，至少在使用NAND的演示中，事实并非如此。 对于她来说，仍然有一个非常简单的公理系统，但是如果您仅从最简单的一个公理开始对公理系统进行编号，则可能会从所有可能的公理中找到十万个公理。 <br><br> 鉴于此，显而易见的下一个问题将是：公理的所有其他系统又如何？ 他们的行为如何？  《新型科学》一书探讨的就是这个问题。 我在其中肯定，自然界中观察到的系统之类的东西最经常用这些“其他规则”来最好地描述，我们可以通过对可能性进行编号来找到它们。 <br><br> 至于公理系统，我做了一张图片，表示与各种公理系统相对应的“数学领域”中发生的事情。 该系列显示了某个公理系统的结果，并且方框表明了给定公理系统中某个定理的真相（是的，在某些时候， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">哥德尔定理</a>开始生效，在此之后，在给定的公理系统中证明或反证给定定理变得非常困难；实际上，根据我的方法，这种情况发生在图片所示位置的右边。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/56f/8e5/62756f8e5e47459b575ad148feacee99.png"></div><br> 人们已经“探索”的数学领域在本质上有什么特别之处吗？ 从这些图片和其他图片来看，没有什么明显的想到。 我怀疑这些区域只有一个功能-研究它们的历史事实。  （您可以发表诸如“它们描述了现实世界”或“与大脑工作方式有关的陈述，但书中描述的结果却相反”）。 <br><br> 那么，我的公理系统对逻辑的意义是什么？ 它的大小使您感受到作为公理系统的逻辑的最终信息内容。 而且，这使我们至少在目前如此认为，我们需要将逻辑更多地视为“人发明的构造”，而不是因“自然原因”而发生的“发现”。 <br><br> 如果故事发生了变化，并且我们将不断搜索（如书中所述）许多可能的最简单的公理系统，则我们可能会“打开”逻辑公理系统，例如我们发现其性质有趣的系统。 但是，由于我们研究了这么少的所有可能的公理系统，因此我认为将逻辑视为“发明”（一种特殊创建的结构）是合理的。 <br><br> 从某种意义上说，在中世纪，逻辑看起来像是-当可能的三段论（可接受的论据类型）以拉丁助记符的形式（如bArbArA和cElErAnt）表示时。 因此，现在有趣的是找到我们现在所知道的最简单的逻辑公理系统的助记符表示。 <br><br> 从（（p·q）·r）·（p·（（p·r）·p））= r开始，每个p·q都可以表示为前缀或波兰语条目（与HP计算器的“波兰语反向条目”相反） ）以Dpq的形式-因此，整个公理可以表示为= DDDpqrDpDDprpr。 关于此主题还有一个英语助记符-Figure OuT Queue，其中角色p，q，r由u，r，e扮演。 或者，您也可以查看以下句子中的单词的首字母（其中B是运算符，而p，q，r是a，p，c）：“一点一点，程序计算了布尔代数的最佳二进制公理，涵盖了所有情况” [通过程序计算出的布尔代数的最佳二进制公理逐渐描述了所有情况]。 <br><br><h2> 证明力学 </h2><br> 好的，那么您如何证明我的公理系统的正确性？ 首先想到的是，证明有可能从中得出著名的逻辑公理系统-例如，Schaeffer公理系统： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/54a/161/b5f54a161b3ff941c7459003cd9dffd9.png"></div><br> 这里有三个公理，我们需要推导每个公理。 这是使用最新版本的Wolfram语言输出第一项内容的方法： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47b/f3e/10c/47bf3e10c7a79db3328816c3ff931a68.png"></div><br> 值得注意的是，现在已经可以做到这一点。 在“证据对象”中，记载了54个步骤用于证据。 基于此对象，我们可以生成描述每个步骤的“笔记本”： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/b12/0f3/b2db120f3a2bd50432ed16525ca72342.png"></div><br> 通常，这里证明了中间引理的整个序列，这使我们可以得出最终结果。 在引理之间有相互依存的整个网络： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc1/272/d6f/dc1272d6fd14710be4e2a49ec684efa8.png"></div><br> 但是在Scheffer公理系统中推导所有三个公理所涉及的网络-对于后者，使用了令人难以置信的504步： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/0e5/d15/c330e5d159782e0d4cff4931f2b9f605.png"></div><br> 是的，很明显，这些网络令人困惑。 但是，在讨论这种复杂性意味着什么之前，让我们先讨论一下此证据的每个步骤会发生什么。 <br><br> 主要思想很简单。 想象我们有一个简单地写成p·q = q·p的公理（从数学上讲这意味着算子是可交换的）。 更准确地说，公理说，对于任何表达式p和q，p·q等于q·p。 <br><br> 好吧，假设我们要根据这个公理推论（a·b）·（c·d）=（d·c）·（b·a）。 可以使用公理将d·c转换为c·d，b·a转换为a·b，最后将（c·d）·（a·b）转换为（a·b）·（c·d ） <br><br> 尽管FindEquationalProof并没有按照完全相同的顺序执行这些步骤，但它实际上执行了相同的操作，并且更改了等式的左侧和右侧。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f4/f43/f6b/9f4f43f6b97bb816052eeb50ec01dcb2.png"></div><br> 收到此类证明后，您可以简单地跟踪每个步骤并验证它们是否给出了规定的结果。 但是如何找到证据呢？ 排列和变换有许多可能的顺序。 如何找到成功地带来最终结果的序列？ <br><br> 一个人可以决定：为什么不尝试所有可能的序列，并且如果其中有一个有效的序列，那么最终应该找到它？<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题在于您可以快速得出天文数字的序列。</font><font style="vertical-align: inherit;">自动证明定理的现有技术包括寻找减少验证序列数量的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这很快会涉及到技术细节，但是如果您了解代数的基础知识，那么基本概念很容易讨论。</font><font style="vertical-align: inherit;">假设我们正在尝试证明一个代数结果，例如</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc0/402/9b6/fc04029b6fa134be318b5b9999d0beeb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有一种可靠的方法可以做到这一点：只需应用代数规则来揭示每一面，就可以立即看到它们的相似性： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c93/6e3/5b0/c936e35b0bf0addb94eece9e2379f15f.png"></div><br> 为什么行得通？<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为有一种使用此类表达式的方法，所以可以系统地将它们简化为标准格式。是否可以在任意公理系统中执行相同的操作？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是马上。在代数中，这是有效的，因为它具有特殊的属性，可确保您始终可以在简化表达式的路径上“移动”。但是在1970年代，不同的科学家几次独立地发现（以Knuth-Bendix算法或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gröbner为基础的名称</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），即使公理系统没有必要的内部特性，也有可能在该系统中发现“附加”。有。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是FindEquationalProof（基于Valdmeister的系统，“树木大师”）提供的典型证据中发生的情况。</font><font style="vertical-align: inherit;">有所谓 </font><font style="vertical-align: inherit;">“关键对引理”不直接推动证明，但使出现能够做到这一点的路径成为可能。</font><font style="vertical-align: inherit;">由于尽管我们想要得到的最终表达式很短，但在走向它的过程中，您可能必须经历更长的中间表达式，所以一切都很复杂。</font><font style="vertical-align: inherit;">因此，例如，第一个谢弗公理的证明具有以下中间步骤：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/c98/287/b0fc98287cfb9bb8968eea6664aaa0ec.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这种情况下，最大的步骤是原始公理的4倍： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdd/885/774/cdd885774255091503fdb07d55fd8b0b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的表达式可以表示为树。</font><font style="vertical-align: inherit;">与原始公理的树相比，这是他的树：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/465/f16/a7f465f1661555adf78695f71ea4fb8c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这就是在每个舍弗公理的证明过程中，中间步骤的大小如何发展： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/ba7/c59/5d2ba7c5933f2d3d77b0b8acfb594020.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为什么这么难？ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难怪这一证据如此复杂？</font><font style="vertical-align: inherit;">不是真的，真的。</font><font style="vertical-align: inherit;">毕竟，我们深知数学可能很复杂。</font><font style="vertical-align: inherit;">原则上，数学中的所有真相都可能易于证明。</font><font style="vertical-align: inherit;">但是，哥德尔1931年定理的副作用之一是，即使那些有证据的事物，通往它们的道路也可能任意长。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是更为普遍的现象的征兆，我称之为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算不可约性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">考虑一个受细胞自动机简单规则控制的系统（当然，在我的任何论文中，总会存在细胞自动机）。</font><font style="vertical-align: inherit;">运行该系统。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/f6e/5b2/511f6e5b21afb7a21c62622cab036fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以确定，如果系统基于简单规则，则应该有一种快速的方法来了解系统的功能。</font></font>但是事实并非如此。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据我</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的计算等价原理，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统的操作通常对应于计算，其复杂度与我们为理解系统行为而可以进行的任何计算都一致。这意味着，系统的实际行为实际上对应于这样的计算工作量，原则上不能减少。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于上面的图片：假设我们要找出模式最后是否消失。我们可以继续实现它，如果幸运的话，它最终将退化为某种事物，其命运将显而易见。但是，总的来说，实际上我们花多少时间在证明上没有上限。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当类似的事情在逻辑上发生时，它的发生则有所不同。我们询问是否有一种方法可以通过遵循几个步骤来达到某个特定的结果，而每个步骤都必须遵循某个特定的规则，而不是根据某些规则开始工作。作为实际的计算任务，该任务要复杂得多。但是复杂性的本质是相同的计算不可约现象，这种现象表明没有通用的方法可以简要地研究系统将要做什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毋庸置疑，世界上有很多事情-尤其是在技术和科学建模以及各种形式的规则领域中-传统上是为了避免计算不可约而设计的，并且为了使其工作结果立即可见而工作，无需进行不可简化的计算。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，我的计算等价原理的后果之一是这些情况是奇异且不自然的-他认为，计算不可约性存在于计算宇宙的所有系统中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那数学呢？</font><font style="vertical-align: inherit;">也许是专门选择了数学规则来证明计算可简化性。</font><font style="vertical-align: inherit;">在某些情况下是这种情况（从某种意义上说，这也在逻辑上发生）。</font><font style="vertical-align: inherit;">但是在大多数情况下，似乎数学公理的系统对于所有可能的公理系统的空间并不是非典型的，在这些空间中，计算不可约性不可避免。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为什么我们需要证据？ </font></font></h2><br> 从某种意义上说，需要证明才能知道某件事的真相。 当然，尤其是在我们这个时代，证据已经逐渐淡出背景，让位于纯计算。 在实践中，通过计算生成某种事物的愿望比“退一步”并构建某种事物的真实性的愿望更为普遍。 <br><br> 但是，在纯数学中，通常必须处理至少在名义上包括无数种情况（“对所有素数都是正确的”等）的额头计算将不起作用的概念。 。 并且当出现确认问题时（“该程序会以错误结尾吗？”还是“我可以两次使用这种加密货币？”）尝试证明这一点比计算所有可能的情况更为合理。 <br><br> 但是，在实际的数学实践中，证明不仅仅是建立真理。 当Euclid撰写他的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Beginnings</a> ”时，他只是指出结果，然后“留给读者”。 但是，一种或另一种方式，尤其是在上个世纪，证据已变成不仅在幕后发生的事情，而且是传播概念的主要媒介。 <br><br> 在我看来，由于历史的怪癖，今天提供的证据是人们应该理解的对象，程序被视为计算机应该执行的东西。 为什么会这样呢？ 好吧，至少在过去，证据可以文本形式呈现-因此，如果有人使用过，则只有人。 而且程序几乎总是以计算机语言的形式记录的。 并且很长一段时间以来，创建这些语言的目的是使它们可以或多或少地直接转换为低级计算机操作-也就是说，计算机可以立即理解它们，但人们不必这么做。 <br><br> 但是，过去几十年来我工作的主要目标之一是改变这种状况，并以Wolfram语言开发一种真正的“计算通信语言”，在其中可以传输计算思想，以便计算机和人们可以理解它们。 <br><br> 这种语言有很多后果。 其中之一是改变证据的作用。 假设我们看一些数学结果。 过去，唯一能使人们理解的方法就是提供人们阅读的证据。 但是现在又有可能了：您可以为Wolfram Language给出一个计算结果的程序。 在许多方面，这是传达结果真实性的更丰富的方法。 程序的每个部分都是精确而明确的-每个人都可以启动它。 没有试图理解文本某些部分的问题，需要填补一些空白。 一切都在文本中明确指出。 <br><br> 那证据呢？ 是否有任何清晰准确的证据撰写方式？ 可能是的，尽管这并不是特别容易。 尽管Wolfram语言基金会已经成立了30年，但直到今天，才出现一种合理的方法来用它提供结构简单明了的证据，例如我上面提到的一个公理。 <br><br> 您可以想象使用Wolfram语言创建证据的方式与人们创建程序的方式相同-我们正在努力提供“帮助证据”的高级功能版本。 但是，没有人创建我的公理系统的证据-计算机找到了它。 这更像是程序的输出，而不是程序本身。 但是，从某种意义上说，就像程序一样，证明也可以“运行”以验证结果。 <br><br><h2> 创造清晰度 </h2><br> 大多数时候，使用Wolfram语言或Wolfram | Alpha的人们都想数一数。 他们需要得到结果，而不是为什么才得到这样的结果。 但是在Wolfram | Alpha中，尤其是在数学和化学等领域，学生中的一个流行功能是构建“逐步”解决方案。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/a19/015/77da190153b5c78394653c8bdee8bb98.png"></div><br> 例如，当Wolfram | Alpha系统计算积分时，它将使用为接收答案而优化的各种强大的算法技术。 但是，当要求她显示计算的各个阶段时，她会做其他事情：她需要逐步解释为什么这是获得的结果。 <br><br> 解释如何实际获得结果将没有任何好处； 对于人类来说，这是一个非常不合适的过程。 她需要了解可以将人们学到的哪些操作用于获取结果。 她经常想出一些有用的把戏。 是的，她有系统地执行此操作的方法，该方法始终有效。 但是其中有太多的“机械”阶段。 在一般情况下，“技巧”（替代，部分集成等）将不起作用，但是在这种特定情况下，它将提供一种更快的答案。 <br><br> 如何获得其他事物的清晰版本？ 例如，一般情况下程序的工作。 或我的公理系统的证据。 <br><br> 让我们从程序开始。 假设我们写了一个程序，想解释一下它是如何工作的。 传统方法之一是在代码中包含注释。 如果我们使用传统的低级语言编写，这可能是最好的出路。 但是Wolfram语言作为一种计算交流语言的全部实质是，该语言本身应该允许思想的传播，而无需包含其他文本。 <br><br> 必须努力使Wolfram语言程序对过程进行良好的描述，并使纯英文文本对过程进行良好的描述。 但是，您可以获得一段Wolfram语言代码，该代码非常清楚地解释了一切如何独立运行。 <br><br> 当然，经常会发生这样的情况，即代码的实际执行导致明显不符合程序要求的事情。 我将很快提到一些极端情况，例如细胞自动机。 但是现在，让我们想象一下，我们已经创建了一个程序，通过它我们可以想象它通常会做什么。 <br><br> 在那种情况下，我发现以Wolfram Notebooks呈现的计算论文是解释正在发生的事情的好工具。  Wolfram语言很重要，这使您可以单独运行程序的最小部分（使用相应的符号表达式作为输入和输出数据）。 之后，您可以将程序的步骤序列想象为构成计算笔记本基础的对话元素序列。 <br><br> 实际上，通常有必要创建输入和输出数据的可视化。 是的，一切都可以表达为明确的符号表示。 但是，比起任何一维类似语言的线条，人们更容易理解事物的视觉表示。 <br><br> 当然，创建良好的可视化效果类似于艺术。 但是在Wolfram Language，我们做了很多工作来使这种艺术自动化，通常是在相当复杂的机器学习和其他算法（例如网络或图形元素的布局）的帮助下进行的。 <br><br> 从简单的程序跟踪开始怎么办？ 这很难做到。 我已经对此进行了数十年的尝试，但从未对结果完全满意。 是的，您可以放大并查看正在发生的事情的许多细节。 但是我没有找到足够好的技术来理解整个画面，并自动给出一些特别有用的东西。 <br><br> 在某种程度上，该任务类似于逆向工程。 会显示给您机器代码，芯片电路等等。 您需要退后一步，并重新创建该人员排斥的高级描述，该人员以某种方式“汇编”为您看到的内容。 <br><br> 在传统的工程方法中，当人们分步创建产品时，总是能够预见其创建的结果，因此该方法原则上可以起作用。 但是，如果相反地，您只是在计算领域中徘徊以寻找最佳程序（正如我在寻找可能的公理系统来寻找逻辑系统一样），则不能保证该程序背后将有任何“人类历史”或解释。 <br><br> 自然科学中也遇到类似的问题。 您将看到生物系统中复杂的各种过程集如何发展。 是否可以对他们进行“逆向工程”以找到“解释”？ 有时可以说，自然选择的进化会导致这种情况。 或者它经常在计算领域中发现，因此它发生的可能性很高。 但是，不能保证自然界必须经过精心设计，以便人们可以对其进行解释。 <br><br> 自然地，在对事物建模时，我们不可避免地会只考虑我们感兴趣的方面，并将其他所有方面理想化。 特别是在像医学这样的领域，您通常必须使用带有浅决策树的近似模型，这很容易解释。 <br><br><h2> 可解释性的性质 </h2><br>  “可以解释的东西”是什么意思？ 从本质上讲，这意味着人们可以理解它。 <br><br> 人们需要什么才能理解某些东西？ 我们需要以某种方式意识到这一点。 以具有复杂行为的典型细胞自动机为例。 计算机没有任何问题，可以经历其发展的每个步骤。 通过巨大的努力和劳动，一个人可以重现计算机的工作。 <br><br> 但是不能说在这种情况下，一个人会“理解”细胞自动机的作用。 为此，人们将不得不轻易地从高水平谈论细胞自动机的行为。 或者，换句话说，一个人应该能够“讲述一个故事”，讲述别人可以理解的自动机的行为。 <br><br> 有通用的方法可以做到这一点吗？ 否，由于计算的不可约性。 但是，可能会发生某些局限性，从高层次上解释对人们重要的某些功能。 <br><br> 如何运作？ 为此，您需要创建某种特定的高级语言来描述我们感兴趣的功能。 在研究细胞自动机的典型图时，人们可以试着不是用大量单个细胞的颜色说话，而是可以检测到更高层次的结构说话。 最主要的是，您至少可以编译此类结构的部分目录：尽管会有很多细节不适合分类，但是某些结构是常见的。 <br><br> 而且，如果我们要开始“解释”细胞自动机的行为，我们将从命名结构开始，然后从这些结构的角度讨论正在发生的事情。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b79/395/b3b/b79395b3bad1a1a63252ad645d54cc4b.png"></div><br> 元胞自动机的情况有一个简化的特征：由于它是根据简单的确定性规则进行操作的，因此具有相同的重复结构。 例如，在自然界中，我们通常不会遇到相同的重复。 只有一只，例如一只老虎，与另一只非常相似，因此尽管它们的原子排列不同，我们都将它们称为“老虎”。 <br><br> 这一切的一般含义是什么？ 它包括使用符号表示的思想。 我们说我们可以分配一个特定的符号-通常是这个词-可以用来象征性地描述整个事物类别，而不必详细列出这些事物的所有组成部分的每个细节。 <br><br> 这类似于信息压缩：我们使用符号构造来找到一种简短的方式来描述我们感兴趣的事物。 <br><br> 假设我们生成了一个巨大的结构，例如一个数学结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/923/5ac/27d9235ac9fd46bd22ef8c526e0afbc6.png"></div><br> 第一步是创建某种高级内部表示形式。 例如，我们可以检测可重用的结构。 我们可以给他们起名字。 然后在他们的帮助下显示整个结构的“骨架”： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/102/c89/ba2102c898a14c573ddd207694fd5696.png"></div><br> 是的，该方案类似于“字典压缩”，对于达到可解释性的第一层很有用。 <br><br> 但是，让我们回到我的公理系统的证明。 在该证明中创建的引理是专门选择为可重用元素的。 但是，除了它们之外，我们仍然留下人们无法立即理解的证据。 <br><br> 你还能做什么？ 我们需要提出一个更高层次的描述。 可能是什么？ <br><br><h2> 概念的概念 </h2><br> 如果您想向某人解释某些事情，那么如果您发现其他事情，但这样做可能会容易得多，但是其他人已经可以理解。 想象一下，您将如何向石器时代的人解释现代无人机的概念。 很难做到。 但是，将其解释给50年前已经看过直升机和飞机模型的人，要容易得多。 <br><br> 最后，最重要的是，当我们解释某事时，我们会以一种既对我们又向被解释者所熟悉的语言进行操作。 语言越丰富，为了传达我们试图解释的内容，我们必须引入的新元素就越少。 <br><br> 在整个思维过程中都有一种重复的模式。 某些事物被多次注意。 逐渐地，他们开始理解这些事物在某种程度上抽象地相似，并且所有这些事物都可以用一个新概念来描述，该新概念用某个新词或短语来描述。 <br><br> 假设我们注意到水，血液和油之类的东西。 在某种程度上，我们了解到存在一个广义的“液体”概念，所有这些都可以描述为液体。 当我们有了这样一个概念时，我们可以开始用它的术语进行推理，找到更多的概念，例如基于它的粘度。 <br><br> 什么时候将事物组合成一个概念有意义？ 如果不预见使用此概念可以完成的所有工作，就无法回答这个难题。 在实践中，在一个人的语言和思想发展的过程中，观察到一定程度的逐次逼近过程。 <br><br> 在现代机器学习系统中，信息的求和要快得多。 想象一下，我们带走了世界各地的各种对象，并向它们提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FeatureSpacePlot</a>函数以查看会发生什么。 如果我们在特征空间中获得某些聚类，则可以得出结论，可以将每个聚类定义为与某个“概念”相对应，例如可以用单词标记。 <br><br> 坦白说，在人类智力发展的过程中，FeatureSpacePlot发生的事情在某种意义上是逐步的过程。 要按要素空间分配对象，FeatureSpacePlot使用从先前的分类尝试中学习到的要素中提取。 <br><br> 好吧，如果我们按原样接受世界，那么可以用来描述事物的最佳类别或概念是什么？ 这个问题在不断发展。 通常，所有突破（无论是科学，技术还是其他方面的突破）通常都与实现以有用的方式识别新类别或概念的可能性紧密相关。 <br><br> 但是，在我们文明发展的过程中，存在一定的螺旋。 首先，定义一个确定的概念-比方说，一个程序的想法。 之后，人们开始使用它并对其进行反思。 很快，在此概念的基础上建立了许多不同的概念。 然后确定另一个抽象级别，根据前一个概念创建新概念。 <br><br> 历史是现代文明的技术知识集及其知识性知识集的特征。 那里到处都有概念的塔和抽象的层次接连不断。 <br><br><h2> 学习问题 </h2><br> 为了使人们可以使用某种概念进行交流，他们需要了解这一点。 而且，是的，人们仅通过观察自然就可以自动识别某些概念（例如对象的恒定性）。 但是假设，如果您看一下现代英语的常用单词列表，将会很清楚地看到，我们现代文明使用的大多数概念不适用于人们了解自己，观察自然的那些概念。 <br><br> 相反，这使人想起现代机器学习，他们需要对“受监督”的世界有特殊的了解，这些知识的组织是为了强调某些概念的重要性。 在更抽象的领域（例如数学），他们可能需要以直接抽象的形式遇到概念。 <br><br> 是的，但是随着积累的文明知识的不断增长，我们是否需要一直学习越来越多的知识？ 可能令人担心的是，在某些时候我们的大脑将无法跟上发展的步伐，我们将不得不增加一些额外的帮助。 但是在我看来，幸运的是，这些问题可以“在软件级别”解决。 <br><br> 问题是这样的：在历史的任何时刻，都有一定的概念对这一时期的世界至关重要。 并且，是的，随着文明的发展，新概念被揭示并且新概念被引入。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，还有另一个过程：新概念引入了新的抽象级别，通常包括大量较早的概念。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们经常可以在技术上观察到这一点。曾经有一段时间，您需要了解许多底层细节才能在计算机上工作。但是随着时间的流逝，这些细节被抽象化了，所以现在您只需要一个通用的概念。您单击图标，该过程即开始-您无需了解操作系统，中断处理程序，调度程序和所有其他详细信息的复杂性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，Wolfram语言提供了一个很好的例子。它花费大量精力来自动化许多底层细节（例如，应使用哪种算法），并允许用户思考高层概念。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是的，仍然需要了解抽象基础的细节的人员（尽管我不确定现代社会需要多少切石机）。但是在大多数情况下，教育可以集中在高水平的知识上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常认为，为了在学习过程中获得高级概念，一个人必须首先以某种方式总结这些概念在历史上如何成为历史。但是通常-也许总是-事实并非如此。您可以举一个极端的例子：想象一下，要学习如何使用计算机，您必须首先阅读整个数学逻辑的历史。但是，实际上众所周知，人们无需研究某种历史就可以立即转向现代计算概念。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，概念网络的清晰度最终看起来像什么？是否存在只能通过理解其他概念才能理解的概念？给定基于与环境交互（或训练神经网络）的人员训练，他们的秩序可能存在。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是在我看来，某种类似于计算的普遍性的原则表明，只要手头“纯脑子”，您就可以从任何地方开始。</font><font style="vertical-align: inherit;">因此，如果某些外星人会学习类别理论，而几乎没有别的东西，他们无疑会建立一个以该理论为根基的概念网络，我们将从中研究算术基础类似于我们研究所的某个地方。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，这样的外星人可以以与我们完全不同的方式来构建他们的技术和环境-就像如果计算机能够在19世纪而不是20世纪中期成功开发那样，我们的故事可能会完全不同。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数学进展 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我经常反思数学的历史轨迹在多大程度上受机会的作用以及在何种程度上不可避免。正如我已经提到的，在形式系统的层次上，有许多可能的公理系统，您可以在它们上构建形式上类似于数学的东西。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，数学的真实历史并非始于任意的公理体系。它始于巴比伦人的时代，尝试将算术用于商业，并将几何用于土地开发。从这些实际的根源开始，增加了后续的抽象层次，最终导致了现代数学的发展。例如，数字逐渐从正整数到有理数，再到根，再到所有整数，十进制小数，复数，再到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代数数字</font></font></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,   . <br><br>       ? ,    , . ,          .   ,      ,              –       ,   ,   - . <br><br>       ?         .    ,     .         –  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  ,  <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03C0;</mi><msqrt><mn>163</mn></msqrt></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.092ex" height="2.78ex" viewBox="0 -1091.4 2623.1 1197.1" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhiyzQYCHOXoRXLJppQCdcsRxSuc7w#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,362)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhiyzQYCHOXoRXLJppQCdcsRxSuc7w#MJMATHI-3C0" x="0" y="0"></use><g transform="translate(405,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhiyzQYCHOXoRXLJppQCdcsRxSuc7w#MJMAIN-221A" x="0" y="26"></use><rect stroke="none" width="1061" height="42" x="589" y="543"></rect><g transform="translate(589,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhiyzQYCHOXoRXLJppQCdcsRxSuc7w#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhiyzQYCHOXoRXLJppQCdcsRxSuc7w#MJMAIN-36" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhiyzQYCHOXoRXLJppQCdcsRxSuc7w#MJMAIN-33" x="1001" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mi>π</mi><msqrt><mn>163</mn></msqrt></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1">e^{\pi \sqrt{163}}</script><br><br><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以一种可以对公理系统进行编号的方式，可以想象数学中可能存在的问题的编号。但这立即引起了问题。哥德尔定理指出，在诸如与算术相关的公理系统中，存在着“形式上不可解的”定理，这些定理无法在该公理系统的框架内得到证明或证明。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，哥德尔创建的具体示例似乎与数学课中可能出现的情况相去甚远。长期以来，人们一直认为，从某种意义上说，不可解决的现象在某种程度上是存在的，但与“真实的数学”无关。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，根据我的计算等价原理和我在计算领域的经验，我很确定事实并非如此-实际上，即使在典型的数学中，不可解性也非常接近。如果今天尚未解决的数学问题的有形部分（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riemann假设</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，P = NP等）证明是不可</font><font style="vertical-align: inherit;">解决的，我不会感到惊讶</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果周围存在许多不可解决的问题，那么如何成功解决数学中的那么多问题呢？我认为这是因为选择成功解决问题的方法是为了避免无法解决，这仅仅是因为数学的发展是如何建立的。因为，实际上，如果我们根据已经证明的概念形成连续的抽象级别，那么我们正在铺平前进的道路而不会变成不溶性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，实验数学或“随机问题”可以立即将我们引向一个无法解决的领域。但是，至少到目前为止，数学的基础学科还没有以这种方式发展。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些“数学的随机事实”又如何呢？是的，与其他智力研究领域一样。直到围绕它们建立了某种结构（通常是一些抽象概念）之后，“随机事实”才被包括在智力发展的道路上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个很好的例子是我最喜欢的这种系统中复杂性起源的发现，通常是30个细胞自动机。是的，甚至在数千年前就已经观察到类似现象（例如，素数序列中的随机性）。但是，如果没有更广泛的概念平台，很少有人会关注它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个例子是嵌套序列（分形）。有一些例子说明了它们如何在十三世纪的马赛克中相遇，但是直到1980年代，没有人注意到它们，整个平台围绕分形出现了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的故事一遍又一遍地重复：直到定义了抽象概念，即使面对新的概念也很难谈论新概念。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我怀疑在数学中就是这种情况：某些抽象概念在某些抽象概念之上必然存在一定的分层，这决定了数学的发展道路。这种方式独特吗？毫无疑问，不。在可能的数学事实的广阔空间中，为进一步的构造选择了某些方向。但是您可以选择其他人。</font></font><br><br>   ,        ?   ,     .  –   ,      ,    ,     –   ,               . <br><br> ,  -       ,    :    ( «»),     , ,        –             . <br><br><h2>      </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回到逻辑证明。它们与典型数学有何关系？到目前为止，没有办法。是的，证明的名义上与标准数学证明的形式相同。但这不是“对数学人友好的”。这些只是机械零件。它与人类数学可以理解的高级抽象概念无关。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们发现非平凡的证明引理已经出现在数学文献中，那将对我们有很大帮助（我不认为是这样，但是我们通过定理进行搜索的可能性尚未达到可以确定的水平）。但是，如果它们出现了，它可能会给我们一种将这些引理与数学中其他事物联系起来并定义它们的抽象概念圈的一种方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果没有这一点，如何使证据可以解释呢？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许还有其他方法可以进行证明，从根本上讲，它与现有的数学关系更紧密。但是即使有了我们现在已有的证据，也可以想象“尝试”新概念，这些概念将定义更高的抽象级别，并将此证明置于更一般的上下文中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不确定如何执行此操作。我当时正在考虑提名一个奖项（类似于我的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2007年图灵奖</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）以“将证据转化为可理解的形式”。但是，如何评估“可解释性”是完全不可理解的。可能会要求您录制一个小时的视频，其中会成功地给出证明的解释，适用于典型的数学家，但这将是非常主观的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，就像可以自动搜索漂亮的网络布局一样，也许我们可以自动化将证据变为可解释的过程。实际上，目前的证明毫无解释地建议考虑数百个引理。但是假设我们可以定义少量的“有趣”引理。也许我们可以以某种方式将它们添加到我们的著名数学经典中，然后我们可以使用它们来理解证明。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与语言的发展类比。通过创建Wolfram语言，我尝试确定人们经常需要的“计算工作”。我们从这些语言创建内置于语言中的函数，并使用特定名称供人们用来引用它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在自然语言的发展过程中，尽管没有那么有组织地进行着类似的过程。最终变得有用的“意义部分”最终获得了该语言的用词。有时，它们以包含几个现有单词的短语开头。但是，最有影响力的词通常都与现有词相距甚远，以新词的形式出现，这可能很难定义。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开发使用英文单词调用其功能的Wolfram语言时，我依赖于一个人对英语的一般理解（有时还取决于对通用计算机应用程序中使用的单词的理解）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在确定要添加到数学规范中的引理时，必须做类似的事情。不仅要确保每个引理在某种程度上都是“本质上有趣的”，而且有必要从现有的数学概念和结果中选择“易于推论”的引理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，什么使引理“本质上很有趣”？必须说，在我写书之前，我将罪魁祸首（或塔楼）归咎于教科书中描述和命名的任何数学领域，极大的专横性和历史性事故。</font></font><br><br> ,      ,  ,    . ,            <br> ( , p = p  , p AND p = p –  ,  ..).      .       ,     . <br><br>    ,   ,      ,    .  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  14</a> ,  ,  ,   ,         ( AND –  ∧, OR  ∨,  NOT  ¬.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/078/057/a0007805787992eee313fa748deba866.png"></div><br>  ,    ,  «»    ,        . ,     -      ,     ,   ,   ,   –     ,     . <br><br>    NAND, , ,    ? -,       ,  ,           : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/4b3/022/3a84b3022c9b5408ce524671b006c814.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NAND没有AND，OR和NOT这样的历史传统。并且，显然，没有人类语言用一个词来表示NAND。但是在NAND定理列表中，上面的第一个很容易被认为是NAND的可交换性。之后，仅需几句翻译即可为其命名：a =（a·a）·（a·a）就像是双重否定，a =（a·a）·（a·b）就像</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吸收定律</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，（a ·A）·b =（a·b）·b类似于“弱化”，依此类推。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，如果我们要学习一些NAND逻辑的“关键定理”，那么这些定理应该是什么样的？也许这些应该是证明中的“流行引理”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，任何定理可能都有许多可能的证明。但是假设我们将仅使用FindEquationalProof产生的证据。然后证明，在前一千个NAND定理的证明中，最流行的引理是a·a = a·（（a·a）·a），后跟（a·（（a·a）·a））类型的引理。 a（a（（（a a）a））））= a。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些引理是什么？它们对于FindEquationalProof使用的方法很有用。但是对于人们来说，它们似乎不太适合。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么引理短的引理呢？ a·b = b·a绝对不是最受欢迎的，而是最短的。 （a·a）·（a·a）= a更受欢迎，但更长。然后有（a·a）·（b·a）= a的引理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些引理将有多大用处？这是验证这一点的一种方法。让我们看一下前一千个NAND定理，并评估加引理如何缩短这些定理的证明（至少是FindEquationalProof找到的证明）：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/2f6/5d5/5492f65d5a0b28d9b2ad56e910d4a673.png"></div><br> a · b = b · a  ,       100 . (a · a) · (a · a) = a   ;    «  » FindEquationalProof,    ,   (   ). (a · a) · (b · a) = a    ,    ,  a · b = b · a. ,     a · b = b · a,     . <br><br>   , ,   ,            .    ,     « »  a · b = b · a  (a · a) · (b · a) = a,      –  ,  ,   «». <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/410/c0e/5c5410c0e4690236d76c45f5e32e53f3.png"></div><br><h2>    ? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有多种建模方法。几百年来，精确的科学一直被发现数学方程式的思想所主导，可以通过求解数学方程式来显示系统的行为。但是自从我的书问世以来，已经朝着创建可以运行以查看系统运行方式的程序进行了积极的转变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时，此类程序是为特定任务编写的；有时会搜索很长时间。并且在我们这个时代，至少一类这样的程序是使用机器学习通过逆向运动方法从系统行为的已知示例中得出的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些不同类型的建模“理解正在发生的事情”有多容易？找到数学方程式的“精确解”是一个很大的优势-然后可以用精确的数学公式描述系统的行为。但是，即使不是这样，通常也可以写下一些抽象到足以与其他系统和行为相关的数学语句。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如我在上面所写，使用程序（例如蜂窝自动机），一切都可能有所不同。经常发生的情况是，我们立即遇到了计算不可约性，这限制了我们走近距离并“解释”正在发生的事情的能力。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器学习和神经网络又如何呢？从某种意义上说，神经网络训练就像对自然科学中的归纳搜索的简要总结。我们正在尝试从示例开始，推断出系统行为模型。但是，然后可以理解该模型吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，计算不可约性也存在问题。但是，让我们讨论一个案例，在该案例中我们可以想象一下情况如何，在此情况下我们可以了解正在发生的情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看使用神经网络模拟系统行为，而不是使用神经网络来模拟系统行为：例如，拍摄图像并根据其内容（“船”，“长颈鹿”等）进行分配。当我们训练神经网络时，它会学习产生正确的输出。但是您可以将这个过程想象为一系列差异的内部构造（类似于“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二十个问题</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">的游戏</font><font style="vertical-align: inherit;">），最终确定正确的结论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是这些区别是什么？有时我们可以认出他们。例如，“图片中有很多蓝色吗？”但是大多数时候，这些是世界上人们并不注意到的某些特性。也许还有另类的自然科学史，其中有些会被证明是。但是它们不是当前感知或分析标准的一部分。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们想添加它们，那么也许我们会想出它们的名称。但是这种情况类似于有逻辑证据的情况。自动系统创建了一些东西，将其用作里程碑来生成结果。但是我们不认识这些里程碑，它们对我们没有任何意义。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，如果我们发现在神经网络中经常发现某些特定的差异，则可以认为它们值得我们自己研究，并将它们添加到描述世界的标准方法中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们能期望少数这样的差异使我们创造出有意义的东西吗？似乎问题是，少量定理是否可以帮助我们理解诸如逻辑证明之类的问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为答案尚不清楚。例如，如果您学习大量的数学科学著作，则可以提出各种定理使用频率的问题。事实证明，这些定理的频率几乎完全符合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zipf定律</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（并且首先会有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中心极限定理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐函数</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Tonelli-Fubini定理</font></a><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">对于“值得了解”的差异或“值得了解”的新定理，可能也会发生同样的情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几个定理的知识将使我们有足够的机会进一步发展，但是总会有无限的指数尾巴，而且我们也不会走到尽头。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 知识的未来 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习数学，科学或技术，您会看到类似的定性发展基本路径，其中包括建立一组不断增加的抽象。</font><font style="vertical-align: inherit;">量化这个过程将是很好的。</font><font style="vertical-align: inherit;">也许可以计算出在较高抽象级别中如何同时包含经常发现的某些术语或描述，新的术语或描述又会与它们联系在一起。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用诸如图灵机之类的正式计算模型，可以创建此过程的理想模型。想象一下，在最低级别上有一台没有抽象的基本图灵机。现在，假设我们根据一些特定的随机过程为此Turing机器选择程序。然后，我们运行这些程序并进行分析，以查看哪种“较高”计算水平的模型可以成功重现这些程序的联合行为，而不必在每个程序中执行每个步骤。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以断定，计算不可约将导致以下事实：创建此更高级别的计算模型将不可避免地更加复杂。但是关键是我们只试图重现程序的联合行为，而不是它们的单独行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果这个过程一遍又一遍地重复，再现了人类理想化的思想史，并创造了越来越高的抽象塔，会发生什么呢？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">据推测，这里我们可以对物理学中的关键现象和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重归一化群</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法进行类比</font><font style="vertical-align: inherit;">。如果是这样，我们可以想象我们可以确定平台空间中代表概念的轨迹。这条轨迹会做什么？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在历史上的任何时候，如果有大约相同数量的值得研究的概念（可能是固定价值），新概念会慢慢开放，旧概念会被吸收。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这对数学意味着什么？</font><font style="vertical-align: inherit;">例如，凭经验发现的任何“随机数学事实”最终将在达到一定抽象水平时加以考虑。</font><font style="vertical-align: inherit;">对于此过程的工作原理没有明显的了解。</font><font style="vertical-align: inherit;">的确，在任何抽象层次上，总有一些新的经验事实必须被人们跳到上面。</font><font style="vertical-align: inherit;">可能还会发生“提高抽象级别”移动得比这些“跳转”所需的速度慢。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 理解的未来 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这一切对将来的理解意味着什么？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过去，人们学习自然时，只有很少的理由来理解自然。有时，他们以神灵或神灵的形式将其某些方面拟人化。但是他们接受了它的原样，而不是考虑了解过程原因的所有细节的可能性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着现代科学的到来-尤其是当我们越来越多的生命用于由我们开发的技术主导的人造环境中时，这些期望已经改变。而且当我们研究由AI执行的计算时，我们不喜欢我们可能不理解它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，在我们世界的系统和大脑根据其行为可以计算出的结果之间始终存在竞争。如果我们决定只与在计算能力上比大脑简单得多的系统进行交互，那么我们可以期望我们可以系统地了解它们在做什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果我们要使用宇宙中所有可用的计算功能，那么不可避免地，我们与之交互的系统将获得大脑的处理能力。这就意味着，根据计算不可约的原理，我们永远无法系统地“超越”或“理解”这些系统的运行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，我们如何才能使用它们呢？好吧，就像人类总是使用自然系统一样。当然，我们不知道他们工作或能力的所有细节。但是在一定的抽象水平上，我们足够了解如何在他们的帮助下实现我们的目标。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么数学领域呢？在数学中，我们习惯于建立我们的知识集，以便我们可以理解每个步骤。但是实验数学以及诸如定理自动证明之类的功能使我们无法使用这种方法的领域变得显而易见。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们会称它们为“数学”吗？</font><font style="vertical-align: inherit;">我认为他们应该。</font><font style="vertical-align: inherit;">但是，这一传统不同于我们上一个千年以来的传统。</font><font style="vertical-align: inherit;">我们仍然可以在那里创建抽象，并建立新的理解水平。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是在其基础上的某处将存在各种形式的计算不可约性，我们永远无法将其转移到人类理解的领域。</font><font style="vertical-align: inherit;">这近似于我小的逻辑公理的证明。</font><font style="vertical-align: inherit;">这是我认为将来将成为数学主要方面之一的早期示例，甚至更多。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431956/">https://habr.com/ru/post/zh-CN431956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431944/index.html">Yealink Meeting Server 2.0-新的视频会议功能</a></li>
<li><a href="../zh-CN431946/index.html">安全周49：入侵戴尔和万豪酒店</a></li>
<li><a href="../zh-CN431948/index.html">Deep Mind教授其AI可预测蛋白质结构</a></li>
<li><a href="../zh-CN431950/index.html">如何使用机器学习预测需求并自动进行购买：Ozon案例</a></li>
<li><a href="../zh-CN431954/index.html">Sun和DEC的前副总裁成为MIPS / Wave的总裁，谈论俄罗斯和RISC / V</a></li>
<li><a href="../zh-CN431958/index.html">特斯拉的虚拟电池发电站扩展到1000座澳大利亚房屋</a></li>
<li><a href="../zh-CN431960/index.html">Nvidia疯狂并在BSD-3下打开PhysX</a></li>
<li><a href="../zh-CN431964/index.html">合并排序</a></li>
<li><a href="../zh-CN431968/index.html">关于长途火车和不明显规则的常见问题解答</a></li>
<li><a href="../zh-CN431970/index.html">支持部门：期望与现实</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>