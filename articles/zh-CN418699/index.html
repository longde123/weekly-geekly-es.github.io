<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔊 👨🏾‍🎓 🐚 创建一个模拟器街机。 第三部分 🍊 💃 👨🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第一部分和第二部分 。 

 8080处理器仿真器 
 仿真器外壳 
 现在，您应该具有开始创建8080处理器仿真器的所有必要知识。 

 我将尝试使我的代码尽可能清晰，每个操作码都是单独实现的。 当您适应它时，可能需要重写它以优化性能或重用代码。 

 首先，我将创建一个内存结构，其中将包含编写反...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>创建一个模拟器街机。 第三部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="图片"></div><br> 第一部分和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a> 。 <br><br><h1>  8080处理器仿真器 </h1><br><h1> 仿真器外壳 </h1><br> 现在，您应该具有开始创建8080处理器仿真器的所有必要知识。 <br><br>  <em>我将尝试使我的代码尽可能清晰，每个操作码都是单独实现的。</em>  <em>当您适应它时，可能需要重写它以优化性能或重用代码。</em> <br><br> 首先，我将创建一个内存结构，其中将包含编写反汇编程序时所需的所有内容的字段。 还将有一个用于内存缓冲区的地方，它将是RAM。 <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br> 现在创建一个带有错误调用的过程，该过程将以错误结束该程序。 它看起来像这样： <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br> 让我们实现一些操作码。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br> 你去。 对于每个操作码，我们都会更改状态和内存，就像在真实8080上执行的命令一样。 <br><br>  8080大约有7种类型，具体取决于您如何对其进行分类： <br><br><ul><li> 资料传输 </li><li> 算术运算 </li><li> 逻辑上 </li><li> 分行 </li><li> 叠放 </li><li> 输入输出 </li><li> 特别的 </li></ul><br> 让我们分别看看它们。 <br><br><h1> 算术组 </h1><br> 算术指令是8080处理器的256个操作码中的许多，其中包括各种加法和减法。 大多数算术指令与寄存器A一起使用，并将结果保存在A中。（寄存器A也称为累加器）。 <br><br> 有趣的是，这些命令会影响条件代码。 根据执行命令的结果设置状态码（也称为标志）。 并非所有命令都会影响标志，并且并非所有影响标志的团队都会立即影响所有标志。 <br><br><h3> 旗帜8080 </h3><br> 在8080处理器中，标记称为Z，S，P，CY和AC。 <br><br><ul><li> 当结果为零时，Z（零，零）取值1 </li><li> 给定数学命令的位7（最高有效位，最高有效位，MSB）时，S（符号）取值为1 </li><li>  P（奇偶校验，奇偶校验）在结果为偶数时设置，在结果为奇数时重置 </li><li> 当命令的结果是执行转移或借入高阶位时，CY（进位）取值为1 </li><li>  AC（辅助进位）主要用于BCD（二进制编码的十进制）数学。 有关更多详细信息，请参见《太空侵略者》中的手册，该标志未使用。 </li></ul><br> 状态代码用于条件分支命令中，例如，仅当设置了Z标志时，JZ才执行分支。 <br><br> 大多数指令具有三种形式：用于寄存器，用于立即数和用于存储器。 让我们实施一些指令以理解其形式，并查看使用状态码的样子。  （请注意，由于未使用辅助传输标志，因此未实现。如果实现，则无法测试。） <br><br><h4> 登记表格 </h4><br> 这是两个具有寄存器形式的指令的示例实现； 在第一个示例中，我部署了代码以使其工作更易于理解，第二个示例中，我提出了一种更紧凑的形式来执行相同的操作。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br> 我用16位数字模拟8位数学命令。 这样可以更轻松地跟踪计算产生进位的情况。 <br><br><h4> 立即价值表格 </h4><br> 立即值的形式几乎相同，除了命令后的字节是添加的源。 由于“操作码”是内存中当前命令的指针，因此操作码[1]将立即成为下一个字节。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4> 形状记忆 </h4><br> 在存储形式中，将添加一个字节，一对HL寄存器中存储的地址指示该字节。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3> 注意事项 </h3><br> 其余的算术指令以类似的方式实现。 补充： <br><br><ul><li> 根据参考手册，在带有进位的不同版本（ADC，ACI，SBB，SUI）中，我们在计算中使用进位。 </li><li>  INX和DCX影响寄存器对；这些命令不影响标志。 </li><li>  DAD是一对寄存器的另一个命令，它仅影响进位标志 </li><li>  INR和DCR不影响进位标记 </li></ul><br><h1> 分支组 </h1><br> 处理完状态代码后，分支组将对您足够清楚。 分支有两种类型-过渡（JMP）和调用（CALL）。  JMP只是将PC设置为跳转目标的值。  CALL用于例程，它将返回地址写入堆栈，然后为PC分配目标地址。  RET从CALL返回，从堆栈中接收地址并将其写入PC。 <br><br>  JMP和CALL都只能到达操作码后以字节编码的绝对地址。 <br><br><h3>  Jmp </h3><br>  JMP命令无条件分支到目标地址。 对于所有状态代码（AC除外），还有条件分支命令： <br><br><ul><li>  JNZ和JZ为零 </li><li>  JNC和JC进行迁移 </li><li>  JPO和JPE实现奇偶校验 </li><li>  JP（加号）和JM（减号） </li></ul><br> 这是其中一些的实现： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3> 通话和退回 </h3><br> 调用后，CALL将指令的地址压入堆栈，然后跳转到目标地址。  RET从堆栈接收地址并将其保存在PC上。 所有状态都存在条件版本的CALL和RET。 <br><br><ul><li>  CZ，CNZ，RZ，RNZ为零 </li><li>  CNC，CC，RNC，RC进行传输 </li><li>  CPO，CPE，RPO，RPE用于奇偶校验 </li><li>  CP，CM，RP，RM表示符号 </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3> 注意事项 </h3><br><ul><li>  PCHL命令无条件地跳转到一对HL寄存器中的地址。 </li><li> 我没有将先前讨论的RST包括在该组中。 它将返回地址写入堆栈，然后跳转到内存底部的预定义地址。 </li></ul><br><h1> 逻辑组 </h1><br> 该小组执行逻辑操作（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本</a>教程的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章</a> ）。 从本质上讲，它们类似于算术组，因为大多数操作都使用寄存器A（驱动器），并且大多数操作会影响标志。 所有操作均针对8位值执行，在该组中，没有命令影响寄存器对。 <br><br><h3> 布尔运算 </h3><br>  AND，OR，NOT（CMP）和“异或”（XOR）被称为布尔运算。  OR和AND我已经在前面进行了解释。  NOT命令（对于8080处理器，它称为CMA或补码累加器）仅更改位值-所有单位变为零，而零变为1。 <br><br> 我将XOR视为“差异识别器”。 她的真值表如下所示： <br><br><table><tbody><tr><td>  X </td><td>  ÿ </td><td> 结果 </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1个 </td><td>  1个 </td></tr><tr><td>  1个 </td><td>  0 </td><td>  1个 </td></tr><tr><td>  1个 </td><td>  1个 </td><td>  0 </td></tr></tbody></table><br>  AND，OR和XOR具有寄存器，存储器和立即数的形式。  （CMP仅具有区分大小写的命令）。 这是一对操作码的实现： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3> 循环移位命令 </h3><br> 这些命令更改寄存器中位的顺序。 向右移动可将它们向右移动一位，向左移动-可向左移动一位： <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br> 他们似乎一文不值，但实际上并非如此。 它们可用于乘以除以二的幂。 以左移为例。  <code>0b00000001</code>是十进制1，将其向左移动将使其变为<code>0b00000010</code> （即十进制2）。如果再向左移动， <code>0b00000100</code>得到<code>0b00000100</code> ，即4。再向左移动，然后再乘以8。这将适用于任何按数字：5（ <code>0b00000101</code> ）左移时得到10（ <code>0b00001010</code> ）。 另一个左移为20（ <code>0b00010100</code> ）。 向右移动的方法相同，但用于除法。 <br><br>  8080没有乘法命令，但是可以使用这些命令来实现。 如果您知道该怎么做，您将获得奖励积分。 在面试中问了这样一个问题。  （我做了，尽管花了我几分钟。） <br><br> 这些命令周期性地旋转驱动器，并且仅影响进位标志。 这是几个命令： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3> 比较方式 </h3><br>  CMP和CPI的任务仅是设置标志（用于分支）。 他们通过减去标志来做到这一点，但不存储结果。 <br><br><ul><li> 同样：如果两个数字相等，则设置Z标志，因为它们彼此相减得出零。 </li><li> 大于：如果A大于要比较的值，则清除CY标志（因为可以进行减法而无需借用）。 </li><li> 较小：如果A小于比较值，则设置CY标志（因为A必须完成借位才能完成减法）。 </li></ul><br> 这些命令有用于寄存器，存储器和立即数的版本。 该实现是一个简单的减法，但不保存结果： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC和STC </h3><br> 他们完成了逻辑组。 它们用于设置和清除进位标志。 <br><br><h1> 输入输出和特殊命令组 </h1><br> 这些命令不能分配给任何其他类别。 为了完整起见，我会提到它们，但是在我看来，当我们开始模仿“太空侵略者”的硬件时，我们将不得不再次回到它们身上。 <br><br><ul><li>  EI和DI启用或禁用处理器处理中断的能力。 我将interrupt_enabled标志添加到处理器状态结构，并使用以下命令对其进行设置/重置。 </li><li> 似乎RIM和SIM主要用于串行I / O。 如果您有兴趣，可以阅读手册，但是这些命令在Space Invaders中不使用。 我不会效仿它们。 </li><li>  HLT是一站式服务。 我认为我们不需要模仿它，但是您可以在看到此命令时调用退出（或退出（0））代码。 </li><li>  IN和OUT是8080处理器设备用于与外部设备进行通信的命令。 虽然我们正在实现它们，但是它们除了跳过数据字节外不会做任何事情。  （稍后我们将返回给他们）。 </li><li>  NOP是“无操作”。  NOP的一种应用是控制面板定时（执行需要四个CPU周期）。 </li></ul><br>  NOP的另一个应用是代码修改。 假设我们需要更改游戏的ROM代码。 我们不能只删除不必要的操作码，因为我们不想更改所有的CALL和JMP命令（如果至少移动一部分代码，它们将是不正确的）。 使用NOP，我们可以摆脱代码。  <em>添加代码要困难得多！</em>  <em>您可以通过在ROM中的某个位置找到空间并将命令更改为JMP来添加它。</em> <br><br><h1> 堆叠组 </h1><br> 我们已经完成了堆栈组中大多数团队的机制。 如果您与我一起工作，那么这些命令将很容易实现。 <br><br><h3> 推和弹出 </h3><br>  PUSH和POP仅适用于寄存器对。  PUSH将一对寄存器写入堆栈，而POP从堆栈顶部获取2个字节，并将它们写入一对寄存器。 <br><br> 对于PUSH和POP，有四个操作码，每个对分别为：BC，DE，HL和PSW。  PSW是一对特殊的驱动器标志寄存器和状态代码。 这是我对BC和PSW的PUSH和POP的实现。 其中没有评论-我认为这里没有特别棘手的内容。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL和XTHL </h3><br> 堆栈组中还有另外两个团队-SPHL和XTHL。 <br><br><ul><li>  <code>SPHL</code>将HL移至SP（强制SP获得新地址）。 </li><li>  <code>XTHL</code>将堆栈顶部的内容与一对HL寄存器中的<code>XTHL</code>交换。 您为什么需要这样做？ 我不知道 </li></ul><br><h1> 关于二进制数的更多信息 </h1><br> 编写计算机程序时，需要做出的决定之一就是选择用于数字的数据类型-是否希望它们为负数，以及它们的最大大小应为多少。 对于CPU仿真器，我们需要数据类型与目标CPU的数据类型匹配。 <br><br><h3> 已签名和未签名 </h3><br> 当我们开始讨论十六进制数时，我们认为它们是无符号的-也就是说，十六进制数的每个二进制数都有一个正值，并且每个被认为是2的幂（单位，2、4等）。 <br><br> 我们处理负数的计算机存储问题。 如果您知道所讨论的数据带有符号，即它们可以是负数，则可以通过数字的最高有效位（最高有效位，MSB）来识别负数。 如果数据大小为一个字节，则每个具有给定MSB位值的数字均为负，而每个具有零MSB的值为正。 <br><br> 负数的值将作为附加代码存储。 如果我们有一个带符号的数字，并且MSB等于1，并且我们想找出这个数字是什么，则可以按如下所示进行转换：对十六进制数字执行二进制“ NOT”，然后加一个。 <br><br> 例如，对于十六进制数字0x80，MSB位置1，即为负。 数字0x80的二进制“ NOT”为0x7f，即十进制127。127 + 1 =128。即，十进制0x80为-128。 第二个示例：0xC5。 不是（0xC5）= 0x3A =十进制58 +1 =十进制59。也就是说，0xC5是十进制-59。 <br><br> 使用附加代码在数字上令人惊讶的是，我们可以像对无符号数字一样对它们执行计算，并且它们仍然<em>可以使用</em> 。 电脑不需要对标志做任何特殊的事情。 我将展示一些例子来证明这一点。 <br><br><pre> 例子1<font></font>
<font></font>
     十进制十六进制二进制    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^记录在进位位<font></font>
<font></font>
   例子2    <font></font>
<font></font>
     十进制十六进制二进制    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br> 在示例1中，我们看到将10和-3的结果相加为7，将结果相加，因此可以设置C标志；在示例2中，相加结果为负，因此我们将其解码为：Not（0xE6）= 0x19 = 25 + 1 = <code>0xE6 = -26</code>大脑爆炸！ <br><br> 如果需要，请阅读有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia</a>上的其他代码的更多信息。 <br><br><h3> 资料类型 </h3><br> 在C语言中，数据类型和用于此类型的字节数之间存在关系。 实际上，我们只对整数感兴趣。 标准/老式C数据类型为char，int和long，以及他们的朋友unsigned char，unsigned int和unsigned long。 问题在于，在不同的平台和不同的编译器中，这些类型的大小可能不同。 <br><br> 因此，最好为我们的平台选择一个明确声明数据大小的数据类型。 如果您的平台具有stdint.h，则可以使用int8_t，uint8_t等。 <br><br> 整数的大小确定可以存储在其中的最大数目。 如果是无符号整数，则可以8位存储0到255之间的数字，如果转换为十六进制，则是0x00到0xFF。 由于0xFF具有“所有位已设置”，并且它对应于十进制255，因此完全合乎逻辑的是，单字节无符号整数的间隔为0-255。 间隔告诉我们，所有整数大小都将完全相同-数字与设置所有位时获得的数字相对应。 <br><br><table><tbody><tr><th> 型式 </th><th> 间隔时间 </th><th> 十六进制 </th></tr><tr><td>  8位无符号 </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  8位带符号 </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16位无符号 </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  16位带符号 </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32位无符号 </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  32位带符号 </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br> 更加有趣的是，每种有符号数据类型中的-1是设置了所有位的数字（有符号字节为0xFF，有符号16位数字为0xFFFF，有符号32位数字为0xFFFFFFFF）。 如果数据被认为是无符号的，那么对于所有给定的位，将获得此类数据的最大可能数目。 <br><br> 为了模拟处理器寄存器，我们选择与该寄存器的大小相对应的数据类型。 可能值得选择默认情况下的未签名类型，并在需要将其视为已签名时进行转换。 例如，我们使用uint8_t数据类型表示一个8位寄存器。 <br><br><h3> 提示：使用调试器转换数据类型 </h3><br> 如果gdb安装在您的平台上，那么使用它来处理二进制数字将非常方便。 下面，我将显示一个示例-在下面的会话中，以＃开头的行是我稍后添加的注释。 <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br> 当我使用十六进制数字时，我总是在gdb中执行它-几乎每天都会发生。 这比通过GUI打开程序员的计算器容易得多。 在Linux（和Mac OS X）计算机上，要启动gdb会话，只需打开终端并输入“ gdb”。 如果在OS X上使用Xcode，则在启动程序后，可以在Xcode（输出printf输出的控制台）中使用控制台。 在Windows上，Cygwin提供了gdb调试器。 <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU仿真器终止 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到所有这些信息后，您就可以准备长途旅行。</font><font style="vertical-align: inherit;">您必须决定如何实现仿真器-创建完整的8080仿真或仅实现完成游戏所需的命令。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果决定进行全面仿真，则将需要更多工具。</font><font style="vertical-align: inherit;">我将在下一节中讨论它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一种方法是仅模拟游戏使用的指令。</font><font style="vertical-align: inherit;">我们将继续填写在“仿真器外壳程序”部分中创建的庞大的开关构造。</font><font style="vertical-align: inherit;">我们将重复以下过程，直到只有一个未实现的命令：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用ROM Space Invaders启动仿真器 </font></font></li><li><font style="vertical-align: inherit;"></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果命令尚未准备就绪，则</font><font style="vertical-align: inherit;">呼叫将</font><font style="vertical-align: inherit;">退出</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 模拟此指令 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 转到1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始编写仿真器时，我要做的第一件事是从反汇编器中添加代码。</font><font style="vertical-align: inherit;">因此，我能够输出应按以下方式执行的命令：</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我还在末尾添加了代码以显示所有寄存器和状态标志。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好消息：为了深入研究5万个团队的程序，我们只需要8080个操作码的子集，我什至会列出需要实现的操作码列表：</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 操作码 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 团队 </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B，D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B，D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 爸爸b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0d </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C，D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rrc </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D，D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 英寸 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 爸爸 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H，D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H，D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 爸爸 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP，D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA ADR </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI M，D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDA ADR </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A，D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV D，M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E，M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV H，M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L，A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M，A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A，D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A，E </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A，H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A，M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 全日空 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 流行音乐b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 詹兹·阿德 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JMP ADR </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 推B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 致电adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 流行音乐 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D8输出 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 推D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 流行音乐 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 推H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ch </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 推PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPI D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这些只是50条指令，其中10条是微不足道的实现。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 侦错 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我有一个坏消息。</font><font style="vertical-align: inherit;">几乎可以肯定，您的仿真器将无法正常工作，并且很难找到此类代码中的错误。</font><font style="vertical-align: inherit;">如果您知道哪个命令的行为不正确（例如，转换或对无意义代码的调用），则可以尝试通过检查代码来修复错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了仔细检查代码外，还有另一种解决问题的方法-通过将仿真器与实际可用的仿真器进行比较。</font><font style="vertical-align: inherit;">我们假设另一个模拟器始终可以正常工作，并且所有区别都是模拟器中的错误。</font><font style="vertical-align: inherit;">例如，您可以使用我的模拟器。</font><font style="vertical-align: inherit;">您可以手动并行运行它们。</font><font style="vertical-align: inherit;">如果将我的代码集成到项目中以进行以下过程，则可以节省时间：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为模拟器创建状态 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为我的国家创造状态 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于下一队 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用状态调用模拟器 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用我的财富来呼唤我 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 比较我们的两个状态 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 寻找任何差异中的错误 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 转到3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一种方法是手动使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此站点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个8080 Javascript处理器仿真器，甚至包括ROM Space Invaders。</font><font style="vertical-align: inherit;">过程如下：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过单击“空间侵略者”按钮来重新启动“空间侵略者”仿真 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 按“运行1”按钮执行命令。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在模拟器中执行以下命令 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 比较处理器状态与您的状态 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果条件匹配，请转到2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果条件不匹配，则您的指令仿真是错误的。</font><font style="vertical-align: inherit;">更正它，然后从步骤1重新开始。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在开始调试8080仿真器时就使用了这种方法，但我不会撒谎-这个过程可能很漫长。结果，我的很多问题都变成了错别字和复制粘贴错误，这些错误在检测到后很容易解决。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果逐步执行代码，则前3万条指令中的大多数指令都将以$ 1a5f的周期执行。如果您在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模拟器中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">javascript</font></a><font style="vertical-align: inherit;">，则</font><font style="vertical-align: inherit;">可以看到该代码将数据复制到了屏幕上。我确定经常会调用此代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一次渲染屏幕后，经过5万条命令，程序陷入了这一无休止的循环：</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它一直等到$ 20c0的内存值变为零。</font><font style="vertical-align: inherit;">由于此循环中的代码未完全更改$ 20c0，因此它必须是来自其他位置的信号。</font><font style="vertical-align: inherit;">现在该讨论模拟街机的“铁”了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在继续进行下一部分之前，请确保您的CPU仿真器陷入这种无休止的循环。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">供参考，请参阅</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的资料</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完整的8080仿真 </font></font></h1><br> ,   :   ,    .        .     ,     .         ,     . <br><br>     ,       8080     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  8080</a>   cpudiag.asm,       8080. <br><br>           : <br><br><ol><li>  ,          .  ,   cpudiag.asm    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，该过程非常艰苦。</font><font style="vertical-align: inherit;">我认为，如果未列出这些步骤，则调试汇编代码的新手将遇到很大的困难。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是我在模拟器上使用此测试的方式。</font><font style="vertical-align: inherit;">您可以使用它，或者想出一种更好的方法来集成它。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 测试组装 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我尝试了几件事，但最终我决定使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个漂亮的页面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我将文本cpudiag.asm粘贴到左窗格中，并且构建完成，没有任何问题。</font><font style="vertical-align: inherit;">我花了一分钟的时间弄清楚如何下载结果，但是通过单击左下方的“ Make Beautiful Code”按钮，我下载了一个名为test.bin的文件，该文件的编译代码为8080。我能够使用反汇编程序进行验证。</font><font style="vertical-align: inherit;">从我的网站上的镜像</font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载cpudiag.asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从我的网站</font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载cpudiag.bin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（编译代码8080）。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将测试上传到我的模拟器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是加载入侵者*文件，而是加载此二进制文件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里出现一些小困难。首先，源汇编程序代码中有一行</font></font><code>ORG 00100H</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即，这意味着在假定第一行代码为0x100 hex的情况下编译整个文件。我以前从未在汇编器8080中编写过代码，所以我不知道此行的作用。我花了一分钟的时间才发现所有分支分支地址都不正确，并且内存必须从0x100开始。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，由于仿真器是从头开始的，因此我必须首先过渡到真实代码。将十六进制值插入到零地址的内存中后</font></font><code>JMP $0100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我进行了处理。 （或者您可以将PC初始化为0x100。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三，我在编译后的代码中发现了一个错误。</font><font style="vertical-align: inherit;">我认为原因是对最后一行代码的处理不正确</font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是我不确定。</font><font style="vertical-align: inherit;">尽可能地，编译期间的堆栈位于$ 6ad，并且前几个PUSH开始重写代码。</font><font style="vertical-align: inherit;">我建议该变量也应像代码其余部分一样偏移0x100，因此我通过在初始化堆栈指针的代码行中插入“ 0x7”来修复该变量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，由于我没有在模拟器中实现DAA或辅助迁移，因此我修改了代码以跳过此检查（我们只是使用JMP跳过了此检查）。</font></font><br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 测试试图得出一个结论 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，该测试依赖于CP / M OS的帮助。我发现CP / M在$ 0005处有一些代码可以将消息打印到控制台，并更改了CALL仿真以处理此行为。我不确定是否一切正常，但是对于程序尝试打印的两条消息，它是否起作用。我运行此测试的CALL仿真如下所示：</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过此测试，我在模拟器中发现了几个问题。我不确定他们会参与其中的游戏，但是如果他们参与了，那么很难找到他们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我继续执行所有的操作码（DAA和他的朋友除外）。我花了3-4个小时来解决挑战中的问题并实施新的挑战。绝对比我上面描述的手动过程要快-在我找到此测试之前，我花了4个小时以上的时间进行手动过程。如果您能弄清楚这个解释，那么我建议您使用这种方法，而不要手动进行比较。但是，了解手动过程也是一项很好的技能，如果您想模拟另一个处理器，则应该返回到它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您无法执行此过程或看起来过于复杂，那么绝对值得选择上述方法，并在程序中运行两个不同的模拟器。</font><font style="vertical-align: inherit;">当程序中出现数百万个命令并添加了中断时，将无法手动比较两个仿真器。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418699/">https://habr.com/ru/post/zh-CN418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418687/index.html">3.5“革命：带有蒸汽的软盘的小繁荣的细节</a></li>
<li><a href="../zh-CN418689/index.html">如何使用在线拍卖的示例在Figma中创建组件库，节省预算</a></li>
<li><a href="../zh-CN418691/index.html">牧场主：5分钟内使用裸机进行Kubernetes</a></li>
<li><a href="../zh-CN418693/index.html">为什么幸福很难在大脑中发现</a></li>
<li><a href="../zh-CN418695/index.html">反盗版战争-帝国反击</a></li>
<li><a href="../zh-CN418701/index.html">我们研究俄语的语法分析器</a></li>
<li><a href="../zh-CN418705/index.html">Futex基础</a></li>
<li><a href="../zh-CN418707/index.html">KDispatcher-轻巧方便的日常事件总线</a></li>
<li><a href="../zh-CN418709/index.html">需要强迫自己：驱动程序和界面障碍</a></li>
<li><a href="../zh-CN418711/index.html">令牌管理寄存器1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>