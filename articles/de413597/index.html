<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌞 🧕🏾 🐤 "Last Resort" oder warum Database First Design benötigt wird 🤭 💪🏾 👨‍❤️‍💋‍👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem sehr späten Artikel werde ich erklären, warum Sie meiner Meinung nach in den meisten Fällen bei der Entwicklung eines Datenmodells für eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Last Resort" oder warum Database First Design benötigt wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413597/"><p>  In diesem sehr späten Artikel werde ich erklären, warum Sie meiner Meinung nach in den meisten Fällen bei der Entwicklung eines Datenmodells für eine Anwendung den ersten Ansatz der Datenbank befolgen müssen.  Anstelle des Ansatzes „Java [jede andere Sprache] zuerst“, der Sie zu einem langen Weg voller Schmerzen und Leiden führt, sobald das Projekt zu wachsen beginnt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fcf/aaf/2aefcfaafbeb94adc7a73ec265b5feb1.png" alt="Bild"><br>  <em>"Too Busy to Be Better" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lizenzierter CC</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alan O'Rourke / Audience Stack</a> .</em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalbild</a></em> <em><br></em> </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel wurde von einer aktuellen StackOverflow-Frage inspiriert</a> . </p><br><p>  Interessante reddit Diskussionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ r / java</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ r / Programmierung</a> . </p><br><h2 id="kodogeneraciya">  Codegenerierung </h2><br><p>  Zu meiner Überraschung scheint eine kleine Gruppe von Benutzern schockiert gewesen zu sein, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jOOQ</a> stark mit der Generierung von Quellcode verbunden ist. </p><br><p>  Während Sie jOOQ genau so verwenden können, wie Sie möchten, besteht die bevorzugte Methode (gemäß Dokumentation) darin, mit dem vorhandenen Datenbankschema zu beginnen und dann die erforderlichen Clientklassen (entsprechend Ihren Tabellen) mit jOOQ zu generieren. Danach ist es einfach, typsicher zu schreiben Abfragen für diese Tabellen: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Record2&lt;String, String&gt; record : DSL.using(configuration) <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^^^^^^^^^^^^^^ Type information derived from the // generated code referenced from the below SELECT clause .select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME) // vvvvv ^^^^^^^^^^^^ ^^^^^^^^^^^^^^^ Generated names .from(ACTOR) .orderBy(1, 2)) { // ... }</span></span></code> </pre> <br><p>  Der Code kann entweder manuell außerhalb der Baugruppe oder automatisch mit jeder Baugruppe generiert werden.  Eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche Generierung kann beispielsweise unmittelbar nach der Installation von Flyway-Migrationen erfolgen</a> , die auch manuell oder automatisch gestartet werden können. </p><br><h3 id="generaciya-ishodnogo-koda">  Quellcode-Generierung </h3><br><p>  Es gibt verschiedene Philosophien, Vor- und Nachteile in Bezug auf diese Ansätze zur Codegenerierung, die ich in diesem Artikel nicht diskutieren möchte.  Im Wesentlichen bedeutet der generierte Code jedoch, dass es sich um eine Java-Darstellung dessen handelt, was wir als eine Art "Standard" betrachten (sowohl innerhalb als auch außerhalb unseres Systems).  In gewisser Weise machen Compiler dasselbe, wenn sie Bytecode, Maschinencode oder einen anderen Quellcode aus der Quelle generieren. Dadurch erhalten wir eine Vorstellung von unserem „Standard“ in einer anderen spezifischen Sprache. </p><br><p>  Es gibt einige solcher Codegeneratoren.  Beispielsweise kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XJC Java-Code aus XSD- oder WSDL-Dateien generieren</a> .  Das Prinzip ist immer dasselbe: </p><br><ul><li>  Es gibt einige Standards (extern oder intern), wie z. B. Spezifikation, Datenmodell usw. </li><li>  Es ist notwendig, sich in unserer üblichen Programmiersprache ein Bild von diesem Standard zu machen. </li></ul><br><p>  Und fast immer ist es sinnvoll, diese Ansicht zu <em>generieren</em> , um unnötige Arbeit und unnötige Fehler zu vermeiden. </p><br><h3 id="type-providers-i-obrabotka-annotaciy">  Typanbieter und Anmerkungsverarbeitung </h3><br><p>  Es ist bemerkenswert, dass ein anderer, modernerer Ansatz zur Codegenerierung in jOOQ Type Providers ist ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie in F #</a> ), bei dem der Code vom Compiler während der Kompilierung generiert wird und niemals in der ursprünglichen Form vorhanden ist.  Ein ähnliches (aber weniger ausgefeiltes) Tool in Java sind Annotationsprozessoren wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lombok</a> . </p><br><p>  In beiden Fällen ist alles das gleiche wie bei der normalen Codegenerierung, außer: </p><br><ul><li>  Sie sehen den generierten Code nicht (vielleicht ist dies für viele ein großes Plus?) </li><li>  Sie müssen sicherstellen, dass Ihre „Referenz“ bei jeder Zusammenstellung verfügbar ist.  Dies verursacht keine Probleme im Fall von Lombok, das den Quellcode selbst direkt kommentiert, was in diesem Fall der "Standard" ist.  Etwas komplizierter bei Datenbankmodellen, die auf einer aktiven Live-Verbindung basieren. </li></ul><br><h2 id="v-chem-problema-s-generaciey-koda">  Was ist das Problem bei der Codegenerierung? </h2><br><p>  Neben der kniffligen Frage, ob der Code manuell oder automatisch generiert werden soll, denken einige Leute, dass der Code überhaupt nicht generiert werden muss.  Der Grund, den ich am häufigsten höre, ist, dass eine solche Generierung in der CI / CD-Pipeline schwer zu implementieren ist.  Und ja, es ist wahr, weil  Wir erhalten Overhead für die Erstellung und Unterstützung zusätzlicher Infrastrukturen, insbesondere wenn Sie mit den verwendeten Tools (jOOQ, JAXB, Hibernate usw.) noch nicht vertraut sind. </p><br><p>  Wenn der Aufwand für das Studium des Codegenerators zu hoch ist, hat dies nur einen geringen Nutzen.  Dies ist jedoch das einzige Argument dagegen.  In den meisten anderen Fällen macht es absolut keinen Sinn, Code manuell zu schreiben, was die übliche Darstellung eines Modells von etwas ist. </p><br><p>  Viele Leute behaupten, dass sie dafür keine Zeit haben, weil  Im Moment müssen Sie so schnell wie möglich ein weiteres MVP einführen.  Und sie werden irgendwann später in der Lage sein, ihre CI / CD-Pipeline fertigzustellen.  In solchen Fällen sage ich normalerweise: "Sie sind zu beschäftigt, um besser zu werden." </p><br><h2 id="no-ved-hibernatejpa-delaet-java-first-razrabotku-gorazdo-prosche">  "Aber Hibernate / JPA erleichtert die erste Entwicklung von Java erheblich." </h2><br><p>  Ja es ist wahr.  Dies ist sowohl eine Freude als auch ein Schmerz für Benutzer im Ruhezustand.  Mit ihm können Sie einfach mehrere Objekte des Formulars schreiben: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; String title; }</code> </pre> <br><p>  Und das ist fast geschafft.  Als nächstes übernimmt Hibernate die gesamte Routine zum Definieren dieses Objekts in DDL und im gewünschten SQL-Dialekt: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, title <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> pk_book PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> i_book_title <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> book (title);</code> </pre> <br><p>  Dies ist wirklich eine großartige Möglichkeit, schnell mit der Entwicklung zu beginnen - Sie müssen nur die Anwendung starten. </p><br><p>  Aber nicht alles ist so rosig.  Es gibt noch viele Fragen: </p><br><ul><li>  Wird Hibernate den Namen generieren, den ich für den Primärschlüssel benötige? </li><li>  Werde ich den Index erstellen, den ich für das Feld TITLE benötige? </li><li>  Wird für jeden Datensatz ein eindeutiger ID-Wert generiert? </li></ul><br><p>  Es scheint nicht.  Während das Projekt entwickelt wird, können Sie Ihre aktuelle Datenbank jederzeit wegwerfen und alles von Grund auf neu generieren, indem Sie dem Modell die erforderlichen Anmerkungen hinzufügen. <br>  Die Buchklasse in ihrer endgültigen Form sieht also ungefähr so ​​aus: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"book"</span></span>, indexes = { <span class="hljs-meta"><span class="hljs-meta">@Index</span></span>(name = <span class="hljs-string"><span class="hljs-string">"i_book_title"</span></span>, columnList = <span class="hljs-string"><span class="hljs-string">"title"</span></span>) }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; String title; }</code> </pre> <br><h2 id="no-vy-zaplatite-za-eto-chut-pozzhe">  Aber Sie werden etwas später dafür bezahlen </h2><br><p>  Früher oder später wird Ihre Anwendung in Produktion genommen, und das beschriebene Schema funktioniert nicht mehr: </p><br><blockquote>  In einem lebendigen und realen System können Sie Ihre Datenbank nicht mehr nur abholen und ablegen, weil  Daten werden darin verwendet und können viel Geld kosten. </blockquote><p>  Von nun an müssen Sie Migrationsskripte für jede Änderung im Datenmodell schreiben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">z. B. mit Flyway</a> .  Was passiert jedoch mit Ihren Kundenklassen?  Sie können sie entweder manuell anpassen (was zu doppelter Arbeit führt) oder Hibernate bitten, sie zu generieren (aber wie wahrscheinlich ist es, dass die Ergebnisse dieser Generierung die Erwartungen erfüllen?).  Infolgedessen können Sie große Probleme erwarten. </p><br><p>  Sobald der Code in Produktion geht, müssen fast sofort und so schnell wie möglich Korrekturen vorgenommen werden. </p><br><p>  Und weil  Die Installation von Datenbankmigrationen ist nicht in Ihre Fertigungslinie integriert. Sie müssen solche Patches manuell auf eigenes Risiko installieren.  Es wird nicht genug Zeit geben, um zurück zu gehen und alles richtig zu machen.  Es reicht nur aus, Hibernate für all seine Probleme verantwortlich zu machen. </p><br><p>  Stattdessen hätten Sie von Anfang an ganz anders handeln können.  Verwenden Sie nämlich runde Räder anstelle von quadratischen. </p><br><h2 id="vpered-k-database-first">  Gehen Sie zuerst zur Datenbank </h2><br><p>  Die Referenz und Steuerung des Datenschemas befindet sich im Büro Ihres DBMS.  Eine Datenbank ist der einzige Ort, an dem ein Schema definiert ist, und alle Clients haben eine <em>Kopie</em> dieses Schemas, aber nicht umgekehrt.  Die Daten befinden sich in Ihrer Datenbank und nicht in Ihrem Client. Daher ist es sinnvoll, die Kontrolle über das Schema und seine Integrität genau dort zu übernehmen, wo sich die Daten befinden. </p><br><p>  Das ist alte Weisheit, nichts Neues.  Primär- und eindeutige Schlüssel sind gut.  Fremdschlüssel sind wunderschön.  Das Überprüfen der Einschränkungen auf der Datenbankseite ist wunderbar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Behauptung (wenn sie endlich implementiert sind) ist</a> großartig. </p><br><p>  Und das ist noch nicht alles.  Wenn Sie beispielsweise Oracle verwenden, können Sie Folgendes angeben: </p><br><ul><li>  In welchem ​​Tablespace befindet sich Ihre Tabelle? </li><li>  Was bedeutet PCTFREE? </li><li>  Wie groß ist der Sequenzcache? </li></ul><br><p>  Vielleicht spielt all dies auf kleinen Systemen keine Rolle, aber auf größeren Systemen müssen Sie nicht dem Pfad von "Big Data" folgen, bis Sie alle Säfte aus Ihrem aktuellen Speicher herausgepresst haben.  Mit keinem einzigen ORM, den ich jemals gesehen habe (einschließlich jOOQ), können Sie den vollständigen Satz von DDL-Parametern verwenden, die Ihr DBMS bereitstellt.  ORMs bieten nur einige Tools, mit denen Sie DDL schreiben können. </p><br><p>  Letztendlich sollte ein gut gestaltetes Schema nur manuell mit einer DBMS-spezifischen DDL geschrieben werden.  Alle automatisch generierten DDLs sind nur eine Annäherung daran. </p><br><h2 id="chto-naschet-klientskoy-modeli">  Was ist mit dem Kundenmodell? </h2><br><p>  Wie bereits erwähnt, benötigen Sie eine bestimmte Darstellung des Datenbankschemas auf der Clientseite.  Diese Ansicht muss natürlich mit dem realen Modell synchronisiert werden.  Wie kann man das machen?  Natürlich mit Codegeneratoren. </p><br><p>  Alle Datenbanken bieten Zugriff auf ihre Metainformationen über das gute alte SQL.  So können Sie beispielsweise eine Liste aller Tabellen aus verschiedenen Datenbanken abrufen: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- H2, HSQLDB, MySQL, PostgreSQL, SQL Server SELECT table_schema, table_name FROM information_schema.tables -- DB2 SELECT tabschema, tabname FROM syscat.tables -- Oracle SELECT owner, table_name FROM all_tables -- SQLite SELECT name FROM sqlite_master -- Teradata SELECT databasename, tablename FROM dbc.tables</span></span></code> </pre> <br><p>  Es sind solche Abfragen (sowie ähnliche Abfragen für Ansichten, materialisierte Ansichten und Tabellenfunktionen), die ausgeführt werden, wenn die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DatabaseMetaData.getTables ()</a> -Methode eines bestimmten JDBC-Treibers aufgerufen wird, oder im jOOQ-Metamodul. </p><br><p>  Aus den Ergebnissen solcher Abfragen ist es relativ einfach, eine Client-Darstellung des Datenbankmodells zu erstellen, unabhängig davon, welche Datenzugriffstechnologie verwendet wird. </p><br><ul><li>  Wenn Sie JDBC oder Spring verwenden, können Sie eine Gruppe von String-Konstanten erstellen </li><li>  Wenn Sie JPA verwenden, können Sie Objekte selbst erstellen </li><li>  Wenn Sie jOOQ verwenden, können Sie jOOQ-Metamodelle erstellen </li></ul><br><p>  Abhängig von der Anzahl der Funktionen, die Ihre Datenzugriffs-API bietet (jOOQ, JPA oder etwas anderes), kann das generierte Metamodell sehr umfangreich und vollständig sein.  Als Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die implizite Verknüpfungsfunktion in jOOQ 3.11, die auf Metainformationen über die Beziehungen von Fremdschlüsseln zwischen Ihren Tabellen basiert</a> . </p><br><p>  Jetzt führt jede Änderung am Datenbankschema automatisch zu einer Aktualisierung des Client-Codes. </p><br><p>  Stellen Sie sich vor, Sie müssen eine Spalte in einer Tabelle umbenennen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> book_title;</code> </pre> <br><p>  Sind Sie sicher, dass Sie diese Arbeit zweimal ausführen möchten?  Auf keinen Fall.  Übernehmen Sie einfach diese DDL, führen Sie den Build aus und genießen Sie das aktualisierte Objekt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"book"</span></span>, indexes = { <span class="hljs-comment"><span class="hljs-comment">// Would you have thought of this? @Index(name = "i_book_title", columnList = "book_title") }) class Book { @Id @GeneratedValue(strategy = IDENTITY) int id; @Column("book_title") String **bookTitle**; }</span></span></code> </pre> <br><p>  Außerdem muss der empfangene Client nicht jedes Mal kompiliert werden (zumindest bis zur nächsten Änderung des Datenbankschemas), was bereits ein großes Plus sein kann! <br>  Die meisten DDL-Änderungen sind auch semantische Änderungen, nicht nur syntaktische.  Daher ist es großartig, im generierten Client-Code zu sehen, welche genauen Änderungen in der Datenbank betroffen sind. </p><br><h2 id="pravda-vsegda-odna">  Die Wahrheit ist immer allein </h2><br><p>  Unabhängig davon, welche Technologie Sie verwenden, sollte es immer nur ein Modell geben, das der Standard für das Subsystem ist.  Oder zumindest sollten wir uns darum bemühen und Verwirrung im Geschäftsleben vermeiden, wo der „Standard“ überall und nirgendwo gleichzeitig ist.  Es macht alles viel einfacher.  Wenn Sie beispielsweise XML-Dateien für ein anderes System freigeben, verwenden Sie wahrscheinlich XSD.  Als Metamodell INFORMATION_SCHEMA jOOQ im XML-Format: <a href="">https://www.jooq.org/xsd/jooq-meta-3.10.0.xsd</a> </p><br><ul><li>  XSD ist gut verstanden </li><li>  XSD beschreibt XML-Inhalte perfekt und ermöglicht die Validierung in allen Client-Sprachen </li><li>  XSD macht die Versionierung einfach und abwärtskompatibel </li><li>  XSD kann mit XJC in Java-Code umgewandelt werden </li></ul><br><p>  Besonderes Augenmerk legen wir auf den letzten Punkt.  Bei der Kommunikation mit einem externen System über XML-Nachrichten müssen wir uns der Gültigkeit der Nachrichten sicher sein.  Und mit Dingen wie JAXB, XJC und XSD ist das wirklich sehr einfach.  Es wäre verrückt, über die Angemessenheit des Java-First-Ansatzes in diesem Fall nachzudenken.  Das auf der Grundlage der XML-Objekte generierte XML ist von schlechter Qualität, schlecht dokumentiert und schwer zu erweitern.  Und wenn es eine SLA für eine solche Interaktion gibt, werden Sie enttäuscht sein. </p><br><p>  Ehrlich gesagt ähnelt dies dem, was jetzt mit den verschiedenen JSON-APIs passiert, aber das ist eine ganz andere Geschichte ... </p><br><h3 id="chem-bazy-dannyh-huzhe">  Was macht Datenbanken schlimmer? </h3><br><p>  Bei der Arbeit mit einer Datenbank ist hier alles gleich.  Die Datenbank besitzt die Daten und muss auch der Master des Datenschemas sein.  Alle Schemaänderungen müssen direkt über DDL vorgenommen werden, um die Referenz zu aktualisieren. </p><br><p>  Nach der Aktualisierung der Referenz sollten alle Kunden ihre Vorstellungen zum Modell aktualisieren.  Einige Clients können mit jOOQ und / oder Hibernate oder JDBC in Java geschrieben werden.  Andere Kunden können in Perl (viel Glück für sie) oder sogar in C # geschrieben werden.  Es spielt keine Rolle.  Das Hauptmodell befindet sich in der Datenbank.  Mit ORM erstellte Modelle sind zwar von schlechter Qualität, jedoch nicht gut dokumentiert und schwer zu erweitern. </p><br><p>  Tun Sie dies daher nicht und von Anfang an.  Beginnen Sie stattdessen mit einer Datenbank.  Erstellen Sie eine automatisierte CI / CD-Pipeline.  Verwenden Sie die Codegenerierung, um automatisch ein Datenbankmodell für Clients für jeden Build zu generieren.  Und hör auf, dir Sorgen zu machen, alles wird gut.  Alles, was erforderlich ist, ist ein kleiner anfänglicher Aufwand zum Aufbau der Infrastruktur, aber als Ergebnis erhalten Sie für den Rest Ihres Projekts über Jahre hinweg einen Gewinn im Entwicklungsprozess. </p><br><p>  Nein danke. </p><br><h2 id="poyasneniya">  Erklärungen </h2><br><p>  Konsolidierung: In diesem Artikel wird in keiner Weise behauptet, dass das Datenbankmodell für Ihr gesamtes System (Themenbereich, Geschäftslogik usw.) gelten sollte.  Meine Aussagen bestehen nur darin, dass der mit der Datenbank interagierende Client-Code nur eine <em>Darstellung</em> des Datenbankschemas sein sollte, es aber in keiner Weise definieren und formen sollte. </p><br><p>  In den zweistufigen Architekturen, die noch einen Platz haben, ist das Datenbankschema möglicherweise die einzige Informationsquelle über das Modell Ihres Systems.  Auf den meisten Systemen sehe ich die Ebene des Datenzugriffs jedoch als ein „Subsystem“, das ein Datenbankmodell kapselt.  Irgendwie so. </p><br><h2 id="isklyucheniya">  Ausnahmen </h2><br><p>  Wie bei jeder anderen guten Regel gibt es auch bei uns Ausnahmen (und ich habe bereits gewarnt, dass der erste Ansatz der Datenbank und die Codegenerierung nicht immer die richtige Wahl sind).  Diese Ausnahmen (möglicherweise ist die Liste nicht vollständig): </p><br><ul><li>  Wenn die Schaltung nicht im Voraus bekannt ist und untersucht werden muss.  Sie sind beispielsweise Anbieter eines Tools, mit dem Benutzer in jedem Schema navigieren können.  Natürlich kann es keine Codegenerierung geben.  In jedem Fall müssen Sie sich jedoch mit der Datenbank selbst und ihrem Schema befassen. </li><li>  Wenn Sie für eine Aufgabe ein Schema im laufenden Betrieb erstellen müssen.  Dies kann einer der Variationen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entity-Attribut-Wert-Musters</a> ähnlich sein, wie z  Sie haben kein klar definiertes Muster.  Es gibt auch keine Gewissheit, dass RDBMS in diesem Fall die richtige Wahl ist. </li></ul><br><p>  Die Besonderheit dieser Ausnahmen ist, dass sie sich in Wildtieren selten treffen.  In den meisten Fällen ist das Schema bei Verwendung relationaler Datenbanken im Voraus bekannt und der "Standard" Ihres Modells. Clients sollten mit einer Kopie dieses Modells arbeiten, die mit Codegeneratoren erstellt wurde. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413597/">https://habr.com/ru/post/de413597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413585/index.html">Hansen-Zusammenarbeit: entweder gut oder nichts (Teil 2)</a></li>
<li><a href="../de413587/index.html">Bewertung der Testabdeckung eines Java-Projekts am Beispiel von Apache Ignite</a></li>
<li><a href="../de413589/index.html">Code Review: Erfolgreiche Erfahrung</a></li>
<li><a href="../de413591/index.html">Industrierobotik - 57 Jahre! Erinnern Sie sich, woher die Zählung kommt</a></li>
<li><a href="../de413593/index.html">Weiter den Meeresboden erobern. Microsoft und sein Unterwasser-Rechenzentrumsprojekt Natick 2</a></li>
<li><a href="../de413599/index.html">Es gibt S.L.O.N.a in Teilen. ITAM einführen und nicht ersticken</a></li>
<li><a href="../de413601/index.html">Erwärmt das Rechenzentrum von Microsoft das Meer?</a></li>
<li><a href="../de413603/index.html">Codegenerierung in Uber</a></li>
<li><a href="../de413605/index.html">Fragen Sie Ethan: Was passiert, wenn ein Stern das Sonnensystem passiert?</a></li>
<li><a href="../de413607/index.html">Fintech Digest: Digitale Währungen bedrohen das Finanzsystem der Russischen Föderation nicht. PayPal hat herausgefunden, wie viel Spieler für Spiele ausgeben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>