<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„äôÔ∏è üßê üñ®Ô∏è Desarrollo de prote√≠nas en la nube usando Python y Transcriptic o C√≥mo crear cualquier prote√≠na por $ 360 üëºüèª üîõ üëú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQu√© sucede si tiene una idea para una prote√≠na fresca y saludable y quiere obtenerla en realidad? Por ejemplo, ¬øle gustar√≠a crear una vacuna contra H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de prote√≠nas en la nube usando Python y Transcriptic o C√≥mo crear cualquier prote√≠na por $ 360</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451124/">  ¬øQu√© sucede si tiene una idea para una prote√≠na fresca y saludable y quiere obtenerla en realidad?  Por ejemplo, ¬øle gustar√≠a crear una vacuna contra <i>H. pylori</i> (como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">equipo esloveno en iGEM 2008</a> ) creando una prote√≠na h√≠brida que combine fragmentos de flagelina de <i>E. coli</i> que estimulen la respuesta inmune con la flagelina de <i>H. pylori</i> habitual? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9c/dd5/691/e9cdd5691f1bab368bb400a8818b6507.png"></div>  <i><font color="gray">H. Pylori Hybrid Flagellin Design presentado por el equipo esloveno en iGEM 2008</font></i> <br><br>  Sorprendentemente, estamos muy cerca de crear cualquier prote√≠na que queramos sin abandonar el port√°til Jupyter, gracias a los √∫ltimos desarrollos en gen√≥mica, biolog√≠a sint√©tica y, m√°s recientemente, en laboratorios en la nube. <br><br>  En este art√≠culo, mostrar√© el c√≥digo de Python desde la idea de una prote√≠na hasta su expresi√≥n en una c√©lula bacteriana, sin tocar una pipeta ni hablar con nadie.  ¬°El costo total ser√° de unos pocos cientos de d√≥lares!  Usando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">terminolog√≠a de Vijaya Pande de A16Z</a> , esto es Biolog√≠a 2.0. <br><a name="habracut"></a><br>  M√°s espec√≠ficamente, en el art√≠culo, el c√≥digo Python del laboratorio de la nube hace lo siguiente: <br><br><ul><li>  <b>S√≠ntesis de</b> una secuencia de ADN que codifica cualquier prote√≠na que quiera. <br></li><li>  <b>Clonando</b> este ADN sint√©tico en un <b>vector</b> que puede expresarlo. <br></li><li>  <b>Transformaci√≥n de</b> bacterias con este <b>vector</b> y confirmaci√≥n de que est√° ocurriendo la expresi√≥n. </li></ul><br><h1>  Configuraci√≥n de Python </h1><br>  Primero, la configuraci√≥n general de Python que se necesita para cualquier bloc de notas Jupyter.  Importamos algunos m√≥dulos Python √∫tiles y creamos algunas funciones de utilidad, principalmente para la visualizaci√≥n de datos. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sns <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mpl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StringIO <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Bio.Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Bio.Alphabet <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> generic_dna <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> IPython.display <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> display, Image, HTML, SVG <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr)</span></span></span><span class="hljs-function">:</span></span> print(astr + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"-"</span></span>*len(astr)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_html</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> display(HTML(<span class="hljs-string"><span class="hljs-string">'{}'</span></span>.format(astr))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_svg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr, w=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, h=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> SVG_HEAD = <span class="hljs-string"><span class="hljs-string">'''&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;'''</span></span> SVG_START = <span class="hljs-string"><span class="hljs-string">'''&lt;svg viewBox="0 0 {w:} {h:}" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink"&gt;'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> display(SVG(SVG_HEAD + SVG_START.format(w=w, h=h) + astr + <span class="hljs-string"><span class="hljs-string">'&lt;/svg&gt;'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table_print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, header=True)</span></span></span><span class="hljs-function">:</span></span> html = [<span class="hljs-string"><span class="hljs-string">"&lt;table&gt;"</span></span>] html_row = <span class="hljs-string"><span class="hljs-string">"&lt;/td&gt;&lt;td&gt;"</span></span>.join(k <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rows[<span class="hljs-number"><span class="hljs-number">0</span></span>]) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;tr style='font-weight:{}'&gt;&lt;td&gt;{}&lt;/td&gt;&lt;/tr&gt;"</span></span>.format(<span class="hljs-string"><span class="hljs-string">'bold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> header <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span>, html_row)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rows[<span class="hljs-number"><span class="hljs-number">1</span></span>:]: html_row = <span class="hljs-string"><span class="hljs-string">"&lt;/td&gt;&lt;td&gt;"</span></span>.join(row) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;tr style='font-family:monospace;'&gt;&lt;td&gt;{:}&lt;/td&gt;&lt;/tr&gt;"</span></span>.format(html_row)) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;/table&gt;"</span></span>) show_html(<span class="hljs-string"><span class="hljs-string">''</span></span>.join(html)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_seq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dna)</span></span></span><span class="hljs-function">:</span></span> dna = re.sub(<span class="hljs-string"><span class="hljs-string">"\s"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>,dna) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACGTN"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dna) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Seq(dna, generic_dna) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_aas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aas)</span></span></span><span class="hljs-function">:</span></span> aas = re.sub(<span class="hljs-string"><span class="hljs-string">"\s"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>,aas) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(aa <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACDEFGHIKLMNPQRSTVWY*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> aa <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> aas) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aas <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Images</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images, header=None, width=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"100%"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># to match Image syntax if type(width)==type(1): width = "{}px".format(width) html = ["&lt;table style='width:{}'&gt;&lt;tr&gt;".format(width)] if header is not None: html += ["&lt;th&gt;{}&lt;/th&gt;".format(h) for h in header] + ["&lt;/tr&gt;&lt;tr&gt;"] for image in images: html.append("&lt;td&gt;&lt;img src='{}' /&gt;&lt;/td&gt;".format(image)) html.append("&lt;/tr&gt;&lt;/table&gt;") show_html(''.join(html)) def new_section(title, color="#66aa33", padding="120px"): style = "text-align:center;background:{};padding:{} 10px {} 10px;".format(color,padding,padding) style += "color:#ffffff;font-size:2.55em;line-height:1.2em;" return HTML('&lt;div style="{}"&gt;{}&lt;/div&gt;'.format(style, title)) # Show or hide text HTML(""" &lt;style&gt; .section { display:flex;align-items:center;justify-content:center;width:100%; height:400px; background:#6a3;color:#eee;font-size:275%; } .showhide_label { display:block; cursor:pointer; } .showhide { position: absolute; left: -999em; } .showhide + div { display: none; } .showhide:checked + div { display: block; } .shown_or_hidden { font-size:85%; } &lt;/style&gt; """) # Plotting style plt.rc("axes", titlesize=20, labelsize=15, linewidth=.25, edgecolor='#444444') sns.set_context("notebook", font_scale=1.2, rc={}) %matplotlib inline %config InlineBackend.figure_format = 'retina' # or 'svg'</span></span></code> </pre> </div></div><br><h1>  Laboratorios de nubes </h1><br>  Al igual que AWS o cualquier nube inform√°tica, el laboratorio de la nube cuenta con equipos de biolog√≠a molecular, as√≠ como con robots que alquila a trav√©s de Internet.  Puede emitir instrucciones a sus robots haciendo clic en algunos botones en la interfaz o escribiendo c√≥digo que los programe usted mismo.  No es necesario escribir sus propios protocolos, como har√© aqu√≠, una parte importante de la biolog√≠a molecular son las tareas de rutina est√°ndar, por lo que generalmente es mejor confiar en un protocolo alien√≠gena confiable que muestre una buena interacci√≥n con los robots. <br><br>  Recientemente, han aparecido varias compa√±√≠as con laboratorios en la nube: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transcriptic</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Autodesk Wet Lab Accelerator</a> (beta, y construido sobre la base de Transcriptic), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arcturus BioCloud</a> (beta), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Emerald Cloud Lab</a> (beta), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Synthego</a> (a√∫n no ha comenzado).  Incluso hay empresas creadas sobre laboratorios en la nube, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desktop Genetics</a> , que se especializa en CRISPR.  Est√°n comenzando a aparecer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos cient√≠ficos</a> sobre el uso de los laboratorios en la nube en la ciencia real. <br><br>  Al momento de escribir este art√≠culo, solo Transcriptic est√° en el dominio p√∫blico, por lo que lo usaremos.  Seg√∫n tengo entendido, la mayor parte del negocio de Transcriptic se basa en la automatizaci√≥n de protocolos comunes, y escribir sus propios protocolos en Python (como har√© en este art√≠culo) es menos com√∫n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/94e/38f/0a6/94e38f0a6f9ea9af3509a0278242b9b4.jpg"><br>  <i><font color="gray">Transcriptic "celda de trabajo" con refrigeradores en la parte inferior y diversos equipos de laboratorio en el stand</font></i> <br><br>  Dar√© instrucciones a los robots transcriptos sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">protocolo autom√°tico</a> .  Autoprotocol es un lenguaje basado en JSON para escribir protocolos para robots de laboratorio (y humanos, por as√≠ decirlo).  Autoprotocol se realiza principalmente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta biblioteca de Python</a> .  El lenguaje fue creado originalmente y todav√≠a es compatible con Transcriptic, pero, seg√∫n tengo entendido, est√° completamente abierto.  Hay buena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> . <br><br>  Una idea interesante es que en el protocolo autom√°tico puede escribir instrucciones para personas en laboratorios remotos, por ejemplo, en China o India, y potencialmente obtener algunas ventajas al usar tanto personas (su juicio) como robots (falta de juicio).  Necesitamos mencionar los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">protocolos. Aqu√≠</a> , este es un intento de estandarizar protocolos para mejorar la reproducibilidad, pero para los humanos, no para los robots. <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"instructions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"well"</span></span>: <span class="hljs-string"><span class="hljs-string">"water/0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"volume"</span></span>: <span class="hljs-string"><span class="hljs-string">"500.0:microliter"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"op"</span></span>: <span class="hljs-string"><span class="hljs-string">"provision"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span> }, ... ]</code> </pre> <br>  <i><font color="gray">Ejemplo de fragmento de autoprotocolo</font></i> <br><br><h1>  Configuraci√≥n de Python para biolog√≠a molecular </h1><br>  Adem√°s de importar bibliotecas est√°ndar, necesitar√© algunas utilidades biol√≥gicas moleculares espec√≠ficas.  Este c√≥digo es principalmente para auto-protocolo y transcriptic. <br><br>  El concepto de "volumen muerto" a menudo se encuentra en el c√≥digo.  Esto significa la √∫ltima gota de l√≠quido que los robots Transcriptic no pueden tomar con una pipeta de los tubos (¬°porque no pueden verla!).  Tienes que pasar mucho tiempo para asegurarte de que los matraces tengan suficiente material. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> autoprotocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Unit <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.container <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Container <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.protocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.protocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ref <span class="hljs-comment"><span class="hljs-comment"># "Link a ref name (string) to a Container instance." import requests import logging # Transcriptic authorization org_name = 'hgbrian' tsc_headers = {k:v for k,v in json.load(open("auth.json")).items() if k in ["X_User_Email","X_User_Token"]} # Transcriptic-specific dead volumes _dead_volume = [("96-pcr",3), ("96-flat",25), ("96-flat-uv",25), ("96-deep",15), ("384-pcr",2), ("384-flat",5), ("384-echo",15), ("micro-1.5",15), ("micro-2.0",15)] dead_volume = {k:Unit(v,"microliter") for k,v in _dead_volume} def init_inventory_well(well, headers=tsc_headers, org_name=org_name): """Initialize well (set volume etc) for Transcriptic""" def _container_url(container_id): return 'https://secure.transcriptic.com/{}/samples/{}.json'.format(org_name, container_id) response = requests.get(_container_url(well.container.id), headers=headers) response.raise_for_status() container = response.json() well_data = container['aliquots'][well.index] well.name = "{}/{}".format(container["label"], well_data['name']) if well_data['name'] is not None else container["label"] well.properties = well_data['properties'] well.volume = Unit(well_data['volume_ul'], 'microliter') if 'ERROR' in well.properties: raise ValueError("Well {} has ERROR property: {}".format(well, well.properties["ERROR"])) if well.volume &lt; Unit(20, "microliter"): logging.warn("Low volume for well {} : {}".format(well.name, well.volume)) return True def touchdown(fromC, toC, durations, stepsize=2, meltC=98, extC=72): """Touchdown PCR protocol generator""" assert 0 &lt; stepsize &lt; toC &lt; fromC def td(temp, dur): return {"temperature":"{:2g}:celsius".format(temp), "duration":"{:d}:second".format(dur)} return [{"cycles": 1, "steps": [td(meltC, durations[0]), td(C, durations[1]), td(extC, durations[2])]} for C in np.arange(fromC, toC-stepsize, -stepsize)] def convert_ug_to_pmol(ug_dsDNA, num_nts): """Convert ug dsDNA to pmol""" return float(ug_dsDNA)/num_nts * (1e6 / 660.0) def expid(val): """Generate a unique ID per experiment""" return "{}_{}".format(experiment_name, val) def ¬µl(microliters): """Unicode function name for creating microliter volumes""" return Unit(microliters,"microliter")</span></span></code> </pre> </div></div><br><h1>  S√≠ntesis de ADN y biolog√≠a sint√©tica </h1><br>  A pesar de su conexi√≥n con la biolog√≠a sint√©tica moderna, la s√≠ntesis de ADN es una tecnolog√≠a bastante antigua.  Durante d√©cadas, hemos podido fabricar oligonucle√≥tidos (es decir, secuencias de ADN de hasta 200 bases).  Sin embargo, siempre fue costoso, y la qu√≠mica nunca permiti√≥ secuencias largas de ADN.  Recientemente, ha sido posible sintetizar genes completos a un precio razonable (hasta miles de bases).  Este logro realmente abre la era de la "biolog√≠a sint√©tica". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Synthetic Genomics de</a> Craig Venter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ha</a> llevado la biolog√≠a sint√©tica m√°s lejos al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sintetizar un organismo completo</a> , con m√°s de un mill√≥n de bases de longitud.  A medida que aumenta la longitud del ADN, el problema ya no es la s√≠ntesis, sino el ensamblaje (es decir, unir secuencias de ADN sintetizadas).  Con cada ensamblaje, puede duplicar la longitud del ADN (o m√°s), por lo que despu√©s de una docena de iteraciones, ¬°obtendr√° una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mol√©cula bastante larga</a> !  La distinci√≥n entre s√≠ntesis y ensamblaje pronto deber√≠a quedar clara para el usuario final. <br><br><h1>  Ley de Moore? </h1><br>  El precio de la s√≠ntesis de ADN est√° cayendo bastante r√°pido, de m√°s de $ 0.30 hace un a√±o dos a aproximadamente $ 0.10 hoy, pero se est√° desarrollando m√°s como bacterias que como procesadores.  En contraste, los precios de secuenciaci√≥n de ADN est√°n cayendo m√°s r√°pido que la ley de Moore.  Un objetivo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">$ 0.02 por base se establece como un punto de inflexi√≥n</a> donde puede reemplazar muchas manipulaciones de ADN que consumen mucho tiempo con s√≠ntesis simple.  Por ejemplo, a este precio, puede sintetizar un pl√°smido completo de 3 kb por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">$ 60</a> y omitir un mont√≥n de biolog√≠a molecular.  Espero que lo logremos en un par de a√±os. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/373/b42/050/373b42050b870646857266bb3e07c7ed.png"><br>  <i><font color="gray">Precios de s√≠ntesis de ADN en comparaci√≥n con los precios de secuenciaci√≥n de ADN, precio por 1 base (Carlson, 2014)</font></i> <br><br><h1>  Empresas de s√≠ntesis de ADN </h1><br>  Hay varias compa√±√≠as grandes en el campo de la s√≠ntesis de ADN: IDT es el mayor productor de oligonucle√≥tidos y tambi√©n puede producir "fragmentos de genes" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gBlocks</a> ) m√°s largos (hasta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2kb</a> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gen9</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twist</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DNA 2.0</a> generalmente se especializan en secuencias de ADN m√°s largas: estas son compa√±√≠as de s√≠ntesis de genes.  Tambi√©n hay algunas compa√±√≠as nuevas interesantes, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cambrian Genomics</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Genesis DNA</a> , que est√°n trabajando en los m√©todos de s√≠ntesis de pr√≥xima generaci√≥n. <br><br>  Otras compa√±√≠as, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amyris</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zymergen</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ginkgo Bioworks</a> , usan el ADN sintetizado por estas compa√±√≠as para trabajar a nivel corporal.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Synthetic Genomics tambi√©n</a> hace esto, pero sintetiza el ADN mismo. <br><br>  Ginkgo recientemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lleg√≥ a un acuerdo con Twist</a> para hacer 100 millones de bases: el acuerdo m√°s grande que he visto.  Esto demuestra que vivimos en el futuro, Twist incluso anunci√≥ un c√≥digo promocional en Twitter: cuando compras 10 millones de bases de ADN (¬°casi todo el genoma de la levadura!), Obtienes otros 10 millones gratis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e07/bfb/ac9/e07bfbac9c53ddb79634b63efc3fc0e7.png"><br>  <i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Oferta de</a> nicho de Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twist</a></font></i> <br><br><h1>  Primera parte: dise√±o de experimentos </h1><br><h3>  Prote√≠na fluorescente verde </h3><br>  En este experimento, sintetizamos una secuencia de ADN para una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prote√≠na fluorescente verde</a> simple (GFP).  La prote√≠na GFP se encontr√≥ por primera vez en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">medusa</a> que fluoresce bajo la luz ultravioleta.  Esta es una prote√≠na extremadamente √∫til porque es f√°cil detectar su expresi√≥n simplemente midiendo la fluorescencia.  Hay opciones de GFP que producen amarillo, rojo, naranja y otros colores. <br><br>  Es interesante ver c√≥mo varias mutaciones afectan el color de una prote√≠na, y este es un problema de aprendizaje autom√°tico potencialmente interesante.  M√°s recientemente, tendr√≠as que pasar mucho tiempo en el laboratorio para esto, ¬°pero ahora te mostrar√© que es (casi) tan f√°cil como editar un archivo de texto! <br><br>  T√©cnicamente, mi GFP es una opci√≥n de Super Carpeta (sfGFP) con algunas mutaciones para mejorar la calidad. <br><br><img src="https://habrastorage.org/webt/tb/tm/_v/tbtm_vcly3elxlwhbcoknhsjpuo.jpeg"><br>  <i><font color="gray">En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superfolder-GFP</a> (sfGFP), algunas mutaciones le dan ciertas propiedades √∫tiles.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/645/232/c67/645232c67631f484ed6e8b30f6fa91eb.jpg"><br>  <i><font color="gray">Estructura de GFP (visualizada usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PV</a> )</font></i> <br><br><h3>  S√≠ntesis de GFP en Twist </h3><br>  Tuve la suerte de ingresar al programa de pruebas alfa de Twist, as√≠ que utilic√© su servicio de s√≠ntesis de ADN (hicieron un peque√±o pedido, ¬°gracias Twist!).  Esta es una nueva empresa en nuestro campo, con un nuevo proceso de s√≠ntesis simplificado.  Sus precios rondan los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">$ 0,10 por base o menos</a> , pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">todav√≠a</a> est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en beta</a> y el programa alfa en el que particip√© se cerr√≥.  Twist recaud√≥ alrededor de $ 150 millones, por lo que su tecnolog√≠a es animada. <br><br>  Envi√© mi secuencia de ADN a Twist como una hoja de c√°lculo de Excel (todav√≠a no hay API, pero supongo que ser√° pronto), y enviaron el ADN sintetizado directamente a mi caja en el laboratorio Transcriptic (tambi√©n us√© IDT para s√≠ntesis, pero no enviaron ADN justo en Transcriptic, que estropea un poco la diversi√≥n). <br><br>  Obviamente, este proceso a√∫n no se ha convertido en un caso de uso t√≠pico y requiere algo de soporte, pero funcion√≥, por lo que toda la tuber√≠a permanece virtual.  Sin esto, probablemente necesitar√≠a acceso al laboratorio: muchas compa√±√≠as no enviar√°n ADN o reactivos a su domicilio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/378/b0b/734378b0b151d2ed64bbd3ebb6edf0f3.jpg"><br>  <i><font color="gray">GFP es inofensivo, por lo que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se resalta cualquier tipo</a></font></i> <br><br><h3>  Vector pl√°smido </h3><br>  Para expresar esta prote√≠na en bacterias, el gen necesita vivir en alg√∫n lugar, de lo contrario, el ADN sint√©tico que codifica el gen simplemente se degrada instant√°neamente.  Como regla general, en biolog√≠a molecular usamos un pl√°smido, una pieza de ADN redondo que vive fuera del genoma bacteriano y expresa prote√≠nas.  Los pl√°smidos son una forma conveniente para que las bacterias compartan m√≥dulos funcionales √∫tiles e independientes, como la resistencia a los antibi√≥ticos.  Puede haber cientos de pl√°smidos en una c√©lula. <br><br>  La terminolog√≠a ampliamente utilizada es que un pl√°smido es un <b>vector</b> , y el ADN sint√©tico es una inserci√≥n (inserci√≥n).  Entonces, aqu√≠ estamos tratando de clonar la inserci√≥n en un vector y luego transformar la bacteria usando el vector. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/9ae/d03/66c9aed037ae408c6f642433d9a2a130.jpg"><br>  <i><font color="gray">Genoma bacteriano y pl√°smido (¬°no a escala!) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> )</font></i> <br><br><h3>  pUC19 </h3><br>  Eleg√≠ un pl√°smido bastante est√°ndar en la serie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pUC19</a> .  Este pl√°smido se usa con mucha frecuencia y, dado que est√° disponible como parte del inventario transcriptico est√°ndar, no necesitamos enviarles nada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f3/576/8f1/4f35768f17d5ff5506f7d1aca0b064a0.png"><br>  <i><font color="gray">Estructura de pUC19: los componentes principales son el gen de resistencia a la ampicilina, lacZŒ±, MCS / polylinker y el origen de la replicaci√≥n (Wikipedia)</font></i> <br><br>  PUC19 tiene una buena funci√≥n: dado que contiene el gen lacZŒ±, puede usar el m√©todo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">selecci√≥n azul-blanco</a> y ver en qu√© colonias la inserci√≥n fue exitosa.  Se necesitan dos productos qu√≠micos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPTG</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">X-gal</a> , y el circuito funciona de la siguiente manera: <br><br><ul><li>  IPTG induce la expresi√≥n de lacZŒ±. <br></li><li>  Si lacZŒ± se desactiva mediante el ADN insertado en el sitio de clonaci√≥n m√∫ltiple ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MCS / polylinker</a> ) en lacZŒ±, entonces el pl√°smido no puede hidrolizar X-gal y estas colonias ser√°n blancas en lugar de azules. <br></li><li>  Por lo tanto, una inserci√≥n exitosa produce colonias blancas y una inserci√≥n fallida produce colonias azules. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/123/aac/aca/123aacacac400c6f96966d2f2caeb918.jpg"><br>  <i><font color="gray">La selecci√≥n azul y blanca muestra d√≥nde se desactiv√≥ la expresi√≥n de lacZŒ± ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> )</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La documentaci√≥n de openwetware</a> dice: <br><br><blockquote>  E. coli DH5Œ± no requiere IPTG para inducir la expresi√≥n del promotor lac, incluso si se expresa un represor Lac en la cepa.  El n√∫mero de copias de la mayor√≠a de los pl√°smidos excede el n√∫mero de represores en las c√©lulas.  Si necesita una expresi√≥n m√°xima, agregue IPTG a una concentraci√≥n final de 1 mM. </blockquote><br><h1>  Secuencias de ADN sint√©tico </h1><br><h3>  Secuencia de ADN de SfGFP </h3><br>  Es f√°cil obtener la secuencia de ADN para sfGFP tomando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la secuencia de prote√≠nas</a> y codific√°ndola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con codones</a> adecuados para el organismo hu√©sped (aqu√≠, <i>E. coli</i> ).  Esta es una prote√≠na de tama√±o mediano con 236 amino√°cidos, por lo que a 10 centavos la s√≠ntesis de ADN cuesta alrededor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">$ 70</a> por base. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/296/9da/a41/2969daa417296779220366c36c02a0e5.png"><br>  <i><font color="gray">Wolfram Alpha, c√°lculo del costo de s√≠ntesis</font></i> <br><br>  Las primeras 12 bases de nuestro sfGFP son la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuencia Shine-Delgarno</a> , que agregu√© yo mismo, que en teor√≠a deber√≠a aumentar la expresi√≥n (AGGAGGACAGCT, luego ATG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cod√≥n de inicio</a> ) inicia la prote√≠na).  De acuerdo con una herramienta computacional desarrollada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Salis Lab</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diapositivas de la conferencia</a> ), podemos esperar una expresi√≥n media a alta de nuestra prote√≠na (tasa de inicio de traducci√≥n de 10,000 "unidades arbitrarias"). <br><br><pre> <code class="python hljs">sfGFP_plus_SD = clean_seq(<span class="hljs-string"><span class="hljs-string">""" AGGAGGACAGCTATGTCGAAAGGAGAAGAACTGTTTACCGGTGTGGTTCCGATTCTGGTAGAACTGGA TGGGGACGTGAACGGCCATAAATTTAGCGTCCGTGGTGAGGGTGAAGGGGATGCCACAAATGGCAAAC TTACCCTTAAATTCATTTGCACTACCGGCAAGCTGCCGGTCCCTTGGCCGACCTTGGTCACCACACTG ACGTACGGGGTTCAGTGTTTTTCGCGTTATCCAGATCACATGAAACGCCATGACTTCTTCAAAAGCGC CATGCCCGAGGGCTATGTGCAGGAACGTACGATTAGCTTTAAAGATGACGGGACCTACAAAACCCGGG CAGAAGTGAAATTCGAGGGTGATACCCTGGTTAATCGCATTGAACTGAAGGGTATTGATTTCAAGGAA GATGGTAACATTCTCGGTCACAAATTAGAATACAACTTTAACAGTCATAACGTTTATATCACCGCCGA CAAACAGAAAAACGGTATCAAGGCGAATTTCAAAATCCGGCACAACGTGGAGGACGGGAGTGTACAAC TGGCCGACCATTACCAGCAGAACACACCGATCGGCGACGGCCCGGTGCTGCTCCCGGATAATCACTAT TTAAGCACCCAGTCAGTGCTGAGCAAAGATCCGAACGAAAAACGTGACCATATGGTGCTGCTGGAGTT CGTGACCGCCGCGGGCATTACCCATGGAATGGATGAACTGTATAAA"""</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Read in sfGFP plus Shine-Dalgarno: {} bases long"</span></span>.format(len(sfGFP_plus_SD))) sfGFP_aas = clean_aas(<span class="hljs-string"><span class="hljs-string">"""MSKGEELFTGVVPILVELDGDVNGHKFSVRGEGEGDATNGKLTLKFICTTGKLPVPWPTLVTTLTYG VQCFSRYPDHMKRHDFFKSAMPEGYVQERTISFKDDGTYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNFNSHNVYITADKQKN GIKANFKIRHNVEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSVLSKDPNEKRDHMVLLEFVTAAGITHGMDELYK"""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sfGFP_plus_SD[<span class="hljs-number"><span class="hljs-number">12</span></span>:].translate() == sfGFP_aas print(<span class="hljs-string"><span class="hljs-string">"Translation matches protein with accession 532528641"</span></span>)</code> </pre> <br><pre>  Lea en sfGFP plus Shine-Dalgarno: 726 bases de largo
 La traducci√≥n coincide con la prote√≠na con la adhesi√≥n 532528641 </pre><br><h3>  Secuencia de ADN PUC19 </h3><br>  Primero, verifico que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuencia pUC19 que descargu√© del NEB tiene la</a> longitud correcta e incluye el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polienlazador</a> esperado. <br><br><pre> <code class="python hljs">pUC19_fasta = !cat puc19fsa.txt pUC19_fwd = clean_seq(<span class="hljs-string"><span class="hljs-string">''</span></span>.join(pUC19_fasta[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) pUC19_rev = pUC19_fwd.reverse_complement() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACGT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pUC19_fwd) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(pUC19_fwd) == <span class="hljs-number"><span class="hljs-number">2686</span></span> pUC19_MCS = clean_seq(<span class="hljs-string"><span class="hljs-string">"GAATTCGAGCTCGGTACCCGGGGATCCTCTAGAGTCGACCTGCAGGCATGCAAGCTT"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Read in pUC19: {} bases long"</span></span>.format(len(pUC19_fwd))) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pUC19_fwd print(<span class="hljs-string"><span class="hljs-string">"Found MCS/polylinker"</span></span>)</code> </pre> <br><pre>  Leer en pUC19: 2686 bases de largo
 MCS / polienlazador encontrado </pre><br>  Hacemos algunos QC b√°sicos para asegurarnos de que EcoRI y BamHI est√©n presentes en pUC19 solo una vez (las siguientes enzimas de restricci√≥n est√°n disponibles en el inventario transcriptico predeterminado: <i>PstI</i> , <i>PvuII</i> , <i>EcoRI</i> , <i>BamHI</i> , <i>BbsI</i> , <i>BsmBI</i> ). <br><br><pre> <code class="python hljs">REs = {<span class="hljs-string"><span class="hljs-string">"EcoRI"</span></span>:<span class="hljs-string"><span class="hljs-string">"GAATTC"</span></span>, <span class="hljs-string"><span class="hljs-string">"BamHI"</span></span>:<span class="hljs-string"><span class="hljs-string">"GGATTC"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rename, res <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> REs.items(): <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (pUC19_fwd.find(res) == pUC19_fwd.rfind(res) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pUC19_rev.find(res) == pUC19_rev.rfind(res)) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (pUC19_fwd.find(res) == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pUC19_rev.find(res) == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pUC19_fwd.find(res) == len(pUC19_fwd) - pUC19_rev.find(res) - len(res)) print(<span class="hljs-string"><span class="hljs-string">"Asserted restriction enzyme sites present only once: {}"</span></span>.format(REs.keys()))</code> </pre> <br>  Ahora miramos la secuencia lacZŒ± y verificamos que no haya nada inesperado.  Por ejemplo, debe comenzar con Met y terminar con un cod√≥n de parada.  Tambi√©n es f√°cil confirmar que este es el ORF lacZŒ± completo de 324 pb cargando la secuencia de pUC19 en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">visor de genes</a> libres. <br><br><pre> <code class="python hljs">lacZ = pUC19_rev[<span class="hljs-number"><span class="hljs-number">2217</span></span>:<span class="hljs-number"><span class="hljs-number">2541</span></span>] print(<span class="hljs-string"><span class="hljs-string">"lacZŒ± sequence:\t{}"</span></span>.format(lacZ)) print(<span class="hljs-string"><span class="hljs-string">"r_MCS sequence:\t{}"</span></span>.format(pUC19_MCS.reverse_complement())) lacZ_p = lacZ.translate() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> lacZ_p[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">"M"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lacZ_p[:<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lacZ_p[<span class="hljs-number"><span class="hljs-number">-1</span></span>] == <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS.reverse_complement() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lacZ <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS.reverse_complement() == pUC19_rev[<span class="hljs-number"><span class="hljs-number">2234</span></span>:<span class="hljs-number"><span class="hljs-number">2291</span></span>] print(<span class="hljs-string"><span class="hljs-string">"Found MCS once in lacZ sequence"</span></span>)</code> </pre> <br><pre>  secuencia lacZ: ATGACCATGATTACGCCAAGCTTGCATGCCTGCAGGTCGACTCTAGAGGATCCCCGGGTACCGAGCTCGAATTCACTGGCCGTCGTTTTACAACGTCGTGACTGGGAAAACCCTGGCGTTACCCAACTTAATCGCCTTGCAGCACATCCCCCTTTCGCCAGCTGGCGTAATAGCGAAGAGGCCCGCACCGATCGCCCTTCCCAACAGTTGCGCAGCCTGAATGGCGAATGGCGCCTGATGCGGTATTTTCTCCTTACGCATCTGTGCGGTATTTCACACCGCATATGGTGCACTCTCAGTACAATCTGCTCTGATGCCGCATAG
 Secuencia r_MCS: AAGCTTGCATGCCTGCAGGTCGACTCTAGAGGATCCCCGGGTACCGAGCTCGAATTC
 MCS encontrado una vez en secuencia lacZ </pre><br><h1>  Asamblea Gibson </h1><br>  Ensamblar ADN simplemente significa entrecruzar fragmentos.  Por lo general, recolecta varios fragmentos de ADN en un segmento m√°s largo y luego lo clona en un pl√°smido o genoma.  En este experimento, quiero clonar un segmento de ADN en el pl√°smido pUC19 debajo del promotor lac para la expresi√≥n en <i>E. coli</i> . <br><br>  Existen muchos m√©todos de clonaci√≥n (p. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ej.</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NEB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">openwetware</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">addgene</a> ).  Aqu√≠ usar√© el ensamblaje Gibson ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desarrollado por Daniel Gibson</a> en Synthetic Genomics en 2009), que no es necesariamente el m√©todo m√°s barato, sino simple y flexible.  ¬°Solo necesita colocar el ADN que desea recolectar (con la superposici√≥n apropiada) en un tubo de ensayo con Gibson Assembly Master Mix, y se ensamblar√° solo! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8df/946/db5/8df946db53b725f89277be267d2e3ab9.jpg"><br>  <i><font color="gray">Revisi√≥n de la Asamblea de Gibson ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NEB</a> )</font></i> <br><br><h3>  Material de origen </h3><br>  Comenzamos con 100 ng de ADN sint√©tico en 10 Œºl de l√≠quido.  Esto equivale a 0.21 picomoles de ADN o una concentraci√≥n de 10 ng / Œºl. <br><br><pre> <code class="python hljs">pmol_sfgfp = convert_ug_to_pmol(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, len(sfGFP_plus_SD)) print(<span class="hljs-string"><span class="hljs-string">"Insert: 100ng of DNA of length {:4d} equals {:.2f} pmol"</span></span>.format(len(sfGFP_plus_SD), pmol_sfgfp))</code> </pre> <br><pre>  Inserto: 100 ng de ADN de longitud 726 equivalen a 0.21 pmol </pre><br>  Seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el protocolo de ensamblaje de NEB</a> , este es suficiente material de origen: <br><br><blockquote>  NEB recomienda un total de 0.02-0.5 picomoles de fragmentos de ADN cuando 1 o 2 fragmentos se ensamblan en el vector, o 0.2-1.0 picomoles de fragmentos de ADN cuando se recogen 4-6 fragmentos. <br><br>  0.02-0.5 pmoles * X Œºl <br>  * La eficiencia de clonaci√≥n optimizada es de 50-100 ng de vectores con un exceso de inserciones de 2-3 veces.  Utilice 5 veces m√°s inserciones si el tama√±o es inferior a 200 bps.  El volumen total de fragmentos de PCR sin filtrar en la reacci√≥n de ensamblaje de Gibson no debe exceder el 20%. </blockquote><br><h3>  NEBuilder para ensamblaje Gibson </h3><br>  El NEBuilder de Biolab es una herramienta realmente excelente para crear el protocolo de compilaci√≥n Gibson.  Incluso le genera un PDF completo de cuatro p√°ginas con toda la informaci√≥n.  Usando esta herramienta, desarrollamos un protocolo para cortar pUC19 con EcoRI, y luego usamos PCR [PCR, la reacci√≥n en cadena de la polimerasa permite lograr un aumento significativo en peque√±as concentraciones de ciertos fragmentos de ADN en material biol√≥gico - aprox.  por.] para agregar fragmentos del tama√±o apropiado a la inserci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f5/d52/171/1f5d52171cb60c8e8b4cb83f24b0c8c8.png"><br><br><h1>  Segunda parte: experimento </h1><br>  El experimento consta de cuatro etapas: <br><br><ol><li>  Reacci√≥n de inserci√≥n de la cadena de polimerasa para agregar material con una secuencia de flanqueo. <br></li><li>  Cortar un pl√°smido para acomodar la inserci√≥n. <br></li><li>  Montaje por inserci√≥n de Gibson y pl√°smidos. <br></li><li>  Transformaci√≥n de bacterias utilizando el pl√°smido ensamblado. </li></ol><br><h3>  Paso 1. Inserci√≥n de PCR </h3><br>  El ensamblaje de Gibson depende de la secuencia de ADN que recolecte, que tenga una secuencia superpuesta (consulte el protocolo NEB con instrucciones detalladas m√°s arriba).  Adem√°s de la amplificaci√≥n simple, la PCR tambi√©n le permite agregar una secuencia de ADN flanqueante simplemente incluyendo una secuencia adicional en los cebadores (tambi√©n se puede clonar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usando solo OE-PCR</a> ). <br><br>  Sintetizamos cebadores de acuerdo con el protocolo NEB anterior.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prob√© el protocolo Quickstart</a> en el sitio Transcriptic, pero todav√≠a hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un comando de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">protocolo</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autom√°tico</a> .  Transcriptic en s√≠ no sintetiza oligonucle√≥tidos, por lo que despu√©s de 1-2 d√≠as de espera, estos cebadores aparecen m√°gicamente en mi inventario (tenga en cuenta que la parte espec√≠fica del gen de los cebadores se indica en may√∫scula a continuaci√≥n, pero estas son solo cosas cosm√©ticas). <br><br><pre> <code class="python hljs">insert_primers = [<span class="hljs-string"><span class="hljs-string">"aaacgacggccagtgTTTATACAGTTCATCCATTCCATG"</span></span>, <span class="hljs-string"><span class="hljs-string">"cgggtaccgagctcgAGGAGGACAGCTATGTCG"</span></span>]</code> </pre> <br><h3>  An√°lisis de cebadores </h3><br>  Puede analizar las propiedades de estos cebadores utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDT OligoAnalyzer</a> .    PCR         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer dimer</a> ,   NEB       . <br><br><pre> Gene-specific portion of flank (uppercase)<font></font>
  Melt temperature: 51C, 53.5C<font></font>
Full sequence<font></font>
  Melt temperature: 64.5C, 68.5C<font></font>
  Hairpin: -.4dG, -5dG<font></font>
  Self-dimer: -9dG, -16dG<font></font>
  Heterodimer: -6dG </pre><br>      PCR,     ,        PCR.          (      ),      :       .            .   ,        ‚Äî    . <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">""" PCR overlap extension of sfGFP according to NEB protocol. v5: Use 3/10ths as much primer as the v4 protocol. v6: more complex touchdown pcr procedure. The Q5 temperature was probably too hot v7: more time at low temperature to allow gene-specific part to anneal v8: correct dNTP concentration, real touchdown """</span></span> p = Protocol() <span class="hljs-comment"><span class="hljs-comment"># --------------------------------------------------- # Set up experiment # experiment_name = "sfgfp_pcroe_v8" template_length = 740 _options = {'dilute_primers' : False, # if working stock has not been made 'dilute_template': False, # if working stock has not been made 'dilute_dNTP' : False, # if working stock has not been made 'run_gel' : True, # run a gel to see the plasmid size 'run_absorbance' : False, # check absorbance at 260/280/320 'run_sanger' : False} # sanger sequence the new sequence options = {k for k,v in _options.items() if v is True} # --------------------------------------------------- # Inventory and provisioning # https://developers.transcriptic.com/v1.0/docs/containers # # 'sfgfp2': 'ct17yx8h77tkme', # inventory; sfGFP tube #2, micro-1.5, cold_20 # 'sfgfp_puc19_primer1': 'ct17z9542mrcfv', # inventory; micro-2.0, cold_4 # 'sfgfp_puc19_primer2': 'ct17z9542m5ntb', # inventory; micro-2.0, cold_4 # 'sfgfp_idt_1ngul': 'ct184nnd3rbxfr', # inventory; micro-1.5, cold_4, (ERROR: no template) # inv = { 'Q5 Polymerase': 'rs16pcce8rdytv', # catalog; Q5 High-Fidelity DNA Polymerase 'Q5 Buffer': 'rs16pcce8rmke3', # catalog; Q5 Reaction Buffer 'dNTP Mixture': 'rs16pcb542c5rd', # catalog; dNTP Mixture (25mM?) 'water': 'rs17gmh5wafm5p', # catalog; Autoclaved MilliQ H2O 'sfgfp_pcroe_v5_puc19_primer1_10uM': 'ct186cj5cqzjmr', # inventory; micro-1.5, cold_4 'sfgfp_pcroe_v5_puc19_primer2_10uM': 'ct186cj5cq536x', # inventory; micro-1.5, cold_4 'sfgfp1': 'ct17yx8h759dk4', # inventory; sfGFP tube #1, micro-1.5, cold_20 } # Existing inventory template_tube = p.ref("sfgfp1", id=inv['sfgfp1'], cont_type="micro-1.5", storage="cold_4").well(0) dilute_primer_tubes = [p.ref('sfgfp_pcroe_v5_puc19_primer1_10uM', id=inv['sfgfp_pcroe_v5_puc19_primer1_10uM'], cont_type="micro-1.5", storage="cold_4").well(0), p.ref('sfgfp_pcroe_v5_puc19_primer2_10uM', id=inv['sfgfp_pcroe_v5_puc19_primer2_10uM'], cont_type="micro-1.5", storage="cold_4").well(0)] # New inventory resulting from this experiment dilute_template_tube = p.ref("sfgfp1_0.25ngul", cont_type="micro-1.5", storage="cold_4").well(0) dNTP_10uM_tube = p.ref("dNTP_10uM", cont_type="micro-1.5", storage="cold_4").well(0) sfgfp_pcroe_out_tube = p.ref(expid("amplified"), cont_type="micro-1.5", storage="cold_4").well(0) # Temporary tubes for use, then discarded mastermix_tube = p.ref("mastermix", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) water_tube = p.ref("water", cont_type="micro-1.5", storage="ambient", discard=True).well(0) pcr_plate = p.ref("pcr_plate", cont_type="96-pcr", storage="cold_4", discard=True) if 'run_absorbance' in options: abs_plate = p.ref("abs_plate", cont_type="96-flat", storage="cold_4", discard=True) # Initialize all existing inventory all_inventory_wells = [template_tube] + dilute_primer_tubes for well in all_inventory_wells: init_inventory_well(well) print(well.name, well.volume, well.properties) # ----------------------------------------------------- # Provision water once, for general use # p.provision(inv["water"], water_tube, ¬µl(500)) # ----------------------------------------------------- # Dilute primers 1/10 (100uM-&gt;10uM) and keep at 4C # if 'dilute_primers' in options: for primer_num in (0,1): p.transfer(water_tube, dilute_primer_tubes[primer_num], ¬µl(90)) p.transfer(primer_tubes[primer_num], dilute_primer_tubes[primer_num], ¬µl(10), mix_before=True, mix_vol=¬µl(50)) p.mix(dilute_primer_tubes[primer_num], volume=¬µl(50), repetitions=10) # ----------------------------------------------------- # Dilute template 1/10 (10ng/ul-&gt;1ng/ul) and keep at 4C # OR # Dilute template 1/40 (10ng/ul-&gt;0.25ng/ul) and keep at 4C # if 'dilute_template' in options: p.transfer(water_tube, dilute_template_tube, ¬µl(195)) p.mix(dilute_template_tube, volume=¬µl(100), repetitions=10) # Dilute dNTP to exactly 10uM if 'dilute_DNTP' in options: p.transfer(water_tube, dNTP_10uM_tube, ¬µl(6)) p.provision(inv["dNTP Mixture"], dNTP_10uM_tube, ¬µl(4)) # ----------------------------------------------------- # Q5 PCR protocol # www.neb.com/protocols/2013/12/13/pcr-using-q5-high-fidelity-dna-polymerase-m0491 # # 25ul reaction # ------------- # Q5 reaction buffer 5 ¬µl # Q5 polymerase 0.25 ¬µl # 10mM dNTP 0.5 ¬µl -- 1¬µl = 4x12.5mM # 10uM primer 1 1.25 ¬µl # 10uM primer 2 1.25 ¬µl # 1pg-1ng Template 1 ¬µl -- 0.5 or 1ng/ul concentration # ------------------------------- # Sum 9.25 ¬µl # # # Mastermix tube will have 96ul of stuff, leaving space for 4x1ul aliquots of template p.transfer(water_tube, mastermix_tube, ¬µl(64)) p.provision(inv["Q5 Buffer"], mastermix_tube, ¬µl(20)) p.provision(inv['Q5 Polymerase'], mastermix_tube, ¬µl(1)) p.transfer(dNTP_10uM_tube, mastermix_tube, ¬µl(1), mix_before=True, mix_vol=¬µl(2)) p.transfer(dilute_primer_tubes[0], mastermix_tube, ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(dilute_primer_tubes[1], mastermix_tube, ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.mix(mastermix_tube, volume="48:microliter", repetitions=10) # Transfer mastermix to pcr_plate without template p.transfer(mastermix_tube, pcr_plate.wells(["A1","B1","C1"]), ¬µl(24)) p.transfer(mastermix_tube, pcr_plate.wells(["A2"]), ¬µl(24)) # acknowledged dead volume problems p.mix(pcr_plate.wells(["A1","B1","C1","A2"]), volume=¬µl(12), repetitions=10) # Finally add template p.transfer(template_tube, pcr_plate.wells(["A1","B1","C1"]), ¬µl(1)) p.mix(pcr_plate.wells(["A1","B1","C1"]), volume=¬µl(12.5), repetitions=10) # --------------------------------------------------------- # Thermocycle with Q5 and hot start # 61.1 annealing temperature is recommended by NEB protocol # p.seal is enforced by transcriptic # extension_time = int(max(2, np.ceil(template_length * (11.0/1000)))) assert 0 &lt; extension_time &lt; 60, "extension time should be reasonable for PCR" cycles = [{"cycles": 1, "steps": [{"temperature": "98:celsius", "duration": "30:second"}]}] + \ touchdown(70, 61, [8, 25, extension_time], stepsize=0.5) + \ [{"cycles": 16, "steps": [{"temperature": "98:celsius", "duration": "8:second"}, {"temperature": "61.1:celsius", "duration": "25:second"}, {"temperature": "72:celsius", "duration": "{:d}:second".format(extension_time)}]}, {"cycles": 1, "steps": [{"temperature": "72:celsius", "duration": "2:minute"}]}] p.seal(pcr_plate) p.thermocycle(pcr_plate, cycles, volume=¬µl(25)) # -------------------------------------------------------- # Run a gel to hopefully see a 740bp fragment # if 'run_gel' in options: p.unseal(pcr_plate) p.mix(pcr_plate.wells(["A1","B1","C1","A2"]), volume=¬µl(12.5), repetitions=10) p.transfer(pcr_plate.wells(["A1","B1","C1","A2"]), pcr_plate.wells(["D1","E1","F1","D2"]), [¬µl(2), ¬µl(4), ¬µl(8), ¬µl(8)]) p.transfer(water_tube, pcr_plate.wells(["D1","E1","F1","D2"]), [¬µl(18),¬µl(16),¬µl(12),¬µl(12)], mix_after=True, mix_vol=¬µl(10)) p.gel_separate(pcr_plate.wells(["D1","E1","F1","D2"]), ¬µl(20), "agarose(10,2%)", "ladder1", "10:minute", expid("gel")) #--------------------------------------------------------- # Absorbance dilution series. Take 1ul out of the 25ul pcr plate wells # if 'run_absorbance' in options: p.unseal(pcr_plate) abs_wells = ["A1","B1","C1","A2","B2","C2","A3","B3","C3"] p.transfer(water_tube, abs_plate.wells(abs_wells[0:6]), ¬µl(10)) p.transfer(water_tube, abs_plate.wells(abs_wells[6:9]), ¬µl(9)) p.transfer(pcr_plate.wells(["A1","B1","C1"]), abs_plate.wells(["A1","B1","C1"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) p.transfer(abs_plate.wells(["A1","B1","C1"]), abs_plate.wells(["A2","B2","C2"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) p.transfer(abs_plate.wells(["A2","B2","C2"]), abs_plate.wells(["A3","B3","C3"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) for wavelength in [260, 280, 320]: p.absorbance(abs_plate, abs_plate.wells(abs_wells), "{}:nanometer".format(wavelength), exp_id("abs_{}".format(wavelength)), flashes=25) # ----------------------------------------------------------------------------- # Sanger sequencing: https://developers.transcriptic.com/docs/sanger-sequencing # "Each reaction should have a total volume of 15 ¬µl and we recommend the following composition of DNA and primer: # PCR product (40 ng), primer (1 ¬µl of a 10 ¬µM stock)" # # By comparing to the gel ladder concentration (175ng/lane), it looks like 5ul of PCR product has approximately 30ng of DNA # if 'run_sanger' in options: p.unseal(pcr_plate) seq_wells = ["G1","G2"] for primer_num, seq_well in [(0, seq_wells[0]),(1, seq_wells[1])]: p.transfer(dilute_primer_tubes[primer_num], pcr_plate.wells([seq_well]), ¬µl(1), mix_before=True, mix_vol=¬µl(50)) p.transfer(pcr_plate.wells(["A1"]), pcr_plate.wells([seq_well]), ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(water_tube, pcr_plate.wells([seq_well]), ¬µl(9)) p.mix(pcr_plate.wells(seq_wells), volume=¬µl(7.5), repetitions=10) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[0]).indices(), expid("seq1")) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[1]).indices(), expid("seq2")) # ------------------------------------------------------------------------- # Then consolidate to one tube. Leave at least 3ul dead volume in each tube # remaining_volumes = [well.volume - dead_volume['96-pcr'] for well in pcr_plate.wells(["A1","B1","C1"])] print("Consolidated volume", sum(remaining_volumes, ¬µl(0))) p.consolidate(pcr_plate.wells(["A1","B1","C1"]), sfgfp_pcroe_out_tube, remaining_volumes, allow_carryover=True) uprint("\nProtocol 1. Amplify the insert (oligos previously synthesized)") jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> WARNING:root:Low volume for well sfGFP 1 /sfGFP 1 : 2.0:microliter </pre><br><pre> sfGFP 1 /sfGFP 1 2.0:microliter {'dilution': '0.25ng/ul'}<font></font>
sfgfp_pcroe_v5_puc19_primer1_10uM 75.0:microliter {}<font></font>
sfgfp_pcroe_v5_puc19_primer2_10uM 75.0:microliter {}<font></font>
Consolidated volume 52.0:microliter<font></font>
<font></font>
Protocol 1. Amplify the insert (oligos previously synthesized)<font></font>
---------------------------------------------------------------<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  11 instructions<font></font>
  8 containers<font></font>
  Total Cost: $32.18<font></font>
  Workcell Time: $4.32<font></font>
  Reagents &amp; Consumables: $27.86 </pre><br><h1> : PCR  </h1><br><h3>     </h3><br>      <b></b>     (   )   <b></b> ( ).    ,      ,     . <br><br>      D1, E1, F1   2 , 4   8   .               (50      ). ,     . <br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GelEval</a> ,   ,    ,    ,    .                .            GelEval  40 /. <br><br>  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> ,    dNTP  , ,     12,5   ,     6   740bp  25 .         GelEval  40  x 25  (1   2 ),        ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74a/f5d/284/74af5d28463dbbd2279353a4651087f6.jpg"><br> <i><font color="gray">- EcoRI- pUC19,   (D1, E1, F1),   (D2)</font></i> <br><br><h3>   PCR </h3><br>  Transcriptic          .        ,           . <br><br>   ,     .    35  PCR,             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> PCR</a> .        ‚Äî   ! ‚Äî     ,   PCR       ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/9eb/1b8/8dc9eb1b85c382df68cc064583512707.jpg"><br> <i><font color="gray">    PCR:  ,      35   42 </font></i> <br><br><h2>  2.   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para insertar nuestro ADN sfGFP en pUC19, primero debe cortar el pl√°smido. </font><font style="vertical-align: inherit;">Siguiendo el protocolo NEB, hago esto usando la enzima de restricci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EcoRI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En el inventario transcriptico est√°ndar hay reactivos que necesito: estos son </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEB EcoRI y 10x CutSmart buffer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ como el pl√°smido </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEB pUC19</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para informaci√≥n, a continuaci√≥n se encuentran los precios de su inventario. </font><font style="vertical-align: inherit;">De hecho, pago solo una parte del precio, ya que Transcriptic toma el pago por la cantidad realmente consumida:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID del art√≠culo Cantidad Precio de concentraci√≥n</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
------------ ------ ------------- ----------------- - ----</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CutSmart 10x B7204S 5 ml 10 X $ 19.00</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EcoRI R3101L 50,000 unidades 20,000 unidades / ml $ 225.00</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pUC19 N3041L 250 Œºg 1,000 Œºg / ml $ 268.00 </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Segu√≠ el protocolo NEB tanto como pude: </font></font><br><br><blockquote>       .   10X  dH2O    1X.   ,  ,   , , .   50    5  10x NEBuffer       ,   dH2O. <br><br>      ,    1  Œª    1   37¬∞C     50 .  ,   5-10       10-20     1- . <br><br>   1      50 . </blockquote><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Protocol for cutting pUC19 with EcoRI."""</span></span> p = Protocol() experiment_name = <span class="hljs-string"><span class="hljs-string">"puc19_ecori_v3"</span></span> options = {} inv = { <span class="hljs-string"><span class="hljs-string">'water'</span></span>: <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "pUC19": "rs17tcqmncjfsh", # catalog; pUC19; cold_20 "EcoRI": "rs17ta8xftpdk6", # catalog; EcoRI-HF; cold_20 "CutSmart": "rs17ta93g3y85t", # catalog; CutSmart Buffer 10x; cold_20 "ecori_p10x": "ct187v4ea85k2h", # inventory; EcoRI diluted 10x } # Tubes and plates I use then discard re_tube = p.ref("re_tube", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) water_tube = p.ref("water_tube", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) pcr_plate = p.ref("pcr_plate", cont_type="96-pcr", storage="cold_4", discard=True) # The result of the experiment, a pUC19 cut by EcoRI, goes in this tube for storage puc19_cut_tube = p.ref(expid("puc19_cut"), cont_type="micro-1.5", storage="cold_20").well(0) # ------------------------------------------------------------- # Provisioning and diluting. # Diluted EcoRI can be used more than once # p.provision(inv["water"], water_tube, ¬µl(500)) if 'dilute_ecori' in options: ecori_p10x_tube = p.ref("ecori_p10x", cont_type="micro-1.5", storage="cold_20").well(0) p.transfer(water_tube, ecori_p10x_tube, ¬µl(45)) p.provision(inv["EcoRI"], ecori_p10x_tube, ¬µl(5)) else: # All "inventory" (stuff I own at transcriptic) must be initialized ecori_p10x_tube = p.ref("ecori_p10x", id=inv["ecori_p10x"], cont_type="micro-1.5", storage="cold_20").well(0) init_inventory_well(ecori_p10x_tube) # ------------------------------------------------------------- # Restriction enzyme cutting pUC19 # # 50ul total reaction volume for cutting 1ug of DNA: # 5ul CutSmart 10x # 1ul pUC19 (1ug of DNA) # 1ul EcoRI (or 10ul diluted EcoRI, 20 units, &gt;10 units per ug DNA) # p.transfer(water_tube, re_tube, ¬µl(117)) p.provision(inv["CutSmart"], re_tube, ¬µl(15)) p.provision(inv["pUC19"], re_tube, ¬µl(3)) p.mix(re_tube, volume=¬µl(60), repetitions=10) assert re_tube.volume == ¬µl(120) + dead_volume["micro-1.5"] print("Volumes: re_tube:{} water_tube:{} EcoRI:{}".format(re_tube.volume, water_tube.volume, ecori_p10x_tube.volume)) p.distribute(re_tube, pcr_plate.wells(["A1","B1","A2"]), ¬µl(40)) p.distribute(water_tube, pcr_plate.wells(["A2"]), ¬µl(10)) p.distribute(ecori_p10x_tube, pcr_plate.wells(["A1","B1"]), ¬µl(10)) assert all(well.volume == ¬µl(50) for well in pcr_plate.wells(["A1","B1","A2"])) p.mix(pcr_plate.wells(["A1","B1","A2"]), volume=¬µl(25), repetitions=10) # Incubation to induce cut, then heat inactivation of EcoRI p.seal(pcr_plate) p.incubate(pcr_plate, "warm_37", "60:minute", shaking=False) p.thermocycle(pcr_plate, [{"cycles": 1, "steps": [{"temperature": "65:celsius", "duration": "21:minute"}]}], volume=¬µl(50)) # -------------------------------------------------------------- # Gel electrophoresis, to ensure the cutting worked # p.unseal(pcr_plate) p.mix(pcr_plate.wells(["A1","B1","A2"]), volume=¬µl(25), repetitions=5) p.transfer(pcr_plate.wells(["A1","B1","A2"]), pcr_plate.wells(["D1","E1","D2"]), ¬µl(8)) p.transfer(water_tube, pcr_plate.wells(["D1","E1","D2"]), ¬µl(15), mix_after=True, mix_vol=¬µl(10)) assert all(well.volume == ¬µl(20) + dead_volume["96-pcr"] for well in pcr_plate.wells(["D1","E1","D2"])) p.gel_separate(pcr_plate.wells(["D1","E1","D2"]), ¬µl(20), "agarose(10,2%)", "ladder2", "15:minute", expid("gel")) # ---------------------------------------------------------------------------- # Then consolidate all cut plasmid to one tube (puc19_cut_tube). # remaining_volumes = [well.volume - dead_volume['96-pcr'] for well in pcr_plate.wells(["A1","B1"])] print("Consolidated volume: {}".format(sum(remaining_volumes, ¬µl(0)))) p.consolidate(pcr_plate.wells(["A1","B1"]), puc19_cut_tube, remaining_volumes, allow_carryover=True) assert all(tube.volume &gt;= dead_volume['micro-1.5'] for tube in [water_tube, re_tube, puc19_cut_tube, ecori_p10x_tube]) # --------------------------------------------------------------- # Test protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("Protocol {}\n\n{}".format(experiment_name, jprotocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> Volumes: re_tube:135.0:microliter water_tube:383.0:microliter EcoRI:30.0:microliter<font></font>
Consolidated volume: 78.0:microliter<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  12 instructions<font></font>
  5 containers<font></font>
  Total Cost: $30.72<font></font>
  Workcell Time: $3.38<font></font>
  Reagents &amp; Consumables: $27.34 </pre><br><h3> :   </h3><br>              ,    .    . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´¬ª </a> (  1,5    15 !). ,     D1  E1 (     ).     ,      EcoRI   . <br><br>    ,     D1  E1      2,6kb.   D2  :   ,           . <br><br>      -.    ,    Transcriptic   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f8/b9c/e3c/8f8b9ce3cc42de99099976a3c60a9ada.jpg"><br> <i><font color="gray"> ,   pUC19 (2,6kb)   D1  E1,   pUC19  D2</font></i> <br><br><h2>  3.    </h2><br>    ,       ‚Äî    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> M13</a> (  )          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qPCR</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,  ,   .      ,  ,     ,       . <br><br>     ,   M13  ,         M13. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Debugging transformation protocol: Gibson assembly followed by qPCR and a gel v2: include v3 Gibson assembly"""</span></span> p = Protocol() options = {} experiment_name = <span class="hljs-string"><span class="hljs-string">"debug_sfgfp_puc19_gibson_seq_v2"</span></span> inv = { <span class="hljs-string"><span class="hljs-string">"water"</span></span> : <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "M13_F" : "rs17tcpqwqcaxe", # catalog; M13 Forward (-41); cold_20 (1ul = 100pmol) "M13_R" : "rs17tcph6e2qzh", # catalog; M13 Reverse (-48); cold_20 (1ul = 100pmol) "SensiFAST_SYBR_No-ROX" : "rs17knkh7526ha", # catalog; SensiFAST SYBR for qPCR "sfgfp_puc19_gibson_v1_clone" : "ct187rzdq9kd7q", # inventory; assembled sfGFP; cold_4 "sfgfp_puc19_gibson_v3_clone" : "ct188ejywa8jcv", # inventory; assembled sfGFP; cold_4 } # --------------------------------------------------------------- # First get my sfGFP pUC19 clones, assembled with Gibson assembly # clone_plate1 = p.ref("sfgfp_puc19_gibson_v1_clone", id=inv["sfgfp_puc19_gibson_v1_clone"], cont_type="96-pcr", storage="cold_4", discard=False) clone_plate2 = p.ref("sfgfp_puc19_gibson_v3_clone", id=inv["sfgfp_puc19_gibson_v3_clone"], cont_type="96-pcr", storage="cold_4", discard=False) water_tube = p.ref("water", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) master_tube = p.ref("master", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) primer_tube = p.ref("primer", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) pcr_plate = p.ref(expid("pcr_plate"), cont_type="96-pcr", storage="cold_4", discard=False) init_inventory_well(clone_plate1.well("A1")) init_inventory_well(clone_plate2.well("A1")) seq_wells = ["B2","B4","B6", # clone_plate1 "D2","D4","D6", # clone_plate2 "F2","F4"] # control # clone_plate2 was diluted 4X (20ul-&gt;80ul), according to NEB instructions assert clone_plate1.well("A1").volume == ¬µl(18), clone_plate1.well("A1").volume assert clone_plate2.well("A1").volume == ¬µl(78), clone_plate2.well("A1").volume # -------------------------------------------------------------- # Provisioning # p.provision(inv["water"], water_tube, ¬µl(500)) # primers, diluted 2X, discarded at the end p.provision(inv["M13_F"], primer_tube, ¬µl(13)) p.provision(inv["M13_R"], primer_tube, ¬µl(13)) p.transfer(water_tube, primer_tube, ¬µl(26), mix_after=True, mix_vol=¬µl(20), repetitions=10) # ------------------------------------------------------------------- # PCR Master mix -- 10ul SYBR mix, plus 1ul each undiluted primer DNA (100pmol) # Also add 15ul of dead volume # p.provision(inv['SensiFAST_SYBR_No-ROX'], master_tube, ¬µl(11+len(seq_wells)*10)) p.transfer(primer_tube, master_tube, ¬µl(4+len(seq_wells)*4)) p.mix(master_tube, volume=¬µl(63), repetitions=10) assert master_tube.volume == ¬µl(127) # 15ul dead volume p.distribute(master_tube, pcr_plate.wells(seq_wells), ¬µl(14), allow_carryover=True) p.distribute(water_tube, pcr_plate.wells(seq_wells), [¬µl(ul) for ul in [5,4,2, 4,2,0, 6,6]], allow_carryover=True) # Template -- starting with some small, unknown amount of DNA produced by Gibson p.transfer(clone_plate1.well("A1"), pcr_plate.wells(seq_wells[0:3]), [¬µl(1),¬µl(2),¬µl(4)], one_tip=True) p.transfer(clone_plate2.well("A1"), pcr_plate.wells(seq_wells[3:6]), [¬µl(2),¬µl(4),¬µl(6)], one_tip=True) assert all(pcr_plate.well(w).volume == ¬µl(20) for w in seq_wells) assert clone_plate1.well("A1").volume == ¬µl(11) assert clone_plate2.well("A1").volume == ¬µl(66) # -------------------------------------------------------------- # qPCR # standard melting curve parameters # p.seal(pcr_plate) p.thermocycle(pcr_plate, [{"cycles": 1, "steps": [{"temperature": "95:celsius","duration": "2:minute"}]}, {"cycles": 40, "steps": [{"temperature": "95:celsius","duration": "5:second"}, {"temperature": "60:celsius","duration": "20:second"}, {"temperature": "72:celsius","duration": "15:second", "read": True}]}], volume=¬µl(20), # volume is optional dataref=expid("qpcr"), dyes={"SYBR": seq_wells}, # dye must be specified (tells transcriptic what aborbance to use?) melting_start="65:celsius", melting_end="95:celsius", melting_increment="0.5:celsius", melting_rate="5:second") # -------------------------------------------------------------- # Gel -- 20ul required # Dilute such that I have 11ul for sequencing # p.unseal(pcr_plate) p.distribute(water_tube, pcr_plate.wells(seq_wells), ¬µl(11)) p.gel_separate(pcr_plate.wells(seq_wells), ¬µl(20), "agarose(8,0.8%)", "ladder1", "10:minute", expid("gel")) # This appears to be a bug in Transcriptic. The actual volume should be 11ul # but it is not updating after running a gel with 20ul. # Primer tube should be equal to dead volume, or it's a waste assert all(pcr_plate.well(w).volume==¬µl(31) for w in seq_wells) assert primer_tube.volume == ¬µl(16) == dead_volume['micro-1.5'] + ¬µl(1) assert water_tube.volume &gt; ¬µl(25) # --------------------------------------------------------------- # Test and run protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> WARNING:root:Low volume for well sfgfp_puc19_gibson_v1_clone/sfgfp_puc19_gibson_v1_clone : 11.0:microliter </pre><br><pre> ‚úì Protocol analyzed<font></font>
  11 instructions<font></font>
  6 containers<font></font>
  Total Cost: $32.09<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Tiempo de celda de trabajo: $ 6.98</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Reactivos y consumibles: $ 25.11 </font></font></pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados: qPCR para ensamblaje Gibson </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puedo acceder a los datos de qPCR en formato JSON a trav√©s de la API transcriptica. </font><font style="vertical-align: inherit;">Esta caracter√≠stica no est√° bien </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero puede ser extremadamente √∫til. </font><font style="vertical-align: inherit;">Las API incluso le dan acceso a algunos datos de diagn√≥stico de robots, que pueden ayudar con la depuraci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, solicitamos datos de lanzamiento:</font></font><br><br><pre> <code class="python hljs">project_id, run_id = <span class="hljs-string"><span class="hljs-string">"p16x6gna8f5e9"</span></span>, <span class="hljs-string"><span class="hljs-string">"r18mj3cz3fku7"</span></span> api_url = <span class="hljs-string"><span class="hljs-string">"https://secure.transcriptic.com/hgbrian/{}/runs/{}/data.json"</span></span>.format(project_id, run_id) data_response = requests.get(api_url, headers=tsc_headers) data = data_response.json()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luego, especificamos esta identificaci√≥n para obtener los datos de "procesamiento posterior" de qPCR: </font></font><br><br><pre> <code class="python hljs">qpcr_id = data[<span class="hljs-string"><span class="hljs-string">'debug_sfgfp_puc19_gibson_seq_v1_qpcr'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>] pp_api_url = <span class="hljs-string"><span class="hljs-string">"https://secure.transcriptic.com/data/{}.json?key=postprocessed_data"</span></span>.format(qpcr_id) data_response = requests.get(pp_api_url, headers=tsc_headers) pp_data = data_response.json()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√°n los valores de Ct (umbral de ciclo) para cada tubo. </font><font style="vertical-align: inherit;">Ct es simplemente el punto en el que la fluorescencia excede un cierto valor. </font><font style="vertical-align: inherit;">Ella dice aproximadamente cu√°nto ADN hay en este momento (y, por lo tanto, aproximadamente d√≥nde comenzamos).</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Simple util to convert wellnum to wellname n_w = {str(wellnum):'ABCDEFGH'[wellnum//12]+str(1+wellnum%12) for wellnum in range(96)} w_n = {v: k for k, v in n_w.items()} ct_vals = {n_w[k]:v for k,v in pp_data["amp0"]["SYBR"]["cts"].items()} ct_df = pd.DataFrame(ct_vals, index=["Ct"]).T ct_df["well"] = ct_df.index f, ax = plt.subplots(figsize=(16,6)) _ = sns.barplot(y="well", x="Ct", data=ct_df)</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/32f/a42/de3/32fa42de3ad35392ac0bbf7ae6f595b3.png"><br><br>  ,       D2/4/6 (      ¬´v3¬ª),  B2/4/6 (  ¬´v1¬ª).   v1  v3     ,   v3  4X     NEB,     .      30    (F2, F4),   -,    ,         . <br><br>       qPCR,    . <br><br><pre> <code class="python hljs">f, ax = plt.subplots(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)) ax.set_color_cycle([<span class="hljs-string"><span class="hljs-string">'#fb6a4a'</span></span>, <span class="hljs-string"><span class="hljs-string">'#de2d26'</span></span>, <span class="hljs-string"><span class="hljs-string">'#a50f15'</span></span>, <span class="hljs-string"><span class="hljs-string">'#74c476'</span></span>, <span class="hljs-string"><span class="hljs-string">'#31a354'</span></span>, <span class="hljs-string"><span class="hljs-string">'#006d2c'</span></span>, <span class="hljs-string"><span class="hljs-string">'#08519c'</span></span>, <span class="hljs-string"><span class="hljs-string">'#6baed6'</span></span>]) amp0 = pp_data[<span class="hljs-string"><span class="hljs-string">'amp0'</span></span>][<span class="hljs-string"><span class="hljs-string">'SYBR'</span></span>][<span class="hljs-string"><span class="hljs-string">'baseline_subtracted'</span></span>] _ = [plt.plot(amp0[w_n[well]], label=well) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> well <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">'B2'</span></span>, <span class="hljs-string"><span class="hljs-string">'B4'</span></span>, <span class="hljs-string"><span class="hljs-string">'B6'</span></span>, <span class="hljs-string"><span class="hljs-string">'D2'</span></span>, <span class="hljs-string"><span class="hljs-string">'D4'</span></span>, <span class="hljs-string"><span class="hljs-string">'D6'</span></span>, <span class="hljs-string"><span class="hljs-string">'F2'</span></span>, <span class="hljs-string"><span class="hljs-string">'F4'</span></span>]] _ = ax.set_ylim(<span class="hljs-number"><span class="hljs-number">0</span></span>,) _ = plt.title(<span class="hljs-string"><span class="hljs-string">"qPCR (reds=Gibson v1, greens=Gibson v3, blues=control)"</span></span>) _ = plt.legend(bbox_to_anchor=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">.75</span></span>), bbox_transform=plt.gcf().transFigure)</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/88e/d2a/a19/88ed2aa19537b77b3214e6b36f55fdde.png"><br><br>  ,  qPCR  ,               .   v3    ,  v1,    . <br><br><h3> :     </h3><br>    ,      1kb   B2, B4, B6, D2, D4, D6:      (   740bp,   M13 ‚Äî  40bp   ).    .     ,    F2  F4    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf7/509/629/cf750962951b700c8a9333ea1d747a94.jpg"><br> <i><font color="gray">   :    v3     (D2, D4, D6),       qPCR</font></i> <br><br><h2>  4.  </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ‚Äî       .     <b></b> <i>E. coli</i>   sfGFP-  pUC19. <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zymo DH5Œ± Mix&amp;Go</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> .   ‚Äî    Transcriptic.  ,    ,     ,      ,  .        , ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/951/9a6/a57/9519a6a578f11d26c3c9a2ddda039539.jpg"><br> <i><font color="gray"> Zymo Mix &amp; Go   </font></i> <br><br><h4>    </h4><br>   ‚Äî  ,               .      (¬´     ¬ª),      ,         (¬´,   ¬ª).      ,      . <br><br>        .   ,                  37¬∞C. ,      ,      ,  ,   Transcriptic     ‚Äî   ,      .     , ,       -    ,    . .      . <br><br>    :        (,   ,   Mix&amp;Go );        (,     );        (,   PCR   ). <br><br> ,    , ,     ,         .     ,   ,     ! <br><br><h2>   </h2><br>        ,    ,  ,      pUC19 (. .        sfGFP) . pUC19     ,         ,   . <br><br>       (¬´6-flat¬ª   Transcriptic),    ,  .  ,         , ,  .     . <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Simple transformation protocol: transformation with unaltered pUC19"""</span></span> p = Protocol() experiment_name = <span class="hljs-string"><span class="hljs-string">"debug_sfgfp_puc19_gibson_v1"</span></span> inv = { <span class="hljs-string"><span class="hljs-string">"water"</span></span> : <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "DH5a" : "rs16pbj944fnny", # catalog; Zymo DH5Œ±; cold_80 "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "pUC19" : "rs17tcqmncjfsh", # catalog; pUC19; cold_20 } # Catalog transform_plate = p.ref("transform_plate", cont_type="96-pcr", storage="ambient", discard=True) transform_tube = transform_plate.well(0) # ------------------------------------------------------------------------------------ # Plating transformed bacteria according to Tali's protocol (requires different code!) # http://learn.transcriptic.com/blog/2015/9/9/provisioning-commercial-reagents # Add 1-5ul plasmid and pre-warm culture plates to 37C before starting. # # # Extra inventory for plating # inv["lb-broth-100ug-ml-amp_6-flat"] = "ki17sbb845ssx9" # (kit, not normal ref) from blogpost inv["noAB-amp_6-flat"] = "ki17reefwqq3sq" # kit id inv["LB Miller"] = "rs17bafcbmyrmh" # # Ampicillin and no ampicillin plates # amp_6_flat = Container(None, p.container_type('6-flat')) p.refs["amp_6_flat"] = Ref('amp_6_flat', {"reserve": inv['lb-broth-100ug-ml-amp_6-flat'], "store": {"where": 'cold_4'}}, amp_6_flat) noAB_6_flat = Container(None, p.container_type('6-flat')) p.refs["noAB_6_flat"] = Ref('noAB_6_flat', {"reserve": inv['noAB-amp_6-flat'], "store": {"where": 'cold_4'}}, noAB_6_flat) # # Provision competent bacteria # p.provision(inv["DH5a"], transform_tube, ¬µl(50)) p.provision(inv["pUC19"], transform_tube, ¬µl(2)) # # Heatshock the bacteria to transform using a PCR machine # p.seal(transform_plate) p.thermocycle(transform_plate, [{"cycles": 1, "steps": [{"temperature": "4:celsius", "duration": "5:minute"}]}, {"cycles": 1, "steps": [{"temperature": "37:celsius", "duration": "30:minute"}]}], volume=¬µl(50)) p.unseal(transform_plate) # # Then dilute bacteria and spread onto 6-flat plates # Put more on ampicillin plates for more opportunities to get a colony # p.provision(inv["LB Miller"], transform_tube, ¬µl(355)) p.mix(transform_tube, ¬µl(150), repetitions=5) for i in range(6): p.spread(transform_tube, amp_6_flat.well(i), ¬µl(55)) p.spread(transform_tube, noAB_6_flat.well(i), ¬µl(10)) assert transform_tube.volume &gt;= ¬µl(15), transform_tube.volume # # Incubate and image 6-flat plates over 18 hours # for flat_name, flat in [("amp_6_flat", amp_6_flat), ("noAB_6_flat", noAB_6_flat)]: for timepoint in [6,12,18]: p.cover(flat) p.incubate(flat, "warm_37", "6:hour") p.uncover(flat) p.image_plate(flat, mode="top", dataref=expid("{}_t{}".format(flat_name, timepoint))) # --------------------------------------------------------------- # Analyze protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("Protocol {}\n\n{}".format(experiment_name, protocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> ‚úì Protocol analyzed<font></font>
  43 instructions<font></font>
  3 containers<font></font>
  $45.43 </pre><br><h3> :   </h3><br>     ,    ( )      ,     ,   . ,  Transcriptic      ,    . <br><br>    ( )   ,    .       ,   , , ,    55        10     .               .        ,    .        ,       ,         . <br><br> (          ,        ,    ,        <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E. coli</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El crecimiento es mucho m√°s d√©bil en las placas de ampicilina, aunque hay muchas m√°s bacterias all√≠, como se esperaba). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, la transformaci√≥n funcion√≥ lo suficientemente bien como para continuar, aunque hay algunos defectos. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/296/c9b/7e2/296c9b7e28b653015159907b8a2bb59e.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placas de c√©lulas transformadas con pUC19 despu√©s de 18 horas: sin antibi√≥tico (izquierda) y con antibi√≥tico (derecha)</font></font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transformaci√≥n del producto despu√©s del montaje. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que el ensamblaje Gibson y la simple transformaci√≥n pUC19 parecen funcionar, ahora puede probar la transformaci√≥n con un pl√°smido completamente ensamblado que exprese sfGFP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de la inserci√≥n recopilada, tambi√©n agregar√© un poco de IPTG y X-gal a las placas para ver la conversi√≥n exitosa utilizando el m√©todo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selecci√≥n azul y blanco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta informaci√≥n adicional es √∫til, porque si la transformaci√≥n se lleva a cabo con el pUC19 habitual, que no contiene sfGFP, todav√≠a dar√° resistencia a los antibi√≥ticos.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absorci√≥n y fluorescencia. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seg√∫n esta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabla</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sfGFP brilla mejor a longitudes de onda de excitaci√≥n de 485 nm / 510 nm. </font><font style="vertical-align: inherit;">Encontr√© que en Transcriptic, 485/535 funciona mejor. </font><font style="vertical-align: inherit;">Supongo que porque 485 y 510 son demasiado similares. </font><font style="vertical-align: inherit;">Mido el crecimiento bacteriano a 600 nm ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OD600</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ab/0d3/453/6ab0d345359a5b1d15f8f6341f1bee08.png"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variedad de GFP ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biotek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPTG y X-gal </font></font></h4><br>  IPTG    1M    1:1000.   , X-gal   20 /    1:1000 (20 /). ,  2000¬µl LB    2  . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>    40  X-gal   20 /  40  IPTG  0,1 mM ( 4  IPTG  1M),   30 .      ,     IPTG, X-gal        . <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Full Gibson assembly and transformation protocol for sfGFP and pUC19 v1: Spread IPTG and X-gal onto plates, then spread cells v2: Mix IPTG, X-gal and cells; spread the mixture v3: exclude X-gal so I can do colony picking better v4: repeat v3 to try other excitation/emission wavelengths"""</span></span> p = Protocol() options = { <span class="hljs-string"><span class="hljs-string">"gibson"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-comment"><span class="hljs-comment"># do a new gibson assembly "sanger" : False, # sanger sequence product "control_pUC19" : True, # unassembled pUC19 "XGal" : False # excluding X-gal should make the colony picking easier } for k, v in list(options.items()): if v is False: del options[k] experiment_name = "sfgfp_puc19_gibson_plates_v4" # ----------------------------------------------------------------------- # Inventory # inv = { # catalog "water" : "rs17gmh5wafm5p", # catalog; Autoclaved MilliQ H2O; ambient "DH5a" : "rs16pbj944fnny", # catalog; Zymo DH5Œ±; cold_80 "Gibson Mix" : "rs16pfatkggmk5", # catalog; Gibson Mix (2X); cold_20 "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "pUC19" : "rs17tcqmncjfsh", # catalog; pUC19; cold_20 # my inventory "puc19_cut_v2": "ct187v4ea7vvca", # inventory; pUC19 cut with EcoRI; cold_20 "IPTG" : "ct18a2r5wn6tqz", # inventory; IPTG at 1M (conc semi-documented); cold_20 "XGal" : "ct18a2r5wp5hcv", # inventory; XGal at 0.1M (conc not documented); cold_20 "sfgfp_pcroe_v8_amplified" : "ct1874zqh22pab", # inventory; sfGFP amplified to 40ng/ul; cold_4 "sfgfp_puc19_gibson_v3_clone" : "ct188ejywa8jcv", # inventory; assembled sfGFP; cold_4 # kits (must be used differently) "lb-broth-100ug-ml-amp_6-flat" : "ki17sbb845ssx9", # catalog; ampicillin plates "noAB-amp_6-flat" : "ki17reefwqq3sq" # catalog; no antibiotic plates } # # Catalog (all to be discarded afterward) # water_tube = p.ref("water", cont_type="micro-1.5", storage="ambient", discard=True).well(0) transform_plate = p.ref("trn_plate", cont_type="96-pcr", storage="ambient", discard=True) transform_tube = transform_plate.well(39) # experiment transform_tube_L = p.ref("trn_tubeL", cont_type="micro-1.5", storage="ambient", discard=True).well(0) transctrl_tube = transform_plate.well(56) # control transctrl_tube_L = p.ref("trc_tubeL", cont_type="micro-1.5", storage="ambient", discard=True).well(0) # # Plating according to Tali's protocol # http://learn.transcriptic.com/blog/2015/9/9/provisioning-commercial-reagents # amp_6_flat = Container(None, p.container_type('6-flat')) p.refs[expid("amp_6_flat")] = Ref(expid("amp_6_flat"), {"reserve": inv['lb-broth-100ug-ml-amp_6-flat'], "store": {"where": 'cold_4'}}, amp_6_flat) noAB_6_flat = Container(None, p.container_type('6-flat')) p.refs[expid("noAB_6_flat")] = Ref(expid("noAB_6_flat"), {"reserve": inv['noAB-amp_6-flat'], "store": {"where": 'cold_4'}}, noAB_6_flat) # # My inventory: EcoRI-cut pUC19, oePCR'd sfGFP, Gibson-assembled pUC19, IPTG and X-Gal # if "gibson" in options: puc19_cut_tube = p.ref("puc19_ecori_v2_puc19_cut", id=inv["puc19_cut_v2"], cont_type="micro-1.5", storage="cold_20").well(0) sfgfp_pcroe_amp_tube = p.ref("sfgfp_pcroe_v8_amplified", id=inv["sfgfp_pcroe_v8_amplified"], cont_type="micro-1.5", storage="cold_4").well(0) clone_plate = p.ref(expid("clone"), cont_type="96-pcr", storage="cold_4", discard=False) else: clone_plate = p.ref("sfgfp_puc19_gibson_v3_clone", id=inv["sfgfp_puc19_gibson_v3_clone"], cont_type="96-pcr", storage="cold_4", discard=False) IPTG_tube = p.ref("IPTG", id=inv["IPTG"], cont_type="micro-1.5", storage="cold_20").well(0) if "XGal" in options: XGal_tube = p.ref("XGal", id=inv["XGal"], cont_type="micro-1.5", storage="cold_20").well(0) # # Initialize inventory # if "gibson" in options: all_inventory_wells = [puc19_cut_tube, sfgfp_pcroe_amp_tube, IPTG_tube] assert puc19_cut_tube.volume == ¬µl(66), puc19_cut_tube.volume assert sfgfp_pcroe_amp_tube.volume == ¬µl(36), sfgfp_pcroe_amp_tube.volume else: all_inventory_wells = [IPTG_tube, clone_plate.well(0)] if "XGal" in options: all_inventory_wells.append(XGal_tube) for well in all_inventory_wells: init_inventory_well(well) print("Inventory: {} {} {}".format(well.name, well.volume, well.properties)) # # Provisioning. Water is used all over the protocol. Provision an excess since it's cheap # p.provision(inv["water"], water_tube, ¬µl(500)) # ----------------------------------------------------------------------------- # Cloning/assembly (see NEBuilder protocol above) # # "Optimized efficiency is 50‚Äì100 ng of vectors with 2 fold excess of inserts." # pUC19 is 20ng/ul (78ul total). # sfGFP is ~40ng/ul (48ul total) # Therefore 4ul of each gives 80ng and 160ng of vector and insert respectively # def do_gibson_assembly(): # # Combine all the Gibson reagents in one tube and thermocycle # p.provision(inv["Gibson Mix"], clone_plate.well(0), ¬µl(10)) p.transfer(water_tube, clone_plate.well(0), ¬µl(2)) p.transfer(puc19_cut_tube, clone_plate.well(0), ¬µl(4)) p.transfer(sfgfp_pcroe_amp_tube, clone_plate.well(0), ¬µl(4), mix_after=True, mix_vol=¬µl(10), repetitions=10) p.seal(clone_plate) p.thermocycle(clone_plate, [{"cycles": 1, "steps": [{"temperature": "50:celsius", "duration": "16:minute"}]}], volume=¬µl(50)) # # Dilute assembled plasmid 4X according to the NEB Gibson assembly protocol (20ul-&gt;80ul) # p.unseal(clone_plate) p.transfer(water_tube, clone_plate.well(0), ¬µl(60), mix_after=True, mix_vol=¬µl(40), repetitions=5) return # -------------------------------------------------------------------------------------------------- # Transformation # "Transform NEB 5-alpha Competent E. coli cells with 2 Œºl of the # assembled product, following the appropriate transformation protocol." # # Mix &amp; Go http://www.zymoresearch.com/downloads/dl/file/id/173/t3015i.pdf # "[After mixing] Immediately place on ice and incubate for 2-5 minutes" # "The highest transformation efficiencies can be obtained by incubating Mix &amp; Go cells with DNA on # ice for 2-5 minutes (60 minutes maximum) prior to plating." # "It is recommended that culture plates be pre-warmed to &gt;20¬∞C (preferably 37¬∞C) prior to plating." # "Avoid exposing the cells to room temperature for more than a few seconds at a time." # # "If competent cells are purchased from other manufacture, dilute assembled products 4-fold # with H2O prior transformation. This can be achieved by mixing 5 Œºl of assembled products with # 15 Œºl of H2O. Add 2 Œºl of the diluted assembled product to competent cells." # def _do_transformation(): # # Combine plasmid and competent bacteria in a pcr_plate and shock # p.provision(inv["DH5a"], transform_tube, ¬µl(50)) p.transfer(clone_plate.well(0), transform_tube, ¬µl(3), dispense_speed="10:microliter/second") assert clone_plate.well(0).volume == ¬µl(54), clone_plate.well(0).volume if 'control_pUC19' in options: p.provision(inv["DH5a"], transctrl_tube, ¬µl(50)) p.provision(inv["pUC19"], transctrl_tube, ¬µl(1)) # # Heatshock the bacteria to transform using a PCR machine # p.seal(transform_plate) p.thermocycle(transform_plate, [{"cycles": 1, "steps": [{"temperature": "4:celsius", "duration": "5:minute"}]}, {"cycles": 1, "steps": [{"temperature": "37:celsius", "duration": "30:minute"}]}], volume=¬µl(50)) return def _transfer_transformed_to_plates(): assert transform_tube.volume == ¬µl(53), transform_tube.volume p.unseal(transform_plate) num_ab_plates = 4 # antibiotic places # # Transfer bacteria to a bigger tube for diluting # Then spread onto 6-flat plates # Generally you would spread 50-100ul of diluted bacteria # Put more on ampicillin plates for more opportunities to get a colony # I use a dilution series since it's unclear how much to plate # p.provision(inv["LB Miller"], transform_tube_L, ¬µl(429)) # # Add all IPTG and XGal to the master tube # 4ul (1M) IPTG on each plate; 40ul XGal on each plate # p.transfer(IPTG_tube, transform_tube_L, ¬µl(4*num_ab_plates)) if 'XGal' in options: p.transfer(XGal_tube, transform_tube_L, ¬µl(40*num_ab_plates)) # # Add the transformed cells and mix (use new mix op in case of different pipette) # p.transfer(transform_tube, transform_tube_L, ¬µl(50)) p.mix(transform_tube_L, volume=transform_tube_L.volume/2, repetitions=10) assert transform_tube.volume == dead_volume['96-pcr'] == ¬µl(3), transform_tube.volume assert transform_tube_L.volume == ¬µl(495), transform_tube_L.volume # # Spread an average of 60ul on each plate == 480ul total # for i in range(num_ab_plates): p.spread(transform_tube_L, amp_6_flat.well(i), ¬µl(51+i*6)) p.spread(transform_tube_L, noAB_6_flat.well(i), ¬µl(51+i*6)) assert transform_tube_L.volume == dead_volume["micro-1.5"], transform_tube_L.volume # # Controls: include 2 ordinary pUC19-transformed plates as a control # if 'control_pUC19' in options: num_ctrl = 2 assert num_ab_plates + num_ctrl &lt;= 6 p.provision(inv["LB Miller"], transctrl_tube_L, ¬µl(184)+dead_volume["micro-1.5"]) p.transfer(IPTG_tube, transctrl_tube_L, ¬µl(4*num_ctrl)) if "XGal" in options: p.transfer(XGal_tube, transctrl_tube_L, ¬µl(40*num_ctrl)) p.transfer(transctrl_tube, transctrl_tube_L, ¬µl(48)) p.mix(transctrl_tube_L, volume=transctrl_tube_L.volume/2, repetitions=10) for i in range(num_ctrl): p.spread(transctrl_tube_L, amp_6_flat.well(num_ab_plates+i), ¬µl(55+i*10)) p.spread(transctrl_tube_L, noAB_6_flat.well(num_ab_plates+i), ¬µl(55+i*10)) assert transctrl_tube_L.volume == dead_volume["micro-1.5"], transctrl_tube_L.volume assert IPTG_tube.volume == ¬µl(808), IPTG_tube.volume if "XGal" in options: assert XGal_tube.volume == ¬µl(516), XGal_tube.volume return def do_transformation(): _do_transformation() _transfer_transformed_to_plates() # ------------------------------------------------------ # Measure growth in plates (photograph) # def measure_growth(): # # Incubate and photograph 6-flat plates over 18 hours # to see blue or white colonies # for flat_name, flat in [(expid("amp_6_flat"), amp_6_flat), (expid("noAB_6_flat"), noAB_6_flat)]: for timepoint in [9,18]: p.cover(flat) p.incubate(flat, "warm_37", "9:hour") p.uncover(flat) p.image_plate(flat, mode="top", dataref=expid("{}_t{}".format(flat_name, timepoint))) return # --------------------------------------------------------------- # Sanger sequencing, TURNED OFF # Sequence to make sure assembly worked # 500ng plasmid, 1 ¬µl of a 10 ¬µM stock primer # "M13_F" : "rs17tcpqwqcaxe", # catalog; M13 Forward (-41); cold_20 (1ul = 100pmol) # "M13_R" : "rs17tcph6e2qzh", # catalog; M13 Reverse (-48); cold_20 (1ul = 100pmol) # def do_sanger_seq(): seq_primers = [inv["M13_F"], inv["M13_R"]] seq_wells = ["G1","G2"] p.unseal(pcr_plate) for primer_num, seq_well in [(0, seq_wells[0]),(1, seq_wells[1])]: p.provision(seq_primers[primer_num], pcr_plate.wells([seq_well]), ¬µl(1)) p.transfer(pcr_plate.wells(["A1"]), pcr_plate.wells(seq_wells), ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(water_tube, pcr_plate.wells(seq_wells), ¬µl(9)) p.mix(pcr_plate.wells(seq_wells), volume=¬µl(7.5), repetitions=10) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[0]).indices(), expid("seq1")) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[1]).indices(), expid("seq2")) return # --------------------------------------------------------------- # Generate protocol # # Skip Gibson since I already did it if 'gibson' in options: do_gibson_assembly() do_transformation() measure_growth() if 'sanger' in options: do_sanger_seq() # --------------------------------------------------------------- # Output protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("\nProtocol {}\n\n{}".format(experiment_name, jprotocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> Inventory: IPTG/IPTG/IPTG/IPTG/IPTG/IPTG 832.0:microliter {}<font></font>
Inventory: sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone 57.0:microliter {}<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  40 instructions<font></font>
  8 containers<font></font>
  Total Cost: $53.20<font></font>
  Workcell Time: $17.35<font></font>
  Reagents &amp; Consumables: $35.86 </pre><br><h2>   </h2><br>      ,   ¬´¬ª       96- .        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autopick</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Pick colonies from plates and grow in amp media and check for fluorescence. v2: try again with a new plate (no blue colonies) v3: repeat with different emission and excitation wavelengths"""</span></span> p = Protocol() options = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list(options.items()): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> options[k] experiment_name = <span class="hljs-string"><span class="hljs-string">"sfgfp_puc19_gibson_pick_v3"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plate_expid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""refer to the previous plating experiment's outputs"""</span></span> plate_exp = <span class="hljs-string"><span class="hljs-string">"sfgfp_puc19_gibson_plates_v4"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{}_{}"</span></span>.format(plate_exp, val) <span class="hljs-comment"><span class="hljs-comment"># ----------------------------------------------------------------------- # Inventory # inv = { # catalog "water" : "rs17gmh5wafm5p", # catalog; Autoclaved MilliQ H2O; ambient "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "IPTG" : "ct18a2r5wn6tqz", # inventory; IPTG at 1M (conc semi-documented); cold_20 # plates from previous experiment, must be changed every new experiment plate_expid("amp_6_flat") : "ct18snmr9avvg9", # inventory; Ampicillin plates with blue-white screening of pUC19 plate_expid("noAB_6_flat") : "ct18snmr9dxfw2", # inventory; no AB plates with blue-white screening of pUC19 } # Tubes and plates lb_amp_tubes = [p.ref("lb_amp_{}".format(i+1), cont_type="micro-2.0", storage="ambient", discard=True).well(0) for i in range(4)] lb_xab_tube = p.ref("lb_xab", cont_type="micro-2.0", storage="ambient", discard=True).well(0) growth_plate = p.ref(expid("growth"), cont_type="96-flat", storage="cold_4", discard=False) # My inventory IPTG_tube = p.ref("IPTG", id=inv["IPTG"], cont_type="micro-1.5", storage="cold_20").well(0) # ampicillin plate amp_6_flat = Container(None, p.container_type('6-flat')) p.refs[plate_expid("amp_6_flat")] = Ref(plate_expid("amp_6_flat"), {"id":inv[plate_expid("amp_6_flat")], "store": {"where": 'cold_4'}}, amp_6_flat) # Use a total of 50 wells abs_wells = ["{}{}".format(row,col) for row in "BCDEF" for col in range(1,11)] abs_wells_T = ["{}{}".format(row,col) for col in range(1,11) for row in "BCDEF"] assert abs_wells[:3] == ["B1","B2","B3"] and abs_wells_T[:3] == ["B1","C1","D1"] def prepare_growth_wells(): # # To LB, add ampicillin at ~1/1000 concentration # Mix slowly in case of overflow # p.provision(inv["LB Miller"], lb_xab_tube, ¬µl(1913)) for lb_amp_tube in lb_amp_tubes: p.provision(inv["Amp 100mgml"], lb_amp_tube, ¬µl(2)) p.provision(inv["LB Miller"], lb_amp_tube, ¬µl(1911)) p.mix(lb_amp_tube, volume=¬µl(800), repetitions=10) # # Add IPTG but save on X-Gal # http://openwetware.org/images/f/f1/Dh5a_sub.pdf # "If you are concerned about obtaining maximal levels of expression, add IPTG to a final concentration of 1 mM." # 2ul of IPTG in 2000ul equals 1mM # p.transfer(IPTG_tube, [lb_xab_tube] + lb_amp_tubes, ¬µl(2), one_tip=True) # # Distribute LB among wells, row D is control (no ampicillin) # cols = range(1,11) row = "D" # control, no AB cwells = ["{}{}".format(row,col) for col in cols] assert set(cwells).issubset(set(abs_wells)) p.distribute(lb_xab_tube, growth_plate.wells(cwells), ¬µl(190), allow_carryover=True) rows = "BCEF" for row, lb_amp_tube in zip(rows, lb_amp_tubes): cwells = ["{}{}".format(row,col) for col in cols] assert set(cwells).issubset(set(abs_wells)) p.distribute(lb_amp_tube, growth_plate.wells(cwells), ¬µl(190), allow_carryover=True) assert all(lb_amp_tube.volume == lb_xab_tube.volume == dead_volume['micro-2.0'] for lb_amp_tube in lb_amp_tubes) return def measure_growth_wells(): # # Growth: absorbance and fluorescence over 24 hours # Absorbance at 600nm: cell growth # Absorbance at 615nm: X-gal, in theory # Fluorescence at 485nm/510nm: sfGFP # or 450nm/508nm (http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2695656/) # hr = 4 for t in range(0,24,hr): if t &gt; 0: p.cover(growth_plate) p.incubate(growth_plate, "warm_37", "{}:hour".format(hr), shaking=True) p.uncover(growth_plate) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="485:nanometer", emission="535:nanometer", dataref=expid("fl2_{}".format(t)), flashes=25) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="450:nanometer", emission="508:nanometer", dataref=expid("fl1_{}".format(t)), flashes=25) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="395:nanometer", emission="508:nanometer", dataref=expid("fl0_{}".format(t)), flashes=25) p.absorbance(growth_plate, growth_plate.wells(abs_wells).indices(), wavelength="600:nanometer", dataref=expid("abs_{}".format(t)), flashes=25) return # --------------------------------------------------------------- # Protocol steps # prepare_growth_wells() batch = 10 for i in range(5): p.autopick(amp_6_flat.well(i), growth_plate.wells(abs_wells_T[i*batch:i*batch+batch]), dataref=expid("autopick_{}".format(i))) p.image_plate(amp_6_flat, mode="top", dataref=expid("autopicked_{}".format(i))) measure_growth_wells() # --------------------------------------------------------------- # Output protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> ‚úì Protocol analyzed<font></font>
  62 instructions<font></font>
  8 containers<font></font>
  Total Cost: $66.38<font></font>
  Workcell Time: $57.59<font></font>
  Reagents &amp; Consumables: $8.78 </pre><br><h2> :   </h2><br> ‚Äì   ,  ,       (1-4)        (5-6).   ,   ,      ,  ,    IPTG  X-gal,     Transcriptic. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc4/d2b/c10/bc4d2bc102d423993907a021598257ef.jpg"><br> <i><font color="gray">  -     (1-4)    (5-6)</font></i> <br><br>  -      - .                  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GraphicsMagick</a> ).  ,   ,     (   ,      ). <br><br>      ,   Transcriptic. ,      10     .   ,      ,      .             .      ,  ,  ,    ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8f/ee9/b71/c8fee9b710a214fdb7421dbc2d74e1b4.jpg"><br> <i><font color="gray">   -    (1-4)    (5-6),     </font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cribado azul y blanco tuvo un prop√≥sito espec√≠fico. </font><font style="vertical-align: inherit;">Mostr√≥ que la mayor√≠a de las colonias se transforman correctamente. </font><font style="vertical-align: inherit;">Al menos hay una inserci√≥n. </font><font style="vertical-align: inherit;">Sin embargo, para una mejor colecci√≥n de colonias, repet√≠ el experimento sin X-gal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo con colonias blancas el robot recolector ensambl√≥ con √©xito diez colonias de cada una de las primeras cinco placas. </font><font style="vertical-align: inherit;">Se puede suponer que en la mayor√≠a de las colonias recolectadas hay inserciones exitosas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cb/6f1/835/2cb6f183502e484f66e1f95ba1b44ed7.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colonias que crecen en placas con ampicilina (1-4) y sin antibi√≥tico (5-6)</font></font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados: transformaci√≥n con producto ensamblado </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de cultivar 50 colonias seleccionadas en una placa de 96 tubos durante 20 horas, mido la fluorescencia para verificar la expresi√≥n de sfGFP. Transcriptic utiliza un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lector Tecan Infinite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para medir la fluorescencia y la absorci√≥n (y la luminiscencia, si lo desea) </font><font style="vertical-align: inherit;">.</font></font><br><br>  ,         ,         ,      sfGFP.      ,      ,     - ,      sfGFP       . ,    sfGFP,       ,       ,       ,   . <br><br>     (OD600)        20  ( 60 ). <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>]: abs_data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">"glow/sfgfp_puc19_gibson_pick_v3_abs_{}.csv"</span></span>.format(t), index_col=<span class="hljs-string"><span class="hljs-string">"Well"</span></span>) flr_data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">"glow/sfgfp_puc19_gibson_pick_v3_fl2_{}.csv"</span></span>.format(t), index_col=<span class="hljs-string"><span class="hljs-string">"Well"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t == <span class="hljs-number"><span class="hljs-number">0</span></span>: new_data = abs_data.join(flr_data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new_data = new_data.join(abs_data, rsuffix=<span class="hljs-string"><span class="hljs-string">'_{}'</span></span>.format(t)) new_data = new_data.join(flr_data, rsuffix=<span class="hljs-string"><span class="hljs-string">'_{}'</span></span>.format(t)) new_data.columns = [<span class="hljs-string"><span class="hljs-string">"OD 600:nanometer_0"</span></span>, <span class="hljs-string"><span class="hljs-string">"Fluorescence_0"</span></span>] + list(new_data.columns[<span class="hljs-number"><span class="hljs-number">2</span></span>:])</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos en el gr√°fico los datos de la hora 20 y los rastros de mediciones anteriores. De hecho, solo me interesan los √∫ltimos datos, ya que es entonces cuando se debe observar un pico de fluorescencia.</font></font><br><br><pre> <code class="python hljs">svg = [] W, H = <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> min_x, max_x = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span> min_y, max_y = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_toxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> W*(x-min_x)/(max_x-min_x), HH*(y-min_y)/(max_y-min_y) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_topt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span>.join(map(str,_toxy(x,y))) ab_fls = [[row[<span class="hljs-number"><span class="hljs-number">0</span></span>]] + [list(row[<span class="hljs-number"><span class="hljs-number">1</span></span>])] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data.iterrows()] <span class="hljs-comment"><span class="hljs-comment"># axes svg.append('&lt;g fill="#888" font-size="18" transform="translate(20,0),scale(.95)"&gt;') svg.append('&lt;text x="0" y="{}"&gt;OD600 ‚Üí&lt;/text&gt;'.format(H+20)) svg.append('&lt;text x="0" y="0" transform="rotate(-90),translate(-{},-8)"&gt;Fluorescence ‚Üí&lt;/text&gt;'.format(H)) svg.append('&lt;line x1="0" y1="{}" x2="{}" y2="{}" style="stroke:#888;stroke-width:2" /&gt;'.format(H,W,H)) svg.append('&lt;line x1="0" y1="0" x2="0" y2="{}" style="stroke:#888;stroke-width:2" /&gt;'.format(H)) # glow filter svg.append("""&lt;filter id="glow" x="-200%" y="-200%" height="400%" width="400%"&gt; &lt;feColorMatrix type="matrix" values="0 0 0 0 0 255 0 0 0 0 0 0 0 0 0 0 0 0 1 0"/&gt; &lt;feGaussianBlur stdDeviation="10" result="coloredBlur"/&gt; &lt;feMerge&gt;&lt;feMergeNode in="coloredBlur"/&gt;&lt;feMergeNode in="SourceGraphic"/&gt;&lt;/feMerge&gt; &lt;/filter&gt;""") for n, (well, vals) in enumerate(ab_fls): fill = "#444" if not well.startswith("D") else "#aaa" gfilter = 'filter="url(#glow)"' if well in ["C3", "D1", "D3"] else "" cx, cy = _toxy(*vals[-2:]) svg.append('''&lt;g id="point{n:d}"&gt;&lt;circle {gfilter:s} r="12" cx="{cx:f}" cy="{cy:f}" fill="{fill:s}" /&gt; &lt;text x="{cx:f}" y="{cy:f}" font-size="10" text-anchor="middle" fill="#fff" alignment-baseline="middle"&gt;{txt:s}&lt;/text&gt;&lt;/g&gt; '''.format(n=n, cx=cx, cy=cy, fill=fill, txt=well, gfilter=gfilter)) pathd = 'M{} '.format(_topt(*vals[:2])) pathd += ' '.join("L{}".format(_topt(*vals[i:i+2])) for i in range(2,len(vals),2)) svg.append('''&lt;path d="{pathd:}" stroke="#ccc" stroke-width=".2" fill="none" id="path{n:d}"/&gt;'''.format(pathd=pathd, n=n)) svg.append("&lt;/g&gt;") # entire chart group show_svg(''.join(svg), w=W, h=H)</span></span></code> </pre> <br><br><img src="https://habrastorage.org/webt/03/z3/kk/03z3kkczqokp7nhgplib_q1bhia.png"><br> <i><font color="gray">  OD600:    ,     .   ,       sfGFP</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">miniprep</a> ,    ,       13.  ,  -  miniprep       - Transcriptic,    .          (C1, D1, D3)    (B1, B3, E1),    sfGFP   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muscle</a> . <br><br>   C1, D3  D3      sfGFP,      B1, B3  E1       . <br><br><h4>    </h4><br>  ,    . ,           0     (40 000 ).  20-            OD600   (, -    ),      . ,     ,  , , 11-15 . <br><br>            (. .  ,  ),  ,       ,     ). <br><br>       , ,     50   sfGFP  .    ,   . ,       ( ,  ,  miniprep),       200  ,        . <br><br>       ,          .   ,         GFP,    Python! <br><br><h1>  :  </h1><br><h4>  Precio </h4><br>    ,  ,      $360,     : <br><br><ul><li> <b>$70</b>    <br></li><li> <b>$32</b>  PCR       <br></li><li> <b>$31</b>    <br></li><li> <b>$32</b>    <br></li><li> <b>$53</b>   <br></li><li> <b>$67</b>    <br></li><li> <b>$75</b>  3 miniprep'   </li></ul><br> ,      $250-300   . ,   50     , ,    . <br><br>   ,       ( )     (  IT).  Transcriptic         ,       .        ,       ,   .  ,   ,  ,     ,     . <br><br>  ,       . ,    -     ,         .         ,       :      ,  ,  IDT       . <br><br><h4>  :    </h4><br> ,       .            ,                  : <br><br><ul><li> <b>!</b> ,   .              autoprotocol,     . <br></li><li> <b></b> .      100    ,    . <br></li><li> <b>  </b> , ,  PCR.       ,          ,      ?    /       ?    ,   ,      ,      ¬´  2-3 ¬ª.  ? <br></li><li> <b> </b> .          .     ,   . <br></li><li> <b></b> .       . <br></li><li> <b></b> .           . ,      1  96    (96‚àíx)   96- ,    . <br></li><li> <b> </b> .         csv   ,    . <br></li><li> <b></b> .                -    ,    . </li></ul><br> ,    ,  ,     .    ,     1994 : <br><br><ul><li>    Transcriptic   ‚Äî  .   ,    ,         ,    .         , ,     . <br></li><li>         ‚Äî        Transcriptic. <br></li><li>   ,      .     Transcriptic     ( ,   ,     ). <br></li><li>         ,        (   : ~$0).    ,       . <br></li><li> Transcriptic      .   ,    ,      . </li></ul><br><h4>     </h4><br>         ,  ,    -  ,      ,         . <br><br>   ,    : <br><br><ul><li>   Twist/IDT/Gen9  Transcriptic (,     -     ). <br></li><li>    ,    ,       , ,    . . <br></li><li>     (    NEB,    IDT)       (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer3</a> ). </li></ul><br>          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ) , ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . ,               in vivo (. .   ). <br><br>     ,        , :    RBS   ,    ;        ;   . <br><br><h4>   ? </h4><br>        ,    .   : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   - //,  . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   ,   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . <br></li><li>    <i>in vivo</i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">split-GFP</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">scFv</a>     .  scFvs   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BiTE</a>     ,      (   ,  ). <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haga una vacuna local que ingrese al cuerpo a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trav√©s de los fol√≠culos pilosos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (no recomiendo probar esto en casa).</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mutagenice su prote√≠na de cientos de maneras diferentes y vea qu√© sucede. </font><font style="vertical-align: inherit;">¬øEntonces escalar a 1000 o 10,000 mutaciones? </font><font style="vertical-align: inherit;">¬øQuiz√°s caracterizar las mutaciones de GFP?</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener nuevas ideas sobre lo que es posible con el dise√±o de prote√≠nas, mire cientos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de proyectos de iGEM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al final, quiero agradecer al </font><font style="vertical-align: inherit;">Transcriptic </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ben Miles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por su ayuda para completar este proyecto.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451124/">https://habr.com/ru/post/451124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451112/index.html">Jetpack componer</a></li>
<li><a href="../451114/index.html">Microbios ind√≠genas e investigaci√≥n de productos en tiendas</a></li>
<li><a href="../451116/index.html">C√≥mo luch√© con la Transici√≥n de elementos compartidos y escrib√≠ mi primera biblioteca de c√≥digo abierto</a></li>
<li><a href="../451118/index.html">Las pruebas no son para principiantes</a></li>
<li><a href="../451120/index.html">Sobre los desaf√≠os de portar Dead Cells a plataformas m√≥viles</a></li>
<li><a href="../451126/index.html">Caja de herramientas para investigadores - N√∫mero uno: autoorganizaci√≥n y visualizaci√≥n de datos</a></li>
<li><a href="../451130/index.html">Swift: ARC y gesti√≥n de memoria</a></li>
<li><a href="../451132/index.html">Consumer Driven Contracts o Gitlab CI-eyed QA test automation</a></li>
<li><a href="../451138/index.html">Symfony CLI - Nueva herramienta de desarrollo local</a></li>
<li><a href="../451140/index.html">¬øCu√°nto cuesta crear una soluci√≥n de IoT?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>