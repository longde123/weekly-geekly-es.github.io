<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé® üèÖ üßï Fa√ßons de trouver le but. Le r√¥le du hasard üßúüèæ üêª üöØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 
 La recherche peut √™tre complexe ou simple. Lorsqu'il n'est pas connu (ou seulement partiellement connu) √† la fois l'objectif lui-m√™m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fa√ßons de trouver le but. Le r√¥le du hasard</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479414/"><h4>  1. Introduction </h4><br>  La recherche peut √™tre complexe ou simple.  Lorsqu'il n'est pas connu (ou seulement partiellement connu) √† la fois l'objectif lui-m√™me et la mani√®re de l'atteindre, le hasard est important <br><br>  Le but de l'article de recherche est de comparer les m√©thodes de recherche de la cible en mouvement (objet jaune) et immobile. <br><br>  Ces m√©thodes: <br><br><ul><li>  Recherche al√©atoire (objet rouge) </li><li>  Recherche al√©atoire avec m√©moire (objet bleu) </li><li>  Recherche al√©atoire avec m√©moire et hi√©rarchie (objet vert) </li><li>  Recherche du premier itin√©raire (objet violet) </li><li>  Recherche d'un itin√©raire court (objet marron) </li></ul><br>  Sur la figure 1, ces objets sont repr√©sent√©s.  Code de programme complet publi√© sur <a href="https://github.com/bulygina07/rp/blob/master/random_path.py">github</a> <br><br><img src="https://habrastorage.org/webt/qm/73/tj/qm73tjbhq60wc-ohyw8uuoxmli0.jpeg"><br><a name="habracut"></a><br><h4>  2. La partie principale </h4><br>  2.1.  Classe P - Recherche al√©atoire <br><br>  Le constructeur initialise les attributs et variables de classe: fen√™tre principale, couleur, coordonn√©es y et x, compteur, dictionnaire visit√©, cible, dictionnaire de hi√©rarchie, dictionnaire de voisins.  La m√©thode init_3_dict remplit trois dictionnaires.  La m√©thode d'exposition peint la cellule dans la couleur souhait√©e.  La m√©thode de mise √† jour met √† jour l'objet.  La m√©thode top_show cr√©e une fen√™tre de niveau sup√©rieur et indique le nombre d'√©tapes effectu√©es vers la cible. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, root, color, node, target, maps, ban)</span></span></span><span class="hljs-function">:</span></span> self.root = root self.color = color self.y = node[<span class="hljs-number"><span class="hljs-number">0</span></span>] self.x = node[<span class="hljs-number"><span class="hljs-number">1</span></span>] P.target = target self.count = <span class="hljs-number"><span class="hljs-number">0</span></span> self.visit = {} P.hierarchy = {} P.neighbor = {} self.init_3_dict(maps, ban)</code> </pre> <br>  La fonction is_en est d√©clar√©e dans la m√©thode init_3_dict, qui v√©rifie que la coordonn√©e n'est pas interdite et ne d√©passe pas la carte. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_3_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, maps, ban)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_en</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(yx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> yx[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; len(maps)<span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> yx[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; len(maps[<span class="hljs-number"><span class="hljs-number">0</span></span>])<span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ban: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br>  Dans un cycle, dans le dictionnaire visit√© avec la cl√© de coordonn√©es, √©crivez la valeur initiale z√©ro.  Dans le dictionnaire de hi√©rarchie avec la m√™me cl√©, √©crivez le nom hi√©rarchique de cette coordonn√©e.  Ensuite, nous remplissons le dictionnaire des voisins en appelant la fonction is_en. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(maps)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(maps[<span class="hljs-number"><span class="hljs-number">0</span></span>])): self.visit[(y,x)] = <span class="hljs-number"><span class="hljs-number">0</span></span> P.hierarchy[(y,x)] = maps[y][x] n = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y<span class="hljs-number"><span class="hljs-number">-1</span></span>,x)): n.append((y<span class="hljs-number"><span class="hljs-number">-1</span></span>,x)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y+<span class="hljs-number"><span class="hljs-number">1</span></span>,x)): n.append((y+<span class="hljs-number"><span class="hljs-number">1</span></span>,x)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y,x<span class="hljs-number"><span class="hljs-number">-1</span></span>)): n.append((y,x<span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y,x+<span class="hljs-number"><span class="hljs-number">1</span></span>)): n.append((y,x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) P.neighbor[(y,x)] = n</code> </pre><br>  La m√©thode show peint une cellule avec les coordonn√©es y, x dans la couleur souhait√©e. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, y, x, color)</span></span></span><span class="hljs-function">:</span></span> lb = Label(text=<span class="hljs-string"><span class="hljs-string">" "</span></span>, background = color) lb.configure(text=P.hierarchy[(y,x)] ) lb.grid(row=self.y, column=self.x, ipadx=<span class="hljs-number"><span class="hljs-number">10</span></span>, ipady=<span class="hljs-number"><span class="hljs-number">5</span></span>, padx=<span class="hljs-number"><span class="hljs-number">1</span></span>, pady=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  La m√©thode de d√©placement d√©place l'objet.  Dans les variables y, x, nous √©crivons les coordonn√©es du voisin, qui sont s√©lectionn√©es au hasard dans la liste des voisins.  Ensuite, nous redessinons avec les nouvelles coordonn√©es. <br><br>  Nous augmentons le compteur.  V√©rifiez si l'objectif est atteint.  Si l'objectif est atteint, alors dans la variable de la classe J.disable nous √©crivons correctement.  Nous appelons la m√©thode top_show (). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[(self.y, self.x)]: v.append(i) y,x = random.choice(v) self.show(self.y, self.x, <span class="hljs-string"><span class="hljs-string">'white'</span></span>) self.y = y self.x = x self.show(y, x, self.color) self.count +=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> P.target == P.hierarchy[(self.y, self.x)]: J.disable = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.top_show()</code> </pre><br>  La m√©thode de mise √† jour appelle move et met √† jour toutes les demi-secondes. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.move() self.root.after(<span class="hljs-number"><span class="hljs-number">500</span></span>, self.update)</code> </pre><br>  La m√©thode top_show affiche les r√©sultats. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> top = Toplevel() lbt = Label(top, text=self.color + <span class="hljs-string"><span class="hljs-string">" = "</span></span> + str(self.count)) lbt.pack() top.mainloop()</code> </pre><br>  2.2.  Classe M - Recherche al√©atoire dans la m√©moire <br><br>  Le constructeur appelle le constructeur de la classe parente et augmente la valeur de la cellule du champ o√π nous allons.  La m√©thode de d√©placement d√©place l'objet.  La m√©thode de choix renvoie les coordonn√©es s√©lectionn√©es par l'algorithme de recherche al√©atoire avec m√©moire. <br><br>  Dans la m√©thode de d√©placement, appelez la m√©thode de choix.  Sinon, son travail est similaire √† la m√©thode du parent. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> yx = self.choice((self.y, self.x))</code> </pre><br>  La m√©thode de choix parcourt les coordonn√©es des voisins et ajoute des tuples √† la liste v.  Le premier √©l√©ment du tuple sera la coordonn√©e du voisin, le second - combien de fois il a √©t√© visit√©.  Ensuite, nous trions de petit √† grand.  Nous trions tous les tuples et dans la liste v nous ne laissons que ceux qui se sont produits autant de fois que ceux enregistr√©s dans le premier tuple.  S√©lectionnez au hasard l'un d'entre eux. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, yx)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[yx]: v.append((i, self.visit[i])) v.sort(key = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) v = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] == i[<span class="hljs-number"><span class="hljs-number">1</span></span>]] v = random.choice(v) self.visit[v[<span class="hljs-number"><span class="hljs-number">0</span></span>]] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  2.3.  Classe N - recherche al√©atoire avec m√©moire et hi√©rarchie. <br><br>  La m√©thode de choix s√©lectionne les tuples qui correspondent le mieux au nom hi√©rarchique de la cible.  Si cette correspondance est la m√™me, les coordonn√©es les moins visit√©es sont s√©lectionn√©es. <br><br>  Le constructeur appelle le constructeur du parent et initialise l'attribut de co√Øncidence le nombre de correspondances de caract√®res du nom hi√©rarchique avec la cible. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, root, color, node, target, maps, ban)</span></span></span><span class="hljs-function">:</span></span> super().__init__(root, color, node, target, maps, ban) self.coincidence = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  La m√©thode de choix dans la boucle √©crit le nom hi√©rarchique de la coordonn√©e actuelle du voisin.  La variable r stocke le nombre de correspondances de cette variable avec la cible.  Si le nombre de correspondances r est sup√©rieur, la co√Øncidence est remplac√©e.  Dans ce cas, le tuple (coordonn√©es, nombre de visites) de la liste v est √©crit dans la liste d.  Si r est √©gal √† la co√Øncidence, alors dans d nous ajoutons un tuple de v. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, yx)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[yx]: v.append((i, self.visit[i])) d = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v: c = P.hierarchy[l[<span class="hljs-number"><span class="hljs-number">0</span></span>]] r = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(P.target)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c[i] == P.target[i]: r +=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r &gt; self.coincidence: self.coincidence = r d = [l] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r == self.coincidence: d.append(l) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d: v = d v.sort(key = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) v = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] == i[<span class="hljs-number"><span class="hljs-number">1</span></span>]] v = random.choice(v) self.visit[v[<span class="hljs-number"><span class="hljs-number">0</span></span>]] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  2.4.  Classe K - recherchez un itin√©raire et recherchez l'itin√©raire le plus court. <br><br>  Le constructeur √©crit les coordonn√©es de fin dans la variable de fin.  Si le param√®tre court est False, nous appelons la recherche d'itin√©raire.  Sinon, nous trouvons l'itin√©raire le plus court. <br><br>  La m√©thode find_path ajoute les coordonn√©es actuelles √† l'itin√©raire.  Si l'objectif est atteint, retourne l'itin√©raire.  Nous trions tous les voisins.  S'il n'y a pas de voisin dans le chemin, appelez-nous r√©cursivement.  Et le fait que la m√©thode retourne est √©crit dans newpath.  Le premier itin√©raire trouv√© sera newpath.  La diff√©rence entre la m√©thode find_short_path est que si la longueur de newpath est sup√©rieure ou √©gale √† la longueur de shortest, alors shortest est √©cras√©. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node, end, path=[])</span></span></span><span class="hljs-function">:</span></span> path = path + [node] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[node]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> path: newpath = self.find_path(v, end, path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newpath: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newpath</code> </pre><br>  2.5.  La classe J est une cible mobile. <br><br>  Un objet de classe J se d√©place comme la classe P. Si la variable de classe J.disable est vraie, alors l'objet s'arr√™te. <br><br>  2.6.  Fonction principale. <br><br>  Cr√©ez la fen√™tre principale.  Dans la variable cible, √©crivez le nom hi√©rarchique de la cible.  La liste des interdictions contient les coordonn√©es des cellules interdites.  Dans la liste des cartes, la carte elle-m√™me.  Dans la boucle, nous dessinons une carte.  Cr√©ez des objets de classe.  Ensuite, nous appelons la fonction de mise √† jour, qui met √† jour les objets. <br><br><h4>  3. Conclusions </h4><br>  Cinq exp√©riences ont √©t√© r√©alis√©es √† la fois pour une cible en mouvement et pour une cible immobile. <br><br>  Le tableau 1 montre que le meilleur algorithme est l'itin√©raire le plus court.  Le deuxi√®me plus efficace est une recherche al√©atoire avec m√©moire et hi√©rarchie.  Le pire est la recherche al√©atoire. <br><br>  Tableau 1. Cible fixe <br><br><img src="https://habrastorage.org/webt/lv/w3/_7/lvw3_7ehvk3w0oeffgo8nyrq5zk.jpeg" alt="image"><br><br>  Dans le cas d'une cible mobile, les r√©sultats sont diff√©rents.  Les pires algorithmes sont ceux qui ont initialement calcul√© l'itin√©raire vers l'objectif.  Dans le tableau 2, un tiret indique que l'objectif n'a pas √©t√© atteint.  Brown s'est av√©r√© pire que Violet.  Pire, car Violet a une trajectoire plus longue (la chance de rencontrer une cible en mouvement est plus grande).  Le meilleur algorithme lors de la recherche d'une cible mobile est une recherche al√©atoire avec m√©moire et hi√©rarchie.  En deuxi√®me place, une recherche al√©atoire avec m√©moire. <br><br>  Tableau 2. Cible mobile <br><br><img src="https://habrastorage.org/webt/3r/_d/58/3r_d58csbdvlpe0abgm49s8pp44.jpeg" alt="image"><br><br>  Si l'on ne sait pas si la cible se d√©place ou non, il est pr√©f√©rable d'utiliser l'algorithme de recherche al√©atoire avec m√©moire et hi√©rarchie ou simplement la recherche al√©atoire avec m√©moire. <br><br><h4>  4. Conclusion </h4><br>  L'al√©atoire est important si la recherche d'une cible se produit face √† l'incertitude.  La recherche est r√©duite si les donn√©es sont pr√©sent√©es de mani√®re hi√©rarchique.  La m√©moire, bien s√ªr, est √©galement pr√©cieuse. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479414/">https://habr.com/ru/post/fr479414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479398/index.html">Nous apportons l'√©quation de r√©gression lin√©aire sous forme de matrice</a></li>
<li><a href="../fr479400/index.html">Comment faire d'un journaliste un r√©seau de neurones, ou "Les secrets de la r√©duction du texte sur Habr√© sans un mot"</a></li>
<li><a href="../fr479402/index.html">Comment payer officiellement des services d'ind√©pendant √† l'√©tranger, payer 0% d'imp√¥ts et ne pas alimenter les syst√®mes de paiement</a></li>
<li><a href="../fr479404/index.html">Personnel pour le P√®re No√´l</a></li>
<li><a href="../fr479406/index.html">16 conseils de d√©veloppement pour Android dans Kotlin. Partie 1</a></li>
<li><a href="../fr479416/index.html">Voyez o√π vous allez (vision p√©riph√©rique vs charge cognitive)</a></li>
<li><a href="../fr479420/index.html">Microphone ouvert: backend. Inscription des invit√©s</a></li>
<li><a href="../fr479422/index.html">[Animation vid√©o] Monde filaire: comment en 35 ans un r√©seau de c√¢bles sous-marins a envelopp√© le globe</a></li>
<li><a href="../fr479426/index.html">Semaine de la s√©curit√© 50: Attaques d'homme au milieu dans Confluence et Linux</a></li>
<li><a href="../fr479428/index.html">√âv√©nements num√©riques √† Moscou du 9 au 15 d√©cembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>