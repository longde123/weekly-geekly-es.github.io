<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏼 👩🏾‍🔧 🐗 Go + = Paketversionierung 👩🏾‍💼 😐 🎄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel geschrieben im Februar 2018. 

 Go muss die Paketversionierung hinzufügen. 

 Genauer gesagt müssen Sie das Konzept der Versionierung in das A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go + = Paketversionierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442272/"> <i><font color="gray">Artikel geschrieben im Februar 2018.</font></i> <br><br>  Go muss die Paketversionierung hinzufügen. <br><br>  Genauer gesagt müssen Sie das Konzept der Versionierung in das Arbeitswörterbuch und die Tools der Go-Entwickler aufnehmen, damit jeder die gleichen Versionsnummern verwendet, wenn er angibt, welches Programm erstellt, ausgeführt oder analysiert werden soll.  Der Befehl <code>go</code> sollte genau angeben, welche Versionen welcher Pakete sich in einer bestimmten Assembly befinden. <br><br>  Mit der Versionsnummerierung können Sie reproduzierbare Assemblys erstellen: Wenn ich die neueste Version meines Programms veröffentliche, erhalten Sie nicht nur die neueste Version meines Codes, sondern auch genau die gleichen Versionen aller Pakete, von denen mein Code abhängt, sodass wir vollständig äquivalente Binärdateien erstellen. <br><br>  Durch die Versionierung wird auch sichergestellt, dass das Programm morgen genau so erstellt wird wie heute.  Selbst wenn neue Versionen von Abhängigkeiten veröffentlicht werden, werden sie von <code>go</code> nicht ohne einen speziellen Befehl verwendet. <br><a name="habracut"></a><br>  Obwohl Sie die Versionskontrolle hinzufügen müssen, sollten Sie die Hauptvorteile des Befehls <code>go</code> nicht aufgeben: Es ist einfach, schnell und verständlich.  Heutzutage achten viele Programmierer nicht auf die Versionen und alles funktioniert gut.  Wenn Sie das richtige Modell herstellen, achten die Programmierer immer <i>noch</i> nicht auf die Versionsnummern, sondern alles funktioniert besser und wird klarer.  Bestehende Workflows werden sich kaum ändern.  Die Veröffentlichung neuer Versionen ist sehr einfach.  Im Allgemeinen sollte die Versionskontrolle auf der Strecke bleiben und die Aufmerksamkeit des Entwicklers nicht auf sich ziehen. <br><br>  Kurz gesagt, Sie müssen die Versionskontrolle des Pakets hinzufügen, aber nicht break <code>go get</code> .  In diesem Artikel schlagen wir vor, wie dies zu tun ist, und zeigen einen Prototyp, den Sie jetzt ausprobieren können und der hoffentlich die Grundlage für eine mögliche <code>go</code> Integration wird.  Ich hoffe, dieser Artikel ist der Beginn einer produktiven Diskussion darüber, was funktioniert und was nicht.  Basierend auf dieser Diskussion werde ich sowohl meinen Vorschlag als auch den Prototyp anpassen und dann den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Vorschlag</a> zum Hinzufügen einer optionalen Funktion zu Go 1.11 vorstellen. <br><br>  Dieser Vorschlag behält alle Vorteile von <code>go get</code> , fügt jedoch reproduzierbare Builds hinzu, unterstützt die semantische Versionskontrolle, eliminiert die Vendorisierung, entfernt GOPATH zugunsten eines projektbasierten Workflows und bietet eine reibungslose Abkehr von <code>dep</code> und seinen Vorgängern.  Dieser Vorschlag befindet sich jedoch noch in einem frühen Stadium.  Wenn die Details nicht korrekt sind, werden wir sie beheben, bevor die Arbeit in die Go-Hauptdistribution gelangt. <br><br><h1>  Allgemeine Situation </h1><br>  Bevor wir den Vorschlag prüfen, schauen wir uns die aktuelle Situation an und wie wir dazu gekommen sind.  Dieser Abschnitt mag etwas zu groß sein, aber die Geschichte bringt wichtige Lektionen und hilft zu verstehen, warum wir etwas ändern wollen.  Wenn dies für Sie nicht interessant ist, können Sie sofort zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angebot gehen</a> oder den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zugehörigen Blog-Artikel mit einem Beispiel</a> lesen. <br><br><h3>  <code>Makefile</code> , <code>goinstall</code> und <code>go get</code> </h3><br>  Im November 2009 wurden der Compiler, der Linker und mehrere Bibliotheken mit der ersten Version von Go veröffentlicht.  Um die Programme zu kompilieren und zu verknüpfen, mussten <code>6g</code> und <code>6l</code> , und wir haben Beispiel-Makefiles in das Kit aufgenommen.  Die minimale <code>gobuild</code> Shell könnte ein Paket kompilieren und das entsprechende Makefile schreiben (in den meisten Fällen).  Es gab keine etablierte Möglichkeit, den Code mit anderen zu teilen.  Wir wussten, dass dies nicht genug war - aber wir veröffentlichten, was wir hatten, und planten, den Rest zusammen mit der Community zu entwickeln. <br><br>  Im Februar 2010 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schlugen wir goinstall vor</a> , einen einfachen Befehl zum Herunterladen von Paketen aus Repositorys von Versionskontrollsystemen wie Bitbucket und GitHub.  <code>Goinstall</code> Konventionen für <code>Goinstall</code> eingeführt, die jetzt allgemein akzeptiert werden.  Zu diesem Zeitpunkt folgte jedoch kein Code diesen Konventionen. <code>goinstall</code> funktionierte zunächst nur mit Paketen, die nur die Standardbibliothek importierten.  Die Entwickler gingen jedoch schnell zu einer einzigen Vereinbarung über, die wir heute kennen, und die veröffentlichten Go-Pakete haben sich zu einem ganzheitlichen Ökosystem entwickelt. <br><br>  Goinstall hat auch die Makefiles und damit die Komplexität der benutzerdefinierten Build-Optionen behoben.  Obwohl es manchmal unpraktisch ist, dass Paketautoren nicht bei jedem Build Code generieren können, ist diese Vereinfachung für Paketbenutzer unglaublich wichtig: Sie müssen sich nicht um die Installation derselben Tools kümmern, die der Autor verwendet hat.  Diese Vereinfachung ist auch für den Betrieb der Werkzeuge von entscheidender Bedeutung.  Makefile ist ein erforderliches schrittweises Rezept zum Kompilieren eines Pakets.  und das Anwenden eines anderen Werkzeugs wie <code>go vet</code> oder Autocompletion auf dasselbe Paket kann ziemlich schwierig sein.  Selbst das korrekte Abrufen von Abhängigkeiten, um Pakete bei Bedarf und nur bei Bedarf neu zu erstellen, ist mit beliebigen Makefiles viel komplizierter.  Obwohl zu dieser Zeit einige Leute Einwände dagegen erhoben, dass ihnen die Flexibilität entzogen wurde, wird im Rückblick klar, dass das Aufgeben des Makefiles der richtige Schritt war: Die Vorteile überwiegen bei weitem die Unannehmlichkeiten. <br><br>  Im Dezember 2011 haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir</a> in Vorbereitung auf Go 1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Befehl go eingeführt</a> , der <code>goinstall</code> durch <code>go get</code> ersetzte. <br><br>  Im Allgemeinen werden wichtige Änderungen eingeführt: Go-Entwickler konnten Quellcode austauschen und die Arbeit des anderen nutzen.  Er isolierte auch Teile des Build-Systems innerhalb des Befehls <code>go</code> , so dass eine signifikante Automatisierung mit Hilfe von Werkzeugen möglich wurde.  Aber <code>go get</code> fehlt das Konzept der Versionskontrolle.  In den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Diskussionen über goinstall</a> wurde klar: Sie müssen etwas mit der Versionskontrolle tun.  Leider war nicht klar, was genau zu tun ist.  Zumindest haben wir im Go-Team dies nicht klar verstanden.  Wenn <code>go get</code> ein Paket anfordert, erhält es immer die neueste Kopie und delegiert Download- und Aktualisierungsvorgänge an ein Versionskontrollsystem wie Git oder Mercurial.  Eine solche "blinde Arbeit" hat zu mindestens zwei signifikanten Mängeln geführt. <br><br><h3>  Versionierung und API-Stabilität </h3><br>  Der erste große Nachteil von <code>go get</code> ist, dass es ohne das Konzept der Versionskontrolle dem Benutzer nichts darüber sagen kann, welche Änderungen in diesem Update zu erwarten sind. <br><br>  Im November 2013 wurde in einer Version von Go 1.2 ein FAQ-Eintrag mit solchen Hinweisen zur Versionierung hinzugefügt (der Text wurde nicht in Version Go 1.10 geändert): <br><br><blockquote>  Pakete für den allgemeinen Gebrauch sollten während der Entwicklung die Abwärtskompatibilität beibehalten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Kompatibilitätsempfehlungen für Go 1</a> sind hier relevant: Löschen Sie keine exportierten Namen, fördern Sie das Markieren von zusammengesetzten Literalen usw.  Wenn neue Funktionen erforderlich sind, fügen Sie einen neuen Namen hinzu, anstatt den alten zu ändern.  Erstellen Sie im Falle einer grundlegenden Änderung ein neues Paket mit einem neuen Importpfad. </blockquote><br>  Im März 2014 startete Gustavo Niemeyer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gopkg.in</a> unter dem Deckmantel "stabiler APIs für die Go-Sprache".  Diese Domain ist eine versionierungsspezifische GitHub-Umleitung, mit der Pfade wie <code>gopkg.in/yaml.v1</code> und <code>gopkg.in/yaml.v2</code> für verschiedene Commits (möglicherweise in verschiedenen Zweigen) eines Git-Repositorys importiert werden können.  Gemäß der semantischen Versionierung sollten Autoren bei kritischen Änderungen eine neue Hauptversion veröffentlichen.  Daher ersetzen spätere Versionen des <code>v1</code> Importpfads die vorherigen, und <code>v2</code> kann völlig andere APIs bereitstellen. <br><br>  Im August 2015 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reichte</a> Dave Cheney <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Vorschlag zur semantischen Versionskontrolle ein</a> .  In den nächsten Monaten löste dies eine interessante Diskussion aus: Alle schienen sich einig zu sein, dass das semantische Markieren von Versionen eine großartige Idee ist, aber niemand wusste, wie die Tools mit diesen Versionen funktionieren sollten. <br><br>  Alle Argumente für eine semantische Versionierung werden unweigerlich unter Bezugnahme auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hyrumsche Gesetz</a> kritisiert: <br><br><blockquote>  Der Vertrag Ihrer API wird bei einer ausreichenden Anzahl von Benutzern unwichtig.  Jemand hängt von einem beobachteten Verhalten des Systems ab. </blockquote><br>  Obwohl das Hyrumsche Gesetz empirisch korrekt ist, ist die semantische Versionskontrolle immer noch ein nützlicher Weg, um Erwartungen über die Beziehung zwischen Releases zu generieren.  Ein Upgrade von 1.2.3 auf 1.2.4 sollte Ihren Code nicht beschädigen, und ein Upgrade von 1.2.3 auf 2.0.0 kann sehr gut sein.  Wenn der Code nach dem Update auf 1.2.4 nicht mehr funktioniert, akzeptiert der Autor höchstwahrscheinlich einen Fehlerbericht und behebt den Fehler in Version 1.2.5.  Wenn der Code nach dem Update auf 2.0.0 nicht mehr funktioniert (oder sogar kompiliert wurde), war diese Änderung mit größerer Wahrscheinlichkeit beabsichtigt, und dementsprechend ist es unwahrscheinlich, dass in 2.0.1 etwas behoben wird. <br><br>  Ich möchte aus Hirams Gesetz nicht schließen, dass eine semantische Versionierung unmöglich ist.  Stattdessen bin ich der Meinung, dass Assemblys sorgfältig verwendet werden sollten und genau die gleichen Versionen jeder Abhängigkeit wie der Autor verwenden sollten.  Das heißt, die Standardbaugruppe sollte so reproduzierbar wie möglich sein. <br><br><h3>  Verkaufsautomaten und reproduzierbare Baugruppen </h3><br>  Der zweite große Nachteil von <code>go get</code> ist, dass ein Team ohne das Konzept der Versionskontrolle die Idee eines reproduzierbaren Builds nicht bereitstellen und sogar ausdrücken kann.  Sie können nicht sicher sein, dass Benutzer dieselbe Version der Code-Abhängigkeiten wie Sie kompilieren.  Im November 2013 wurden die folgenden FAQ zu den FAQ für Go 1.2 hinzugefügt: <br><br><blockquote>  Wenn Sie ein externes Paket verwenden und befürchten, dass es sich unerwartet ändert, besteht die einfachste Lösung darin, es in das lokale Repository zu kopieren (dieser Ansatz wird von Google verwendet).  Speichern Sie eine Kopie mit einem neuen Importpfad, der sie als lokale Kopie identifiziert.  Sie können beispielsweise <code>original.com/pkg</code> nach <code>you.com/external/original.com/pkg</code> .  Eines der Werkzeuge für dieses Verfahren ist Kit Reriks Goven. </blockquote><br>  Keith Rarik hat dieses Projekt im März 2012 gestartet.  Das Dienstprogramm <code>goven</code> kopiert die Abhängigkeit in das lokale Repository und aktualisiert alle <code>goven</code> , um den neuen Speicherort <code>goven</code> .  Solche Quellcodeänderungen sind notwendig, aber unangenehm.  Sie erschweren das Vergleichen und Einfügen neuer Kopien und erfordern auch das Aktualisieren von anderem kopiertem Code unter Verwendung dieser Abhängigkeit. <br><br>  Im September 2013 führte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keith godep ein</a> , "ein neues Tool zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beheben von Paketabhängigkeiten</a> ".  Die Hauptleistung von <code>godep</code> war das, was wir jetzt als Vendoring bezeichnen, <code>godep</code> das Kopieren von Abhängigkeiten in das Projekt, <i>ohne</i> die Quelldateien <i>zu</i> ändern, ohne direkte Unterstützung für die Tools durch eine bestimmte Konfiguration von GOPATH. <br><br>  Im Oktober 2014 schlug Keith vor, Go-Tools um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für „externe Pakete“</a> zu erweitern, damit Tools Projekte, die diese Konvention verwenden, besser verstehen.  Zu diesem Zeitpunkt waren bereits mehrere Dienstprogramme im <code>godep</code> Stil erschienen.  Matt Farina veröffentlichte einen Beitrag „Travelling the Sea of ​​Go- <code>godep</code> “, in dem er <code>godep</code> mit <code>godep</code> , insbesondere mit <code>glide</code> . <br><br>  Im April 2015 führte Dave Cheney <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gb ein</a> , „ein projektbasiertes Build-Tool ... mit wiederholten Builds durch Quellenverkauf“, ohne die Importpfade neu zu schreiben (eine weitere Motivation für die Erstellung von gb bestand darin, die Notwendigkeit zu vermeiden, Code in bestimmten Verzeichnissen in GOPATH zu speichern was nicht immer bequem ist). <br><br>  In diesem Frühjahr untersuchte Jason Buberlie die Situation mit Go-Paketverwaltungssystemen, einschließlich mehrfacher Doppelarbeit und der vergeblichen Arbeit an ähnlichen Dienstprogrammen.  Seine Umfrage machte Entwicklern klar, dass die Unterstützung für den Verkauf ohne Umschreiben von Importpfaden zum Befehl <code>go</code> hinzugefügt werden muss.  Gleichzeitig begann Daniel Theofanes, Spezifikationen für ein Dateiformat zu erstellen, das den genauen Ursprung und die Version des Codes im Verzeichnis des Anbieters beschreibt.  Im Juni 2015 haben wir den Vorschlag von Keith als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Experiment zum Verkauf in Go 1.5</a> akzeptiert, der standardmäßig in Go 1.6 enthalten war.  Wir haben die Autoren aller Verkaufstools ermutigt, mit Daniel zusammenzuarbeiten, um ein einziges Metadatendateiformat zu verwenden. <br><br>  Durch die Einführung des Vending-Konzepts in Go konnten Tools wie <code>vet</code> Programme kompetenter analysieren. Heute wurde es von einem Dutzend oder zwei Paketmanagern oder Vending-Tools verwendet.  Da jedoch jeder unterschiedliche Metadatenformate hat, interagieren sie nicht und können Abhängigkeitsinformationen nicht einfach austauschen. <br><br>  Grundsätzlich ist der Verkauf eine unvollständige Lösung für das Problem der Versionskontrolle.  Es bietet nur die Reproduzierbarkeit der Baugruppe, hilft jedoch nicht, die Paketversionen zu verstehen und zu entscheiden, welche verwendet werden soll.  Paketmanager wie <code>glide</code> und <code>dep</code> fügen Go implizit das Konzept der Versionskontrolle hinzu und <code>dep</code> das Herstellerverzeichnis auf eine bestimmte Weise ein.  Infolgedessen können viele Tools im Go-Ökosystem möglicherweise nicht die richtigen Versionsinformationen abrufen.  Es ist klar, dass Go direkte Unterstützung für Paketversionen benötigt. <br><br><h3>  Offizielles Paketmanagement-Experiment </h3><br>  Auf der GopherCon 2016 am Hack Day (jetzt Community Day) versammelte sich eine Gruppe von Go-Aktivisten, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragen der Paketverwaltung umfassend zu diskutieren</a> .  Eines der Ergebnisse war die Bildung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausschusses und einer Beratergruppe zur Durchführung einer Reihe von Aktivitäten mit dem Ziel, ein neues Paketmanagement-Tool zu schaffen</a> .  Die Idee war, ein einheitliches Tool vorhandene ersetzen zu lassen, obwohl es weiterhin außerhalb des direkten Toolkits von Go mithilfe von Anbieterkatalogen implementiert werden würde.  Dem Ausschuss gehörten Andrew Gerrand, Ed Müller, Jesse Frazel und Sam Boyer unter der Leitung von Peter Burgon an.  Sie bereiteten einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwurf für eine Spezifikation vor</a> , und dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementierten</a> Sam und seine Assistenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dep</a> .  Ein Verständnis der allgemeinen Situation finden Sie in Sams Artikel vom Februar 2016 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„So möchten Sie einen Paketmanager schreiben“, in</a> seinem Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Go Dependency Management Saga“</a> vom Dezember 2016 und in seiner Rede im Juli 2017 auf der GopherCon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Eine neue Ära des</a> Paketmanagements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Geh</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> <br><br>  <code>Dep</code> führt viele Aufgaben aus: Dies ist eine wichtige Verbesserung gegenüber den derzeitigen Praktiken.  Dies ist ein wichtiger Schritt in Richtung einer zukünftigen Lösung und gleichzeitig ein Experiment - wir nennen es ein „offizielles Experiment“ -, das uns hilft, die Bedürfnisse von Entwicklern besser zu verstehen.  <code>dep</code> kein direkter Prototyp für die mögliche Integration von <code>go</code> Befehlen in die Paketversionierung.  Dies ist eine leistungsstarke, flexible und nahezu universelle Möglichkeit, den Raum für Designentscheidungen zu erkunden.  Es ähnelt den Makefiles, gegen die wir am Anfang gekämpft haben.  Sobald wir jedoch den Raum für Entwurfsentscheidungen besser verstehen und ihn auf einige wichtige Funktionen eingrenzen können, die unterstützt werden sollten, wird dies dem Go-Ökosystem helfen, andere Funktionen zu entfernen, die Ausdruckskraft zu verringern und verbindliche Konventionen zu übernehmen, die Go-Codebasen konsistenter und verständlicher machen. <br><br>  Dieser Artikel ist der Beginn des nächsten Schritts nach <code>dep</code> : der erste Prototyp der endgültigen Integration mit dem Befehl <code>go</code> , dem Batch-Äquivalent von <code>goinstall</code> .  Ein Prototyp ist ein separater Befehl, den wir <code>vgo</code> nennen: ein <code>go</code> Ersatz mit Unterstützung für die Paketversionierung.  Dies ist ein neues Experiment, und wir werden sehen, was daraus wird.  Wie bei der Ankündigung der <code>goinstall</code> sind einige Projekte und Code jetzt mit <code>vgo</code> kompatibel, während andere Änderungen benötigen.  Wir werden etwas Kontrolle und Ausdruckskraft entfernen, genau wie die Makefiles entfernt wurden, um das System zu vereinfachen und die Komplexität für die Benutzer zu beseitigen.  Vor allem suchen wir Pioniere, die beim Experimentieren mit <code>vgo</code> helfen, um so viele Bewertungen wie möglich zu erhalten. <br><br>  Das Starten eines Experiments mit <code>vgo</code> bedeutet nicht, die <code>dep</code> Unterstützung zu <code>vgo</code> : Es bleibt verfügbar, bis wir eine vollständige und offene Integration mit <code>go</code> .  Wir werden auch versuchen, den endgültigen Übergang von <code>dep</code> zu Integration so reibungslos wie möglich zu gestalten, in welcher Form auch immer diese Integration stattfindet.  Projekte, die noch nicht in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>godep</code></a> konvertiert wurden, können weiterhin von dieser Konvertierung profitieren (beachten Sie, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>godep</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>glide</code></a> aktive Entwicklung gestoppt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>glide</code></a> und die Migration nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>godep</code></a> fördern).  Vielleicht möchten einige Projekte direkt zu <code>vgo</code> wechseln, wenn dies ihren Anforderungen entspricht. <br><br><h1>  Angebot </h1><br>  Der Vorschlag, dem Befehl <code>go</code> eine Versionskontrolle hinzuzufügen <code>go</code> besteht aus vier Schritten.  Akzeptieren Sie zunächst die <i>Importkompatibilitätsregel</i> , die in den FAQ und in gopkg.in angegeben ist: Neuere Versionen des Pakets mit dem angegebenen Importpfad müssen mit älteren Versionen abwärtskompatibel sein.  Verwenden Sie zweitens einen einfachen neuen Algorithmus, der als <i>Auswahl der Mindestversion bezeichnet wird</i> , um zu bestimmen, welche Versionen des Pakets in dieser Assembly verwendet werden.  Drittens führen Sie das Konzept des Go- <i>Moduls ein</i> : Gruppen von Paketen, die als Ganzes versioniert sind, und deklarieren die Mindestanforderungen, die durch ihre Abhängigkeiten erfüllt werden müssen.  Viertens legen Sie fest, wie Sie all dies in Ihren vorhandenen Befehl <code>go</code> damit sich die grundlegenden Workflows gegenüber heute nicht wesentlich ändern.  Im Rest dieses Artikels betrachten wir jeden dieser Schritte.  Sie werden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anderen Blog-Artikeln</a> ausführlicher behandelt. <br><br><h3>  Kompatibilitätsregel importieren </h3><br>  Das Hauptproblem bei Paketverwaltungssystemen sind Versuche, Inkompatibilitäten zu beheben.  Beispielsweise erlauben die meisten Systeme, dass Paket B deklariert, dass es Paket D der Version 6 oder höher benötigt, und dass Paket C deklariert, dass es D Version 2, 3 oder 4 benötigt, jedoch nicht Version 5 oder höher.  Wenn Sie also B und C in Ihrem Paket verwenden möchten, haben Sie kein Glück: Sie können keine Version von D auswählen, die beide Bedingungen erfüllt, und Sie können nichts tun. <br><br>  Anstelle eines Systems, das unweigerlich die Zusammenstellung großer Programme blockiert, führt unser Vorschlag eine <i>Importkompatibilitätsregel</i> für Paketautoren ein: <br><br><blockquote>  Wenn das alte und das neue Paket denselben Importpfad haben, muss das neue Paket abwärtskompatibel mit dem alten Paket sein. </blockquote><br>  Die Regel wiederholt die zuvor erwähnten FAQ.  Dieser Text endete mit den Worten: "Erstellen Sie im Falle einer radikalen Änderung ein neues Paket mit einem neuen Importpfad."<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für eine so große Änderung setzen Entwickler heute auf die semantische Versionskontrolle, daher integrieren wir sie in unseren Vorschlag. </font><font style="vertical-align: inherit;">Insbesondere kann die Nummer der zweiten und der nachfolgenden Hauptversionen direkt in den Pfad aufgenommen werden:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-yaml/yaml/v2"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der semantischen Versionskontrolle bedeutet Version 2.0.0 eine radikale Änderung, sodass ein neues Paket mit einem neuen Importpfad erstellt wird. </font><font style="vertical-align: inherit;">Da jede Hauptversion einen anderen Importpfad hat, kann eine bestimmte ausführbare Go-Datei eine der Hauptversionen enthalten. </font><font style="vertical-align: inherit;">Dies ist zu erwarten und wünschenswert. </font><font style="vertical-align: inherit;">Ein solches System unterstützt die Zusammenstellung von Programmen und ermöglicht es Teilen eines sehr großen Programms, unabhängig voneinander von v1 auf v2 zu aktualisieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Einhaltung der Importkompatibilitätsregel durch die Autoren verhindert Versuche, Inkompatibilitäten zu beheben, indem das Gesamtsystem exponentiell vereinfacht und die Fragmentierung des Paketökosystems verringert wird. </font><font style="vertical-align: inherit;">In der Praxis brechen Aktualisierungen innerhalb derselben Hauptversion natürlich trotz aller Bemühungen der Autoren manchmal Benutzerpakete. </font><font style="vertical-align: inherit;">Daher sollten Sie nicht zu oft aktualisieren. </font><font style="vertical-align: inherit;">Dies bringt uns zum nächsten Schritt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Minimale Versionsauswahl </font></font></h3><br>     ,  <code>dep</code>  <code>cargo</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">       </a> .  ,         . -,  «  »   -  ,   -   . ,   -     ,      ,    ,   . -,      ,    ,    «,    X»,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    X</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Vorschlag verwendet einen anderen Ansatz, den ich als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswahl der Mindestversion bezeichne</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Standardmäßig wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die älteste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zulässige Version jedes Pakets verwendet. Diese Entscheidung wird sich morgen nicht ändern, da es unmöglich ist, eine ältere Version zu veröffentlichen. Noch besser ist es für einen Paketmanager trivial zu bestimmen, welche Version verwendet werden soll. Ich nenne dies die Wahl der Mindestversion, weil die ausgewählten Versionsnummern minimal sind und weil das System als Ganzes wahrscheinlich auch minimal ist, wodurch fast die gesamte Komplexität bestehender Systeme vermieden wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Auswahl der Mindestversion können Module nur die Mindestanforderungen für Abhängigkeiten angeben. Dies sind klar definierte, eindeutige Antworten für Aktualisierungs- und Downgrade-Vorgänge, und diese Vorgänge sind wirklich effektiv. Dieses Prinzip ermöglicht es dem Autor des gesamten Moduls, die Version der Abhängigkeiten anzugeben, die er ausschließen möchte, oder das Ersetzen einer bestimmten Abhängigkeit durch ihre Verzweigung anzugeben, die sich entweder im lokalen Speicher befindet oder als separates Modul veröffentlicht wird. Diese Ausnahmen und Ersetzungen gelten nicht, wenn ein Modul als Abhängigkeit von einem anderen Modul erstellt wird. Dies gibt Benutzern die vollständige Kontrolle darüber, wie ihre eigenen Programme zusammengestellt werden, nicht jedoch über Fremde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Auswahl der Mindestversion werden standardmäßig reproduzierbare Assemblys ohne Sperrdatei bereitgestellt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Importkompatibilität ist der Schlüssel zur einfachen Auswahl der Mindestversion. </font><font style="vertical-align: inherit;">Benutzer können nicht mehr "Nein, dies ist eine zu neue Version" sagen, sondern nur "Nein, es ist zu alt". </font><font style="vertical-align: inherit;">In diesem Fall ist die Lösung klar: Verwenden Sie die (minimale) neuere Version. </font><font style="vertical-align: inherit;">Und neuere Versionen sind gemäß Konvention akzeptabler Ersatz für ältere.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go-Module definieren </font></font></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go- </font><i><font style="vertical-align: inherit;">Modul</font></i><font style="vertical-align: inherit;"> ist eine Sammlung von Paketen mit einem allgemeinen Importpfadpräfix, das als Modulpfad bezeichnet wird. Ein Modul ist eine Versionskontrolleinheit, und Versionen werden als semantische Zeichenfolgen geschrieben. Bei der Entwicklung mit Git definieren Entwickler eine neue semantische Version des Moduls, indem sie dem Git-Repository des Moduls ein Tag hinzufügen. Obwohl dringend empfohlen wird, semantische Versionen anzugeben, werden auch Links zu bestimmten Commits unterstützt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der neuen Datei </font></font><code>go.mod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert </font><font style="vertical-align: inherit;">das </font><font style="vertical-align: inherit;">Modul die Mindestversionsanforderungen für andere Module, von denen es abhängt. Hier ist zum Beispiel eine einfache Datei </font></font><code>go.mod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// My hello, world. module "rsc.io/hello" require ( "golang.org/x/text" v0.0.0-20180208041248-4e4a3210bb54 "rsc.io/quote" v1.5.2 )</span></span></code> </pre> <br>    ,     <code>rsc.io/hello</code> ,       : <code>golang.org/x/text</code>  <code>rsc.io/quote</code> .            ,    <code>go.mod</code> .     ,         -     . <br><br>      ,  <code>vgo</code>    ,    .   <code>rsc.io/quote</code> ,    <code>github.com/rsc/quote</code> ,   ,    1.5.2.    <code>golang.org/x/text</code>    .     ,  <i>v0.0.0-yyyymmddhhmmss-commit</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert ein bestimmtes Commit an einem bestimmten Datum. Bei der semantischen Versionierung entspricht diese Zeile der Vorabversion v0.0.0 mit dem Bezeichner </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yyyymmddhhmmss-commit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die semantischen Regeln der Versionspriorität erkennen solche Vorabversionen vor Version v0.0.0 und führen Zeichenfolgenvergleiche durch. Die Datumsreihenfolge in der Pseudoversion stellt sicher, dass der Zeichenfolgenvergleich mit dem Datumsvergleich übereinstimmt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich zu diesen Anforderungen können Dateien </font></font><code>go.mod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die im vorherigen Abschnitt erwähnten Ausnahmen und Ersetzungen angeben, sie gelten jedoch wiederum nur beim Erstellen eines isolierten Moduls und nicht beim Erstellen als Teil eines größeren Programms. All dies wird in den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielen gezeigt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <code>Goinstall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und alt</font></font><code>go get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tools zur Versionskontrolle wie </font></font><code>git</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">werden aufgerufen, um den Code herunterzuladen </font></font><code>hg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was zu vielen Problemen führt, einschließlich Fragmentierung. Beispielsweise können Benutzer ohne </font></font><code>bzr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Code nicht aus den Bazaar-Repositorys herunterladen. Im Gegensatz zu diesem System werden Go-Module immer über HTTP in Form von Zip-Archiven ausgegeben. Zuvor gab </font></font><code>go get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es spezielle Teams für beliebte Code-Hosting-Sites. Jetzt verfügen sie über </font></font><code>vgo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spezielle API-Verfahren zum Empfangen von Archiven von diesen Sites.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einheitliche Darstellung von Modulen in Form von Zip-Archiven ermöglicht die einfache Implementierung eines Protokolls und eines Proxyservers zum Laden von Modulen. </font><font style="vertical-align: inherit;">Unternehmen und einzelne Benutzer haben unterschiedliche Gründe für den Start solcher Proxyserver, einschließlich der Sicherheit und des Wunsches, im Falle des Löschens von Originalen mit zwischengespeicherten Kopien zu arbeiten. </font><font style="vertical-align: inherit;">Wenn ein Proxy vorhanden ist </font></font><code>go.mod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden die Herstellerverzeichnisse nicht mehr benötigt </font><font style="vertical-align: inherit;">, um die Zugänglichkeit sicherzustellen und </font><font style="vertical-align: inherit;">zu bestimmen, welcher Code verwendet werden soll.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Team </font></font><code>go</code> </h3><br>      <code>go</code>  .      ,    ,   <code>go build</code> , <code>go install</code> , <code>go run</code>  <code>go test</code> ,      .   <code>golang.org/x/text</code>           Go   . <br><br>     —   GOPATH    .   <code>go.mod</code>       ,       ,    <code>go.mod</code>    ,     ,      .     <code>git clone</code> , <code>cd</code> ,   .  .  GOPATH. <br><br><h1>  Was weiter? </h1><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«     Go»</a>  ,   <code>vgo</code> .    ,        <code>vgo</code> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .   . <br><br> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> vgo</a> .       .   <code>go.mod</code> .  ,       <code>go.mod</code> ,   <code>dep</code> , <code>glide</code> , <code>glock</code> , <code>godep</code> , <code>godeps</code> , <code>govend</code> , <code>govendor</code>    <code>gvt</code> ,  <code>vgo</code>      <code>go.mod</code> . <br><br>  ,  Go        .     ,     Go, —   ,       <code>go get</code> ,  GOPATH            GOPATH.          . <br><br>      - . ,    ,   <code>vgo</code>     .   ,  Go 1.11      Go,    ,   Go 1.12    .        ,  <code>go get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist jedoch ein aggressiver Plan. Wenn Sie für die richtige Funktionalität auf spätere Versionen warten müssen, sollten Sie dies auch tun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bin sehr besorgt über den Übergang von den alten </font></font><code>go get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und unzähligen Verkaufsautomaten zum neuen modularen System. </font><font style="vertical-align: inherit;">Dieser Prozess ist für mich genauso wichtig wie die richtige Funktionalität. </font><font style="vertical-align: inherit;">Wenn ein erfolgreicher Übergang bedeutet, auf spätere Versionen zu warten, dann sei es auch so.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442272/">https://habr.com/ru/post/de442272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442262/index.html">Geheimnis der Firmware</a></li>
<li><a href="../de442264/index.html">Beseitigung von Möglichkeiten zur Entführung von Verkehr</a></li>
<li><a href="../de442266/index.html">Delta Chat - dezentraler Messenger über E-Mail</a></li>
<li><a href="../de442268/index.html">AsyncIO Micropython: Synchronisationsmethoden in der asynchronen Programmierung</a></li>
<li><a href="../de442270/index.html">5 Fehler, die beim Erstellen von 3D-Modellen für den 3D-Druck vermieden werden sollten</a></li>
<li><a href="../de442274/index.html">Dart 2. Asynchrone Programmierung: Datenströme</a></li>
<li><a href="../de442278/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 6</a></li>
<li><a href="../de442280/index.html">Maschinelles Lernen in Dodo. So starten Sie eine neue Richtung, wenn Sie Entwickler sind</a></li>
<li><a href="../de442282/index.html">Dart 2. Asynchrone Programmierung: Futures</a></li>
<li><a href="../de442284/index.html">NoVerify: Der Linter für PHP vom VKontakte-Team ist jetzt gemeinfrei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>