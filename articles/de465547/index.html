<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍑 👩‍👩‍👧‍👦 👨‍🎨 SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 1) 👨🏿‍🤝‍👨🏾 🕊️ 🍤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erfahren Sie mehr über Antimuster, Ausführungspläne, Zeitkomplexität, Abfrageoptimierung und SQL-Optimierung 
 Structured Query Language (SQL) ist ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  Erfahren Sie mehr über Antimuster, Ausführungspläne, Zeitkomplexität, Abfrageoptimierung und SQL-Optimierung </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Structured Query Language (SQL) ist eine unverzichtbare Fähigkeit in der Informatikbranche, und im Allgemeinen ist das Erlernen dieser Fähigkeit relativ einfach.  Die meisten Leute vergessen jedoch, dass es bei SQL nicht nur um das Schreiben von Abfragen geht, sondern nur um den ersten Schritt in die Zukunft.  Ganz anders ist es, die Abfrageleistung sicherzustellen oder den Kontext abzugleichen, in dem Sie arbeiten. <br><br>  Aus diesem Grund erhalten Sie in diesem SQL-Handbuch einen kleinen Überblick über einige der Schritte, die Sie zur Bewertung Ihrer Abfrage ausführen können: <br><br><ul><li>  Zunächst erhalten Sie einen kurzen Überblick über die Bedeutung des SQL-Lernens für die Arbeit im Bereich der Datenwissenschaft. </li><li>  Als Nächstes lernen Sie zunächst, wie Sie SQL-Abfragen verarbeiten und ausführen, um zu verstehen, wie wichtig es ist, Qualitätsabfragen zu erstellen.  Insbesondere werden Sie sehen, dass die Anfrage analysiert, neu geschrieben, optimiert und schließlich ausgewertet wird. </li><li>  In diesem Sinne werden Sie nicht nur zu einigen der Antimuster von Abfragen übergehen, die Anfänger beim Schreiben von Abfragen stellen, sondern auch mehr über Alternativen und Lösungen für diese möglichen Fehler erfahren.  Darüber hinaus erfahren Sie mehr über den satzbasierten Abfrageansatz. </li><li>  Sie werden auch feststellen, dass diese Antimuster auf Leistungsproblemen beruhen und dass Sie zusätzlich zum „manuellen“ Ansatz zur Verbesserung von SQL-Abfragen Ihre Abfragen mithilfe einiger anderer Tools, die Ihnen beim Anzeigen des Abfrageplans helfen, strukturierter und eingehender analysieren können.  Und </li><li>  Sie lernen kurz die zeitliche Komplexität und die große O-Notation kennen, um sich rechtzeitig vor der Ausführung der Anforderung ein Bild von der Komplexität des Ausführungsplans zu machen. </li><li>  Sie erfahren kurz, wie Sie Ihre Abfrage optimieren. </li></ul><a name="habracut"></a><br><h2>  Warum sollten Sie SQL lernen, um mit Daten zu arbeiten? </h2><br>  SQL ist alles andere als tot: Dies ist eine der gefragtesten Fähigkeiten, die Sie in Stellenbeschreibungen aus der Datenverarbeitungs- und Analysebranche finden, unabhängig davon, ob Sie sich für Datenanalyse, Dateningenieur, Datenspezialist oder eine andere Rolle bewerben.  Dies wird von 70% der Befragten der O 'Reilly Data Science-Gehaltsumfrage für 2016 bestätigt, die angeben, dass sie SQL in ihrem beruflichen Kontext verwenden.  Darüber hinaus hebt sich SQL in dieser Umfrage von den Programmiersprachen R (57%) und Python (54%) ab. <br><br>  Sie bekommen das Bild: SQL ist eine notwendige Fähigkeit, wenn Sie daran arbeiten, einen Job in der IT-Branche zu bekommen. <br><br>  Nicht schlecht für eine Sprache, die in den frühen 1970ern entwickelt wurde, oder? <br><br>  Aber warum wird es so oft verwendet?  Und warum ist er nicht gestorben, obwohl er so lange existiert hat? <br><br>  Es gibt mehrere Gründe: Einer der ersten Gründe könnte sein, dass Unternehmen Daten hauptsächlich in relationalen Datenbankverwaltungssystemen (RDBMS) oder in relationalen Datenflussmanagementsystemen (RDSMS) speichern und SQL für den Zugriff auf diese Daten erforderlich ist.  SQL ist eine <i>Verkehrssprache für</i> Daten: Es ermöglicht die Interaktion mit fast jeder Datenbank oder sogar die Erstellung eigener Datenbanken vor Ort! <br><br>  Wenn dies immer noch nicht ausreicht, denken Sie daran, dass es einige SQL-Implementierungen gibt, die zwischen Anbietern nicht kompatibel sind und nicht unbedingt den Standards entsprechen.  Kenntnisse in Standard-SQL sind daher eine Voraussetzung, um sich in der Branche (Informatik) zurechtzufinden. <br><br>  Darüber hinaus kann man mit Sicherheit sagen, dass auch neuere Technologien SQL beigetreten sind, z. B. Hive, eine SQL-ähnliche Abfragesprachenschnittstelle zum Abfragen und Verwalten großer Datenmengen, oder Spark SQL, mit dem SQL-Abfragen ausgeführt werden können.  Auch hier unterscheidet sich das SQL, das Sie dort finden, von dem Standard, den Sie lernen könnten, aber die Lernkurve wird viel einfacher. <br><br>  Wenn Sie einen Vergleich anstellen möchten, betrachten Sie ihn als Lernen der linearen Algebra: Wenn Sie all diese Anstrengungen in dieses eine Fach gesteckt haben, wissen Sie, dass Sie damit auch maschinelles Lernen beherrschen können! <br><br>  Kurz gesagt, aus diesem Grund sollten Sie diese Abfragesprache lernen: <br><br><ul><li>  Es ist ziemlich leicht zu lernen, auch für Anfänger.  Die Lernkurve ist recht einfach und schrittweise, sodass Sie so schnell wie möglich Abfragen schreiben. </li><li>  Es folgt dem Prinzip „einmal lernen, überall anwenden“, also ist dies eine großartige Investition Ihrer Zeit! </li><li>  Dies ist eine großartige Ergänzung zu Programmiersprachen.  In einigen Fällen ist das Schreiben einer Abfrage sogar dem Schreiben von Code vorzuziehen, da dies effizienter ist! </li><li>  ... </li></ul><br>  Worauf warten Sie noch?  :) :) <br><br><h2>  SQL-Verarbeitung und Abfrageausführung </h2><br>  Um die Leistung Ihrer SQL-Abfrage zu verbessern, müssen Sie zunächst wissen, was im Inneren passiert, wenn Sie auf eine Verknüpfung klicken, um die Abfrage auszuführen. <br><br>  Zunächst wird die Anforderung in einen Analysebaum analysiert.  Die Anforderung wird auf Übereinstimmung mit syntaktischen und semantischen Anforderungen analysiert.  Der Parser erstellt eine interne Darstellung der Eingabeanforderung.  Diese Ausgabe wird dann an den Umschreibemechanismus übertragen. <br><br>  Dann muss der Optimierer den optimalen Ausführungs- oder Abfrageplan für die angegebene Abfrage finden.  Der Ausführungsplan bestimmt genau, welcher Algorithmus für jede Operation verwendet wird und wie Operationen koordiniert werden. <br><br>  Um den optimalsten Ausführungsplan zu finden, listet der Optimierer alle möglichen Implementierungspläne auf, ermittelt die Qualität oder die Kosten jedes Plans, empfängt Informationen über den aktuellen Status der Datenbank und wählt dann den besten als endgültigen Implementierungsplan aus.  Da Abfrageoptimierer unvollständig sein können, müssen Benutzer und Datenbankadministratoren die vom Optimierer erstellten Pläne manchmal manuell überprüfen und optimieren, um die Leistung zu verbessern. <br><br>  Jetzt fragen Sie sich wahrscheinlich, was als „guter Abfrageplan“ angesehen wird. <br><br>  Wie Sie bereits gelesen haben, spielt die Qualität der Kosten eines Plans eine wichtige Rolle.  Insbesondere sind Dinge wie die Anzahl der zur Auswertung des Plans erforderlichen Festplatten-E / A, die Kosten der CPU des Plans und die Gesamtantwortzeit, die der Datenbankclient beobachten kann, sowie die Gesamtausführungszeit wichtig.  Hier entsteht das Konzept der Zeitkomplexität.  Sie werden später mehr darüber erfahren. <br><br>  Anschließend wird der ausgewählte Abfrageplan ausgeführt, vom Systemausführungsmechanismus ausgewertet und die Abfrageergebnisse zurückgegeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  SQL-Abfragen schreiben </h2><br>  Aus dem vorherigen Abschnitt ist möglicherweise nicht klar geworden, dass sich das Prinzip von Garbage In, Garbage Out (GIGO) natürlich in der Verarbeitung und Ausführung einer Abfrage manifestiert: Derjenige, der die Abfrage formuliert, verfügt auch über Schlüssel für die Leistung Ihrer SQL-Abfragen.  Wenn der Optimierer eine schlecht formulierte Anfrage erhält, kann er genauso viel tun ... <br><br>  Dies bedeutet, dass Sie beim Schreiben einer Anfrage einige Dinge tun können.  Wie Sie bereits in der Einleitung gesehen haben, gibt es hier zwei Verantwortlichkeiten: Es geht nicht nur darum, Abfragen zu schreiben, die einem bestimmten Standard entsprechen, sondern auch darum, Ideen zu sammeln, wo Leistungsprobleme in Ihrer Abfrage verborgen sein könnten. <br><br>  Ein idealer Ausgangspunkt besteht darin, in Ihren Abfragen an „Stellen“ zu denken, an denen Probleme auftreten können.  Im Allgemeinen gibt es vier Schlüsselwörter, bei denen Neulinge mit Leistungsproblemen rechnen können: <br><br><ul><li> Bedingung <code>WHERE</code> ; </li><li>  Alle Schlüsselwörter <code>INNER JOIN</code> oder <code>LEFT JOIN</code> ;  Und auch, </li><li>  Zustand haben; </li></ul><br>  Natürlich ist dieser Ansatz einfach und naiv, aber für Anfänger sind diese Punkte hervorragende Hinweise, und man kann mit Sicherheit sagen, dass beim ersten Start Fehler an diesen Stellen auftreten und seltsamerweise auch dort, wo es schwer zu bemerken ist. <br><br>  Sie sollten jedoch auch verstehen, dass Leistung etwas ist, das sinnvoll werden sollte.  Nur zu sagen, dass diese Sätze und Schlüsselwörter schlecht sind, ist jedoch nicht das, was Sie brauchen, wenn Sie über die SQL-Leistung nachdenken.  Eine <code>HAVING</code> oder <code>HAVING</code> in einer Anfrage zu haben, bedeutet nicht unbedingt, dass es sich um eine schlechte Anfrage handelt ... <br><br>  Im nächsten Abschnitt erfahren Sie mehr über Antimuster und alternative Ansätze zum Erstellen Ihrer Abfrage.  Diese Tipps und Tricks dienen als Leitfaden.  Wie und ob Sie Ihre Anfrage wirklich neu schreiben müssen, hängt unter anderem von der Datenmenge, der Datenbank und der Häufigkeit ab, mit der Sie die Anfrage abschließen müssen.  Es hängt ganz vom Zweck Ihrer Anfrage ab und es ist entscheidend, Vorkenntnisse über die Datenbank zu haben, mit der Sie arbeiten werden! <br><br><h3>  1. Rufen Sie nur die erforderlichen Daten ab </h3><br>  Die Schlussfolgerung „Je mehr Daten, desto besser“ muss beim Schreiben von SQL nicht beachtet werden: Sie riskieren nicht nur, verwirrt zu werden, wenn Sie mehr Daten abrufen, als Sie wirklich benötigen, sondern auch die Leistung kann darunter leiden, dass Ihre Abfrage zu viele Daten empfängt. <br><br>  Aus diesem Grund sollten Sie in der Regel auf die <code>SELECT</code> , die <code>DISTINCT</code> <code>SELECT</code> und die <code>LIKE</code> Anweisung achten. <br><br><h4>  <code>SELECT</code> </h4><br>  Das erste, was Sie bereits beim Schreiben einer Abfrage überprüfen können, ist, ob die <code>SELECT</code> so kompakt wie möglich ist.  Das Ziel hier sollte sein, unnötige Spalten aus <code>SELECT</code> zu entfernen.  Auf diese Weise zwingen Sie sich, nur Daten abzurufen, die Ihrem Abfragezweck dienen. <br><br>  Wenn Sie Unterabfragen mit <code>EXISTS</code> korreliert haben, sollten Sie versuchen, eine Konstante in der <code>SELECT</code> dieser Unterabfrage zu verwenden, anstatt den Wert der tatsächlichen Spalte auszuwählen.  Dies ist besonders praktisch, wenn Sie nur nach Existenz suchen. <br><br>  <b>Denken Sie daran,</b> dass eine korrelierte Unterabfrage eine Unterabfrage ist, die Werte aus einer externen Abfrage verwendet.  Und beachten Sie, dass <code>NULL</code> in diesem Zusammenhang zwar als „Konstante“ <code>NULL</code> kann, dies jedoch sehr verwirrend ist! <br><br>  Betrachten Sie das folgende Beispiel, um zu verstehen, was unter Verwendung einer Konstante zu verstehen ist: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Tipp: Es ist</b> hilfreich zu wissen, dass eine korrelierte Unterabfrage nicht immer eine gute Idee ist.  Sie können sie jederzeit <code>INNER JOIN</code> , indem Sie sie beispielsweise mit <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  Operation <code>DISTINCT</code> </h4><br>  Die <code>SELECT DISTINCT</code> verwendet, um nur unterschiedliche Werte zurückzugeben.  <code>DISTINCT</code> ist ein Punkt, der nach Möglichkeit unbedingt vermieden werden sollte.  Wie in anderen Beispielen erhöht sich die Ausführungszeit nur, wenn dieser Satz zur Anforderung hinzugefügt wird.  Daher ist es immer hilfreich zu prüfen, ob Sie diese <code>DISTINCT</code> Operation wirklich benötigen, um die gewünschten Ergebnisse zu erzielen. <br><br><h4>  <code>LIKE</code> Aussage </h4><br>  Bei Verwendung des Operators <code>LIKE</code> in einer Abfrage wird der Index nicht verwendet, wenn das Muster mit <code>%</code> oder <code>_</code> beginnt.  Dadurch wird verhindert, dass die Datenbank den Index verwendet (falls vorhanden).  Unter einem anderen Gesichtspunkt kann natürlich auch argumentiert werden, dass diese Art von Anforderung möglicherweise dazu führt, dass zu viele Datensätze abgerufen werden, die nicht unbedingt den Zweck der Anforderung erfüllen. <br><br>  Wenn Sie die in der Datenbank gespeicherten Daten kennen, können Sie eine Vorlage formulieren, die alle Daten korrekt filtert, um nur die Zeilen zu finden, die für Ihre Abfrage wirklich wichtig sind. <br><br><h3>  2. Begrenzen Sie Ihre Ergebnisse </h3><br>  Wenn Sie das Filtern Ihrer <code>SELECT</code> nicht vermeiden können, können Sie Ihre Ergebnisse auf andere Weise einschränken.  Hier kommen Ansätze wie die <code>LIMIT</code> und Datentypkonvertierungen ins <code>LIMIT</code> . <br><br><h4>  <code>ROWNUM</code> <code>LIMIT</code> <code>ROWNUM</code> und <code>ROWNUM</code> </h4><br>  Sie können Abfragen <code>LIMIT</code> oder <code>TOP</code> Anweisungen hinzufügen, um die maximale Anzahl von Zeilen für die Ergebnismenge anzugeben.  Hier einige Beispiele: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Beachten Sie, dass Sie optional <code>PERCENT</code> angeben <code>PERCENT</code> , wenn Sie beispielsweise die erste <code>SELECT TOP 50 PERCENT *</code> mit <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Alternativ können Sie die <code>ROWNUM</code> hinzufügen, die der Verwendung von <code>LIMIT</code> in der Abfrage entspricht: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Datentypkonvertierungen </h4><br>  Die effektivsten sollten immer verwendet werden, d.h.  kleinste Datentypen.  Es besteht immer ein Risiko, wenn Sie einen großen Datentyp bereitstellen, während ein kleinerer Datentyp ausreicht. <br><br>  Wenn Sie der Abfrage jedoch eine Datentypkonvertierung hinzufügen, erhöht sich nur die Ausführungszeit. <br><br>  Eine Alternative besteht darin, die Datentypkonvertierung so weit wie möglich zu vermeiden.  Beachten Sie auch, dass es nicht immer möglich ist, die Datentypkonvertierung aus Abfragen zu entfernen oder zu überspringen. Sie sollten jedoch immer versuchen, sie einzuschließen, und die Auswirkungen des Hinzufügens überprüfen, bevor Sie die Abfrage ausführen. <br><br><h3>  3. Machen Sie Abfragen nicht komplizierter als sie sein sollten </h3><br>  Datentypkonvertierungen führen Sie zu folgendem Punkt: Sie sollten Ihre Abfragen nicht übermäßig gestalten.  Versuchen Sie, sie einfach und effektiv zu machen.  Dies mag zu einfach oder zu dumm erscheinen, um ein Hinweis zu sein, hauptsächlich weil die Anforderungen komplex sein können. <br><br>  In den in den folgenden Abschnitten genannten Beispielen werden Sie jedoch feststellen, dass Sie einfache Abfragen problemlos komplexer gestalten können, als sie sein sollten. <br><br><h4>  <code>OR</code> Operator </h4><br>  Wenn Sie den Operator <code>OR</code> in Ihrer Abfrage verwenden, verwenden Sie höchstwahrscheinlich keinen Index. <br><br>  Denken Sie daran, dass ein Index eine Datenstruktur ist, die die Suche nach Daten in einer Datenbanktabelle beschleunigt, aber teuer ist: Zusätzliche Datensätze und zusätzlicher Speicherplatz sind erforderlich, um die Indexdatenstruktur aufrechtzuerhalten.  Indizes werden verwendet, um schnell nach Daten zu suchen oder zu suchen, ohne bei jedem Zugriff auf die Datenbanktabelle jede Zeile in der Datenbank durchsuchen zu müssen.  Indizes können mithilfe einer oder mehrerer Spalten in einer Datenbanktabelle erstellt werden. <br><br>  Wenn Sie keine in der Datenbank enthaltenen Indizes verwenden, dauert die Ausführung Ihrer Abfrage zwangsläufig länger.  Aus diesem Grund sollten Sie in Ihrer Abfrage nach Alternativen zur Verwendung des Operators <code>OR</code> suchen. <br><br>  Betrachten Sie die folgende Abfrage: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  Der Bediener kann ersetzt werden durch: <br><br>  Bedingung mit <code>IN</code> ;  oder <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Zwei <code>SELECT</code> mit <code>UNION</code> . <br><br>  <b>Tipp:</b> Hier müssen Sie darauf achten, die unnötige <code>UNION</code> Operation nicht zu verwenden, da Sie dieselbe Tabelle mehrmals anzeigen.  Gleichzeitig sollten Sie verstehen, dass sich die Ausführungszeit erhöht, wenn Sie <code>UNION</code> in Ihrer Abfrage verwenden.  Alternativen zur <code>UNION</code> Operation: Formulieren Sie die Abfrage neu, sodass alle Bedingungen in einer einzigen <code>SELECT</code> , oder verwenden Sie <code>OUTER JOIN</code> anstelle von <code>UNION</code> . <br><br>  <b>Tipp:</b> Beachten Sie, dass <code>OR</code> - und die anderen Operatoren, die in den folgenden Abschnitten erwähnt werden - höchstwahrscheinlich keinen Index verwenden, die Indexsuche jedoch nicht immer vorzuziehen ist! <br><br><h4>  <code>NOT</code> Betreiber </h4><br>  Wenn Ihre Abfrage einen <code>NOT</code> Operator enthält, wird der Index wahrscheinlich nicht wie beim <code>OR</code> Operator verwendet.  Dies wird Ihre Anfrage zwangsläufig verlangsamen.  Wenn Sie nicht wissen, was hier gemeint ist, berücksichtigen Sie die folgende Abfrage: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Diese Anforderung wird sicherlich langsamer ausgeführt als erwartet, hauptsächlich weil sie viel komplexer formuliert ist als sie sein kann: In solchen Fällen ist es am besten, nach einer Alternative zu suchen.  Ersetzen Sie <code>NOT</code> Vergleichsoperatoren wie <code>&gt;</code> , <code>&lt;&gt;</code> oder <code>!&gt;</code> .  Das obige Beispiel kann tatsächlich umgeschrieben werden und ungefähr so ​​aussehen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Es sieht schon besser aus, oder? <br><br><h4>  <code>AND</code> Operator </h4><br>  Der <code>AND</code> Operator ist ein weiterer Operator, der keinen Index verwendet und eine Abfrage verlangsamen kann, wenn sie wie im folgenden Beispiel zu komplex und ineffizient verwendet wird: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Es ist besser, diese Abfrage mit der <code>BETWEEN</code> Anweisung neu zu schreiben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> und <code>ALL</code> Operatoren </h4><br>  Darüber hinaus sollten Sie mit den Operatoren <code>ANY</code> und <code>ALL</code> vorsichtig sein, da der Index nicht verwendet wird, wenn Sie sie in Ihre Abfragen aufnehmen.  Hier sind alternative Aggregationsfunktionen wie <code>MIN</code> oder <code>MAX</code> nützlich. <br><br>  Tipp: In Fällen, in denen Sie die vorgeschlagenen Alternativen verwenden, sollten Sie sich bewusst sein, dass alle Aggregationsfunktionen wie <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> über viele Zeilen zu einer langen Abfrage führen können.  In solchen Fällen können Sie versuchen, die Anzahl der zu verarbeitenden Zeilen zu minimieren oder diese Werte vorab zu berechnen.  Wieder einmal sehen Sie, dass es wichtig ist, über Ihre Umgebung, Ihren Zweck der Anfrage, ... Bescheid zu wissen, wenn Sie sich für eine Anfrage entscheiden! <br><br><h4>  Säulen unter Bedingungen isolieren </h4><br>  In Fällen, in denen eine Spalte in einer Berechnung oder in einer Skalarfunktion verwendet wird, wird der Index nicht verwendet.  Eine mögliche Lösung wäre, einfach eine bestimmte Spalte auszuwählen, damit sie nicht mehr Teil der Berechnung oder Funktion ist.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Es sieht lustig aus, oder?  Versuchen Sie stattdessen, die Berechnung zu überarbeiten, und schreiben Sie die Abfrage folgendermaßen neu: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Mangel an roher Gewalt </h3><br>  Dieser letzte Tipp bedeutet, dass Sie nicht versuchen sollten, die Anforderung zu stark einzuschränken, da dies die Leistung beeinträchtigen kann.  Dies gilt insbesondere für Joins und für die HAVING-Klausel. <br><br><h4>  Tabellenreihenfolge in Joins </h4><br>  Beim Verbinden von zwei Tabellen kann es wichtig sein, die Reihenfolge der Tabellen im Join zu berücksichtigen.  Wenn Sie feststellen, dass eine Tabelle erheblich größer als die andere ist, müssen Sie die Abfrage möglicherweise neu schreiben, damit die größte Tabelle als letzte im Join platziert wird. <br><br><h4>  Übermäßige Verbindungsbedingungen </h4><br>  Wenn Sie SQL-Verbindungen zu viele Bedingungen hinzufügen, müssen Sie einen bestimmten Pfad auswählen.  Es kann jedoch sein, dass dieser Pfad nicht immer effizienter ist. <br><br><h4>  Zustand haben </h4><br>  Die <code>HAVING</code> wurde ursprünglich zu SQL hinzugefügt, da das <code>WHERE</code> Schlüsselwort nicht mit Aggregatfunktionen verwendet werden konnte.  <code>HAVING</code> normalerweise mit der <code>GROUP BY</code> , um Gruppen zurückgegebener Zeilen auf diejenigen zu beschränken, die bestimmte Bedingungen erfüllen.  Wenn diese Bedingung jedoch in der Abfrage verwendet wird, wird der Index nicht verwendet, was, wie Sie bereits wissen, dazu führen kann, dass die Abfrage tatsächlich nicht so gut funktioniert. <br><br>  Wenn Sie nach einer Alternative suchen, verwenden Sie die <code>WHERE</code> . <br><br>  Berücksichtigen Sie die folgenden Fragen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  Die erste Abfrage verwendet die <code>WHERE</code> , um die Anzahl der Zeilen zu begrenzen, die zusammengefasst werden müssen, während die zweite Abfrage alle Zeilen in der Tabelle <code>HAVING</code> und dann <code>HAVING</code> , um die berechneten Beträge zu verwerfen.  In solchen Fällen ist die Option <code>WHERE</code> eindeutig besser, da Sie keine Ressourcen verschwenden. <br><br>  Es ist ersichtlich, dass es nicht darum geht, die Ergebnismenge zu begrenzen, sondern darum, die mittlere Anzahl von Datensätzen in der Abfrage zu begrenzen. <br><br>  Es ist zu beachten, dass der Unterschied zwischen den beiden Bedingungen darin besteht, dass die <code>WHERE</code> eine Bedingung für einzelne Zeilen <code>HAVING</code> , während die <code>HAVING</code> eine Bedingung für Aggregationen oder Auswahlergebnisse einführt, wobei ein Ergebnis wie <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... war aus mehreren Zeilen erstellt. <br><br>  Sie sehen, Qualitätsbewertung, Schreiben und Umschreiben von Anfragen sind keine leichte Aufgabe, da sie so produktiv wie möglich sein sollten.  Die Verhinderung von Antimustern und die Berücksichtigung alternativer Optionen sind ebenfalls Teil der Verantwortung beim Schreiben von Abfragen, die in einem professionellen Umfeld an Datenbanken ausgeführt werden müssen. <br><br>  Diese Liste war nur eine kleine Übersicht über einige Antimuster und Tipps, von denen ich hoffe, dass sie Anfängern helfen.  Wenn Sie sich ein Bild davon machen möchten, welche älteren Entwickler die häufigsten Anti-Patterns betrachten, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Diskussion</a> . <br><br><h2>  Set-basierte versus prozedurale Ansätze zum Schreiben von Abfragen </h2><br>  Die oben genannten Antimuster implizierten, dass sie tatsächlich auf einen Unterschied in den satzbasierten und prozeduralen Ansätzen zur Erstellung Ihrer Abfragen zurückzuführen sind. <br><br>  Der prozedurale Ansatz für Abfragen ist dem Programmieren sehr ähnlich: Sie teilen dem System mit, was zu tun ist und wie es zu tun ist. <br><br>  Ein Beispiel hierfür sind übermäßige Bedingungen in Verbindungen oder Fällen, in denen Sie die <code>HAVING</code> Bedingungen missbrauchen, wie in den obigen Beispielen, in denen Sie eine Datenbank abfragen, indem Sie eine Funktion ausführen und dann eine andere Funktion aufrufen, oder wenn Sie eine Logik verwenden, die Bedingungen, Schleifen und benutzerdefinierte Funktionen enthält ( UDF), Cursor, ... um das Endergebnis zu erhalten.  Bei diesem Ansatz fordern Sie häufig eine Teilmenge der Daten an, fordern dann eine weitere Teilmenge der Daten an und so weiter. <br><br>  Es ist nicht überraschend, dass dieser Ansatz häufig als "Schritt-für-Schritt" - oder "Zeile für Zeile" -Abfrage bezeichnet wird. <br><br>  Ein anderer Ansatz ist ein satzbasierter Ansatz, bei dem Sie einfach angeben, was zu tun ist.  Ihre Aufgabe besteht darin, die Bedingungen oder Anforderungen für die Ergebnismenge anzugeben, die Sie von der Abfrage erhalten möchten.  Sie überlassen die Art und Weise, wie Ihre Daten abgerufen werden, den internen Mechanismen, die die Implementierung der Abfrage bestimmen: Sie lassen das Datenbankmodul die besten Algorithmen oder Verarbeitungslogiken bestimmen, um Ihre Abfrage auszuführen. <br><br>  Da SQL satzbasiert ist, ist es nicht verwunderlich, dass dieser Ansatz effizienter als prozedural ist, und es wird auch erklärt, warum SQL in einigen Fällen schneller als Code ausgeführt werden kann. <br><br>  <b>Beratung ist ein satzbasierter</b> Ansatz für die Abfrage, den die meisten führenden Arbeitgeber in der Informationstechnologiebranche von Ihnen verlangen!  Es ist oft notwendig, zwischen diesen beiden Arten von Ansätzen zu wechseln. <br><br>  <b>Bitte beachten Sie,</b> dass Sie, wenn Sie jemals eine Verfahrensanforderung benötigen, in Betracht ziehen sollten, diese umzuschreiben oder umzugestalten. <br><br>  Der nächste Teil behandelt die Plan- und Abfrageoptimierung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465547/">https://habr.com/ru/post/de465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465535/index.html">Wer implementiert IPv6 und was behindert seine Entwicklung?</a></li>
<li><a href="../de465537/index.html">Yandex: ein Smart Home für Erwachsene</a></li>
<li><a href="../de465539/index.html">766 km - ein neuer Reichweitenrekord für LoRaWAN</a></li>
<li><a href="../de465541/index.html">Vom Unternehmen zum KMU: Wir teilen unsere Erfahrung bei der Anpassung von Unternehmenslösungen für kleine und mittlere Unternehmen mit Monetarisierung mithilfe des SaaS-Modells</a></li>
<li><a href="../de465545/index.html">Auf verschiedenen Seiten des Staates: Wie Facebook im US-Kongress gebraten wurde, während Telegram mit dem FSB kämpfte</a></li>
<li><a href="../de465551/index.html">September IT Events Digest (Teil 1)</a></li>
<li><a href="../de465553/index.html">Programmiersprache Ü. Einführung, Motivation zu schaffen, Ziele</a></li>
<li><a href="../de465555/index.html">12 Soft Skills, die IT-Projektmanager unaufhaltsam machen</a></li>
<li><a href="../de465557/index.html">Produktentwicklungsfristen</a></li>
<li><a href="../de465561/index.html">Was ich von einem führenden Programmierer gelernt habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>