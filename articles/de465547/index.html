<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçë üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üë®‚Äçüé® SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 1) üë®üèø‚Äçü§ù‚Äçüë®üèæ üïäÔ∏è üç§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erfahren Sie mehr √ºber Antimuster, Ausf√ºhrungspl√§ne, Zeitkomplexit√§t, Abfrageoptimierung und SQL-Optimierung 
 Structured Query Language (SQL) ist ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  Erfahren Sie mehr √ºber Antimuster, Ausf√ºhrungspl√§ne, Zeitkomplexit√§t, Abfrageoptimierung und SQL-Optimierung </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Structured Query Language (SQL) ist eine unverzichtbare F√§higkeit in der Informatikbranche, und im Allgemeinen ist das Erlernen dieser F√§higkeit relativ einfach.  Die meisten Leute vergessen jedoch, dass es bei SQL nicht nur um das Schreiben von Abfragen geht, sondern nur um den ersten Schritt in die Zukunft.  Ganz anders ist es, die Abfrageleistung sicherzustellen oder den Kontext abzugleichen, in dem Sie arbeiten. <br><br>  Aus diesem Grund erhalten Sie in diesem SQL-Handbuch einen kleinen √úberblick √ºber einige der Schritte, die Sie zur Bewertung Ihrer Abfrage ausf√ºhren k√∂nnen: <br><br><ul><li>  Zun√§chst erhalten Sie einen kurzen √úberblick √ºber die Bedeutung des SQL-Lernens f√ºr die Arbeit im Bereich der Datenwissenschaft. </li><li>  Als N√§chstes lernen Sie zun√§chst, wie Sie SQL-Abfragen verarbeiten und ausf√ºhren, um zu verstehen, wie wichtig es ist, Qualit√§tsabfragen zu erstellen.  Insbesondere werden Sie sehen, dass die Anfrage analysiert, neu geschrieben, optimiert und schlie√ülich ausgewertet wird. </li><li>  In diesem Sinne werden Sie nicht nur zu einigen der Antimuster von Abfragen √ºbergehen, die Anf√§nger beim Schreiben von Abfragen stellen, sondern auch mehr √ºber Alternativen und L√∂sungen f√ºr diese m√∂glichen Fehler erfahren.  Dar√ºber hinaus erfahren Sie mehr √ºber den satzbasierten Abfrageansatz. </li><li>  Sie werden auch feststellen, dass diese Antimuster auf Leistungsproblemen beruhen und dass Sie zus√§tzlich zum ‚Äûmanuellen‚Äú Ansatz zur Verbesserung von SQL-Abfragen Ihre Abfragen mithilfe einiger anderer Tools, die Ihnen beim Anzeigen des Abfrageplans helfen, strukturierter und eingehender analysieren k√∂nnen.  Und </li><li>  Sie lernen kurz die zeitliche Komplexit√§t und die gro√üe O-Notation kennen, um sich rechtzeitig vor der Ausf√ºhrung der Anforderung ein Bild von der Komplexit√§t des Ausf√ºhrungsplans zu machen. </li><li>  Sie erfahren kurz, wie Sie Ihre Abfrage optimieren. </li></ul><a name="habracut"></a><br><h2>  Warum sollten Sie SQL lernen, um mit Daten zu arbeiten? </h2><br>  SQL ist alles andere als tot: Dies ist eine der gefragtesten F√§higkeiten, die Sie in Stellenbeschreibungen aus der Datenverarbeitungs- und Analysebranche finden, unabh√§ngig davon, ob Sie sich f√ºr Datenanalyse, Dateningenieur, Datenspezialist oder eine andere Rolle bewerben.  Dies wird von 70% der Befragten der O 'Reilly Data Science-Gehaltsumfrage f√ºr 2016 best√§tigt, die angeben, dass sie SQL in ihrem beruflichen Kontext verwenden.  Dar√ºber hinaus hebt sich SQL in dieser Umfrage von den Programmiersprachen R (57%) und Python (54%) ab. <br><br>  Sie bekommen das Bild: SQL ist eine notwendige F√§higkeit, wenn Sie daran arbeiten, einen Job in der IT-Branche zu bekommen. <br><br>  Nicht schlecht f√ºr eine Sprache, die in den fr√ºhen 1970ern entwickelt wurde, oder? <br><br>  Aber warum wird es so oft verwendet?  Und warum ist er nicht gestorben, obwohl er so lange existiert hat? <br><br>  Es gibt mehrere Gr√ºnde: Einer der ersten Gr√ºnde k√∂nnte sein, dass Unternehmen Daten haupts√§chlich in relationalen Datenbankverwaltungssystemen (RDBMS) oder in relationalen Datenflussmanagementsystemen (RDSMS) speichern und SQL f√ºr den Zugriff auf diese Daten erforderlich ist.  SQL ist eine <i>Verkehrssprache f√ºr</i> Daten: Es erm√∂glicht die Interaktion mit fast jeder Datenbank oder sogar die Erstellung eigener Datenbanken vor Ort! <br><br>  Wenn dies immer noch nicht ausreicht, denken Sie daran, dass es einige SQL-Implementierungen gibt, die zwischen Anbietern nicht kompatibel sind und nicht unbedingt den Standards entsprechen.  Kenntnisse in Standard-SQL sind daher eine Voraussetzung, um sich in der Branche (Informatik) zurechtzufinden. <br><br>  Dar√ºber hinaus kann man mit Sicherheit sagen, dass auch neuere Technologien SQL beigetreten sind, z. B. Hive, eine SQL-√§hnliche Abfragesprachenschnittstelle zum Abfragen und Verwalten gro√üer Datenmengen, oder Spark SQL, mit dem SQL-Abfragen ausgef√ºhrt werden k√∂nnen.  Auch hier unterscheidet sich das SQL, das Sie dort finden, von dem Standard, den Sie lernen k√∂nnten, aber die Lernkurve wird viel einfacher. <br><br>  Wenn Sie einen Vergleich anstellen m√∂chten, betrachten Sie ihn als Lernen der linearen Algebra: Wenn Sie all diese Anstrengungen in dieses eine Fach gesteckt haben, wissen Sie, dass Sie damit auch maschinelles Lernen beherrschen k√∂nnen! <br><br>  Kurz gesagt, aus diesem Grund sollten Sie diese Abfragesprache lernen: <br><br><ul><li>  Es ist ziemlich leicht zu lernen, auch f√ºr Anf√§nger.  Die Lernkurve ist recht einfach und schrittweise, sodass Sie so schnell wie m√∂glich Abfragen schreiben. </li><li>  Es folgt dem Prinzip ‚Äûeinmal lernen, √ºberall anwenden‚Äú, also ist dies eine gro√üartige Investition Ihrer Zeit! </li><li>  Dies ist eine gro√üartige Erg√§nzung zu Programmiersprachen.  In einigen F√§llen ist das Schreiben einer Abfrage sogar dem Schreiben von Code vorzuziehen, da dies effizienter ist! </li><li>  ... </li></ul><br>  Worauf warten Sie noch?  :) :) <br><br><h2>  SQL-Verarbeitung und Abfrageausf√ºhrung </h2><br>  Um die Leistung Ihrer SQL-Abfrage zu verbessern, m√ºssen Sie zun√§chst wissen, was im Inneren passiert, wenn Sie auf eine Verkn√ºpfung klicken, um die Abfrage auszuf√ºhren. <br><br>  Zun√§chst wird die Anforderung in einen Analysebaum analysiert.  Die Anforderung wird auf √úbereinstimmung mit syntaktischen und semantischen Anforderungen analysiert.  Der Parser erstellt eine interne Darstellung der Eingabeanforderung.  Diese Ausgabe wird dann an den Umschreibemechanismus √ºbertragen. <br><br>  Dann muss der Optimierer den optimalen Ausf√ºhrungs- oder Abfrageplan f√ºr die angegebene Abfrage finden.  Der Ausf√ºhrungsplan bestimmt genau, welcher Algorithmus f√ºr jede Operation verwendet wird und wie Operationen koordiniert werden. <br><br>  Um den optimalsten Ausf√ºhrungsplan zu finden, listet der Optimierer alle m√∂glichen Implementierungspl√§ne auf, ermittelt die Qualit√§t oder die Kosten jedes Plans, empf√§ngt Informationen √ºber den aktuellen Status der Datenbank und w√§hlt dann den besten als endg√ºltigen Implementierungsplan aus.  Da Abfrageoptimierer unvollst√§ndig sein k√∂nnen, m√ºssen Benutzer und Datenbankadministratoren die vom Optimierer erstellten Pl√§ne manchmal manuell √ºberpr√ºfen und optimieren, um die Leistung zu verbessern. <br><br>  Jetzt fragen Sie sich wahrscheinlich, was als ‚Äûguter Abfrageplan‚Äú angesehen wird. <br><br>  Wie Sie bereits gelesen haben, spielt die Qualit√§t der Kosten eines Plans eine wichtige Rolle.  Insbesondere sind Dinge wie die Anzahl der zur Auswertung des Plans erforderlichen Festplatten-E / A, die Kosten der CPU des Plans und die Gesamtantwortzeit, die der Datenbankclient beobachten kann, sowie die Gesamtausf√ºhrungszeit wichtig.  Hier entsteht das Konzept der Zeitkomplexit√§t.  Sie werden sp√§ter mehr dar√ºber erfahren. <br><br>  Anschlie√üend wird der ausgew√§hlte Abfrageplan ausgef√ºhrt, vom Systemausf√ºhrungsmechanismus ausgewertet und die Abfrageergebnisse zur√ºckgegeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  SQL-Abfragen schreiben </h2><br>  Aus dem vorherigen Abschnitt ist m√∂glicherweise nicht klar geworden, dass sich das Prinzip von Garbage In, Garbage Out (GIGO) nat√ºrlich in der Verarbeitung und Ausf√ºhrung einer Abfrage manifestiert: Derjenige, der die Abfrage formuliert, verf√ºgt auch √ºber Schl√ºssel f√ºr die Leistung Ihrer SQL-Abfragen.  Wenn der Optimierer eine schlecht formulierte Anfrage erh√§lt, kann er genauso viel tun ... <br><br>  Dies bedeutet, dass Sie beim Schreiben einer Anfrage einige Dinge tun k√∂nnen.  Wie Sie bereits in der Einleitung gesehen haben, gibt es hier zwei Verantwortlichkeiten: Es geht nicht nur darum, Abfragen zu schreiben, die einem bestimmten Standard entsprechen, sondern auch darum, Ideen zu sammeln, wo Leistungsprobleme in Ihrer Abfrage verborgen sein k√∂nnten. <br><br>  Ein idealer Ausgangspunkt besteht darin, in Ihren Abfragen an ‚ÄûStellen‚Äú zu denken, an denen Probleme auftreten k√∂nnen.  Im Allgemeinen gibt es vier Schl√ºsselw√∂rter, bei denen Neulinge mit Leistungsproblemen rechnen k√∂nnen: <br><br><ul><li> Bedingung <code>WHERE</code> ; </li><li>  Alle Schl√ºsselw√∂rter <code>INNER JOIN</code> oder <code>LEFT JOIN</code> ;  Und auch, </li><li>  Zustand haben; </li></ul><br>  Nat√ºrlich ist dieser Ansatz einfach und naiv, aber f√ºr Anf√§nger sind diese Punkte hervorragende Hinweise, und man kann mit Sicherheit sagen, dass beim ersten Start Fehler an diesen Stellen auftreten und seltsamerweise auch dort, wo es schwer zu bemerken ist. <br><br>  Sie sollten jedoch auch verstehen, dass Leistung etwas ist, das sinnvoll werden sollte.  Nur zu sagen, dass diese S√§tze und Schl√ºsselw√∂rter schlecht sind, ist jedoch nicht das, was Sie brauchen, wenn Sie √ºber die SQL-Leistung nachdenken.  Eine <code>HAVING</code> oder <code>HAVING</code> in einer Anfrage zu haben, bedeutet nicht unbedingt, dass es sich um eine schlechte Anfrage handelt ... <br><br>  Im n√§chsten Abschnitt erfahren Sie mehr √ºber Antimuster und alternative Ans√§tze zum Erstellen Ihrer Abfrage.  Diese Tipps und Tricks dienen als Leitfaden.  Wie und ob Sie Ihre Anfrage wirklich neu schreiben m√ºssen, h√§ngt unter anderem von der Datenmenge, der Datenbank und der H√§ufigkeit ab, mit der Sie die Anfrage abschlie√üen m√ºssen.  Es h√§ngt ganz vom Zweck Ihrer Anfrage ab und es ist entscheidend, Vorkenntnisse √ºber die Datenbank zu haben, mit der Sie arbeiten werden! <br><br><h3>  1. Rufen Sie nur die erforderlichen Daten ab </h3><br>  Die Schlussfolgerung ‚ÄûJe mehr Daten, desto besser‚Äú muss beim Schreiben von SQL nicht beachtet werden: Sie riskieren nicht nur, verwirrt zu werden, wenn Sie mehr Daten abrufen, als Sie wirklich ben√∂tigen, sondern auch die Leistung kann darunter leiden, dass Ihre Abfrage zu viele Daten empf√§ngt. <br><br>  Aus diesem Grund sollten Sie in der Regel auf die <code>SELECT</code> , die <code>DISTINCT</code> <code>SELECT</code> und die <code>LIKE</code> Anweisung achten. <br><br><h4>  <code>SELECT</code> </h4><br>  Das erste, was Sie bereits beim Schreiben einer Abfrage √ºberpr√ºfen k√∂nnen, ist, ob die <code>SELECT</code> so kompakt wie m√∂glich ist.  Das Ziel hier sollte sein, unn√∂tige Spalten aus <code>SELECT</code> zu entfernen.  Auf diese Weise zwingen Sie sich, nur Daten abzurufen, die Ihrem Abfragezweck dienen. <br><br>  Wenn Sie Unterabfragen mit <code>EXISTS</code> korreliert haben, sollten Sie versuchen, eine Konstante in der <code>SELECT</code> dieser Unterabfrage zu verwenden, anstatt den Wert der tats√§chlichen Spalte auszuw√§hlen.  Dies ist besonders praktisch, wenn Sie nur nach Existenz suchen. <br><br>  <b>Denken Sie daran,</b> dass eine korrelierte Unterabfrage eine Unterabfrage ist, die Werte aus einer externen Abfrage verwendet.  Und beachten Sie, dass <code>NULL</code> in diesem Zusammenhang zwar als ‚ÄûKonstante‚Äú <code>NULL</code> kann, dies jedoch sehr verwirrend ist! <br><br>  Betrachten Sie das folgende Beispiel, um zu verstehen, was unter Verwendung einer Konstante zu verstehen ist: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Tipp: Es ist</b> hilfreich zu wissen, dass eine korrelierte Unterabfrage nicht immer eine gute Idee ist.  Sie k√∂nnen sie jederzeit <code>INNER JOIN</code> , indem Sie sie beispielsweise mit <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  Operation <code>DISTINCT</code> </h4><br>  Die <code>SELECT DISTINCT</code> verwendet, um nur unterschiedliche Werte zur√ºckzugeben.  <code>DISTINCT</code> ist ein Punkt, der nach M√∂glichkeit unbedingt vermieden werden sollte.  Wie in anderen Beispielen erh√∂ht sich die Ausf√ºhrungszeit nur, wenn dieser Satz zur Anforderung hinzugef√ºgt wird.  Daher ist es immer hilfreich zu pr√ºfen, ob Sie diese <code>DISTINCT</code> Operation wirklich ben√∂tigen, um die gew√ºnschten Ergebnisse zu erzielen. <br><br><h4>  <code>LIKE</code> Aussage </h4><br>  Bei Verwendung des Operators <code>LIKE</code> in einer Abfrage wird der Index nicht verwendet, wenn das Muster mit <code>%</code> oder <code>_</code> beginnt.  Dadurch wird verhindert, dass die Datenbank den Index verwendet (falls vorhanden).  Unter einem anderen Gesichtspunkt kann nat√ºrlich auch argumentiert werden, dass diese Art von Anforderung m√∂glicherweise dazu f√ºhrt, dass zu viele Datens√§tze abgerufen werden, die nicht unbedingt den Zweck der Anforderung erf√ºllen. <br><br>  Wenn Sie die in der Datenbank gespeicherten Daten kennen, k√∂nnen Sie eine Vorlage formulieren, die alle Daten korrekt filtert, um nur die Zeilen zu finden, die f√ºr Ihre Abfrage wirklich wichtig sind. <br><br><h3>  2. Begrenzen Sie Ihre Ergebnisse </h3><br>  Wenn Sie das Filtern Ihrer <code>SELECT</code> nicht vermeiden k√∂nnen, k√∂nnen Sie Ihre Ergebnisse auf andere Weise einschr√§nken.  Hier kommen Ans√§tze wie die <code>LIMIT</code> und Datentypkonvertierungen ins <code>LIMIT</code> . <br><br><h4>  <code>ROWNUM</code> <code>LIMIT</code> <code>ROWNUM</code> und <code>ROWNUM</code> </h4><br>  Sie k√∂nnen Abfragen <code>LIMIT</code> oder <code>TOP</code> Anweisungen hinzuf√ºgen, um die maximale Anzahl von Zeilen f√ºr die Ergebnismenge anzugeben.  Hier einige Beispiele: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Beachten Sie, dass Sie optional <code>PERCENT</code> angeben <code>PERCENT</code> , wenn Sie beispielsweise die erste <code>SELECT TOP 50 PERCENT *</code> mit <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Alternativ k√∂nnen Sie die <code>ROWNUM</code> hinzuf√ºgen, die der Verwendung von <code>LIMIT</code> in der Abfrage entspricht: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Datentypkonvertierungen </h4><br>  Die effektivsten sollten immer verwendet werden, d.h.  kleinste Datentypen.  Es besteht immer ein Risiko, wenn Sie einen gro√üen Datentyp bereitstellen, w√§hrend ein kleinerer Datentyp ausreicht. <br><br>  Wenn Sie der Abfrage jedoch eine Datentypkonvertierung hinzuf√ºgen, erh√∂ht sich nur die Ausf√ºhrungszeit. <br><br>  Eine Alternative besteht darin, die Datentypkonvertierung so weit wie m√∂glich zu vermeiden.  Beachten Sie auch, dass es nicht immer m√∂glich ist, die Datentypkonvertierung aus Abfragen zu entfernen oder zu √ºberspringen. Sie sollten jedoch immer versuchen, sie einzuschlie√üen, und die Auswirkungen des Hinzuf√ºgens √ºberpr√ºfen, bevor Sie die Abfrage ausf√ºhren. <br><br><h3>  3. Machen Sie Abfragen nicht komplizierter als sie sein sollten </h3><br>  Datentypkonvertierungen f√ºhren Sie zu folgendem Punkt: Sie sollten Ihre Abfragen nicht √ºberm√§√üig gestalten.  Versuchen Sie, sie einfach und effektiv zu machen.  Dies mag zu einfach oder zu dumm erscheinen, um ein Hinweis zu sein, haupts√§chlich weil die Anforderungen komplex sein k√∂nnen. <br><br>  In den in den folgenden Abschnitten genannten Beispielen werden Sie jedoch feststellen, dass Sie einfache Abfragen problemlos komplexer gestalten k√∂nnen, als sie sein sollten. <br><br><h4>  <code>OR</code> Operator </h4><br>  Wenn Sie den Operator <code>OR</code> in Ihrer Abfrage verwenden, verwenden Sie h√∂chstwahrscheinlich keinen Index. <br><br>  Denken Sie daran, dass ein Index eine Datenstruktur ist, die die Suche nach Daten in einer Datenbanktabelle beschleunigt, aber teuer ist: Zus√§tzliche Datens√§tze und zus√§tzlicher Speicherplatz sind erforderlich, um die Indexdatenstruktur aufrechtzuerhalten.  Indizes werden verwendet, um schnell nach Daten zu suchen oder zu suchen, ohne bei jedem Zugriff auf die Datenbanktabelle jede Zeile in der Datenbank durchsuchen zu m√ºssen.  Indizes k√∂nnen mithilfe einer oder mehrerer Spalten in einer Datenbanktabelle erstellt werden. <br><br>  Wenn Sie keine in der Datenbank enthaltenen Indizes verwenden, dauert die Ausf√ºhrung Ihrer Abfrage zwangsl√§ufig l√§nger.  Aus diesem Grund sollten Sie in Ihrer Abfrage nach Alternativen zur Verwendung des Operators <code>OR</code> suchen. <br><br>  Betrachten Sie die folgende Abfrage: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  Der Bediener kann ersetzt werden durch: <br><br>  Bedingung mit <code>IN</code> ;  oder <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Zwei <code>SELECT</code> mit <code>UNION</code> . <br><br>  <b>Tipp:</b> Hier m√ºssen Sie darauf achten, die unn√∂tige <code>UNION</code> Operation nicht zu verwenden, da Sie dieselbe Tabelle mehrmals anzeigen.  Gleichzeitig sollten Sie verstehen, dass sich die Ausf√ºhrungszeit erh√∂ht, wenn Sie <code>UNION</code> in Ihrer Abfrage verwenden.  Alternativen zur <code>UNION</code> Operation: Formulieren Sie die Abfrage neu, sodass alle Bedingungen in einer einzigen <code>SELECT</code> , oder verwenden Sie <code>OUTER JOIN</code> anstelle von <code>UNION</code> . <br><br>  <b>Tipp:</b> Beachten Sie, dass <code>OR</code> - und die anderen Operatoren, die in den folgenden Abschnitten erw√§hnt werden - h√∂chstwahrscheinlich keinen Index verwenden, die Indexsuche jedoch nicht immer vorzuziehen ist! <br><br><h4>  <code>NOT</code> Betreiber </h4><br>  Wenn Ihre Abfrage einen <code>NOT</code> Operator enth√§lt, wird der Index wahrscheinlich nicht wie beim <code>OR</code> Operator verwendet.  Dies wird Ihre Anfrage zwangsl√§ufig verlangsamen.  Wenn Sie nicht wissen, was hier gemeint ist, ber√ºcksichtigen Sie die folgende Abfrage: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Diese Anforderung wird sicherlich langsamer ausgef√ºhrt als erwartet, haupts√§chlich weil sie viel komplexer formuliert ist als sie sein kann: In solchen F√§llen ist es am besten, nach einer Alternative zu suchen.  Ersetzen Sie <code>NOT</code> Vergleichsoperatoren wie <code>&gt;</code> , <code>&lt;&gt;</code> oder <code>!&gt;</code> .  Das obige Beispiel kann tats√§chlich umgeschrieben werden und ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Es sieht schon besser aus, oder? <br><br><h4>  <code>AND</code> Operator </h4><br>  Der <code>AND</code> Operator ist ein weiterer Operator, der keinen Index verwendet und eine Abfrage verlangsamen kann, wenn sie wie im folgenden Beispiel zu komplex und ineffizient verwendet wird: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Es ist besser, diese Abfrage mit der <code>BETWEEN</code> Anweisung neu zu schreiben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> und <code>ALL</code> Operatoren </h4><br>  Dar√ºber hinaus sollten Sie mit den Operatoren <code>ANY</code> und <code>ALL</code> vorsichtig sein, da der Index nicht verwendet wird, wenn Sie sie in Ihre Abfragen aufnehmen.  Hier sind alternative Aggregationsfunktionen wie <code>MIN</code> oder <code>MAX</code> n√ºtzlich. <br><br>  Tipp: In F√§llen, in denen Sie die vorgeschlagenen Alternativen verwenden, sollten Sie sich bewusst sein, dass alle Aggregationsfunktionen wie <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> √ºber viele Zeilen zu einer langen Abfrage f√ºhren k√∂nnen.  In solchen F√§llen k√∂nnen Sie versuchen, die Anzahl der zu verarbeitenden Zeilen zu minimieren oder diese Werte vorab zu berechnen.  Wieder einmal sehen Sie, dass es wichtig ist, √ºber Ihre Umgebung, Ihren Zweck der Anfrage, ... Bescheid zu wissen, wenn Sie sich f√ºr eine Anfrage entscheiden! <br><br><h4>  S√§ulen unter Bedingungen isolieren </h4><br>  In F√§llen, in denen eine Spalte in einer Berechnung oder in einer Skalarfunktion verwendet wird, wird der Index nicht verwendet.  Eine m√∂gliche L√∂sung w√§re, einfach eine bestimmte Spalte auszuw√§hlen, damit sie nicht mehr Teil der Berechnung oder Funktion ist.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Es sieht lustig aus, oder?  Versuchen Sie stattdessen, die Berechnung zu √ºberarbeiten, und schreiben Sie die Abfrage folgenderma√üen neu: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Mangel an roher Gewalt </h3><br>  Dieser letzte Tipp bedeutet, dass Sie nicht versuchen sollten, die Anforderung zu stark einzuschr√§nken, da dies die Leistung beeintr√§chtigen kann.  Dies gilt insbesondere f√ºr Joins und f√ºr die HAVING-Klausel. <br><br><h4>  Tabellenreihenfolge in Joins </h4><br>  Beim Verbinden von zwei Tabellen kann es wichtig sein, die Reihenfolge der Tabellen im Join zu ber√ºcksichtigen.  Wenn Sie feststellen, dass eine Tabelle erheblich gr√∂√üer als die andere ist, m√ºssen Sie die Abfrage m√∂glicherweise neu schreiben, damit die gr√∂√üte Tabelle als letzte im Join platziert wird. <br><br><h4>  √úberm√§√üige Verbindungsbedingungen </h4><br>  Wenn Sie SQL-Verbindungen zu viele Bedingungen hinzuf√ºgen, m√ºssen Sie einen bestimmten Pfad ausw√§hlen.  Es kann jedoch sein, dass dieser Pfad nicht immer effizienter ist. <br><br><h4>  Zustand haben </h4><br>  Die <code>HAVING</code> wurde urspr√ºnglich zu SQL hinzugef√ºgt, da das <code>WHERE</code> Schl√ºsselwort nicht mit Aggregatfunktionen verwendet werden konnte.  <code>HAVING</code> normalerweise mit der <code>GROUP BY</code> , um Gruppen zur√ºckgegebener Zeilen auf diejenigen zu beschr√§nken, die bestimmte Bedingungen erf√ºllen.  Wenn diese Bedingung jedoch in der Abfrage verwendet wird, wird der Index nicht verwendet, was, wie Sie bereits wissen, dazu f√ºhren kann, dass die Abfrage tats√§chlich nicht so gut funktioniert. <br><br>  Wenn Sie nach einer Alternative suchen, verwenden Sie die <code>WHERE</code> . <br><br>  Ber√ºcksichtigen Sie die folgenden Fragen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  Die erste Abfrage verwendet die <code>WHERE</code> , um die Anzahl der Zeilen zu begrenzen, die zusammengefasst werden m√ºssen, w√§hrend die zweite Abfrage alle Zeilen in der Tabelle <code>HAVING</code> und dann <code>HAVING</code> , um die berechneten Betr√§ge zu verwerfen.  In solchen F√§llen ist die Option <code>WHERE</code> eindeutig besser, da Sie keine Ressourcen verschwenden. <br><br>  Es ist ersichtlich, dass es nicht darum geht, die Ergebnismenge zu begrenzen, sondern darum, die mittlere Anzahl von Datens√§tzen in der Abfrage zu begrenzen. <br><br>  Es ist zu beachten, dass der Unterschied zwischen den beiden Bedingungen darin besteht, dass die <code>WHERE</code> eine Bedingung f√ºr einzelne Zeilen <code>HAVING</code> , w√§hrend die <code>HAVING</code> eine Bedingung f√ºr Aggregationen oder Auswahlergebnisse einf√ºhrt, wobei ein Ergebnis wie <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... war aus mehreren Zeilen erstellt. <br><br>  Sie sehen, Qualit√§tsbewertung, Schreiben und Umschreiben von Anfragen sind keine leichte Aufgabe, da sie so produktiv wie m√∂glich sein sollten.  Die Verhinderung von Antimustern und die Ber√ºcksichtigung alternativer Optionen sind ebenfalls Teil der Verantwortung beim Schreiben von Abfragen, die in einem professionellen Umfeld an Datenbanken ausgef√ºhrt werden m√ºssen. <br><br>  Diese Liste war nur eine kleine √úbersicht √ºber einige Antimuster und Tipps, von denen ich hoffe, dass sie Anf√§ngern helfen.  Wenn Sie sich ein Bild davon machen m√∂chten, welche √§lteren Entwickler die h√§ufigsten Anti-Patterns betrachten, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Diskussion</a> . <br><br><h2>  Set-basierte versus prozedurale Ans√§tze zum Schreiben von Abfragen </h2><br>  Die oben genannten Antimuster implizierten, dass sie tats√§chlich auf einen Unterschied in den satzbasierten und prozeduralen Ans√§tzen zur Erstellung Ihrer Abfragen zur√ºckzuf√ºhren sind. <br><br>  Der prozedurale Ansatz f√ºr Abfragen ist dem Programmieren sehr √§hnlich: Sie teilen dem System mit, was zu tun ist und wie es zu tun ist. <br><br>  Ein Beispiel hierf√ºr sind √ºberm√§√üige Bedingungen in Verbindungen oder F√§llen, in denen Sie die <code>HAVING</code> Bedingungen missbrauchen, wie in den obigen Beispielen, in denen Sie eine Datenbank abfragen, indem Sie eine Funktion ausf√ºhren und dann eine andere Funktion aufrufen, oder wenn Sie eine Logik verwenden, die Bedingungen, Schleifen und benutzerdefinierte Funktionen enth√§lt ( UDF), Cursor, ... um das Endergebnis zu erhalten.  Bei diesem Ansatz fordern Sie h√§ufig eine Teilmenge der Daten an, fordern dann eine weitere Teilmenge der Daten an und so weiter. <br><br>  Es ist nicht √ºberraschend, dass dieser Ansatz h√§ufig als "Schritt-f√ºr-Schritt" - oder "Zeile f√ºr Zeile" -Abfrage bezeichnet wird. <br><br>  Ein anderer Ansatz ist ein satzbasierter Ansatz, bei dem Sie einfach angeben, was zu tun ist.  Ihre Aufgabe besteht darin, die Bedingungen oder Anforderungen f√ºr die Ergebnismenge anzugeben, die Sie von der Abfrage erhalten m√∂chten.  Sie √ºberlassen die Art und Weise, wie Ihre Daten abgerufen werden, den internen Mechanismen, die die Implementierung der Abfrage bestimmen: Sie lassen das Datenbankmodul die besten Algorithmen oder Verarbeitungslogiken bestimmen, um Ihre Abfrage auszuf√ºhren. <br><br>  Da SQL satzbasiert ist, ist es nicht verwunderlich, dass dieser Ansatz effizienter als prozedural ist, und es wird auch erkl√§rt, warum SQL in einigen F√§llen schneller als Code ausgef√ºhrt werden kann. <br><br>  <b>Beratung ist ein satzbasierter</b> Ansatz f√ºr die Abfrage, den die meisten f√ºhrenden Arbeitgeber in der Informationstechnologiebranche von Ihnen verlangen!  Es ist oft notwendig, zwischen diesen beiden Arten von Ans√§tzen zu wechseln. <br><br>  <b>Bitte beachten Sie,</b> dass Sie, wenn Sie jemals eine Verfahrensanforderung ben√∂tigen, in Betracht ziehen sollten, diese umzuschreiben oder umzugestalten. <br><br>  Der n√§chste Teil behandelt die Plan- und Abfrageoptimierung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465547/">https://habr.com/ru/post/de465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465535/index.html">Wer implementiert IPv6 und was behindert seine Entwicklung?</a></li>
<li><a href="../de465537/index.html">Yandex: ein Smart Home f√ºr Erwachsene</a></li>
<li><a href="../de465539/index.html">766 km - ein neuer Reichweitenrekord f√ºr LoRaWAN</a></li>
<li><a href="../de465541/index.html">Vom Unternehmen zum KMU: Wir teilen unsere Erfahrung bei der Anpassung von Unternehmensl√∂sungen f√ºr kleine und mittlere Unternehmen mit Monetarisierung mithilfe des SaaS-Modells</a></li>
<li><a href="../de465545/index.html">Auf verschiedenen Seiten des Staates: Wie Facebook im US-Kongress gebraten wurde, w√§hrend Telegram mit dem FSB k√§mpfte</a></li>
<li><a href="../de465551/index.html">September IT Events Digest (Teil 1)</a></li>
<li><a href="../de465553/index.html">Programmiersprache √ú. Einf√ºhrung, Motivation zu schaffen, Ziele</a></li>
<li><a href="../de465555/index.html">12 Soft Skills, die IT-Projektmanager unaufhaltsam machen</a></li>
<li><a href="../de465557/index.html">Produktentwicklungsfristen</a></li>
<li><a href="../de465561/index.html">Was ich von einem f√ºhrenden Programmierer gelernt habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>