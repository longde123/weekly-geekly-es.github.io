<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí§ üéã üë®üèº‚Äç‚úàÔ∏è Prueba de anotaciones @ no nulas / @ anulables üë∞üèª üòÉ üöÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En lugar de "Dedicado a ..." 
 La tarea que se describe a continuaci√≥n no fue innovadora ni muy √∫til, la empresa en la que trabajo no recibir√° gananci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba de anotaciones @ no nulas / @ anulables</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464939/"><h3>  En lugar de "Dedicado a ..." </h3><br>  La tarea que se describe a continuaci√≥n no fue innovadora ni muy √∫til, la empresa en la que trabajo no recibir√° ganancias por ello, pero ser√© una bonificaci√≥n. <br><br>  Pero esta tarea era, y por lo tanto ten√≠a que ser resuelta. <br><br><h3>  Introducci√≥n </h3><br>  En el art√≠culo, a menudo encontrar√°s la palabra Lombok, les pido a los que odian que no se apresuren a sacar conclusiones. <br>  No voy a "ahogarme" por Lombok o su ausencia, yo, como Geralt Sapkovsky, trato de ser neutral, y puedo leer el c√≥digo con o sin Lombok con calma y sin temblar en el siglo. <br><br>  Pero en el proyecto actual, la biblioteca mencionada est√° presente, y algo me dice que nuestro proyecto no es el √∫nico. <br>  Entonces aqu√≠. <br><a name="habracut"></a><br>  La √∫ltima vez en Java ciertamente hay una tendencia hacia annotashki.  Para la gloria del concepto de falla r√°pida, los par√°metros de los m√©todos a menudo se anotan con la anotaci√≥n @NonNull (de modo que si algo sale mal, entonces desaparece). <br><br>  Hay muchas opciones de importaci√≥n para esto (o una anotaci√≥n similar en ideolog√≠a), pero, como ya ha quedado claro, nos centraremos en la versi√≥n <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.NonNull;</code> </pre> <cut></cut><br>  Si usa esta anotaci√≥n (o similar), entonces tiene alg√∫n contrato que debe verificar con una prueba y cualquier analizador de c√≥digo est√°tico le dir√° amablemente (Sonar le dice exactamente). <br><br>  Probar esta anotaci√≥n con una prueba unitaria es bastante simple, el problema es que tales pruebas se multiplicar√°n en su proyecto a la velocidad de los conejos en la primavera, y los conejos, como saben, violan el principio DRY. <br><br>  En el art√≠culo, escribiremos un peque√±o marco de prueba para probar el contrato de las anotaciones @NonNull (y para que Sonar no brille en tus ojos con una desagradable luz roja). <br><br>  <b>PD:</b> El nombre de la canci√≥n se inspir√≥ en la canci√≥n de la banda PowerWolf, que toc√≥ (por golly) cuando escrib√≠ el nombre (en el original, el nombre suena m√°s positivo) <br><br><h3>  Cuerpo principal </h3><br>  Inicialmente, probamos la anotaci√≥n algo as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodNameWithNullArgumentThrowException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { instance.getAnyType(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); fail(<span class="hljs-string"><span class="hljs-string">"Exception not thrown"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> NullPointerException e) { assertNotNull(e); } }</code> </pre> <br>  Llamaron al m√©todo y pasaron nulo como un par√°metro anotado con la anotaci√≥n @NonNull. <br>  Obtuvieron NPE y quedaron satisfechos (Sonar tambi√©n estaba feliz). <br><br>  Luego comenzaron a hacer lo mismo, pero con una afirmaci√≥n m√°s moderna que funciona a trav√©s del proveedor (nos encantan las lambdas): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TestUnitRepeatOnce</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodNameWithNullArgumentThrowException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertThrows(NullPointerException.class, () -&gt; instance.getAnyType(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)); }</code> </pre> <br>  Con estilo  De moda  Juventud <br><br>  Parece posible terminar, las anotaciones se prueban, ¬øy qu√© m√°s? <br><br>  El problema (no es el problema, pero a√∫n as√≠) de este m√©todo de prueba "surgi√≥" cuando un d√≠a escrib√≠ una prueba para un m√©todo, funcion√≥ con √©xito, y luego not√© que no hay una anotaci√≥n @NonNull en el par√°metro. <br><br>  Es comprensible: llama al m√©todo de prueba, sin describir el comportamiento de las clases de moque, a trav√©s de when () / then ().  El hilo de ejecuci√≥n ingresa de manera segura al m√©todo, en alg√∫n lugar dentro de √©l atrapa NPE, en un objeto desbloqueado (o bloqueado, pero sin cu√°ndo () / luego ()) y se bloquea, sin embargo, con NPE, como advirti√≥, lo que significa que la prueba es verde <br><br>  Resulta que estamos probando en este caso, no la anotaci√≥n, pero no est√° claro qu√©.  Con la prueba funcionando correctamente, ni siquiera deber√≠amos tener que profundizar en el m√©todo (caer en el umbral). <cut></cut><br>  Las anotaciones @NonNull de Lombok tienen una caracter√≠stica: si pasamos de NPE a anotaciones, el nombre del par√°metro se escribe en el error. <br><br>  Nos involucraremos en esto, despu√©s de que caigamos de NPE, verificaremos adicionalmente el texto de stacktrace, as√≠: <br><br><pre> <code class="java hljs">exception.getCause().getMessage().equals(parameter.getName())</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Y si de repente ...</b> <div class="spoiler_text">  En caso de que Lombok se actualice repentinamente y deje de escribir el nombre del par√°metro que recibi√≥ un valor nulo en stacktrace, revisaremos la conferencia de Andrei Pangin sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TI JVM</a> y escribiremos un complemento para la JVM, en el que pasamos el nombre del par√°metro. <br></div></div><br>  Todo parece ser nada, ahora realmente comprobamos lo que se necesita, pero el problema de los "conejos" no est√° resuelto. <br><br>  Me gustar√≠a tener una herramienta que podr√≠a decirse, por ejemplo, as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TestUnitRepeatOnce</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonNullAnnotationTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertNonNullAnnotation(YourPerfectClass.class); }</code> </pre> <br>  y √©l mismo ir√≠a a escanear todos los m√©todos p√∫blicos de la clase especificada y comprobar√≠a todos sus par√°metros @NonNull con una prueba. <br><br>  Dir√°, obtenga una reflexi√≥n y verifique si el m√©todo @NonNull est√° activado y si hay una vi√±eta nula. <br><br>  Todo no ser√≠a nada, pero RetentionPolicy no es el indicado. <br><br>  Todas las anotaciones tienen un par√°metro RetentionPolicy, que puede ser de 3 tipos: SOURCE, CLASS y RUNTIME, por lo que Lombok tiene RetentionPolicy.SOURCE de forma predeterminada, lo que significa que esta anotaci√≥n no es visible en Runtime y no la encontrar√° a trav√©s de la reflexi√≥n. <br><br>  En nuestro proyecto, todos los par√°metros de los m√©todos p√∫blicos se anotan (sin contar las primitivas), si se entiende que el par√°metro no puede ser nulo, si se supone lo contrario, entonces spring @Nullable anotar√° el par√°metro.  Puede participar en esto, buscaremos todos los m√©todos p√∫blicos y todos los par√°metros que no est√©n marcados con @Nullable y que no sean primitivos. <br>  Queremos decir que para todos los dem√°s casos, la anotaci√≥n @NonNull debe estar en los par√°metros. <br><br>  Por conveniencia, siempre que sea posible, difundiremos la l√≥gica por m√©todos privados, para empezar obtendremos todos los m√©todos p√∫blicos: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;Method&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPublicMethods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(clazz.getDeclaredMethods()) .filter(METHOD_FILTER) .collect(toList()); }</code> </pre> <br>  donde METHOD_FILTER es un predicado regular en el que decimos que: <br><br><ul><li>  El m√©todo debe ser p√∫blico. </li><li>  No debe ser sint√©tico (y esto sucede cuando tiene un m√©todo con un par√°metro sin formato) </li><li>  No debe ser abstracto (sobre clases abstractas por separado y a continuaci√≥n) </li><li>  El nombre del m√©todo no debe ser igual (en caso de que alg√∫n tipo de persona malvada decida poblar una clase con iguales anulados () en la entrada de nuestro marco POJO) </li></ul><br>  Despu√©s de obtener todos los m√©todos que necesitamos, comenzamos a clasificarlos en un bucle, <br>  Si el m√©todo no tiene ning√∫n par√°metro, este no es nuestro candidato: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getParameterCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Si hay par√°metros, debemos entender si est√°n @NonNull anotados (en caso de que sean m√°s precisos, de acuerdo con <br><br><div class="spoiler">  <b class="spoiler_title">l√≥gica</b> <div class="spoiler_text"><ul><li>  m√©todo p√∫blico </li><li>  no @Nullable </li><li>  no primitivo </li></ul><br></div></div><br>  Para hacer esto, haga un mapa y coloque nuestros par√°metros en √©l de acuerdo con la secuencia en el m√©todo, y frente a ellos ponemos una bandera que dice si la anotaci√≥n @NonNull debe estar arriba o no: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nonNullAnnotationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; val parameterCurrentMethodArray = method.getParameters(); val notNullAnnotationParameterMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer, Boolean&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val parameter : parameterCurrentMethodArray) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); nonNullAnnotationCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  este mapa es √∫til para que podamos llamar al m√©todo y pasarlo como nulo a todos los par√°metros con la anotaci√≥n @NonNull a su vez, y no solo el primero. <br><br>  El par√°metro nonNullAnnotationCount cuenta cu√°ntos par√°metros en el m√©todo se deben anotar @NonNull, determinar√° el n√∫mero de interacciones de integraci√≥n de llamadas para cada m√©todo. <br><br>  Por cierto, si no hay anotaciones @NonNull (hay par√°metros, pero todos son primitivos o @Nullable), entonces no hay nada de qu√© hablar: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Tenemos a mano un mapa de par√°metros.  Sabemos cu√°ntas veces llamar a un m√©todo y en qu√© posiciones anular, el asunto es peque√±o (como pens√© ingenuamente sin comprender), necesitamos crear una instancia de la clase y llamar m√©todos sobre ellos. <br><br>  Los problemas comienzan cuando te das cuenta de cu√°n diferente es una instancia: puede ser una clase privada, puede ser una clase con un constructor predeterminado, con un constructor con par√°metros, con tal y tal constructor, una clase abstracta, una interfaz (con sus m√©todos predeterminados, que tambi√©n son p√∫blicos y que tambi√©n necesitan ser probados). <br><br>  Y cuando construimos la instancia por las buenas o por las malas, necesitamos pasar los par√°metros al m√©todo de invocaci√≥n y aqu√≠ tambi√©n expandirnos: ¬øc√≥mo crear una instancia de la clase final?  y Enum?  y primitivo?  y un conjunto de primitivas (que tambi√©n es un objeto y tambi√©n puede ser anotado). <br><br>  Bueno, hag√°moslo en orden. <br><br>  El primer caso es una clase con un constructor privado: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(clazz, invokeMethodParameterArray); makeErrorMessage(method); }</code> </pre> <br>  luego simplemente invocamos nuestro m√©todo de invocaci√≥n, pasamos el clazz que vino del exterior a la prueba y una matriz de par√°metros en los que nulo ya est√° cargado en la primera posici√≥n con la bandera para la anotaci√≥n @NonNull (recuerde, arriba creamos el mapa @ NonNulls) comenzamos ejecutar en un bucle y crear una matriz de par√°metros, cambiando alternativamente la posici√≥n del par√°metro nulo y poniendo a cero la bandera antes de llamar al m√©todo, de modo que en la pr√≥xima integraci√≥n el otro par√°metro se vuelva nulo. <br><br>  En c√≥digo, se ve as√≠: <br><br><pre> <code class="java hljs">val invokeMethodParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[parameterCurrentMethodArray.length]; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentNullableIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invokeMethodParameterArray.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) { currentNullableIndex = i; invokeMethodParameterArray[i] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i); } }</code> </pre> <br>  La primera opci√≥n de instanciaci√≥n fue resuelta. <br><br>  En otras interfaces, no puede tomar y crear una instancia de una interfaz (ni siquiera tiene un constructor). <br><br>  Por lo tanto, con la interfaz ser√° as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (INTERFACE_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray); makeErrorMessage(method); }</code> </pre> <br>  createInstanceByDynamicProxy nos permite crear una instancia en una clase si implementa al menos una interfaz, o si es una interfaz en s√≠ misma <br><br><div class="spoiler">  <b class="spoiler_title">Matiz</b> <div class="spoiler_text">  tenga en cuenta que aqu√≠ es fundamentalmente qu√© interfaces implementa la clase, la interfaz de tipo (y no algunas Comparable) es importante, en el que hay m√©todos que implementa en la clase de destino, de lo contrario la instancia lo sorprender√° con su tipo <br></div></div><br>  pero por dentro es as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByDynamicProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newProxyInstance( currentThread().getContextClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, (proxy, method1, args) -&gt; { Constructor&lt;Lookup&gt; constructor = Lookup.class .getDeclaredConstructor(Class.class); constructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); constructor.newInstance(clazz) .in(clazz) .unreflectSpecial(method1, clazz) .bindTo(proxy) .invokeWithArguments(invokeMethodParameterArray); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Rastrillo</b> <div class="spoiler_text">  Por cierto, tambi√©n hubo algunos rastrillos aqu√≠, ya no recuerdo cu√°les, hab√≠a muchos, pero debes crear un proxy a trav√©s de Lookup.class <br></div></div><br>  La siguiente instancia (mi favorita) es una clase abstracta.  Y aqu√≠, el proxy din√°mico ya no nos ayudar√°, ya que si una clase abstracta implementa alg√∫n tipo de interfaz, claramente este no es el tipo que nos gustar√≠a.  Y as√≠, no podemos tomar y crear newInstance () a partir de una clase abstracta.  Aqu√≠ CGLIB vendr√° en nuestra ayuda, una biblioteca de primavera que crea proxies basados ‚Äã‚Äãen la herencia, pero el problema es que la clase objetivo debe tener un constructor predeterminado (sin par√°metros) <br><br><div class="spoiler">  <b class="spoiler_title">Chismes</b> <div class="spoiler_text">  Aunque a juzgar por los chismes en Internet desde la primavera 4, CGLIB puede funcionar sin √©l, y entonces: ¬° <b>Entonces no funciona!</b> <br></div></div>  La opci√≥n para crear instancias de una clase abstracta ser√≠a esta: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAbstract(clazz.getModifiers())) { createInstanceByCGLIB(clazz, method, invokeMethodParameterArray); makeErrorMessage(); }</code> </pre> <br>  makeErrorMessage (), que ya se vio en los ejemplos de c√≥digo, descarta la prueba, si llamamos al m√©todo con el par√°metro anotado @NonNull pasando nulo y no cay√≥, entonces la prueba no funcion√≥, debe descartar. <br><br>  Para el mapeo de par√°metros, tenemos un m√©todo com√∫n que puede mapear y bloquear los par√°metros del constructor y del m√©todo, se ve as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstantiationException, IllegalAccessException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinal(parameter.getType().getModifiers())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isEnum()) { methodParam[index] = Enum.valueOf( (Class&lt;Enum&gt;) (parameter.getType()), parameter.getType().getEnumConstants()[<span class="hljs-number"><span class="hljs-number">0</span></span>].toString() ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isPrimitive()) { mappingPrimitiveName(parameter, methodParam, index); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().getTypeName().equals(<span class="hljs-string"><span class="hljs-string">"byte[]"</span></span>)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = parameter.getType().newInstance(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = mock(parameter.getType()); } }</code> </pre> <br>  Presta atenci√≥n a la creaci√≥n de Enum (guinda del pastel), en general, no puedes simplemente tomar y crear Enum. <br><br>  Aqu√≠ para los par√°metros finales, su propia asignaci√≥n, para los no finales, y luego simplemente en el texto (c√≥digo). <br><br>  Bueno, despu√©s de crear los par√°metros para el constructor y para el m√©todo, formamos nuestra instancia: <br><br><pre> <code class="java hljs">val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParameterArray.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i); } notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray); makeErrorMessage(method);</code> </pre> <cut></cut><br>  Ya sabemos con certeza que, dado que hemos llegado a esta etapa del c√≥digo, significa que tenemos al menos un constructor, podemos tomar cualquiera para crear una instancia, por lo que tomamos el primero que vemos, vemos si tiene par√°metros en el constructor y, si no, llama as√≠: <br><br><pre> <code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray);</code> </pre> <br><br>  Bueno, si hay algo como esto: <br><pre> <code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray);</code> </pre> <cut></cut><br>  Esta es la l√≥gica que ocurre en el m√©todo createAndInvoke () que viste un poco m√°s arriba. <br>  La versi√≥n completa de la clase de prueba bajo el spoiler, no la sub√≠ a git, como escrib√≠ en un proyecto de trabajo, pero de hecho es solo una clase que se puede heredar en tus pruebas y usar. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Method&gt; METHOD_FILTER = method -&gt; isPublic(method.getModifiers()) &amp;&amp; isFalse(method.isSynthetic()) &amp;&amp; isFalse(isAbstract(method.getModifiers())) &amp;&amp; isFalse(method.getName().equals(<span class="hljs-string"><span class="hljs-string">"equals"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Class&gt; ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER = clazz -&gt; clazz.getConstructors().length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; isFalse(clazz.isInterface()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;Class&gt; INTERFACE_FILTER = clazz -&gt; clazz.getConstructors().length == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiPredicate&lt;Exception, Parameter&gt; LOMBOK_ERROR_FILTER = (exception, parameter) -&gt; isNull(exception.getCause().getMessage()) || isFalse(exception.getCause().getMessage().equals(parameter.getName())); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertNonNullAnnotation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val method : getPublicMethods(clazz)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getParameterCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nonNullAnnotationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; val parameterCurrentMethodArray = method.getParameters(); val notNullAnnotationParameterMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer, Boolean&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val parameter : parameterCurrentMethodArray) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); nonNullAnnotationCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonNullAnnotationCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; nonNullAnnotationCount; j++) { val invokeMethodParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[parameterCurrentMethodArray.length]; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentNullableIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invokeMethodParameterArray.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) { currentNullableIndex = i; invokeMethodParameterArray[i] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; hasNullParameter = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(clazz, invokeMethodParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (INTERFACE_FILTER.test(clazz)) { notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAbstract(clazz.getModifiers())) { createInstanceByCGLIB(clazz, method, invokeMethodParameterArray); makeErrorMessage(); } val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParameterArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParameterArray.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i); } notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray); makeErrorMessage(method); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LOMBOK_ERROR_FILTER.test(e, parameterCurrentMethodArray[currentNullableIndex])) { makeErrorMessage(method); } } } } } <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndInvoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Constructor firstFindConstructor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] constructorParameterArray )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (firstFindConstructor.getParameters().length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance()), invokeMethodParameterArray); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { method.invoke(spy(clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>].newInstance(constructorParameterArray)), invokeMethodParameterArray); } } <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByCGLIB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ MethodInterceptor handler = (obj, method1, args, proxy) -&gt; proxy.invoke(clazz, args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clazz.getConstructors().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; val constructorParam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[firstFindConstructor.getParameters().length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorParam.length; i++) { mappingParameter(firstFindConstructor.getParameters()[i], constructorParam, i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val constructor : clazz.getConstructors()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constructor.getParameters().length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { val proxy = Enhancer.create(clazz, handler); method.invoke(proxy.getClass().newInstance(), invokeMethodParameterArray); } } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstanceByDynamicProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] invokeMethodParameterArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newProxyInstance( currentThread().getContextClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, (proxy, method1, args) -&gt; { Constructor&lt;Lookup&gt; constructor = Lookup.class .getDeclaredConstructor(Class.class); constructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); constructor.newInstance(clazz) .in(clazz) .unreflectSpecial(method1, clazz) .bindTo(proxy) .invokeWithArguments(invokeMethodParameterArray); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeErrorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fail(<span class="hljs-string"><span class="hljs-string">"  @NonNull     DefaultConstructor  "</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeErrorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method method)</span></span></span><span class="hljs-function"> </span></span>{ fail(<span class="hljs-string"><span class="hljs-string">"    "</span></span> + method.getName() + <span class="hljs-string"><span class="hljs-string">"   @NonNull"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;Method&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPublicMethods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class clazz)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(clazz.getDeclaredMethods()) .filter(METHOD_FILTER) .collect(toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstantiationException, IllegalAccessException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinal(parameter.getType().getModifiers())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isEnum()) { methodParam[index] = Enum.valueOf( (Class&lt;Enum&gt;) (parameter.getType()), parameter.getType().getEnumConstants()[<span class="hljs-number"><span class="hljs-number">0</span></span>].toString() ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().isPrimitive()) { mappingPrimitiveName(parameter, methodParam, index); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameter.getType().getTypeName().equals(<span class="hljs-string"><span class="hljs-string">"byte[]"</span></span>)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = parameter.getType().newInstance(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { methodParam[index] = mock(parameter.getType()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappingPrimitiveName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Parameter parameter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] methodParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ val name = parameter.getType().getName(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"long"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"int"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"byte"</span></span>.equals(name)) { methodParam[index] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"short"</span></span>.equals(name)) { methodParam[index] = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"double"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>d; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"float"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"boolean"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"char"</span></span>.equals(name)) { methodParam[index] = <span class="hljs-string"><span class="hljs-string">'A'</span></span>; } } }</code> </pre> <br></div></div><br><h3>  Conclusi√≥n </h3><br>  Este c√≥digo funciona y prueba las anotaciones en un proyecto real, por el momento solo hay una opci√≥n posible, cuando todo lo dicho puede colapsarse. <br><br>  Declare un setter de Lombock en la clase (si hay un especialista que no establece el setter en la clase Pojo, aunque eso simplemente no sucede) y el campo en el que se declarar√° el setter no ser√° definitivo. <br><br>  Luego, el marco dir√° amablemente que hay un m√©todo p√∫blico, y tiene un par√°metro en el que no hay una anotaci√≥n @NonNull, la soluci√≥n es simple: declarar expl√≠citamente el establecedor y anotar su par√°metro en funci√≥n del contexto de la l√≥gica @ NonNull / @ Nullable. <br><br>  Tenga en cuenta que si desea que est√© vinculado al nombre del par√°metro del m√©todo en sus pruebas (o algo m√°s), en Runtime los nombres de las variables en los m√©todos no est√°n disponibles de forma predeterminada, encontrar√° arg [0] y arg [1], etc. . <br>  Para habilitar la visualizaci√≥n de nombres de m√©todos en Runtime, use el complemento Maven: <br><br><pre> <code class="java hljs">&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;${maven.compiler.plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;${compile.target.source}&lt;/source/&gt; &lt;target&gt;${compile.target.source}&lt;/target&gt; &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt; &lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt;</code> </pre><br>  y en particular esta clave: <br><br><pre> <code class="java hljs">&lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt;</code> </pre> <br>  Espero que te haya interesado. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464939/">https://habr.com/ru/post/464939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464929/index.html">Carga diferida de la imagen del navegador (atributo de carga)</a></li>
<li><a href="../464931/index.html">Ensamblador inserta ... en C #?</a></li>
<li><a href="../464933/index.html">Aplicaciones para libros electr√≥nicos en el sistema operativo Android. Parte 4. Juegos</a></li>
<li><a href="../464935/index.html">C√≥modo DevOpsSec: Nemesida WAF Gratis para NGINX con API y cuenta personal</a></li>
<li><a href="../464937/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 312 (del 19 al 25 de agosto)</a></li>
<li><a href="../464947/index.html">Eventos digitales en Mosc√∫ del 25 de agosto al 1 de septiembre</a></li>
<li><a href="../464949/index.html">Una vez m√°s sobre GCD, el algoritmo euclidiano y un poco sobre la historia de los algoritmos en general. Por supuesto con ejemplos Swift</a></li>
<li><a href="../464951/index.html">Cuanto m√°s simple es la tarea, m√°s a menudo me equivoco</a></li>
<li><a href="../464955/index.html">Iron Mike Tyson y el proyecto blockchain Fight to Fame</a></li>
<li><a href="../464959/index.html">Analizando la oraci√≥n del idioma ruso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>