<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜ üßëüèº‚Äçü§ù‚Äçüßëüèº üëÜüèº RabbitMQ vs. Kafka: uso de Kafka en aplicaciones orientadas a eventos üßóüèº ü§≤üèø üë©üèø‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un art√≠culo anterior, analizamos los patrones y las topolog√≠as utilizadas en RabbitMQ. En esta parte, recurriremos a Kafka y lo compararemos con Ra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: uso de Kafka en aplicaciones orientadas a eventos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/418389/"><p>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior,</a> analizamos los patrones y las topolog√≠as utilizadas en RabbitMQ.  En esta parte, recurriremos a Kafka y lo compararemos con RabbitMQ para obtener algunas ideas sobre sus diferencias.  Debe tenerse en cuenta que las arquitecturas de aplicaciones orientadas a eventos se comparar√°n en lugar de las canalizaciones de procesamiento de datos, aunque la l√≠nea entre estos dos conceptos ser√° bastante borrosa en este caso.  En general, esto es m√°s un espectro que una separaci√≥n clara.  Nuestra comparaci√≥n se centrar√° simplemente en la parte de este espectro relacionada con las aplicaciones basadas en eventos. </p><br><p><img src="https://habrastorage.org/webt/fu/xp/vw/fuxpvw1pzsm4miouvpbwo7qxq-m.png"></p><a name="habracut"></a><br><p>  La primera diferencia que viene a la mente es que el reintento de mensajes y los mecanismos de repetici√≥n utilizados por RabbitMQ para trabajar con mensajes de letra muerta en Kafka no tienen sentido.  En RabbitMQ, los mensajes son temporales, se transmiten y desaparecen.  Por lo tanto, volver a agregarlos es un caso de uso absolutamente real.  Y en Kafka, la revista ocupa un lugar central.  Resolver problemas de entrega reenviando un mensaje a la cola no tiene sentido y solo da√±a el diario.  Una de las ventajas es la distribuci√≥n clara y garantizada de mensajes entre las particiones de la revista, los mensajes repetidos confunden un esquema bien organizado.  En RabbitMQ, ya puede enviar mensajes a la cola con la que trabaja un destinatario, y en la plataforma Kafka hay un diario para todos los destinatarios.  Las demoras en la entrega y los problemas con la entrega de mensajes no representan mucho da√±o para el funcionamiento de la revista, pero Kafka no contiene mecanismos de demora incorporados. </p><br><p>  En la secci√≥n sobre esquemas de mensajer√≠a se discutir√° c√≥mo reenviar mensajes en la plataforma Kafka. </p><br><p>  La segunda gran diferencia que afecta los posibles esquemas de mensajer√≠a es que RabbitMQ almacena mensajes mucho menos que Kafka.  Cuando un mensaje ya se entreg√≥ al destinatario en RabbitMQ, se elimina sin dejar rastro de su existencia.  En Kafka, cada mensaje se mantiene en un registro hasta que se borra.  La frecuencia de la limpieza depende de la cantidad de datos disponibles, la cantidad de espacio en disco que planea asignar para ellos y los esquemas de mensajer√≠a que desea garantizar. Puede usar la ventana de tiempo en la que almacenamos los mensajes durante un per√≠odo de tiempo determinado: los √∫ltimos d√≠as / semanas / meses. </p><br><p>  De esta forma, Kafka permite al destinatario volver a ver o recuperar mensajes anteriores.  Parece una tecnolog√≠a para enviar mensajes, aunque no funciona exactamente igual que en RabbitMQ. </p><br><p>  Si RabbitMQ mueve mensajes y proporciona elementos poderosos para crear esquemas de enrutamiento complejos, Kafka guarda el estado actual y anterior del sistema.  Esta plataforma se puede utilizar como fuente de datos hist√≥ricos confiables, ya que RabbitMQ no. </p><br><h3>  Ejemplo de esquema de mensajer√≠a en la plataforma Kafka <br></h3><br><p> El ejemplo m√°s simple de usar tanto RabbitMQ como Kafka es la difusi√≥n de informaci√≥n de acuerdo con el esquema "editor-suscriptor".  Uno o m√°s publicadores agregan mensajes al registro particionado, y estos mensajes son recibidos por el suscriptor de uno o m√°s grupos de suscriptores. </p><br><p><img src="https://habrastorage.org/webt/rx/lw/56/rxlw56hzrjigugjyiiu01avpxho.png"><br>  <em>Figura 1. Varios editores env√≠an mensajes al registro particionado y varios grupos de destinatarios los reciben.</em> </p><br><p>  Si no entra en detalles sobre c√≥mo el editor env√≠a mensajes a las secciones necesarias de la revista, y c√≥mo los grupos de destinatarios se coordinan entre s√≠, este esquema no difiere de la topolog√≠a de fanout (intercambio bifurcado) que se utiliza en RabbitMQ. <br>  En un art√≠culo anterior, se discutieron todos los esquemas y topolog√≠as de mensajer√≠a RabbitMQ.  Quiz√°s en alg√∫n momento pensaste "No necesito todas estas dificultades, solo quiero enviar y recibir mensajes en la cola", y el hecho de que puedes rebobinar la revista a posiciones anteriores hablaba de las ventajas obvias de Kafka. </p><br><p>  Para las personas que est√°n acostumbradas a las caracter√≠sticas tradicionales de los sistemas de colas, el hecho de la posibilidad de retroceder el reloj y rebobinar el registro de eventos en el pasado es sorprendente.  Esta propiedad (disponible mediante el uso del registro en lugar de la cola) es muy √∫til para recuperarse de fallas.  Yo (el autor del art√≠culo en ingl√©s) comenc√© a trabajar para mi cliente actual hace 4 a√±os como gerente t√©cnico del grupo de soporte del sistema del servidor.  Ten√≠amos m√°s de 50 aplicaciones que recib√≠an informaci√≥n en tiempo real sobre eventos comerciales a trav√©s de MSMQ, y lo habitual era que cuando se produc√≠a un error en la aplicaci√≥n, el sistema lo detectaba solo al d√≠a siguiente.  Desafortunadamente, a menudo los mensajes desaparecieron como resultado, pero usualmente pudimos obtener los datos iniciales de un sistema de terceros y reenviar mensajes solo al "suscriptor" que ten√≠a el problema.  Esto nos oblig√≥ a crear una infraestructura de mensajer√≠a para los destinatarios.  Y si tuvi√©ramos la plataforma Kafka, no ser√≠a m√°s dif√≠cil hacer ese trabajo que cambiar el enlace a la ubicaci√≥n del √∫ltimo mensaje recibido para la aplicaci√≥n en la que ocurri√≥ el error. </p><br><h3 id="integraciya-dannyh-v-sobytiyno-orientirovannyh-prilozheniyah-i-sistemah">  Integraci√≥n de datos en aplicaciones y sistemas orientados a eventos </h3><br><p>  Este esquema es, en muchos sentidos, un medio para generar eventos, aunque no est√° relacionado con una sola aplicaci√≥n.  Hay dos niveles de generaci√≥n de eventos: software y sistema.  El presente esquema est√° asociado con este √∫ltimo. </p><br><h4 id="programmnyy-uroven-porozhdeniya-sobytiy">  Generaci√≥n de eventos a nivel de programa </h4><br><p>  La aplicaci√≥n gestiona su propio estado a trav√©s de una secuencia inmutable de eventos de cambio que se almacenan en el almac√©n de eventos.  Para obtener el estado actual de la aplicaci√≥n, debe jugar o combinar sus eventos en la secuencia correcta.  Por lo general, en dicho modelo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el</a> modelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CQRS</a> Kafka se puede usar como este sistema. </p><br><h4 id="vzaimodeystvie-mezhdu-prilozheniyami-na-urovne-sistemy">  Interacci√≥n entre aplicaciones a nivel de sistema. </h4><br><p>  Las aplicaciones o servicios pueden administrar su estado de cualquier manera que su desarrollador quiera administrar, por ejemplo, en una base de datos relacional regular. </p><br><p>  Pero las aplicaciones a menudo necesitan datos unos de otros, esto conduce a arquitecturas sub√≥ptimas, por ejemplo, bases de datos comunes, desenfoque de los l√≠mites de la entidad o API REST inconvenientes. </p><br><p>  Yo (el autor del art√≠culo en ingl√©s) escuch√© el podcast " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Software Engineering Daily</a> ", que describe un escenario orientado a eventos para los perfiles de servicio en las redes sociales.  Hay una serie de servicios relacionados en el sistema, como la b√∫squeda, un sistema de gr√°ficos sociales, un motor de recomendaciones, etc., todos ellos necesitan saber acerca de un cambio en el estado de un perfil de usuario.  Cuando yo (el autor del art√≠culo en ingl√©s) trabaj√© como arquitecto de la arquitectura para un sistema relacionado con el transporte a√©reo, ten√≠amos dos grandes sistemas de software con una mir√≠ada de peque√±os servicios relacionados.  Los servicios de soporte requer√≠an datos de pedidos y vuelos.  Cada vez que se creaba o cambiaba un pedido, cuando un vuelo se retrasaba o cancelaba, estos servicios ten√≠an que activarse. </p><br><p>  Se requer√≠a una t√©cnica para generar eventos.  Pero primero, veamos algunos problemas comunes que surgen en los grandes sistemas de software, y veamos c√≥mo la generaci√≥n de eventos puede resolverlos. </p><br><p>  Un gran sistema corporativo integrado generalmente se desarrolla org√°nicamente;  Se realizan migraciones a nuevas tecnolog√≠as y nuevas arquitecturas, que pueden no afectar al 100% del sistema.  Los datos se distribuyen a diferentes partes de la instituci√≥n, las aplicaciones divulgan bases de datos para uso p√∫blico de modo que la integraci√≥n se produce lo m√°s r√°pido posible, y nadie puede predecir con certeza c√≥mo interactuar√°n todos los elementos del sistema. </p><br><h4 id="neuporyadochennoe-rasprostranenie-dannyh">  Distribuci√≥n aleatoria de datos </h4><br><p>  Los datos se distribuyen en diferentes lugares y se administran en diferentes lugares, por lo que es dif√≠cil de entender: </p><br><ul><li>  c√≥mo se mueven los datos en los procesos comerciales; </li><li>  c√≥mo los cambios en una parte del sistema pueden afectar a otras partes; </li><li>  qu√© hacer con los conflictos de datos que surgen debido al hecho de que hay muchas copias de datos que se propagan lentamente. </li></ul><br><p>  Si no hay l√≠mites claros de las entidades de dominio, los cambios ser√°n costosos y riesgosos, ya que afectan a muchos sistemas a la vez. </p><br><h4 id="centralizovannaya-raspredelennaya-baza-dannyh">  Base de datos distribuida centralizada </h4><br><p>  Una base de datos abierta p√∫blicamente puede causar varios problemas: </p><br><ul><li>  No est√° lo suficientemente optimizado para cada aplicaci√≥n por separado. Lo m√°s probable es que esta base de datos contenga un conjunto de datos excesivamente completo para la aplicaci√≥n, adem√°s, est√° normalizada de tal manera que las aplicaciones tendr√°n que ejecutar consultas muy complejas para recibirlas. </li><li>  Usando una base de datos com√∫n, las aplicaciones pueden afectar el trabajo de los dem√°s. </li><li>  Los cambios en la estructura l√≥gica de la base de datos requieren coordinaci√≥n a gran escala y trabajo en la migraci√≥n de datos, y el desarrollo de servicios individuales se detendr√° durante todo este proceso. </li><li>  Nadie quiere cambiar la estructura de almacenamiento.  Los cambios que todos esperan son demasiado dolorosos. </li></ul><br><h4 id="ispolzovanie-neudobnogo-rest-api">  Usando la inconveniente API REST </h4><br><p>  Obtener datos de otros sistemas a trav√©s de la API REST, por un lado, agrega conveniencia y aislamiento, pero a√∫n as√≠ no siempre es exitoso.  Cada interfaz de este tipo puede tener su propio estilo especial y sus propias convenciones.  Obtener los datos necesarios puede requerir muchas solicitudes HTTP y ser bastante complicado. </p><br><p>  Nos estamos moviendo cada vez m√°s hacia la c√©ntrica API, y tales arquitecturas brindan muchas ventajas, especialmente cuando los servicios est√°n fuera de nuestro control.  Hay tantas maneras convenientes de crear una API en este momento que no tenemos que escribir tanto c√≥digo como necesit√°bamos antes.  Sin embargo, esta no es la √∫nica herramienta disponible, y existen alternativas para la arquitectura interna del sistema. </p><br><h4 id="kafka-kak-hranilische-sobytiy">  Kafka como repositorio de eventos </h4><br><p>  Damos un ejemplo.  Hay un sistema que gestiona las reservas en una base de datos relacional.  El sistema utiliza todas las garant√≠as de atomicidad, consistencia, aislamiento y durabilidad que ofrece la base de datos para administrar sus caracter√≠sticas de manera efectiva y todos est√°n contentos.  La divisi√≥n de la responsabilidad en equipos y solicitudes, la generaci√≥n de eventos, los microservicios est√°n ausentes, en general, un monolito tradicionalmente construido.  Pero hay una gran cantidad de servicios de soporte (posiblemente microservicios) relacionados con las reservas: notificaciones push, distribuci√≥n de correo electr√≥nico, sistema antifraude, programa de fidelizaci√≥n, facturaci√≥n, sistema de cancelaci√≥n, etc.  La lista sigue y sigue.  Todos estos servicios requieren detalles de reserva, y hay muchas maneras de obtenerlos.  Estos servicios producen datos que pueden ser √∫tiles para otras aplicaciones. </p><br><p><img src="https://habrastorage.org/webt/tk/e6/rc/tke6rcvglscapqo_nbx4yk228si.png"><br>  <em>Figura 2. Diversos tipos de integraci√≥n de datos.</em> </p><br><p>  Arquitectura alternativa basada en Kafka.  Cada vez que realiza una nueva reserva o cambia una reserva anterior, el sistema env√≠a datos completos sobre el estado actual de esta reserva a Kafka.  Al consolidar el diario, puede acortar los mensajes para que solo quede informaci√≥n sobre el √∫ltimo estado de reserva.  En este caso, el tama√±o de la revista estar√° bajo control. </p><br><p><img src="https://habrastorage.org/webt/gq/bq/j2/gqbqj2zxxu_zk2sgd-qxrvd17pm.png"><br>  <em>Figura 3. Integraci√≥n de datos basada en Kafka como base para la generaci√≥n de eventos.</em> </p><br><p>  Para todas las aplicaciones para las que esto es necesario, esta informaci√≥n es la fuente de la verdad y la √∫nica fuente de datos.  De repente, nos estamos moviendo de una red integrada de dependencias y tecnolog√≠as para enviar y recibir datos a / desde los temas de Kafka. </p><br><p>  Kafka como repositorio de eventos: </p><br><ul><li>  Si no hay ning√∫n problema con el espacio en disco, Kafka puede almacenar todo el historial de eventos, es decir, se puede implementar una nueva aplicaci√≥n y descargar toda la informaci√≥n necesaria del diario.  Los registros de eventos que reflejan completamente las caracter√≠sticas de los objetos se pueden comprimir compilando el registro, lo que har√° que este enfoque est√© m√°s justificado para muchos escenarios. </li><li>  ¬øQu√© pasa si los eventos deben jugarse en el orden correcto?  Mientras los registros de eventos se distribuyan correctamente, puede establecer el orden de su reproducci√≥n y aplicar filtros, herramientas de conversi√≥n, etc., para que la reproducci√≥n de datos siempre termine con la informaci√≥n necesaria.  Dependiendo de la posibilidad de distribuci√≥n de datos, es posible asegurar su procesamiento altamente paralelo en el orden correcto. </li><li>  Puede ser necesario un cambio de modelo de datos.  Al crear una nueva funci√≥n de filtro / transformaci√≥n, puede ser necesario reproducir registros de todos los eventos o eventos durante la semana pasada. </li></ul><br><p>  Los mensajes pueden llegar a Kafka no solo desde aplicaciones de su organizaci√≥n que env√≠an mensajes sobre todos los cambios en sus caracter√≠sticas (o los resultados de estos cambios) sino tambi√©n desde servicios de terceros integrados con su sistema.  Esto sucede de las siguientes maneras: </p><br><ul><li>  Exportaci√≥n peri√≥dica, transferencia, importaci√≥n de datos recibidos de servicios de terceros y su descarga a Kafka. </li><li>  Descarga de datos de servicios de terceros en Kafka. </li><li>  Los datos de CSV y otros formatos cargados desde servicios de terceros se cargan a Kafka. </li></ul><br><p>  Volvamos a las preguntas que consideramos anteriormente.  La arquitectura basada en Kafka simplifica la distribuci√≥n de datos.  Sabemos d√≥nde est√° la fuente de la verdad, sabemos d√≥nde est√°n sus fuentes de datos y todas las aplicaciones de destino funcionan con copias <strong>derivadas</strong> de estos datos.  Los datos van del remitente a los destinatarios.  Los datos de origen pertenecen solo al remitente, pero otros son libres de trabajar con sus proyecciones.  Pueden filtrar, transformar, complementarlos con datos de otras fuentes, guardarlos en sus propias bases de datos. </p><br><p><img src="https://habrastorage.org/webt/hw/i7/jw/hwi7jw2n5m5t2hkqb9kx2rqi49c.png"><br>  <em>Fig. 4. Fuente y datos de salida.</em> </p><br><p>  Toda aplicaci√≥n que necesite datos de reserva y de vuelo los recibir√° por s√≠ misma, ya que est√° "suscrita" a las secciones de Kafka que contienen estos datos.  Para esta aplicaci√≥n, pueden usar SQL, Cypher, JSON o cualquier otro lenguaje de consulta.  Una aplicaci√≥n puede guardar datos en su sistema como mejor le parezca.  El esquema de distribuci√≥n de datos se puede cambiar sin afectar el funcionamiento de otras aplicaciones. </p><br><p>  Puede surgir la pregunta: ¬øpor qu√© no se puede hacer todo esto usando RabbitMQ?  La respuesta es que RabbitMQ puede usarse para procesar eventos en tiempo real, pero no como base para generar eventos.  RabbitMQ es una soluci√≥n completa solo para responder a eventos que est√°n sucediendo ahora.  Cuando se agrega una nueva aplicaci√≥n que necesita su propia parte de los datos de reserva presentados en un formato optimizado para las tareas de esta aplicaci√≥n, RabbitMQ no podr√° ayudar.  Con RabbitMQ, volvemos a las bases de datos compartidas o la API REST. </p><br><p>  En segundo lugar, el orden en que se procesan los eventos es importante.  Si trabaja con RabbitMQ, cuando agrega un segundo destinatario a la cola, se pierde la garant√≠a de cumplimiento del pedido.  Por lo tanto, el orden correcto de env√≠o de mensajes se observa solo para un destinatario, pero esto, por supuesto, no es suficiente. </p><br><p>  Kafka, por el contrario, puede proporcionar todos los datos que esta aplicaci√≥n necesita para crear su propia copia de los datos y mantenerlos actualizados, mientras que Kafka sigue el orden en que se env√≠an los mensajes. </p><br><p>  Ahora volvamos a las arquitecturas centradas en API.  ¬øEstas interfaces ser√°n siempre la mejor opci√≥n?  Cuando desee abrir el acceso de datos de solo lectura, preferir√≠a una arquitectura de emisi√≥n de eventos.  Evitar√° fallas en cascada y acortar√° la vida √∫til asociada con un aumento en el n√∫mero de dependencias de otros servicios.  Habr√° m√°s oportunidades para una organizaci√≥n de datos creativa y eficiente dentro de los sistemas.  Pero a veces necesita cambiar los datos de forma sincronizada tanto en su sistema como en otro sistema, y ‚Äã‚Äãen tal situaci√≥n, los sistemas centrados en API ser√°n √∫tiles.  Muchos los prefieren a otros m√©todos asincr√≥nicos.  Creo que esto es cuesti√≥n de gustos. </p><br><h3 id="prilozheniya-chuvstvitelnye-k-vysokomu-trafiku-i-poryadku-obrabotki-sobytiy">  Aplicaciones sensibles de alto tr√°fico y procesamiento de eventos. </h3><br><p>  No hace mucho tiempo, surgi√≥ un problema con uno de los receptores de RabbitMQ, que recibi√≥ archivos en cola de un servicio de terceros.  El tama√±o total del archivo era grande y la aplicaci√≥n se configur√≥ espec√≠ficamente para recibir ese volumen de datos.  El problema fue que los datos llegaron de manera inconsistente, esto cre√≥ muchos problemas. </p><br><p>  Adem√°s, a veces hab√≠a un problema en el hecho de que a veces dos archivos estaban destinados al mismo destino, y su hora de llegada difer√≠a en varios segundos.  Ambos pasaron por el procesamiento y tuvieron que cargarse en un servidor.  Y despu√©s de que el segundo mensaje se grab√≥ en el servidor, el primer mensaje que le sigue sobrescribe el segundo.  Por lo tanto, todo termin√≥ con el almacenamiento de datos no v√°lidos.  RabbitMQ cumpli√≥ su funci√≥n y envi√≥ mensajes en el orden correcto, pero de todos modos, todo termin√≥ en el orden incorrecto en la aplicaci√≥n misma. </p><br><p>  Este problema se resolvi√≥ leyendo la marca de tiempo de los registros existentes y la falta de respuesta si el mensaje era antiguo.  Adem√°s, se aplic√≥ hashing constante durante el intercambio de datos, y la cola se dividi√≥, al igual que con la misma partici√≥n en la plataforma Kafka. </p><br><p>  Como parte de la partici√≥n, Kafka almacena los mensajes en el orden en que fueron enviados.  El orden del mensaje existe solo dentro de la partici√≥n.  En el ejemplo anterior, usando Kafka, tuvimos que aplicar la funci√≥n hash al id del destino para seleccionar la partici√≥n deseada.  Tuvimos que crear un conjunto de particiones, deber√≠a haber m√°s de las que requiri√≥ el cliente.  El orden de procesamiento de mensajes deber√≠a haberse logrado debido al hecho de que cada partici√≥n est√° destinada a un solo destinatario.  Simple y efectivo. </p><br><p>  Kafka, en comparaci√≥n con RabbitMQ, tiene algunas ventajas asociadas con la divisi√≥n de mensajes mediante hashing.  No hay nada en la plataforma RabbitMQ que pueda evitar conflictos de destinatarios dentro de la misma cola que se genera como parte del intercambio de datos utilizando hashing consistente.  RabbitMQ no ayuda a coordinar los destinatarios para que solo un destinatario de toda la cola use el mensaje.  Kafka proporciona todo esto mediante el uso de grupos de destinatarios y un nodo coordinador.  Esto le permite asegurarse de que solo un destinatario de la secci√≥n tenga garantizado el uso del mensaje y que el orden de procesamiento de datos est√© garantizado. </p><br><h3 id="lokalnost-dannyh">  Localidad de datos </h3><br><p>  Utilizando una funci√≥n hash para distribuir datos entre particiones, Kafka proporciona la localidad de datos.  Por ejemplo, los mensajes del usuario con ID 1001 siempre deben ir al destinatario 3. Dado que los eventos del usuario 1001 siempre van al destinatario 3, el destinatario 3 puede realizar efectivamente algunas operaciones que ser√≠an mucho m√°s dif√≠ciles si fuera necesario recibir un acceso regular a una base de datos externa u otros sistemas datos  Podemos leer datos, realizar agregaciones, etc.  directamente con informaci√≥n en la memoria del destinatario.  Este es el lugar donde las aplicaciones orientadas a eventos y la transmisi√≥n de datos comienzan a combinarse. </p><br><p>  ¬øC√≥mo proporciona Kafka la localidad de datos?  Para empezar, es importante tener en cuenta que Kafka no permite aumentar y disminuir el√°sticamente el n√∫mero de particiones.  En primer lugar, no puede reducir el n√∫mero de particiones: si hay 10, no puede reducir el n√∫mero a 9.  Pero, por otro lado, esto no es obligatorio.  Cada destinatario puede usar 1 o varias particiones, por lo tanto, apenas es necesario reducir su n√∫mero.  La creaci√≥n de particiones adicionales en Kafka lleva a un retraso en el momento del reequilibrio, por lo que intentamos escalar el n√∫mero de particiones teniendo en cuenta las cargas m√°ximas. </p><br><p>  Pero si a√∫n necesitamos aumentar el n√∫mero de particiones y destinatarios para escalar, solo necesitaremos costos indirectos √∫nicos si es necesario reequilibrar.  Cabe se√±alar que, al escalar, los datos antiguos permanecen en las mismas particiones donde estaban.  Pero los nuevos mensajes entrantes ya se enrutar√°n de manera diferente, y las nuevas particiones comenzar√°n a recibir nuevos mensajes.  Los mensajes del usuario 1001 ahora pueden ir al destinatario 4 (porque los datos sobre el usuario 1001 ahora est√°n en dos secciones). </p><br><p>  Adem√°s, compararemos y compararemos la sem√°ntica de entrega de los mensajes de entrega en ambos sistemas.  El tema del reequilibrio y la partici√≥n merece un art√≠culo separado, que discutiremos en la siguiente parte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418389/">https://habr.com/ru/post/es418389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418379/index.html">Pr√≥tesis bioel√©ctrica infantil. Parte 2</a></li>
<li><a href="../es418381/index.html">Novedades de DevTools en Chrome Versi√≥n 68</a></li>
<li><a href="../es418383/index.html">Animaciones de Android basadas en Kotlin y RxJava</a></li>
<li><a href="../es418385/index.html">C√≥mo ensambl√© una computadora para juegos antiguos</a></li>
<li><a href="../es418387/index.html">Di√°logo f√≠sico sobre el alma.</a></li>
<li><a href="../es418391/index.html">OSPF (primera parte)</a></li>
<li><a href="../es418393/index.html">[Viernes] C√≥mo vimos Web 3D</a></li>
<li><a href="../es418395/index.html">Elon Musk: los generadores locales de campo electromagn√©tico proteger√°n a los colonos en Marte</a></li>
<li><a href="../es418397/index.html">Gesti√≥n del viernes: seminarios web gratuitos de Skillbox</a></li>
<li><a href="../es418399/index.html">En la ola de Selectel FM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>