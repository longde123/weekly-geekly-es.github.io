<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ´Ô∏è ü§úüèº üëâüèæ Errores de HttpClient en .NET üëû ‚è© üìì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuando con una serie de art√≠culos sobre "trampas", no puedo ignorar System.Net.HttpClient, que se usa muy a menudo en la pr√°ctica, pero tiene var...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Errores de HttpClient en .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424873/">  Continuando con una serie de art√≠culos sobre "trampas", no puedo ignorar System.Net.HttpClient, que se usa muy a menudo en la pr√°ctica, pero tiene varios problemas graves que pueden no ser visibles de inmediato. <br><br>  Un problema bastante com√∫n en la programaci√≥n es que los desarrolladores se centran solo en la funcionalidad de un componente en particular, mientras ignoran por completo un componente no funcional muy importante, que puede afectar el rendimiento, la escalabilidad, la facilidad de recuperaci√≥n en caso de fallas, seguridad, etc.  Por ejemplo, el mismo HttpClient es aparentemente un componente elemental, pero hay varias preguntas: cu√°nto crea conexiones paralelas al servidor, cu√°nto tiempo viven, c√≥mo se comportar√° si el nombre DNS al que se accedi√≥ anteriormente se cambia a una direcci√≥n IP diferente ?  Intentemos responder estas preguntas en el art√≠culo. <br><a name="habracut"></a><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuga de conexi√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limite las conexiones concurrentes del servidor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conexiones duraderas y almacenamiento en cach√© de DNS</a> </li></ol><br><a name="1"></a>  El primer problema con HttpClient es la <b>fuga de conexi√≥n</b> no obvia.  Muy a menudo, ten√≠a que encontrar el c√≥digo donde se crea para ejecutar cada solicitud: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid textId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">$"http://someservice.com/api/v1/some-text/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{textId}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br>  Desafortunadamente, este enfoque conduce a un gran desperdicio de recursos y una alta probabilidad de obtener un desbordamiento de la lista de conexiones abiertas.  Para mostrar claramente el problema, es suficiente ejecutar el siguiente c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); } } }</code> </pre><br>  Y al final, mira la lista de conexiones abiertas a trav√©s de netstat: <br><br><pre> PS C: \ Desarrollo \ Ejercicios&gt; netstat -n |  select-string -pattern "178.248.237.68"<font></font>
<font></font>
   TCP 192.168.1.13:43684 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43685 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43686 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43687 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43689 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003690 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003691 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003692 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003693 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003695 178.248.237.68-00-0043 TIME_WAIT
</pre><br>  <i>Aqu√≠, el modificador -n se usa para acelerar la salida, ya que de lo contrario netstat para cada IP buscar√° el nombre de dominio, y 178.248.237.68 buscar√° la direcci√≥n IP de habr.com al momento de escribir esto.</i> <br><br>  En total, vemos que a pesar del uso de la construcci√≥n, y aunque el programa se complet√≥ por completo, las conexiones al servidor permanecieron "colgadas".  Y se colgar√°n durante el tiempo indicado en la clave de registro HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Services \ Tcpip \ Parameters \ TcpTimedWaitDelay. <br><br>  Puede surgir una pregunta de inmediato: ¬øc√≥mo se comporta .NET Core en tales casos?  Lo que est√° en Windows, lo que est√° en Linux, exactamente lo mismo, porque dicha retenci√≥n de conexi√≥n se produce a nivel del sistema y no a nivel de la aplicaci√≥n.  El estado TIME_WAIT es un estado especial del socket despu√©s de que la aplicaci√≥n lo cierra, y esto es necesario para procesar paquetes que a√∫n pueden pasar por la red.  Para Linux, la duraci√≥n de este estado se especifica en segundos en / proc / sys / net / ipv4 / tcp_fin_timeout y, por supuesto, se puede cambiar si es necesario. <br><br><a name="2"></a>  El segundo problema de HttpClient es el <b>l√≠mite</b> no obvio <b>de conexiones concurrentes al servidor</b> .  Suponga que usa el .NET Framework 4.7 familiar, con la ayuda del cual desarrolla un servicio altamente cargado, donde hay llamadas a otros servicios a trav√©s de HTTP.  Se ha solucionado el problema potencial con la p√©rdida de conexi√≥n, por lo que se utiliza la misma instancia de HttpClient para todas las solicitudes.  ¬øQu√© podr√≠a estar mal? <br><br>  El problema se puede ver f√°cilmente ejecutando el siguiente c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  <i>El recurso especificado en el enlace le permite retrasar la respuesta del servidor durante el tiempo especificado, en este caso, 5 segundos.</i> <br><br>  Como es f√°cil notar despu√©s de ejecutar el c√≥digo anterior, cada 5 segundos solo llegan 2 respuestas, aunque se crearon 10 solicitudes simult√°neas.  Esto se debe al hecho de que la interacci√≥n con HTTP en un marco .NET regular, entre otras cosas, pasa por una clase especial System.Net.ServicePointManager que controla varios aspectos de las conexiones HTTP.  Esta clase tiene una propiedad DefaultConnectionLimit que indica cu√°ntas conexiones concurrentes se pueden crear para cada dominio.  Y as√≠, hist√≥ricamente, el valor predeterminado de una propiedad es 2. <br><br>  Si agrega el ejemplo de c√≥digo anterior al principio <br><br><pre> <code class="cs hljs">ServicePointManager.DefaultConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  entonces la ejecuci√≥n del ejemplo se acelerar√° notablemente, ya que las solicitudes se ejecutar√°n en lotes de 5. <br><br>  Y antes de pasar a c√≥mo funciona esto en .NET Core, se debe decir un poco m√°s sobre ServicePointManager.  La propiedad descrita anteriormente indica el n√∫mero predeterminado de conexiones que se utilizar√°n para conexiones posteriores a cualquier dominio.  Pero junto con esto, es posible controlar los par√°metros para cada nombre de dominio individualmente y esto se hace a trav√©s de la clase ServicePoint: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk"</span></span>)); delayServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Despu√©s de ejecutar este c√≥digo, cualquier interacci√≥n con Habr a trav√©s de la misma instancia de HttpClient utilizar√° 5 conexiones simult√°neas y 3 conexiones con el sitio "lento". <br><br>  Aqu√≠ hay otro matiz interesante: el l√≠mite en el n√∫mero de conexiones para direcciones locales (localhost) es int.MaxValue de forma predeterminada.  Solo mire los resultados de ejecutar este c√≥digo sin configurar primero el DefaultConnectionLimit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); Console.WriteLine(habrServicePoint.ConnectionLimit); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>)); Console.WriteLine(localServicePoint.ConnectionLimit);</code> </pre><br>  Ahora pasemos a .NET Core.  Aunque ServicePointManager todav√≠a existe en el espacio de nombres System.Net, no afecta el comportamiento de HttpClient en .NET Core.  En cambio, los par√°metros de conexi√≥n HTTP se pueden controlar utilizando HttpClientHandler (o SocketsHttpHandler, del que hablaremos m√°s adelante): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler(); handler.MaxConnectionsPerServer = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  El ejemplo anterior se comportar√° exactamente igual que el ejemplo inicial para .NET Framework normal: para establecer solo 2 conexiones a la vez.  Pero si elimina la l√≠nea con el conjunto de propiedades MaxConnectionsPerServer, el n√∫mero de conexiones simult√°neas ser√° mucho mayor, ya que de forma predeterminada en .NET Core el valor de esta propiedad es int.MaxValue. <br><br><a name="3"></a>  Y ahora veamos el tercer problema no obvio con la configuraci√≥n predeterminada, que puede ser no menos cr√≠tico que los dos anteriores: <b>conexiones de larga duraci√≥n y almacenamiento en cach√© de DNS</b> .  Cuando se establece una conexi√≥n con un servidor remoto, el nombre de dominio se resuelve primero en la direcci√≥n IP correspondiente, luego la direcci√≥n recibida se guarda en la memoria cach√© durante un tiempo para acelerar las conexiones posteriores.  Adem√°s, para ahorrar recursos, a menudo la conexi√≥n no se cierra despu√©s de cada solicitud, sino que se mantiene abierta durante mucho tiempo. <br><br>  Imagine que el sistema que estamos desarrollando deber√≠a funcionar normalmente sin forzar un reinicio si el servidor con el que interact√∫a ha cambiado a una direcci√≥n IP diferente.  Por ejemplo, si cambia a otro centro de datos debido a una falla en el actual.  Incluso si se interrumpe una conexi√≥n permanente debido a una falla en el primer centro de datos (que tambi√©n puede suceder r√°pidamente), la cach√© DNS no permitir√° que nuestro sistema responda r√°pidamente a dicho cambio.  Lo mismo es cierto para las llamadas a la direcci√≥n donde se realiza el equilibrio de carga a trav√©s de DNS round-robin. <br><br>  En el caso de un marco .NET "normal", este comportamiento se puede controlar a trav√©s de ServicePointManager y ServicePoint (todos los par√°metros enumerados a continuaci√≥n toman valores en milisegundos): <br><br><ul><li>  ServicePointManager.DnsRefreshTimeout: indica cu√°nto tiempo se almacenar√° en cach√© la direcci√≥n IP recibida para cada nombre de dominio; el valor predeterminado es 2 minutos (120000). </li><li>  ServicePoint.ConnectionLeaseTimeout: indica durante cu√°nto tiempo se puede mantener abierta la conexi√≥n.  Por defecto, no hay l√≠mite de tiempo para las conexiones; cualquier conexi√≥n puede mantenerse durante un tiempo arbitrariamente largo, ya que este par√°metro es -1.  Establecerlo en 0 har√° que cada conexi√≥n se cierre inmediatamente despu√©s de que se complete la solicitud. </li><li>  ServicePoint.MaxIdleTime: indica despu√©s de qu√© tiempo de inactividad se cerrar√° la conexi√≥n.  Inacci√≥n significa que no hay transferencia de datos a trav√©s de la conexi√≥n.  Por defecto, el valor de este par√°metro es de 100 segundos (100000). </li></ul><br>  Ahora, para mejorar la comprensi√≥n de estos par√°metros, los combinaremos todos en un solo escenario.  Suponga que nadie cambi√≥ DnsRefreshTimeout y MaxIdleTime y son 120 y 100 segundos respectivamente.  Con esto, ConnectionLeaseTimeout se estableci√≥ en 60 segundos.  La aplicaci√≥n establece solo una conexi√≥n, a trav√©s de la cual env√≠a solicitudes cada 10 segundos. <br><br>  Con esta configuraci√≥n, la conexi√≥n se cerrar√° cada 60 segundos (ConnectionLeaseTimeout), aunque transfiera datos peri√≥dicamente.  El cierre y la recreaci√≥n se realizar√°n de tal manera que no interfieran con la ejecuci√≥n correcta de las solicitudes; si se agota el tiempo y en el momento en que la solicitud a√∫n se est√° ejecutando, la conexi√≥n se cerrar√° una vez que se complete la solicitud.  Cada vez que se recrea una conexi√≥n, la direcci√≥n IP correspondiente se tomar√° primero del cach√©, y solo si su resoluci√≥n ha expirado (120 segundos), el sistema enviar√° una solicitud al servidor DNS. <br><br>  El par√°metro MaxIdleTime no jugar√° un papel en este escenario, ya que la conexi√≥n no ha estado inactiva durante m√°s de 10 segundos. <br><br>  La relaci√≥n √≥ptima de estos par√°metros depende en gran medida de la situaci√≥n espec√≠fica y los requisitos no funcionales: <br><br><ul><li>  Si no tiene la intenci√≥n de cambiar de forma transparente las direcciones IP detr√°s del nombre de dominio al que accede su aplicaci√≥n, y al mismo tiempo necesita minimizar el costo de las conexiones de red, entonces la configuraci√≥n predeterminada parece una buena opci√≥n. </li><li>  Si es necesario cambiar entre direcciones IP en caso de fallas, puede establecer DnsRefreshTimeout en 0 y ConnectionLeaseTimeout en el valor no negativo que m√°s le convenga.  Cu√°l depende espec√≠ficamente de qu√© tan r√°pido necesita cambiar a otra IP.  Obviamente, desea tener la respuesta m√°s r√°pida posible a la falla, pero aqu√≠ necesita encontrar el valor √≥ptimo, que, por un lado, proporciona un tiempo de conmutaci√≥n aceptable, por otro lado, no degrada el rendimiento del sistema y el tiempo de respuesta por una reconexi√≥n demasiado frecuente. <br></li><li>  Si necesita la reacci√≥n m√°s r√°pida posible para cambiar la direcci√≥n IP, por ejemplo, como en el caso del equilibrio a trav√©s de DNS round-robin, puede intentar establecer DnsRefreshTimeout y ConnectionLeaseTimeout en 0, pero esto ser√° extremadamente derrochador: para cada solicitud, el servidor DNS se sondear√° primero, despu√©s de lo cual La conexi√≥n al nodo de destino se restablecer√°. <br></li><li>  Puede haber situaciones en las que establecer ConnectionLeaseTimeout en 0 con un DnsRefreshTimeout distinto de cero puede ser √∫til, pero no puedo encontrar una secuencia de comandos adecuada de inmediato.  L√≥gicamente, esto significar√° que para cada solicitud, las conexiones se crear√°n de nuevo, pero las direcciones IP se tomar√°n de la memoria cach√© siempre que sea posible. </li></ul><br>  El siguiente es un ejemplo de c√≥digo que puede usarse para observar el comportamiento de los par√°metros descritos anteriormente: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); ServicePointManager.DnsRefreshTimeout = <span class="hljs-number"><span class="hljs-number">120000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.MaxIdleTime = <span class="hljs-number"><span class="hljs-number">100000</span></span>; habrServicePoint.ConnectionLeaseTimeout = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { client.GetAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>); }</code> </pre><br>  <i>Mientras se ejecuta el programa de prueba, puede ejecutar netstat a trav√©s de PowerShell en un bucle para monitorear las conexiones que establece.</i> <br><br>  Inmediatamente se debe decir c√≥mo administrar los par√°metros descritos en .NET Core.  La configuraci√≥n de ServicePointManager, como en el caso de ConnectionLimit, no funcionar√°.  Core tiene un tipo especial de controlador HTTP que implementa dos de los tres par√°metros descritos anteriormente: SocketsHttpHandler: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketsHttpHandler(); handler.PooledConnectionLifetime = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">60</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ConnectionLeaseTimeout handler.PooledConnectionIdleTimeout = TimeSpan.FromSeconds(100); // MaxIdleTime var client = new HttpClient(handler);</span></span></code> </pre><br>  No hay ning√∫n par√°metro que controle el tiempo de almacenamiento en cach√© de los registros DNS en .NET Core.  Los casos de prueba muestran que el almacenamiento en cach√© no funciona: cuando se crea una nueva conexi√≥n DNS, la resoluci√≥n se realiza nuevamente, por lo que para el funcionamiento normal en condiciones en que el nombre de dominio solicitado puede cambiar entre diferentes direcciones IP, simplemente configure PooledConnectionLifetime en el valor deseado. <br><br>  Adem√°s de todo, hay que decir que los desarrolladores de Microsoft no pudieron pasar desapercibidos todos estos problemas y, por lo tanto, a partir de .NET Core 2.1, apareci√≥ una f√°brica de clientes HTTP que permite resolver algunos de ellos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-">https://docs.microsoft.com/en- us / dotnet / standard / microservices-architecture / implement-resilient-applications / use-httpclientfactory-to-implement-resilient-http-request</a> .  Adem√°s, adem√°s de administrar la vida √∫til de las conexiones, el nuevo componente brinda oportunidades para crear clientes mecanografiados, as√≠ como algunas otras cosas √∫tiles.  En este art√≠culo y sus enlaces, hay suficiente informaci√≥n y ejemplos sobre el uso de HttpClientFactory, por lo tanto, no considerar√© los detalles asociados con √©l en este art√≠culo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424873/">https://habr.com/ru/post/es424873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424861/index.html">Una serpiente en el buz√≥n y qu√© hace F #</a></li>
<li><a href="../es424865/index.html">Part√≠culas de dise√±o elemental descubiertas</a></li>
<li><a href="../es424867/index.html">Desarrollo de hex√°podos desde cero (parte 1) - dise√±o</a></li>
<li><a href="../es424869/index.html">C√≥mo la nueva caracter√≠stica de iOS 12 me record√≥ que es hora de sanar</a></li>
<li><a href="../es424871/index.html">Elon Musk y Tesla resuelven un litigio con la Comisi√≥n de Bolsa y Valores de EE. UU.</a></li>
<li><a href="../es424877/index.html">Sistema de enfriamiento de frenos fluidos</a></li>
<li><a href="../es424879/index.html">Disponibilidad de interfaz Conferencia de Yandex</a></li>
<li><a href="../es424881/index.html">Newtoo: ¬øest√° desarrollando un motor de navegador completo desde cero en 2018?</a></li>
<li><a href="../es424887/index.html">Sobre lo que Lida no dice nada: el comienzo de la carrera de un desarrollador. Principios o c√≥mo convertirse en un Middl</a></li>
<li><a href="../es424889/index.html">Mirando dentro del coprocesador Intel 8087</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>