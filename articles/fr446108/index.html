<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèº üßú üî´ Blocs de construction d'applications distribu√©es. Premi√®re approche üîÉ üßîüèø üìÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le dernier article, nous avons examin√© les fondements th√©oriques de l'architecture r√©active. Il est temps de parler des flux de donn√©es, des moye...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blocs de construction d'applications distribu√©es. Premi√®re approche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446108/"><p><img src="https://habrastorage.org/webt/id/fv/eo/idfveo9cmr8y2uyidusx29gwvtc.jpeg"></p><br><p> Dans le dernier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article,</a> nous avons examin√© les fondements th√©oriques de l'architecture r√©active.  Il est temps de parler des flux de donn√©es, des moyens de mettre en ≈ìuvre des syst√®mes r√©actifs Erlang / Elixir et des mod√®les de messagerie en eux: </p><br><ul><li>  Demander une r√©ponse </li><li>  R√©ponse fragment√©e √† la demande </li><li>  R√©ponse avec demande </li><li>  Publier-s'abonner </li><li>  Publication-abonnement invers√© </li><li>  R√©partition des t√¢ches <a name="habracut"></a></li></ul><br><h2 id="soa-msa-i-obmen-soobscheniyami">  SOA, MSA et messagerie </h2><br><p>  SOA, MSA - architectures syst√®me qui d√©finissent les r√®gles de construction des syst√®mes, tandis que la messagerie fournit des primitives pour leur mise en ≈ìuvre. </p><br><p>  Je ne veux pas promouvoir telle ou telle architecture des syst√®mes de construction.  Je suis pour l'utilisation des pratiques les plus efficaces et utiles pour un projet et une entreprise particuliers.  Quel que soit le paradigme que nous choisissons, il est pr√©f√©rable de cr√©er des blocs syst√®me avec un ≈ìil sur la voie Unix: des composants avec une connectivit√© minimale qui sont responsables d'entit√©s individuelles.  Les m√©thodes API effectuent les actions les plus simples avec les entit√©s. </p><br><p>  Messagerie - comme son nom l'indique, est un courtier de messages.  Son objectif principal est de recevoir et de transmettre des messages.  Il est responsable des interfaces d'envoi des informations, de la formation des canaux logiques de transmission des informations au sein du syst√®me, du routage et de l'√©quilibrage, ainsi que du traitement des d√©faillances au niveau du syst√®me. <br>  La messagerie en cours de d√©veloppement n'essaie pas de concurrencer ou de remplacer rabbitmq.  Ses principales caract√©ristiques: </p><br><ul><li>  Distribution <br>  Des points d'√©change peuvent √™tre cr√©√©s sur tous les n≈ìuds du cluster, le plus pr√®s possible du code qui les utilise. </li><li>  Simplicit√©. <br>  Concentrez-vous sur la minimisation du code standard et de l'utilisabilit√©. </li><li>  La meilleure performance. <br>  Nous n'essayons pas de r√©p√©ter la fonctionnalit√© de rabbitmq, mais seulement de mettre en √©vidence la couche architecturale et de transport, qui est aussi simple que possible dans OTP, minimisant les co√ªts. </li><li>  Souplesse. <br>  Chaque service peut combiner de nombreux mod√®les d'√©change. </li><li>  Tol√©rance aux pannes inh√©rente √† la conception. </li><li>  √âvolutivit√©. <br>  La messagerie grandit avec l'application.  √Ä mesure que la charge augmente, vous pouvez d√©placer les points d'√©change vers des machines individuelles. </li></ul><br><p>  <em>Remarque.</em>  Du point de vue de l'organisation du code, les m√©ta-projets sont bien adapt√©s aux syst√®mes complexes avec Erlang / Elixir.  Tout le code de projet est dans un r√©f√©rentiel - un projet cadre.  Dans le m√™me temps, les microservices sont aussi isol√©s que possible et effectuent des op√©rations simples qui sont responsables d'une entit√© distincte.  Avec cette approche, il est facile de prendre en charge l'API de l'ensemble du syst√®me, il suffit d'apporter des modifications, il est pratique d'√©crire des unit√©s et des tests d'int√©gration. </p><br><p>  Les composants du syst√®me interagissent directement ou via un courtier.  Du point de vue de la messagerie, chaque service comporte plusieurs phases de vie: </p><br><ul><li>  Initialisation du service. <br>  √Ä ce stade, la configuration et le lancement du processus d'ex√©cution du service et des d√©pendances ont lieu. </li><li>  Cr√©ation d'un point d'√©change. <br>  Le service peut utiliser le point d'√©change statique sp√©cifi√© dans la configuration du n≈ìud ou cr√©er des points d'√©change de mani√®re dynamique. </li><li>  Inscription au service. <br>  Pour que le service puisse r√©pondre aux demandes, il doit √™tre enregistr√© au point d'√©change. </li><li>  Fonctionnement normal. <br>  Le service produit un travail utile. </li><li>  Arr√™tez. <br>  Il existe 2 types d'arr√™t: r√©gulier et d'urgence.  Avec un service r√©gulier, il se d√©connecte du point d'√©change et s'arr√™te.  En cas d'urgence, la messagerie ex√©cute l'un des sc√©narios de basculement. </li></ul><br><p>  Cela semble assez compliqu√©, mais tout n'est pas si effrayant dans le code.  Des exemples de code avec commentaires seront donn√©s dans l'analyse des mod√®les un peu plus tard. </p><br><h2 id="exchanges">  √âchanges </h2><br><p>  Un point d'√©change est un processus de messagerie qui impl√©mente la logique d'interaction avec des composants dans un mod√®le de messagerie.  Dans tous les exemples ci-dessous, les composants interagissent via des points d'√©change, dont la combinaison forme une messagerie. </p><br><h2 id="message-exchange-patterns-meps">  Mod√®les d'√©change de messages (MPE) </h2><br><p>  √Ä l'√©chelle mondiale, les mod√®les de partage peuvent √™tre divis√©s en deux sens et unidirectionnel.  Les premiers impliquent une r√©ponse au message re√ßu, les seconds non.  Un exemple classique d'un mod√®le bidirectionnel dans une architecture client-serveur est le mod√®le de demande-r√©ponse.  Consid√©rez le mod√®le et ses modifications. </p><br><h3 id="requestresponse-ili-rpc">  Demande - r√©ponse ou RPC </h3><br><p>  RPC est utilis√© lorsque nous devons obtenir une r√©ponse d'un autre processus.  Ce processus peut √™tre lanc√© sur le m√™me site ou situ√© sur un continent diff√©rent.  Vous trouverez ci-dessous un sch√©ma de l'interaction du client et du serveur via la messagerie. </p><br><p><img src="https://habrastorage.org/webt/pz/x9/hx/pzx9hxfkk0szgfugtdbpc1hwrak.png"></p><br><p>  La messagerie √©tant totalement asynchrone, pour le client l'√©change est divis√© en 2 phases: </p><br><ol><li><p>  Demande de soumission </p><br><pre><code class="erlang hljs">messaging:request(Exchange, ResponseMatchingTag, RequestDefinition, HandlerProcess).</code> </pre> <br><p>  <em>Exchange</em> - un nom unique pour le point d'√©change <br>  <em>ResponseMatchingTag</em> - L'√©tiquette locale pour g√©rer la r√©ponse.  Par exemple, dans le cas d'envoi de plusieurs demandes identiques appartenant √† diff√©rents utilisateurs. <br>  <em>RequestDefinition</em> - corps de la demande <br>  <em>HandlerProcess</em> - <em>Gestionnaire</em> PID.  Ce processus recevra une r√©ponse du serveur. </p><br></li><li><p>  Traitement des r√©ponses </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = EXCHANGE, tag = ResponseMatchingTag,message = ResponsePayload}, State)</span></span></span></span></code> </pre> <br><p>  <em>ResponsePayload</em> - r√©ponse du serveur. </p><br></li></ol><br><p>  Pour le serveur, le processus comprend √©galement 2 phases: </p><br><ol><li>  Initialisation du point d'√©change </li><li>  Traitement des demandes entrantes </li></ol><br><p>  Illustrons ce mod√®le avec du code.  Supposons que nous ayons besoin d'impl√©menter un service simple qui fournit la seule m√©thode d'heure exacte. </p><br><h4 id="kod-servera">  Code serveur </h4><br><p>  Retirez la d√©finition de l'API de service dans api.hrl: </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%% ===================================================== %% entities %% ===================================================== -record(time, { unixtime :: non_neg_integer(), datetime :: binary() }). -record(time_error, { code :: non_neg_integer(), error :: term() }). %% ===================================================== %% methods %% ===================================================== -record(time_req, { opts :: term() }). -record(time_resp, { result :: #time{} | #time_error{} }).</span></span></code> </pre> <br><p>  D√©finissez un contr√¥leur de service dans time_controller.erl </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%%      .     gen_server    . %%  gen_server init(Args) -&gt; %%     messaging:monitor_exchange(req_resp, ?EXCHANGE, default, self()) {ok, #{}}. %%       .    ,      . handle_info(#exchange_die{exchange = ?EXCHANGE}, State) -&gt; erlang:send(self(), monitor_exchange), {noreply, State}; %%  API handle_info(#time_req{opts = _Opts}, State) -&gt; messaging:response_once(Client, #time_resp{ result = #time{ unixtime = time_utils:unixtime(now()), datetime = time_utils:iso8601_fmt(now())} }); {noreply, State}; %%   gen_server terminate(_Reason, _State) -&gt; messaging:demonitor_exchange(req_resp, ?EXCHANGE, default, self()), ok.</span></span></code> </pre> <br><h4 id="kod-klienta">  Code client </h4><br><p>  Pour envoyer une demande √† un service, vous pouvez appeler l'API de demande de messagerie n'importe o√π dans le client: </p><br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> messaging:request(?EXCHANGE, tag, #time_req{opts = #{}}, self()) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; ok; _ -&gt; <span class="hljs-comment"><span class="hljs-comment">%% repeat or fail logic end</span></span></code> </pre> <br><p>  Dans un syst√®me distribu√©, la configuration des composants peut √™tre tr√®s diff√©rente et au moment de la demande, la messagerie peut ne pas encore d√©marrer, ou le contr√¥leur de service ne sera pas pr√™t √† r√©pondre √† la demande.  Par cons√©quent, nous devons v√©rifier la r√©ponse de la messagerie et g√©rer le cas d'√©chec. <br>  Apr√®s l'envoi r√©ussi, le client recevra une r√©ponse ou une erreur du service. <br>  G√©rez les deux cas dans handle_info: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time{unixtime = Utime}}}, State)</span></span></span><span class="hljs-function"> -&gt;</span></span> ?debugVal(Utime), {noreply, State}; handle_info(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time_error{code = ErrorCode}}}, State) -&gt; ?debugVal({error, ErrorCode}), {noreply, State};</code> </pre> <br><h3 id="request-chunked-response">  R√©ponse fragment√©e √† la demande </h3><br><p>  Mieux vaut ne pas autoriser la transmission de gros messages.  La r√©activit√© et le fonctionnement stable de l'ensemble du syst√®me en d√©pendent.  Si la r√©ponse √† la demande prend beaucoup de m√©moire, la d√©composition en plusieurs parties est obligatoire. </p><br><p><img src="https://habrastorage.org/webt/dj/zv/6_/djzv6_lvreaj-iieegxoqemx-vi.png"></p><br><p>  Je vais donner quelques exemples de tels cas: </p><br><ul><li>  Les composants √©changent des donn√©es binaires, telles que des fichiers.  La d√©composition de la r√©ponse en petites parties permet de travailler efficacement avec des fichiers de toute taille et de ne pas rattraper les d√©bordements de m√©moire. </li><li>  Inscriptions.  Par exemple, nous devons s√©lectionner tous les enregistrements d'une √©norme table dans la base de donn√©es et les transf√©rer vers un autre composant. </li></ul><br><p>  J'appelle ces r√©ponses une locomotive.  Dans tous les cas, 1024 messages de 1 Mo sont meilleurs qu'un seul message de 1 Go. </p><br><p>  Dans le cluster Erlang, nous obtenons un gain suppl√©mentaire - r√©duisant la charge sur le point d'√©change et le r√©seau, car les r√©ponses sont imm√©diatement envoy√©es au destinataire, contournant le point d'√©change. </p><br><h3 id="response-with-request">  R√©ponse avec demande </h3><br><p>  Il s'agit d'une modification assez rare du mod√®le RPC pour la cr√©ation de syst√®mes interactifs. </p><br><p><img src="https://habrastorage.org/webt/dg/t5/kt/dgt5ktnzqdttmiqv8jne7h6lneg.png"></p><br><h3 id="publish-subscribe-data-distribution-tree">  Publier-s'abonner (arbre de distribution des donn√©es) </h3><br><p>  Les syst√®mes orient√©s √©v√©nements fournissent des donn√©es aux consommateurs lorsque les donn√©es sont disponibles.  Ainsi, les syst√®mes sont plus enclins √† pousser des mod√®les qu'√† tirer ou √† interroger.  Cette fonctionnalit√© vous permet de ne pas gaspiller des ressources en interrogeant et en attendant constamment des donn√©es. <br>  La figure montre le processus de distribution d'un message aux consommateurs abonn√©s √† un sujet sp√©cifique. </p><br><p><img src="https://habrastorage.org/webt/yg/sp/lx/ygsplxxerjwdvci5gk3hhdn2jay.png"></p><br><p>  Des exemples classiques de l'utilisation de ce mod√®le sont la distribution de l'√âtat: le monde du jeu dans les jeux informatiques, les donn√©es du march√© sur les √©changes, les informations utiles dans les flux de donn√©es. </p><br><p>  Consid√©rez le code d'abonn√©: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Args)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%%   ,  = key messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {ok, #{}}. handle_info(#exchange_die{exchange = ?SUBSCRIPTION}, State) -&gt; %%    ,    messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {noreply, State}; %%    handle_info(#'$msg'{exchange = ?SUBSCRIPTION, message = Msg}, State) -&gt; ?debugVal(Msg), {noreply, State}; %%    -     terminate(_Reason, _State) -&gt; messaging:unsubscribe(?SUBSCRIPTION, key, tag, self()), ok.</span></span></code> </pre> <br><p>  La source peut appeler la fonction de post-publication √† tout endroit appropri√©: </p><br><pre> <code class="erlang hljs">messaging:publish_message(Exchange, Key, Message).</code> </pre> <br><p>  <em>Exchange</em> - le nom du point d'√©change, <br>  <em>Cl√©</em> - cl√© de routage <br>  <em>Message</em> - charge utile </p><br><h2 id="inverted-publish-subscribe">  Publication-abonnement invers√© </h2><br><p><img src="https://habrastorage.org/webt/5h/qz/uq/5hqzuqda_rzuvaphv2q3nqjnvcg.png"></p><br><p>  En d√©veloppant pub-sub, vous pouvez obtenir un mod√®le pratique pour la journalisation.  L'ensemble des sources et des consommateurs peut √™tre compl√®tement diff√©rent.  La figure montre un cas avec un consommateur et plusieurs sources. </p><br><h2 id="task-distribution-pattern">  Mod√®le de distribution des t√¢ches </h2><br><p>  Dans presque tous les projets, des t√¢ches de traitement diff√©r√© surviennent, telles que la g√©n√©ration de rapports, l'envoi de notifications, la r√©ception de donn√©es de syst√®mes tiers.  Le d√©bit d'un syst√®me qui effectue ces t√¢ches est facilement √©volutif en ajoutant des gestionnaires.  Il ne nous reste plus qu'√† former un cluster de gestionnaires et √† r√©partir uniform√©ment les t√¢ches entre eux. </p><br><p>  Consid√©rez les situations qui surviennent avec l'exemple de 3 gestionnaires.  M√™me au stade de la r√©partition des t√¢ches, la question de l'√©quit√© de la r√©partition et du d√©bordement des processeurs se pose.  La distribution √† tour de r√¥le sera responsable de la justice, et afin d'√©viter une situation de d√©bordement de gestionnaires, nous introduisons la restriction <em>prefetch_limit</em> .  Dans les modes transitoires, <em>prefetch_limit</em> emp√™chera un gestionnaire de recevoir toutes les t√¢ches. </p><br><p>  La messagerie g√®re les files d'attente et la priorit√© de traitement.  Les gestionnaires re√ßoivent des t√¢ches √† mesure qu'elles deviennent disponibles.  La t√¢che peut r√©ussir ou √©chouer: </p><br><ul><li>  <code>messaging:ack(Tack)</code> - appel√© en cas de succ√®s de traitement des messages </li><li>  <code>messaging:nack(Tack)</code> - appel√© dans toutes les situations d'urgence.  Apr√®s le retour de la t√¢che, la messagerie la transf√©rera √† un autre gestionnaire. </li></ul><br><p><img src="https://habrastorage.org/webt/w6/yi/hc/w6yihc6yyunvigevthjggejkwjq.png"></p><br><p>  Supposons qu'une d√©faillance complexe se soit produite lors du traitement de trois t√¢ches: le gestionnaire 1, apr√®s avoir re√ßu la t√¢che, s'est √©cras√© avant de pouvoir communiquer avec le point d'√©change.  Dans ce cas, le point d'√©change apr√®s l'expiration du d√©lai d'expiration de l'acquittement transf√©rera le travail √† un autre gestionnaire.  Le gestionnaire 3, pour une raison quelconque, a abandonn√© la t√¢che et l'a envoy√©e nack. Par cons√©quent, la t√¢che a √©galement √©t√© transmise √† un autre gestionnaire qui l'a termin√©e avec succ√®s. </p><br><h2 id="predvaritelnyy-itog">  R√©sultat pr√©liminaire </h2><br><p>  Nous avons d√©mont√© les blocs de construction de base des syst√®mes distribu√©s et avons acquis une compr√©hension de base de leur application dans Erlang / Elixir. </p><br><p>  En combinant des mod√®les de base, vous pouvez cr√©er des paradigmes complexes pour r√©soudre les probl√®mes √©mergents. </p><br><p>  Dans la derni√®re partie du cycle, nous examinerons les probl√®mes g√©n√©raux d'organisation des services, de routage et d'√©quilibrage, et nous parlerons √©galement du c√¥t√© pratique de l'√©volutivit√© et de la tol√©rance aux pannes des syst√®mes. </p><br><p>  La fin de la deuxi√®me partie. </p><br><p>  Photo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Marius Christensen</a> <br>  Illustrations pr√©par√©es par websequencediagrams.com </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446108/">https://habr.com/ru/post/fr446108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446096/index.html">Le livre ¬´TasteVill: comment faire une r√©volution dans le commerce de d√©tail, tout faire mal¬ª</a></li>
<li><a href="../fr446098/index.html">Centre de contr√¥le de vol sovi√©tique de l'√©poque de "Vostok" et "Sunrise"</a></li>
<li><a href="../fr446100/index.html">Cr√©ez automatiquement des fichiers de localisation Android et iOS √† partir d'une feuille de calcul Excel</a></li>
<li><a href="../fr446104/index.html">Le paradoxe Python</a></li>
<li><a href="../fr446106/index.html">Oleg Shelaev √† propos de GraalVM sur jug.msk.ru</a></li>
<li><a href="../fr446110/index.html">WavesKit - Framework de cha√Æne de blocs PHP Waves</a></li>
<li><a href="../fr446112/index.html">WavesKit - Framework PHP pour travailler avec Waves Platform</a></li>
<li><a href="../fr446114/index.html">Un modem de 50 ans: un regard int√©rieur</a></li>
<li><a href="../fr446116/index.html">Une s√©lection de livres sur la fa√ßon d'apprendre, de penser et de prendre des d√©cisions efficaces</a></li>
<li><a href="../fr446118/index.html">Open Rack v3: √† quoi s'attendre de la nouvelle norme d'architecture de rack de serveur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>