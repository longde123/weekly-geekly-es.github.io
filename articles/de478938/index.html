<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏾 👨🏾‍💻 🤖 Wir lernen Versprechen basierend auf der Ecmascript-Spezifikation. Bekanntschaft 👳 🌇 🎢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Beim Studium von JavaScript (und im Prinzip jeder anderen Technologie) stellen sich immer wieder verschiedene Fragen: „Warum funktioniert d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir lernen Versprechen basierend auf der Ecmascript-Spezifikation. Bekanntschaft</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478938/"><img src="https://habrastorage.org/webt/zo/be/at/zobeat0bkvnvgpgaxgkufwtm3li.png" alt="verspreche Einführung"><br><br><p>  Guten Tag.  Beim Studium von JavaScript (und im Prinzip jeder anderen Technologie) stellen sich immer wieder verschiedene Fragen: „Warum funktioniert das so und nicht anders?“ In diesem Moment ist es sehr wichtig, nicht nur die Antwort auf die Frage zu finden, sondern auch die erhaltene Erklärung eingebettet in ein einziges System bereits erworbenen Wissens.  Andernfalls müssen die verwaisten Informationen gespeichert oder vergessen werden. <br></p><br><p>  Gemeinsam etwas lernen hilft viel, um Antworten zu finden.  Wenn ein Schüler / Begleiter eine Frage stellt, wie der Satz zu verstehen ist - "... das Ergebnis des vorherigen Versprechens" versagt "im nächsten Versprechen in der Kette ..." denkt man unfreiwillig ... Das ist so eine seltsame Sache.  Aber man kann es nicht mehr besser sagen, ist es wirklich nicht klar?  Sie schauen in die sauberen, leicht naiven Augen des Begleiters und verstehen - Sie müssen etwas anderes sagen.  Es ist wünschenswert, dass Sie nicht einmal auswendig lernen müssen.  Nur neue Informationen passen organisch in existierende menschliche Gedanken. <br></p><br><p>  Ich werde nicht beschreiben, was wir versucht, gelesen, gesehen haben.  Infolgedessen haben wir uns für die ECMAScript-Spezifikation interessiert.  Wie man es liest und versteht, ist eine separate Konversation (vielleicht sogar ein separater Beitrag).  Aber die Art und Weise, wie Versprechen und ihr Verhalten dort beschrieben werden, hat uns zum ersten Mal ein ganzheitliches und logisch zusammenhängendes Verständnis für dieses Thema vermittelt.  Was ich mit dir teilen möchte. <br></p><a name="habracut"></a><br><p>  Dieser Artikel ist für Anfänger.  Versprechen in Bezug auf die ECMAScript-Spezifikation werden hier diskutiert.  Ich weiß, es klingt seltsam, aber wie es ist. <br></p><br><h2>  Das Versprechen Objekt: seine Philosophie, technische Präsentation, mögliche Zustände <br></h2><br><p>  Mir ist schon mehr als einmal aufgefallen, dass ein qualitativ hochwertiges Programmiertraining aus 2 Teilen bestehen sollte.  Dies ist ein philosophisches Verständnis der Idee und erst dann ihrer technischen Umsetzung.  Das heißt, die übliche menschliche Logik, an der sich der Schüler bei Entscheidungen orientiert, erleichtert das Verständnis der technischen Umsetzung dieser Entscheidung erheblich.  Deshalb beginnen wir mit dem, was ein Versprechen im Leben ist und in welcher Beziehung wir dazu stehen.  Und dann werden wir sehen, wie Beispiele für Versprechen in Code implementiert werden.  Betrachten Sie die folgenden Abbildungen (Abb. 1, 2, 3). <br></p><br><img src="https://habrastorage.org/webt/np/8l/ux/np8luxrdlenwq4o2lzikaludrlw.png" alt="Versprechen Zustand"><br>  <i>Abbildung 1. ([[PromiseState]] - als Ergebnis eines Versprechens)</i> <br><br><img src="https://habrastorage.org/webt/sj/xi/bq/sjxibq_vroug72q8bkdprh4rxik.png" alt="Versprechen Ergebnis"><br>  <i>fig 2. ([[PromiseResult]] - als Information in Bezug auf das Ergebnis eines erfüllten oder unerfüllten Versprechens)</i> <br><br><img src="https://habrastorage.org/webt/2e/zj/l_/2ezjl_fhehmml3yhfqjijcnerbw.png" alt="Versprich Reaktionen"><br>  <i>Abbildung 3. ([[[PromiseFulfillReactions]], [[PromiseRejectReactions]] - als Konsequenzen, die nach der Erfüllung oder Nichterfüllung eines Versprechens auftreten)</i> <br><br><p>  Wir sehen, dass das Konzept des Versprechens auf drei Säulen steht.  1) Wurde das Versprechen überhaupt erfüllt?  2) Welche zusätzlichen Informationen können wir extrahieren, nachdem wir ein Versprechen erfüllt oder abgelehnt haben?  3) Was sind die Konsequenzen, wenn unser Versprechen positiv oder negativ ist? <br></p><br><p>  Technisch gesehen ist ein Versprechen eine gewöhnliche Entität, die durch einen Datentyp wie ein Objekt ausgedrückt wird.  Diese Entität hat ein Namens- / Klassenversprechen.  Objekte aus dieser Klasse haben Promise.prototype in ihrer Prototypenkette.  Und diese Entität muss irgendwie mit all den „Informationen aus dem Leben“ verbunden sein, die wir oben untersucht haben.  Die ECMAScript-Spezifikation verspricht diese Informationen auch auf einer Ebene, die weniger abstrahiert als JavaScript selbst ist.  Zum Beispiel auf der Ebene von C ++.  Dementsprechend gibt es im Gegenstand des Versprechens einen Platz sowohl für den Status als auch für das Ergebnis und für die Konsequenzen des Versprechens.  Sehen Sie sich an, worin <a href="https://www.ecma-international.org/ecma-262/7.0/">das</a> Versprechen von <a href="https://www.ecma-international.org/ecma-262/7.0/">ECMAScript</a> besteht (Abbildung 4). <br></p><br><img src="https://habrastorage.org/webt/bj/m5/lh/bjm5lhtxstjywkkfe6jnjqaqaes.png" alt="Versprechen Felder"><br>  <i>Abbildung 4. (Interne Felder des Versprechungsobjekts gemäß der ECMAScript-Spezifikation)</i> <br><br><p>  Welche neuen Farben hat der Satz "Versprechen heißt nicht heiraten" in Bezug auf einen Programmierer gespielt?  1) PromiseState.  Jemand hat nicht geheiratet.  2) [[PromiseResult]].  Weil er nicht genug Geld für die Hochzeit hatte.  3) [[PromiseRejectReactions]].  Infolgedessen hatte er viel Freizeit, die er für die Selbstentwicklung verbrachte. 4) [[PromiseFulfillReactions]].  Warum braucht eine Person Plan B, wenn sie bereits Plan A gewählt hat? <br></p><br><p>  Ja, es gibt ein fünftes Feld [[PromiseIsHandled]].  Es ist nicht sehr wichtig für uns Menschen, und wir werden es in Zukunft nicht mehr bearbeiten.  Kurz: Dem Interpreter wird signalisiert, ob das Versprechen vom Programmierer abgelehnt wurde oder nicht.  Ist dies nicht der Fall, wird die Ablehnung eines unformatierten Versprechens von der JS-Engine als Fehler interpretiert.  Für Ungeduldige: Wenn der Programmierer die Promise.prototype.then () -Funktion nicht als zweiten Aufruf-Funktions-Handler für den Status des abgelehnten Versprechens aufgehängt hat, zeigt der Status des abgelehnten Versprechens des Objekts einen roten Fehler in der Entwicklerkonsole an. <br></p><br><p>  Haben Sie bemerkt, dass die Felder des Versprechungsobjekts in "[[" und "]]" eingeschlossen sind?  Dies unterstreicht, dass der JS-Programmierer keinen direkten Zugriff auf diese Informationen hat.  Nur über spezielle Tools / Befehle / API, z. B. den Befehl Promise.prototype.then ().  Wenn Sie den unwiderstehlichen Wunsch haben, „diese Küche“ direkt zu steuern, dann begrüßen Sie den Standardclub der EcmaScript-Spezifikation. <br></p><br><p>  Eine kurze Bemerkung am Ende dieses Unterkapitels.  Wenn im Leben in unserem Land Versprechungen teilweise erfüllt werden können, dann in EcmaScript - nicht.  Das heißt, wenn jemand versprochen hat, eine Million zu geben, und 950.000 gegeben hat, dann ist er im Leben vielleicht ein verlässlicher Partner, aber für JavaScript wird ein solcher Schuldner durch PromiseState auf die schwarze Liste gesetzt === "abgelehnt".  Ein Promise-Objekt ändert seinen Status eindeutig und nur einmal.  Wie dies technisch umgesetzt wird, ist etwas später. <br></p><br><h2>  Designer Promise, seine Philosophie.  Der Callback Function Executor ist wie der "Executor" eines Versprechens.  Interaktionsschema: Promise (Konstruktor) - Executor (Rückruf) - Promise (Objekt) </h2><br><p>  Wir haben also herausgefunden, dass Versprechen eine Entität ist, die technisch gesehen ein JS-Objekt mit speziellen verborgenen inneren Feldern ist, die wiederum eine philosophische Füllung mit der Bedeutung des Wortes „Versprechen“ bieten. <br></p><br><p>  Wenn ein Anfänger zum ersten Mal ein Versprechen erstellt, erwartet ihn das folgende Bild (Abb. 5). <br></p><br><img src="https://habrastorage.org/webt/m1/xg/3u/m1xg3uoxgytd1nd2x7pc_z9i93m.png" alt="falsches erstellen versprechen objekt"><br>  <i>Abbildung 5. (Das erste Mal, dass wir intuitiv ein Versprechungsobjekt erstellen.)</i> <br><br><p>  Was ist schief gelaufen und warum ist der Fehler eine Standardfrage.  Bei der Beantwortung ist es besser, wieder eine Analogie aus dem Leben zu bringen.  Zum Beispiel mögen nur wenige Menschen "leere Glockenspiele" um uns herum, die nur versprechen, aber nichts tun, um ihre Aussagen zu erfüllen (Politik zählt nicht).  Wir sind viel besser in den Menschen, die nach ihrem Versprechen einen Plan haben und sofort Maßnahmen ergreifen, um das versprochene Ergebnis zu erzielen. <br></p><br><p>  Die ECMAScript-Philosophie impliziert also, dass Sie, wenn Sie ein Versprechen erstellen, sofort angeben, wie Sie es erfüllen werden.  Der Programmierer muss seinen Aktionsplan in Form eines Funktionsparameters erstellen, den Sie an den Promise-Konstruktor übergeben.  Das nächste Experiment sieht so aus (Abb. 6). <br></p><br><img src="https://habrastorage.org/webt/xh/sk/h7/xhskh7cuzrn1jxavomenlnfzwu0.png" alt="Promise-Konstruktor verwendet Executor"><br>  <i>Abbildung 6. (Erstellen Sie ein Versprechen-Objekt und übergeben Sie die Executor-Funktion an den Versprechen-Konstruktor.)</i> <br><br><p>  Von der Überschrift bis zur Abbildung sehen wir, dass die Funktion (Promise-Konstruktorparameter) einen eigenen Namen hat - executor.  Ihre Aufgabe ist es, damit zu beginnen, das Versprechen zu erfüllen und es vorzugsweise zu einer Art logischen Schlussfolgerung zu bringen.  Und wenn der Programmierer Code in den Executor schreiben kann, wie kann der Programmierer JS dann signalisieren, dass alles - die Arbeit ist erledigt - Sie können die Ergebnisse des Versprechens sehen? <br></p><br><p>  Markierungen oder Signale, mit denen der Programmierer darüber informiert wird, dass das Versprechen erfüllt ist, werden automatisch an den Executor übergeben - a-Parameter in Form von Argumenten, die speziell von JavaScript erstellt wurden.  Diese Parameter können nach Belieben aufgerufen werden, aber am häufigsten werden Sie sie unter Namen wie res und rej finden.  In der ECMAScript-Spezifikation lautet ihr vollständiger Name Auflösungsfunktion und Zurückweisungsfunktion.  Diese Funktionsmarker haben ihre eigenen Eigenschaften, auf die wir später noch eingehen werden. <br></p><br><p>  Um die neuen Informationen zu verstehen, wird der Neuankömmling aufgefordert, die folgende Aussage eigenständig zu kodieren: „Ich verspreche, dass ich eine Zahl in eine andere aufteilen und eine Antwort geben kann, wenn nur der Teiler nicht Null ist.“  So würde der Code aussehen (Abb. 7). <br></p><br><img src="https://habrastorage.org/webt/uu/to/gj/uutogjuluy9r5xxvwo2hrrwnaaq.png" alt="Versprechen Aufgabe: Division durch Null"><br>  <i>Abbildung 7. (Lösung des Problems, 2 Zahlen durch Versprechen zu teilen)</i> <br><br><p>  Jetzt können Sie das Ergebnis analysieren.  Wir sehen, dass die Browserkonsole das Promis-Objekt zum zweiten Mal auf interessante Weise anzeigt.  Nämlich: 2 zusätzliche Felder sind in doppelten eckigen Klammern angegeben.  Sie können sicher eine Analogie zwischen [[PromiseState]] und [[PromiseStatus]] ziehen, erfüllt und aufgelöst, [[PromiseValue]] und [[PromiseResult]].  Ja, der Browser selbst versucht, dem Programmierer das Vorhandensein und den Wert der internen Felder des Versprechungsobjekts mitzuteilen.  Wir sehen auch das verbundene System des Versprechen-Objekts, die Executor-Funktion, die speziellen Funktions-Callback-Token res und rej. <br></p><br><p>  Damit sich der Student / Partner in diesem Material entspannter fühlt, wird ihm der folgende Code angeboten (Abb. 8).  Es ist notwendig, es zu analysieren und die folgenden Fragen zu beantworten. <br></p><br><img src="https://habrastorage.org/webt/zs/md/vv/zsmdvv05gwmpi-vyq5a-d5sorjq.png" alt="Versprechen Aufgabe: Division durch Null. Alternative Version"><br>  <i>Abbildung 8. (Variation der Lösung des Problems, 2 Zahlen durch Versprechen zu teilen)</i> <br><br><p>  Wird der Code funktionieren?  Wo ist hier die Executor-Funktion und wie heißt sie?  Entspricht der Name "wantToDivide" in diesem Code?  Was gibt die Bindefunktion nach sich selbst zurück?  Warum werden Argumente nur an zweiter und dritter Stelle an die Bindefunktion übergeben?  Wo sind die Sonderfunktionen Funktion auflösen und Funktion verwerfen verschwunden?  Wie sind die notwendigen Eingabenummern Nummer1 und Nummer2 in den „Versprechen-Erfüllungsplan“ eingeflossen?  Wie viele Elemente enthält das Argument Pseudo-Array?  Ist es möglich, aus dem Speicher wiederherzustellen, wie die Antwort in der Browserkonsole aussehen wird? <br></p><br><p>  Der Leser wird gebeten, über die Antworten auf die Fragen selbst nachzudenken.  Und auch <br>  im Code experimentieren.  Glücklicherweise ist der Code klein und die Idee der Aufgabe ist einfach.  Ja, es gibt Fragen zu Versprechen und allgemeinen Kenntnissen von JavaScript.  Überall warten wir auf Überraschungen, die uns daran hindern, uns zu entspannen.  Sobald dir alles klar ist, kannst du weitermachen. <br></p><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen / kopieren</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number1 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number2 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 2"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wantToDivide = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-string"><span class="hljs-string">"it is forbidden to divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>](result); }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(wantToDivide.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, number1, number2)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myPromise);</code> </pre> <br></div></div><br><h2>  Betrachten Sie die Argumente executor-a: Funktionen auflösen und ablehnen <br></h2><br><p>  Also haben wir einen Kaffee getrunken - wir ziehen weiter.  Betrachten wir die Sonderfunktionen Auflösungsfunktion und Zurückweisungsfunktion, die automatisch von JavaScript generiert werden, um das Versprechen des Objekts in den erfüllten oder zurückgewiesenen Zustand zu versetzen, der das Ende des Versprechens symbolisiert. <br></p><br><p>  Beginnen wir damit, sie einfach in der Entwicklerkonsole anzusehen (Abb. 9). <br></p><br><img src="https://habrastorage.org/webt/rz/ox/vj/rzoxvjvsvmt3962toiukmqtf9ye.png" alt="Forschungsauflösungsfunktion"><br>  <i>Abbildung 9. (Untersuchung der Funktion resolve function - res)</i> <br><br><p>  Wir sehen, dass die Auflösungsfunktion eine Funktion ist, die ein Argument akzeptiert (Eigenschaftslänge === 1).  Und sein Prototyp ist Function.prototype. <br></p><br><p>  Ok, lass uns die Experimente fortsetzen.  Und was passiert, wenn wir den Link zur Auflösungs- / Zurückweisungsfunktion vom Executor zum externen Bereich entfernen?  Wird etwas kaputt gehen (Abb. 10)? <br></p><br><img src="https://habrastorage.org/webt/9z/2i/cf/9z2icfrmkwiwfeeerdphezhtjay.png" alt="externe kontrolle des versprechensgegenstandes"><br>  <i>Abbildung 10. (Wir übersetzen das myPromise-Versprechen in den erfüllten Zustand außerhalb des Versprechens.)</i> <br><br><p>  Nichts Außergewöhnliches.  Funktionen als Unterart eines Objekts in JavaScript werden als Referenz übergeben.  Alles hat wie erwartet geklappt.  Die Variable aus dem OuterRes-Abschluss hat einen Verweis auf unsere Auflösungsfunktion res erhalten.  Und wir haben seine Funktionalität genutzt, um das Versprechen außerhalb des Executors selbst in den erfüllten Zustand zu versetzen.  Das folgende leicht modifizierte Beispiel zeigt die gleiche Idee. Schauen Sie sich also den Code an und überlegen Sie, in welchem ​​Zustand und mit welchem ​​Wert myPromise1 und myPromise2 sein werden (Abb. 11).  Dann können Sie Ihre Vermutungen unter dem Spoiler überprüfen. </p><br><img src="https://habrastorage.org/webt/re/gf/ov/regfovwn9xc5-jwlkftz0ed8vgc.png" alt="Versprechen Aufgabe. Frage">  <i>Abbildung 11. (Die Aufgabe der Reflexion. In welchem ​​Zustand und mit welchem ​​Wert befinden sich die Versprechen myPromise1 und myPromise2 in der Entwicklerkonsole?)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort auf das Problem in Abbildung 11 (Abbildung 12).</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/iy/3x/k-/iy3xk-yuomgcgev4ddftqcffnvm.png" alt="Versprechen Aufgabe. Antwort"><br>  <i>Abbildung 12. (Die Antwort auf das Problem in Abbildung 11)</i> <br></div></div><br><p>  Und jetzt können Sie über eine interessante Frage nachdenken.  Aber woher weiß die Auflösungs- / Zurückweisungsfunktion immer genau, welches Versprechen in den erforderlichen Zustand zu übersetzen ist?  Wir wenden uns dem <a href="https://www.ecma-international.org/ecma-262/7.0/">Algorithmus in der Spezifikation zu</a> , der beschreibt, wie diese Funktionen erstellt werden (Abb. 13). <br></p><br><img src="https://habrastorage.org/webt/4n/gq/k-/4ngqk-fikg8ddjo6uhe00_rhkci.png" alt="Erstellen Sie auflösende Funktionen"><br>  <i>Abbildung 13. (Funktionen zum Erstellen von Auflösungsfunktionen für ein bestimmtes Versprechungsobjekt)</i> <br><br><p>  Wichtige Punkte zu beachten: <br></p><br><ul><li>  Zum Zeitpunkt der Erstellung der Auflösungs- / Zurückweisungsfunktionen sind sie fest mit dem einzigen Versprechungsobjekt verbunden, das diesem entspricht <br></li><li>  Die Auflösungs- / Zurückweisungsfunktionen als Objektdatentyp haben ihre eigenen versteckten Felder [[Promise]] und [[AlreadyResolved]], die jedem die vertraute intuitive Logik bieten, dass a) - Auflösungsfunktionen selbst das Versprechungsobjekt in den erforderlichen Zustand übersetzen;  und die Tatsache, dass b) ein Versprechen nicht in einen anderen Staat übertragen werden kann, wenn mindestens einmal eine Abwicklungs- oder Zurückweisungsfunktion aufgerufen wurde.  Dieser Algorithmus kann durch die folgende Abbildung dargestellt werden (Abb. 14). <br><br><img src="https://habrastorage.org/webt/0p/wt/1d/0pwt1dmqxhzhq0uuat_zljihrhc.png" alt="Funktionen lösen und Objekt versprechen"><br>  <i>Abbildung 14. (Versteckte Funktionsfelder der Auflösungsfunktion und der Zurückweisungsfunktion)</i> <br><br><p>  Algorithmen, die diese Informationen aus ausgeblendeten Feldern verwenden, werden jetzt nicht berücksichtigt, da sie ausführlicher und komplexer sind.  Wir müssen uns sowohl theoretisch als auch moralisch auf sie vorbereiten.  Im Moment kann ich nur Ihren Gedanken bestätigen: „Wow, wie einfach es sich herausstellt.  Wahrscheinlich wird bei jeder Auflösung / Auflösung des Versprechens des Objekts das "Objekt" -Flag {[[Wert]]: false} überprüft.  Und wenn es auf wahr gesetzt ist, stoppen wir den Prozess der Übersetzung des Versprechens in einen anderen Zustand mit einer einfachen Rückkehr. "  Ja, genau das passiert.  Es scheint, dass Sie die folgende Frage ohne Probleme richtig beantworten können.  Was ist das Ergebnis in der Entwicklerkonsole (Abb. 15)? <br></p><br><img src="https://habrastorage.org/webt/p6/1l/co/p61lcoillhsvjme0-hotfyacsoi.png" alt="Expertise bei der Verknüpfung von Lösungsfunktionen und Versprechensobjekt"><br>  <i>Abbildung 15. (Ein Experiment, das die Beziehung zwischen Auflösungs- und Zurückweisungsfunktionen für ein bestimmtes Versprechungsobjekt zeigt.)</i> <br><br><h2>  Algorithmus zum Erstellen eines Versprechungsobjekts gemäß der ECMAScript-Spezifikation </h2><br><p>  Betrachten Sie den bezaubernden Moment, in dem es in die Welt hineingeboren wird - ein vollwertiges <a href="https://www.ecma-international.org/ecma-262/7.0/">Versprechungsobjekt</a> (Abb. 16). <br></p><br><img src="https://habrastorage.org/webt/xm/yu/09/xmyu0944vrpk4ykurzgunwst0ji.png" alt="Versprechen Erstellung in Ecmascript"><br>  <i>Abbildung 16. (Algorithmus zum Erstellen eines Versprechungsobjekts aus der EcmaScript-Spezifikation)</i> <br><br><p>  Bei der Anzeige sollten keine komplizierten Fragen auftauchen: </p><p></p><ul><li>  Der Promise-Konstruktor muss im Konstruktormodus und nicht nur als Funktionsaufruf aufgerufen werden <br></li><li>  Der Promise-Konstruktor benötigt eine Executor-Funktion <br></li><li>  Erstellen Sie ein JavaScript-Objekt mit bestimmten ausgeblendeten Feldern <br></li><li>  Initialisieren Sie ausgeblendete Felder mit Anfangswerten <br></li><li>  Erstellen Sie die Auflösungs- und Zurückweisungsfunktionen, die dem Versprechungsobjekt zugeordnet sind <br></li><li>  wir rufen die executor-funktion zur ausführung auf und übergeben dort bereits generierte token auflösungsfunktion und ablehnungsfunktion als argumente <br></li><li>  Wenn während der Ausführung des Testaments ein Fehler aufgetreten ist, versetzen Sie unser Versprechungsobjekt in den Status "Abgelehnt" <br></li><li>  kehre zu der Variablen das geborene Versprechen-Versprechen-Objekt zurück. <br></li></ul><br><p>  Ich weiß nicht, ob es für Sie eine Entdeckung war, dass der Funktionsausführungsalgorithmus hier und jetzt im normalen synchronen Modus ausgeführt wird, noch bevor etwas in die Variable links vom Promise-Konstruktor geschrieben wird.  Aber zu gegebener Zeit wurde es für mich eine Offenbarung. <br></p><br><p>  Da wir das Thema Synchronität und Asynchronität angesprochen haben, finden Sie hier den folgenden Code, über den Sie nachdenken oder experimentieren können.  Frage: Wenn Sie sich eine Kreation des Programmierers Dima angesehen haben, können Sie dann beantworten, welche Bedeutung das unten codierte Spiel hat. <br></p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomInteger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">min, max</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(min + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * (max + <span class="hljs-number"><span class="hljs-number">1</span></span> - min)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> guessCubeNumber = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"Throw dice? Guess number?"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"throwing dice ... wait until it stop"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gottenNumberDice = randomInteger(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); gottenNumberDice === guessCubeNumber ? res(<span class="hljs-string"><span class="hljs-string">"you win!"</span></span>) : rej(<span class="hljs-string"><span class="hljs-string">`you loose. </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${gottenNumberDice}</span></span></span><span class="hljs-string"> points dropped on dice`</span></span>); }, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameState; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(game());</code> </pre><br><p>  Dies ist natürlich eine Emulation eines Würfelwurfs.  Kann der Benutzer die Zahl erraten, die herausgefallen ist oder nicht?  Sehen Sie, wie sich das organisch asynchrone setTimeout in den synchronen Executor integriert - in unserem Plan werfen Sie einen Würfel und finden Sie die Zahl heraus, die herausgefallen ist.  Wie kann man die Ergebnisse in der Entwicklerkonsole auf besondere Weise interpretieren (Abb. 17)? <br></p><br><p>  Wenn wir versuchen, das Versprechen anzuschauen, bis der Würfel stoppt (3000 ms werden im Code angezeigt), werden wir feststellen, dass das Versprechen immer noch wartet: Das Spiel ist noch nicht beendet, der Würfel ist noch nicht gestoppt, es ist keine Zahl herausgefallen.  Wenn wir versuchen, das Versprechungsobjekt nach dem Stoppen des Würfels zu betrachten, sehen wir sehr spezifische Informationen: ob der Benutzer gewonnen hat (die Zahl erraten hat) oder verloren hat und warum (welche Zahl fiel tatsächlich aus). <br></p><br><img src="https://habrastorage.org/webt/g4/oi/ba/g4oibarzyfjcrnzbvdqs9nqddqm.png" alt="Versprechen Spiel - Würfel werfen"><br>  <i>Abbildung 17. (Der Versprechungsstatus eines Objekts bei einer asynchronen Operation in der Executor-Funktion)</i> <br><br><p>  Wenn Sie an diesem Beispiel interessiert sind oder die Anzahl der umgedrehten Würfel erraten möchten, können Sie den Code kopieren und Ihre Experimente durchführen.  Wage es! <br></p><br><h2>  Versprechen Reaktion als Folge eines erfüllten Versprechens </h2><br><p>  Wie Sie in Abbildung 14 sehen können, werden die Konsequenzen des Auflösens / Auflösens eines Versprechens eines Objekts als "+ Reaktion" und "-Reaktion" gekennzeichnet.  Der offizielle Begriff für diese Wörter aus der ECMAScript-Spezifikation ist Versprechen Reaktion.  Es wird davon ausgegangen, dass dieses Thema in den folgenden Artikeln ausführlich behandelt wird.  Wir beschränken uns vorerst auf die allgemeine Vorstellung, was eine verheißungsvolle Reaktion ist, damit dieser Begriff richtig mit der philosophischen Bedeutung dieses Wortes und seiner technischen Ausführung in Verbindung gebracht werden kann. <br></p><br><p>  Wie wir uns erinnern, kann ein Versprechen Konsequenzen haben, aber nicht.  Was ist die konsequenz  Dies ist eine Aktion, die einige Zeit später stattfinden wird: nachdem das Versprechen erfüllt ist.  Und da dies eine Aktion ist, kann die Konsequenz durch eine normale JavaScript-Funktion ausgedrückt werden.  Einige Funktionen werden im Falle einer erfolgreichen Lösung des Versprechens ausgeführt (+ Reaktion);  andere Funktionen - für den Fall, dass das Versprechen in den abgelehnten Zustand übergeht (-reaktion).  Technisch werden diese Funktionen (Konsequenzen) in Argumenten übergeben, wenn die Promise.prototype.then () -Methode aufgerufen wird. <br></p><br><p>  Ein wichtiger Teil einer Versprechungsreaktion ist daher eine asynchrone Aktion, die irgendwann in der Zukunft ausgeführt wird.  Es gibt eine zweite wichtige Komponente der Versprechungsreaktion - dies ist die neu erstellte Versprechung, die nach Ausführung des Befehls Promise.prototype.then () zurückgegeben wird.  Dies liegt daran, dass die Konsequenzen andere Versprechen beeinflussen.  Zum Beispiel gibt es ein Versprechen, ein Auto zu kaufen, aber erst, wenn das Versprechen, einen bestimmten Geldbetrag zu verdienen, erfüllt ist.  Ein Versprechen wurde erfüllt - die Konsequenz hat sich herausgestellt - jetzt kann das zweite erfüllt werden. <br></p><br><p>  Tatsächlich bindet eine Versprechungsreaktion Versprechungen in einem bestimmten Zeitintervall aneinander.  Es ist wichtig zu beachten, dass die Reaktion automatisch verarbeitet wird.  Funktionsaufrufe - die Konsequenzen der Erfüllung eines Versprechens - werden von der JS-Engine und nicht vom Programmierer ausgeführt (Abb. 18).  Und da die Reaktionen eng mit den Versprechungsobjekten (Versprechungen) selbst zusammenhängen, ist es logisch anzunehmen, dass die Versprechungsreaktionsalgorithmen ihre internen Felder in ihrer Logik verwenden.  Und es ist besser, über all diese Nuancen Bescheid zu wissen, um die asynchrone Logik auf der Grundlage von Versprechungen bewusst steuern zu können. <br></p><br><img src="https://habrastorage.org/webt/zc/tk/ja/zctkjapwx_daq-shustmj4yc5fo.png" alt="verspreche Reaktion in then () Methode"><br>  <i>Abbildung 18. (Die Konsequenzen der Auflösung eines Versprechens werden von Rückruffunktionen in der then () -Methode aufgezeichnet. Der Rückruf wird von der JS-Engine automatisch asynchron aufgerufen.)</i> <br><br><h2>  Um es zusammenzufassen </h2><br><p>  1) Wir haben die Versprechen in JavaScript, ihre Philosophie und technische Ausführung kennengelernt.  All dies wird mithilfe spezieller interner Versprechungsfelder des Objekts implementiert: [[PromiseState]], [[PromiseValue]], [[PromiseFulFillReactions]], [[PromiseRejectReactions]]. <br></p><br><p>  2) Der Programmierer hat die Möglichkeit, sein Versprechen durch die Executor-Funktion zu erfüllen, die dem Promise-Konstruktor als Argument übergeben wird. <br></p><br><p>  3) Die Grenzen eines erfüllten oder unerfüllten Versprechens werden durch spezielle Markierungsfunktionen, Auflösungsfunktion und Zurückweisungsfunktion bestimmt, häufig im Code res und rej genannt.  Diese Funktionen werden automatisch von JavaScript erstellt und in Argumenten an den Executor übergeben. <br></p><br><p>  4) Auflösungsfunktion und Zurückweisungsfunktion haben immer ein Versprechungsobjekt sowie ein gemeinsames Spezialfeld {[[Wert]]: false}, das sicherstellt, dass die Versprechung nur einmal aufgelöst wird. <br></p><br><p>  5) [[PromiseFulFillReactions]] und [[PromiseRejectReactions]] sind interne Felder des Versprechungsobjekts, in denen die Konsequenzen der Auflösung der Versprechung gespeichert sind. Ein wichtiger Teil davon sind benutzerdefinierte asynchrone Funktionen, die mit der Versprechungsmethode Promise.prototype.then () des Objekts definiert wurden. <br></p><br><h2>  PS </h2><br><p>  Dieser Artikel wurde als Zusammenfassung der Videositzung der InSimpleWords-Gruppe erstellt.  Es gibt genug solche "Video-Lektionen" und es gibt immer noch Material für Notizen.  Eine andere Frage ist, ob es für Community-Mitglieder interessant sein wird, welchen Artikel über Versprechen hintereinander zu lesen.  Warten auf Ihre Kommentare. <br></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478938/">https://habr.com/ru/post/de478938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478924/index.html">Konfigurieren eines Heimrouters + NAS auf unRAID (Teil 2)</a></li>
<li><a href="../de478928/index.html">Python oder nicht Python</a></li>
<li><a href="../de478930/index.html">Wie man MySQL ohne Passwort benutzt (und Sicherheitsrisiken)</a></li>
<li><a href="../de478932/index.html">Docker für das Frontend. Teil 1. Warum?</a></li>
<li><a href="../de478934/index.html">Das nützlichste Python-Standardbibliotheksmodul, das jeder ständig vergisst</a></li>
<li><a href="../de478942/index.html">Tolles Porno-Experiment: Die Geschichte des Internets für Erwachsene</a></li>
<li><a href="../de478950/index.html">Das Ergebnis der Woche: Huawei passt sich den Sanktionen an, Putin unterzeichnet sensationelle Gesetze und blockiert in Russland ShutterStock</a></li>
<li><a href="../de478952/index.html">Ein Monat mit Onyx Boox Note Pro</a></li>
<li><a href="../de478954/index.html">RE: Angst und Abscheu vor IT</a></li>
<li><a href="../de478956/index.html">Einführung von 3CX V16 Update 4 Beta mit einem Chrome VoIP-Client und einer Videoanwendung für Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>