<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèæ üë®üèæ‚Äçüíª ü§ñ Wir lernen Versprechen basierend auf der Ecmascript-Spezifikation. Bekanntschaft üë≥ üåá üé¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Beim Studium von JavaScript (und im Prinzip jeder anderen Technologie) stellen sich immer wieder verschiedene Fragen: ‚ÄûWarum funktioniert d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir lernen Versprechen basierend auf der Ecmascript-Spezifikation. Bekanntschaft</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478938/"><img src="https://habrastorage.org/webt/zo/be/at/zobeat0bkvnvgpgaxgkufwtm3li.png" alt="verspreche Einf√ºhrung"><br><br><p>  Guten Tag.  Beim Studium von JavaScript (und im Prinzip jeder anderen Technologie) stellen sich immer wieder verschiedene Fragen: ‚ÄûWarum funktioniert das so und nicht anders?‚Äú In diesem Moment ist es sehr wichtig, nicht nur die Antwort auf die Frage zu finden, sondern auch die erhaltene Erkl√§rung eingebettet in ein einziges System bereits erworbenen Wissens.  Andernfalls m√ºssen die verwaisten Informationen gespeichert oder vergessen werden. <br></p><br><p>  Gemeinsam etwas lernen hilft viel, um Antworten zu finden.  Wenn ein Sch√ºler / Begleiter eine Frage stellt, wie der Satz zu verstehen ist - "... das Ergebnis des vorherigen Versprechens" versagt "im n√§chsten Versprechen in der Kette ..." denkt man unfreiwillig ... Das ist so eine seltsame Sache.  Aber man kann es nicht mehr besser sagen, ist es wirklich nicht klar?  Sie schauen in die sauberen, leicht naiven Augen des Begleiters und verstehen - Sie m√ºssen etwas anderes sagen.  Es ist w√ºnschenswert, dass Sie nicht einmal auswendig lernen m√ºssen.  Nur neue Informationen passen organisch in existierende menschliche Gedanken. <br></p><br><p>  Ich werde nicht beschreiben, was wir versucht, gelesen, gesehen haben.  Infolgedessen haben wir uns f√ºr die ECMAScript-Spezifikation interessiert.  Wie man es liest und versteht, ist eine separate Konversation (vielleicht sogar ein separater Beitrag).  Aber die Art und Weise, wie Versprechen und ihr Verhalten dort beschrieben werden, hat uns zum ersten Mal ein ganzheitliches und logisch zusammenh√§ngendes Verst√§ndnis f√ºr dieses Thema vermittelt.  Was ich mit dir teilen m√∂chte. <br></p><a name="habracut"></a><br><p>  Dieser Artikel ist f√ºr Anf√§nger.  Versprechen in Bezug auf die ECMAScript-Spezifikation werden hier diskutiert.  Ich wei√ü, es klingt seltsam, aber wie es ist. <br></p><br><h2>  Das Versprechen Objekt: seine Philosophie, technische Pr√§sentation, m√∂gliche Zust√§nde <br></h2><br><p>  Mir ist schon mehr als einmal aufgefallen, dass ein qualitativ hochwertiges Programmiertraining aus 2 Teilen bestehen sollte.  Dies ist ein philosophisches Verst√§ndnis der Idee und erst dann ihrer technischen Umsetzung.  Das hei√üt, die √ºbliche menschliche Logik, an der sich der Sch√ºler bei Entscheidungen orientiert, erleichtert das Verst√§ndnis der technischen Umsetzung dieser Entscheidung erheblich.  Deshalb beginnen wir mit dem, was ein Versprechen im Leben ist und in welcher Beziehung wir dazu stehen.  Und dann werden wir sehen, wie Beispiele f√ºr Versprechen in Code implementiert werden.  Betrachten Sie die folgenden Abbildungen (Abb. 1, 2, 3). <br></p><br><img src="https://habrastorage.org/webt/np/8l/ux/np8luxrdlenwq4o2lzikaludrlw.png" alt="Versprechen Zustand"><br>  <i>Abbildung 1. ([[PromiseState]] - als Ergebnis eines Versprechens)</i> <br><br><img src="https://habrastorage.org/webt/sj/xi/bq/sjxibq_vroug72q8bkdprh4rxik.png" alt="Versprechen Ergebnis"><br>  <i>fig 2. ([[PromiseResult]] - als Information in Bezug auf das Ergebnis eines erf√ºllten oder unerf√ºllten Versprechens)</i> <br><br><img src="https://habrastorage.org/webt/2e/zj/l_/2ezjl_fhehmml3yhfqjijcnerbw.png" alt="Versprich Reaktionen"><br>  <i>Abbildung 3. ([[[PromiseFulfillReactions]], [[PromiseRejectReactions]] - als Konsequenzen, die nach der Erf√ºllung oder Nichterf√ºllung eines Versprechens auftreten)</i> <br><br><p>  Wir sehen, dass das Konzept des Versprechens auf drei S√§ulen steht.  1) Wurde das Versprechen √ºberhaupt erf√ºllt?  2) Welche zus√§tzlichen Informationen k√∂nnen wir extrahieren, nachdem wir ein Versprechen erf√ºllt oder abgelehnt haben?  3) Was sind die Konsequenzen, wenn unser Versprechen positiv oder negativ ist? <br></p><br><p>  Technisch gesehen ist ein Versprechen eine gew√∂hnliche Entit√§t, die durch einen Datentyp wie ein Objekt ausgedr√ºckt wird.  Diese Entit√§t hat ein Namens- / Klassenversprechen.  Objekte aus dieser Klasse haben Promise.prototype in ihrer Prototypenkette.  Und diese Entit√§t muss irgendwie mit all den ‚ÄûInformationen aus dem Leben‚Äú verbunden sein, die wir oben untersucht haben.  Die ECMAScript-Spezifikation verspricht diese Informationen auch auf einer Ebene, die weniger abstrahiert als JavaScript selbst ist.  Zum Beispiel auf der Ebene von C ++.  Dementsprechend gibt es im Gegenstand des Versprechens einen Platz sowohl f√ºr den Status als auch f√ºr das Ergebnis und f√ºr die Konsequenzen des Versprechens.  Sehen Sie sich an, worin <a href="https://www.ecma-international.org/ecma-262/7.0/">das</a> Versprechen von <a href="https://www.ecma-international.org/ecma-262/7.0/">ECMAScript</a> besteht (Abbildung 4). <br></p><br><img src="https://habrastorage.org/webt/bj/m5/lh/bjm5lhtxstjywkkfe6jnjqaqaes.png" alt="Versprechen Felder"><br>  <i>Abbildung 4. (Interne Felder des Versprechungsobjekts gem√§√ü der ECMAScript-Spezifikation)</i> <br><br><p>  Welche neuen Farben hat der Satz "Versprechen hei√üt nicht heiraten" in Bezug auf einen Programmierer gespielt?  1) PromiseState.  Jemand hat nicht geheiratet.  2) [[PromiseResult]].  Weil er nicht genug Geld f√ºr die Hochzeit hatte.  3) [[PromiseRejectReactions]].  Infolgedessen hatte er viel Freizeit, die er f√ºr die Selbstentwicklung verbrachte. 4) [[PromiseFulfillReactions]].  Warum braucht eine Person Plan B, wenn sie bereits Plan A gew√§hlt hat? <br></p><br><p>  Ja, es gibt ein f√ºnftes Feld [[PromiseIsHandled]].  Es ist nicht sehr wichtig f√ºr uns Menschen, und wir werden es in Zukunft nicht mehr bearbeiten.  Kurz: Dem Interpreter wird signalisiert, ob das Versprechen vom Programmierer abgelehnt wurde oder nicht.  Ist dies nicht der Fall, wird die Ablehnung eines unformatierten Versprechens von der JS-Engine als Fehler interpretiert.  F√ºr Ungeduldige: Wenn der Programmierer die Promise.prototype.then () -Funktion nicht als zweiten Aufruf-Funktions-Handler f√ºr den Status des abgelehnten Versprechens aufgeh√§ngt hat, zeigt der Status des abgelehnten Versprechens des Objekts einen roten Fehler in der Entwicklerkonsole an. <br></p><br><p>  Haben Sie bemerkt, dass die Felder des Versprechungsobjekts in "[[" und "]]" eingeschlossen sind?  Dies unterstreicht, dass der JS-Programmierer keinen direkten Zugriff auf diese Informationen hat.  Nur √ºber spezielle Tools / Befehle / API, z. B. den Befehl Promise.prototype.then ().  Wenn Sie den unwiderstehlichen Wunsch haben, ‚Äûdiese K√ºche‚Äú direkt zu steuern, dann begr√º√üen Sie den Standardclub der EcmaScript-Spezifikation. <br></p><br><p>  Eine kurze Bemerkung am Ende dieses Unterkapitels.  Wenn im Leben in unserem Land Versprechungen teilweise erf√ºllt werden k√∂nnen, dann in EcmaScript - nicht.  Das hei√üt, wenn jemand versprochen hat, eine Million zu geben, und 950.000 gegeben hat, dann ist er im Leben vielleicht ein verl√§sslicher Partner, aber f√ºr JavaScript wird ein solcher Schuldner durch PromiseState auf die schwarze Liste gesetzt === "abgelehnt".  Ein Promise-Objekt √§ndert seinen Status eindeutig und nur einmal.  Wie dies technisch umgesetzt wird, ist etwas sp√§ter. <br></p><br><h2>  Designer Promise, seine Philosophie.  Der Callback Function Executor ist wie der "Executor" eines Versprechens.  Interaktionsschema: Promise (Konstruktor) - Executor (R√ºckruf) - Promise (Objekt) </h2><br><p>  Wir haben also herausgefunden, dass Versprechen eine Entit√§t ist, die technisch gesehen ein JS-Objekt mit speziellen verborgenen inneren Feldern ist, die wiederum eine philosophische F√ºllung mit der Bedeutung des Wortes ‚ÄûVersprechen‚Äú bieten. <br></p><br><p>  Wenn ein Anf√§nger zum ersten Mal ein Versprechen erstellt, erwartet ihn das folgende Bild (Abb. 5). <br></p><br><img src="https://habrastorage.org/webt/m1/xg/3u/m1xg3uoxgytd1nd2x7pc_z9i93m.png" alt="falsches erstellen versprechen objekt"><br>  <i>Abbildung 5. (Das erste Mal, dass wir intuitiv ein Versprechungsobjekt erstellen.)</i> <br><br><p>  Was ist schief gelaufen und warum ist der Fehler eine Standardfrage.  Bei der Beantwortung ist es besser, wieder eine Analogie aus dem Leben zu bringen.  Zum Beispiel m√∂gen nur wenige Menschen "leere Glockenspiele" um uns herum, die nur versprechen, aber nichts tun, um ihre Aussagen zu erf√ºllen (Politik z√§hlt nicht).  Wir sind viel besser in den Menschen, die nach ihrem Versprechen einen Plan haben und sofort Ma√ünahmen ergreifen, um das versprochene Ergebnis zu erzielen. <br></p><br><p>  Die ECMAScript-Philosophie impliziert also, dass Sie, wenn Sie ein Versprechen erstellen, sofort angeben, wie Sie es erf√ºllen werden.  Der Programmierer muss seinen Aktionsplan in Form eines Funktionsparameters erstellen, den Sie an den Promise-Konstruktor √ºbergeben.  Das n√§chste Experiment sieht so aus (Abb. 6). <br></p><br><img src="https://habrastorage.org/webt/xh/sk/h7/xhskh7cuzrn1jxavomenlnfzwu0.png" alt="Promise-Konstruktor verwendet Executor"><br>  <i>Abbildung 6. (Erstellen Sie ein Versprechen-Objekt und √ºbergeben Sie die Executor-Funktion an den Versprechen-Konstruktor.)</i> <br><br><p>  Von der √úberschrift bis zur Abbildung sehen wir, dass die Funktion (Promise-Konstruktorparameter) einen eigenen Namen hat - executor.  Ihre Aufgabe ist es, damit zu beginnen, das Versprechen zu erf√ºllen und es vorzugsweise zu einer Art logischen Schlussfolgerung zu bringen.  Und wenn der Programmierer Code in den Executor schreiben kann, wie kann der Programmierer JS dann signalisieren, dass alles - die Arbeit ist erledigt - Sie k√∂nnen die Ergebnisse des Versprechens sehen? <br></p><br><p>  Markierungen oder Signale, mit denen der Programmierer dar√ºber informiert wird, dass das Versprechen erf√ºllt ist, werden automatisch an den Executor √ºbergeben - a-Parameter in Form von Argumenten, die speziell von JavaScript erstellt wurden.  Diese Parameter k√∂nnen nach Belieben aufgerufen werden, aber am h√§ufigsten werden Sie sie unter Namen wie res und rej finden.  In der ECMAScript-Spezifikation lautet ihr vollst√§ndiger Name Aufl√∂sungsfunktion und Zur√ºckweisungsfunktion.  Diese Funktionsmarker haben ihre eigenen Eigenschaften, auf die wir sp√§ter noch eingehen werden. <br></p><br><p>  Um die neuen Informationen zu verstehen, wird der Neuank√∂mmling aufgefordert, die folgende Aussage eigenst√§ndig zu kodieren: ‚ÄûIch verspreche, dass ich eine Zahl in eine andere aufteilen und eine Antwort geben kann, wenn nur der Teiler nicht Null ist.‚Äú  So w√ºrde der Code aussehen (Abb. 7). <br></p><br><img src="https://habrastorage.org/webt/uu/to/gj/uutogjuluy9r5xxvwo2hrrwnaaq.png" alt="Versprechen Aufgabe: Division durch Null"><br>  <i>Abbildung 7. (L√∂sung des Problems, 2 Zahlen durch Versprechen zu teilen)</i> <br><br><p>  Jetzt k√∂nnen Sie das Ergebnis analysieren.  Wir sehen, dass die Browserkonsole das Promis-Objekt zum zweiten Mal auf interessante Weise anzeigt.  N√§mlich: 2 zus√§tzliche Felder sind in doppelten eckigen Klammern angegeben.  Sie k√∂nnen sicher eine Analogie zwischen [[PromiseState]] und [[PromiseStatus]] ziehen, erf√ºllt und aufgel√∂st, [[PromiseValue]] und [[PromiseResult]].  Ja, der Browser selbst versucht, dem Programmierer das Vorhandensein und den Wert der internen Felder des Versprechungsobjekts mitzuteilen.  Wir sehen auch das verbundene System des Versprechen-Objekts, die Executor-Funktion, die speziellen Funktions-Callback-Token res und rej. <br></p><br><p>  Damit sich der Student / Partner in diesem Material entspannter f√ºhlt, wird ihm der folgende Code angeboten (Abb. 8).  Es ist notwendig, es zu analysieren und die folgenden Fragen zu beantworten. <br></p><br><img src="https://habrastorage.org/webt/zs/md/vv/zsmdvv05gwmpi-vyq5a-d5sorjq.png" alt="Versprechen Aufgabe: Division durch Null. Alternative Version"><br>  <i>Abbildung 8. (Variation der L√∂sung des Problems, 2 Zahlen durch Versprechen zu teilen)</i> <br><br><p>  Wird der Code funktionieren?  Wo ist hier die Executor-Funktion und wie hei√üt sie?  Entspricht der Name "wantToDivide" in diesem Code?  Was gibt die Bindefunktion nach sich selbst zur√ºck?  Warum werden Argumente nur an zweiter und dritter Stelle an die Bindefunktion √ºbergeben?  Wo sind die Sonderfunktionen Funktion aufl√∂sen und Funktion verwerfen verschwunden?  Wie sind die notwendigen Eingabenummern Nummer1 und Nummer2 in den ‚ÄûVersprechen-Erf√ºllungsplan‚Äú eingeflossen?  Wie viele Elemente enth√§lt das Argument Pseudo-Array?  Ist es m√∂glich, aus dem Speicher wiederherzustellen, wie die Antwort in der Browserkonsole aussehen wird? <br></p><br><p>  Der Leser wird gebeten, √ºber die Antworten auf die Fragen selbst nachzudenken.  Und auch <br>  im Code experimentieren.  Gl√ºcklicherweise ist der Code klein und die Idee der Aufgabe ist einfach.  Ja, es gibt Fragen zu Versprechen und allgemeinen Kenntnissen von JavaScript.  √úberall warten wir auf √úberraschungen, die uns daran hindern, uns zu entspannen.  Sobald dir alles klar ist, kannst du weitermachen. <br></p><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen / kopieren</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number1 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number2 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 2"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wantToDivide = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-string"><span class="hljs-string">"it is forbidden to divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>](result); }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(wantToDivide.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, number1, number2)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myPromise);</code> </pre> <br></div></div><br><h2>  Betrachten Sie die Argumente executor-a: Funktionen aufl√∂sen und ablehnen <br></h2><br><p>  Also haben wir einen Kaffee getrunken - wir ziehen weiter.  Betrachten wir die Sonderfunktionen Aufl√∂sungsfunktion und Zur√ºckweisungsfunktion, die automatisch von JavaScript generiert werden, um das Versprechen des Objekts in den erf√ºllten oder zur√ºckgewiesenen Zustand zu versetzen, der das Ende des Versprechens symbolisiert. <br></p><br><p>  Beginnen wir damit, sie einfach in der Entwicklerkonsole anzusehen (Abb. 9). <br></p><br><img src="https://habrastorage.org/webt/rz/ox/vj/rzoxvjvsvmt3962toiukmqtf9ye.png" alt="Forschungsaufl√∂sungsfunktion"><br>  <i>Abbildung 9. (Untersuchung der Funktion resolve function - res)</i> <br><br><p>  Wir sehen, dass die Aufl√∂sungsfunktion eine Funktion ist, die ein Argument akzeptiert (Eigenschaftsl√§nge === 1).  Und sein Prototyp ist Function.prototype. <br></p><br><p>  Ok, lass uns die Experimente fortsetzen.  Und was passiert, wenn wir den Link zur Aufl√∂sungs- / Zur√ºckweisungsfunktion vom Executor zum externen Bereich entfernen?  Wird etwas kaputt gehen (Abb. 10)? <br></p><br><img src="https://habrastorage.org/webt/9z/2i/cf/9z2icfrmkwiwfeeerdphezhtjay.png" alt="externe kontrolle des versprechensgegenstandes"><br>  <i>Abbildung 10. (Wir √ºbersetzen das myPromise-Versprechen in den erf√ºllten Zustand au√üerhalb des Versprechens.)</i> <br><br><p>  Nichts Au√üergew√∂hnliches.  Funktionen als Unterart eines Objekts in JavaScript werden als Referenz √ºbergeben.  Alles hat wie erwartet geklappt.  Die Variable aus dem OuterRes-Abschluss hat einen Verweis auf unsere Aufl√∂sungsfunktion res erhalten.  Und wir haben seine Funktionalit√§t genutzt, um das Versprechen au√üerhalb des Executors selbst in den erf√ºllten Zustand zu versetzen.  Das folgende leicht modifizierte Beispiel zeigt die gleiche Idee. Schauen Sie sich also den Code an und √ºberlegen Sie, in welchem ‚Äã‚ÄãZustand und mit welchem ‚Äã‚ÄãWert myPromise1 und myPromise2 sein werden (Abb. 11).  Dann k√∂nnen Sie Ihre Vermutungen unter dem Spoiler √ºberpr√ºfen. </p><br><img src="https://habrastorage.org/webt/re/gf/ov/regfovwn9xc5-jwlkftz0ed8vgc.png" alt="Versprechen Aufgabe. Frage">  <i>Abbildung 11. (Die Aufgabe der Reflexion. In welchem ‚Äã‚ÄãZustand und mit welchem ‚Äã‚ÄãWert befinden sich die Versprechen myPromise1 und myPromise2 in der Entwicklerkonsole?)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort auf das Problem in Abbildung 11 (Abbildung 12).</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/iy/3x/k-/iy3xk-yuomgcgev4ddftqcffnvm.png" alt="Versprechen Aufgabe. Antwort"><br>  <i>Abbildung 12. (Die Antwort auf das Problem in Abbildung 11)</i> <br></div></div><br><p>  Und jetzt k√∂nnen Sie √ºber eine interessante Frage nachdenken.  Aber woher wei√ü die Aufl√∂sungs- / Zur√ºckweisungsfunktion immer genau, welches Versprechen in den erforderlichen Zustand zu √ºbersetzen ist?  Wir wenden uns dem <a href="https://www.ecma-international.org/ecma-262/7.0/">Algorithmus in der Spezifikation zu</a> , der beschreibt, wie diese Funktionen erstellt werden (Abb. 13). <br></p><br><img src="https://habrastorage.org/webt/4n/gq/k-/4ngqk-fikg8ddjo6uhe00_rhkci.png" alt="Erstellen Sie aufl√∂sende Funktionen"><br>  <i>Abbildung 13. (Funktionen zum Erstellen von Aufl√∂sungsfunktionen f√ºr ein bestimmtes Versprechungsobjekt)</i> <br><br><p>  Wichtige Punkte zu beachten: <br></p><br><ul><li>  Zum Zeitpunkt der Erstellung der Aufl√∂sungs- / Zur√ºckweisungsfunktionen sind sie fest mit dem einzigen Versprechungsobjekt verbunden, das diesem entspricht <br></li><li>  Die Aufl√∂sungs- / Zur√ºckweisungsfunktionen als Objektdatentyp haben ihre eigenen versteckten Felder [[Promise]] und [[AlreadyResolved]], die jedem die vertraute intuitive Logik bieten, dass a) - Aufl√∂sungsfunktionen selbst das Versprechungsobjekt in den erforderlichen Zustand √ºbersetzen;  und die Tatsache, dass b) ein Versprechen nicht in einen anderen Staat √ºbertragen werden kann, wenn mindestens einmal eine Abwicklungs- oder Zur√ºckweisungsfunktion aufgerufen wurde.  Dieser Algorithmus kann durch die folgende Abbildung dargestellt werden (Abb. 14). <br><br><img src="https://habrastorage.org/webt/0p/wt/1d/0pwt1dmqxhzhq0uuat_zljihrhc.png" alt="Funktionen l√∂sen und Objekt versprechen"><br>  <i>Abbildung 14. (Versteckte Funktionsfelder der Aufl√∂sungsfunktion und der Zur√ºckweisungsfunktion)</i> <br><br><p>  Algorithmen, die diese Informationen aus ausgeblendeten Feldern verwenden, werden jetzt nicht ber√ºcksichtigt, da sie ausf√ºhrlicher und komplexer sind.  Wir m√ºssen uns sowohl theoretisch als auch moralisch auf sie vorbereiten.  Im Moment kann ich nur Ihren Gedanken best√§tigen: ‚ÄûWow, wie einfach es sich herausstellt.  Wahrscheinlich wird bei jeder Aufl√∂sung / Aufl√∂sung des Versprechens des Objekts das "Objekt" -Flag {[[Wert]]: false} √ºberpr√ºft.  Und wenn es auf wahr gesetzt ist, stoppen wir den Prozess der √úbersetzung des Versprechens in einen anderen Zustand mit einer einfachen R√ºckkehr. "  Ja, genau das passiert.  Es scheint, dass Sie die folgende Frage ohne Probleme richtig beantworten k√∂nnen.  Was ist das Ergebnis in der Entwicklerkonsole (Abb. 15)? <br></p><br><img src="https://habrastorage.org/webt/p6/1l/co/p61lcoillhsvjme0-hotfyacsoi.png" alt="Expertise bei der Verkn√ºpfung von L√∂sungsfunktionen und Versprechensobjekt"><br>  <i>Abbildung 15. (Ein Experiment, das die Beziehung zwischen Aufl√∂sungs- und Zur√ºckweisungsfunktionen f√ºr ein bestimmtes Versprechungsobjekt zeigt.)</i> <br><br><h2>  Algorithmus zum Erstellen eines Versprechungsobjekts gem√§√ü der ECMAScript-Spezifikation </h2><br><p>  Betrachten Sie den bezaubernden Moment, in dem es in die Welt hineingeboren wird - ein vollwertiges <a href="https://www.ecma-international.org/ecma-262/7.0/">Versprechungsobjekt</a> (Abb. 16). <br></p><br><img src="https://habrastorage.org/webt/xm/yu/09/xmyu0944vrpk4ykurzgunwst0ji.png" alt="Versprechen Erstellung in Ecmascript"><br>  <i>Abbildung 16. (Algorithmus zum Erstellen eines Versprechungsobjekts aus der EcmaScript-Spezifikation)</i> <br><br><p>  Bei der Anzeige sollten keine komplizierten Fragen auftauchen: </p><p></p><ul><li>  Der Promise-Konstruktor muss im Konstruktormodus und nicht nur als Funktionsaufruf aufgerufen werden <br></li><li>  Der Promise-Konstruktor ben√∂tigt eine Executor-Funktion <br></li><li>  Erstellen Sie ein JavaScript-Objekt mit bestimmten ausgeblendeten Feldern <br></li><li>  Initialisieren Sie ausgeblendete Felder mit Anfangswerten <br></li><li>  Erstellen Sie die Aufl√∂sungs- und Zur√ºckweisungsfunktionen, die dem Versprechungsobjekt zugeordnet sind <br></li><li>  wir rufen die executor-funktion zur ausf√ºhrung auf und √ºbergeben dort bereits generierte token aufl√∂sungsfunktion und ablehnungsfunktion als argumente <br></li><li>  Wenn w√§hrend der Ausf√ºhrung des Testaments ein Fehler aufgetreten ist, versetzen Sie unser Versprechungsobjekt in den Status "Abgelehnt" <br></li><li>  kehre zu der Variablen das geborene Versprechen-Versprechen-Objekt zur√ºck. <br></li></ul><br><p>  Ich wei√ü nicht, ob es f√ºr Sie eine Entdeckung war, dass der Funktionsausf√ºhrungsalgorithmus hier und jetzt im normalen synchronen Modus ausgef√ºhrt wird, noch bevor etwas in die Variable links vom Promise-Konstruktor geschrieben wird.  Aber zu gegebener Zeit wurde es f√ºr mich eine Offenbarung. <br></p><br><p>  Da wir das Thema Synchronit√§t und Asynchronit√§t angesprochen haben, finden Sie hier den folgenden Code, √ºber den Sie nachdenken oder experimentieren k√∂nnen.  Frage: Wenn Sie sich eine Kreation des Programmierers Dima angesehen haben, k√∂nnen Sie dann beantworten, welche Bedeutung das unten codierte Spiel hat. <br></p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomInteger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">min, max</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(min + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * (max + <span class="hljs-number"><span class="hljs-number">1</span></span> - min)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> guessCubeNumber = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"Throw dice? Guess number?"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"throwing dice ... wait until it stop"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gottenNumberDice = randomInteger(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); gottenNumberDice === guessCubeNumber ? res(<span class="hljs-string"><span class="hljs-string">"you win!"</span></span>) : rej(<span class="hljs-string"><span class="hljs-string">`you loose. </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${gottenNumberDice}</span></span></span><span class="hljs-string"> points dropped on dice`</span></span>); }, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameState; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(game());</code> </pre><br><p>  Dies ist nat√ºrlich eine Emulation eines W√ºrfelwurfs.  Kann der Benutzer die Zahl erraten, die herausgefallen ist oder nicht?  Sehen Sie, wie sich das organisch asynchrone setTimeout in den synchronen Executor integriert - in unserem Plan werfen Sie einen W√ºrfel und finden Sie die Zahl heraus, die herausgefallen ist.  Wie kann man die Ergebnisse in der Entwicklerkonsole auf besondere Weise interpretieren (Abb. 17)? <br></p><br><p>  Wenn wir versuchen, das Versprechen anzuschauen, bis der W√ºrfel stoppt (3000 ms werden im Code angezeigt), werden wir feststellen, dass das Versprechen immer noch wartet: Das Spiel ist noch nicht beendet, der W√ºrfel ist noch nicht gestoppt, es ist keine Zahl herausgefallen.  Wenn wir versuchen, das Versprechungsobjekt nach dem Stoppen des W√ºrfels zu betrachten, sehen wir sehr spezifische Informationen: ob der Benutzer gewonnen hat (die Zahl erraten hat) oder verloren hat und warum (welche Zahl fiel tats√§chlich aus). <br></p><br><img src="https://habrastorage.org/webt/g4/oi/ba/g4oibarzyfjcrnzbvdqs9nqddqm.png" alt="Versprechen Spiel - W√ºrfel werfen"><br>  <i>Abbildung 17. (Der Versprechungsstatus eines Objekts bei einer asynchronen Operation in der Executor-Funktion)</i> <br><br><p>  Wenn Sie an diesem Beispiel interessiert sind oder die Anzahl der umgedrehten W√ºrfel erraten m√∂chten, k√∂nnen Sie den Code kopieren und Ihre Experimente durchf√ºhren.  Wage es! <br></p><br><h2>  Versprechen Reaktion als Folge eines erf√ºllten Versprechens </h2><br><p>  Wie Sie in Abbildung 14 sehen k√∂nnen, werden die Konsequenzen des Aufl√∂sens / Aufl√∂sens eines Versprechens eines Objekts als "+ Reaktion" und "-Reaktion" gekennzeichnet.  Der offizielle Begriff f√ºr diese W√∂rter aus der ECMAScript-Spezifikation ist Versprechen Reaktion.  Es wird davon ausgegangen, dass dieses Thema in den folgenden Artikeln ausf√ºhrlich behandelt wird.  Wir beschr√§nken uns vorerst auf die allgemeine Vorstellung, was eine verhei√üungsvolle Reaktion ist, damit dieser Begriff richtig mit der philosophischen Bedeutung dieses Wortes und seiner technischen Ausf√ºhrung in Verbindung gebracht werden kann. <br></p><br><p>  Wie wir uns erinnern, kann ein Versprechen Konsequenzen haben, aber nicht.  Was ist die konsequenz  Dies ist eine Aktion, die einige Zeit sp√§ter stattfinden wird: nachdem das Versprechen erf√ºllt ist.  Und da dies eine Aktion ist, kann die Konsequenz durch eine normale JavaScript-Funktion ausgedr√ºckt werden.  Einige Funktionen werden im Falle einer erfolgreichen L√∂sung des Versprechens ausgef√ºhrt (+ Reaktion);  andere Funktionen - f√ºr den Fall, dass das Versprechen in den abgelehnten Zustand √ºbergeht (-reaktion).  Technisch werden diese Funktionen (Konsequenzen) in Argumenten √ºbergeben, wenn die Promise.prototype.then () -Methode aufgerufen wird. <br></p><br><p>  Ein wichtiger Teil einer Versprechungsreaktion ist daher eine asynchrone Aktion, die irgendwann in der Zukunft ausgef√ºhrt wird.  Es gibt eine zweite wichtige Komponente der Versprechungsreaktion - dies ist die neu erstellte Versprechung, die nach Ausf√ºhrung des Befehls Promise.prototype.then () zur√ºckgegeben wird.  Dies liegt daran, dass die Konsequenzen andere Versprechen beeinflussen.  Zum Beispiel gibt es ein Versprechen, ein Auto zu kaufen, aber erst, wenn das Versprechen, einen bestimmten Geldbetrag zu verdienen, erf√ºllt ist.  Ein Versprechen wurde erf√ºllt - die Konsequenz hat sich herausgestellt - jetzt kann das zweite erf√ºllt werden. <br></p><br><p>  Tats√§chlich bindet eine Versprechungsreaktion Versprechungen in einem bestimmten Zeitintervall aneinander.  Es ist wichtig zu beachten, dass die Reaktion automatisch verarbeitet wird.  Funktionsaufrufe - die Konsequenzen der Erf√ºllung eines Versprechens - werden von der JS-Engine und nicht vom Programmierer ausgef√ºhrt (Abb. 18).  Und da die Reaktionen eng mit den Versprechungsobjekten (Versprechungen) selbst zusammenh√§ngen, ist es logisch anzunehmen, dass die Versprechungsreaktionsalgorithmen ihre internen Felder in ihrer Logik verwenden.  Und es ist besser, √ºber all diese Nuancen Bescheid zu wissen, um die asynchrone Logik auf der Grundlage von Versprechungen bewusst steuern zu k√∂nnen. <br></p><br><img src="https://habrastorage.org/webt/zc/tk/ja/zctkjapwx_daq-shustmj4yc5fo.png" alt="verspreche Reaktion in then () Methode"><br>  <i>Abbildung 18. (Die Konsequenzen der Aufl√∂sung eines Versprechens werden von R√ºckruffunktionen in der then () -Methode aufgezeichnet. Der R√ºckruf wird von der JS-Engine automatisch asynchron aufgerufen.)</i> <br><br><h2>  Um es zusammenzufassen </h2><br><p>  1) Wir haben die Versprechen in JavaScript, ihre Philosophie und technische Ausf√ºhrung kennengelernt.  All dies wird mithilfe spezieller interner Versprechungsfelder des Objekts implementiert: [[PromiseState]], [[PromiseValue]], [[PromiseFulFillReactions]], [[PromiseRejectReactions]]. <br></p><br><p>  2) Der Programmierer hat die M√∂glichkeit, sein Versprechen durch die Executor-Funktion zu erf√ºllen, die dem Promise-Konstruktor als Argument √ºbergeben wird. <br></p><br><p>  3) Die Grenzen eines erf√ºllten oder unerf√ºllten Versprechens werden durch spezielle Markierungsfunktionen, Aufl√∂sungsfunktion und Zur√ºckweisungsfunktion bestimmt, h√§ufig im Code res und rej genannt.  Diese Funktionen werden automatisch von JavaScript erstellt und in Argumenten an den Executor √ºbergeben. <br></p><br><p>  4) Aufl√∂sungsfunktion und Zur√ºckweisungsfunktion haben immer ein Versprechungsobjekt sowie ein gemeinsames Spezialfeld {[[Wert]]: false}, das sicherstellt, dass die Versprechung nur einmal aufgel√∂st wird. <br></p><br><p>  5) [[PromiseFulFillReactions]] und [[PromiseRejectReactions]] sind interne Felder des Versprechungsobjekts, in denen die Konsequenzen der Aufl√∂sung der Versprechung gespeichert sind. Ein wichtiger Teil davon sind benutzerdefinierte asynchrone Funktionen, die mit der Versprechungsmethode Promise.prototype.then () des Objekts definiert wurden. <br></p><br><h2>  PS </h2><br><p>  Dieser Artikel wurde als Zusammenfassung der Videositzung der InSimpleWords-Gruppe erstellt.  Es gibt genug solche "Video-Lektionen" und es gibt immer noch Material f√ºr Notizen.  Eine andere Frage ist, ob es f√ºr Community-Mitglieder interessant sein wird, welchen Artikel √ºber Versprechen hintereinander zu lesen.  Warten auf Ihre Kommentare. <br></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478938/">https://habr.com/ru/post/de478938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478924/index.html">Konfigurieren eines Heimrouters + NAS auf unRAID (Teil 2)</a></li>
<li><a href="../de478928/index.html">Python oder nicht Python</a></li>
<li><a href="../de478930/index.html">Wie man MySQL ohne Passwort benutzt (und Sicherheitsrisiken)</a></li>
<li><a href="../de478932/index.html">Docker f√ºr das Frontend. Teil 1. Warum?</a></li>
<li><a href="../de478934/index.html">Das n√ºtzlichste Python-Standardbibliotheksmodul, das jeder st√§ndig vergisst</a></li>
<li><a href="../de478942/index.html">Tolles Porno-Experiment: Die Geschichte des Internets f√ºr Erwachsene</a></li>
<li><a href="../de478950/index.html">Das Ergebnis der Woche: Huawei passt sich den Sanktionen an, Putin unterzeichnet sensationelle Gesetze und blockiert in Russland ShutterStock</a></li>
<li><a href="../de478952/index.html">Ein Monat mit Onyx Boox Note Pro</a></li>
<li><a href="../de478954/index.html">RE: Angst und Abscheu vor IT</a></li>
<li><a href="../de478956/index.html">Einf√ºhrung von 3CX V16 Update 4 Beta mit einem Chrome VoIP-Client und einer Videoanwendung f√ºr Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>