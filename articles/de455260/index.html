<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª üë®üèæ‚Äçüîß üòê Merkle Tree: rostig und schnell üë©‚Äçüë©‚Äçüë¶ üëø üé†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! K√ºrzlich entdeckte die Sprache Rust. Er teilte seine ersten Eindr√ºcke in einem fr√ºheren Artikel . Jetzt habe ich beschlossen, etwas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merkle Tree: rostig und schnell</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455260/"><p><img src="https://habrastorage.org/webt/02/we/l8/02wel89vk_uuxibqbvaiimofkkk.png" alt="Bild"></p><br><p>  Hallo allerseits!  K√ºrzlich entdeckte die Sprache Rust.  Er teilte seine ersten Eindr√ºcke in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel</a> .  Jetzt habe ich beschlossen, etwas tiefer zu graben, daf√ºr brauchst du etwas Ernsthafteres als die Liste.  Meine Wahl fiel auf den Merkle-Baum.  In diesem Artikel m√∂chte ich: </p><br><ul><li>  Sprechen Sie √ºber diese Datenstruktur </li><li>  Schau dir an, was Rust schon hat </li><li>  Bieten Sie Ihre Implementierung an </li><li>  Leistung vergleichen </li></ul><a name="habracut"></a><br><h1 id="derevo-merkla">  Merkle Tree </h1><br><p> Dies ist eine relativ einfache Datenstruktur, √ºber die es im Internet bereits viele Informationen gibt, aber ich denke, mein Artikel wird ohne eine Beschreibung des Baums unvollst√§ndig sein. </p><br><h2 id="v-chyom-problema">  Was ist das Problem </h2><br><p>  Der Merkle-Baum wurde 1979 erfunden, gewann aber dank der Blockchain an Popularit√§t.  Die Blockkette im Netzwerk ist sehr gro√ü (f√ºr Bitcoin sind es mehr als 200 GB), und nicht alle Knoten k√∂nnen sie abpumpen.  Zum Beispiel Telefone oder Registrierkassen.  Sie m√ºssen jedoch wissen, ob diese oder jene Transaktion in den Block aufgenommen wird.  Hierzu wurde das Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPV - Simplified Payment Verification</a> erfunden. </p><br><h2 id="kak-ustroeno-derevo">  Wie ein Baum funktioniert </h2><br><p>  Dies ist ein bin√§rer Baum, dessen Bl√§tter Hashes von Objekten sind.  Um die n√§chste Ebene zu erstellen, werden Hashes benachbarter Bl√§tter paarweise verkettet und der Hash aus dem Ergebnis der Verkettung berechnet, was im Bild in der Kopfzeile dargestellt ist.  Somit ist die Wurzel des Baumes ein Hasch aller Bl√§tter.  Wenn Sie ein Element entfernen oder hinzuf√ºgen, √§ndert sich der Stamm. </p><br><h2 id="kak-rabotaet-derevo">  Wie funktioniert ein Baum? </h2><br><p>  Mit einem Merkle-Baum k√∂nnen Sie Beweise f√ºr die Aufnahme einer Transaktion in einen Block als Pfad von einem Transaktions-Hash zum Stamm erstellen.  Zum Beispiel sind wir an der Transaktion Tx2 interessiert, daf√ºr wird der Beweis sein (Hash3, Hash01).  Dieser Mechanismus wird auch in SPV verwendet.  Der Client l√§dt nur den Blockheader mit seinem Hash herunter.  Bei einer Transaktion von Interesse fordert er einen Beweis von einem Knoten an, der die gesamte Kette enth√§lt.  Dann macht es eine √úberpr√ºfung, f√ºr Tx2 wird es sein: </p><br><pre><code class="plaintext hljs">hash(Hash01, hash(Hash2, Hash3)) = Root Hash</code> </pre> <br><p>  Das Ergebnis wird mit der Wurzel des Blockheaders verglichen.  Dieser Ansatz macht es unm√∂glich, Beweise zu f√§lschen, da in diesem Fall das Testergebnis nicht mit dem Inhalt des Headers konvergiert. </p><br><h1 id="kakie-uzhe-est-realizacii">  Welche Implementierungen existieren bereits? </h1><br><p>  Rust ist eine junge Sprache, aber viele Erkenntnisse des Merkle-Baumes sind bereits darauf geschrieben.  Nach Github zu urteilen, ist dies im Moment 56 mehr als in C und C ++ zusammen.  Obwohl Go sie mit 80 Implementierungen auf den neuesten Stand bringt. </p><br><h2 id="spinresearchmerklershttpsgithubcomspinresearchmerklers">  <a href="">SpinResearch / merkle.rs</a> </h2><br><p>  F√ºr meinen Vergleich habe ich diese Implementierung anhand der Anzahl der Sterne im Repository ausgew√§hlt. </p><br><p>  Dieser Baum ist auf die offensichtlichste Weise konstruiert, dh es handelt sich um ein Diagramm von Objekten.  Wie bereits erw√§hnt, ist dieser Ansatz nicht vollst√§ndig rostfreundlich.  Beispielsweise ist es nicht m√∂glich, eine bidirektionale Kommunikation von Kindern zu Eltern herzustellen. </p><br><p>  Die Konstruktion von Beweisen erfolgt durch eine eingehende Suche.  Wenn ein Blatt mit dem richtigen Hash gefunden wird, ist der Pfad dazu das Ergebnis. </p><br><h2 id="chto-mozhno-uluchshit">  Was kann verbessert werden </h2><br><p>  Es war f√ºr mich nicht interessant, eine einfache (n + 1) -te Implementierung durchzuf√ºhren, also dachte ich √ºber Optimierung nach.  Der Code f√ºr meinen <em>Vektor-Merkle-Baum</em> ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> . </p><br><h3 id="hranenie-dannyh">  Datenspeicherung </h3><br><p>  Das erste, was mir in den Sinn kommt, ist, den Baum in ein Array zu verschieben.  Diese L√∂sung ist in Bezug auf die Datenlokalit√§t viel besser: mehr Cache-Treffer und eine bessere Vorladung.  Das Gehen um Objekte, die aus dem Ged√§chtnis verstreut sind, dauert l√§nger.  Eine bequeme Tatsache ist, dass alle Hashes gleich lang sind, weil  berechnet von einem Algorithmus.  Der Merkle-Baum im Array sieht folgenderma√üen aus: <br><img src="https://habrastorage.org/webt/7_/in/4_/7_in4_ijawhhqj4f9pldunhl2mu.png" alt="Bild"></p><br><h3 id="dokazatelstvo">  Beweis </h3><br><p>  Wenn Sie den Baum initialisieren, k√∂nnen Sie eine HashMap mit allen Blattindizes erstellen.  Wenn es also kein Blatt gibt, m√ºssen Sie nicht um den ganzen Baum herumgehen, und wenn ja, k√∂nnen Sie sofort dorthin gehen und sich zur Wurzel erheben, um einen Beweis zu erstellen.  In meiner Implementierung habe ich HashMap optional gemacht. </p><br><h3 id="konkatenaciya-i-heshirovanie">  Verkettung und Hashing </h3><br><p>  Es scheint, dass hier verbessert werden kann?  Immerhin ist alles klar - nehmen Sie zwei Hashes, kleben Sie sie und berechnen Sie einen neuen Hash.  Tatsache ist jedoch, dass diese Funktion nicht kommutativ ist, d.h.  Hash (H0, H1) ‚â† Hash (H1, H0).  Aus diesem Grund m√ºssen Sie sich beim Erstellen des Proofs merken, auf welcher Seite sich der benachbarte Knoten befindet.  Dies erschwert die Implementierung des Algorithmus und macht das Speichern redundanter Daten erforderlich.  Alles ist sehr einfach zu reparieren, sortieren Sie einfach die beiden Knoten vor dem Hashing.  Zum Beispiel habe ich Tx2 unter Ber√ºcksichtigung der Kommutativit√§t zitiert. Die Pr√ºfung sieht folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs">hash(hash(Hash2, Hash3), Hash01) = Root Hash</code> </pre> <br><p>  Wenn Sie sich keine Gedanken √ºber die Reihenfolge machen m√ºssen, sieht der √úberpr√ºfungsalgorithmus wie eine einfache Faltung eines Arrays aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { proof[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .fold( get_pair_hash(proof[<span class="hljs-number"><span class="hljs-number">0</span></span>], proof[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo), |a, b| get_pair_hash(a.as_ref(), b, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo) ).as_ref() == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_root() }</code> </pre> <br><p>  Das Nullelement ist der Hash des gew√ºnschten Objekts, das erste ist sein Nachbar. </p><br><h1 id="pognali">  Lass uns gehen! </h1><br><p>  Die Geschichte w√§re unvollst√§ndig ohne einen Leistungsvergleich, der mehrmals l√§nger dauerte als die Implementierung des Baums.  F√ºr diese Zwecke habe ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kriterien-</a> Framework verwendet.  Die Quellen der Tests selbst sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Alle Tests finden √ºber die <em>TreeWrapper-</em> Schnittstelle statt, die f√ºr beide Probanden implementiert wurde: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeWrapper</span></span></span></span>&lt;V&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); }</code> </pre> <br><p>  Beide B√§ume arbeiten mit derselben Ringkryptographie.  Hier werde ich nicht verschiedene Bibliotheken vergleichen.  Ich habe am h√§ufigsten genommen. </p><br><p>  Als Hash-Objekte werden zuf√§llig generierte Zeichenfolgen verwendet.  B√§ume werden auf Arrays unterschiedlicher L√§nge verglichen: (500, 1000, 1500, 2000, 2500 3000).  2500 - 3000 ist die ungef√§hre Anzahl der Transaktionen im Bitcoin-Block. </p><br><p>  In allen Diagrammen gibt die X-Achse die Anzahl der Array-Elemente (oder die Anzahl der Transaktionen im Block) an, und die Y-Achse gibt die durchschnittliche Zeit an, um den Vorgang in Mikrosekunden abzuschlie√üen.  Das hei√üt, je mehr desto schlimmer. </p><br><h2 id="sozdanie-dereva">  Baum machen </h2><br><p>  Die Speicherung aller Baumdaten in einem Array √ºbersteigt das Leistungsdiagramm von Objekten erheblich.  F√ºr ein Array mit 500 Elementen das 1,5-fache und f√ºr 3000 Elemente bereits das 3,6-fache.  Die nichtlineare Natur der Abh√§ngigkeit der Komplexit√§t vom Volumen der Eingabedaten in der Standardimplementierung ist deutlich sichtbar. </p><br><p>  Au√üerdem habe ich im Vergleich zwei Varianten des <em>Vektorbaums</em> hinzugef√ºgt: mit und ohne <em>HashMap</em> .  Durch das Ausf√ºllen einer zus√§tzlichen Datenstruktur werden etwa 20% hinzugef√ºgt, aber Sie k√∂nnen beim Erstellen von Beweisen viel schneller nach Objekten suchen. <br><img src="https://habrastorage.org/webt/xk/nf/kj/xknfkjl5aqy8oqagfzaj05p1qo4.png" alt="Bild"></p><br><h2 id="postroenie-dokazatelstva">  Beweise bauen </h2><br><p>  Hier sehen Sie die offensichtliche Ineffizienz der Suche in der Tiefe.  Mit zunehmendem Input wird es nur noch schlimmer.  Es ist wichtig zu verstehen, dass die gew√ºnschten Objekte Bl√§tter sind, daher kann es kein Komplexit√§tsprotokoll <em>(n) geben</em> .  Wenn die Daten zuvor gehasht wurden, ist die Betriebszeit praktisch unabh√§ngig von der Anzahl der Elemente.  Ohne Hashing w√§chst die Komplexit√§t linear und besteht in der Brute-Force-Suche. <br><img src="https://habrastorage.org/webt/py/lc/20/pylc206tjr1oraib8eynbeeatym.png" alt="Bild"></p><br><h2 id="validaciya-dokazatelstva">  Validierung von Beweisen </h2><br><p>  Dies ist die letzte Operation.  Es kommt nicht auf die Struktur des Baumes an, weil  arbeitet mit dem Ergebnis der Beweiserstellung.  Ich glaube, dass die Hauptschwierigkeit hier die Hash-Berechnung ist. <br><img src="https://habrastorage.org/webt/2h/n6/hk/2hn6hkfzrbhxnejuihg2xx2hpoc.png" alt="Bild"></p><br><h1 id="itog">  Zusammenfassung </h1><br><ul><li>  Die Art und Weise, wie Daten gespeichert werden, wirkt sich stark auf die Leistung aus.  Wenn alles in einem Array viel schneller ist.  Und die Serialisierung einer solchen Struktur wird sehr einfach sein.  Die Gesamtmenge an Code wird ebenfalls reduziert. </li><li>  Das Verketten von Knoten mit dem Sortieren vereinfacht den Code erheblich, macht ihn jedoch nicht schneller. </li></ul><br><h1 id="nemnogo-o-rust">  Ein bisschen √ºber Rust </h1><br><ul><li>  Gefiel der <em>Kriterienrahmen</em> .  Es liefert klare Ergebnisse mit Durchschnittswerten und Abweichungen, die mit Grafiken ausgestattet sind.  Kann verschiedene Implementierungen desselben Codes vergleichen. </li><li>  Mangelnde Vererbung beeintr√§chtigt das Leben nicht wesentlich. </li><li>  Makros sind ein m√§chtiger Mechanismus.  Ich habe sie in <a href="">meinen Baumtests</a> zur Parametrisierung verwendet.  Ich denke, wenn sie schlecht verwendet werden, k√∂nnen Sie so etwas tun, dass Sie selbst sp√§ter nicht gl√ºcklich sind. </li><li>  An einigen Stellen langweilte sich der Compiler mit seinen Speicherpr√ºfungen.  Meine anf√§ngliche Annahme, dass der Beginn des Schreibens in Rust so einfach nicht funktioniert hat, war richtig. <br><img src="https://habrastorage.org/webt/1n/uw/mf/1nuwmfwfozbeosqyvhtmbybur7w.png" alt="Bild"></li></ul><br><h1 id="ssylki">  Referenzen </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine vollst√§ndigere Beschreibung des Merkle-Baum-Algorithmus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kriterium - Lasttest-Framework</a> </li><li>  <a href="">merkle.rs - der beliebteste Baum unter Rust</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vector-merkle-tree - meine Baumimplementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">merkle-tree-test-rs - ein Projekt zum Vergleich der Leistung zweier Bibliotheken</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455260/">https://habr.com/ru/post/de455260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455248/index.html">Top Entwicklungsfehler bei der Arbeit mit PostgreSQL</a></li>
<li><a href="../de455250/index.html">Derjenige, der Herzog Nukem wiederbelebt hat: Interview mit Randy Pitchford, Magier von Gearbox</a></li>
<li><a href="../de455252/index.html">.NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t - Teil 1</a></li>
<li><a href="../de455256/index.html">Habr Weekly # 4 / Computex, wie k√∂nnen wir Apple Beta, Durov hungert, BadComedian Katze, warum hat das neuronale Netzwerk nach Pornodarstellern gesucht</a></li>
<li><a href="../de455258/index.html">Die Abstimmung f√ºr die Berichte der Backend-Sektion zum Jubil√§um von DevConfX begann am 21. und 22. Juni in Moskau</a></li>
<li><a href="../de455264/index.html">Sei wie Munch oder ein paar Worte √ºber technische Pflicht</a></li>
<li><a href="../de455268/index.html">Wie alles begann: flexible und faltbare Displays - die Geschichte des Auftretens und Austritts von "Menschen"</a></li>
<li><a href="../de455272/index.html">TheOutloud - Sprechen Sie und teilen Sie Ihre Lieblingsartikel und -geschichten.</a></li>
<li><a href="../de455280/index.html">Antwort des Psychiaters auf den Artikel "Krank-gesund"</a></li>
<li><a href="../de455284/index.html">Alexey Savvateev und die Spieltheorie: "Wie hoch ist die Wahrscheinlichkeit, dass eine Atombombe in den n√§chsten f√ºnf Jahren abgeworfen wird?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>