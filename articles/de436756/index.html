<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇 🚩 👩🏼‍🎨 Isomorphismus eilt zur Rettung 👨‍🌾 🧙🏿 👧🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Isomorphismus" ist eines der Grundkonzepte der modernen Mathematik. Anhand konkreter Beispiele in Haskell und C # werde ich nicht nur die Theorie für...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Isomorphismus eilt zur Rettung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436756/"><p> "Isomorphismus" ist eines der Grundkonzepte der modernen Mathematik.  Anhand konkreter Beispiele in Haskell und C # werde ich nicht nur die Theorie für Nicht-Mathematiker erklären (ohne obskure mathematische Symbole und Begriffe zu verwenden), sondern auch zeigen, wie dies in der täglichen Praxis verwendet werden kann. </p><a name="habracut"></a><br><p>  Das Problem ist, dass die strikte Gleichheit (zum Beispiel 2 + 2 = 4) oft zu streng ist.  Hier ist ein Beispiel: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add</span></span> :: (a, a) -&gt; a add (x, y) = x + y</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">pair</span></span>) { return pair.Item1 + pair.Item2; }</code> </pre> </div></div><br><p>  Es gibt jedoch noch eine weitere - schwierigere und in vielen Situationen viel praktischere - Möglichkeit, dieselbe Funktion <b>in gewissem Sinne</b> zu definieren: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add'</span></span> :: a -&gt; a -&gt; a add' x = \y -&gt; x + y</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Add_</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>) { return y =&gt; x + y; }</code> </pre> </div></div><br><p>  Im Gegensatz zu der offensichtlichen Tatsache, dass beide Funktionen für zwei <i>x, y</i> immer dasselbe Ergebnis liefern, erfüllen sie nicht die strikte Gleichheit: </p><br><ul><li>  Die erste Funktion gibt sofort den Betrag zurück (d. h. führt die Berechnung zum Zeitpunkt des Exports durch). </li><li>  während die zweite Funktion eine andere Funktion zurückgibt (die am Ende die Summe zurückgibt - wenn jemand sie aufruft, wird natürlich keine Berechnung durchgeführt: Dies ist ein Beispiel für eine verzögerte Berechnung und es gibt auch einen Isomorphismus, auf den ich zurückkommen werde etwas später). </li></ul><br><p>  Und das ist "zu streng sein". </p><br><p>  Der Isomorphismus ist "ziemlich streng";  es erfordert keine vollständige, allumfassende Gleichheit, sondern beschränkt sich auf die Gleichheit „in einem bestimmten Sinne“, die immer durch einen bestimmten Kontext bestimmt wird. </p><br><p>  Wie Sie vielleicht erraten haben, sind beide obigen Definitionen isomorph.  Dies bedeutet genau das Folgende: Wenn mir nur einer von ihnen gegeben wird, dann werden mir beide <em>implizit gegeben</em> : alles dank <b>Isomorphismus - ein Zwei-Wege-Konverter von einem in einen anderen</b> .  Fassen Sie die Typen ein wenig zusammen: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> :: ((a, b) → c) → a → b → c curry fxy = f (x, y), uncurry :: (a → b → c) → (a, b) → c uncurry f (x, y) = fxy</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uncurried</span></span>) { return arg1 =&gt; arg2 =&gt; uncurried(Tuple.Create(arg1, arg2)); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">curried</span></span>) { return pair =&gt; curried(pair.Item1)(pair.Item2); }</code> </pre> </div></div><br><p>  ... und jetzt für jedes <em>x, y</em> : </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> add $ x, y = uncurry add' $ (x, y)</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add_</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Create</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>))</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen mehr Mathe für die besonders Neugierigen</b> <div class="spoiler_text"><p>  In der Tat sollte es so aussehen: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> . uncurry = id uncurry . curry = id id x = x</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>, : <span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span>&gt;(<span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">arg</span></span>) =&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">arg</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt;( <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">first</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">second</span></span>) { return arg =&gt; second(first(arg)); } ...  <span class="hljs-selector-tag"><span class="hljs-selector-tag">extension-</span></span> (  <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>   ): <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>, : <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt;( <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">first</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">second</span></span>) { return arg =&gt; second(first(arg)); }</code> </pre> </div></div><br><p>  Ich sollte verstehen, dass "nichts passiert ist".  Da Isomorphismus per Definition ein Zwei-Wege-Transformator ist, können Sie immer 1) eine Sache nehmen, 2) sie in eine andere umwandeln und 3) sie zurück in die erste umwandeln.  Es gibt nur zwei solche Operationen: In der ersten Phase (Nr. 1) stehen nur zwei Optionen zur Auswahl.  Und in beiden Fällen sollte die Operation zu genau dem gleichen Ergebnis führen, als wäre überhaupt nichts passiert (aus diesem Grund ist eine strikte Gleichheit erforderlich - weil sich überhaupt nichts geändert hat und sich nicht „etwas“ geändert hat). </p><br><p>  Darüber hinaus gibt es einen Satz, dass das id-Element immer eindeutig ist.  Beachten Sie, dass die Id-Funktion generisch, polymorph und daher in Bezug auf jeden bestimmten Typ wirklich einzigartig ist. </p></div></div><br><p>  Isomorphismus ist sehr, sehr nützlich, gerade weil er streng ist, aber nicht zu viel.  Es behält bestimmte wichtige Eigenschaften bei (im obigen Beispiel - dasselbe Ergebnis mit denselben Argumenten) und ermöglicht es Ihnen, die Datenstrukturen selbst frei zu transformieren (Träger von isomorphem Verhalten und Eigenschaften).  Und das ist absolut sicher - denn Isomorphismus funktioniert immer in beide Richtungen, was bedeutet, dass Sie jederzeit zurückkehren können, ohne diese „wichtigen Eigenschaften“ zu verlieren.  Ich werde ein weiteres Beispiel nennen, das in der Praxis so nützlich ist, dass es sogar viele "fortgeschrittene" Programmiersprachen wie Haskells unterstützt: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">toLazy</span></span> :: a -&gt; () -&gt; a toLazy x = \_ -&gt; a fromLazy :: (() -&gt; a) -&gt; a fromLazy f = f ()</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lazy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">res</span></span>) { return () =&gt; res; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lazy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">lazy</span></span>) { return lazy(); }</code> </pre> </div></div><br><p>  Dieser Isomorphismus bewahrt das Ergebnis der verzögerten Berechnung selbst - dies ist die „wichtige Eigenschaft“, während die Datenstrukturen unterschiedlich sind. </p><br><p>  Die Schlussfolgerung?  OOP, besonders stark typisiert, arbeitet (erzwungen) auf der Ebene der "strengen Gleichheit".  Und deshalb ist es - im Anschluss an die obigen Beispiele - oft zu streng.  Wenn Sie sich daran gewöhnen, „zu streng“ zu denken (und dies geschieht unmerklich - es dringt in den Programmierer ein, insbesondere wenn er nicht nach Inspiration in der Mathematik sucht), verlieren Ihre Entscheidungen unabsichtlich ihre gewünschte (oder zumindest objektiv mögliche) Flexibilität.  Isomorphismus verstehen - in einer Gemeinschaft mit dem bewussten Versuch, mehr auf die eigenen zu achten <br>  und Fremdcode - es hilft, den Kreis der "wichtigen Eigenschaften" klarer zu definieren und von unnötigen Details zu abstrahieren: nämlich von bestimmten Datenstrukturen, auf die diese "wichtigen Eigenschaften" aufgedruckt sind (sie sind auch "Implementierungsdetails").  Zuallererst ist dies eine Denkweise und erst dann - erfolgreichere (Mikro-) Architekturlösungen und als natürliche Konsequenz ein überarbeiteter Testansatz. </p><br><p>  PS Wenn ich sehe, dass der Artikel davon profitiert hat, werde ich auf die Themen „erfolgreichere (Mikro-) Architekturlösungen“ und „einen überarbeiteten Testansatz“ zurückkommen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436756/">https://habr.com/ru/post/de436756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436746/index.html">So verschlechtern Sie die Leistung, indem Sie sie verbessern</a></li>
<li><a href="../de436748/index.html">Hexapod von Grund auf neu entwickeln (Teil 3) - Kinematik</a></li>
<li><a href="../de436750/index.html">Trendanalyse des russischen YouTube für 2018</a></li>
<li><a href="../de436752/index.html">Der Kuchen ist eine Lüge</a></li>
<li><a href="../de436754/index.html">Q2VKPT: Quake II mit realistischer Beleuchtung komplett neu geschrieben</a></li>
<li><a href="../de436762/index.html">Couchbase bei Telecom</a></li>
<li><a href="../de436764/index.html">Erstellen Sie Ihre jsfiddle, Teil 1</a></li>
<li><a href="../de436768/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 282 (vom 14. bis 20. Januar)</a></li>
<li><a href="../de436770/index.html">Russische Mobilfunkbetreiber verdienen in den Wolken</a></li>
<li><a href="../de436772/index.html">Gesetz "Über Kommunikation" und Verwundbarkeit in Boten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>