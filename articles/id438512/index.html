<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌸 👩🏼‍💼 🗃️ Kompresi data Huffman 👼🏾 👨🏼‍🏫 👨‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entri 
 Pada artikel ini saya akan berbicara tentang algoritma Huffman yang terkenal, serta penerapannya dalam kompresi data. 

 Sebagai hasilnya, kam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompresi data Huffman</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438512/"><h2>  Entri </h2><br>  Pada artikel ini saya akan berbicara tentang algoritma Huffman yang terkenal, serta penerapannya dalam kompresi data. <br><br>  Sebagai hasilnya, kami akan menulis arsip sederhana.  Sudah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang itu di Habré</a> , tetapi tanpa implementasi praktis.  Materi teoritis dari posting saat ini diambil dari pelajaran ilmu komputer sekolah dan buku Robert Lafore "Struktur Data dan Algoritma di Jawa".  Jadi, semuanya ada di bawah jalan! <br><a name="habracut"></a><br><h2>  Sedikit pemikiran </h2><br>  Dalam file teks biasa, satu karakter dikodekan dengan 8 bit (ASCII encoding) atau 16 (Unicode encoding).  Selanjutnya kami akan mempertimbangkan pengkodean ASCII.  Misalnya, ambil baris s1 = "SUSIE MENGATAKAN ITU MUDAH \ n".  Secara total, ada 22 karakter di baris, tentu saja, termasuk spasi dan karakter baris baru - '\ n'.  File yang berisi baris ini akan berbobot 22 * ​​8 = 176 bit.  Pertanyaan segera muncul: apakah rasional menggunakan semua 8 bit untuk mengkodekan 1 karakter?  Kami tidak menggunakan semua karakter ASCII.  Bahkan jika digunakan, akan lebih rasional untuk huruf yang paling sering - S - untuk memberikan kode sesingkat mungkin, dan untuk huruf paling langka - T (atau U, atau '\ n') - untuk memberikan kode yang lebih otentik.  Ini adalah algoritma Huffman: Anda perlu menemukan opsi pengkodean terbaik, di mana file akan memiliki berat minimal.  Sangat normal bahwa panjang kode akan berbeda untuk karakter yang berbeda - ini adalah dasar dari algoritma. <br><br><h3>  Coding </h3><br>  Mengapa tidak memberikan karakter 'S' kode, misalnya, panjang 1 bit: 0 atau 1. Biarkan 1. Maka kita akan memberikan karakter kedua yang paling ditemui - '' (spasi) - 0. Bayangkan, Anda mulai men-decode pesan Anda - string yang dikodekan s1 - dan Anda melihat bahwa kode dimulai dengan 1. Jadi apa yang harus dilakukan: apakah itu karakter S, atau apakah itu karakter lain, misalnya A?  Oleh karena itu, aturan penting muncul: <br><br>  <b>Tidak ada kode yang harus merupakan awalan dari yang lain</b> <br><br>  Aturan ini adalah kunci dalam algoritma.  Oleh karena itu, pembuatan kode dimulai dengan tabel frekuensi, yang menunjukkan frekuensi (jumlah kemunculan) dari masing-masing karakter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/h6/y6/cuh6y658iqqnvb0whujokfbsaeq.jpeg" width="350"></div>  Karakter dengan kejadian terbanyak harus dikodekan dengan jumlah bit sekecil <u>mungkin</u> .  Saya akan memberikan contoh dari salah satu tabel kode yang mungkin: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3j/01/_2/3j01_2tsdi_q790e8yuwa1l41zc.jpeg" width="350"></div>  Dengan demikian, pesan yang disandikan akan terlihat seperti ini: <br><br><pre><code class="plaintext hljs">10 01111 10 110 1111 00 10 010 1110 10 00 110 0110 00 110 10 00 1111 010 10 1110 01110</code> </pre> <br>  Saya memisahkan kode masing-masing karakter dengan spasi.  Ini tidak akan benar-benar terjadi dalam file terkompresi! <br>  <s>Muncul</s> pertanyaan: <s>bagaimana cara salaga ini menghasilkan kode</s> ? Bagaimana cara membuat tabel kode?  Ini akan dibahas di bawah. <br><br><h4>  Membangun pohon huffman </h4><br>  Di sini pohon pencarian biner datang untuk menyelamatkan.  Jangan khawatir, di sini metode pencarian, penyisipan, dan penghapusan tidak diperlukan.  Berikut adalah struktur pohon di java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frequence; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> letter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node leftChild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node rightChild; ... }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node root; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = root; } ... }</code> </pre><br>  Ini bukan kode lengkap, kode lengkapnya ada di bawah. <br><br>  Berikut adalah algoritma pembuatan pohon itu sendiri: <br><br><ol><li>  Buat objek Node untuk setiap karakter dari pesan (baris s1).  Dalam kasus kami, akan ada 9 node (objek Node).  Setiap node terdiri dari dua bidang data: simbol dan frekuensi </li><li>  Buat objek Tree (BinaryTree) untuk masing-masing node Node.  Node menjadi akar pohon. </li><li>  Rekatkan pohon ini dalam antrian prioritas.  Semakin rendah frekuensinya, semakin tinggi prioritas.  Jadi, ketika mengekstraksi, Dervo selalu dipilih dengan frekuensi terendah. </li></ol><br>  Selanjutnya, Anda perlu melakukan hal berikut secara siklis: <br><br><ol><li>  Ekstrak dua pohon dari antrian prioritas dan buat mereka turunan dari simpul baru (simpul yang baru dibuat tanpa surat).  Frekuensi simpul baru sama dengan jumlah frekuensi dua pohon turunan. </li><li>  Untuk simpul ini, buat pohon dengan root di simpul ini.  Rekatkan pohon ini kembali ke antrian prioritas.  (Karena pohon memiliki frekuensi baru, maka kemungkinan besar pohon itu akan sampai ke tempat baru dalam antrian) </li><li>  Lanjutkan langkah 1 dan 2 hingga hanya ada satu pohon yang tersisa dalam antrian - pohon Huffman </li></ol><br>  Pertimbangkan algoritma ini pada baris s1: <br><br><img src="https://habrastorage.org/webt/v4/l2/xn/v4l2xnrj2mzomws6y696cm7o3_q.jpeg"><br><br>  Di sini, simbol "Jika" (linefeed) menunjukkan transisi ke baris baru, "sp" (spasi) adalah spasi. <br><br><h4>  Apa selanjutnya </h4><br>  Kami punya pohon Huffman.  Baiklah  Dan apa hubungannya dengan itu?  <s>Mereka tidak akan mengambilnya secara gratis.</s> Dan kemudian, Anda perlu melacak semua jalur yang mungkin dari akar ke daun pohon.  Mari kita sepakat untuk menetapkan tepi 0 jika mengarah ke keturunan kiri dan 1 jika ke kanan.  Sebenarnya, dalam notasi ini, kode simbol adalah jalur dari akar pohon ke lembar yang berisi simbol yang sama ini. <br><br><img src="https://habrastorage.org/webt/of/pi/k4/ofpik4e7t3afswjddxugb-ddkfa.jpeg"><br><br>  Jadi, tabel kode ternyata.  Perhatikan bahwa jika kita mempertimbangkan tabel ini, kita dapat menyimpulkan tentang "bobot" dari setiap karakter - ini adalah panjang kodenya.  Maka file yang dikompresi akan menimbang: 2 * 3 + 2 * 4 + 3 * 3 + 6 * 2 + 1 * 4 + 1 * 5 + 2 * 4 + 4 * 2 + 1 * 5 = 65 bit.  Awalnya, beratnya 176 bit.  Karenanya, kami menguranginya sebanyak 176/65 = 2,7 kali!  Tapi ini utopia.  Koefisien semacam itu tidak mungkin diperoleh.  Mengapa  Ini akan dibahas sedikit kemudian. <br><br><h3>  Decoding </h3><br>  Yah, mungkin hal paling sederhana yang tersisa adalah decoding.  Saya pikir banyak dari Anda menduga bahwa tidak mungkin hanya membuat file terkompresi tanpa petunjuk bagaimana itu dikodekan - kami tidak akan dapat men-decode itu!  Ya, sulit bagi saya untuk menyadari hal ini, tetapi saya harus membuat file teks table.txt dengan tabel kompresi: <br><br><pre> <code class="plaintext hljs">01110 00 A010 E1111 I110 S10 T0110 U01111 Y1110</code> </pre><br>  Rekam tabel dalam bentuk 'karakter' "kode karakter".  Mengapa 01110 tanpa karakter?  Bahkan, itu dengan simbol, hanya alat java yang digunakan oleh saya ketika mengeluarkan ke file, karakter baris baru - '\ n' - dikonversi ke baris baru (tidak peduli seberapa bodoh kedengarannya).  Oleh karena itu, baris kosong di atas adalah karakter untuk kode 01110. Untuk kode 00, karakter adalah spasi di awal baris.  Saya harus segera mengatakan bahwa metode <s>kami</s> menyimpan tabel ini mungkin mengklaim yang paling tidak rasional.  Tetapi sederhana untuk dipahami dan diimplementasikan.  Saya akan senang mendengar rekomendasi Anda di komentar mengenai optimasi. <br><br>  Memiliki tabel ini sangat mudah untuk diterjemahkan.  Ingat aturan apa yang dipandu oleh kami saat membuat pengodean: <br><br>  <b>Tidak ada kode yang harus diawali kode lain</b> <br><br>  Di sinilah ia memainkan peran fasilitasi.  Kami membaca berurutan sedikit demi sedikit dan, segera setelah string yang diterima d, yang terdiri dari bit yang dibaca, cocok dengan pengkodean yang sesuai dengan karakter karakter, kami segera tahu bahwa karakter karakter telah dikodekan (dan hanya itu!).  Selanjutnya, kita menulis karakter di baris decoding (baris yang berisi pesan yang didekodekan), nol baris d, dan kemudian membaca file yang disandikan. <br><br><h2>  Implementasi </h2><br>  Saatnya <s>mempermalukan kode saya dengan</s> menulis arsip.  Sebut saja Kompresor. <br><br>  Mari kita mulai dari awal.  Pertama, kita menulis kelas Node: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frequence;<span class="hljs-comment"><span class="hljs-comment">// private char letter;// private Node leftChild;//  private Node rightChild;//  public Node(char letter, int frequence) { //,  this.letter = letter; this.frequence = frequence; } public Node() {}//    (.       ) public void addChild(Node newNode) {//  if (leftChild == null)//  =&gt;  =&gt;    leftChild = newNode; else { if (leftChild.getFrequence() &lt;= newNode.getFrequence()) // ,   rightChild = newNode;// ,     else { rightChild = leftChild; leftChild = newNode; } } frequence += newNode.getFrequence();//  } public Node getLeftChild() { return leftChild; } public Node getRightChild() { return rightChild; } public int getFrequence() { return frequence; } public char getLetter() { return letter; } public boolean isLeaf() {//   return leftChild == null &amp;&amp; rightChild == null; } }</span></span></code> </pre><br>  Sekarang pohonnya: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node root; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = root; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFrequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.getFrequence(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root; } }</code> </pre><br>  Antrian Prioritas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList;<span class="hljs-comment"><span class="hljs-comment">//-,      class PriorityQueue { private ArrayList&lt;BinaryTree&gt; data;//  private int nElems;//-    public PriorityQueue() { data = new ArrayList&lt;BinaryTree&gt;(); nElems = 0; } public void insert(BinaryTree newTree) {// if (nElems == 0) data.add(newTree); else { for (int i = 0; i &lt; nElems; i++) { if (data.get(i).getFrequence() &gt; newTree.getFrequence()) {//     data.add(i, newTree);// . ,  c       1  break;//       } if (i == nElems - 1) data.add(newTree); } } nElems++;// -   1 } public BinaryTree remove() {//   BinaryTree tmp = data.get(0);//   data.remove(0);//,  nElems--;// -   1 return tmp;//  (   ) } }</span></span></code> </pre><br>  Kelas yang menciptakan pohon Huffman: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HuffmanTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>;<span class="hljs-comment"><span class="hljs-comment">//   private String myString;// private BinaryTree huffmanTree;//  private int[] freqArray;//  private String[] encodingArray;//  //----------------constructor---------------------- public HuffmanTree(String newString) { myString = newString; freqArray = new int[ENCODING_TABLE_SIZE]; fillFrequenceArray(); huffmanTree = getHuffmanTree(); encodingArray = new String[ENCODING_TABLE_SIZE]; fillEncodingArray(huffmanTree.getRoot(), "", ""); } //--------------------frequence array------------------------ private void fillFrequenceArray() { for (int i = 0; i &lt; myString.length(); i++) { freqArray[(int)myString.charAt(i)]++; } } public int[] getFrequenceArray() { return freqArray; } //------------------------huffman tree creation------------------ private BinaryTree getHuffmanTree() { PriorityQueue pq = new PriorityQueue(); //   for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) {//     Node newNode = new Node((char) i, freqArray[i]);//    Node BinaryTree newTree = new BinaryTree(newNode);//  Node  BinaryTree pq.insert(newTree);//   } } while (true) { BinaryTree tree1 = pq.remove();//    . try { BinaryTree tree2 = pq.remove();//     Node newNode = new Node();//  Node newNode.addChild(tree1.getRoot());//      newNode.addChild(tree2.getRoot()); pq.insert(new BinaryTree(newNode); } catch (IndexOutOfBoundsException e) {//     return tree1; } } } public BinaryTree getTree() { return huffmanTree; } //-------------------encoding array------------------ void fillEncodingArray(Node node, String codeBefore, String direction) {//   if (node.isLeaf()) { encodingArray[(int)node.getLetter()] = codeBefore + direction; } else { fillEncodingArray(node.getLeftChild(), codeBefore + direction, "0"); fillEncodingArray(node.getRightChild(), codeBefore + direction, "1"); } } String[] getEncodingArray() { return encodingArray; } public void displayEncodingArray() {//  fillEncodingArray(huffmanTree.getRoot(), "", ""); System.out.println("======================Encoding table===================="); for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) { System.out.print((char)i + " "); System.out.println(encodingArray[i]); } } System.out.println("========================================================"); } //----------------------------------------------------- String getOriginalString() { return myString; } }</span></span></code> </pre><br>  Kelas yang mengandung encode / decode: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HuffmanOperator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>;<span class="hljs-comment"><span class="hljs-comment">//  private HuffmanTree mainHuffmanTree;//  (   ) private String myString;//  private int[] freqArray;//  private String[] encodingArray;//  private double ratio;//  public HuffmanOperator(HuffmanTree MainHuffmanTree) {//for compress this.mainHuffmanTree = MainHuffmanTree; myString = mainHuffmanTree.getOriginalString(); encodingArray = mainHuffmanTree.getEncodingArray(); freqArray = mainHuffmanTree.getFrequenceArray(); } public HuffmanOperator() {}//for extract; //---------------------------------------compression----------------------------------------------------------- private String getCompressedString() { String compressed = ""; String intermidiate = "";// (  ) //System.out.println("=============================Compression======================="); //displayEncodingArray(); for (int i = 0; i &lt; myString.length(); i++) { intermidiate += encodingArray[myString.charAt(i)]; } //      .       8=&gt; //    ( 1,  ) byte counter = 0;//     (   : 0&lt;=counter&lt;8&lt;127) for (int length = intermidiate.length(), delta = 8 - length % 8; counter &lt; delta ; counter++) {//delta -    intermidiate += "0"; } // -         compressed = String.format("%8s", Integer.toBinaryString(counter &amp; 0xff)).replace(" ", "0") + intermidiate; //  setCompressionRatio(); //System.out.println("==============================================================="); return compressed; } private void setCompressionRatio() {//   double sumA = 0, sumB = 0;//A-the original sum for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) { sumA += 8 * freqArray[i]; sumB += encodingArray[i].length() * freqArray[i]; } } ratio = sumA / sumB; } public byte[] getBytedMsg() {//final compression StringBuilder compressedString = new StringBuilder(getCompressedString()); byte[] compressedBytes = new byte[compressedString.length() / 8]; for (int i = 0; i &lt; compressedBytes.length; i++) { compressedBytes[i] = (byte) Integer.parseInt(compressedString.substring(i * 8, (i + 1) * 8), 2); } return compressedBytes; } //---------------------------------------end of compression---------------------------------------------------------------- //------------------------------------------------------------extract----------------------------------------------------- public String extract(String compressed, String[] newEncodingArray) { String decompressed = ""; String current = ""; String delta = ""; encodingArray = newEncodingArray; //displayEncodingArray(); // -   for (int i = 0; i &lt; 8; i++) delta += compressed.charAt(i); int ADDED_ZEROES = Integer.parseInt(delta, 2); for (int i = 8, l = compressed.length() - ADDED_ZEROES; i &lt; l; i++) { //i = 8, ..      -   current += compressed.charAt(i); for (int j = 0; j &lt; ENCODING_TABLE_SIZE; j++) { if (current.equals(encodingArray[j])) {//  decompressed += (char)j;//   current = "";//    } } } return decompressed; } public String getEncodingTable() { String enc = ""; for (int i = 0; i &lt; encodingArray.length; i++) { if (freqArray[i] != 0) enc += (char)i + encodingArray[i] + '\n'; } return enc; } public double getCompressionRatio() { return ratio; } public void displayEncodingArray() {//  System.out.println("======================Encoding table===================="); for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { //if (freqArray[i] != 0) { System.out.print((char)i + " "); System.out.println(encodingArray[i]); //} } System.out.println("========================================================"); } }</span></span></code> </pre><br>  Kelas yang memfasilitasi penulisan ke file: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Closeable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileOutputHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> File outputFile; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileOutputStream fileOutputStream; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileOutputHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> FileNotFoundException </span></span>{ outputFile = file; fileOutputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(outputFile); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.write(msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.write(msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (PrintWriter pw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(outputFile)) { pw.write(msg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">" ,     !"</span></span>); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ close(); } }</code> </pre><br>  Kelas yang memfasilitasi membaca dari file: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.EOFException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.InputStreamReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Closeable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileInputHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileInputStream fileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BufferedReader fileBufferedReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileInputHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileInputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); fileBufferedReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(fileInputStream)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = fileInputStream.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur == -<span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">//   throw new EOFException(); return (byte)cur; } public String readLine() throws IOException { return fileBufferedReader.readLine(); } @Override public void close() throws IOException{ fileInputStream.close(); } }</span></span></code> </pre><br>  Nah, dan kelas utama: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.charset.MalformedInputException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Files; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.NoSuchFileException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Paths; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.EOFException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {<span class="hljs-comment"><span class="hljs-comment">//       if (args[0].equals("--compress") || args[0].equals("-c")) compress(args[1]); else if ((args[0].equals("--extract") || args[0].equals("-x")) &amp;&amp; (args[2].equals("--table") || args[2].equals("-t"))) { extract(args[1], args[3]); } else throw new IllegalArgumentException(); } catch (ArrayIndexOutOfBoundsException | IllegalArgumentException e) { System.out.println("    "); System.out.println(" Readme.txt"); e.printStackTrace(); } } public static void compress(String stringPath) throws IOException { List&lt;String&gt; stringList; File inputFile = new File(stringPath); String s = ""; File compressedFile, table; try { stringList = Files.readAllLines(Paths.get(inputFile.getAbsolutePath())); } catch (NoSuchFileException e) { System.out.println(" ,     !"); return; } catch (MalformedInputException e) { System.out.println("    "); return; } for (String item : stringList) { s += item; s += '\n'; } HuffmanOperator operator = new HuffmanOperator(new HuffmanTree(s)); compressedFile = new File(inputFile.getAbsolutePath() + ".cpr"); compressedFile.createNewFile(); try (FileOutputHelper fo = new FileOutputHelper(compressedFile)) { fo.writeBytes(operator.getBytedMsg()); } //create file with encoding table: table = new File(inputFile.getAbsolutePath() + ".table.txt"); table.createNewFile(); try (FileOutputHelper fo = new FileOutputHelper(table)) { fo.writeString(operator.getEncodingTable()); } System.out.println("   : " + compressedFile.getAbsolutePath()); System.out.println("    " + table.getAbsolutePath()); System.out.println("     !"); double idealRatio = Math.round(operator.getCompressionRatio() * 100) / (double) 100;//  double realRatio = Math.round((double) inputFile.length() / ((double) compressedFile.length() + (double) table.length()) * 100) / (double)100;//  System.out.println("    " + idealRatio); System.out.println("      " + realRatio); } public static void extract(String filePath, String tablePath) throws FileNotFoundException, IOException { HuffmanOperator operator = new HuffmanOperator(); File compressedFile = new File(filePath), tableFile = new File(tablePath), extractedFile = new File(filePath + ".xtr"); String compressed = ""; String[] encodingArray = new String[ENCODING_TABLE_SIZE]; //read compressed file //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!check here: try (FileInputHelper fi = new FileInputHelper(compressedFile)) { byte b; while (true) { b = fi.readByte();//method returns EOFException compressed += String.format("%8s", Integer.toBinaryString(b &amp; 0xff)).replace(" ", "0"); } } catch (EOFException e) { } //-------------------- //read encoding table: try (FileInputHelper fi = new FileInputHelper(tableFile)) { fi.readLine();//skip first empty string encodingArray[(byte)'\n'] = fi.readLine();//read code for '\n' while (true) { String s = fi.readLine(); if (s == null) throw new EOFException(); encodingArray[(byte)s.charAt(0)] = s.substring(1, s.length()); } } catch (EOFException ignore) {} extractedFile.createNewFile(); //extract: try (FileOutputHelper fo = new FileOutputHelper(extractedFile)) { fo.writeString(operator.extract(compressed, encodingArray)); } System.out.println("    " + extractedFile.getAbsolutePath()); } }</span></span></code> </pre><br>  File instruksi readme.txt terserah Anda untuk menulis sendiri :-) <br><br><h2>  Kesimpulan </h2><br>  Mungkin ini yang ingin saya katakan.  Jika Anda memiliki sesuatu untuk dikatakan tentang <s>ketidakmampuan saya untuk</s> perbaikan dalam kode, algoritma, dan optimasi apa pun secara umum, jangan ragu untuk menulis.  Jika saya salah paham sesuatu, juga menulis.  Saya akan senang mendengar dari Anda di komentar! <br><br><h3>  PS </h3><br>  Ya, ya, saya masih di sini, karena saya tidak lupa tentang koefisien.  Untuk baris s1, tabel penyandian memiliki berat 48 byte - jauh lebih banyak daripada file asli, dan mereka tidak melupakan nol tambahan (jumlah nol yang ditambahkan adalah 7) =&gt; rasio kompresi akan kurang dari satu: 176 / (65 + 48 * 8 + 7) = 0,38.  Jika Anda juga memperhatikan ini, maka <s>tidak hanya di wajah</s> Anda sudah selesai.  Ya, implementasi ini akan sangat tidak efisien untuk file kecil.  Tetapi apa yang terjadi pada file besar?  Ukuran file jauh melebihi ukuran tabel penyandian.  Di sini algoritma berfungsi sebagaimana mestinya!  Sebagai contoh, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">monolog Faust,</a> pengarsipan memberikan koefisien nyata (tidak ideal) sama dengan 1,46 - hampir satu setengah kali!  Dan ya, file itu seharusnya dalam bahasa Inggris. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438512/">https://habr.com/ru/post/id438512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438498/index.html">Bagaimana cara mempersiapkan wawancara dengan cepat, yang akan memiliki pertanyaan tentang algoritma dan teknologi pemrosesan informasi?</a></li>
<li><a href="../id438500/index.html">Sisi baiknya: bagaimana Optimus Prime membawa Kingston dan HyperX ke CES 2019</a></li>
<li><a href="../id438506/index.html">Musim dingin kedua saya tanpa salju atau magistrasi di Belgia</a></li>
<li><a href="../id438508/index.html">Aktivitas otak manusia pertama kali diterjemahkan ke dalam ucapan yang jelas</a></li>
<li><a href="../id438510/index.html">Komposisi versus pewarisan, pola tim dan pengembangan game secara umum</a></li>
<li><a href="../id438514/index.html">Bagaimana saya belum bekerja selama setahun di Sberbank</a></li>
<li><a href="../id438516/index.html">Kapan harus menyimpan panjang array ke variabel lokal di C #</a></li>
<li><a href="../id438518/index.html">Membuat jsfiddle Anda, bagian 2</a></li>
<li><a href="../id438522/index.html">Equaliser strategis</a></li>
<li><a href="../id438524/index.html">Arsitektur aplikasi flutter 101: Vanilla, Scoped Model, BLoC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>