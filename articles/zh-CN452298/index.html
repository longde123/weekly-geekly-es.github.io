<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎚️ 👨🏽‍⚕️ 🏺 高负载.NET服务中的垃圾收集优化 👌 🎊 👃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="每天，来自全球数千个组织的数万名员工在Pyrus工作。 我们认为服务的响应能力（处理请求的速度）是一项重要的竞争优势，因为它直接影响用户体验。 对我们而言，关键指标是“慢查询的百分比”。 在研究其行为时，我们注意到应用程序服务器上每隔一分钟就有大约1000 ms的暂停时间。 在这些时间间隔内，服务器...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>高负载.NET服务中的垃圾收集优化</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452298/">每天，来自全球数千个组织的数万名员工在Pyrus工作。 我们认为服务的响应能力（处理请求的速度）是一项重要的竞争优势，因为它直接影响用户体验。 对我们而言，关键指标是“慢查询的百分比”。 在研究其行为时，我们注意到应用程序服务器上每隔一分钟就有大约1000 ms的暂停时间。 在这些时间间隔内，服务器不响应，并且出现几十个请求的队列。 本文将讨论在应用程序中寻找由垃圾收集引起的瓶颈的原因并消除瓶颈。 <br><br><img src="https://habrastorage.org/webt/fu/1s/j9/fu1sj9ixpj4nc633ikhwblbhlfs.jpeg"><br><a name="habracut"></a><br> 现代编程语言可以分为两组。 在诸如C / C ++或Rust的语言中，使用了手动内存管理，因此程序员花费更多的时间编写代码，管理对象的生存期，然后进行调试。 同时，由于内存使用不当引起的错误是最难以调试的，因此，大多数现代开发都是使用具有自动内存管理功能的语言进行的。 这些包括，例如，Java，C＃，Python，Ruby，Go，PHP，JavaScript等。 程序员可以节省开发时间，但是您必须支付程序通常在垃圾回收上花费的额外执行时间-释放程序中没有链接的对象所占用的内存。 在小型程序中，这个时间可以忽略不计，但是随着对象数量的增加和其创建强度的增加，垃圾回收开始对程序的总执行时间做出显着贡献。 <br><br>  Pyrus Web服务器在.NET平台上运行，该平台使用自动内存管理。 大多数垃圾收集都是``阻止世界''，即 在工作时，他们停止了应用程序的所有线程。 非阻塞（后台）程序集实际上也会停止所有线程，但是会持续很短的时间。 在线程阻塞期间，服务器不处理请求，现有请求被冻结，新请求被添加到队列中。 结果，直接降低了垃圾收集时处理的请求，并且由于累积的队列，垃圾收集完成后立即处理请求的速度变慢。 这会使指标“慢查询的百分比”恶化。 <br><br> 有了最近出版的《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Konrad Kokosa：Pro .NET内存管理》</a> （关于我们如何在两天内将其第一份副本带到俄罗斯，您可以写一篇单独的文章）的书，我们完全致力于.NET中的内存管理，我们开始研究此问题。 <br><br><h2> 测量值 </h2><br> 为了分析Pyrus Web服务器，我们使用了PerfView实用程序（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/Microsoft/perfview</a> ），该实用程序经过了改进，可用于分析.NET应用程序。 该实用程序基于Windows事件跟踪（ETW）引擎，并且对配置文件应用程序的性能影响很小，因此可以在战斗服务器上使用。 此外，对性能的影响取决于事件的类型和收集的信息。 我们不收集任何东西-该应用程序照常工作。 另外，PerfView不需要重新编译或重新启动应用程序。 <br><br> 使用/ GCCollectOnly参数运行PerfView跟踪（跟踪时间为1.5小时）。 在这种模式下，它仅收集垃圾收集事件，并且对性能的影响最小。 让我们看一下“内存组/ GCStats”跟踪报告，并在其中总结垃圾收集器事件： <br><br><img src="https://habrastorage.org/webt/v4/ia/cd/v4iacdyso10-0toycwyijfm0zbm.png"><br><br> 在这里，我们可以立即看到几个有趣的指标： <br><ul><li> 第二代的平均构建暂停时间为700毫秒，最大暂停时间约为一秒钟。 该图显示了.NET应用程序中所有线程停止的时间，特别是，此暂停将添加到所有已处理的请求中。 <br></li><li> 第2代的装配件数与第1代相当，并且略少于第0代的装配件数。 <br></li><li> 诱导列列出了第二代中的53个装配。 诱导程序集是显式调用GC.Collect（）的结果。 在我们的代码中，没有找到对该方法的单个调用，这意味着应归咎于应用程序使用的某些库。 <br></li></ul><br> 让我们解释一下有关垃圾收集数量的观察。 将对象除以它们的生存期的想法是基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">世代假设的</a> ：创建的对象中有很大一部分会很快死亡，而其他大多数对象的寿命很长（换句话说，具有“平均”生存期的对象很少）。 在这种模式下，.NET垃圾收集器将被监禁，并且在这种模式下，第二代程序集应该比第0代小得多。 也就是说，为了使垃圾收集器最佳运行，我们必须根据世代假设调整应用程序的工作。 让我们将规则表述如下：对象必须要么死掉而又不存活到老一代，要么必须生存下去并永远存在。 该规则也适用于其他使用自动内存管理并按代分离的平台，例如Java。 <br><br> 我们感兴趣的数据可以从GCStats报告中的另一个表中提取： <br><br><img src="https://habrastorage.org/webt/m5/7y/je/m57yjedgbkwfpbiwmjkvnbhgl4o.png"><br><br> 在某些情况下，应用程序尝试创建大对象（在.NET Framework中，在LOH中创建了大于85,000字节的对象-大对象堆），它必须等待第二代程序集的完成，该程序在后台并行发生。 分配器的这些暂停没有垃圾回收器的暂停那么重要，因为它们仅影响一个线程。 在此之前，我们使用.NET Framework 4.6.1版本，并且在Microsoft 4.7.1版本中最终确定了垃圾收集器，现在它允许您在第二代的后台构建期间在大对象堆中分配内存： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//docs.microsoft.com / ru-ru / dotnet /框架/最新消息/＃common-language-runtime-clr</a> <br> 因此，我们当时升级到了最新版本4.7.2。 <br><br><h2> 第二代构建 </h2><br> 为什么我们有这么多的上一代产品？ 第一个假设是我们有内存泄漏。 为了检验这个假设，让我们看一下第二代的大小（我们在Zabbix中设置了对相应性能计数器的监视）。 从2台Pyrus服务器的第二代大小的图表中可以看出，它的大小先增大（主要是由于缓存的填充），然后又稳定了（图形上的大故障-定期重启Web服务以更新版本）： <br><br><img src="https://habrastorage.org/webt/gg/lc/ce/gglcce4tssnhzgcjfhesec9rcja.png"><br><br> 这意味着没有明显的内存泄漏，即，由于另一个原因，发生了大量的第二代程序集。 下一个假设是存在大量内存流量，即许多对象属于第二代，并且许多对象在那里死亡。  PerfView具有/ GCOnly模式来查找此类对象。 在跟踪报告中，我们要注意“第二代对象死亡（粗采样）堆栈”，其中包含第二代中死亡的对象的选择，以及这些对象创建位置的调用堆栈。 在这里，我们看到以下结果： <br><br><img src="https://habrastorage.org/webt/h7/r2/d0/h7r2d0htyxsnaqrr_ekn_ybilti.png"><br><br> 打开该行之后，我们在内部看到了代码中那些位置的调用堆栈，这些位置创建了直到第二代的对象。 其中包括： <br><ul><li>  System.Byte []如果查看内部，我们将看到一半以上是用于JSON序列化的缓冲区： <br></li></ul><br><img src="https://habrastorage.org/webt/la/up/6v/laup6v0mho5e1tbwjfkfmsgdhog.png"><br><br><ul><li> 插槽[System.Int32] []（这是HashSet实现的一部分），System.Int32 []等。 这是我们的代码，用于计算客户端缓存-该用户看到的目录，表单，列表，朋友等，并在其浏览器或移动应用程序中缓存： <br></li></ul><br><img src="https://habrastorage.org/webt/dx/et/jy/dxetjyvj2ande72qrod6leza6i8.png"><br><br><img src="https://habrastorage.org/webt/v6/k6/r-/v6k6r-wq0qeof0edb6h5jvct-he.png"><br><br> 有趣的是，JSON和计算客户端缓存的缓冲区都是存在于同一请求上的所有临时对象。 他们为什么不辜负第二代？ 请注意，所有这些对象都是相当大的数组。 并且在大于85000字节的大小下，用于它们的内存分配在大对象堆中，该对象仅与第二代一起收集。 <br><br> 要进行检查，请在perfview / GCOnly结果中打开“ GC Heap Alloc忽略免费（粗采样）堆栈”部分。 在这里，我们看到LargeObject行，其中PerfView将大对象的创建分组，在内部，我们看到的是与之前分析中相同的所有数组。 我们承认垃圾收集器出现问题的根本原因：我们创建了许多临时的大对象。 <br><br><img src="https://habrastorage.org/webt/sy/kr/lk/sykrlkgbmvl9jyny5hl1_ftg4ee.png"><br><br><img src="https://habrastorage.org/webt/f9/6q/mp/f96qmplnj4devma1buedg6fpo8q.png"><br><br><h2>  Pyrus系统的变化 </h2><br> 根据测量结果，我们确定了进一步工作的主要领域：在计算客户端缓存和JSON序列化时与大型对象的斗争。 有几种解决此问题的方法： <br><ul><li> 最简单的事情是不创建大型对象。 例如，如果在顺序数据转换A-&gt; B-&gt; C中使用大缓冲区B，则有时可以通过将它们转换为A-&gt; C并消除对象B的创建来组合这些转换。此选项并非始终适用，但是最简单，最有效的方法。 <br></li><li> 对象池。 无需不断创建新对象并扔掉它们，而是加载垃圾收集器，我们可以存储自由对象的集合。 在最简单的情况下，当我们需要一个新对象时，我们从池中获取它，如果池为空，则创建一个新对象。 当我们不再需要该对象时，我们将其返回到池中。 一个很好的例子是.NET Core中的ArrayPool，它也可以作为.System.Buffers Nuget包的一部分在.NET Framework中使用。 <br></li><li> 使用小物体代替大物体。 <br></li></ul><br> 让我们分别考虑大型对象的两种情况-计算客户端缓存和JSON序列化。 <br><br><h2> 客户端缓存计算 </h2><br>  Pyrus Web客户端和移动应用程序缓存用户可用的数据（项目，表单，用户等）。缓存用于加快工作速度，在脱机模式下工作也是必需的。 缓存在服务器上计算，然后传输到客户端。 它们对于每个用户都是独立的，因为它们取决于他们的访问权限，并且经常在例如更改其有权访问的目录时进行更新。 <br><br> 因此，在服务器上定期执行许多客户端缓存计算，并且创建了许多临时的短期对象。 如果用户是一个大型组织，则他可以分别访问许多对象，因此对他而言客户端缓存将很大。 这就是为什么我们在大型对象堆中看到了为大型临时数组分配内存的原因。 <br><br> 让我们分析为摆脱大型对象的创建而提议的选项： <br><ul><li> 彻底处理大物件。 此方法不适用，因为数据准备算法除其他外使用集的排序和并集，并且它们需要临时缓冲区。 <br></li><li> 使用对象池。 这种方法有困难： <br><ul><li> 使用了各种集合以及其中的元素类型：使用了HashSet，List和Array（可以将后两个集合结合使用）。  Int32，Int64以及各种数据类都存储在集合中。 对于每种使用的类型，您将需要自己的池，该池还将存储不同大小的集合。 <br></li><li> 收藏品的使用寿命很困难。 为了从池中获得收益，池中的对象将在使用后返回。 如果将对象用于一种方法，则可以完成此操作。 但是在我们的情况下情况更加复杂，因为许多大对象在方法之间移动，被放入数据结构中，然后被转移到其他结构等。 <br></li><li> 实施。 有Microsoft的ArrayPool，但我们仍然需要List和HashSet。 我们找不到合适的库，因此我们必须自己实现这些类。 </li></ul></li><li> 使用小物件。 一个大数组可以分为几个小块，我不会加载大对象堆，而是在第0代中创建，然后在第1和第2代中遵循标准路径。 我们希望它们不会辜负第二代，但会在第0代，或者在极端情况下在第1代被垃圾收集器收集。 这种方法的优点是对现有代码的更改最少。 难点： <br><ul><li> 实施。 我们找不到任何合适的库，因此我们必须自己编写类。 缺少库是可以理解的，因为方案“不加载大对象堆的集合”的范围非常狭窄。 </li></ul></li></ul><br> 我们决定走第三条路线， <strike>发明自行车</strike>来编写List和HashSet，而不是加载大对象堆。 <br><br><h2> 件清单 </h2><br> 我们的ChunkedList &lt;T&gt;实现了标准接口，包括IList &lt;T&gt;，该接口只需对现有代码进行最少的更改即可。 是的，我们使用的Newtonsoft.Json库能够自动序列化它，因为它实现了IEnumerable &lt;T&gt;： <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ChunkedList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">ICollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>, <span class="hljs-title"><span class="hljs-title">IList</span></span>, <span class="hljs-title"><span class="hljs-title">ICollection</span></span>, <span class="hljs-title"><span class="hljs-title">IReadOnlyList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IReadOnlyCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; {</code> </pre> <br> 标准列表&lt;T&gt;具有以下字段：元素数组和填充元素的数量。 在ChunkedList &lt;T&gt;中，有一个元素数组数组，完全填充的数组数量，最后一个数组中的元素数量。 每个少于85,000个字节的元素数组： <br><br><img src="https://habrastorage.org/webt/72/zj/js/72zjjs9q6lcfud-l7nq8cy5prdi.png"><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T[][] chunks; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentChunk; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentChunkSize;</code> </pre> <br> 由于ChunkedList &lt;T&gt;相当复杂，因此我们在上面编写了详细的测试。 任何操作都必须在至少两种模式下进行测试：如果“整个”列表可容纳多达85,000个字节，则以“小”模式运行；如果包含多个以上的内容，则以“大”模式进行测试。 此外，对于更改大小的方法（例如，添加），方案甚至更大：“小”-&gt;“小”，“小”-&gt;“大”，“大”-&gt;“大”，“大”-&gt;“小。” 在这里，有很多令人困惑的边界案例，它们的单元测试效果很好。 <br><br> 由于不使用IList接口中的某些方法，因此可以简化这种情况，并且可以将其省略（例如Insert，Remove）。 它们的实施和测试将是相当大的开销。 另外，由于不需要编写新功能，因此简化了编写单元测试的过程，ChunkedList &lt;T&gt;的行为应与List &lt;T&gt;相同。 也就是说，所有测试的组织方式如下：创建List &lt;T&gt;和ChunkedList &lt;T&gt;，对它们执行相同的操作并比较结果。 <br><br> 我们使用BenchmarkDotNet库测量了性能，以确保从List &lt;T&gt;切换到ChunkedList &lt;T&gt;时，我们不会降低代码的速度。 让我们测试一下，例如，将项目添加到列表中： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ChunkedList&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChunkedList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChunkedList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) list.Add(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br> 与相同的测试使用List &lt;T&gt;进行比较。 添加500个元素时的结果（所有元素都适合一个数组）： <br><div class="scrollable-table"><table><tbody><tr><td> 方法 </td><td> 均值 </td><td> 失误 </td><td> 标准差 </td><td>  Gen 0 / 1k Op </td><td>  Gen 1 / 1k Op </td><td>  Gen 2 / 1k Op </td><td> 分配的内存/操作 </td></tr><tr><td> 标准清单 </td><td>  1.415美元 </td><td>  0.0149美元 </td><td>  0.0140美元 </td><td>  0.6847 </td><td>  0.0095 </td><td>  -- </td><td>  4.21 KB </td></tr><tr><td> 块列表 </td><td>  3.728我们 </td><td>  0.0238美元 </td><td>  0.0222我们 </td><td>  0.6943 </td><td>  0.0076 </td><td>  -- </td><td>  4.28 KB </td></tr></tbody></table></div><br> 添加50,000个元素（拆分为多个数组）时的结果： <br><div class="scrollable-table"><table><tbody><tr><td> 方法 </td><td> 均值 </td><td> 失误 </td><td> 标准差 </td><td>  Gen 0 / 1k Op </td><td>  Gen 1 / 1k Op </td><td>  Gen 2 / 1k Op </td><td> 分配的内存/操作 </td></tr><tr><td> 标准清单 </td><td>  146.273我们 </td><td>  3.1466我们 </td><td>  4.8053我们 </td><td>  124.7559 </td><td>  124.7559 </td><td>  124.7559 </td><td>  513.23 KB </td></tr><tr><td> 块列表 </td><td>  287.687我们 </td><td>  1.4630我们 </td><td>  1.2969我们 </td><td>  41.5039 </td><td>  20.5078 </td><td>  -- </td><td>  256.75 KB </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">结果列的详细说明</b> <div class="spoiler_text"><pre> <code class="cs hljs">BenchmarkDotNet=v0<span class="hljs-number"><span class="hljs-number">.11</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>, OS=Windows <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.17763</span></span><span class="hljs-number"><span class="hljs-number">.379</span></span> (<span class="hljs-number"><span class="hljs-number">1809</span></span>/October2018Update/Redstone5) Intel Core i7<span class="hljs-number"><span class="hljs-number">-8700</span></span>K CPU <span class="hljs-number"><span class="hljs-number">3.70</span></span>GHz (Coffee Lake), <span class="hljs-number"><span class="hljs-number">1</span></span> CPU, <span class="hljs-number"><span class="hljs-number">12</span></span> logical and <span class="hljs-number"><span class="hljs-number">6</span></span> physical cores [Host] : .NET Framework <span class="hljs-number"><span class="hljs-number">4.7</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> (CLR <span class="hljs-number"><span class="hljs-number">4.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span><span class="hljs-number"><span class="hljs-number">.42000</span></span>), <span class="hljs-number"><span class="hljs-number">64b</span></span>it RyuJIT-v4<span class="hljs-number"><span class="hljs-number">.7</span></span><span class="hljs-number"><span class="hljs-number">.3324</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> DefaultJob : .NET Framework <span class="hljs-number"><span class="hljs-number">4.7</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> (CLR <span class="hljs-number"><span class="hljs-number">4.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span><span class="hljs-number"><span class="hljs-number">.42000</span></span>), <span class="hljs-number"><span class="hljs-number">64b</span></span>it RyuJIT-v4<span class="hljs-number"><span class="hljs-number">.7</span></span><span class="hljs-number"><span class="hljs-number">.3324</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-comment"><span class="hljs-comment">// * Hints * Outliers ListAdd.StandardList: Default -&gt; 2 outliers were removed ListAdd.ChunkedList: Default -&gt; 1 outlier was removed // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Gen 0/1k Op : GC Generation 0 collects per 1k Operations Gen 1/1k Op : GC Generation 1 collects per 1k Operations Gen 2/1k Op : GC Generation 2 collects per 1k Operations Allocated Memory/Op : Allocated memory per single operation (managed only, inclusive, 1KB = 1024B) 1 us : 1 Microsecond (0.000001 sec)</span></span></code> </pre> <br></div></div><br> 如果您查看显示平均测试执行时间的“平均值”列，您会发现我们的实施仅比标准实施慢2-2.5倍。 考虑到在实际代码中，带有列表的操作仅是所有执行的动作的一小部分，因此这种差异变得微不足道。 但是``Gen 2 / 1k op''（每1000次测试运行中第二代的程序集数量）一栏表明我们已经实现了目标：拥有大量元素的ChunkedList不会在第二代中创建垃圾，这是我们的任务。 <br><br><h2> 件套 </h2><br> 同样，ChunkedHashSet &lt;T&gt;实现ISet &lt;T&gt;接口。 在编写ChunkedHashSet &lt;T&gt;时，我们重用了ChunkedList中已实现的小块逻辑。 为此，我们从.NET参考源中获取了现成的HashSet &lt;T&gt;的实现（可从MIT许可下获得），并将其中的数组替换为ChunkedLists。 <br><br> 在单元测试中，我们还使用与列表相同的技巧：我们将ChunkedHashSet &lt;T&gt;与参考HashSet &lt;T&gt;的行为进行比较。 <br><br> 最后是性能测试。 我们使用的主要操作是集合的并集，这就是我们对其进行测试的原因： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ChunkedHashSet&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChunkedHashSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] source</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChunkedHashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> source) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.UnionWith(arr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br> 与标准HashSet完全相同的测试。 小套的第一次测试： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] { Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).ToArray(), }</code> </pre> <br><div class="scrollable-table"><table><tbody><tr><td> 方法 </td><td> 均值 </td><td> 失误 </td><td> 标准差 </td><td>  Gen 0 / 1k Op </td><td>  Gen 1 / 1k Op </td><td>  Gen 2 / 1k Op </td><td> 分配的内存/操作 </td></tr><tr><td> 标准哈希集 </td><td>  30.16美元 </td><td>  0.1046我们 </td><td>  0.0979美元 </td><td>  9.3079 </td><td>  1.6785 </td><td>  -- </td><td>  57.41 KB </td></tr><tr><td> 块哈希集 </td><td>  73.54美元 </td><td>  0.5919我们 </td><td>  0.5247美元 </td><td>  9.5215 </td><td>  1.5869 </td><td>  -- </td><td>  58.84 KB </td></tr></tbody></table></div><br> 大型集合的第二项测试导致了一堆大型对象出现问题： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] { Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">30000</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">60000</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">30000</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>).ToArray(), }</code> </pre> <br><div class="scrollable-table"><table><tbody><tr><td> 方法 </td><td> 均值 </td><td> 失误 </td><td> 标准差 </td><td>  Gen 0 / 1k Op </td><td>  Gen 1 / 1k Op </td><td>  Gen 2 / 1k Op </td><td> 分配的内存/操作 </td></tr><tr><td> 标准哈希集 </td><td>  3,031.30我们 </td><td>  32.0797我们 </td><td>  28.4378我们 </td><td>  699.2188 </td><td>  667.9688 </td><td>  664.0625 </td><td>  4718.23 KB </td></tr><tr><td> 块哈希集 </td><td>  7,189.66我们 </td><td>  25.6319我们 </td><td>  23.9761我们 </td><td>  539.0625 </td><td>  265.6250 </td><td>  7.8125 </td><td>  3280.71 KB </td></tr></tbody></table></div><br> 结果与清单类似。  ChunkedHashSet的速度慢了2-2.5倍，但同时在大型集合上，它对第二代的负载减少了2个数量级。 <br><br><h2>  JSON中的序列化 </h2><br>  Pyrus Web服务器提供了几个使用不同序列化的API。 我们发现了在漫游器使用的API和同步实用程序（以下称为“公共API”）中创建了大型对象。 请注意，API基本上使用自己的序列化，不受此问题的影响。 我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/en/post/227595/</a>中的文章“ 2。 您不知道应用程序的瓶颈在哪里。” 也就是说，主要API已经运行良好，并且随着请求数量和响应中数据量的增加，该问题出现在Public API中。 <br><br> 让我们优化公共API。 通过使用主API的示例，我们知道您可以以流模式将响应返回给用户。 也就是说，您无需创建包含整个响应的中间缓冲区，而是将响应立即写入流中。 <br><br> 通过仔细检查，我们发现在序列化响应的过程中，我们为中间结果创建了一个临时缓冲区（“ content”是一个字节数组，其中包含UTF-8编码的JSON）： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serializer = Newtonsoft.Json.JsonSerializer.Create(...); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] content; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamWriter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UTF8Encoding(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Newtonsoft.Json.JsonTextWriter(sw)) { serializer.Serialize(writer, result); writer.Flush(); content = ms.ToArray(); }</code> </pre> <br> 让我们看看在哪里使用内容。 由于历史原因，公共API基于WCF，因此XML是标准的请求和响应格式。 在我们的例子中，XML响应只有一个'Binary'元素，在其中写入了以Base64编码的JSON： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RawBodyWriter</span></span> : <span class="hljs-title"><span class="hljs-title">BodyWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] _content; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RawBodyWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] content</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { _content = content; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWriteBodyContents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">XmlDictionaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.WriteStartElement(<span class="hljs-string"><span class="hljs-string">"Binary"</span></span>); writer.WriteBase64(_content, <span class="hljs-number"><span class="hljs-number">0</span></span>, _content.Length); writer.WriteEndElement(); } }</code> </pre> <br> 请注意，此处不需要临时缓冲区。  JSON可以立即写入WCF提供给我们的XmlWriter缓冲区，并在Base64中即时对其进行编码。 因此，我们将走第一种方式，摆脱内存分配： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWriteBodyContents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">XmlDictionaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serializer = Newtonsoft.Json.JsonSerializer.Create(...); writer.WriteStartElement(<span class="hljs-string"><span class="hljs-string">"Binary"</span></span>); Stream stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Base64Writer(writer); Var sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamWriter(stream, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UTF8Encoding(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Newtonsoft.Json.JsonTextWriter(sw)) { serializer.Serialize(jsonWriter, _result); jsonWriter.Flush(); } writer.WriteEndElement(); }</code> </pre> <br> 这里的Base64Writer是XmlWriter的简单包装，实现了Stream接口，该接口以Base64的形式写入XmlWriter。 同时，从整个接口来看，仅实现一个Write方法就足够了，该方法在StreamWriter中被调用： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base64Writer</span></span> : <span class="hljs-title"><span class="hljs-title">Stream</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> XmlWriter _writer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base64Writer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">XmlWriter writer</span></span></span><span class="hljs-function">)</span></span> { _writer = writer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { _writer.WriteBase64(buffer, offset, count); } &lt;...&gt; }</code> </pre> <br><h2> 诱导GC </h2><br> 让我们尝试处理神秘的垃圾收集。 我们针对GC.Collect调用重新检查了10次代码，但这失败了。 我设法在PerfView中捕获了这些事件，但是调用堆栈的指示性不是很好（DotNETRuntime / GC /触发事件）： <br><br><img src="https://habrastorage.org/webt/ye/j0/qg/yej0qglbieyx_tg05hdgutajhmc.png"><br><br> 有一个小提示-在引发垃圾回收之前调用RecycleLimitMonitor.RaiseRecycleLimitEvent。 让我们跟踪对RaiseRecycleLimitEvent方法的调用堆栈： <br><br><pre> <code class="cs hljs">RecycleLimitMonitor.RaiseRecycleLimitEvent(...) RecycleLimitMonitor.RecycleLimitMonitorSingleton.AlertProxyMonitors(...) RecycleLimitMonitor.RecycleLimitMonitorSingleton.CollectInfrequently(...) RecycleLimitMonitor.RecycleLimitMonitorSingleton.PBytesMonitorThread(...)</code> </pre> <br> 方法的名称与其功能一致： <br><ul><li> 在RecycleLimitMonitor.RecycleLimitMonitorSingleton的构造函数中，创建一个计时器，该计时器以特定间隔调用PBytesMonitorThread。 <br></li><li>  PBytesMonitorThread收集有关内存使用情况的统计信息，在某些情况下，不经常调用CollectIn。 <br></li><li>  CollectInfrequently调用AlertProxyMonitors，结果为布尔值，如果为true，则调用GC.Collect（）。 他还监视自上次调用垃圾收集器以来经过的时间，并且不经常调用它。 <br></li><li>  AlertProxyMonitors遍历正在运行的IIS Web应用程序的列表，每个都引发相应的RecycleLimitMonitor对象，然后调用RaiseRecycleLimitEvent。 <br></li><li>  RaiseRecycleLimitEvent引发IObserver &lt;RecycleLimitInfo&gt;列表。 处理程序接收RecycleLimitInfo作为参数，在其中可以设置RequestGC标志，该标志将返回到CollectInfrequently，从而引发垃圾回收。 <br></li></ul><br><br> 进一步的调查显示，IObserver &lt;RecycleLimitInfo&gt;处理程序已添加到RecycleLimitMonitor.Subscribe（）方法中，该方法在AspNetMemoryMonitor.Subscribe（）方法中被调用。 另外，默认的IObserver &lt;RecycleLimitInfo&gt;处理程序（RecycleLimitObserver类）挂在AspNetMemoryMonitor类中，该类清除ASP.NET缓存，有时还要求进行垃圾收集。 <br><br> 诱导GC的难题几乎解决了。 仍然需要找出为什么调用此垃圾回收的问题。  RecycleLimitMonitor监视IIS内存的使用（更精确地讲，专用字节数），并且当其使用达到某个限制时，它会以一种相当混乱的算法开始，以引发RaiseRecycleLimitEvent事件。  AspNetMemoryMonitor.ProcessPrivateBytesLimit的值用作内存限制，并且依次包含以下逻辑： <br><ul><li> 如果IIS中的“应用程序池”设置为“专用内存限制（KB）”，则从那里获取以千字节为单位的值 <br></li><li> 否则，对于64位系统，将占用60％的物理内存（对于32位系统，逻辑会更复杂）。 <br></li></ul><br> 调查的结论是：ASP.NET接近其内存限制，并开始定期调用垃圾回收。 未设置“专用内存限制（KB）”，因此ASP.NET被限制为物理内存的60％。 该问题被以下事实掩盖了：在任务管理器服务器上，它显示了很多可用内存，并且似乎丢失了。 我们已将IIS中“应用程序池”设置中的“专用内存限制（KB）”值增加到物理内存的80％。 这鼓励ASP.NET使用更多的可用内存。 我们还添加了对性能计数器“ .NET CLR内存/＃诱导的GC”的监视，以免下次ASP.NET决定其接近内存使用限制时不会丢失。 <br><br><h2> 重复测量 </h2><br> 让我们看看所有这些更改之后垃圾回收发生了什么。 让我们从perfview / GCCollectOnly（跟踪时间-1小时）开始，GCStats报告： <br><br><img src="https://habrastorage.org/webt/8b/l3/fn/8bl3fnxpuymka28coyzbo0r5ak4.png"><br><br> 可以看出，第二代的组件现在比第0代和第1代小2个数量级。 而且，这些组装的时间减少了。 不再观察到诱导组装。 让我们看一下第二代的程序集列表： <br><br><img src="https://habrastorage.org/webt/mx/oy/tv/mxoytvprkypunnhwtao6o6fboai.png"><br><br>  “ Gen”列显示第二代的所有装配都已成为背景（“ 2B”表示第二代，背景）。 即，大多数工作与应用程序的执行并行执行，并且所有线程都在短时间内被阻塞（列“ Pause MSec”）。 让我们看一下创建大对象时的停顿： <br><br><img src="https://habrastorage.org/webt/qp/04/hp/qp04hpcq35buinfnfjn5uuudnyg.png"><br><br> 可以看出，创建大型对象时，此类暂停的次数大大减少了。 <br><br><h2> 总结 </h2><br> 由于文章中描述的更改，可以显着减少第二代组件的数量和持续时间。 我设法找到引起装配的原因并消除它们。 第0代和第1代的程序集数量增加了，但是它们的平均持续时间却减少了（从〜200 ms到〜60 ms）。 第0代和第1代的最大装配时间有所减少，但并没有那么明显。 第二代装配变得更快，长达1000ms的长时间停顿完全消失了。 <br><br> 至于关键指标“慢查询的百分比”，经过所有更改后，它下降了40％。 <br><br> 由于我们的工作，我们意识到需要使用性能计数器来评估内存和垃圾回收情况，并将其添加到Zabbix进行连续监视。 以下是我们需要注意并找出原因的最重要列表（例如，请求流增加，大量传输的数据，应用程序中的错误）： <br><div class="scrollable-table"><table><tbody><tr><td> 绩效柜台 </td><td> 内容描述 </td><td> 什么时候注意 </td></tr><tr><td>  \处理（*）\专用字节 </td><td> 为应用程序分配的内存量 </td><td rowspan="3"> 值远远超过阈值。 作为阈值，您可以从最高每日值中获取2周的中位数。 </td></tr><tr><td>  \ .NET CLR内存（*）\＃Gen 2集合 </td><td> 老一代的内存量 </td></tr><tr><td>  \ .NET CLR内存（*）\大对象堆大小 </td><td> 大对象的内存量 </td></tr><tr><td>  \ .NET CLR内存（*）\％GC时间 </td><td> 花在收集垃圾上的时间百分比 </td><td> 该值大于5％。 </td></tr><tr><td>  \ .NET CLR内存（*）\＃诱导GC </td><td> 诱导组件数 </td><td> 值大于0。 </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452298/">https://habr.com/ru/post/zh-CN452298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452284/index.html">使用eo-learn对土地覆盖进行分类。 第一部分</a></li>
<li><a href="../zh-CN452288/index.html">情况：美国移动运营商被指控订户地理数据非法交易</a></li>
<li><a href="../zh-CN452290/index.html">黑客在PHDays破产时会错过什么</a></li>
<li><a href="../zh-CN452294/index.html">网络研讨会“员工-后门：现代社会工程技术”</a></li>
<li><a href="../zh-CN452296/index.html">积极Hack Day 9：竞争情报竞赛5月18日</a></li>
<li><a href="../zh-CN452302/index.html">PyConRu-2019初步计划：两名Python核心开发人员，Anaconda，Intel，JetBrains，Yandex的发言人</a></li>
<li><a href="../zh-CN452304/index.html">OpenAI AI学习写诗，文章和新闻</a></li>
<li><a href="../zh-CN452306/index.html">金融科技的去向，如何计算单位经济学以及为什么要发展国内企业家精神。 Mitap Yandex.Money</a></li>
<li><a href="../zh-CN452310/index.html">设置DO-RA小工具的网络销售渠道</a></li>
<li><a href="../zh-CN452312/index.html">英国电信将向用户赔偿断开连接的费用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>