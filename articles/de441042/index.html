<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî∫ üé§ üéá Generieren von Multi-Brand-Multi-Plattform-Symbolen mit Sketch und einem Node.js-Skript - Teil 2 üëäüèª üö∂üèΩ üìµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil eines Beitrags √ºber die Erstellung einer Pipeline, die eine Skizzendatei aufnehmen und alle in der Datei enthaltenen Symbole ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generieren von Multi-Brand-Multi-Plattform-Symbolen mit Sketch und einem Node.js-Skript - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/441042/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  Dies ist der zweite Teil eines Beitrags √ºber die Erstellung einer Pipeline, die eine Skizzendatei aufnehmen und alle in der Datei enthaltenen Symbole in verschiedenen Formaten f√ºr verschiedene Plattformen exportieren kann, wobei AB die M√∂glichkeit bietet, jedes Symbol zu testen. <br><br>  Den ersten Teil des Beitrags k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  Die Skizzendateien mit allen gesammelten, gestalteten und ordnungsgem√§√ü benannten Symbolen waren fertig.  Jetzt war es Zeit, den Code zu schreiben. <br><br>  Es gen√ºgt zu sagen, dass der Prozess ein Versuch und Irrtum war: Nach dem wichtigen anf√§nglichen Code-Kern, der von meinem Teamleiter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nikhil Verma</a> (der die Skriptgrundlagen legte) entwickelt wurde, durchlief ich einen inkrementellen Prozess, der mindestens drei Phasen des Refactorings erforderte und einige √úberarbeitungen.  Aus diesem Grund werde ich nicht zu sehr auf die Entwicklung des Skripts eingehen, sondern mich darauf konzentrieren, wie das Skript heute in seiner endg√ºltigen Form funktioniert. <br><a name="habracut"></a><br><h2>  Das Build-Skript </h2><br>  Das in Node.js geschriebene Build-Skript ist in seinem Ablauf relativ einfach: Nach dem Importieren der Abh√§ngigkeiten wurde die Liste der zu verarbeitenden Skizzendateien deklariert (als Liste der Marken und f√ºr jede Marke eine Liste der Dateien f√ºr diese Marke) und Wenn √ºberpr√ºft wurde, ob Sketch auf dem Client installiert ist, durchl√§uft das Skript das Markenarray und f√ºhrt f√ºr jede dieser Marken die folgenden Schritte nacheinander aus: <br><br><ol><li>  Holen Sie sich die Design-Token f√ºr die Marke (wir brauchen die Farbwerte) </li><li>  Klonen Sie die mit der Marke verkn√ºpften Skizzendateien, entpacken Sie sie, um die internen JSON-Dateien verf√ºgbar zu machen, und bearbeiten Sie einige der internen Werte dieser JSON-Dateien (dazu sp√§ter mehr). </li><li>  Lesen Sie die relevanten Metadaten aus den Sketch JSON-Dateien ( <i>document.json</i> , <i>meta.json</i> und <i>pages / pageUniqueID.json</i> ).  Insbesondere ben√∂tigen wir die Liste der freigegebenen Stile und die Liste der in den Dateien enthaltenen Assets / Symbole </li><li>  Nach einigen weiteren Manipulationen der Sketch JSON-Dateien komprimieren Sie sie zur√ºck und exportieren und generieren Sie mithilfe der (geklonten und aktualisierten) Sketch-Dateien die endg√ºltigen Ausgabedateien f√ºr die drei Plattformen (iOS, Android, Mobile Web). </li></ol><br>  Sie k√∂nnen die relevanten Teile des Haupt-Build-Skripts hier anzeigen: <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; { // get the design tokens for the brand const brandTokens = getDesignTokens(brand); // prepare the Sketch files (unzipped) and get a list of them const sketchUnzipFolders = await prepareSketchFiles({ brand, sketchFileNames: SKETCH_FILES[brand], sketchFolder: SKETCH_FOLDER_PATH, sketchTempFolder: SKETCH_TEMP_PATH }); // get the Sketch metadata const sketchMetadata = getSketchMetadata(sketchUnzipFolders); const sketchDataSharedStyles = sketchMetadata.sharedStyles; const sketchDataAssets = sketchMetadata.assetsMetadata; generateAssetsPDF({ platform: 'ios', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsSVGDynamicMobileWeb({ platform: 'mw', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsVectorDrawableDynamicAndroid({ platform: 'android', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); }); }</code> </pre> <br>  Tats√§chlich ist der gesamte Pipeline-Code viel komplexer als dieser, und die Komplexit√§t liegt in den Funktionen <b>prepareSketchFiles</b> , <b>getSketchMetadata</b> und <b>generateAssets [format] [platform]</b> .  Ich werde versuchen, sie weiter unten n√§her zu erl√§utern. <br><br><h2>  Vorbereiten der Skizzendateien </h2><br>  Der erste Schritt im Erstellungsprozess ist die Vorbereitung der Skizzendateien, damit sie sp√§ter f√ºr den Export der Assets f√ºr die verschiedenen Plattformen verwendet werden k√∂nnen. <br><br>  Die mit der Marke verkn√ºpften Dateien - f√ºr Blendr beispielsweise die Dateien <i>icons_common.sketch</i> und <i>icons_blendr.sketch</i> - werden zun√§chst in einen tempor√§ren Ordner (genauer gesagt in einen Unterordner, der nach der Marke benannt ist, die verarbeitet wird) geklont und entpackt. <br><br>  Anschlie√üend werden die internen JSON-Dateien zu einem Pr√§fix verarbeitet, das den Assets hinzugef√ºgt wird, die AB-Tests unterzogen werden sollen, sodass sie beim Export in einem Unterordner mit einem vordefinierten Namen (dem eindeutigen Namen des Experiments) gespeichert werden.  Um zu verstehen, welche Assets getestet werden sollen, √ºberpr√ºfen wir einfach, ob dem Namen der Seite, auf der sie in Sketch gespeichert sind, <i>"XP_"</i> vorangestellt ist. <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br>  <i>Ein Vergleich der Ebenennamen in den Skizzendateien vor und nach dem Update.</i> <br><br>  Im obigen Beispiel werden die Assets beim Export im Unterordner <i>"this__is_an_experiment"</i> mit dem Dateinamen <i>"icon-name [variantenname] .ext" gespeichert</i> . <br><br><h2>  Lesen der Skizzenmetadaten </h2><br>  Der zweite wichtige Schritt in diesem Prozess besteht darin, alle relevanten Metadaten aus den Skizzendateien zu holen, insbesondere aus ihren internen JSON-Dateien.  Wie oben erl√§utert, sind diese Dateien die beiden Hauptdateien ( <i>document.json</i> und <i>meta.json</i> ) und die Seitendateien ( <i>pages / pageUniqueId.json</i> ). <br><br>  Die <i>Datei document.json</i> wird verwendet, um die Liste der <i>freigegebenen</i> Stile <i>abzurufen</i> , die unter der <i>Objekteigenschaft layerStyles angezeigt</i> werden: <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": { "_class": "sharedStyleContainer", "objects": [ { "_class": "sharedStyle", "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4", "name": "features/feature-like", "value": { "_class": "style", "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.10588235408067703, "green": 0.4000000059604645, "red": 1 }, "fillType": 0, "noiseIndex": 0, "noiseIntensity": 0, "patternFillType": 1, "patternTileScale": 1 } ], "blur": {...}, "startMarkerType": 0, "endMarkerType": 0, "miterLimit": 10, "windingRule": 1 } }, ...</code> </pre> <br>  F√ºr jeden Stil speichern wir einige grundlegende Informationen in einem Schl√ºsselwertobjekt.  Dies wird sp√§ter verwendet, wenn wir den Namen eines Stils basierend auf seiner eindeutigen ID <i>abrufen m√ºssen</i> (in Sketch die Eigenschaft <i>do_objectID</i> ): <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = { name: object.name, isFill: _.get(object, 'value.fills[0].color') !== undefined, isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br><br>  Zu diesem Zeitpunkt verschieben wir die Datei <i>meta.json</i> , um die Liste der Seiten <i>abzurufen.</i> Insbesondere ben√∂tigen wir deren <i>eindeutige ID</i> und <i>Namen</i> : <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": { "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": { "name": "Icons", "artboards": { "3275987C-CE1B-4369-B789-06366EDA4C98": { "name": "badge-feature-like" }, "C6992142-8439-45E7-A346-FC35FA01440F": { "name": "badge-feature-crush" }, ... "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": { "name": "tabbar-livestream" } ... } }, "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": { "name": "XP_this__is_an_experiment", "artboards": { "31A812E8-D960-499F-A10F-C2006DDAEB65": { "name": "this__is_an_experiment/tabbar-livestream[variant1]" }, "20F03053-ED77-486B-9770-32E6BA73A0B8": { "name": "this__is_an_experiment/tabbar-livestream[variant2]" }, "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": { "name": "this__is_an_experiment/tabbar-livestream[control]" } } },</code> </pre> <br>  Dann lesen wir f√ºr jede Seite die entsprechende JSON-Datei unter dem <i>Seitenordner</i> (wie bereits gesagt, der Dateiname lautet <i>[pageUniqueId] .json</i> ) und gehen die auf dieser Seite enthaltenen Assets durch (sie werden als Ebenen <i>angezeigt</i> ).  Auf diese Weise erhalten wir f√ºr jedes Symbol seinen Namen, seine Breite / H√∂he, die Sketch-Metadaten f√ºr dieses Ebenensymbol und, falls es sich auf einer Experimentierseite befindet, den Namen des betreffenden AB-Tests und den Namen der Variante f√ºr dieses Symbol. <br><br>  <i>Hinweis</i> : Das Objekt "page.json" ist sehr komplex, daher werde ich hier nicht darauf eingehen.  Wenn Sie neugierig sind und sehen m√∂chten, wie es aussieht, empfehle ich Ihnen, eine neue, leere Skizzendatei zu erstellen, Inhalte hinzuzuf√ºgen und zu speichern.  Benennen Sie dann die Erweiterung in zip um, entpacken Sie sie und sehen Sie sich eine der Dateien an, die im Ordner "pages" angezeigt werden. <br><br>  W√§hrend der Verarbeitung der Zeichenfl√§chen erstellen wir auch eine Liste von Experimenten (mit den entsprechenden Elementen), anhand derer sp√§ter bestimmt wird, welche Symboloptionen und f√ºr welches Experiment verwendet werden, wobei der Name der Symboloptionen dem Objekt "Symbolbasis" zugeordnet wird. <br><br>  F√ºr jede verarbeitete <i>Skizzendatei</i> , die der Marke zugeordnet ist, erstellen wir ein <i>AssetsMetadata-</i> Objekt, das folgenderma√üen aussieht: <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": { "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977", ...sketch_artboard_properties, "name": "navigation-bar-edit", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 "layers": [ { "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4", "name": "Path", ...sketch_layer_properties, "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5", "style": { ... "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.8784313725490196, "green": 0.8784313725490196, "red": 0.8784313725490196 }, } ], "miterLimit": 10, "startMarkerType": 0, "windingRule": 1 }, }, ], ... }, "experiment-name/navigation-bar-edit[variant]": { "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7", ...sketch_artboard_properties, "name": "experiment-name/navigation-bar-edit[variant]", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 ...</code> </pre> <br>  Wie Sie sehen k√∂nnen, kann das gleiche "Symbol" (in diesem Fall die <i>Bearbeitung der Navigationsleiste</i> ) experimentell mit mehreren "Assets" verkn√ºpft sein.  Das gleiche Symbol kann jedoch mit demselben Namen in einer zweiten Skizzendatei angezeigt werden, die der Marke zugeordnet ist. Dies ist sehr n√ºtzlich: Es ist der Trick, den wir verwendet haben, um einen gemeinsamen Satz von Symbolen zu kompilieren und dann abh√§ngig von der Marke. <br><br>  Aus diesem Grund haben wir die mit der jeweiligen Marke verkn√ºpften Skizzendateien als Array deklariert: <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  Denn in diesem Fall ist die Reihenfolge wichtig.  Tats√§chlich geben wir in der vom <i>Erstellungsskript</i> aufgerufenen Funktion <i>getSketchMetadata</i> die <i>AssetsMetadata-</i> Objekte (eines pro Datei) nicht als Liste zur√ºck, sondern f√ºhren eine <i>gr√ºndliche</i> Zusammenf√ºhrung jedes Objekts in das andere durch <i>Gibt</i> ein einzelnes zusammengef√ºhrtes <i>AssetsMetadata-</i> Objekt zur√ºck. <br><br>  Dies ist nichts anderes als die "logische" Zusammenf√ºhrung der Skizzendateien und ihrer Assets zu einer einzigen Datei.  Aber die Logik ist nicht so einfach, wie es aussieht.  Hier ist das Schema, das wir erstellen mussten, um herauszufinden, was passiert, wenn Symbole mit demselben Namen (m√∂glicherweise unter AB-Test) in verschiedenen Dateien vorhanden sind, die derselben Marke zugeordnet sind: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br>  <i>Das logische Schema, wie das "√úberschreiben" desselben Symbols funktioniert, zwischen einer gemeinsamen Gruppe von Symbolen und Symbolen, die speziell f√ºr White-Labels entwickelt wurden (auch unter Ber√ºcksichtigung des AB-Tests).</i> <br><br><h2>  Generieren der endg√ºltigen Dateien in verschiedenen Formaten f√ºr verschiedene Plattformen </h2><br>  Der letzte Schritt des Prozesses ist die eigentliche Generierung der Symboldateien mit unterschiedlichen Formaten f√ºr die verschiedenen Plattformen (PDF f√ºr iOS, SVG / JSX f√ºr Web und VectorDrawable f√ºr Android). <br><br>  Wie Sie an der Anzahl der Parameter sehen k√∂nnen, die an die Funktionen <i>generateAssets [Format] [Plattform] √ºbergeben wurden, ist</i> dies der komplexeste Teil der Pipeline.  Hier <b>beginnt der Prozess, sich</b> f√ºr die verschiedenen Plattformen <b>zu teilen und auseinander</b> zu gehen.  Im Folgenden sehen Sie den vollst√§ndigen logischen Ablauf des Skripts und wie sich der Teil, der sich auf die Generierung der Assets bezieht, <b>in drei √§hnliche, aber nicht identische Abl√§ufe aufteilt:</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  Um die endg√ºltigen Assets mit den richtigen Farben zu generieren, die der zu verarbeitenden Marke zugeordnet sind, m√ºssen wir eine weitere Reihe von Manipulationen an den Sketch JSON-Dateien vornehmen: Wir durchlaufen iterativ jede Ebene, auf die ein gemeinsamer Stil angewendet wurde, und ersetzen die Farbwerte mit den Farben aus den Design-Token f√ºr die Marke. <br><br>  F√ºr die Android-Generation ist eine zus√§tzliche Manipulation erforderlich (dazu sp√§ter mehr): Wir √§ndern die F√ºllregeleigenschaft jeder Ebene von <i>gerade-ungerade</i> auf <i>ungleich Null</i> (dies wird durch die Eigenschaft "windingRule" im JSON-Objekt gesteuert, wobei " 1 "bedeutet" gerade-ungerade "und" 0 "bedeutet" nicht Null "). <br><br>  Nach Abschluss dieser Manipulationen komprimieren wir die Sketch-JSON-Dateien wieder in eine Standard-Sketch-Datei, damit sie verarbeitet werden k√∂nnen, um die Assets mit den aktualisierten Eigenschaften zu exportieren (die geklonten und aktualisierten Dateien sind absolut normale Sketch-Dateien: Sie k√∂nnen in Sketch ge√∂ffnet werden , angezeigt, bearbeitet, gespeichert usw.). <br><br>  Zu diesem Zeitpunkt k√∂nnen wir sketchtool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem Node Wrapper</a> ) verwenden, um automatisch alle Assets in bestimmten Formaten f√ºr bestimmte Plattformen zu exportieren.  F√ºr jede Datei, die einer Marke zugeordnet ist (genauer gesagt, ihre geklonte und aktualisierte Version), f√ºhren wir diesen Befehl aus: <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg &lt;i&gt;--scales=1 &lt;/i&gt;--output=${destinationFolder} --overwriting`);</code> </pre> <br>  Wie Sie vielleicht erraten haben, exportiert dieser Befehl die Assets in einem bestimmten Format unter Anwendung einer optionalen Skalierung (im Moment behalten wir immer die urspr√ºngliche Skalierung bei) in einen Zielordner.  Die Option <i>--overwriting</i> ist hier von entscheidender Bedeutung: Auf die gleiche Weise, wie wir eine "Deep Merge" der AssetsMetadata-Objekte durchf√ºhren (was einer "logischen Zusammenf√ºhrung" der Skizzendateien entspricht), erfolgt dies beim Exportieren aus mehreren Dateien in der gleiche Ordner (eindeutig pro Marke / Plattform).  Dies bedeutet, dass ein Asset, das durch seinen Layernamen identifiziert wurde und bereits in einer vorherigen Skizzendatei vorhanden war, durch den folgenden Export √ºberschrieben wird.  Dies ist wiederum nichts anderes als eine "Zusammenf√ºhrungs" -Operation. <br><br>  In diesem Fall haben wir jedoch m√∂glicherweise einige Assets, die "Geister" sind.  Dies geschieht, wenn ein Symbol in einer Datei AB-getestet, in einer nachfolgenden Datei jedoch √ºberschrieben wird.  In solchen F√§llen werden die Variantendateien in den <i>Zielordner</i> exportiert, auf den im <i>AssetsMetadata-</i> Objekt als Asset (mit seinem Schl√ºssel und seinen Eigenschaften) <i>verwiesen wird</i> , das jedoch keinem "Basis" <i>-Asset zugeordnet ist</i> (aufgrund der tiefen Zusammenf√ºhrung der <i>AssetsMetadata-</i> Objekte).  Diese Dateien werden in einem sp√§teren Schritt vor Abschluss des Vorgangs entfernt. <br><br><hr><br>  Wie oben erw√§hnt, ben√∂tigen wir unterschiedliche Endformate f√ºr unterschiedliche Plattformen.  F√ºr iOS m√∂chten wir PDF-Dateien und k√∂nnen diese direkt mit dem Befehl <i>sketchtool exportieren</i> .  F√ºr Mobile Web m√∂chten wir JSX-Dateien und f√ºr Android VectorDrawable-Dateien.  Aus diesem Grund exportieren wir die Assets im SVG-Format in einen Zwischenordner und unterziehen sie dann einer weiteren Verarbeitung. <br><br><h2>  PDF-Dateien f√ºr iOS </h2><br>  Seltsamerweise ist PDF das (einzige?) Format, das von Xcode und OS / iOS zum Importieren und Rendern von Vektor-Assets unterst√ºtzt wird ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier eine kurze Erl√§uterung</a> der technischen Gr√ºnde f√ºr diese Auswahl von Apple). <br><br>  Da wir √ºber Sketchtool direkt in PDF exportieren k√∂nnen, sind f√ºr diese Plattform keine zus√§tzlichen Schritte erforderlich: Wir speichern die Dateien einfach direkt im Zielordner, und das war's. <br><br><h2>  Reagieren / JSX-Dateien f√ºr das Web </h2><br>  Im Fall von Web verwenden wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Knotenbibliothek</a> namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">svgr</a> , die einfache SVG-Dateien in React-Komponenten konvertiert.  Aber wir wollen etwas noch St√§rkeres tun: Wir wollen das Symbol zur Laufzeit "dynamisch malen", wobei die Farben von den Design-Token stammen.  Aus diesem Grund ersetzen wir kurz vor der Konvertierung in der SVG die <i>F√ºllwerte</i> der Pfade, auf die urspr√ºnglich ein gemeinsamer Stil angewendet wurde, durch den entsprechenden Tokenwert, der diesem Stil zugeordnet ist. <br><br>  Wenn dies also die aus <i>sketch</i> exportierte Datei <i>badge-feature-like.svg ist</i> : <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) - &lt;a href="http://www.bohemiancoding.com/sketch"&gt;http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt; &lt;g id="badge-feature-like"&gt; &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt; &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt; &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  Das endg√ºltige Asset / Symbol von <i>badge-feature-like.js</i> sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return ( &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt; &lt;g fill="none" fillRule="evenodd"&gt; &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt; &lt;path fill="#FFF" d="M80.4061668,..." /&gt; &lt;/g&gt; &lt;/svg&gt; ); };</code> </pre> <br>  Wie Sie sehen k√∂nnen, haben wir den statischen Wert f√ºr die <i>F√ºllfarbe</i> des Kreises durch einen dynamischen Wert ersetzt, der seinen Wert aus den Entwurfstoken bezieht (diese werden der Komponente React <i>&lt;Icon /&gt;</i> √ºber die Kontext-API zur Verf√ºgung gestellt). aber das ist eine andere Geschichte). <br><br>  Diese Ersetzung wird durch die Sketch-Metadaten f√ºr das im <i>Assets-Metadatenobjekt</i> gespeicherte Asset erm√∂glicht: Durch rekursives Durchlaufen der Layer des Assets kann ein DOM-Selektor erstellt werden (im obigen Fall w√§re dies <i>#Icons # badge-feature-). wie #circle</i> ) und verwenden Sie es, um den Knoten im SVG-Baum zu finden und den Wert seines <i>F√ºllattributs zu</i> ersetzen (f√ºr diese Operation verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cheerio-</a> Bibliothek). <br><br><h2>  VectorDrawable-Dateien f√ºr Android </h2><br>  Android unterst√ºtzt Vektorgrafiken mit seinem benutzerdefinierten Vektorformat namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VectorDrawable</a> .  Normalerweise wird die Konvertierung von SVG zu VectorDrawable von den Entwicklern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">direkt in Android Studio durchgef√ºhrt</a> .  Aber hier wollten wir den gesamten Prozess automatisieren, also mussten wir einen Weg finden, sie per Code zu konvertieren. <br><br>  Nachdem wir uns verschiedene Bibliotheken und Tools angesehen hatten, entschieden wir uns f√ºr eine Bibliothek namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">svg2vectordrawable</a> .  Es wird nicht nur aktiv gewartet (zumindest besser als die anderen, die wir gefunden haben), sondern es ist auch vollst√§ndiger. <br><br>  Tatsache ist, dass VectorDrawable nicht mit SVG √ºbereinstimmt: Einige der erweiterten Funktionen von SVG (z. B. radiale Farbverl√§ufe, komplexe Masken usw.) werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht unterst√ºtzt</a> , und einige von ihnen wurden erst k√ºrzlich unterst√ºtzt (mit Android API 24 und h√∂her).  Ein Nachteil davon ist, dass in Android vor 24 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die "gerade-ungerade" F√ºllregel nicht unterst√ºtzt wird</a> .  Aber bei Badoo m√ºssen wir Android 5 und h√∂her unterst√ºtzen.  Aus diesem Grund m√ºssen wir, wie oben erl√§utert, f√ºr Android jeden Pfad in den Skizzendateien in eine F√ºllung ungleich Null konvertieren. <br><br>  M√∂glicherweise k√∂nnten die Designer dies manuell tun: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  Dies kann jedoch leicht √ºbersehen werden und ist daher anf√§llig f√ºr menschliches Versagen. <br><br>  Aus diesem Grund haben wir einen zus√§tzlichen Schritt in unserem Prozess f√ºr Android hinzugef√ºgt, in dem wir alle Pfade im Sketch JSON automatisch in einen Wert <i>ungleich Null</i> konvertieren.  Dies bedeutet, dass die Symbole beim Exportieren in SVG bereits in diesem Format vorliegen und jedes generierte VectorDrawable auch mit Android 5-Ger√§ten kompatibel ist. <br><br>  Die endg√ºltige Datei <i>badge-feature-like.xml</i> sieht in diesem Fall folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path android:fillColor="?color_feature_liked_you" android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path android:fillColor="#FFFFFF" android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  Wie Sie sehen k√∂nnen, f√ºgen wir auch in den VectorDrawable-Dateien Variablennamen f√ºr die <i>F√ºllfarben ein</i> , die den Designtoken √ºber benutzerdefinierte Stile in den Android-Anwendungen zugeordnet sind. <br><br>  So sieht VectorDrawable nach dem Import in Android Studio aus: <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br>  <i>Ein Beispiel f√ºr ein in Android Studio importiertes VectorDrawable-Symbol</i> <br><br>  Eines ist in diesem Fall zu beachten: Android Studio hat eine sehr strenge und vorgeschriebene Art der Organisation der Assets: kein verschachtelter Ordner und alle Namen in Kleinbuchstaben!  Dies bedeutete, dass wir ein etwas anderes Format f√ºr die Namen ihrer Symbole entwickeln mussten: Im Fall eines zu <i>testenden Assets lautet</i> sein Name so etwas wie <i>ic_icon-name__experiment-name__variant-name</i> . <br><br><h2>  JSON-W√∂rterbuch als Assets-Bibliothek </h2><br>  Sobald die Asset-Dateien in ihrem endg√ºltigen Format gespeichert sind, m√ºssen Sie als letztes alle w√§hrend des Erstellungsprozesses gesammelten Metainformationen speichern und in einem "W√∂rterbuch" speichern, damit sie sp√§ter verf√ºgbar gemacht werden k√∂nnen wenn die Assets von der Codebasis der verschiedenen Plattformen importiert und verwendet werden. <br><br>  Nachdem wir die flache Liste der Symbole aus dem <i>AssetsMetadata-</i> Objekt extrahiert haben, <i>durchlaufen</i> wir sie und √ºberpr√ºfen sie f√ºr jedes Element: <br><br><ul><li>  Wenn es sich um ein normales Asset handelt (z. B. <i>Tabbar-Livestream</i> ), und wenn dies der <i>Fall</i> ist, behalten wir es einfach bei. </li><li>  Wenn es sich um eine Variante in einem AB-Test handelt (z. B. <i>Experiment / Tabbar-Livestream [Variante]</i> ), <i>ordnen</i> wir den Namen, den Pfad, den AB-Test und die Variantennamen den Eigenschaftsabtests des "Basis" <i>-Assets zu</i> (in diesem Fall <i>tabbar-). Livestream</i> ), und dann entfernen wir den Varianteneintrag aus der Liste / dem Objekt (nur die "Basis" z√§hlt); </li><li>  Wenn es sich um eine "Ghost" -Variante handelt, l√∂schen wir die Datei und entfernen den Eintrag aus der Liste / dem Objekt. </li></ul><br>  Sobald die Schleife abgeschlossen ist, enth√§lt das W√∂rterbuch die Liste aller und nur der "Basis" -Symbole (und ihrer AB-Tests, falls experimentiert).  F√ºr jedes dieser Elemente enth√§lt es seinen Namen, seine Gr√∂√üe, seinen Pfad und, falls sich ein Symbol im AB-Test befindet, die Informationen zu den verschiedenen Optionen des Assets. <br><br>  Dieses W√∂rterbuch wird dann im JSON-Format im Zielordner f√ºr die <i>Marke</i> und die <i>Plattform</i> gespeichert.  Hier ist zum Beispiel die Datei <i>resources.json</i> , die f√ºr die Anwendung "Blendr" im "mobilen Web" generiert wurde: <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": { "badge-feature-like": { "assetname": "badge-feature-like", "path": "assets/badge-feature-like.jsx", "width": 64, "height": 64, "source": "icons_common" }, "navigation-bar-edit": { "assetname": "navigation-bar-edit", "path": "assets/navigation-bar-edit.jsx", "width": 48, "height": 48, "source": "icons_common" }, "tabbar-livestream": { "assetname": "tabbar-livestream", "path": "assets/tabbar-livestream.jsx", "width": 128, "height": 128, "source": "icons_blendr", "abtest": { "this__is_an_experiment": { "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx", "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx", "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx" }, "a_second-experiment": { "control": "assets/a_second-experiment/tabbar-livestream__control.jsx", "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx" } } }, ... } }</code> </pre> <br>  Der allerletzte Schritt besteht darin, alle <i>Assets-</i> Ordner in zu komprimieren.  <i>Zip-</i> Dateien, damit sie einfacher heruntergeladen werden k√∂nnen. <br><br><h2>  Das Endergebnis </h2><br>  Der oben beschriebene Prozess - vom anf√§nglichen Klonen und Bearbeiten der Skizzendateien √ºber den Export (und die Konvertierung) der Assets in dem f√ºr jede unterst√ºtzte Plattform gew√ºnschten Format bis zur Speicherung der gesammelten Metainformationen in einer Asset-Bibliothek - ist wird f√ºr jede im Build-Skript deklarierte Marke wiederholt. <br><br>  Unten sehen Sie einen Screenshot, wie die Struktur der Ordner <i>src</i> und <i>dist</i> nach Abschluss des Erstellungsprozesses aussieht: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br>  <i>Struktur der Ordner "src" und "dist" nach Abschluss des Erstellungsprozesses.</i> <br><br>  Zu diesem Zeitpunkt ist es mit einem einfachen Befehl m√∂glich, alle Ressourcen (JSON-Dateien, ZIP-Dateien und Assets-Dateien) in ein Remote-Repository hochzuladen und f√ºr alle verschiedenen Plattformen verf√ºgbar zu machen, um sie in ihren Codebasen herunterzuladen und zu verwenden. <br><br>  (Wie die tats√§chlichen Plattformen die Assets abrufen und verarbeiten - √ºber benutzerdefinierte Skripte, die zu diesem Zweck ad-hoc erstellt wurden -, geht √ºber den Rahmen dieses Artikels hinaus. Dies wird jedoch wahrscheinlich sehr bald in anderen speziellen Blog-Posts von einem der Autoren behandelt andere Entwickler, die mit mir an diesem Projekt gearbeitet haben). <br><br><h2>  Schlussfolgerungen (und dabei gewonnene Erkenntnisse) </h2><br>  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sketch</a> immer geliebt.  Seit Jahren ist es das "De-facto" -Tool der Wahl f√ºr das Web- und App-Design (und die Entwicklung).  Daher war ich sehr interessiert und neugierig, m√∂gliche Integrationen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTML-Sketchapp</a> oder √§hnliche Tools zu untersuchen, die wir in unseren Workflows und Pipelines verwenden konnten. <br><br>  Dieser (ideale) Fluss war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr mich</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und viele andere</a> ) immer der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">heilige Gral</a> : <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  Skizze als Entwurfswerkzeug kann als m√∂gliches "Ziel" der Codebasis vorgestellt werden. <br><br>  Aber ich muss zugeben, dass ich mich k√ºrzlich gefragt habe, ob Sketch immer noch das richtige Werkzeug ist, insbesondere im Kontext eines Design-Systems.  Also begann ich, neue Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Figma</a> mit seinen offenen APIs und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Framer X</a> mit seiner unglaublichen Integration in React zu erkunden, da ich keine gleichwertigen Bem√ºhungen von Sketch sah, auf die Integration mit Code (welcher Code auch immer) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzuarbeiten</a> . <br><br>  Nun, dieses Projekt hat meine Meinung ge√§ndert.  Nicht ganz, aber definitiv viel. <br><br>  Vielleicht macht Sketch seine APIs nicht offiziell verf√ºgbar, aber die Art und Weise, wie sie die interne Struktur ihrer Dateien erstellt haben, ist sicherlich eine Art "inoffizielle" API.  Sie k√∂nnten kryptische Namen verwendet oder die Schl√ºssel in den JSON-Objekten verschleiert haben.  Stattdessen haben sie sich f√ºr eine klare, leicht lesbare, f√ºr Menschen lesbare, semantische Namenskonvention entschieden.  Ich kann nicht denken, dass dies nur ein Zufall ist. <br><br>  Die Tatsache, dass Skizzendateien manipuliert werden k√∂nnen, hat mir eine Vielzahl m√∂glicher zuk√ºnftiger Entwicklungen und Verbesserungen er√∂ffnet.  Von Plugins zur Validierung der Benennung, des Stils und der Struktur der Ebenen f√ºr die Symbole √ºber m√∂gliche Integrationen in unser Wiki und unsere Designsystemdokumentation (in beide Richtungen) bis hin zur Erstellung von Node-Apps, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Electron</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Carlo</a> gehostet werden, um viele der Funktionen zu vereinfachen sich wiederholende Aufgaben, die die Designer √ºbernehmen m√ºssen. <br><br>  Ein unerwarteter Bonus dieses Projekts (zumindest f√ºr mich) ist, dass die Skizzendateien mit den "Cosmos-Symbolen" jetzt zu einer "Quelle der Wahrheit" geworden sind, √§hnlich wie dies mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cosmos-</a> Designsystem geschehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> .  Wenn ein Symbol nicht vorhanden ist, ist es nicht in der Codebasis vorhanden (oder besser, es sollte nicht vorhanden sein: aber zumindest wissen wir, dass es eine Ausnahme ist).  Ich wei√ü, dass es jetzt ziemlich offensichtlich ist, aber es war nicht vorher, zumindest f√ºr mich. <br><br>  Was als MVP-Projekt begann, tauchte bald (buchst√§blich) tief in die Interna von Sketch-Dateien ein, mit der Erkenntnis, dass diese manipuliert werden k√∂nnen.  Wir wissen noch nicht, wohin das alles f√ºhren wird, aber bisher war es ein Erfolg.  Designer, Entwickler, PMs und Stakeholder sind sich einig, dass dies viel manuelle Arbeit f√ºr alle erspart und viele potenzielle Fehler verhindert.  Es √∂ffnet aber auch die T√ºren f√ºr die Verwendung der bisher unm√∂glichen Symbole. <br><br>  Eine letzte Sache: Was ich in diesem langen Beitrag beschrieben habe, ist eine Pipeline, die wir hier erstellt haben, um <i>unsere</i> speziellen Probleme zu l√∂sen, und die daher notwendigerweise f√ºr <i>unseren</i> Kontext besonders angepasst ist.  Beachten Sie, dass es m√∂glicherweise nicht <i>Ihren</i> gesch√§ftlichen Anforderungen entspricht oder f√ºr <i>Ihren</i> Kontext geeignet ist. <br><br>  Aber was mir wichtig ist und was ich teilen wollte, ist, dass es getan werden kann.  M√∂glicherweise auf unterschiedliche Weise, mit unterschiedlichen Ans√§tzen und unterschiedlichen Ausgabeformaten, m√∂glicherweise mit geringerer Komplexit√§t (d. H. M√∂glicherweise ben√∂tigen Sie das Multi-Branding und die AB-Tests nicht).  Jetzt k√∂nnen Sie den Workflow f√ºr die Bereitstellung Ihrer Symbole mit einem benutzerdefinierten Node.js-Skript und einer Skizze automatisieren. <br><br>  Finden Sie Ihren eigenen Weg, es zu tun.  Es macht Spa√ü (und ist relativ einfach). <br><br><h2>  Credits </h2><br>  Dieses riesige Projekt wurde in Zusammenarbeit mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nikhil Verma</a> (Mobile Web) entwickelt, der die erste Version des Build-Skripts erstellt hat, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artem Rudoi</a> (Android) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Igor Savelev</a> (iOS), der die Skripte entwickelt hat, mit denen die Assets importiert und verwendet werden jeweilige native Plattformen.  Vielen Dank, Leute, es war eine tolle Zeit, mit Ihnen an diesem Projekt zu arbeiten und zu beobachten, wie es zum Leben erweckt wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441042/">https://habr.com/ru/post/de441042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441030/index.html">Erkennen von Webangriffen mit einem Seq2Seq Autoencoder</a></li>
<li><a href="../de441032/index.html">KeeBee Erstellen Sie Ihre eigene USB-Tastatur von Grund auf neu</a></li>
<li><a href="../de441034/index.html">6 Punkte Conversion-Wachstum oder wie Sie das Vertrauen mit einem Telefon auf der Website erh√∂hen k√∂nnen</a></li>
<li><a href="../de441036/index.html">Wie man Feedback gibt und erh√§lt, wenn man ein Spatzen-Soziophobus ist</a></li>
<li><a href="../de441040/index.html">Generieren von Multi-Brand-Multi-Plattform-Symbolen mit Sketch und einem Node.js-Skript - Teil 1</a></li>
<li><a href="../de441044/index.html">Die Geschichte, wie wir das PVS-Studio-Symbol ge√§ndert haben</a></li>
<li><a href="../de441046/index.html">Die Geschichte, wie wir das PVS-Studio-Symbol ge√§ndert haben</a></li>
<li><a href="../de441048/index.html">Pro aggressives B√ºro</a></li>
<li><a href="../de441050/index.html">Herstellung einer DIY-W√§rmebildkamera basierend auf einem Raspberry Pi</a></li>
<li><a href="../de441052/index.html">16. M√§rz Badoo PHP Meetup: Tests und Codequalit√§t. Die Registrierung ist offen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>