<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€âš–ï¸ ğŸ‘¨ğŸ¿ ğŸ‘ CICD: penyebaran mulus ke sistem cluster terdistribusi tanpa downtime ğŸ¦ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ ğŸ‘«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya memposting laporan kedua dari mitap pertama kami, yang diadakan pada bulan September. Terakhir kali Anda bisa membaca (dan melihat) tentang mengg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CICD: penyebaran mulus ke sistem cluster terdistribusi tanpa downtime</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/425813/">  Saya memposting laporan kedua dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mitap pertama</a> kami, yang diadakan pada bulan September.  Terakhir kali Anda bisa membaca (dan melihat) tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan Konsul untuk meningkatkan skala layanan</a> dari Ivan Bubnov dari BIT.GAMES, dan hari ini kita akan berbicara tentang CICD.  Lebih tepatnya, administrator sistem kami Egor Panov akan memberi tahu tentang hal ini, yang bertanggung jawab atas ketersediaan infrastruktur dan layanan di Pixonic.  Di bawah cut - decoding kinerja. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/U6AE8J7q81M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Untuk memulainya, industri game lebih berisiko - Anda tidak pernah tahu persis apa yang akan meresap ke hati pemain.  Jadi kami membuat banyak prototipe.  Tentu saja, kami membuat prototipe di ujung tongkat, tali, dan bahan improvisasi lainnya. <br><br>  Tampaknya dengan pendekatan ini, melakukan sesuatu yang kemudian dapat didukung pada umumnya tidak mungkin.  Tetapi bahkan pada tahap ini kita bertahan.  Kami berpegang pada tiga pilar: <br><br><ol><li>  keahlian penguji yang sangat baik; </li><li>  interaksi dekat dengan mereka; </li><li>  waktu yang kami berikan untuk pengujian. </li></ol><br>  Dengan demikian, jika kita tidak membangun proses kita, misalnya, penyebaran atau CI (integrasi berkelanjutan), cepat atau lambat kita akan sampai pada kesimpulan bahwa durasi pengujian akan meningkat dan meningkat setiap saat.  Dan kita akan melakukan segalanya dengan lambat dan kehilangan pasar, atau kita akan meledak di setiap penyebaran. <br><br>  Tetapi membangun proses CICD tidak sesederhana itu.  Beberapa orang akan berkata, ya, saya akan taruh Jenkins, saya akan segera menelepon sesuatu, sekarang saya sudah siap CICD.  Tidak, ini bukan hanya alat, itu juga praktik.  Mari kita mulai. <br><br><img src="https://habrastorage.org/webt/3e/di/1h/3edi1hvgrx4zntc1usxtekz-09w.png"><br>  Yang pertama.  Dalam banyak artikel mereka menulis bahwa semuanya perlu disimpan dalam satu repositori: kode, dan tes, dan gunakan, dan bahkan skema database, dan pengaturan IDE yang umum untuk semua.  Kami pergi dengan cara kami sendiri. <br><br>  Kami telah mengalokasikan berbagai repositori: penempatan di repositori kami, tes di tempat lain.  Ini bekerja lebih cepat.  Ini mungkin tidak cocok untuk Anda, tetapi bagi kami itu jauh lebih nyaman.  Karena ada satu poin penting pada titik ini - Anda perlu membangun yang sederhana dan transparan untuk semua arus hit.  Tentu saja, Anda dapat mengunduh yang sudah selesai di suatu tempat, tetapi dalam hal apa pun, Anda perlu memperbaiki sendiri, memperbaikinya.  Bagi kami, sebagai contoh, sebuah deployment hidup dengan gitflow sendiri, yang lebih seperti aliran GitHub, dan pengembangan server hidup dengan gitflow sendiri. <br><br>  Paragraf selanjutnya.  Anda perlu mengonfigurasi bangunan yang sepenuhnya otomatis.  Jelas bahwa pada tahap pertama pengembang itu sendiri secara pribadi mengumpulkan proyek, kemudian ia secara pribadi menyebarkannya menggunakan SCP, meluncurkannya sendiri, mengirimkannya kepada siapa pun yang membutuhkannya.  Opsi ini tidak berumur panjang, skrip bash muncul.  Nah, karena lingkungan pengembang terus berubah, server khusus yang dibangun telah muncul.  Dia hidup sangat lama, selama ini kami berhasil meningkatkan hingga 500 di server, mengkonfigurasi konfigurasi server pada Puppet, mengumpulkan warisan pada Puppet, menolak Puppet, beralih ke Ansible, dan buildserver ini terus hidup. <br><br>  Mereka memutuskan untuk mengubah segalanya setelah dua panggilan, mereka tidak menunggu untuk yang ketiga.  Ceritanya jelas: buildserver adalah satu titik kegagalan dan, tentu saja, ketika kami perlu menyebarkan sesuatu, pusat data benar-benar jatuh bersama dengan buildserver kami.  Dan panggilan kedua: kami perlu memperbarui versi Java - kami memperbaruinya pada buildserver, memasangnya di atas panggung, semuanya keren, semuanya bagus dan di sana perlu menjalankan beberapa perbaikan bug kecil pada prod.  Tentu saja, kami lupa untuk mundur dan semuanya berantakan. <br><br>  Setelah itu, mereka menulis ulang semuanya sehingga seluruh build dapat terjadi pada agen TeamCity dan menulis ulang pada Ansible, karena itu dikonfigurasi pada Ansible, mengapa tidak menggunakan alat yang sama untuk penyebaran juga. <br><br>  Aturan berikut: semakin sering Anda berkomitmen, semakin baik.  Mengapa  Karena ada yang keempat: setiap komit dikumpulkan.  Dan faktanya, bahkan lebih dari setiap komitmen.  Saya sudah mengatakan bahwa kami memiliki TeamCity, dan itu memungkinkan Anda untuk menjalankan komit dari IDE favorit Anda (coba tebak apa yang saya maksud).  Sebenarnya, umpan balik cepat, semuanya bagus. <br><br>  Bangunan yang rusak segera diperbaiki.  Segera setelah Anda mengatur penyebaran otomatis, Anda perlu mengatur notifikasi otomatis di Slack.  Kita semua tahu betul bahwa pengembang tahu bagaimana kodenya bekerja hanya pada saat dia menulisnya.  Oleh karena itu: orang tersebut tahu - segera diperbaiki. <br><br>  Kami menguji pada lingkungan mengulangi prod.  Sederhana, kami memilih Ansible dan AWX.  Seseorang mungkin bertanya, tetapi bagaimana dengan Docker, Kubernetes, OpenShift, di mana semua masalah di luar kotak telah lama diselesaikan?  Saya lupa mengatakan bahwa kami memiliki komponen Linux dan Windows.  Dan, misalnya, server Photon, yang ada di Windows, kami baru saja dapat mengemas lebih atau kurang secara normal dalam wadah buruh pelabuhan 10 GB.  Karenanya, kami memiliki aplikasi Windows yang tidak dikemas dengan baik dalam sebuah wadah;  Ada aplikasi di Linux (yang ada di Jawa), yang dikemas dengan sempurna, tetapi tidak ada alasan untuk itu, itu berfungsi dengan baik di mana pun Anda menjalankannya.  Ini Jawa. <br><br>  Selanjutnya, kami memilih antara Ansible dan Chef.  Keduanya bekerja dengan baik dengan Windows, tetapi Ansible ternyata jauh lebih mudah bagi kami.  Ketika kami sudah menginstal AWX - secara umum semua api menjadi.  AWX memiliki rahasia, grafik, sejarah.  Anda dapat menunjukkan kepada seseorang yang jauh dari semua ini, dia akan segera melihat semuanya dan semuanya akan menjadi jelas. <br><br>  Dan Anda selalu harus menjaga build dengan cepat.  Saya tidak tahu mengapa, tetapi setiap kali Anda meluncurkan proyek baru, Anda benar-benar lupa tentang pembuat server, tentang agen-agen dan memilih beberapa komputer yang ada di sekitar - ini adalah pembuat server kami.  Tidak diinginkan untuk mengulangi kesalahan ini, karena semua yang saya bicarakan (umpan balik cepat, plus) - semuanya tidak akan terlalu relevan jika perakitan dimulai pada laptop Anda sendiri lebih cepat daripada pada beberapa jenis pertanian pembuatan server. <br><br><img src="https://habrastorage.org/webt/ll/ab/zl/llabzlqv49woxdlukv36uohavcg.png"><br>  7 poin - dan kami telah membangun semacam proses CI.  Bagus  Diagram berikut tidak terlihat, tetapi masih ada Graylog di samping.  Siapa yang membaca artikel kami di HabrÃ©, yang sudah melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana kami memilih Graylog</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara memasang</a> .  Bagaimanapun, itu membantu untuk membelokkan jika masalah masih terjadi. <br><br><img src="https://habrastorage.org/webt/7d/g7/vo/7dg7vonpatitv6azg812qcycovw.png"><br>  Sekarang di pangkalan ini sudah dimungkinkan untuk melanjutkan ke penyebaran. <br><br><img src="https://habrastorage.org/webt/z4/9d/ey/z49deyle1javphwp9unxx8stk24.png"><br>  Tapi saya sudah bicara tentang penyebaran di paragraf kedua, jadi saya tidak akan terlalu memikirkan hal ini.  Saya akan mengatakan satu hal tentang kehidupan: jika Anda menggunakan Ansible, pastikan untuk menambahkan serial ini, yang ada di slide.  Itu terjadi lebih dari sekali ketika Anda memulai sesuatu, dan kemudian Anda mengerti, tapi saya memulainya dengan salah, atau salah, atau salah, dan kemudian Anda melihat bahwa ini hanya satu server.  Dan kami dapat dengan mudah kehilangan satu server dan Anda cukup mengunggahnya lagi, tidak ada yang menyadarinya. <br><br>  Plus, mereka menginstal repositori artefak pada Nexus - ini adalah titik masuk tunggal untuk semua orang, bukan hanya CI. <br><br><img src="https://habrastorage.org/webt/vd/gn/bx/vdgnbxlqrwunngs2a2qwec-rqqa.gif"><br>  Dan itu sangat membantu kita untuk memastikan pengulangan.  Yah, karena nexus dapat berfungsi sebagai layanan proxy di berbagai wilayah, mereka mempercepat penyebaran, pemasangan paket-paket rpm, gambar buruh pelabuhan, apa saja. <br><br>  Ketika Anda meletakkan proyek baru, disarankan untuk memilih komponen yang mudah diotomatisasi.  Misalnya, kami tidak berhasil dengan server Photon.  Bagaimanapun, itu adalah solusi terbaik dalam hal lain.  Tapi Cassandra, misalnya, sangat mudah diperbarui dan diotomatisasi. <br><br><img src="https://habrastorage.org/webt/47/0d/dp/470ddpcmyhjgdxscckex6l_drow.png"><br>  Ini adalah contoh dari salah satu proyek kami.  Klien datang ke server APP, di mana ia memiliki profil di basis data Cassandra, dan kemudian pergi ke server master, yang dengan bantuan perjodohan memberinya server permainan dengan beberapa jenis ruang.  Semua layanan lain dibuat dalam bentuk "aplikasi - database" dan diperbarui dengan cara yang persis sama. <br><br>  Poin kedua - Anda perlu menyediakan arsitektur penyebaran yang sederhana dan longgar.  Kami telah berhasil. <br><br><img src="https://habrastorage.org/webt/hi/_u/gg/hi_uggurj1cdydwxnel9t_wfawi.png"><br>  Lihat, memperbarui misalnya server aplikasi.  Kami telah mendedikasikan layanan penemuan yang mengkonfigurasi ulang penyeimbang, jadi kami hanya pergi ke server aplikasi, memadamkannya, macet dari penyeimbangan, kami memperbarui semuanya.  Demikian juga dengan masing-masing individu. <br><br>  Server master diperbarui hampir secara identik.  Klien ping setiap server master di wilayah tersebut dan pergi ke yang di mana ping lebih baik.  Dengan demikian, jika kita memperbarui server master, maka mungkin gim akan berjalan sedikit lebih lambat, tetapi itu diperbarui dengan mudah dan sederhana. <br><br>  Server gim diperbarui sedikit berbeda karena masih ada gim yang terjadi.  Kami pergi menjodohkan, memintanya untuk melempar server tertentu dari saldo, datang ke server game, tunggu sampai game menjadi benar-benar nol, dan perbarui.  Lalu kita kembali ke balancing. <br><br><img src="https://habrastorage.org/webt/yk/iv/eu/ykiveufay9i9b2xbtv11e09pw58.gif"><br>  Poin kunci di sini adalah titik akhir yang dimiliki masing-masing komponen, dan yang dengannya mudah dan sederhana untuk berkomunikasi.  Jika Anda memerlukan contoh, maka ada cluster Elasticsearch.  Menggunakan permintaan http biasa di JSON, Anda dapat dengan mudah berkomunikasi dengannya.  Dan dia langsung di JSON yang sama memberikan segala macam metrik dan informasi tingkat tinggi tentang klaster: hijau, kuning, merah. <br><br>  Setelah menyelesaikan 12 langkah ini, kami meningkatkan jumlah lingkungan, mulai menguji lebih banyak, penyebaran dipercepat, orang-orang mulai menerima umpan balik cepat. <br><br><img src="https://habrastorage.org/webt/ax/sx/jh/axsxjh2bd2vw8cazn5tdf1kcguq.png"><br>  Yang sangat penting, kami mendapatkan kesederhanaan dan kecepatan percobaan.  Dan ini sangat penting, karena ketika ada banyak percobaan, kita dapat dengan mudah menyaring ide-ide yang salah dan fokus pada yang benar.  Dan bukan atas dasar penilaian subyektif, tetapi atas dasar indikator objektif. <br><br>  Bahkan, saya tidak lagi mengikuti ketika kami memiliki penempatan di sana, saat rilis.  Tidak ada "oh, lepaskan!" Merasa, semuanya berkumpul dan merinding.  Sekarang ini adalah operasi rutin, saya secara berkala melihat di ruang obrolan bahwa ada sesuatu yang muncul, oke.  Ini sangat keren.  Administrator sistem Anda akan mengaum dengan gembira ketika Anda melakukannya. <br><br>  Tetapi dunia tidak tinggal diam, terkadang memantul.  Kami memiliki sesuatu untuk diperbaiki.  Sebagai contoh, saya ingin meletakkan log build di Graylog juga.  Ini akan membutuhkan penyempurnaan lebih lanjut dari penebangan sehingga tidak ada cerita yang terpisah, tetapi jelas: ini adalah bagaimana membangun itu dirakit, sehingga diuji, itu digunakan, dan berperilaku pada prod.  Dan pemantauan terus menerus - ini adalah kisah yang lebih rumit. <br><br><img src="https://habrastorage.org/webt/bk/b1/pn/bkb1pnqqin9etc8d-ze3jcjl0wa.png"><br>  Kami menggunakan Zabbix, dan dia sama sekali tidak siap untuk pendekatan seperti itu.  Versi 4 akan segera dirilis, kami akan mencari tahu apa yang ada di sana dan jika semuanya buruk, maka kami akan datang dengan solusi yang berbeda.  Saya akan memberi tahu Anda bagaimana hasilnya pada pertemuan berikutnya. <br><br><h4>  Pertanyaan dari audiens </h4><br>  <b>Dan apa yang terjadi ketika Anda membuang sampah dalam produksi?</b>  <b>Misalnya, Anda tidak menghitung sesuatu berdasarkan kinerja dan semuanya baik-baik saja pada integrasi, tetapi dalam produksi, lihat - server Anda mulai macet.</b>  <b>Bagaimana Anda memutar kembali?</b>  <b>Apakah ada tombol simpan saya?</b> <br><br>  Kami mencoba melakukan otomatisasi rollback.  Anda kemudian dapat berbicara tentang laporan tentang cara kerjanya yang keren, betapa indahnya semuanya.  Tetapi pertama-tama, kami merancang agar versi-versi tersebut kompatibel dengan versi sebelumnya dan menguji ini.  Dan ketika kami melakukan hal yang sepenuhnya otomatis ini, yang memeriksa sesuatu dan mengembalikannya, dan kemudian mulai hidup dengannya, kami menyadari bahwa kami berupaya lebih keras daripada jika kami hanya mengambil versi lama dengan pedal yang sama . <br><br>  <b>Mengenai pembaruan otomatis penyebaran: mengapa Anda membuat perubahan ke server saat ini, dan tidak menambahkan yang baru dan hanya menambahkannya ke grup target atau penyeimbang?</b> <br><br>  Jadi lebih cepat. <br><br>  <b>Misalnya, jika Anda perlu memperbarui versi Java, Anda mengubah keadaan instance di Amazon, memperbarui versi Java atau yang lainnya, lalu bagaimana Anda memutar balik dalam kasus itu?</b>  <b>Apakah Anda membuat perubahan pada server produksi?</b> <br><br>  Ya, setiap komponen berfungsi dengan baik dengan versi yang baru dan yang lama.  Ya, Anda mungkin harus memuat ulang server. <br><br>  <b>Ada perubahan kondisi saat masalah besar mungkin terjadi ...</b> <br><br>  Lalu meledak. <br><br>  <b>Sepertinya saya menambahkan server baru dan hanya meletakkannya di grup target di grup target - tugas kecil dalam kompleksitas dan praktik yang cukup bagus.</b> <br><br>  Kita dihosting di perangkat keras, bukan di awan.  Kami dapat menambahkan server - itu mungkin, tetapi sedikit lebih lama daripada hanya mengklik di cloud.  Oleh karena itu, kami mengambil server kami saat ini (kami tidak memiliki muatan sedemikian sehingga kami tidak dapat mengeluarkan beberapa mesin) - kami mengeluarkan beberapa mesin, memperbarui mereka, memasukkan lalu lintas penjualan di sana, melihat cara kerjanya, jika semuanya baik-baik saja, maka kami akan terus melakukan semuanya mobil lain. <br><br>  <b>Anda mengatakan jika setiap komit dikumpulkan dan jika semuanya buruk - pengembang segera mengatur semuanya.</b>  <b>Apakah Anda mengerti bahwa semuanya buruk?</b>  <b>Komitmen apa yang dilakukan?</b> <br><br>  Biasanya, pada awalnya itu semacam pengujian manual, umpan baliknya lambat.  Kemudian, dengan beberapa jenis tes otomatis pada Appium, semua ini dibahas, ia bekerja dan memberikan semacam umpan balik tentang apakah tes jatuh atau tidak jatuh. <br><br>  <b>Yaitu</b>  <b>Pertama, setiap komit diluncurkan dan apakah para penguji memperhatikannya?</b> <br><br>  Ya, tidak semua orang, ini adalah latihan.  Kami membuat satu latihan dari 12 poin ini - dipercepat.  Padahal, ini adalah kerja keras dan panjang, mungkin sepanjang tahun.  Tapi idealnya Anda datang ke ini dan semuanya berfungsi.  Ya, kami membutuhkan semacam uji otomatis, setidaknya satu set minimal, agar semuanya berfungsi untuk Anda. <br><br>  <b>Dan pertanyaannya lebih kecil: ada server aplikasi dalam gambar dan sebagainya, apakah itu yang menarik minat saya di sana?</b>  <b>Anda mengatakan bahwa sepertinya Anda tidak memiliki Docker, apakah itu server?</b>  <b>Jawa telanjang atau apa?</b> <br><br>  Di suatu tempat ini adalah Photon pada Windows (server game), server App adalah aplikasi Java di Tomcat. <br><br>  <b>Yaitu</b>  <b>tidak ada virtualoks, tidak ada wadah, tidak ada?</b> <br><br>  Nah, Jawa bisa dibilang sebuah wadah. <br><br>  <b>Dan apakah semuanya berjalan dengan Ansible?</b> <br><br>  Ya  Yaitu  pada saat tertentu, kami sama sekali tidak berinvestasi dalam orkestrasi, karena mengapa?  Dalam hal apa pun Windows harus dikelola secara terpisah dengan cara yang sama, dan di sini semuanya tertutup dengan satu alat. <br><br>  <b>Dan bagaimana database digunakan?</b>  <b>Ketergantungan pada komponen atau layanan?</b> <br><br>  Ada skema dalam layanan itu sendiri yang akan digunakan ketika muncul dan perlu dikembangkan sehingga tidak ada yang dihapus, tetapi hanya ada sesuatu yang ditambahkan dan itu kompatibel ke belakang. <br><br>  <b>Apakah pangkalan Anda juga besi atau pangkalan di suatu tempat di awan di Amazon?</b> <br><br>  Basis terbesar adalah besi, tetapi ada yang lain.  Ada yang kecil, RDS tidak lagi besi, virtual.  Layanan kecil yang saya perlihatkan: obrolan, liga, mengobrol dengan Facebook, klan, salah satunya adalah RDS. <br><br>  <b>Master server - seperti apa rasanya?</b> <br><br>  Ini, pada kenyataannya, adalah server permainan yang sama, hanya dengan tanda master dan dia penyeimbang.  Yaitu  klien mengirim semua master, lalu menerima yang pingnya kurang, dan sudah menjadi server master dengan bantuan penjaruman mengumpulkan kamar di server game dan mengirimkan pemain. <br><br>  <b>Saya mengerti benar bahwa untuk setiap peluncuran yang Anda tulis (jika ada fitur yang muncul) migrasi untuk memperbarui data?</b>  <b>Anda mengatakan bahwa Anda mengambil artefak lama dan mengisinya - apa yang terjadi pada data?</b>  <b>Apakah Anda menulis migrasi untuk mengembalikan basis?</b> <br><br>  Ini adalah operasi rollback yang sangat langka.  Ya, Anda menulis migrasi pena, dan apa yang harus dilakukan. <br><br>  <b>Bagaimana pembaruan server disinkronkan dengan pembaruan klien?</b>  <b>Yaitu</b>  <b>Anda harus merilis versi baru gim - akankah Anda memperbarui semua server terlebih dahulu, kemudian klien akan diperbarui?</b>  <b>Apakah server mendukung versi lama dan baru?</b> <br><br>  Ya, kami sedang mengembangkan fitur c toggling dan fitur peredupan.  Yaitu  Ini adalah pegangan khusus, sebuah tuas yang memungkinkan Anda untuk mengaktifkan beberapa fitur nanti.  Anda dapat memutakhirkan dengan sangat tenang, melihat bahwa semuanya bekerja untuk Anda, tetapi tidak menyertakan fitur ini.  Dan ketika Anda telah menyebar klien, maka Anda dapat memperketat 10% dengan fiddimming, melihat bahwa semuanya baik-baik saja, dan kemudian sampai penuh. <br><br>  <b>Anda mengatakan bahwa Anda telah secara terpisah menyimpan bagian-bagian dari proyek di repositori yang berbeda, yaitu</b>  <b>apakah Anda memiliki semacam proses pengembangan?</b>  <b>Jika Anda mengubah proyek itu sendiri, maka tes Anda akan jatuh karena Anda mengubah proyek itu.</b>  <b>Jadi tes yang terletak secara terpisah perlu diperbaiki secepat mungkin.</b> <br><br>  Saya katakan tentang paus "interaksi erat dengan penguji."  Skema dengan repositori yang berbeda ini bekerja sangat baik hanya jika ada komunikasi yang sangat padat.  Ini bukan masalah bagi kami, semua orang mudah berkomunikasi satu sama lain, ada komunikasi yang baik. <br><br>  <b>Yaitu</b>  <b>apakah penguji mendukung repositori tes di tim Anda?</b>  <b>Dan autotest terletak secara terpisah?</b> <br><br>  Ya  Anda membuat beberapa fitur dan Anda dapat mengumpulkan autotest yang Anda butuhkan dari repositori penguji, dan tidak memeriksa yang lainnya. <br><br>  <b>Pendekatan seperti itu, ketika semuanya dengan cepat bergulir - Anda mampu untuk segera pergi ke prod untuk setiap komit.</b>  <b>Apakah Anda mengikuti taktik seperti itu atau membuat beberapa rilis?</b>  <b>Yaitu</b>  <b>sekali seminggu, bukan pada hari Jumat, bukan pada akhir pekan, apakah Anda memiliki taktik rilis atau apakah fitur siap, dapatkah saya melepaskannya?</b>  <b>Karena jika Anda membuat rilis kecil dari fitur-fitur kecil, maka Anda kecil kemungkinannya bahwa semuanya akan rusak, dan jika sesuatu rusak, maka Anda pasti tahu apa.</b> <br><br>  Memaksa pengguna klien untuk mengunduh versi baru setiap lima menit atau setiap hari bukanlah ide yang bagus.  Bagaimanapun, Anda akan dilampirkan ke klien.  Sangat bagus ketika Anda memiliki proyek web di mana Anda dapat memperbarui setidaknya setiap hari dan tidak perlu melakukan apa pun.  Ceritanya lebih rumit dengan klien, kami memiliki semacam taktik rilis dan kami berpegang teguh pada itu. <br><br>  <b>Anda berbicara tentang meluncurkan otomatisasi ke server produk, dan (seperti yang saya mengerti) ada juga meluncurkan otomatisasi untuk pengujian - bagaimana dengan lingkungan pengembang?</b>  <b>Apakah ada otomatisasi yang digunakan oleh pengembang?</b> <br><br>  Hal yang hampir sama.  Satu-satunya hal yang bukan server besi, tetapi di mesin virtual, tetapi esensinya hampir sama.  Pada saat yang sama, pada Ansible yang sama, kami menulis (kami memiliki Ovirt) pembuatan mesin virtual ini dan knurling di atasnya. <br><br>  <b>Apakah Anda memiliki keseluruhan cerita yang disimpan dalam satu proyek bersama-sama dengan prod dan konfigurasi yang mungkin, atau apakah itu hidup dan berkembang secara terpisah?</b> <br><br>  Kita dapat mengatakan bahwa ini adalah proyek terpisah.  Dev (kami menyebutnya devbox) adalah cerita ketika semuanya ada dalam satu paket, dan pada prod itu adalah cerita yang didistribusikan. <br><br><h3>  Lebih banyak pembicaraan dengan Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan Konsul untuk meningkatkan layanan yang</a> sah (Ivan Bubnov, DevOps di BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktek menggunakan model aktor di platform backend dari game Quake Champions</a> (Roman Rogozin, pengembang backend Saber Interactive); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur server meta penembak online seluler Tacticool</a> (Pavel Platto, Insinyur Perangkat Lunak Utama di PanzerDog); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana ECS, Sistem Pekerjaan C # dan SRP mengubah pendekatan arsitektur</a> (Valentin Simonov, Insinyur Lapangan di Unity); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip KISS dalam pengembangan</a> (Konstantin Gladyshev, Lead Game Programmer di 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Logika permainan umum pada klien dan server</a> (Anton Grigoriev, Wakil Petugas Teknis di Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mentimun di Awan: Menggunakan Skrip BDD untuk Pengujian Stres Produk</a> (Anton Kosyakin, Manajer Produk Teknis pada Platform ALICE). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425813/">https://habr.com/ru/post/id425813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425803/index.html">Perjuangan untuk sumber daya, bagian 3: ada sedikit memori</a></li>
<li><a href="../id425805/index.html">DevOops 2018: streaming online gratis, pesta, dan lainnya</a></li>
<li><a href="../id425807/index.html">Kompleksitas sistem dan metode "perjuangan" dengannya</a></li>
<li><a href="../id425809/index.html">Mempelajari bahasa pemrograman dalam proses: pengembang perangkat lunak tentang proyek yang kompleks</a></li>
<li><a href="../id425811/index.html">Masalah Tampilan MacBook Pro Lainnya</a></li>
<li><a href="../id425815/index.html">Siapa yang tidak butuh SEO, bagaimana memilih pengoptimal dan menguji kerjanya</a></li>
<li><a href="../id425817/index.html">Seret & Jatuhkan di aplikasi iOS Anda</a></li>
<li><a href="../id425819/index.html">GitLab 11.3 dirilis dengan repositori Maven dan lingkungan yang aman</a></li>
<li><a href="../id425821/index.html">Bagaimana menjadi pengembang Bereaksi pada tahun 2018</a></li>
<li><a href="../id425823/index.html">Statistik IPO 2018: $ 45 miliar diperoleh, Dropbox mengumpulkan lebih sedikit uang daripada perusahaan farmasi dan penjual real estat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>