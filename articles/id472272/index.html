<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔬 🥓 🌆 Gim baru dengan suasana lama di Three.js. Bagian 2 📥 😡 🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama saya berbicara tentang masalah yang saya temui dalam proses pembuatan game 3D untuk browser menggunakan Three.js. Sekarang saya in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gim baru dengan suasana lama di Three.js. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472272/"> Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> saya berbicara tentang masalah yang saya temui dalam proses pembuatan game 3D untuk browser menggunakan Three.js.  Sekarang saya ingin membahas secara terperinci penyelesaian beberapa masalah penting saat menulis gim, seperti membangun level, mendeteksi tabrakan, dan mengadaptasi gambar ke proporsi jendela peramban apa pun. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/jr/45/dsjr45-khpwum64yaoqvndmfynw.jpeg"></div><br><h3>  Diagram level </h3><br>  Sebenarnya, level itu sendiri dibuat dalam editor 3D, yaitu geometri, pemetaan tekstur, pembuatan bayangan, dll.  Saya menggambarkan semua ini di bagian pertama.  Mengapa ada skema lain?  Faktanya adalah bahwa Three.js tidak menawarkan segala jenis mesin fisik, dan saya menggunakan skema level untuk mengidentifikasi kendala. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/7u/j6/pk7uj6hvp3cyrkehdo_ohagtfnc.jpeg"></div><br>  Three.js untuk menyelesaikan masalah tabrakan hanya menawarkan raytracing - cara paling sederhana untuk menentukan persimpangan geometri objek.  Pada prinsipnya, ini dapat digunakan, dan saya bahkan melakukannya di salah satu proyek saya yang lain.  Itu adalah kota virtual tepat di situs, di browser.  Anda bisa bergerak keliling kota dan tidak melewati tembok. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/8y/4s/ud8y4smxvagibioopva3vc1ajoc.jpeg"></div><br>  Dalam kasus ketika persimpangan geometri pemain dan bangunan terjadi selama gerakan, saya menerapkan tolakan pemain dengan jarak tertentu ke arah yang berlawanan dengan dinding.  Tetapi untuk ini, objek harus paralelepiped.  Di sekitar beberapa objek yang kompleks, saya membuat colliders (kami akan memanggil objek tak kasat mata yang memainkan peran sebagai penghalang dan mencegah pemain melewati diri mereka sendiri), yang melaluinya persimpangan dibuat.  Dan bagian bawah dari beberapa bangunan, yang hanya "kotak", kadang-kadang digunakan sebagai colliders sendiri. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/on/3e/fzon3eg8bjup0zvzs_cgg81lrmo.jpeg"></div><br>  Pada objek yang secara geometris kompleks, penelusuran sinar mungkin tidak berfungsi atau berperilaku tidak tepat.  Dan, seperti solusi alternatif, Anda dapat menanamkan objek bukan hanya satu, tetapi beberapa colliders kecil yang tak terlihat dalam bentuk paralelepiped dengan transparansi 100%, yang disusun bersebelahan dan di atas satu sama lain, secara kasar mengulangi bentuk objek. <br><br>  Dalam game tentang ruang bawah tanah, level adalah objek panjang tunggal dengan gerakan potong untuk memindahkan pemain.  Sebenarnya, untuk menyelesaikan masalah tabrakan, seseorang dapat menempel colliders yang tidak terlihat di mana diperlukan dan menggunakan raytracing.  Namun, saya memutuskan untuk pergi ke arah lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ul/ln/rzullnsn4a_befsw71uctfqjyzg.jpeg"></div><br><ul><li>  Pertama, saya ingin mengotomatisasi proses menciptakan berbagai colliders. </li><li>  Kedua, Anda hanya dapat menggunakan informasi tentang colliders, yaitu koordinatnya di ruang angkasa, dan tidak memuat adegan 3D itu sendiri dengan beberapa objek kosong tambahan. </li><li>  Ketiga, karena permainan hanya menggunakan tampilan sisi dan salah satu koordinat tidak pernah berubah saat bergerak, Anda dapat menggunakan perhitungan persimpangan hanya dalam dua koordinat. </li><li>  Dan keempat, setelah semua, pada kenyataannya, akan ada skema level.  Selain itu, datang dengan level baru hanya nyaman dimulai dengan skema seperti itu.  Anda cukup menyeret blok di sekitar layar dalam editor grafis apa pun, membangun koridor dan hambatan baru, dan kemudian menjalankan skrip dan mendapatkan informasi tentang colliders.  Artinya, masalah editor level sebagian diselesaikan. </li></ul><br>  Saya menulis sebuah skrip yang mengambil parameter input seperti nama file skema level (png) dan warnanya, yang isinya ditafsirkan sebagai hambatan.  Warna ruang kosong standar adalah hitam.  Untuk diproses oleh skrip, skema setiap level harus disimpan dalam file png terpisah.  Misalnya, untuk level terendah, tampilannya seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/rg/kw/bargkw-qc8xqbvpszjia3zvnllq.jpeg"></div><br>  Saya setuju bahwa satu blok harus memiliki lebar 80 piksel dan tinggi 48 piksel.  Ini sesuai dengan 4 x 2,4 meter di dunia 3D.  Dimungkinkan untuk membuat 40 x 24 piksel, yaitu, sepuluh kali, tetapi dalam gambar terlihat kecil. <br><br>  Hasil skrip di tingkat pertama (gambar dipotong ke kanan): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xx/zu/9f/xxzu9fsntacg-giuqubbj75iq5k.jpeg"></div><br>  Script dieksekusi di browser.  Saya pikir tidak ada gunanya markup html, itu dasar: bidang entri data dan tombol mulai.  Selanjutnya, gambar baca ditampilkan di kanvas.  Dan sebagai hasil dari skrip, sebuah array ditampilkan di bawah gambar dalam skala dunia 3D, yang berisi koordinat kiri dan kanan atas setiap blok, dan dengan offset yang ditentukan dalam skrip untuk setiap level.  Array ini dapat disalin dan ditempelkan ke dalam daftar collider untuk digunakan dalam game (lebih lanjut tentang itu di bawah), itu akan disimpan dalam semacam konstan.  Koordinat juga muncul pada gambar itu sendiri, tetapi dalam kerangka referensi gambar 2D.  Angka-angka ini ditampilkan di tengah setiap blok dan memungkinkan Anda untuk memeriksa apakah semua blok termasuk dalam perhitungan.  Sendiri, angka-angka ini tidak diperlukan untuk apa pun kecuali untuk inspeksi visual.  Beberapa blok, seperti kolom yang dilewati pemain, tidak boleh dihitung.  Tentang objek mana yang dikecualikan dari perhitungan - di bawah ini. <br><br>  Selain itu, misalnya, di tingkat kedua ada pelat horizontal tipis tempat pemain berjalan.  Mereka harus dipertimbangkan.  Oleh karena itu, Anda perlu memastikan bahwa angka-angka juga muncul pada mereka.  Dalam diagram, buat tingginya 2 piksel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/vm/w1/pqvmw1tghz4brz--t0qh6y-bzek.jpeg"></div><br><br>  Sekarang, tentang bagaimana skrip memperhitungkan blok: <br><br><ul><li>  Skema ini diproses oleh blok 80x48, di mana masing-masing area diambil dari piksel ke-2 hingga ke-79 secara horizontal dan dari piksel ke-ke-47 secara vertikal.  Pixel pertama dan terakhir tidak digunakan sehingga di sekitar blok Anda dapat membuat bingkai hitam dengan lebar 1 piksel, ini meningkatkan persepsi visual dari rangkaian dan memfasilitasi pembuatannya. </li><li>  Semua piksel dari baris atas blok dilihat.  Jika ada yang berwarna di antara mereka, maka koordinat blok bergerak dari pixel berwarna pertama ke terakhir secara horizontal dan ke ketinggian penuh blok secara vertikal dalam array terakhir.  Ini akan menjadi blok kosong pada lebar penuh atau sebagian. </li><li>  Semua piksel garis bawah blok dilihat.  Jika ada yang berwarna di antara mereka, tetapi tidak ada satu berwarna di baris atas, maka koordinat blok bergerak dari pixel berwarna pertama ke terakhir secara horizontal dan 3 piksel secara vertikal dari bawah ke array terakhir.  Ini akan menjadi platform untuk berjalan.  Di dalam satu blok ada beberapa platform horisontal.  Platform dikenali hanya di bagian bawah blok.  Koordinat platform "tenggelam" ke dalam blok, yang terletak di bawah, sehingga permukaan platform berada pada level yang sama dengan blok tetangga - bukan platform. </li><li>  Kolom dan dekorasi lainnya di dalam blok kosong tidak diproses, karena hanya baris piksel atas dan bawah yang dipertimbangkan.  Oleh karena itu, di dalam blok, Anda dapat menempatkan dekorasi, penjelasan untuk diagram, petunjuk, kolom, dll., Tanpa takut bahwa ini entah bagaimana akan mempengaruhi hasil skrip. </li></ul><br>  Kemudian semua koordinat yang diperoleh dari array diterjemahkan ke dalam skala dunia 3D, dikalikan dengan koefisien skalanya (yang dipilih dalam editor 3D saat dibuat).  Array siap digunakan dalam gim.  Kode skrip ditulis dengan tergesa-gesa, sehingga tidak berpura-pura anggun, tetapi melakukan tugasnya. <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre><code class="javascript hljs">ap = { <span class="hljs-comment"><span class="hljs-comment">//      (  ),   3D   lvd: { 'lv01.png': { invw: false, invh: true, level_dw: -8.5, level_dh: -1.5 }, 'lv02.png': { invw: true, invh: true, level_dw: -19.5, level_dh: -5.5 } }, blockw: 80, //   2D blockh: 48, //   2D sc3d: 0.05, //,   3D  ex: 100, //  3D (-   ) v: { data: [] }, i: 0, par: {}, datai: [], resi: [], ars: [], fStopEncode: false, blockColor: function(cl) { document.getElementById('input_cl').value = cl; }, startEncode: function() { //      for (var key in ap.lvd) { ap.lvd[key].dw = ap.lvd[key].level_dw * ap.blockw; ap.lvd[key].dh = ap.lvd[key].level_dh * ap.blockh; }; document.getElementById('startbtn').style.display = 'none'; document.getElementById('startmsg').style.display = 'block'; var cl = document.getElementById('input_cl').value; var fld = document.getElementById('input_fld').value; var nm = document.getElementById('input_nm').value; ap.nm = nm; ap.par = { path: [fld + '/', nm], key: [nm], cl: aplib.hexToRgb(cl.substring(1, 7)) }; setTimeout(function() { ap.datai[ap.par.key] = new Image(); ap.datai[ap.par.key].onload = function() { ap.parseData(); }; ap.datai[ap.par.key].src = ap.par.path[0] + ap.par.path[1]; }, 500); }, stopEnode: function(e) { if (typeof ap !== "undefined") { if (e.keyCode == 27) { console.log('stop'); ap.fStopEncode = true; }; }; }, parseData: function() { ap.w = ap.datai[ap.par.key[0]].width, ap.h = ap.datai[ap.par.key[0]].height; aplib.initCanv(ap.w, ap.h); ctx.drawImage(ap.datai[ap.par.key[0]], 0, 0, ap.w, ap.h, 0, 0, ap.w, ap.h); ap.ars = []; ap.i = 0; setTimeout(function() { ap.parseData1(); }, 1000); }, parseData1: function() { if (ap.i &lt; ap.par.key.length) { document.getElementById('info').innerHTML = '' + ap.nm; ap.blocksw = Math.floor(ap.w / ap.blockw); ap.blocksh = Math.floor(ap.h / ap.blockh); ap.ar = []; ap.arv = {}; ap.hi = 0; ctx.fillStyle = '#CCCCCC'; ap.parseData2(); } else { document.getElementById('startbtn').style.display = 'block'; document.getElementById('startmsg').style.display = 'none'; }; }, parseData2: function() { if (ap.hi &lt; ap.blocksh) { ap.ar.push([]); ap.wi = 0; ap.parseData3(); } else { ap.parseData4(); }; }, parseData3: function() { var k = ''; if (ap.wi &lt; ap.blocksw) { var fground = true, fvari = false, fempty = true; var upx1 = 0, upx2 = 0, dnx1 = 0, dnx2 = 0; var upxf = false, dnxf = false; for (var wii = 1; wii &lt; ap.blockw - 2 + 2; wii++) { pixelDatai = ctx.getImageData(ap.wi * ap.blockw + wii, ap.hi * ap.blockh + 1, 1, 1).data; //  pixelDatai2 = ctx.getImageData(ap.wi * ap.blockw + wii, (ap.hi + 1) * ap.blockh - 3, 1, 1).data; //  if ((pixelDatai[0] == ap.par.cl.r) &amp; (pixelDatai[1] == ap.par.cl.g) &amp; (pixelDatai[2] == ap.par.cl.b)) { //   ground    if (upxf == false) { upxf = true; upx1 = wii; }; } else { //    if (upxf == true) { upx2 = wii + 1; upx1--; //   dy = -1; // 3D       1 ap.v.data.push([ap.wi * ap.blockw + upx1, ap.hi * ap.blockh + dy, ap.wi * ap.blockw + upx2, ap.hi * (ap.blockh) + ap.blockh - 1]); upxf = false; upx1 = 0; upx2 = 0; }; }; if ((pixelDatai2[0] == ap.par.cl.r) &amp; (pixelDatai2[1] == ap.par.cl.g) &amp; (pixelDatai2[2] == ap.par.cl.b)) { //   ground     if (upxf == false) { if (dnxf == false) { dnxf = true dnx1 = wii; }; }; } else { if (upxf == false) { if (dnxf == true) { dnx2 = wii + 1; dnx1--; //   dy = 2; // 3D    2 ap.v.data.push([ap.wi * ap.blockw + dnx1, (ap.hi + 1) * ap.blockh - 3 + dy, ap.wi * ap.blockw + dnx2, (ap.hi + 1) * ap.blockh - 3 + 2 + dy]); dnxf = false; dnx1 = 0; dnx2 = 0; }; }; }; }; if (ap.fStopEncode == true) { ap.hi = ap.h, ap.wi = ap.w, i = ap.par.key.length; }; setTimeout(function() { ap.wi++; ap.parseData3(); }, 10); } else { ap.hi++; ap.parseData2(); }; }, parseData4: function() { setTimeout(function() { var t, tw, tx, ty, ar = []; //  for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; t = ar[0] + ';' + (ar[1]+1) + '&lt;br/&gt;' + ar[2] + ';' + (ar[3]+1); tw = ar[2] - ar[0]; tx = ar[0]; ty = ar[1] + Math.floor((ar[3] - ar[1]) / 2) - 0; aplib.Tex2Canvas(ctx, t, 'normal 10px Arial', 10, '#CCCCCC', tx, ty, tw, 0, 'center', 'top'); }; ap.parseData5(); }, 10); }, parseData5: function() { var t, tw, tx, ty, ar = [], n; //   3D var lv = ap.lvd[ap.nm]; for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; ar[0] += lv.dw; ar[1] += lv.dh; ar[2] += lv.dw; ar[3] += lv.dh; if (lv.invh == true) { n = -ar[1]; ar[1] = -ar[3]; ar[3] = n; }; if (lv.invw == true) { n = -ar[0] ar[0] = -ar[2]; ar[2] = n; }; ar[0] = Math.round(ap.sc3d * ar[0] * ap.ex) / ap.ex; ar[1] = Math.round(ap.sc3d * ar[1] * ap.ex) / ap.ex; ar[2] = Math.round(ap.sc3d * ar[2] * ap.ex) / ap.ex; ar[3] = Math.round(ap.sc3d * ar[3] * ap.ex) / ap.ex; }; //    ap.v.data.sort(aplib.sortBy0); console.log(ap.v.data); document.getElementById('divresult').innerHTML = JSON.stringify(ap.v.data); } }; aplib = { hexToRgb: function(hex) { var arrBuff = new ArrayBuffer(4); var vw = new DataView(arrBuff); vw.setUint32(0, parseInt(hex, 16), false); var arrByte = new Uint8Array(arrBuff); return { r: arrByte[1], g: arrByte[2], b: arrByte[3], s: arrByte[1] + "," + arrByte[2] + "," + arrByte[3] }; }, //   canvas Tex2Canvas: function(ctx, t, font, lin, fcolor, x, y, w, h, haln, valn) { //left, right, center, center-lim- ctx.font = font; ctx.fillStyle = fcolor; var l = 0; var tx = x; var ftw = false; var tw = 1; var arr = t.split('&lt;br/&gt;'); for (var i = 0; i &lt; arr.length; i++) { arr[i] = arr[i].split(' '); }; for (var i = 0; i &lt; arr.length; i++) { var s = '', slen = 0, s1 = '', j = 0; while (j &lt; arr[i].length) { var wordcount = 0; while ((slen &lt; w) &amp; (j &lt; arr[i].length)) { s = s1; s1 = s + arr[i][j] + ' '; slen = ctx.measureText(s1).width; if (slen &lt; w) { j++; wordcount++; } else { if (wordcount &gt; 0) { s1 = s; } else { j++; }; }; }; ftw = false; tw = ctx.measureText(s1).width; if (haln == 'center') { tx = x + Math.round((w - tw) / 2); }; if (haln == 'right') { tx = x + Math.round((w - tw)); }; if (haln == 'center-lim') { if (tw &gt; w) { tw = w; }; if (tw &lt; 1) { tw = 1; }; tx = x + Math.round((w - tw) / 2); ftw = true; }; if (ftw == false) { ctx.fillText(s1, tx, l * lin + y); } else { ctx.fillText(s1, tx, l * lin + y, tw); }; if (s1 == '') { j = arr[i].length + 1; }; l++; s1 = ''; slen = 0; }; }; return Math.round(tw); }, // canvas initCanv: function(w, h) { function canvErr() { document.getElementById('divcanv').innerHTML = '&lt;div style="height:130px"&gt;&lt;/div&gt;&lt;div style="width:440px; border:#FFFFFF 1px solid; margin:10px; padding:4px; background-color:#000000"&gt;&lt;p class="txterr"&gt;---&gt; Error&lt;br/&gt;HTML5 Canvas is not supported!&lt;br/&gt;Please, update your browser!&lt;/p&gt;&lt;/div&gt;'; }; if (w == 0) { w = 740; h = 680; }; elcanv = document.getElementById('divcanv'); elcanv.innerHTML = '&lt;canvas id="canv" style="width:' + w + 'px; height:' + h + 'px; display:block;" width="' + w + '" height="' + h + '"&gt;&lt;/canvas&gt;'; canvas1 = document.getElementById('canv'); if (!canvas1) { canvErr(); return 0; } else { if (canvas1.getContext) { ctx = canvas1.getContext('2d'); ctx.clearRect(0, 0, w, h); return 1; } else { canvErr(); }; }; }, sortBy0: function(i, ii) { if (i[0] &gt; ii[0]) return 1; else if (i[0] &lt; ii[0]) return -1; else return 0; } };</span></span></code> </pre> <br></div></div><br>  Sekarang - tentang cara permainan bekerja dengan berbagai blok.  Gim ini menggunakan koridor berpotongan (level).  Ketika seorang pemain berubah menjadi koridor, array blok baru terhubung: dan untuk setiap koridor, sesuai, array sendiri diperoleh, diperoleh dari skema levelnya.  Selama pergerakan pemain, koordinatnya diperiksa untuk berada di dalam setiap blok.  Dan jika dia ada di dalam blok apa pun, maka kita mendapatkan tabrakan.  Tetapi dengan setiap gerakan pemain kita tidak perlu mencari persimpangan dengan semua blok level, karena bisa ada banyak dari mereka.  Buat array hanya blok yang paling dekat dengan pemain. <br><br><pre> <code class="javascript hljs">collisionsUpdate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, dw, dh</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coll = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ap.v.lv.d.length; i++) { o = ap.v.lv.d[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= x - ap.v.dw) &amp; (o[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= x + ap.v.dw)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;= y - ap.v.dh) &amp; (o[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= y + ap.v.dh)) { coll.push(o); }; }; }; ap.v.coll = coll; },</code> </pre> <br>  Di sini, pada input x, y adalah koordinat pemain saat ini, dw, dh adalah jarak di mana Anda ingin mencari blok secara horizontal dan vertikal, misalnya 12 dan 8 meter.  Dengan kata lain, ambil semua blok di sekitar pemain dalam kotak 24x16 meter persegi.  Mereka akan berpartisipasi dalam pencarian bentrokan.  ap.v.lv.d [i] adalah elemen dari array blok dari level saat ini, pada kenyataannya, dia sendiri juga merupakan array dari 4 angka yang mendefinisikan batas-batas satu blok - [x1, y1, x2, y2], oleh karena itu, untuk memeriksa kuadrat secara horizontal kita mengambil elemen dengan indeks 0 dan 2, dan secara vertikal - 1 dan 3. Jika ada kecocokan, lalu tambahkan blok ini ke daftar untuk collision ap.v.coll. <br><br>  Ketika pemain bergerak, kami akan memperbarui daftar tabrakan ini, tetapi, untuk menghemat kinerja, kami akan melakukan ini tidak pada setiap langkah (atau lebih tepatnya, merender frame), tetapi ketika pemain meninggalkan kotak tertentu, sedikit lebih kecil, ditentukan dalam ap.v.collwStep dan ap.v.collhStep, mis. 8 dan 4 meter.  Artinya, kita akan memasang kembali susunan tabrakan lagi ketika pemain melewati jalur tertentu secara horizontal atau vertikal dari posisi aslinya.  Pada saat yang sama, mari kita ingat posisinya di mana kita memasang kembali array untuk menggunakannya untuk iterasi berikutnya.  pers [kapak] - di sini dengan kapak yang kami maksud adalah sumbu koordinat (kapak), bisa x atau z, tergantung pada arah koridor di mana pemain berjalan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if ((Math.abs(pers[ax] - ap.v.collw) &gt; ap.v.collwStep) || (Math.abs(pers.y - ap.v.collh) &gt; ap.v.collhStep)) { ap.v.collw = pers[ax]; ap.v.collh = pers.y; ap.collisionsUpdate(pers[ax], pers.y, 12, 8); };</span></span></code> </pre> <br>  Mengapa kesulitan seperti itu?  Mengapa tidak menggunakan seluruh susunan tabrakan di tingkat dan tidak mandi uap.  Faktanya adalah bahwa deteksi tabrakan dilakukan sesuai dengan algoritma yang jauh lebih kompleks, dan tidak menguntungkan untuk memeriksa tabrakan dengan benar-benar semua blok level, dan bukan yang paling dekat, di setiap frame rendering.  (Meskipun, ini tidak akurat.) <br><br>  Definisi tabrakan pada setiap rendering frame menggunakan array collision yang disiapkan di atas: <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="javascript hljs">collisionsDetect: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, xOld, yOld, up</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//up=-1 -  var res = false, o; var collw = false, collh = false, collwi = false, collhi = false, collhsup = false, support = [], supportf = false, fw = false, upb = -1; var bub = -1, bubw = 0; var pw2 = ap.v.player.pw2, ph2 = ap.v.player.ph2, supportd = ap.v.supportd; for (var i = 0; i &lt; ap.v.coll.length; i++) { o = ap.v.coll[i]; collwi = false; collhi = false; collhsup = false; fw = false; if ((x + pw2 &gt;= o[0]) &amp; (x - pw2 &lt;= o[2])) { if ((y + ph2 &gt; o[1]) &amp; (y - ph2 &lt; o[3])) { collwi = true; }; }; //     if ((xOld + pw2 &gt;= o[0]) &amp; (xOld - pw2 &lt;= o[2])) { if ((yOld + ph2 &gt; o[1]) &amp; (yOld - ph2 &lt; o[3])) { bub = i; if (Math.abs(xOld - o[0]) &lt; Math.abs(xOld - o[2])) { bubw = -1; } else { bubw = 1; }; }; }; if ((x &gt;= o[0]) &amp; (x &lt;= o[2])) { fw = true; //  i   }; if ((y + ph2 &gt;= o[1]) &amp; (y - ph2 &lt;= o[3])) { if ((x &gt; o[0]) &amp; (x &lt; o[2])) { collhi = true; //  if (y + ph2 &gt; o[3]) { collhsup = true; supportf = true; support = o; upb = 1; }; //  if (y - ph2 &lt; o[1]) { upb = -1; }; }; }; if ((y - ph2 &gt;= o[3] + supportd - 0.11) &amp; (y - ph2 &lt;= o[3] + supportd + 0.001)) { if (fw == true) { collhi = true; collh = true; res = true; collhsup = true; supportf = true; support = o; }; }; if (collwi &amp; collhi) { res = true; }; if (collwi) { collw = true; }; if (collhi) { collh = true; }; }; return { f: res, w: collw, h: collh, support: support, supportf: supportf, upb: upb, bub: bub, bubw: bubw }; },</span></span></code> </pre> <br></div></div><br>  Di sini x, y, xOld, yOld adalah koordinat baru dan saat ini dari pemain.  Yang baru dihitung dengan satu sentuhan tombol, berdasarkan kecepatan yang diberikan, yaitu, ini adalah koordinat yang memungkinkan.  Mereka diperiksa untuk melihat apakah mereka berada di dalam blok mana pun dari daftar tabrakan.  Jika mereka jatuh, maka mereka kembali ke yang lama, dan pemain tidak melewati rintangan.  Dan jika mereka tidak jatuh, maka mereka menjadi lancar.  pw2 dan ph2 adalah setengah lebar dan tinggi collider imajiner pemain (lebar pemain / 2, tinggi pemain / 2).  Output dikeluarkan jika ada tabrakan horizontal dan vertikal (collw, collh), apakah ada blok dukungan di bawah pemain (supportf) - ini memperjelas apakah akan memulai animasi musim gugur lebih lanjut atau jika pemain hanya beralih ke blok tetangga, dan seterusnya.  Hanya saja, jangan bertanya mengapa saya menambahkan 0,001 di sana dan mengurangi 0,11.  Ini adalah kruk mengerikan yang mencegah jatuh melalui blok dan efek jitter ketika bertabrakan dengan penghalang horizontal ... Fungsi ini berfungsi, tetapi perlu ditulis ulang dengan cara normal.  Optimalisasi fungsi ini juga belum hilang. <br><br>  Saya pikir dengan tabrakan itu ada baiknya untuk mengakhiri di sini. <br><br>  Sulit untuk mengatakan seberapa cepat metode saya atau mungkin lebih lambat daripada penelusuran ray, tetapi dalam kasus yang terakhir, Three.js juga menyimpan berbagai objek yang berpartisipasi dalam sistem tumbukan.  Hanya saja tabrakan di sana ditentukan oleh metode memancarkan sinar dan persimpangan dengan bidang sisi-sisi objek, dan dengan saya, dengan menentukan apakah koordinat satu objek berada di dalam yang lain di sepanjang masing-masing kedua sumbu. <br><br>  Gim ini juga memiliki objek bergerak (hiu) dan objek penanda yang memicu beberapa jenis animasi (misalnya, kontak dengan air memicu pergerakan hiu).  Semua objek ini juga berpartisipasi dalam tabrakan, dan beberapa dengan koordinat waktu yang bervariasi.  Di sana, anehnya, semuanya lebih sederhana: selama pergerakan objek koordinatnya dibandingkan dengan koordinat pemain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/cx/rz/mjcxrz4m_3fwkm7kep-yrtbp-qa.jpeg"></div><br><h3>  Gamepad </h3><br>  Secara umum, memelihara gamepad javascript di browser bukanlah tugas yang sepele.  Tidak ada tombol tekan dan lepaskan acara.  Hanya ada peristiwa yang menghubungkan dan melepaskan perangkat dan keadaan yang dapat diperoleh dengan pemungutan suara berkala, dan kemudian membandingkannya dengan yang sebelumnya. <br><br>  Sebuah video yang mendemonstrasikan pengoperasian gamepad di browser pada tablet pada Windows 8.1 dan PC pada Windows 10. Tablet ini, bagaimanapun, adalah yang lama, dirilis pada tahun 2014, sehingga pencahayaan dinamis dimatikan dalam game di atasnya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/knkMKB5uizk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Untuk polling gamepad, fungsi yang dipanggil sekali setiap 100 milidetik digunakan.  Sudah diatur menggunakan fungsi perpustakaan saya m3d.lib.globalTimer.addEvent. <br><br><pre> <code class="javascript hljs">m3d.lib.globalTimer.addEvent({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gamepad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ti</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> st = m3d.gamepad.state(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (st == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.gpDownFlag == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { m3d.gamepad.resetH(); }; }; } });</code> </pre> <br>  Di sini globalTimer adalah sistem manajemen acara javascript setInterval timer yang saya tulis.  Di sana, sederhananya serangkaian acara ditambahkan ke array tertentu yang perlu dipanggil pada interval yang berbeda.  Kemudian, satu set timer Interval diatur dengan frekuensi yang sesuai dengan acara dengan frekuensi tertinggi dari semua.  Pengatur waktu polling fungsi m3d.lib.globalTimer.update (), yang berjalan melalui daftar semua peristiwa dan menjalankan fungsi-fungsi yang telah dijalankan.  Saat menambahkan atau menghapus acara, frekuensi interval juga dapat berubah (misalnya, jika Anda menghapus acara tercepat). <br><br>  Gim ini juga mendefinisikan penangan untuk setiap kunci gamepad: 'a' adalah untuk sumbu (kapak), 'b' adalah untuk tombol (tombol), dan 11 adalah penyimpangan kiri sepanjang sumbu horizontal dari salib (seolah-olah tombolnya 1), 12 - penyimpangan kanan sepanjang sumbu horizontal dari salib (seolah-olah tombolnya 2), 21 dan 22 - untuk sumbu vertikal.  Sebagai contoh: <br><br>  ['a', 11], <br>  ['b', 3] <br><br>  berarti bahwa fungsi selanjutnya akan diatur pada waktu yang sama untuk deviasi sepanjang sumbu horizontal ke kiri dan untuk tombol 3 (kiri).  Nah, kemudian fungsi diatur yang akan dieksekusi ketika tombol ditekan, dan kemudian ketika dirilis. <br><br><pre> <code class="javascript hljs"> m3d.gamepad.setHandler( [ [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>], [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.btState.lt == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { contr.keyDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.gpDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; apcontrolsRenderStart(); }; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m3d.contr.controlsCheckBt(); apcontrolsRenderStart(); } );</code> </pre> <br>  Di sini apcontrolsRenderStart () adalah fungsi yang meluncurkan render jika belum berjalan.  Secara umum, dukungan untuk gamepad terikat erat dengan perpustakaan m3d saya, jadi jika saya melanjutkan untuk menggambarkan semua fitur-fiturnya, itu akan membentang untuk waktu yang sangat lama ... <br><br>  Saya hanya akan memberi Anda bagian darinya - gamepad, di mana saya menerapkan inisialisasi gamepad, pemasangan penangan, dan pemungutan suara negara dengan cara paling sederhana. <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="javascript hljs">gamepad: { <span class="hljs-attr"><span class="hljs-attr">connected</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">gamepad</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">gamepadKey</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">axesCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttonsCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: [], <span class="hljs-comment"><span class="hljs-comment">//  fup: [], //  fval: [], //      fupCall: [], //   buttons: [], //link to f [0.. ] axes: [], //link to f [0.. ] initCb: function() {}, resetH: function() {}, init: function(gp) { var f = false; for (var key in gp) { if (f == false) { if (gp[key] != null) { if (typeof gp[key].id !== "undefined") { f = true; this.connected = true; this.gamepad = gp[key]; this.gamepadKey = key; }; }; }; }; if (typeof this.gamepad.axes !== "undefined") { this.axesCount = this.gamepad.axes.length; }; if (typeof this.gamepad.buttons !== "undefined") { this.buttonsCount = this.gamepad.buttons.length; }; this.f = []; this.fup = []; this.fval = []; this.fupCall = []; this.axes = []; for (var i = 0; i &lt; this.axesCount * 2; i++) { this.axes.push(-1); }; this.buttons = []; for (var i = 0; i &lt; this.buttonsCount; i++) { this.buttons.push(-1); }; this.initCb(); }, setHandlerReset: function(f) { this.resetH = f; }, setHandler: function(ar, f, fup) { //ar['b',3] ['a',11] var fi, bt, ax, finext, finexta; finexta = false; for (var i = 0; i &lt; ar.length; i++) { if (ar[i][0] == 'a') { ax = Math.floor(ar[i][1] / 10); bt = ar[i][1] - (ax * 10); bt = ax * 2 + bt - 3; fi = this.axes[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.axes[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.axes[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; } else if (ar[i][0] == 'b') { bt = ar[i][1] - 1; fi = this.buttons[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.buttons[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.buttons[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; }; }; }, state: function() { var pressed = false; var fi, fval, axesval; for (var i = 0; i &lt; this.fval.length; i++) { this.fval[i] = 0; }; //   var gp = navigator.getGamepads()[this.gamepadKey]; for (var i = 0; i &lt; this.axesCount; i++) { axesval = Math.round(gp.axes[i]); if (axesval &lt; 0) { pressed = true; fi = this.axes[i * 2]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; } else if (axesval &gt; 0) { pressed = true; fi = this.axes[i * 2 + 1]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.buttonsCount; i++) { if (gp.buttons[i].pressed == true) { pressed = true; fi = this.buttons[i]; if (fi != -1) { this.fval[fi] = 1; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.fval.length; i++) { fval = this.fval[i]; if (fval != 0) { this.f[i](this.fval[i]); } else { if (this.fupCall[i] == true) { this.fupCall[i] = false; this.fup[i](this.fval[i]); }; }; }; return pressed; } }, //gamepad</span></span></code> </pre> <br></div></div><br>  Secara umum, dukungan gamepad dalam game masih belum lengkap: hanya dukungan untuk gamepad yang paling sederhana yang diterapkan, tetapi bukan yang, misalnya, digunakan di XBox, karena saya tidak memilikinya.  Jika saya mendapatkannya, saya akan memprogramnya dan bekerja dengannya.  Akan ada kemungkinan untuk menyesuaikan kecepatan karakter, yaitu, dimungkinkan untuk bergerak pada kecepatan apa pun dalam rentang dari langkah untuk menjalankan.  Ini dicapai dengan mengambil parameter fraksional dari sumbu.  Gamepad saya hanya mengembalikan bilangan bulat -1 dan 1. Selain itu, gamepad saya memiliki salib yang menjijikkan, dan ketika ditekan kiri atau kanan, secara bersamaan menekan ke bawah atau ke atas.  Oleh karena itu, saya tidak menggunakan bagian atas dan bawah pada salib dan menduplikasinya dengan tombol di sebelah kanan gamepad ... Dengan merilis permainan saya berencana untuk membuat beberapa profil gamepad.  Selain itu, dalam hal menghubungkan beberapa gamepad, hanya yang terakhir yang akan digunakan sejauh ini. <br><br><h3>  Layar responsif </h3><br>  Gim ini dirancang untuk rasio aspek 16: 9.  Tapi saya menambahkan penyesuaian horizontal otomatis ± 10% sehingga di jendela browser yang diperluas tidak ada bilah hitam di samping: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/bn/a5/eybna55ofeptyziaakgix67heea.jpeg"></div><br>  Dan akan seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vm/0n/aa/vm0naaertcqacqufxjadz-sdfyu.jpeg"></div><br>  Dalam mode layar penuh, akan ada nyata 16: 9.  Dimungkinkan untuk mengadaptasi gambar secara umum dengan rasio aspek apa pun dari jendela browser, tapi saya tidak melakukannya, karena jendela lebar rendah akan mengarah ke sudut tampilan terlalu besar, yang tidak baik dari sudut pandang gameplay: jalan buntu yang jauh, benda, musuh akan segera terlihat dan segala sesuatu yang pemain belum perlu melihatnya.  Karena itu, saya membatasi diri untuk menyesuaikan dalam ± 10% dari 16: 9.  Namun, untuk monitor sempit (4: 3), saya menyadari kemampuan untuk beralih dari 16: 9 ke mode adaptasi dari 4: 3 ke 16: 9 dengan menekan tombol Y.  Tapi tidak lebih luas - jadi, sekali lagi, jangan sampai merusak gameplay.  Artinya, Anda dapat bermain dalam rasio 16: 9 klasik, atau Anda dapat memperbesar gambar dengan ketinggian jendela dengan memotongnya secara horizontal.  Meskipun, ini juga tidak terlalu baik, misalnya, dalam situasi arcade, ketika sesuatu terbang ke arah pemain dari samping.  Hanya sedikit waktu yang tersisa untuk reaksi.  Tetapi Anda selalu dapat dengan cepat kembali ke mode klasik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/bp/ci/rebpciy7i7vmap1bwt_ijmub2fk.jpeg"></div><br>  Adaptasi layar, serta semua tombol pintas yang digunakan dalam game ditampilkan dalam video berikut: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FamXdunFFHY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Sebenarnya, rasio aspek diatur dalam pengaturan game. <br><br><pre> <code class="javascript hljs">aspect1:{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-attr"><span class="hljs-attr">h</span></span>:<span class="hljs-number"><span class="hljs-number">720</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-comment"><span class="hljs-comment">//16x9 +- 10% aspect2:{w:960, h:720, p:34}, //4x3 +- 34%</span></span></code> </pre> <br>  Dan di dalam gim, saat Anda menekan Y, itu akan berganti: <br><br><pre> <code class="javascript hljs">contr.btCodesDn[<span class="hljs-number"><span class="hljs-number">89</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//'y' if (m3dcache.setup.aspect.swch == 1) { m3dcache.setup.aspect = m3dcache.setup.aspect2; m3dcache.setup.aspect.swch = 2; } else { m3dcache.setup.aspect = m3dcache.setup.aspect1; m3dcache.setup.aspect.swch = 1; }; m3d.core.onWindowResize(0); m3d.contr.renderAll(); };</span></span></code> </pre> <br>  Perpustakaan saya memiliki acara yang menggantung di jendela ukuran.  Ini adalah bagiannya: <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m3dcache.v.vw = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; m3dcache.v.vh = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; m3dcache.v.vclipw = <span class="hljs-number"><span class="hljs-number">0</span></span>; m3dcache.v.vcliph = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m3dcache.setup.aspect.w == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (m3dcache.setup.aspect.h == <span class="hljs-number"><span class="hljs-number">0</span></span>)) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.setup.aspect.w, m3dcache.setup.aspect.h, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect.p !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o.clipx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ow = ow * (m3dcache.setup.aspect.p / <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ow &gt; m3dcache.v.vw) { ow = m3dcache.v.vw; }; o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ow, oh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); }; }; m3dcache.v.vclipw = o.clipx; m3dcache.v.vcliph = o.clipy; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> margx = o.clipx + <span class="hljs-string"><span class="hljs-string">'px'</span></span>, margy = o.clipy + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginTop = margy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginTop = margy; }; m3dcache.v.vw = ow; m3dcache.v.vh = oh; }; };</code> </pre> <br></div></div><br>  m3d.lib.inBlock juga merupakan fungsi dari perpustakaan saya, yang menuliskan persegi panjang ke dalam persegi panjang lain dengan parameter seperti pemusatan, penskalaan atau pemangkasan, dan menampilkan dimensi baru dari persegi panjang bertulis, serta ukuran bidang yang dibentuk dalam proses ini.  Berdasarkan informasi ini, wadah div jendela diposisikan.  'renderer' adalah elemen konteks blok dari adegan 3D.  Kemudian kanvas diskalakan di sana sesuai dengan parameter yang diperoleh. <br><br>  UI ditampilkan dalam wadah pada elemen kanvas yang terpisah.  Secara umum, pohon dokumen terdiri dari tiga blok DIV transparan dengan posisi absolut (lebih atau kurang mungkin, tergantung pada kebutuhan permainan): di bagian bawah adalah kanvas adegan 3D, di atas adalah kanvas untuk IU dan bagian atas digunakan untuk menghidupkan elemen antarmuka dan efek visual lainnya. .  Artinya, UI tidak dirender dalam 3D, tetapi pada knavass-nya, atau lapisan.  Tugas menggabungkan lapisan menjadi satu gambar diserahkan ke browser.  Untuk bekerja dengan UI, saya memiliki objek khusus di perpustakaan.  Secara singkat - intinya adalah sebagai berikut.  Daftar sprite dengan elemen UI dalam format png dengan transparansi dimuat.  Dari sana, elemen yang diperlukan diambil - latar belakang, tombol.  Dan mereka digambar di kanvas tengah menggunakan fungsi js drawImage (img, ix, iy, iw, ih, x, y, w, h).  Artinya, fragmen yang diperlukan dari gambar ditampilkan di posisi yang diperlukan di layar.  Tombol ditampilkan di atas latar belakang yang melekat padanya - semua posisi dan ukurannya diatur dalam konfigurasi UI.  Saat mengubah ukuran jendela, posisi elemen pada kanvas target (tempat mereka ditampilkan) dihitung ulang, tergantung pada apakah elemen ini atau itu dipusatkan secara horizontal dan vertikal atau dijepret ke sudut atau wajah layar mana saja.  Ini menciptakan UI adaptif yang tidak bergantung pada rasio aspek layar.  Hanya perlu untuk mengatur resolusi minimum yang mungkin secara horizontal dan vertikal dan tidak jatuh di bawahnya sehingga elemen tidak tumpang tindih satu sama lain.  Saya akan berbicara tentang UI lain kali, karena artikelnya ternyata sangat banyak, dan saya masih bekerja di UI, karena masih ada banyak kekurangan fungsi yang saya butuhkan.  Misalnya, pada monitor resolusi tinggi, antarmuka akan terlihat kecil.  Anda dapat mengalikan ukuran elemen dengan koefisien tertentu, tergantung pada resolusi layar.  Di sisi lain, mungkin tombol besar di layar tidak diperlukan?  Jika resolusi layar sangat besar, maka layar itu sendiri cukup besar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/id/am/kgidamgcsszbyxejvyyar7bgave.jpeg"></div><br>  Dan Anda dapat memberi programmer pilihan - apakah akan skala IU secara dinamis dengan ukuran jendela atau untuk mendistribusikan elemen di sudut-sudut.  Dalam hal ukuran dinamis, ada juga pertanyaan mereka sendiri - misalnya, "sabun" antarmuka saat ditampilkan pada skala yang terlalu besar.  Jika Anda membuat sprite elemen antarmuka dalam resolusi besar yang sengaja, maka mereka akan memakan banyak ruang dan juga, mungkin, itu tidak akan berguna untuk perangkat kecil - mereka masih tidak membutuhkan sprite besar, tetapi mereka akan menghabiskan memori. <br><br>  Saya pikir itu cukup untuk hari ini.  Masih ada sesuatu untuk dipikirkan, bagaimana menerapkan ini atau itu.  Sementara itu, saya ngelantur untuk beberapa waktu dari pemrograman dan melakukan promosi.  Saya berencana untuk berpartisipasi dalam sepasang pameran indie dan secara aktif terlibat dalam promosi permainan di jejaring sosial, karena pada bulan November saya berencana untuk pergi ke platform crowdfunding: Saya akan membutuhkan spesialis di bidang grafik 3D dan animasi kerangka untuk menyelesaikan permainan. <br><br>  Dalam artikel berikut, saya akan berbicara tentang kontrol sentuh di browser untuk perangkat seluler - tidak semua orang menghubungkan gamepad atau keyboard ke tablet, tentang mengoptimalkan grafik 3D untuk perangkat berdaya rendah, dan banyak lagi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472272/">https://habr.com/ru/post/id472272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472258/index.html">Cara "belajar belajar" - meningkatkan perhatian</a></li>
<li><a href="../id472262/index.html">Intisari materi menarik untuk pengembang seluler # 318 (pada 14-20 Oktober)</a></li>
<li><a href="../id472264/index.html">Arkeologi digital dan realitas virtual atau bagaimana saya mencoba berteman dengan BIM dan VR</a></li>
<li><a href="../id472268/index.html">Meningkatkan kontrol Microsoft Edge di Chromium</a></li>
<li><a href="../id472270/index.html">"Anda tidak memiliki akses ke doa saat ini": manik-manik hi-tech dari Vatikan diretas dalam 15 menit</a></li>
<li><a href="../id472274/index.html">Remote SSH: kiat dan peretasan</a></li>
<li><a href="../id472278/index.html">Git favorit saya berkomitmen</a></li>
<li><a href="../id472280/index.html">Tugas menentukan keberadaan telapak tangan pada pemindai vena</a></li>
<li><a href="../id472288/index.html">9 ekstensi browser yang berguna untuk pengembang (daftar untuk 2020)</a></li>
<li><a href="../id472290/index.html">Struktur vs. Kelas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>