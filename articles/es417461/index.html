<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë† üö™ üë©üèæ Ivan Tulup: as√≠ncrono en JS bajo el cap√≥ üëµüèΩ üõ§Ô∏è ‚ÑπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øConoces a Ivan Tulup? Lo m√°s probable es que s√≠, todav√≠a no sabes qu√© tipo de persona es esta, y debes cuidar mucho el estado de su sistema cardiovas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ivan Tulup: as√≠ncrono en JS bajo el cap√≥</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417461/">  ¬øConoces a Ivan Tulup?  Lo m√°s probable es que s√≠, todav√≠a no sabes qu√© tipo de persona es esta, y debes cuidar mucho el estado de su sistema cardiovascular. <br><br>  Acerca de esto y c√≥mo funciona el asincronismo en JS bajo el cap√≥, c√≥mo funciona Event Loop en los navegadores y Node.js, ¬øhay alguna diferencia y tal vez <strong>Mikhail Bashurov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">SaitoNakamura</a> ) dijo cosas similares en su informe sobre RIT? ++.  Nos complace compartir con ustedes la transcripci√≥n de esta presentaci√≥n informativa. <br><br><img src="https://habrastorage.org/webt/mv/fj/ah/mvfjah-dahl8fndi-w8rt4qkbxw.jpeg"><br><br>  <strong>Sobre el orador:</strong> Mikhail Bashurov es un desarrollador web fullstack en JS y .NET de Luxoft.  Le encanta la hermosa interfaz de usuario, las pruebas ecol√≥gicas, la transpilaci√≥n, la compilaci√≥n, la t√©cnica de compilaci√≥n que permite y mejorar la experiencia de desarrollo. <br><br>  <strong>Nota del editor:</strong> el informe de Mikhail estuvo acompa√±ado no solo de diapositivas, sino tambi√©n de un proyecto de demostraci√≥n en el que puede hacer clic en los botones y observar de forma independiente la ejecuci√≥n de la combinaci√≥n aleatoria.  La mejor opci√≥n ser√≠a abrir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaci√≥n</a> en una pesta√±a adyacente y consultarla peri√≥dicamente, pero el texto tambi√©n proporcionar√° enlaces a p√°ginas espec√≠ficas.  Y ahora pasamos la palabra al orador, disfruta leyendo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Abuelo Ivan Tulup </h2><br>  Ten√≠a una candidatura para Ivan Tulup. <br><br><img src="https://habrastorage.org/webt/hl/8x/lx/hl8xlx_fubycz-ivega_hinmhp0.png"><br><br>  Pero decid√≠ seguir un camino m√°s conformista, ¬°as√≠ que conoce al abuelo Ivan Tulup! <br><br><img src="https://habrastorage.org/webt/qd/jc/dn/qdjcdntndkzeyiuw3zpwt4vos74.png"><br><br>  De hecho, solo se necesitan saber dos cosas sobre √©l: <br><br><ol><li>  Le gusta jugar a las cartas. </li><li>  √âl, como todas las personas, tiene un coraz√≥n y late. </li></ol><br><h2>  Hechos de ataque al coraz√≥n </h2><br>  Es posible que haya escuchado que los casos de enfermedades card√≠acas y mortalidad por ellos se han vuelto m√°s frecuentes recientemente.  Probablemente la enfermedad card√≠aca m√°s com√∫n es un ataque card√≠aco, es decir, un ataque card√≠aco. <br><br>  ¬øQu√© tiene de interesante el ataque al coraz√≥n? <br><br><ul><li>  Muy a menudo, ocurre el lunes por la ma√±ana. </li><li>  En personas solteras, el riesgo de un ataque card√≠aco es dos veces mayor.  Aqu√≠, quiz√°s, el punto est√° √∫nicamente en la correlaci√≥n, y no en una relaci√≥n causal.  Desafortunadamente (o afortunadamente), sin embargo, esto es as√≠. </li><li>  Diez conductores murieron de un ataque al coraz√≥n durante la conducci√≥n (¬°trabajo aparentemente muy nervioso!). </li><li>  Un ataque card√≠aco es una necrosis del m√∫sculo card√≠aco causada por la falta de flujo sangu√≠neo. </li></ul><br>  Tenemos una arteria coronaria que lleva sangre al m√∫sculo (miocardio).  Si la sangre comienza a fluir mal hacia ella, el m√∫sculo muere gradualmente.  Naturalmente, esto tiene un efecto extremadamente negativo en el coraz√≥n y su trabajo. <br><br>  El abuelo Ivan Tulup tambi√©n tiene un coraz√≥n y late.  Pero nuestro coraz√≥n bombea sangre, y el coraz√≥n de Ivan Tulup bombea nuestro c√≥digo y nuestras penas. <br><br><h2>  Tasky: un gran c√≠rculo de circulaci√≥n sangu√≠nea <br></h2><br>  ¬øQu√© son las tareas?  ¬øQu√© puede ser generalmente vago en un navegador?  ¬øPor qu√© se necesitan en absoluto? <br><br>  Por ejemplo, ejecutamos c√≥digo desde un script.  Este es un latido del coraz√≥n, y ahora tenemos flujo sangu√≠neo.  Hicimos clic en el bot√≥n y nos suscribimos al evento, el controlador de eventos para este evento escupi√≥, la devoluci√≥n de llamada que enviamos.  Establecieron Timeout, Callback funcion√≥, otra tarea.  Y as√≠, en partes, un latido es una tarea. <br><br><img src="https://habrastorage.org/webt/vz/sb/0z/vzsb0znwotnkpldqmb2chhwblxs.png"><br><br>  Hay muchas fuentes diferentes de repollo, de acuerdo con la especificaci√≥n hay muchas.  Nuestro coraz√≥n contin√∫a latiendo, y mientras late, todo est√° bien con nosotros. <br><br><h3>  Event Loop en el navegador: versi√≥n simplificada <br></h3><br>  Esto se puede representar en un diagrama muy simple. <br><br><img src="https://habrastorage.org/webt/hy/zf/2p/hyzf2pktcyzag0oroich978odpa.png"><br><br><ul><li>  Hay una tarea, la hemos completado. </li><li>  Luego ejecutamos el renderizado del navegador. </li></ul><br>  Pero, de hecho, esto no es necesario, porque en algunos casos el navegador puede no procesar entre dos tareas. <br><br>  Esto puede suceder, por ejemplo, si el navegador puede decidir agrupar m√∫ltiples tiempos de espera o m√∫ltiples eventos de desplazamiento.  O en alg√∫n momento, algo sale mal, y el navegador decide en lugar de 60 fps (velocidad de fotogramas normal para que todo salga bien y sin problemas) para mostrar 30 fps.  Por lo tanto, tendr√° mucho m√°s tiempo para ejecutar su c√≥digo y otros trabajos √∫tiles, podr√° realizar varias descargas. <br><br>  Por lo tanto, el renderizado no se realiza realmente despu√©s de cada tarea. <br><br><h3>  Tasky: clasificaci√≥n <br></h3><br>  Hay dos tipos de operaciones potenciales: <br><br><ol><li>  I / O enlazado; </li><li>  CPU atado. </li></ol><br>  <strong>El l√≠mite de la CPU</strong> es nuestro trabajo √∫til que hacemos (creer, mostrar, etc.) <br><br>  <strong>Los l√≠mites de E / S</strong> son los puntos en los que podemos compartir nuestras tareas.  Podr√≠a ser: <br><br><ul><li>  Tiempo de espera </li></ul>  Hicimos setTimeout 5000 ms, y solo esperamos estos 5000 ms, pero podemos hacer otro trabajo √∫til.  Solo cuando pasa este tiempo, recibimos Callback y trabajamos un poco. <br><br><ul><li>  xhr / fetch. </li></ul>  Nos fuimos en l√≠nea.  Mientras esperamos una respuesta de la red, solo esperamos, pero tambi√©n podemos hacer algo √∫til. <br><br><ul><li>  Red (OBD). </li></ul>  O, por ejemplo, vamos a Network BD.  Tambi√©n estamos hablando de Node.js, incluido, y si queremos ir a alguna parte de la red desde Node.js, esta es la misma tarea potencial de E / S (entrada / salida). <br><br><ul><li>  Archivo. </li></ul>  Lea el archivo: potencialmente no es una tarea vinculada a la CPU.  En Node.js, se ejecuta en el grupo de subprocesos debido a una API de Linux ligeramente torcida, para ser honesto. <br><br>  Entonces CPUbound es: <br><br><ul><li>  Por ejemplo, cuando hacemos un ciclo for of / for (;;) o pasamos a trav√©s de la matriz de alguna manera usando m√©todos adicionales: filtro, mapa, etc. </li><li>  JSON.parse o JSON.stringify, es decir, serializaci√≥n / deserializaci√≥n de mensajes.  Todo esto se hace en la CPU, no podemos esperar a que todo se ejecute m√°gicamente en alguna parte. </li><li>  Contando hashes, es decir, por ejemplo, cripto miner√≠a. </li></ul><br>  Por supuesto, crypto tambi√©n se puede extraer en la GPU, pero creo que, GPU, CPU, entiendes esta analog√≠a. <br><br><h3>  Tasky: arritmia y trombo </h3><br>  Como resultado, resulta que nuestro coraz√≥n late: realiza una tarea, la segunda, la tercera, hasta que hacemos algo mal.  Por ejemplo, revisamos una matriz de 1 mill√≥n de elementos y contamos la suma.  Parece que esto no es tan dif√≠cil, pero puede llevar un tiempo tangible.  Si constantemente tomamos un tiempo tangible sin liberar la tarea, nuestro render no se puede realizar.  Se cern√≠a sobre este anhelo, y todo comienza la arritmia. <br><br>  Creo que todos entienden que la arritmia es una enfermedad card√≠aca bastante desagradable.  Pero a√∫n puedes vivir con √©l.  ¬øQu√© sucede si coloca una tarea que simplemente cuelga todo el bucle de eventos en un bucle sin fin?  De alguna manera, colocas un co√°gulo de sangre en la coronaria o en otra arteria, y todo se volver√° completamente triste.  Lamentablemente, nuestro abuelo Ivan Tulup morir√°. <br><br><h3>  Entonces el abuelo Ivan muri√≥ ... <br></h3><br><img src="https://habrastorage.org/webt/8t/nq/gc/8tnqgc8lygwpsdvts0b3xpqgtta.png"><br><br>  Para nosotros, esto significa que toda la pesta√±a se congela por completo: no puede hacer clic en nada, y luego Chrome dice: "Aw, Snap!" <br><br>  Esto es incluso mucho peor que los errores del sitio web cuando algo sali√≥ mal.  Pero si todo se bloque√≥, e incluso, probablemente, la CPU se carg√≥ y el usuario generalmente se colg√≥, lo m√°s probable es que nunca vuelva a visitar su sitio. <br><br>  Por lo tanto, la idea es la siguiente: tenemos una tarea y no necesitamos colgar en esta tarea durante mucho tiempo.  Necesitamos liberarlo r√°pidamente, para que el navegador, en todo caso, pueda renderizar (si lo desea).  Si no quieres, ¬°genial, baila! <br><br><h2>  Demo de Philip Roberts: Lupa de Philip Roberts <br></h2><br>  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> : <br><br><pre><code class="javascript hljs">$.on(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); }); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span> log(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>); }. <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(‚ÄúHello world<span class="hljs-string"><span class="hljs-string">");</span></span></code> </pre> <br>  La esencia es esta: tenemos un bot√≥n, nos suscribimos a √©l (addEventListener), Timeout se llama durante 5 segundos e inmediatamente en la consola.log escribimos "Hello, world!", En setTimeout escribimos Timeout, en onClick escribimos Click. <br><br>  ¬øQu√© suceder√° si lo ejecutamos y muchas veces hacemos clic en el bot√≥n? ¬øCu√°ndo se ejecutar√° el tiempo de espera?  Veamos la demo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  El c√≥digo comienza a ejecutarse, se pone en la pila, se agota el tiempo de espera.  Mientras tanto, hicimos clic en el bot√≥n.  Al final de la cola, se agregaron varios eventos.  Mientras Click se est√° ejecutando, Timeout espera, aunque han pasado 5 segundos. <br><br>  Aqu√≠, onClick es r√°pido, pero si pones una tarea m√°s larga, entonces todo se congelar√°, como ya se explic√≥.  Este es un ejemplo muy simplificado.  Aqu√≠ hay un giro, pero en los navegadores, de hecho, no todo es as√≠. <br><br>  ¬øEn qu√© orden se ejecutan los eventos? ¬øQu√© dice la especificaci√≥n HTML? <br><br>  Ella dice lo siguiente: tenemos 2 conceptos: <br><br><ol><li>  fuente de tarea; </li><li>  cola de tareas </li></ol><br>  El origen de la tarea es un tipo de tarea.  Esta puede ser la interacci√≥n del usuario, es decir, onClick, onChange, algo con lo que el usuario interact√∫a;  o temporizadores, es decir, setTimeout y setInterval, o PostMessages;  o incluso tipos completamente salvajes como el origen de la tarea de serializaci√≥n de blob de lienzo, tambi√©n un tipo separado. <br><br>  La especificaci√≥n dice que para la misma tarea se garantizar√° que las tareas de origen se ejecuten en el orden en que se agregan.  Para todo lo dem√°s, nada est√° garantizado, porque puede haber un n√∫mero ilimitado de colas de tareas.  El navegador decide cu√°ntos habr√°.  Con la ayuda de la cola de tareas y su creaci√≥n, el navegador puede priorizar ciertas tareas. <br><br><h3>  Prioridades del navegador y colas de tareas <br></h3><br><img src="https://habrastorage.org/webt/xv/fu/s9/xvfus9kn-18e_oxy00s_xwm6vdq.png"><br><br>  Imagina que tenemos 3 l√≠neas: <br><br><ol><li>  interacci√≥n del usuario; </li><li>  tiempos de espera </li><li>  publicar mensajes </li></ol><br>  El navegador comienza a recibir tareas de estas colas: <br><br><ul><li>  Primero, toma la interacci√≥n con el usuario <strong>Focus</strong> - esto es muy importante - un latido se ha ido. <br></li><li>  Luego toma <strong>postMessages</strong> , bueno, postMessages es una prioridad bastante alta, ¬°genial! <br></li><li>  El siguiente, <strong>onChange,</strong> tambi√©n es nuevamente de la interacci√≥n del usuario en prioridad. <br></li><li>  A continuaci√≥n <strong>se</strong> env√≠a <strong>onClick</strong> .  La cola de interacci√≥n del usuario ha finalizado, hemos mostrado al usuario todo lo que se necesita. <br></li><li>  Luego tomamos <strong>setInterval</strong> , agregamos postMessages. <br></li><li>  <strong>setTimeout solo ejecutar√° el m√°s reciente</strong> .  Estaba en alg√∫n lugar al final de la l√≠nea. <br></li></ul><br>  Este es nuevamente un ejemplo muy simplificado y, desafortunadamente, <strong>nadie puede garantizar c√≥mo funcionar√° esto en los navegadores</strong> , porque ellos mismos deciden todo esto.  Debe probar esto usted mismo si desea averiguar de qu√© se trata. <br><br>  Por ejemplo, postMessages tiene prioridad sobre setTimeout.  Es posible que haya o√≠do hablar de setImmediate, que, por ejemplo, en los navegadores IE, era solo nativo.  Pero hay archivos polif√≥nicos que se basan principalmente no en setTimeout, sino en crear un canal postMessages y suscribirse a √©l.  Esto funciona generalmente m√°s r√°pido porque los navegadores lo priorizan. <br><br>  Bueno, estas tareas se llevan a cabo.  ¬øEn qu√© punto terminamos nuestra tarea y entendemos que podemos tomar la siguiente o que podemos rendir? <br><br><h3>  Pila </h3><br>  La pila es una estructura de datos simple que funciona seg√∫n el principio de "√∫ltimo en entrar, primero en salir", es decir  "Puse el √∫ltimo, obtienes el primero" <strong>.</strong>  La contraparte m√°s cercana, probablemente real, es una baraja de cartas.  Por lo tanto, a nuestro abuelo Ivan Tulup le encanta jugar a las cartas. <br><br><img src="https://habrastorage.org/webt/5b/03/dh/5b03dh5di0r9oktsyvekmflkey4.png"><br><br>  En el ejemplo anterior, en el que hay alg√∫n c√≥digo, se puede introducir el mismo ejemplo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaci√≥n</a> .  En alg√∫n lugar llamamos handleClick, ingrese console.log, llame a showPopup y window.  confirmar  Formemos una pila. <br><br><ul><li>  Entonces, primero tomamos handleClick y enviamos la llamada a esta funci√≥n a la pila, ¬°genial! </li><li>  Luego vamos a su cuerpo y lo ejecutamos. </li><li>  Ponemos console.log en la pila e inmediatamente lo ejecutamos, porque todo est√° ah√≠ para ejecutarlo. </li><li>  Luego ponemos showConfirm - esta es una llamada a funci√≥n - genial. </li><li>  Ponemos funciones en la pila, ponemos su cuerpo, es decir, window.confirm. </li></ul><br>  No tenemos nada m√°s, lo estamos haciendo.  Aparecer√° una ventana emergente: "¬øEst√°s seguro?", Haz clic en "S√≠", y todo saldr√° de la pila.  Ahora hemos terminado el cuerpo showConfirm y el cuerpo handleClick.  Nuestra pila se borra y podemos pasar a la siguiente tarea.  Pregunta: Bien, ahora s√© que necesitas dividirlo todo en pedazos peque√±os.  ¬øC√≥mo puedo, por ejemplo, hacer esto en el caso m√°s elemental? <br><br><h3>  Particionar una matriz en trozos y procesarlos de forma asincr√≥nica </h3><br>  Veamos el ejemplo m√°s "de frente".  Te advierto de inmediato: no intentes repetir esto en casa, no se compilar√°. <br><br><img src="https://habrastorage.org/webt/on/a4/kz/ona4kz7lojjan82vfis4dkoxvh0.png"><br><br>  Tenemos una matriz grande, grande, y queremos calcular algo basado en ella, por ejemplo, para analizar algunos datos binarios.  Simplemente podemos dividirlo en trozos: procese esta pieza, esto y esto.  Seleccionamos el tama√±o del fragmento, por ejemplo, 10 mil elementos, consideramos cu√°ntos fragmentos tendremos.  Tenemos una funci√≥n parseData que va a la CPU y realmente puede hacer algo pesado.  Luego dividimos la matriz en trozos, setTimeout (() =&gt; parseData (slice), 0). <br><br>  En este caso, el navegador nuevamente podr√° priorizar la interacci√≥n del Usuario y renderizar en el medio.  Es decir, al menos liberas tu Event Loop, y contin√∫a funcionando.  Tu coraz√≥n contin√∫a latiendo, y eso es bueno. <br><br>  Pero este es realmente un ejemplo muy "de frente".  Hay muchas API en los navegadores para ayudarlo a hacer esto de una manera m√°s especializada. <br><br>  Adem√°s de setTimeout y setInterval, hay API que van m√°s all√° de los l√≠mites, como, por ejemplo, requestAnimationFrame y requestIdleCallback. <br><br>  Probablemente muchos est√©n familiarizados con <strong>requestAnimationFrame</strong> , e incluso ya lo usan.  Se ejecuta antes de renderizar.  Su encanto es que, en primer lugar, intenta ejecutar cada 60 fps (o 30 fps), y en segundo lugar, todo esto se hace inmediatamente antes de crear el Modelo de objetos CSS, etc. <br><br><img src="https://habrastorage.org/webt/0-/hy/qt/0-hyqtkge9dm9ayeciqrrzgjors.png"><br><br>  Por lo tanto, incluso si tiene varios requestAnimationFrame, en realidad agrupar√°n todos los cambios y el marco saldr√° completo.  En el caso de setTimeout, ciertamente no puede obtener tal garant√≠a.  Un setTimeout cambiar√° una cosa, la otra otra, y en el medio de la representaci√≥n puede resbalar: tendr√° un tir√≥n de la pantalla u otra cosa.  RequestAnimationFrame es excelente para esto. <br><br>  Adem√°s de esto, tambi√©n hay <strong>requestIdleCallback.</strong>  Quiz√°s escuchaste que se usa en React v16.0 (Fiber).  RequestIdleCallback funciona de tal manera que si el navegador comprende que tiene tiempo entre cuadros (60 fps) para hacer algo √∫til, y al mismo tiempo ya han hecho todo: hicieron la tarea, requestAnimationFrame lo hizo, parece genial, entonces puede producir cuantos peque√±os, digamos, 50 ms cada uno, para que pueda hacer algo (modo inactivo). <br><br>  No est√° en el diagrama de arriba, porque no est√° ubicado en ning√∫n lugar en particular.  El navegador puede decidir colocarlo antes del marco, despu√©s del marco, entre requestAnimationFrame y el render, despu√©s de la tarea, antes de la tarea.  Nadie puede garantizar esto. <br><br>  Se le garantiza que si tiene un trabajo que no est√° relacionado con el cambio de DOM (porque entonces requestAnimationFrame es animaci√≥n, etc.), aunque no es una prioridad s√∫per, pero tangible, requestIdleCallback es su salida. <br><br>  Entonces, si tenemos una operaci√≥n de CPU larga, entonces podemos tratar de romperla en pedazos. <br><br><ul><li>  Si se trata de un cambio de DOM, use <strong>requestAnimationFrame.</strong> <br></li><li>  Si se trata de una tarea no prioritaria, de corta duraci√≥n y no dif√≠cil que no <strong>sobrecargar√° la</strong> CPU, <strong>solicite la llamada inactiva.</strong> <br></li><li>  Si tenemos una gran tarea poderosa que debe realizarse constantemente, entonces vamos m√°s all√° de Event Loop y usamos WebWorkers.  No hay otra manera <br></li></ul><br>  <strong>Tareas en navegadores:</strong> <br><br><ol><li>  Aplasta todo en peque√±as tareas. </li><li>  Hay muchos tipos de tareas. </li><li>  Estos tipos priorizan las tareas mediante colas de especificaci√≥n. </li><li>  Los navegadores deciden mucho y la √∫nica forma de entender c√≥mo funciona es simplemente verificar si se est√° ejecutando uno u otro c√≥digo. </li><li>  ¬°Pero la especificaci√≥n no siempre se respeta! </li></ol><br>  El problema es que nuestro Ivan Tulup es un viejo abuelo, porque las implementaciones de Event Loop en los navegadores tambi√©n son muy antiguas.  Se crearon antes de que se escribiera la especificaci√≥n, por lo que, lamentablemente, la especificaci√≥n se respeta en la medida en que.  Incluso si lee c√≥mo deber√≠a ser la especificaci√≥n, nadie garantiza que todos los navegadores la admitan.  As√≠ que aseg√∫rese de verificar en los navegadores c√≥mo funciona esto realmente. <br><br>  El abuelo Ivan Tulup en los navegadores es una persona poco predecible, con algunas caracter√≠sticas interesantes, debe recordar esto. <br><br><h2>  Terminator Santa: Mascot Loop en Node.js <br></h2><br>  Node.js es m√°s como alguien as√≠. <br><br><img src="https://habrastorage.org/webt/bb/5u/bx/bb5ubx5cvdgtu2lilmk-rfmeajc.png"><br><br>  Porque, por un lado, es el mismo abuelo con barba, pero al mismo tiempo todo se distribuye en fases y est√° claramente pintado donde se hace. <br><br>  <strong>Fases del bucle de eventos en Node.js:</strong> <br><br><ul><li>  temporizadores <br></li><li>  devoluci√≥n de llamada pendiente; <br></li><li>  inactivo, preparar; <br></li><li>  encuesta <br></li><li>  comprobar <br></li><li>  Cerrar devoluciones de llamada. <br></li></ul><br>  Todo, excepto el √∫ltimo, no tiene muy claro lo que significa.  Las fases tienen nombres tan extra√±os, porque debajo del cap√≥, como ya sabemos, tenemos a Libuv para gobernar a todos: <br><br><ul><li>  <em>Linux -</em> epoll / POSIX AIO; <br></li><li>  <em>BSD -</em> kqueue; <br></li><li>  <em>Windows -</em> IOCP; <br></li><li>  <em>Solaris -</em> puertos de eventos. <br></li></ul><br>  Miles de todos ellos! <br><br>  Adem√°s, Libuv tambi√©n proporciona el mismo bucle de eventos.  No tiene los detalles de Node.js, pero hay fases, y Node.js solo los usa.  Pero por alguna raz√≥n tom√≥ los nombres de all√≠. <br><br>  Veamos qu√© significa realmente cada fase. <br><br><h4>  La fase de temporizadores realiza: <br></h4><br><ul><li>  Temporizadores listos para devoluci√≥n de llamada; <br></li><li>  setTimeout y setInterval; <br></li><li>  Pero <strong>NO</strong> setImmediate es una fase diferente. <br></li></ul><br><h4>  Llamadas pendientes de fase <br></h4><br>  Antes de esto, la fase de documentaci√≥n denominada devoluciones de llamada de E / S.  M√°s recientemente, esta documentaci√≥n se corrigi√≥ y dej√≥ de contradecirse.  Antes de esto, en un lugar se escribi√≥ que las devoluciones de llamada de E / S se ejecutan en esta fase, en otro, que en la fase de sondeo.  Pero ahora todo est√° escrito all√≠ inequ√≠vocamente y bien, as√≠ que lea la documentaci√≥n: algo ser√° mucho m√°s comprensible. <br><br>  En la fase de devoluci√≥n de llamada pendiente, se ejecutan las devoluciones de llamada de algunas operaciones del sistema (error de TCP).  Es decir, si en Unix hay un error en el socket TCP, en este caso no quiere tirarlo inmediatamente, sino en la devoluci√≥n de llamada, que se ejecutar√° solo en esta fase.  Eso es todo lo que necesitamos saber sobre ella.  Pr√°cticamente no nos interesa. <br><br><h4>  Fase inactiva, preparar <br></h4><br>  En esta fase, no podemos hacer nada, por lo que, en principio, lo olvidaremos. <br><br><img src="https://habrastorage.org/webt/xa/6l/n-/xa6ln-ao3qbubxteqecnh8lm5ke.png"><br><br><h4>  Fase de encuesta <br></h4><br>  Esta es la fase m√°s interesante en Node.js porque realiza el trabajo principal √∫til: <br><br><ul><li>  Realiza devoluciones de llamada de E / S (¬°no est√° pendiente la fase de devoluci√≥n de llamada!). </li><li>  Esperando eventos de E / S; </li><li>  Es genial hacer setImmediate; </li><li>  Sin temporizadores; </li></ul><br>  Mirando hacia el futuro, setImmediate se ejecutar√° en la siguiente fase de verificaci√≥n, es decir, garantizada antes de los temporizadores. <br><br>  Y tambi√©n la fase de sondeo controla el flujo del bucle de eventos.  Por ejemplo, si no tenemos temporizadores, no hay setImmediate, es decir, nadie hizo el temporizador, setImmediate no llam√≥, simplemente bloqueamos en esta fase y esperamos el evento desde E / S, si algo nos llega, si hay alguna devoluci√≥n de llamada si nos registramos para algo <br><br>  ¬øC√≥mo se implementa un modelo sin bloqueo?  Por ejemplo, en el mismo Epoll, podemos suscribirnos a un evento: abrir un socket y esperar a que se escriba algo en √©l.  Adem√°s, el segundo argumento es el tiempo de espera, es decir  Esperaremos a Epoll, pero si el tiempo de espera finaliza y el evento de E / S no llega, saldr√° del tiempo de espera.  Si un evento nos llega desde la red (alguien escribe en el socket), entonces vendr√°. <br><br>  Por lo tanto, la fase de sondeo elimina el mont√≥n (el mont√≥n es una estructura de datos que permite una entrega y entrega bien ordenadas) de la devoluci√≥n de llamada m√°s temprana, toma su tiempo de espera, escribe en este tiempo de espera y libera todo.  Por lo tanto, incluso si nadie nos escribe en el socket, el tiempo de espera funcionar√°, volver√° a la fase de sondeo y el trabajo continuar√°. <br><br><blockquote>  Es importante tener en cuenta que en la fase de encuesta hay un l√≠mite en la cantidad de devoluciones de llamada a la vez. <br></blockquote><br>  Es triste que en las fases restantes no lo sea.  Si agrega 10 mil millones de tiempo de espera, agrega 10 mil millones de tiempo de espera.  Por lo tanto, la siguiente fase es la fase de verificaci√≥n. <br><br><h4>  Fase de verificaci√≥n </h4><br>  Aqu√≠ es donde se ejecuta setImmediate.  La fase es hermosa en ese setImmediate, llamado en la fase de sondeo, se garantiza que se ejecute antes que el temporizador.  Porque el temporizador solo estar√° en el siguiente tic al principio y antes de la fase de sondeo.  Por lo tanto, no podemos temer la competencia con otros temporizadores y usar esta fase para aquellas cosas que no queremos por alguna raz√≥n ejecutar en una devoluci√≥n de llamada. <br><br><h4>  Devoluciones de llamada de cierre de fase </h4><br>  Esta fase no ejecuta todas nuestras devoluciones de llamada de cierre de socket y otros tipos: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, ‚Ä¶).</code> </pre><br>  Ella los ejecuta solo si este evento vol√≥ inesperadamente, por ejemplo, alguien en el otro extremo envi√≥: "¬°Todo, cierra el z√≥calo, ve desde aqu√≠, Vasya!"  Entonces esta fase funcionar√°, porque el evento es inesperado.  Pero esto no nos afecta particularmente. <br><br><h3>  Procesamiento asincr√≥nico incorrecto de fragmentos en Node.js </h3><br>  Qu√© suceder√° si ponemos el mismo patr√≥n que tomamos en los navegadores con setTimeout en Node.js, es decir, dividimos la matriz en fragmentos, para cada fragmento hacemos setTimeout - 0. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigArray = [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_000_000] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chunks = getChunks(bigArray) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data for (chunk of chunks) { setTimeout(() =&gt; parseData(slice), 0) }</span></span></code> </pre><br>  ¬øCrees que hay alg√∫n problema con esto? <br><br>  Ya me adelant√© un poco cuando dije que si agrega 10 mil tiempos de espera (¬°o 10 mil millones!), Habr√° 10 mil temporizadores en la cola, y √©l los obtendr√° y ejecutar√°; no hay protecci√≥n contra esto: obtener, ejecutar, obtener ... para cumplir y as√≠ sucesivamente hasta el infinito. <br><br>  Solo la fase de sondeo, si constantemente recibimos un evento de E / S, todo el tiempo alguien escribe algo en el socket para que podamos ejecutar al menos temporizadores y setImmediate, tiene protecci√≥n de l√≠mite y depende del sistema.  Es decir, diferir√° en los diferentes sistemas operativos. <br><br>  Desafortunadamente, otras fases, incluidos los temporizadores y setImmediate, <strong>no tienen dicha protecci√≥n.</strong>  Por lo tanto, si hace lo mismo que en el ejemplo, todo se congelar√° y no llegar√° a la fase de sondeo durante mucho tiempo. <br><br>  ¬øPero crees que algo cambiar√° si reemplazamos setTimeout (() =&gt; parseData (slice), 0) con setImmediate (() =&gt; parseData (slice))?  - Naturalmente, no, tampoco hay protecci√≥n en la fase de verificaci√≥n all√≠. <br><br>  Para resolver este problema, puede llamar al <strong>procesamiento recursivo</strong> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data const recursiveAsyncParseData = (i) =&gt; { parseData(getChunk(i)) setImmediate(() =&gt; recursiveAsyncParseData(i + 1)) } recursiveAsyncParseData(0)</span></span></code> </pre><br>  La conclusi√≥n es que tomamos la funci√≥n parseData y escribimos su llamada recursiva, pero no solo a nosotros mismos, sino a trav√©s de setImmediate.  Cuando llamas a esto en la fase setImmediate, pasa al siguiente tic y no al actual.  Por lo tanto, esto lanzar√° el bucle de eventos, ir√° m√°s lejos en un c√≠rculo.  Es decir, tenemos recursiveAsyncParseData, donde pasamos un cierto √≠ndice, obtenemos el fragmento por este √≠ndice, lo analizamos y luego colocamos setImmediate de cola con el siguiente √≠ndice.  Llegar√° a nuestro pr√≥ximo tic y podremos procesar todo esto recursivamente. <br><br>  Es cierto que el problema es que esto todav√≠a es alg√∫n tipo de tarea vinculada a la CPU.  Quiz√°s todav√≠a pese de alguna manera y tome tiempo en Event Loop.  Lo m√°s probable es que desee que su Node.js est√© limitado a E / S. <br>  Por lo tanto, es mejor usar algunas otras cosas, por ejemplo, el grupo <strong>fork / thread del proceso.</strong> <br><br>  Ahora sabemos sobre Node.js que: <br><br><ul><li>  todo se distribuye en fases, bueno, lo sabemos claramente; <br></li><li>  hay protecci√≥n contra una fase de sondeo demasiado larga, pero no el resto; <br></li><li>  los patrones de procesamiento recursivo se pueden aplicar para no bloquear Event Loop; </li><li>  Pero es mejor usar fork de proceso, grupo de subprocesos, proceso hijo </li></ul><br>  Tambi√©n debe tener cuidado con el grupo de subprocesos, porque Node.js inicia las cosas all√≠, en particular, la resoluci√≥n de DNS, porque para Linux, por alguna raz√≥n, la funci√≥n de resoluci√≥n de DNS no es as√≠ncrona.  Por lo tanto, debe ejecutarse en ThreadPool.  En Windows, afortunadamente, no es as√≠.  Pero all√≠ puedes leer archivos de forma asincr√≥nica.  En Linux, desafortunadamente, es imposible. <br><br>  En mi opini√≥n, el l√≠mite est√°ndar es de 4 procesos en ThreadPool.  Por lo tanto, si hace algo activamente all√≠, competir√° con todos los dem√°s, con fs y otros.  Puede considerar aumentar ThreadPool, pero tambi√©n con mucho cuidado.  Entonces lea algo sobre este tema. <br><br><h2>  Microtask: circulaci√≥n pulmonar </h2><br>  Tenemos tareas en Node.js y tareas en navegadores.  Puede que ya hayas o√≠do hablar de microtask.  Veamos qu√© es y c√≥mo funcionan, y comencemos con los navegadores. <br><br><h3>  Microtask en navegadores <br></h3><br>  Para comprender c√≥mo funciona microtask, recurrimos al algoritmo de bucle de eventos de acuerdo con el est√°ndar whatwg, es decir, vamos a la especificaci√≥n y veamos c√≥mo se ve todo. <br><br><img src="https://habrastorage.org/webt/cb/kj/76/cbkj76j9xqsivioo2demagbbfty.png"><br><br>  Traduciendo al lenguaje humano, se parece a esto: <br><br><ul><li>  Toma la tarea gratis de nuestra l√≠nea </li><li>  Lo llevamos a cabo </li><li>  Llevamos a cabo el punto de control de microtask. De acuerdo, todav√≠a no sabemos qu√© es, pero lo recordamos. </li><li>  Actualizamos el renderizado (si es necesario) y volvemos al punto de partida. </li></ul><br><img src="https://habrastorage.org/webt/1h/rs/ce/1hrsceluhstlxrdjjr7ig2wh9l0.png"><br><br>  Se llevan a cabo en el lugar indicado en el diagrama, y ‚Äã‚Äãen varios lugares m√°s, de los cuales pronto aprenderemos.  Es decir, la tarea ha terminado, se ejecutan microtask. <br><br><h3>  Fuentes de microtucks </h3><br><ul><li>  <strong>Promesa, luego.</strong> </li></ul><br>  Importante: no se promete a s√≠ mismo, es decir, Promise.then.  La devoluci√≥n de llamada que se coloc√≥ en ese momento es una microtask.  Si llam√≥ a 10, entonces, tiene 10 microcoches, 10 mil, entonces, 10 mil microcoches. <br><br><ul><li>  <strong>Observador de mutaciones.</strong> <br></li><li>  <strong>Object.observe</strong> , que est√° en desuso y nadie lo necesita. <br></li></ul><br>  ¬øCu√°ntos usan el observador de mutaciones? <br><br>  Creo que pocos usan el observador de mutaciones.  Lo m√°s probable es que Promise.then se use m√°s, por eso lo consideraremos en el ejemplo. <br><br>  <strong>Caracter√≠sticas del punto de control de microtask:</strong> <br><br><ul><li>  <strong>Hacemos todo</strong> , esto significa que llevamos a cabo todas las microtasks que tenemos en la cola hasta el final.  No soltamos nada, solo tomamos y hacemos todo lo que sea, deber√≠an ser micro, ¬øverdad? </li><li>  Todav√≠a puede generar nuevas microtask en el proceso, y se ejecutar√°n en el mismo punto de control de microtask. </li><li>  Lo que tambi√©n es importante: se ejecutan no solo despu√©s de la ejecuci√≥n de la tarea, sino tambi√©n despu√©s de borrar la pila. </li></ul><br>  Este es un punto interesante.  Resulta que es posible generar nuevas microtasks y todos las cumpliremos hasta el final.  ¬øA qu√© nos puede llevar esto? <br><br><img src="https://habrastorage.org/webt/yr/i_/i9/yri_i9mhp2jz-6nyyj7pvfwl6yg.png"><br>  Tenemos dos corazones  Anim√© el primer coraz√≥n con animaci√≥n JS, y el segundo con animaci√≥n CSS.  Hay otra gran caracter√≠stica llamada starveMicrotasks.  Llamamos Promise.resolve, y luego ponemos la misma funci√≥n en ese momento. <br>  Vea en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaci√≥n</a> qu√© sucede si llama a esta funci√≥n. <br><br>  S√≠, el coraz√≥n de JS se detendr√°, porque agregamos una microtask, y luego agregamos una microtask en ella, y luego agregamos una microtask en ella ... Y as√≠ infinitamente. <br><br>  Es decir, la llamada recursiva de microtucks colgar√° todo.  ¬°Pero parece que tengo todo as√≠ncrono!  Deber√≠a dejarlo ir, llam√© a setTimeout all√≠.  No!  Desafortunadamente, debe tener cuidado con microtask, por lo que si usa una llamada recursiva de alguna manera, tenga cuidado: puede bloquear todo. <br><br>  Adem√°s, como recordamos, microtask se ejecuta al final de la limpieza de la pila.  Recordamos lo que es una pila.  Resulta que tan pronto como salimos de nuestro c√≥digo, se ejecut√≥ la devoluci√≥n de llamada setTimeout, eso es todo, las microtasks fueron all√≠.  Esto puede conducir a efectos secundarios interesantes. <br><br>  Considera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo</a> . <br><br><img src="https://habrastorage.org/webt/kf/e-/tq/kfe-tqsysmprki74ayahty-n9ke.png"><br><br>  Hay un bot√≥n y un contenedor gris en el que se encuentra.  Nos suscribimos al clic del bot√≥n y del contenedor. ,   , ,       . <br><br>     2 : <br><br><ol><li> Promise.resolve; </li><li> .then,    console.log('RO') </li></ol><br>       ¬´FUS¬ª,      ‚Äì ¬´DAH!¬ª (    ). <br><br>   ,      ?      ,    ,   ¬´FUS RO DAH!¬ª  Genial  ,   . <br><br><img src="https://habrastorage.org/webt/3g/b6/w3/3gb6w3gi4es-fzxcicyk2batfm8.png"><br><br>       ,            ,        .   ‚Äì  . , -   ? <br><br><img src="https://habrastorage.org/webt/uo/-t/dx/uo-tdxdjrfwgt0vvse4a6vuqips.png"><br><br>  !         . <br><br><img src="https://habrastorage.org/webt/yk/ob/w3/ykobw30-vcw5h6t6vvlitwk-y2a.png"><br><br>  ,   . <br><br> ,      ,     ,     .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> . <br><br><ul><li>         ‚Äî buttonHandleClick,    . </li><li>    Promise.resolve.     .   ,      console.log('RO')  .   . </li><li>      console.log('FUS'). </li><li>   buttonHandleClick       .        . </li><li>   ,      (divHandleClick)    ,  ¬´DAH!¬ª. </li><li> HandleClick . </li></ul><br>  ,     .         ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> : <br><br><ul><li>  button.click().     . </li><li>   button HandleClick. </li><li>  Promise.resolve  then.      , Promise.resolve . </li><li>    console.log   ¬´FUS¬ª. </li><li>    buttonHandleClick    ,    . </li></ul><br>     (click)  ,       ,    .     divHandleClick , ,  console.log('DAH!') .        ,      . <br><br>   , ,    button.click   . <br>        .   , ,   .  ,    ,    . <br><br>    :     ()       (  ).   - ,      ,   stopPropagation.  ,     ,  ,  ,   -   ,  . <br><br>  ,  -   ( junior-)     ‚Äî      ¬´¬ª,    promise,  ,    then  ,  -  .    ,  <strong>    ,    </strong> :   ,    ,  .   .        ,   -       . <br><br>    (  4)    ,        .     ,   ,  ,   ,      -   .           . <br><br> <strong>     , :</strong> <br><br><ul><li>      Event Loop.  Esto es desagradable. </li><li>         ,   . </li></ul><br>           ,    .  ‚Äî   ,     ,  . <br><br><h2>   Node.js <br></h2><br>   Node.js  Promise.then  process.nextTick.      ,    ‚Äî    .   ,   , ,   , . <br><br><h3> process.nextTick <br></h3><br> ,     process.nextTick,   setImmediate?      Node.js  ? <br><br>    .     createServer,   EventEmitter,    ,     listen (  ),      . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createServer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> evEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">listen</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function"> =&gt;</span></span> { evEmitter.emit(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evEmitter } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = createServer().listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) server.on(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>))</code> </pre><br>    ,  ,   8080,    listening   console.log  - . <br><br>  ,       ,      - . <br><br>    createServer,    .       listen,      ,        .        . <br><br>  ,    ,    .   ?   process.nextTick:  evEmitter.emit('listening', port)  process.nextTick(() =&gt; evEmitter.emit('listening', port)). <br><br>   ,  <strong>process.nextTick     ,    </strong> .    EventEmitter,     . ,   ,      API,       .    process.nextTick,   emit    ,  userland  .      createServer,  ,  listen,    listening.     ‚Äî    process.nextTick ‚Äî !  ,     ,  . <br><br>     process.nextTick  .     ,         . <br><br>   ,  process.nextTick    ,  Promise.then  .     process.nextTick ,     ‚Äî    ,   Event Loop,  Node.js. , ,   . <br><br> <strong> process.nextTick    </strong> ,   ghbvtybnm  setImmediate   ,        C++  ..  process.nextTick       . <br><br><h2> Async/await </h2><br>      API ‚Äî async/await, - .    .    , async/await   Promise,     Event Loop      .     ,          . <br><br><h2>   </h2><br><ul><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Philip Roberts. What the heck is the event loop anyway?</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bert Belder. Everything you need to know about Node.js event loop.</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jake Archibald. In the Loop</a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Node.js Event Loop, Timers, and process.nextTick()</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WHATWG Specification event loop processing model</a> <br></li></ul><br> <strong>,     !</strong> <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Frontend Conf</a>     ‚Äî 4  5   ,  .    ,        : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grid Layout    </a> /   ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Building decentralised apps with JS</a> /   (ING) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> /   () <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StoreWars (ngxs, redux, vuex)</a> /  ,   (Cinimex) <br></li></ul><br>  Ven, ser√° interesante! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417461/">https://habr.com/ru/post/es417461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417449/index.html">Mundo Jur√°sico: ¬øPodemos realmente resucitar dinosaurios?</a></li>
<li><a href="../es417451/index.html">Cinco errores comunes para principiantes</a></li>
<li><a href="../es417453/index.html">Organizaci√≥n de pasant√≠as para estudiantes: rastrillo y trucos.</a></li>
<li><a href="../es417457/index.html">Frontend Conf Moscow: entrada y salida del lado del cliente</a></li>
<li><a href="../es417459/index.html">Conoce tu JIT: m√°s cerca del auto</a></li>
<li><a href="../es417463/index.html">Una reuni√≥n inesperada. Cap√≠tulo 17</a></li>
<li><a href="../es417465/index.html">Una descripci√≥n general de los m√©todos de enlace de texto</a></li>
<li><a href="../es417469/index.html">Cinco razones ego√≠stas para trabajar de forma reproducible</a></li>
<li><a href="../es417471/index.html">Soldadura simple MK936 SMD. Estaci√≥n de soldadura DIY para componentes SMD</a></li>
<li><a href="../es417473/index.html">Almacenamiento confiable con DRBD9 y Proxmox (Parte 1: NFS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>