<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾 👐 🐪 Editor teks bukan matematika tertinggi Anda, di sini Anda perlu berpikir 💅🏿 🧘 👩🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Editor teks modern tidak hanya dapat berbunyi bip dan tidak meninggalkan program. Ternyata metabolisme yang sangat kompleks bermuara di dalamnya. Ingi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Editor teks bukan matematika tertinggi Anda, di sini Anda perlu berpikir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424763/"> Editor teks modern tidak hanya dapat berbunyi bip dan tidak meninggalkan program.  Ternyata metabolisme yang sangat kompleks bermuara di dalamnya.  Ingin tahu trik apa yang sedang dilakukan untuk menghitung ulang koordinat dengan cepat, bagaimana gaya, lipatan dan softwraps dilampirkan pada teks dan bagaimana semuanya diperbarui, apa yang harus dilakukan dengan struktur data fungsional dan antrian prioritas, serta cara menipu pengguna - selamat datang di kucing! <br><br><img src="https://habrastorage.org/webt/sr/i0/vg/sri0vg3jog_-mc16jc5zz-wjxw0.jpeg"><br><br>  Artikel ini didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> Alexei Kudryavtsev dengan Joker 2017. Alexei telah menulis Intellij IDEA di JetBrains selama sekitar 10 tahun.  Di bawah potongan Anda akan menemukan transkrip video dan teks dari laporan. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YzWr9CN6cGQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  Struktur Data Di Dalam Editor Teks </h1><br>  Untuk memahami cara kerja editor, mari kita tulis. <br><br><img src="https://habrastorage.org/webt/q9/nb/-n/q9nb-nr675yuu19v6loydkq3nrm.png"><br><br>  Itu saja, editor paling sederhana kami sudah siap. <br><br>  Di dalam editor, teks termudah untuk disimpan dalam array karakter, atau, apa yang sama (dalam hal organisasi memori), di kelas Java StringBuffer.  Untuk mendapatkan beberapa karakter dengan offset, kita memanggil metode StringBuffer.charAt (i).  Dan untuk memasukkan ke dalamnya karakter yang kita ketikkan pada keyboard, kita memanggil metode StringBuffer.insert (), yang menyisipkan karakter di suatu tempat di tengah. <br><br>  Apa yang paling menarik, terlepas dari semua kesederhanaan dan kebodohan editor ini, adalah ide terbaik yang dapat Anda ciptakan.  Ini sederhana dan hampir selalu cepat. <br><br>  Sayangnya, masalah skala muncul dengan editor ini.  Bayangkan kita mencetak banyak teks di dalamnya dan akan memasukkan huruf lain di tengah.  Berikut ini akan terjadi.  Kami sangat membutuhkan ruang kosong untuk surat ini dengan menggerakkan semua huruf lainnya satu karakter ke depan.  Untuk melakukan ini, kami menggeser surat ini dengan satu posisi, lalu yang berikutnya dan seterusnya, sampai akhir teks. <br><br>  Begini tampilannya di memori: <br><br><img src="https://habrastorage.org/webt/ec/uk/r4/ecukr4oxdmj0tlxojojwuf9k8i4.gif"><br><br>  Menggeser banyak megabita ini tidak terlalu baik: lambat.  Tentu saja, untuk komputer modern, ini adalah masalah sepele - semacam megabita yang menyedihkan untuk bergerak maju mundur.  Tetapi untuk perubahan teks yang sangat aktif, ini bisa terlihat. <br><br>  Untuk mengatasi masalah ini memasukkan karakter di tengah, waktu yang lama muncul dengan solusi yang disebut "Penyangga Gap". <br><br><h3>  Penyangga celah </h3><br>  Gap adalah gap.  Buffer adalah, seperti yang Anda bayangkan, buffer.  Struktur data Gap Buffer adalah buffer kosong yang kami simpan di tengah teks kami, untuk berjaga-jaga.  Jika kami perlu mencetak sesuatu, kami menggunakan buffer teks kecil ini untuk mengetik dengan cepat. <br><br><img src="https://habrastorage.org/webt/vc/ca/v4/vccav4jbt0zboaf_fuo985dzerc.png"><br><br>  Struktur data telah berubah sedikit - array tetap di tempatnya, tetapi dua petunjuk telah muncul: di awal buffer dan di akhir.  Untuk mengambil karakter dari editor di beberapa offset, kita perlu memahami apakah itu sebelum atau sesudah buffer ini dan sedikit mengoreksi offset.  Dan untuk memasukkan karakter, pertama-tama kita harus memindahkan Penyangga Gap ke tempat ini dan mengisinya dengan karakter ini.  Dan, tentu saja, jika kami melampaui buffer kami, entah bagaimana membuatnya kembali.  Ini adalah tampilannya di gambar. <br><br><img src="https://habrastorage.org/webt/bu/4a/gs/bu4ags_jk9vobq_9rxegbww01nw.gif"><br><br>  Seperti yang Anda lihat, pertama-tama kita bergerak untuk waktu yang lama pada buffer celah kecil (kotak biru) ke lokasi pengeditan (cukup menukar karakter dari tepi kiri dan kanan pada gilirannya).  Lalu kami menggunakan buffer ini, mengetik karakter di sana. <br><br>  Seperti yang Anda lihat, tidak ada pergerakan megabita karakter, sisipannya sangat cepat, untuk waktu yang konstan, dan sepertinya semua orang senang.  Segalanya tampak baik-baik saja, tetapi jika prosesor kami sangat lambat, waktu yang cukup nyata terbuang untuk memindahkan celah-buffer dan teks bolak-balik.  Ini terutama terlihat pada saat megahertz yang sangat kecil. <br><br><h3>  Meja potong </h3><br>  Tepat pada saat itu, sebuah perusahaan bernama Microsoft menulis editor teks Word.  Mereka memutuskan untuk menerapkan ide lain untuk mempercepat pengeditan yang disebut "Piece Table", yaitu, "Piece Table".  Dan mereka mengusulkan untuk menyimpan teks editor dalam array karakter paling sederhana yang sama, yang tidak akan berubah, dan menempatkan semua perubahannya dalam tabel terpisah dari potongan-potongan yang sangat diedit ini. <br><br><img src="https://habrastorage.org/webt/gf/gt/gu/gfgtgutww7ymm-bx-4v7tytyjt4.png"><br><br>  Jadi, jika kita perlu menemukan beberapa karakter dengan offset, kita perlu menemukan bagian ini yang kita edit dan ekstrak karakter ini darinya, dan jika tidak ada di sana, maka pergi ke teks asli.  Memasukkan simbol menjadi lebih mudah, kita hanya perlu membuat dan menambahkan bagian baru ini ke tabel.  Berikut tampilannya di gambar: <br><br><img src="https://habrastorage.org/webt/94/8w/3u/948w3uylg_cuxh8mywws-owxs_i.gif"><br><br>  Di sini kami ingin menghapus ruang di offset 5. Untuk melakukan ini, kami menambahkan dua potongan baru ke tabel irisan: satu menunjukkan fragmen pertama ("Nyebelin"), dan yang kedua menunjukkan fragmen setelah mengedit ("domba").  Ternyata celah dari mereka menghilang, dua bagian ini direkatkan bersama, dan kami sudah mendapatkan teks baru tanpa spasi: "Oblomovtsy".  Kemudian kami menambahkan teks baru ("menderita Oblomovisme") ke akhir.  Gunakan buffer tambahan dan tambahkan irisan baru ke tabel potongan yang menunjuk ke teks terbaru ini ditambahkan. <br><br>  Seperti yang Anda lihat, tidak ada gerakan bolak-balik, semua teks tetap di tempatnya.  Berita buruknya adalah semakin sulit untuk mendapatkan simbol, karena memilah-milah semua bagian ini cukup sulit. <br><br>  Untuk meringkas. <br><br>  Apa yang baik tentang <b>Sepotong Meja</b> : <br><br><ul><li>  Sematkan cepat; </li><li>  Mudah dilakukan undo; </li><li>  Hanya tambahkan. </li></ul><br>  Apa yang buruk: <br><br><ul><li>  Sangat sulit untuk mengakses dokumen; </li><li>  Sangat sulit untuk diimplementasikan. </li></ul><br>  Mari kita lihat siapa yang biasanya kita gunakan apa. <br><br>  NetBeans, Eclipse dan Emacs menggunakan Gap Buffer - bagus sekali!  Vi tidak repot dan hanya menggunakan daftar baris.  Word menggunakan Piece Table (baru-baru ini mereka meletakkan jenis kuno mereka dan di sana Anda bahkan dapat memahami sesuatu). <br><br>  Atom lebih menarik.  Sampai saat ini, mereka tidak mengganggu dan menggunakan daftar garis JavaScript.  Dan kemudian mereka memutuskan untuk menulis ulang semuanya dalam C ++ dan menumpuk struktur yang agak rumit, yang tampaknya mirip dengan Piece Table.  Tetapi potongan-potongan ini tidak disimpan dalam daftar, tetapi di pohon, dan dalam apa yang disebut pohon splay - ini adalah pohon yang menyesuaikan diri ketika dimasukkan ke dalamnya, sehingga memasukkan baru-baru ini lebih cepat.  Mereka melakukan hal yang sangat rumit. <br><br>  Apa yang digunakan Intellij IDEA? <br>  Tidak, tidak gap-buffer.  Tidak, Anda salah juga, bukan meja potong. <br>  Ya, benar, sepedamu sendiri. <br><br>  Faktanya adalah bahwa persyaratan IDE untuk menyimpan teks sedikit berbeda dari pada editor teks biasa.  IDE memerlukan dukungan untuk berbagai hal rumit seperti daya saing, yaitu akses paralel ke teks dari editor.  Misalnya, agar berbagai macam makanan panggang dapat membacanya dan melakukan sesuatu.  (Inspeksi adalah sepotong kecil kode yang mem-parsing program dengan satu atau lain cara - misalnya, mencari tempat yang melempar NullPointerException).  IDE juga membutuhkan dukungan versi teks yang dapat diedit.  Beberapa versi secara bersamaan di memori saat Anda bekerja dengan dokumen sehingga proses panjang ini terus menganalisis versi yang lama. <br><br><h1>  Masalahnya </h1><br><h3>  Daya Saing / Versi </h3><br>  Untuk menjaga paralelisme, operasi teks biasanya dibungkus dengan "disinkronkan", atau dalam Baca / Tulis-kunci.  Sayangnya, ini tidak skala dengan sangat baik.  Pendekatan lain adalah Teks Tidak Berubah, yaitu repositori teks tidak berubah. <br><br><img src="https://habrastorage.org/webt/ov/ia/sa/oviasaeniuwmhiaebpsic_mxm88.png"><br><br>  Inilah yang terlihat seperti editor dengan dokumen abadi sebagai struktur data pendukung. <br><br>  Bagaimana cara kerja struktur data? <br><br>  Alih-alih array karakter, kita akan memiliki objek baru tipe ImmutableText, yang menyimpan teks dalam bentuk pohon, di mana substring kecil disimpan dalam lembaran.  Ketika mengakses di beberapa offset, dia mencoba mencapai lembar paling bawah di pohon ini, dan dia sudah akan ditanya simbol yang kita maksudkan.  Dan ketika Anda memasukkan teks, ia membuat pohon baru dan menyimpannya di tempat yang lama. <br><br><img src="https://habrastorage.org/webt/_2/xx/rh/_2xxrh9kohjwodn3ub-gyt2z8la.gif"><br><br>  Misalnya, kami memiliki dokumen dengan teks "Bebas kalori".  Ini diimplementasikan sebagai pohon dengan dua lembar pengganti "Setan" dan "tinggi kalori."  Ketika kami ingin memasukkan baris "cantik" di tengah, versi baru dari dokumen kami dibuat.  Dan tepatnya, root baru dibuat, yang sudah terlampir tiga lembar: "Setan", "cukup" dan "tinggi kalori".  Selain itu, dua lembar baru ini dapat merujuk ke versi pertama dari dokumen kami.  Dan untuk lembar di mana kita memasukkan garis "cantik", sebuah simpul baru dialokasikan.  Di sini baik versi pertama dan versi kedua tersedia pada saat yang sama dan semuanya tidak berubah, tidak dapat diubah.  Semuanya terlihat bagus. <br><br>  Siapa yang menggunakan struktur rumit apa? <br><br><img src="https://habrastorage.org/webt/yf/mt/eh/yfmtehxbzlale_95bblpk2msh2k.jpeg"><br><br>  Sebagai contoh, di GNOME, beberapa widget standar mereka menggunakan struktur yang disebut Rope.  Xi-Editor, editor baru brilian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Raf Levien</a> , menggunakan Persistent Rope.  Dan Intellij IDEA menggunakan Pohon Abadi ini.  Di balik semua nama ini, pada kenyataannya, kurang lebih struktur data yang sama dengan representasi teks seperti pohon.  Kecuali bahwa GtkTextBuffer menggunakan Mutable Rope, mis. Pohon dengan simpul yang bisa berubah, dan Intellij IDEA dan Xi-Editor - Immutable. <br><br>  Hal berikutnya yang perlu dipertimbangkan ketika mengembangkan repositori karakter dalam IDE modern disebut multicats.  Fitur ini memungkinkan Anda mencetak di beberapa tempat sekaligus, menggunakan beberapa media. <br><br><img src="https://habrastorage.org/webt/qb/ak/9t/qbak9tqjnu7v_iiciaouw-qqeug.gif"><br><br>  Kita dapat mencetak sesuatu dan pada saat yang sama di beberapa tempat dokumen kita memasukkan apa yang kita cetak di sana.  Jika kita melihat bagaimana struktur data kita, yang kita periksa, bereaksi terhadap multicaret, kita akan melihat sesuatu yang menarik. <br><br><img src="https://habrastorage.org/webt/ty/4p/8k/ty4p8kuqs1rgeanxr9y3n9i8wz4.jpeg"><br><br>  Jika kita memasukkan karakter ke editor primitif pertama kita, tentu saja akan membutuhkan waktu linier untuk memindahkan sekelompok karakter bolak-balik.  Ini ditulis sebagai O (N).  Untuk editor berdasarkan Gap Buffer, pada gilirannya, waktu yang konstan diperlukan, untuk itulah ia diciptakan. <br><br>  Untuk pohon yang tidak dapat diubah, waktu tergantung pada ukuran logaritmik, karena Anda harus terlebih dahulu pergi dari atas pohon ke daunnya - ini adalah logaritma, dan kemudian untuk semua simpul di jalur untuk membuat simpul baru untuk pohon baru - ini lagi-lagi adalah logaritma.  Piece Table juga membutuhkan konstanta. <br>  Tapi semuanya berubah sedikit jika kita mencoba mengukur waktu memasukkan karakter ke dalam editor dengan multi-gerbong, yaitu, memasukkan secara bersamaan di beberapa tempat.  Sekilas, waktu tampaknya meningkat secara proporsional dengan faktor C - jumlah tempat di mana simbol dimasukkan.  Inilah yang terjadi, dengan pengecualian Gap Buffer.  Dalam kasusnya, waktu, alih-alih waktu C, secara tak terduga meningkatkan beberapa waktu C * L yang tidak dapat dipahami, di mana L adalah jarak rata-rata antara gerbong.  Mengapa ini terjadi? <br><br>  Bayangkan kita perlu memasukkan baris ", on" di dua tempat di dokumen kita. <br><br><img src="https://habrastorage.org/webt/ec/n3/jd/ecn3jdpnsvqscfbvjxivopbs5uq.gif"><br><br>  Inilah yang terjadi pada editor saat ini. <br><br><ul><li>  Buat gap-buffer di editor (kotak biru kecil di gambar); </li><li>  Kami memulai dua gerbong (garis vertikal tebal hitam); </li><li>  Kami mencoba mencetak; </li><li>  Masukkan koma ke Penyangga Gap kami; </li><li>  Anda sekarang harus memasukkannya di tempat kereta kedua; </li><li>  Untuk melakukan ini, kita perlu memindahkan Penyangga Celah kita ke posisi gerbong berikutnya; </li><li>  Mencetak koma di tempat kedua; </li><li>  Sekarang Anda perlu memasukkan karakter berikutnya di posisi kereta pertama; </li><li>  Dan kita harus mendorong Penyangga Gap kita kembali; </li><li>  Masukkan huruf "n"; </li><li>  Dan kami memindahkan penyangga lama kami ke tempat gerbong kedua; </li><li>  Kami memasukkan "n" kami di sana; </li><li>  Pindahkan buffer kembali untuk memasukkan karakter berikutnya. </li></ul><br>  Rasakan kemana semuanya pergi? <br><br>  Ya, ternyata karena banyak gerakan penyangga ini bolak-balik, total waktu kita meningkat.  Sejujurnya, ini bukan karena ngeri secara langsung karena telah meningkat - untuk memindahkan megabyte yang menyedihkan, gigabyte bolak-balik untuk komputer modern bukanlah masalah, tetapi menarik bahwa struktur data ini bekerja secara radikal berbeda dalam kasus multicats. <br><br><h3>  Terlalu banyak garis?  LineSet! </h3><br>  Apa masalah lain yang ada dalam editor teks biasa?  Masalah yang paling sulit adalah menggulung, yaitu menggambar ulang editor sambil memindahkan carriage ke baris berikutnya. <br><br><img src="https://habrastorage.org/webt/yt/0d/rn/yt0drnu1rsxyciwb4pruefmufyu.gif"><br><br>  Ketika editor menggulir, kita perlu memahami dari baris mana, dari simbol apa kita perlu mulai menggambar teks di jendela kecil kita.  Untuk melakukan ini, kita perlu dengan cepat memahami baris mana yang sesuai dengan offset mana. <br><br><img src="https://habrastorage.org/webt/kn/ak/gm/knakgm1aq7-wnjwbruefxeyouh0.png"><br><br>  Ada antarmuka yang jelas untuk ini, ketika kita perlu memahami offsetnya dalam teks dengan nomor baris.  Dan sebaliknya, oleh offset dalam teks untuk memahami di baris mana itu.  Bagaimana ini bisa dilakukan dengan cepat? <br><br>  Misalnya, seperti ini: <br><br>  Atur garis-garis ini menjadi pohon dan tandai setiap simpul pohon ini dengan menggeser awal garis dan menggeser ujung garis.  Dan kemudian, untuk memahami dengan offset di mana garis itu berada, Anda hanya perlu menjalankan pencarian logaritmik di pohon ini dan menemukannya. <br><br><img src="https://habrastorage.org/webt/x1/jq/3w/x1jq3w1gwiytzsrdytznnltc_l0.png"><br><br>  Cara lain bahkan lebih mudah. <br><br>  Tuliskan dalam tabel offset dari awal baris dan akhir baris.  Dan kemudian, untuk menemukan offset awal dan akhir dengan nomor baris, Anda perlu mengakses indeks. <br><br><img src="https://habrastorage.org/webt/wq/ls/wy/wqlswyl-k5brg4fsbgoxaqxkj1u.png"><br><br>  Menariknya, di dunia nyata, kedua metode digunakan. <br><br><img src="https://habrastorage.org/webt/ii/w6/qu/iiw6quo2j0clh8xnovh0mfn5ow0.jpeg"><br><br>  Sebagai contoh, Eclipse menggunakan struktur kayu sedemikian rupa sehingga, seperti yang Anda lihat, bekerja dalam waktu logaritmik untuk membaca dan memperbarui.  Dan IDEA menggunakan struktur tabel, yang pembacaannya adalah konstanta cepat, itu adalah pembalikan indeks dalam tabel, tetapi pembangunan kembali agak lambat, karena Anda perlu membangun kembali seluruh tabel saat mengubah panjang baris. <br><br><h3>  Masih terlalu banyak baris?  Lipatan! </h3><br>  Apa lagi hal buruk yang terjadi pada editor teks?  Misalnya lipatan.  Ini adalah potongan-potongan teks yang dapat Anda "runtuh" ​​dan menunjukkan sesuatu yang lain sebagai gantinya. <br><br><img src="https://habrastorage.org/webt/tp/g1/fc/tpg1fcoak4ahpzd1mbf9wex_jvi.png"><br><br>  Titik-titik ini pada latar belakang hijau dalam gambar menyembunyikan banyak simbol di belakang kami, tetapi jika kita tidak tertarik melihatnya (seperti dalam kasus, misalnya dokumen Java membosankan atau daftar impor yang paling lama), kita menyembunyikannya, menutupnya elipsis. <br><br>  Dan di sini lagi Anda perlu memahami kapan itu berakhir dan kapan wilayah yang perlu kami tunjukkan dimulai, dan bagaimana cara memperbaruinya dengan cepat?  Bagaimana ini diatur, saya akan katakan nanti. <br><br><h3>  Garis terlalu panjang?  Bungkus lembut! </h3><br><img src="https://habrastorage.org/webt/yu/lb/hg/yulbhgos7wf3ilx0gqtxg2lrkpq.jpeg"><br><br>  Juga, editor modern tidak dapat hidup tanpa bungkus lunak.  Gambar tersebut menunjukkan bahwa pengembang membuka file JavaScript setelah minimalisasi dan segera menyesalinya.  Garis besar JavaScript ini, ketika kami mencoba menampilkannya di editor, tidak akan masuk ke layar mana pun.  Oleh karena itu, bungkus lunak secara paksa merobeknya menjadi beberapa garis dan mendorongnya ke layar. <br>  Bagaimana ini diatur - nanti. <br><br><h3>  Kecantikannya terlalu sedikit </h3><br><img src="https://habrastorage.org/webt/md/yh/d0/mdyhd06genl8kiaehxjectze9g4.jpeg"><br><br>  Dan akhirnya, saya juga ingin membawa keindahan ke editor teks.  Misalnya, sorot beberapa kata.  Pada gambar di atas, kata kunci disorot dengan huruf tebal biru, beberapa metode statis dengan cetak miring, beberapa anotasi - juga dalam warna yang berbeda. <br><br>  Jadi bagaimana Anda masih menyimpan dan memproses lipatan, pembungkus lunak, dan highlight? <br>  Ternyata semua ini, pada prinsipnya, adalah satu dan tugas yang sama. <br><br><h3>  Kecantikannya terlalu kecil?  Range highlighters! </h3><br><img src="https://habrastorage.org/webt/jj/rl/t7/jjrlt7sisz9curcqa5lotpzjfya.jpeg"><br><br>  Untuk mendukung semua fitur ini, yang perlu kita lakukan hanyalah menempelkan beberapa atribut teks pada offset yang diberikan dalam teks, misalnya, warna, font atau teks untuk melipat.  Selain itu, atribut teks ini harus diperbarui setiap saat di tempat ini sehingga mereka dapat bertahan dari segala jenis penyisipan dan penghapusan. <br><br>  Bagaimana ini biasanya diterapkan?  Secara alami, dalam bentuk pohon. <br><br><h3>  Masalah: kecantikan terlalu banyak?  Pohon interval! </h3><br><img src="https://habrastorage.org/webt/0e/ux/le/0euxleajuom5pdsa02kwxuudyny.jpeg"><br><br>  Misalnya, di sini kami memiliki beberapa highlight kuning yang ingin kami simpan dalam teks.  Kami menambahkan interval highlight ini ke dalam pohon pencarian, yang disebut pohon interval.  Ini adalah pohon pencarian yang sama, tetapi sedikit rumit karena kita perlu menyimpan interval, bukan angka. <br><br>  Dan karena ada interval sehat dan kecil, bagaimana memilah mereka, membandingkannya satu sama lain dan menempatkannya di pohon adalah tugas yang agak tidak sepele.  Meskipun sangat dikenal luas dalam ilmu komputer.  Kemudian lihat bagaimana pun waktu luang Anda cara kerjanya.  Jadi, kita mengambil dan meletakkan semua interval kita di pohon, dan kemudian setiap perubahan dalam teks di suatu tempat di tengah mengarah ke perubahan logaritmik di pohon ini.  Misalnya, memasukkan karakter harus menghasilkan pembaruan semua interval di sebelah kanan karakter itu.  Untuk melakukan ini, kami menemukan semua simpul dominan untuk simbol ini dan menunjukkan bahwa semua simpul mereka harus dipindahkan satu simbol ke kanan. <br><br><h3>  Masih menginginkan kecantikan?  Ligatur! </h3><br><img src="https://habrastorage.org/webt/iv/j-/tb/ivj-tb9_w2ata-tiwclrmqfjs_a.jpeg"><br><br>  Masih ada hal yang mengerikan - pengikat, yang juga ingin saya dukung.  Ini adalah keindahan yang berbeda, seperti tanda "! =" Digambar dalam bentuk mesin terbang besar "tidak sama" dan seterusnya.  Untungnya, di sini kita mengandalkan mekanisme ayunan untuk mendukung ligatur ini.  Dan, dalam pengalaman kami, ia tampaknya bekerja dengan cara yang paling sederhana.  Di dalam font, daftar semua pasangan karakter ini disimpan, yang, jika digabungkan bersama, membentuk semacam ikatan yang rumit.  Kemudian, ketika menggambar garis, Swing hanya mengulangi semua pasangan ini, menemukan yang diperlukan dan menariknya sesuai.  Jika Anda memiliki banyak ligatur di font, maka, tampaknya, menampilkannya akan melambat secara proporsional. <br><br><h3>  Tip rem </h3><br>  Dan yang paling penting - masalah lain yang dihadapi dalam editor kompleks modern adalah optimalisasi tip, yaitu, menekan tombol dan menampilkan hasilnya. <br><br><img src="https://habrastorage.org/webt/fq/yb/wi/fqybwipttxn9pvl3phzc5qts6_k.jpeg"><br><br>  Jika Anda masuk ke Intellij IDEA dan melihat apa yang terjadi ketika Anda menekan tombol, maka akan terjadi horor berikut: <br><br><ul><li>  Pada klik tombol, kita harus melihat apakah kita berada dalam popup penyelesaian untuk menutup menu untuk penyelesaian jika, misalnya, kita mengetikkan beberapa "Enter". </li><li>  Anda perlu melihat apakah file tersebut di bawah beberapa sistem kontrol versi yang rumit, seperti Perforce, yang perlu mengambil beberapa tindakan untuk mulai mengedit. </li><li>  Periksa apakah ada wilayah khusus dalam dokumen yang tidak dapat dicetak, seperti beberapa teks yang dibuat secara otomatis. </li><li>  Jika dokumen diblokir oleh operasi yang belum berakhir, Anda harus menyelesaikan pemformatan, dan hanya kemudian melanjutkan. </li><li>  injected-,      ,       ,   -  . </li><li>     auto popup handler,    , ,       . </li><li>   info  ,     ,    .     selection remove,    selection  ,   .    selection ,    . </li><li>     typed handler,       ,      . </li><li>    . </li><li>  undo,  virtual space'   write action. </li><li> ,     . </li></ul><br> ! <br><br> , ,   .  ,    . ,    listener  ,   ,  - .  editor view.  -   listener'. <br><br>      ,   ,  -      DocumentListener? <br><br>  Editor.documentChanged()   : <br><br><ul><li>  error stripe; </li><li>  gutter size, ; </li><li>  editor component size,    ; </li><li>      ; </li><li>  soft wrap,    ; </li><li>  repaint(). </li></ul><br>  repaint() —     Swing,        .   ,   Repaint     Swing. <br><br>   -       ,   repaint   ,    : <br><br><img src="https://habrastorage.org/webt/je/qh/cy/jeqhcytdxkun3ft_r7azwrby2eu.jpeg"><br><br>    paint-,   ,        . <br><br>  , ,   ? <br><br><img src="https://habrastorage.org/webt/sm/mo/xq/smmoxqrmfayyfodciwe75svwdzw.jpeg"><br><br>  ,  ,  .    Intellij IDEA   . <br><br><img src="https://habrastorage.org/webt/5u/x8/as/5ux8ashfsenwboudd_u07ubtjmk.jpeg"><br><br>    ,  -   - ,    ,         ,    .  !  ,    ,    ,   -  — !      ,  -    .    .      «Zero latency typing». <br><br><h1>   </h1><br>      —    . <br><br>   ?       ,  —  ,        Google Docs -    -  . <br><br>  : <br><br><ul><li>  ; </li><li>  . </li></ul><br>   ,        ,          . <br><br>  -          .    ,  ,     .   .   —   , «intention preservation».  ,   -  ,          ,     ,   .    — .  ,            -       ,   . <br><br><h3> Operation transformation </h3><br><img src="https://habrastorage.org/webt/h9/e8/pq/h9e8pqu3ljnoh4y70_759peizn0.jpeg"><br><br>  ,       ,  «operation transformation».   .    , - :     ,     .  Operation transformation       .   ,    ,   ,    - . ,        .    ,    -         .  ,      ,    . <br><br>       ,   ,    ,   .     «TP2 puzzle». <br><br><img src="https://habrastorage.org/webt/c1/5i/cs/c15icsdnqbjqykloe_pfbxahz-e.jpeg"><br><br>       - ,    ,     .  ,    Operation transformation       ,  ,  ,     («»).       («»).   ,   .    ,         Operation transformation,  -       . <br><br>          ,  Google Docs, Google Wave  -   Etherpad.   Operation transformation    . <br><br><h3> Conflict-free replicated data type </h3><br>      : «  ,  OT!»     ,      ,  . ,  ,    ,              ,      100%         .   «CRDT» (Conflict-free replicated data type). <br><br><img src="https://habrastorage.org/webt/kn/82/9n/kn829n91st7gpykcp905spuy_ki.jpeg"><br><br>   ,    ,          . ,     , ,   .   ,       . -            (  ),  ()      (  ). <br><br><img src="https://habrastorage.org/webt/vs/9-/i7/vs9-i7bdfpjonh_z1cgie6qj4kk.jpeg"><br><br>           ? <br><br>  Ya ,     G-counter',   ,   .      ,       .        «+1»  ,  «+1»  , ,       —   «2».  ,          ,     .      G-counter,     ,       .       G-counter,    .    ,     ,       .       .    —   . ,       CRDT. ,   . <br><br><h3> Conflict-free replicated inserts </h3><br><img src="https://habrastorage.org/webt/pz/bg/ta/pzbgta8bteajr0embilmbnpxifc.jpeg"><br><br> ,     ,      ,    . , ,        . <br><br>   ,     ,     -  - , ,  ,  ,        .   ,      ,     ,     ,     . , ,  ,     ,     2    «»,    ,    «»   «»   «». <br><br><h3> Conflict-free replicated deletes </h3><br><img src="https://habrastorage.org/webt/jt/w1/fb/jtw1fbphe5mjcyhbye4ua-mjf7s.jpeg"><br><br>      .        ,    ,     ,  - .   ,       ,     .  ,       ,        ,    . <br>  ,      . <br><br><h3> Conflict-free replicated edits </h3><br> ,   , CRDT  - , ,  Xi-Editor,          Fuchsia.  ,     ,    . <br><br><h1> Zipper </h1><br>      ,          «Zipper».  ,      ,      . ,  ,        .    , ( «» ,   ,     «  »). ,      -     .      ,       - ,   .        Zipper. <br><br>           ,     .    . <br><br><img src="https://habrastorage.org/webt/ap/ne/p2/apnep2miklsburr5xhtqgcwbzri.gif"><br><br>  Zipper   ,      («  »).     Zipper'       .    —     .       (),   ,          . ,    Zipper,   -        ,   .  ,     ,   ,   ( ).      ,        ( ).   ,                .    ,        . <br><br>  ,        . <br><br>       ? -,   ,    ,    ,    .  ,       ,   .  -,    ,      .     .  Terima kasih <br><br> → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <br> → <a href=""></a> <br><br><h1>  Referensi </h1><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zipper data structure</a> <br> <a href="">  CRDT in Xi Editor</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">       </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> <br><br>     ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Visual Studio Code editor  Piece Table</a> . <br>  ,   -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br><blockquote> Ingin laporan yang lebih kuat, termasuk Java 11?  Kemudian kami menunggu Anda di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Joker 2018</a> .  Pembicara tahun ini: Josh Long, John McClean, Marcus Hirth, Robert Scholte, dan speaker keren lainnya.  Ada 17 hari tersisa sebelum konferensi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tiket</a> di situs. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424763/">https://habr.com/ru/post/id424763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424751/index.html">Bagaimana Sistem Biometrik Terpadu Bekerja</a></li>
<li><a href="../id424753/index.html">Apa yang Baru di YouTrack 2018.3</a></li>
<li><a href="../id424755/index.html">Uang suka tagihan: bagaimana mobil menyortir tagihan</a></li>
<li><a href="../id424757/index.html">Intisari acara untuk profesional SDM di bidang TI pada Oktober 2018</a></li>
<li><a href="../id424761/index.html">Pengantar proses boot dan boot kernel Linux</a></li>
<li><a href="../id424765/index.html">Manajemen negara dalam aplikasi Flutter</a></li>
<li><a href="../id424767/index.html">Kami membuat kue dari Habr. Lagi</a></li>
<li><a href="../id424771/index.html">Pengalaman pribadi: dari ide dan lembar kosong hingga versi konsep situs</a></li>
<li><a href="../id424773/index.html">Pemodelan biofarma dan numerik: Pengalaman dan praktik Amgen</a></li>
<li><a href="../id424777/index.html">Menggunakan Konsul untuk Skala Layanan Stateful</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>