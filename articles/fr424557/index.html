<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏿 🐪 🐾 Guide Node.js, partie 8: protocoles HTTP et WebSocket 👲🏻 👩🏼‍🔧 🥔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js est une plate-forme serveur. La tâche principale du serveur est de traiter les demandes des clients, en particulier des navigateurs, aussi rap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide Node.js, partie 8: protocoles HTTP et WebSocket</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424557/">  Node.js est une plate-forme serveur.  La tâche principale du serveur est de traiter les demandes des clients, en particulier des navigateurs, aussi rapidement et efficacement que possible.  Le huitième de la traduction du didacticiel Node.js que nous publions aujourd'hui concerne HTTP et WebSocket. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Nous vous conseillons de lire] Autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations générales et mise en route</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript, V8, quelques astuces de développement</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hébergement, REPL, travailler avec la console, les modules</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers npm, package.json et package-lock.json</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">npm et npx</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boucle d'événements, pile d'appels, temporisateurs</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation asynchrone</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 8: Protocoles HTTP et WebSocket</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, partie 9: utilisation du système de fichiers</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 10: Modules standard, flux, bases de données, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF complet du guide Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Que se passe-t-il lors des requêtes HTTP?</font> </h2><br>  Parlons de la façon dont les navigateurs font des requêtes aux serveurs en utilisant le protocole HTTP / 1.1. <br><br>  Si vous avez déjà eu une interview dans le domaine informatique, il se peut que l'on vous demande ce qui se passe lorsque vous tapez quelque chose dans la barre d'adresse de votre navigateur et appuyez sur Entrée.  C'est peut-être l'une des questions les plus populaires qui se posent lors de ces entretiens.  Quiconque pose de telles questions veut savoir si vous pouvez expliquer des concepts assez simples et savoir si vous comprenez les principes d'Internet. <br><br>  Cette question touche à de nombreuses technologies, pour comprendre les principes généraux de ce qui signifie comprendre comment est construit l'un des systèmes les plus complexes jamais construits par l'humanité, qui couvre le monde entier. <br><br><h3>  <font color="#3AC1EF">▍ Protocole HTTP</font> </h3><br>  Les navigateurs modernes sont capables de distinguer les URL réelles entrées dans leur barre d'adresse des requêtes de recherche, pour le traitement desquelles le moteur de recherche par défaut est généralement utilisé.  Nous parlerons des URL.  Si vous entrez une adresse de site Web, telle que <code>flaviocopes.com</code> , dans la ligne du navigateur, le navigateur convertit cette adresse au <code>flaviocopes.com</code> <code>http://flaviocopes.com</code> , en supposant que le protocole HTTP sera utilisé pour échanger des données avec la ressource spécifiée.  Veuillez noter que sous Windows, ce dont nous allons parler ici peut sembler un peu différent de celui sous macOS et Linux. <br><br><h3>  <font color="#3AC1EF">▍ Phase de recherche DNS</font> </h3><br>  Ainsi, le navigateur, en commençant à télécharger des données à partir de l'adresse demandée par les utilisateurs, effectue l'opération de recherche DNS (DNS Lookup) afin de trouver l'adresse IP du serveur correspondant.  Les noms symboliques des ressources saisies dans la barre d'adresse conviennent aux utilisateurs, mais le périphérique Internet implique la possibilité d'échanger des données entre des ordinateurs à l'aide d'adresses IP, qui sont des ensembles de nombres comme 222.324.3.1 (pour IPv4). <br><br>  Tout d'abord, en découvrant l'adresse IP du serveur, le navigateur examine le cache DNS local pour voir si une procédure similaire a été effectuée récemment.  Dans le navigateur Chrome, par exemple, il existe un moyen pratique de consulter le cache DNS en entrant l'adresse suivante dans la barre d'adresse: <code>chrome://net-internals/#dns</code> . <br><br>  Si rien ne se trouve dans le cache, le navigateur utilise l'appel système POSIX <code>gethostbyname</code> pour connaître l'adresse IP du serveur. <br><br><h3>  <font color="#3AC1EF">▍ fonction gethostbyname</font> </h3><br>  La fonction <code>gethostbyname</code> vérifie d'abord le <code>hosts</code> , qui, sur macOS ou Linux, peut être trouvé dans <code>/etc/hosts</code> afin de savoir si des informations locales peuvent être trouvées en recherchant l'adresse du serveur. <br><br>  Si des moyens locaux pour résoudre la demande de découverte de l'adresse IP du serveur échouent, le système effectue une demande au serveur DNS.  Les adresses de ces serveurs sont stockées dans les paramètres système. <br><br>  Voici quelques serveurs DNS populaires: <br><br><ul><li>  8.8.8.8: serveur DNS Google. </li><li>  1.1.1.1: Serveur DNS CloudFlare. </li></ul><br>  La plupart des gens utilisent les serveurs DNS fournis par leurs fournisseurs.  Le navigateur effectue des requêtes DNS à l'aide du protocole UDP. <br><br>  TCP et UDP sont deux protocoles de base utilisés dans les réseaux informatiques.  Ils sont situés au même niveau conceptuel, mais TCP est un protocole orienté connexion, et pour l'échange de messages UDP, dont le traitement crée une petite charge supplémentaire sur le système, une procédure d'établissement de connexion n'est pas nécessaire.  Nous ne parlerons pas exactement de la façon dont les données sont échangées via UDP. <br><br>  L'adresse IP correspondant au nom de domaine qui nous intéresse peut être dans le cache du serveur DNS.  Si ce n'est pas le cas, il contactera le serveur DNS racine.  Le système de serveur DNS racine se compose de 13 serveurs, dont dépend le fonctionnement de l'ensemble de l'Internet. <br><br>  Il convient de noter que le serveur DNS racine ne connaît pas la correspondance entre tous les noms de domaine et adresses IP existants dans le monde.  Mais des serveurs similaires connaissent les adresses des serveurs DNS de niveau supérieur pour des domaines tels que .com, .it, .pizza, etc. <br><br>  Dès réception de la demande, le serveur DNS racine la redirige vers le serveur DNS du domaine de premier niveau, vers le serveur dit TLD (à partir du domaine de premier niveau). <br><br>  Supposons que le navigateur recherche l'adresse IP du serveur <code>flaviocopes.com</code> .  En ce qui concerne le serveur DNS racine, le navigateur recevra de celui-ci l'adresse du serveur TLD pour la zone .com.  Maintenant, cette adresse sera stockée dans le cache, par conséquent, si vous avez besoin de trouver l'adresse IP d'une autre URL à partir de la zone .com, vous n'aurez plus à accéder au serveur DNS racine. <br><br>  Les serveurs TLD ont des adresses IP de serveurs de noms (Name Server, NS), à l'aide desquels vous pouvez trouver l'adresse IP à partir de l'URL que nous avons.  Où le serveur NS obtient-il ces informations?  Le fait est que si vous achetez un domaine, le registraire de domaine envoie des données à ce sujet aux serveurs de noms.  Une procédure similaire est effectuée, par exemple, lors du changement d'hébergement. <br><br>  Les serveurs en question appartiennent généralement à des hébergeurs.  En règle générale, pour se protéger contre les pannes, plusieurs de ces serveurs sont créés.  Par exemple, ils peuvent avoir ces adresses: <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br>  Pour connaître l'adresse IP par URL, ils se tournent finalement vers ces serveurs.  Ils stockent les données réelles sur les adresses IP. <br><br>  Maintenant, après avoir réussi à trouver l'adresse IP derrière l'URL entrée dans la barre d'adresse du navigateur, nous passons à l'étape suivante de notre travail. <br><br><h3>  <font color="#3AC1EF">▍ Etablissement d'une connexion TCP</font> </h3><br>  Après avoir appris l'adresse IP du serveur, le client peut établir une connexion TCP avec lui.  Lors de l'établissement d'une connexion TCP, le client et le serveur se transmettent mutuellement des données de service, après quoi ils peuvent échanger des informations.  Cela signifie qu'une fois la connexion établie, le client pourra envoyer une demande au serveur. <br><br><h3>  <font color="#3AC1EF">▍Envoyer une demande</font> </h3><br>  Une demande est un fragment de texte structuré conformément aux règles du protocole utilisé.  Il se compose de trois parties: <br><br><ul><li>  Chaîne de requête </li><li>  En-tête de demande. </li><li>  Demander le corps. </li></ul><br><h4>  Chaîne de requête </h4><br>  La chaîne de requête est une chaîne de texte unique qui contient les informations suivantes: <br><br><ul><li>  Méthode HTTP. </li><li>  Adresse de la ressource </li><li>  Version du protocole. </li></ul><br>  Cela peut ressembler, par exemple, à ceci: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4>  En-tête de demande </h4><br>  L'en-tête de demande est représenté par un ensemble de <code>: </code> .  Il y a 2 champs d'en-tête obligatoires, dont l'un est <code>Host</code> et le second est <code>Connection</code> .  Les champs restants sont facultatifs. <br><br>  Le titre peut ressembler à ceci: <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  Le champ <code>Host</code> indique le nom de domaine qui intéresse le navigateur.  Le champ <code>Connection</code> , défini sur <code>close</code> , signifie que la connexion entre le client et le serveur n'a pas besoin d'être maintenue ouverte. <br><br>  Les autres en-têtes de demande couramment utilisés sont les suivants: <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br>  En fait, il y en a beaucoup plus. <br><br>  L'en-tête de demande se termine par une chaîne vide. <br><br><h4>  Organe de demande </h4><br>  Le corps de la demande est facultatif; il n'est pas utilisé dans les demandes GET.  Le corps de la requête est utilisé dans les requêtes POST, ainsi que dans d'autres requêtes.  Il peut contenir, par exemple, des données au format JSON. <br><br>  Puisque nous parlons maintenant d'une requête GET, le corps de la requête sera vide, nous ne travaillerons pas avec. <br><br><h3>  <font color="#3AC1EF">▍ Répondre</font> </h3><br>  Une fois que le serveur a reçu la demande envoyée par le client, il la traite et envoie une réponse au client. <br><br>  La réponse commence par un code d'état et un message correspondant.  Si la demande aboutit, le début de la réponse ressemblera à ceci: <br><br><pre> <code class="hljs">200 OK</code> </pre> <br>  En cas de problème, il peut y avoir d'autres codes.  Par exemple, les éléments suivants: <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br>  De plus, la réponse contient une liste d'en-têtes HTTP et le corps de la réponse (qui, puisque la demande est exécutée par le navigateur, sera du code HTML). <br><br><h4>  Analyse HTML </h4><br>  Une fois que le navigateur a reçu la réponse du serveur, dont le corps contient du code HTML, il commence à l'analyser, en répétant le processus ci-dessus pour chaque ressource nécessaire pour former la page.  Ces ressources comprennent, par exemple, les éléments suivants: <br><br><ul><li>  Fichiers CSS. </li><li>  Les images </li><li>  Icône de page Web (favicon). </li><li>  Fichiers JavaScript. </li></ul><br>  La façon exacte dont le navigateur affiche la page ne s'applique pas à notre conversation.  La principale chose qui nous intéresse ici est que le processus de demande et de réception de données ci-dessus est utilisé non seulement pour le code HTML, mais aussi pour tout autre objet transféré du serveur au navigateur à l'aide du protocole HTTP. <br><br><h2>  <font color="#3AC1EF">À propos de la création d'un serveur simple à l'aide de Node.js</font> </h2><br>  Maintenant, après avoir examiné le processus d'interaction entre le navigateur et le serveur, vous pouvez jeter un nouveau regard sur la section d'application First Node.js de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de</a> cette série de documents, dans laquelle nous avons décrit le code d'un serveur simple. <br><br><h2>  <font color="#3AC1EF">Faire des requêtes HTTP avec Node.js</font> </h2><br>  Pour effectuer des requêtes HTTP à l'aide de Node.js, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/">module</a> approprié <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/">est utilisé</a> .  Les exemples ci-dessous utilisent le module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/">https</a> .  Le fait est que dans les conditions modernes, dans la mesure du possible, il est nécessaire d'utiliser le protocole HTTPS. <br><br><h3>  <font color="#3AC1EF">▍ Exécution des requêtes GET</font> </h3><br>  Voici un exemple d'exécution d'une demande GET à l'aide de Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">ExecutionExécution de la requête POST</font> </h3><br>  Voici comment effectuer une demande POST à ​​partir de Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">UTPUT et DELETE requêtes</font> </h3><br>  L'exécution de ces requêtes ressemble à celle des requêtes POST.  La principale différence, outre le contenu sémantique de ces opérations, est la valeur de la propriété <code>method</code> de l'objet <code>options</code> . <br><br><h3>  <font color="#3AC1EF">▍ Exécution de requêtes HTTP dans Node.js à l'aide de la bibliothèque Axios</font> </h3><br>  Axios est une bibliothèque JavaScript très populaire qui fonctionne à la fois dans le navigateur (cela inclut tous les navigateurs modernes et IE, à commencer par IE8), et dans l'environnement Node.js, qui peut être utilisé pour effectuer des requêtes HTTP. <br><br>  Cette bibliothèque est basée sur des promesses, elle présente certains avantages par rapport aux mécanismes standard, en particulier par rapport à l'API Fetch.  Ses avantages sont les suivants: <br><br><ul><li>  Prise en charge des anciens navigateurs (vous avez besoin d'un polyfill pour utiliser Fetch). </li><li>  Possibilité d'interrompre les demandes. </li><li>  Prise en charge de la définition des délais d'expiration des demandes. </li><li>  Protection intégrée contre les attaques CSRF. </li><li>  Prise en charge du téléchargement de données avec la fourniture d'informations sur l'avancement de ce processus. </li><li>  Prise en charge de la conversion de données JSON. </li><li>  Emplois chez Node.js </li></ul><br><h4>  L'installation </h4><br>  Vous pouvez utiliser npm pour installer Axios: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br>  Le même effet peut être obtenu avec du fil: <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br>  Vous pouvez connecter la bibliothèque à la page en utilisant <code>unpkg.com</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  API Axios </h4><br>  Vous pouvez faire une requête HTTP en utilisant l'objet <code>axios</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br>  Mais il est généralement plus pratique d'utiliser des méthodes spéciales: <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br>  Ceci est similaire à la façon dont jQuery utilise <code>$.get()</code> et <code>$.post()</code> au lieu de <code>$.ajax()</code> <code>$.post()</code> . <br><br>  Axios propose des méthodes distinctes pour exécuter d'autres types de requêtes HTTP, qui ne sont pas aussi populaires que GET et POST, mais sont toujours utilisées: <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br>  La bibliothèque dispose d'une méthode pour exécuter une demande conçue pour recevoir uniquement des en-têtes HTTP, sans le corps de la réponse: <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  GET demandes </h4><br>  Axios est pratique à utiliser en utilisant la syntaxe asynchrone / attente moderne.  L'exemple de code suivant, conçu pour Node.js, utilise la bibliothèque pour charger une liste de races de chiens à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'API Dog</a> .  Ici, la méthode <code>axios.get()</code> est appliquée et les roches sont comptées: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br>  Le même peut être réécrit sans utiliser async / wait, en appliquant des promesses: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4>  Utilisation de paramètres dans les requêtes GET </h4><br>  Une requête GET peut contenir des paramètres qui ressemblent à ceci dans une URL: <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br>  Lorsque vous utilisez Axios, une requête de ce type peut être effectuée comme suit: <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br>  Le même effet peut être obtenu en définissant la propriété <code>params</code> dans un objet avec des paramètres: <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  Demandes POST </h4><br>  L'exécution des requêtes POST est très similaire à l'exécution des requêtes GET, mais ici, au lieu de la méthode <code>axios.get()</code> , la méthode <code>axios.post()</code> est utilisée: <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br>  Comme deuxième argument, la méthode <code>post</code> accepte un objet avec des paramètres de requête: <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">Utilisation du protocole WebSocket dans Node.js</font> </h2><br>  WebSocket est une alternative à HTTP, il peut être utilisé pour organiser l'échange de données dans des applications Web.  Ce protocole vous permet de créer des canaux de communication bidirectionnels de longue durée entre le client et le serveur.  Une fois la connexion établie, le canal de communication reste ouvert, ce qui met l'application à la disposition d'une connexion très rapide, caractérisée par de faibles latences et une faible charge supplémentaire sur le système. <br><br>  Le protocole WebSocket est pris en charge par tous les navigateurs modernes. <br><br><h3>  <font color="#3AC1EF">▍ Différences HTTP</font> </h3><br>  HTTP et WebSocket sont des protocoles très différents qui utilisent différentes approches pour l'échange de données.  HTTP est basé sur le modèle «request-response»: le serveur envoie des données au client après leur demande.  Dans le cas de WebSocket, tout est organisé différemment.  À savoir: <br><br><ul><li>  Le serveur peut envoyer des messages au client de sa propre initiative, sans attendre une demande du client. </li><li>  Le client et le serveur peuvent échanger des données en même temps. </li><li>  Lors de la transmission d'un message, une quantité extrêmement faible de données de service est utilisée.  Cela conduit notamment à une faible latence dans la transmission des données. </li></ul><br>  Le protocole WebSocket est très bien adapté aux communications en temps réel sur des canaux qui restent ouverts pendant longtemps.  HTTP, à son tour, est excellent pour organiser des sessions de communication occasionnelles initiées par le client.  Dans le même temps, il convient de noter que, d'un point de vue de la programmation, il est beaucoup plus facile de mettre en œuvre l'échange de données en utilisant le protocole HTTP qu'en utilisant le protocole WebSocket. <br><br><h3>  <font color="#3AC1EF">▍ Version protégée du protocole WebSocket</font> </h3><br>  Il existe une version non sécurisée du protocole WebSocket (schéma <code>ws://</code> URI), qui ressemble, en termes de sécurité, au protocole <code>http://</code> .  L'utilisation de <code>ws://</code> doit être évitée, préférant une version sécurisée du protocole - <code>wss://</code> . <br><br><h3>  <font color="#3AC1EF">▍Création d'une connexion WebSocket</font> </h3><br>  Pour créer une connexion WebSocket, vous devez utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constructeur</a> approprié: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br>  Une fois la connexion établie, l'événement <code>open</code> est déclenché.  Vous pouvez organiser cet événement en affectant une fonction de rappel à la propriété <code>onopen</code> de l'objet de <code>connection</code> : <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Pour gérer les erreurs, le <code>onerror</code> événements <code>onerror</code> est utilisé: <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Envoyer des données au serveur</font> </h3><br>  Après avoir ouvert une connexion WebSocket au serveur, vous pouvez lui envoyer des données.  Cela peut être fait, par exemple, dans le <code>onopen</code> onopen: <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Obtention des données du serveur</font> </h3><br>  Pour recevoir des données envoyées à l'aide du protocole WebSocket du serveur, vous pouvez affecter le <code>onmessage</code> onmessage, qui sera appelé lorsque l'événement de <code>message</code> est reçu: <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Implémentation du serveur WebSocket dans l'environnement Node.js</font> </h3><br>  Afin d'implémenter un serveur WebSocket dans l'environnement Node.js, vous pouvez utiliser la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ws</a> populaire.  Nous l'utilisons pour le développement de serveurs, mais il convient à la création de clients, ainsi qu'à l'organisation de l'interaction entre deux serveurs. <br><br>  Installez cette bibliothèque en initialisant d'abord le projet: <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br>  Le code du serveur WebSocket que nous devons écrire est assez compact: <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br>  Ici, nous créons un nouveau serveur qui écoute sur le port standard 8080 pour le protocole WebSocket et décrivons un rappel qui, lorsque la connexion est établie, envoie un message <code>ho!</code> au client <code>ho!</code>  et imprime sur la console un message reçu du client. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici un</a> exemple de travail d'un serveur WebSocket, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> un client qui peut interagir avec lui. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Aujourd'hui, nous avons parlé des mécanismes de mise en réseau pris en charge par la plateforme Node.js, établissant des parallèles avec des mécanismes similaires utilisés dans les navigateurs.  Notre prochain sujet portera sur les fichiers. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous le protocole WebSocket dans vos applications Web, dont le côté serveur a été créé à l'aide de Node.js? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424557/">https://habr.com/ru/post/fr424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424541/index.html">Histoire du fiasco UGJ 2018: comment créer un jeu que personne n'aime (ne le faites pas!)</a></li>
<li><a href="../fr424543/index.html">Java 11 / JDK 11: disponibilité générale</a></li>
<li><a href="../fr424551/index.html">Warm and tube: cinq balalaïkas sur la technologie audio magnétique</a></li>
<li><a href="../fr424553/index.html">Guide Node.js, partie 6: boucle d'événement, pile d'appels, minuteurs</a></li>
<li><a href="../fr424555/index.html">Manuel Node.js, partie 7: programmation asynchrone</a></li>
<li><a href="../fr424559/index.html">Résistance Big Data 1 ou Joe insaisissable. Anonymat Internet, anti-détection, anti-tracking pour anti-you et anti-us</a></li>
<li><a href="../fr424563/index.html">Beeline envoie les détails des conversations à des étrangers</a></li>
<li><a href="../fr424565/index.html">Présentation: numérisation 3D de locaux immobiliers</a></li>
<li><a href="../fr424567/index.html">L'expérience du blocage de la publicité en ligne dans le réseau local de l'entreprise</a></li>
<li><a href="../fr424569/index.html">Embauche de programmeurs. Conseils du programmeur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>