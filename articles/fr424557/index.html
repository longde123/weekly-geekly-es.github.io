<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèø üê™ üêæ Guide Node.js, partie 8: protocoles HTTP et WebSocket üë≤üèª üë©üèº‚Äçüîß ü•î</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js est une plate-forme serveur. La t√¢che principale du serveur est de traiter les demandes des clients, en particulier des navigateurs, aussi rap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide Node.js, partie 8: protocoles HTTP et WebSocket</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424557/">  Node.js est une plate-forme serveur.  La t√¢che principale du serveur est de traiter les demandes des clients, en particulier des navigateurs, aussi rapidement et efficacement que possible.  Le huiti√®me de la traduction du didacticiel Node.js que nous publions aujourd'hui concerne HTTP et WebSocket. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Nous vous conseillons de lire] Autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations g√©n√©rales et mise en route</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript, V8, quelques astuces de d√©veloppement</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H√©bergement, REPL, travailler avec la console, les modules</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers npm, package.json et package-lock.json</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">npm et npx</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boucle d'√©v√©nements, pile d'appels, temporisateurs</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation asynchrone</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 8: Protocoles HTTP et WebSocket</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, partie 9: utilisation du syst√®me de fichiers</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 10: Modules standard, flux, bases de donn√©es, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF complet du guide Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Que se passe-t-il lors des requ√™tes HTTP?</font> </h2><br>  Parlons de la fa√ßon dont les navigateurs font des requ√™tes aux serveurs en utilisant le protocole HTTP / 1.1. <br><br>  Si vous avez d√©j√† eu une interview dans le domaine informatique, il se peut que l'on vous demande ce qui se passe lorsque vous tapez quelque chose dans la barre d'adresse de votre navigateur et appuyez sur Entr√©e.  C'est peut-√™tre l'une des questions les plus populaires qui se posent lors de ces entretiens.  Quiconque pose de telles questions veut savoir si vous pouvez expliquer des concepts assez simples et savoir si vous comprenez les principes d'Internet. <br><br>  Cette question touche √† de nombreuses technologies, pour comprendre les principes g√©n√©raux de ce qui signifie comprendre comment est construit l'un des syst√®mes les plus complexes jamais construits par l'humanit√©, qui couvre le monde entier. <br><br><h3>  <font color="#3AC1EF">‚ñç Protocole HTTP</font> </h3><br>  Les navigateurs modernes sont capables de distinguer les URL r√©elles entr√©es dans leur barre d'adresse des requ√™tes de recherche, pour le traitement desquelles le moteur de recherche par d√©faut est g√©n√©ralement utilis√©.  Nous parlerons des URL.  Si vous entrez une adresse de site Web, telle que <code>flaviocopes.com</code> , dans la ligne du navigateur, le navigateur convertit cette adresse au <code>flaviocopes.com</code> <code>http://flaviocopes.com</code> , en supposant que le protocole HTTP sera utilis√© pour √©changer des donn√©es avec la ressource sp√©cifi√©e.  Veuillez noter que sous Windows, ce dont nous allons parler ici peut sembler un peu diff√©rent de celui sous macOS et Linux. <br><br><h3>  <font color="#3AC1EF">‚ñç Phase de recherche DNS</font> </h3><br>  Ainsi, le navigateur, en commen√ßant √† t√©l√©charger des donn√©es √† partir de l'adresse demand√©e par les utilisateurs, effectue l'op√©ration de recherche DNS (DNS Lookup) afin de trouver l'adresse IP du serveur correspondant.  Les noms symboliques des ressources saisies dans la barre d'adresse conviennent aux utilisateurs, mais le p√©riph√©rique Internet implique la possibilit√© d'√©changer des donn√©es entre des ordinateurs √† l'aide d'adresses IP, qui sont des ensembles de nombres comme 222.324.3.1 (pour IPv4). <br><br>  Tout d'abord, en d√©couvrant l'adresse IP du serveur, le navigateur examine le cache DNS local pour voir si une proc√©dure similaire a √©t√© effectu√©e r√©cemment.  Dans le navigateur Chrome, par exemple, il existe un moyen pratique de consulter le cache DNS en entrant l'adresse suivante dans la barre d'adresse: <code>chrome://net-internals/#dns</code> . <br><br>  Si rien ne se trouve dans le cache, le navigateur utilise l'appel syst√®me POSIX <code>gethostbyname</code> pour conna√Ætre l'adresse IP du serveur. <br><br><h3>  <font color="#3AC1EF">‚ñç fonction gethostbyname</font> </h3><br>  La fonction <code>gethostbyname</code> v√©rifie d'abord le <code>hosts</code> , qui, sur macOS ou Linux, peut √™tre trouv√© dans <code>/etc/hosts</code> afin de savoir si des informations locales peuvent √™tre trouv√©es en recherchant l'adresse du serveur. <br><br>  Si des moyens locaux pour r√©soudre la demande de d√©couverte de l'adresse IP du serveur √©chouent, le syst√®me effectue une demande au serveur DNS.  Les adresses de ces serveurs sont stock√©es dans les param√®tres syst√®me. <br><br>  Voici quelques serveurs DNS populaires: <br><br><ul><li>  8.8.8.8: serveur DNS Google. </li><li>  1.1.1.1: Serveur DNS CloudFlare. </li></ul><br>  La plupart des gens utilisent les serveurs DNS fournis par leurs fournisseurs.  Le navigateur effectue des requ√™tes DNS √† l'aide du protocole UDP. <br><br>  TCP et UDP sont deux protocoles de base utilis√©s dans les r√©seaux informatiques.  Ils sont situ√©s au m√™me niveau conceptuel, mais TCP est un protocole orient√© connexion, et pour l'√©change de messages UDP, dont le traitement cr√©e une petite charge suppl√©mentaire sur le syst√®me, une proc√©dure d'√©tablissement de connexion n'est pas n√©cessaire.  Nous ne parlerons pas exactement de la fa√ßon dont les donn√©es sont √©chang√©es via UDP. <br><br>  L'adresse IP correspondant au nom de domaine qui nous int√©resse peut √™tre dans le cache du serveur DNS.  Si ce n'est pas le cas, il contactera le serveur DNS racine.  Le syst√®me de serveur DNS racine se compose de 13 serveurs, dont d√©pend le fonctionnement de l'ensemble de l'Internet. <br><br>  Il convient de noter que le serveur DNS racine ne conna√Æt pas la correspondance entre tous les noms de domaine et adresses IP existants dans le monde.  Mais des serveurs similaires connaissent les adresses des serveurs DNS de niveau sup√©rieur pour des domaines tels que .com, .it, .pizza, etc. <br><br>  D√®s r√©ception de la demande, le serveur DNS racine la redirige vers le serveur DNS du domaine de premier niveau, vers le serveur dit TLD (√† partir du domaine de premier niveau). <br><br>  Supposons que le navigateur recherche l'adresse IP du serveur <code>flaviocopes.com</code> .  En ce qui concerne le serveur DNS racine, le navigateur recevra de celui-ci l'adresse du serveur TLD pour la zone .com.  Maintenant, cette adresse sera stock√©e dans le cache, par cons√©quent, si vous avez besoin de trouver l'adresse IP d'une autre URL √† partir de la zone .com, vous n'aurez plus √† acc√©der au serveur DNS racine. <br><br>  Les serveurs TLD ont des adresses IP de serveurs de noms (Name Server, NS), √† l'aide desquels vous pouvez trouver l'adresse IP √† partir de l'URL que nous avons.  O√π le serveur NS obtient-il ces informations?  Le fait est que si vous achetez un domaine, le registraire de domaine envoie des donn√©es √† ce sujet aux serveurs de noms.  Une proc√©dure similaire est effectu√©e, par exemple, lors du changement d'h√©bergement. <br><br>  Les serveurs en question appartiennent g√©n√©ralement √† des h√©bergeurs.  En r√®gle g√©n√©rale, pour se prot√©ger contre les pannes, plusieurs de ces serveurs sont cr√©√©s.  Par exemple, ils peuvent avoir ces adresses: <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br>  Pour conna√Ætre l'adresse IP par URL, ils se tournent finalement vers ces serveurs.  Ils stockent les donn√©es r√©elles sur les adresses IP. <br><br>  Maintenant, apr√®s avoir r√©ussi √† trouver l'adresse IP derri√®re l'URL entr√©e dans la barre d'adresse du navigateur, nous passons √† l'√©tape suivante de notre travail. <br><br><h3>  <font color="#3AC1EF">‚ñç Etablissement d'une connexion TCP</font> </h3><br>  Apr√®s avoir appris l'adresse IP du serveur, le client peut √©tablir une connexion TCP avec lui.  Lors de l'√©tablissement d'une connexion TCP, le client et le serveur se transmettent mutuellement des donn√©es de service, apr√®s quoi ils peuvent √©changer des informations.  Cela signifie qu'une fois la connexion √©tablie, le client pourra envoyer une demande au serveur. <br><br><h3>  <font color="#3AC1EF">‚ñçEnvoyer une demande</font> </h3><br>  Une demande est un fragment de texte structur√© conform√©ment aux r√®gles du protocole utilis√©.  Il se compose de trois parties: <br><br><ul><li>  Cha√Æne de requ√™te </li><li>  En-t√™te de demande. </li><li>  Demander le corps. </li></ul><br><h4>  Cha√Æne de requ√™te </h4><br>  La cha√Æne de requ√™te est une cha√Æne de texte unique qui contient les informations suivantes: <br><br><ul><li>  M√©thode HTTP. </li><li>  Adresse de la ressource </li><li>  Version du protocole. </li></ul><br>  Cela peut ressembler, par exemple, √† ceci: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4>  En-t√™te de demande </h4><br>  L'en-t√™te de demande est repr√©sent√© par un ensemble de <code>: </code> .  Il y a 2 champs d'en-t√™te obligatoires, dont l'un est <code>Host</code> et le second est <code>Connection</code> .  Les champs restants sont facultatifs. <br><br>  Le titre peut ressembler √† ceci: <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  Le champ <code>Host</code> indique le nom de domaine qui int√©resse le navigateur.  Le champ <code>Connection</code> , d√©fini sur <code>close</code> , signifie que la connexion entre le client et le serveur n'a pas besoin d'√™tre maintenue ouverte. <br><br>  Les autres en-t√™tes de demande couramment utilis√©s sont les suivants: <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br>  En fait, il y en a beaucoup plus. <br><br>  L'en-t√™te de demande se termine par une cha√Æne vide. <br><br><h4>  Organe de demande </h4><br>  Le corps de la demande est facultatif; il n'est pas utilis√© dans les demandes GET.  Le corps de la requ√™te est utilis√© dans les requ√™tes POST, ainsi que dans d'autres requ√™tes.  Il peut contenir, par exemple, des donn√©es au format JSON. <br><br>  Puisque nous parlons maintenant d'une requ√™te GET, le corps de la requ√™te sera vide, nous ne travaillerons pas avec. <br><br><h3>  <font color="#3AC1EF">‚ñç R√©pondre</font> </h3><br>  Une fois que le serveur a re√ßu la demande envoy√©e par le client, il la traite et envoie une r√©ponse au client. <br><br>  La r√©ponse commence par un code d'√©tat et un message correspondant.  Si la demande aboutit, le d√©but de la r√©ponse ressemblera √† ceci: <br><br><pre> <code class="hljs">200 OK</code> </pre> <br>  En cas de probl√®me, il peut y avoir d'autres codes.  Par exemple, les √©l√©ments suivants: <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br>  De plus, la r√©ponse contient une liste d'en-t√™tes HTTP et le corps de la r√©ponse (qui, puisque la demande est ex√©cut√©e par le navigateur, sera du code HTML). <br><br><h4>  Analyse HTML </h4><br>  Une fois que le navigateur a re√ßu la r√©ponse du serveur, dont le corps contient du code HTML, il commence √† l'analyser, en r√©p√©tant le processus ci-dessus pour chaque ressource n√©cessaire pour former la page.  Ces ressources comprennent, par exemple, les √©l√©ments suivants: <br><br><ul><li>  Fichiers CSS. </li><li>  Les images </li><li>  Ic√¥ne de page Web (favicon). </li><li>  Fichiers JavaScript. </li></ul><br>  La fa√ßon exacte dont le navigateur affiche la page ne s'applique pas √† notre conversation.  La principale chose qui nous int√©resse ici est que le processus de demande et de r√©ception de donn√©es ci-dessus est utilis√© non seulement pour le code HTML, mais aussi pour tout autre objet transf√©r√© du serveur au navigateur √† l'aide du protocole HTTP. <br><br><h2>  <font color="#3AC1EF">√Ä propos de la cr√©ation d'un serveur simple √† l'aide de Node.js</font> </h2><br>  Maintenant, apr√®s avoir examin√© le processus d'interaction entre le navigateur et le serveur, vous pouvez jeter un nouveau regard sur la section d'application First Node.js de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie de</a> cette s√©rie de documents, dans laquelle nous avons d√©crit le code d'un serveur simple. <br><br><h2>  <font color="#3AC1EF">Faire des requ√™tes HTTP avec Node.js</font> </h2><br>  Pour effectuer des requ√™tes HTTP √† l'aide de Node.js, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/">module</a> appropri√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/">est utilis√©</a> .  Les exemples ci-dessous utilisent le module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/">https</a> .  Le fait est que dans les conditions modernes, dans la mesure du possible, il est n√©cessaire d'utiliser le protocole HTTPS. <br><br><h3>  <font color="#3AC1EF">‚ñç Ex√©cution des requ√™tes GET</font> </h3><br>  Voici un exemple d'ex√©cution d'une demande GET √† l'aide de Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">ExecutionEx√©cution de la requ√™te POST</font> </h3><br>  Voici comment effectuer une demande POST √† ‚Äã‚Äãpartir de Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">UTPUT et DELETE requ√™tes</font> </h3><br>  L'ex√©cution de ces requ√™tes ressemble √† celle des requ√™tes POST.  La principale diff√©rence, outre le contenu s√©mantique de ces op√©rations, est la valeur de la propri√©t√© <code>method</code> de l'objet <code>options</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Ex√©cution de requ√™tes HTTP dans Node.js √† l'aide de la biblioth√®que Axios</font> </h3><br>  Axios est une biblioth√®que JavaScript tr√®s populaire qui fonctionne √† la fois dans le navigateur (cela inclut tous les navigateurs modernes et IE, √† commencer par IE8), et dans l'environnement Node.js, qui peut √™tre utilis√© pour effectuer des requ√™tes HTTP. <br><br>  Cette biblioth√®que est bas√©e sur des promesses, elle pr√©sente certains avantages par rapport aux m√©canismes standard, en particulier par rapport √† l'API Fetch.  Ses avantages sont les suivants: <br><br><ul><li>  Prise en charge des anciens navigateurs (vous avez besoin d'un polyfill pour utiliser Fetch). </li><li>  Possibilit√© d'interrompre les demandes. </li><li>  Prise en charge de la d√©finition des d√©lais d'expiration des demandes. </li><li>  Protection int√©gr√©e contre les attaques CSRF. </li><li>  Prise en charge du t√©l√©chargement de donn√©es avec la fourniture d'informations sur l'avancement de ce processus. </li><li>  Prise en charge de la conversion de donn√©es JSON. </li><li>  Emplois chez Node.js </li></ul><br><h4>  L'installation </h4><br>  Vous pouvez utiliser npm pour installer Axios: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br>  Le m√™me effet peut √™tre obtenu avec du fil: <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br>  Vous pouvez connecter la biblioth√®que √† la page en utilisant <code>unpkg.com</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  API Axios </h4><br>  Vous pouvez faire une requ√™te HTTP en utilisant l'objet <code>axios</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br>  Mais il est g√©n√©ralement plus pratique d'utiliser des m√©thodes sp√©ciales: <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br>  Ceci est similaire √† la fa√ßon dont jQuery utilise <code>$.get()</code> et <code>$.post()</code> au lieu de <code>$.ajax()</code> <code>$.post()</code> . <br><br>  Axios propose des m√©thodes distinctes pour ex√©cuter d'autres types de requ√™tes HTTP, qui ne sont pas aussi populaires que GET et POST, mais sont toujours utilis√©es: <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br>  La biblioth√®que dispose d'une m√©thode pour ex√©cuter une demande con√ßue pour recevoir uniquement des en-t√™tes HTTP, sans le corps de la r√©ponse: <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  GET demandes </h4><br>  Axios est pratique √† utiliser en utilisant la syntaxe asynchrone / attente moderne.  L'exemple de code suivant, con√ßu pour Node.js, utilise la biblioth√®que pour charger une liste de races de chiens √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'API Dog</a> .  Ici, la m√©thode <code>axios.get()</code> est appliqu√©e et les roches sont compt√©es: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br>  Le m√™me peut √™tre r√©√©crit sans utiliser async / wait, en appliquant des promesses: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4>  Utilisation de param√®tres dans les requ√™tes GET </h4><br>  Une requ√™te GET peut contenir des param√®tres qui ressemblent √† ceci dans une URL: <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br>  Lorsque vous utilisez Axios, une requ√™te de ce type peut √™tre effectu√©e comme suit: <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br>  Le m√™me effet peut √™tre obtenu en d√©finissant la propri√©t√© <code>params</code> dans un objet avec des param√®tres: <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  Demandes POST </h4><br>  L'ex√©cution des requ√™tes POST est tr√®s similaire √† l'ex√©cution des requ√™tes GET, mais ici, au lieu de la m√©thode <code>axios.get()</code> , la m√©thode <code>axios.post()</code> est utilis√©e: <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br>  Comme deuxi√®me argument, la m√©thode <code>post</code> accepte un objet avec des param√®tres de requ√™te: <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">Utilisation du protocole WebSocket dans Node.js</font> </h2><br>  WebSocket est une alternative √† HTTP, il peut √™tre utilis√© pour organiser l'√©change de donn√©es dans des applications Web.  Ce protocole vous permet de cr√©er des canaux de communication bidirectionnels de longue dur√©e entre le client et le serveur.  Une fois la connexion √©tablie, le canal de communication reste ouvert, ce qui met l'application √† la disposition d'une connexion tr√®s rapide, caract√©ris√©e par de faibles latences et une faible charge suppl√©mentaire sur le syst√®me. <br><br>  Le protocole WebSocket est pris en charge par tous les navigateurs modernes. <br><br><h3>  <font color="#3AC1EF">‚ñç Diff√©rences HTTP</font> </h3><br>  HTTP et WebSocket sont des protocoles tr√®s diff√©rents qui utilisent diff√©rentes approches pour l'√©change de donn√©es.  HTTP est bas√© sur le mod√®le ¬´request-response¬ª: le serveur envoie des donn√©es au client apr√®s leur demande.  Dans le cas de WebSocket, tout est organis√© diff√©remment.  √Ä savoir: <br><br><ul><li>  Le serveur peut envoyer des messages au client de sa propre initiative, sans attendre une demande du client. </li><li>  Le client et le serveur peuvent √©changer des donn√©es en m√™me temps. </li><li>  Lors de la transmission d'un message, une quantit√© extr√™mement faible de donn√©es de service est utilis√©e.  Cela conduit notamment √† une faible latence dans la transmission des donn√©es. </li></ul><br>  Le protocole WebSocket est tr√®s bien adapt√© aux communications en temps r√©el sur des canaux qui restent ouverts pendant longtemps.  HTTP, √† son tour, est excellent pour organiser des sessions de communication occasionnelles initi√©es par le client.  Dans le m√™me temps, il convient de noter que, d'un point de vue de la programmation, il est beaucoup plus facile de mettre en ≈ìuvre l'√©change de donn√©es en utilisant le protocole HTTP qu'en utilisant le protocole WebSocket. <br><br><h3>  <font color="#3AC1EF">‚ñç Version prot√©g√©e du protocole WebSocket</font> </h3><br>  Il existe une version non s√©curis√©e du protocole WebSocket (sch√©ma <code>ws://</code> URI), qui ressemble, en termes de s√©curit√©, au protocole <code>http://</code> .  L'utilisation de <code>ws://</code> doit √™tre √©vit√©e, pr√©f√©rant une version s√©curis√©e du protocole - <code>wss://</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçCr√©ation d'une connexion WebSocket</font> </h3><br>  Pour cr√©er une connexion WebSocket, vous devez utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constructeur</a> appropri√©: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br>  Une fois la connexion √©tablie, l'√©v√©nement <code>open</code> est d√©clench√©.  Vous pouvez organiser cet √©v√©nement en affectant une fonction de rappel √† la propri√©t√© <code>onopen</code> de l'objet de <code>connection</code> : <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Pour g√©rer les erreurs, le <code>onerror</code> √©v√©nements <code>onerror</code> est utilis√©: <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçEnvoyer des donn√©es au serveur</font> </h3><br>  Apr√®s avoir ouvert une connexion WebSocket au serveur, vous pouvez lui envoyer des donn√©es.  Cela peut √™tre fait, par exemple, dans le <code>onopen</code> onopen: <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Obtention des donn√©es du serveur</font> </h3><br>  Pour recevoir des donn√©es envoy√©es √† l'aide du protocole WebSocket du serveur, vous pouvez affecter le <code>onmessage</code> onmessage, qui sera appel√© lorsque l'√©v√©nement de <code>message</code> est re√ßu: <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Impl√©mentation du serveur WebSocket dans l'environnement Node.js</font> </h3><br>  Afin d'impl√©menter un serveur WebSocket dans l'environnement Node.js, vous pouvez utiliser la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ws</a> populaire.  Nous l'utilisons pour le d√©veloppement de serveurs, mais il convient √† la cr√©ation de clients, ainsi qu'√† l'organisation de l'interaction entre deux serveurs. <br><br>  Installez cette biblioth√®que en initialisant d'abord le projet: <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br>  Le code du serveur WebSocket que nous devons √©crire est assez compact: <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br>  Ici, nous cr√©ons un nouveau serveur qui √©coute sur le port standard 8080 pour le protocole WebSocket et d√©crivons un rappel qui, lorsque la connexion est √©tablie, envoie un message <code>ho!</code> au client <code>ho!</code>  et imprime sur la console un message re√ßu du client. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici un</a> exemple de travail d'un serveur WebSocket, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> un client qui peut interagir avec lui. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Aujourd'hui, nous avons parl√© des m√©canismes de mise en r√©seau pris en charge par la plateforme Node.js, √©tablissant des parall√®les avec des m√©canismes similaires utilis√©s dans les navigateurs.  Notre prochain sujet portera sur les fichiers. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous le protocole WebSocket dans vos applications Web, dont le c√¥t√© serveur a √©t√© cr√©√© √† l'aide de Node.js? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424557/">https://habr.com/ru/post/fr424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424541/index.html">Histoire du fiasco UGJ 2018: comment cr√©er un jeu que personne n'aime (ne le faites pas!)</a></li>
<li><a href="../fr424543/index.html">Java 11 / JDK 11: disponibilit√© g√©n√©rale</a></li>
<li><a href="../fr424551/index.html">Warm and tube: cinq balala√Økas sur la technologie audio magn√©tique</a></li>
<li><a href="../fr424553/index.html">Guide Node.js, partie 6: boucle d'√©v√©nement, pile d'appels, minuteurs</a></li>
<li><a href="../fr424555/index.html">Manuel Node.js, partie 7: programmation asynchrone</a></li>
<li><a href="../fr424559/index.html">R√©sistance Big Data 1 ou Joe insaisissable. Anonymat Internet, anti-d√©tection, anti-tracking pour anti-you et anti-us</a></li>
<li><a href="../fr424563/index.html">Beeline envoie les d√©tails des conversations √† des √©trangers</a></li>
<li><a href="../fr424565/index.html">Pr√©sentation: num√©risation 3D de locaux immobiliers</a></li>
<li><a href="../fr424567/index.html">L'exp√©rience du blocage de la publicit√© en ligne dans le r√©seau local de l'entreprise</a></li>
<li><a href="../fr424569/index.html">Embauche de programmeurs. Conseils du programmeur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>