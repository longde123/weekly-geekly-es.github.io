<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ ğŸ‘†ğŸ¼ ğŸ—ï¸ Menggunakan jaringan saraf convolutional untuk memainkan Life (on Keras) ğŸ‘©ğŸ¼â€ğŸ”§ ğŸ‘¸ğŸ¾ ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tujuan artikel ini adalah untuk mengajarkan jaringan saraf untuk memainkan game Life tanpa mengajarkannya aturan permainan. 


 Halo, Habr! Saya mempe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan jaringan saraf convolutional untuk memainkan Life (on Keras)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481544/"><p><img src="https://habrastorage.org/getpro/habr/post_images/6e6/011/288/6e6011288fb72573558a3cebf6008a15.png"></p><br><p>  Tujuan artikel ini adalah untuk mengajarkan jaringan saraf untuk memainkan game Life tanpa mengajarkannya aturan permainan. </p><br><p>  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel <a href="https://kylewbanks.com/blog/conways-game-of-life-convolutional-neural-network-keras" rel="nofollow">"Menggunakan Jaringan Saraf Konvolusional untuk Memainkan Game of Conway's Life with Keras"</a> oleh kylewbanks. </p><a name="habracut"></a><br><p>  Jika Anda tidak terbiasa dengan permainan yang disebut Life ( <em>ini adalah otomat seluler, diciptakan oleh ahli matematika Inggris John Conway pada tahun 1970</em> ), aturannya adalah sebagai berikut. </p><br><p>  Gim semesta adalah kotak sel persegi dua dimensi yang tak terbatas, masing-masingnya ada di salah satu dari dua kemungkinan keadaan: hidup atau mati (atau masing-masing dihuni dan tidak berpenghuni).  Setiap sel berinteraksi dengan delapan tetangganya secara horizontal, vertikal atau diagonal.  Pada setiap langkah waktu, transisi berikut terjadi: </p><br><ul><li>  Setiap sel hidup dengan kurang dari dua tetangga yang hidup mati. </li><li>  Setiap sel hidup dengan dua atau tiga tetangga yang hidup bertahan hingga generasi berikutnya. </li><li>  Setiap sel hidup dengan lebih dari tiga tetangga yang hidup mati. </li><li>  Setiap sel mati dengan tiga tetangga yang hidup menjadi sel hidup. </li></ul><br><p>  Generasi pertama diciptakan dengan menerapkan aturan-aturan di atas secara bersamaan ke setiap sel dalam keadaan awal, kelahiran dan kematian terjadi secara simultan pada titik-titik waktu yang berbeda.  Setiap generasi adalah fungsi murni dari sebelumnya.  Aturan terus berlaku untuk generasi baru untuk membuat generasi berikutnya. </p><br><p>  Lihat <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B3%25D1%2580%25D0%25B0_%25C2%25AB%25D0%2596%25D0%25B8%25D0%25B7%25D0%25BD%25D1%258C%25C2%25BB" rel="nofollow">Wikipedia untuk</a> detailnya. </p><br><p>  Kenapa melakukan ini?  Terutama untuk hiburan, dan untuk belajar sedikit tentang jaringan saraf convolutional. </p><br><p>  Jadi ... </p><br><h1 id="igrovaya-logika">  Logika game </h1><br><p>  Hal pertama yang harus dilakukan adalah mendefinisikan fungsi yang menggunakan bidang bermain sebagai input dan mengembalikan status berikutnya. </p><br><p>  Untungnya, banyak implementasi yang tersedia di Internet, seperti: <a href="https://jakevdp.github.io/blog/2013/08/07/conways-game-of-life/" rel="nofollow">https://jakevdp.github.io/blog/2013/08/07/conways-game-of-life/</a> . </p><br><p>  Bahkan, dibutuhkan matriks dari lapangan bermain sebagai input, di mana 0 mewakili sel mati, dan 1 mewakili sel hidup dan mengembalikan matriks dengan ukuran yang sama, tetapi berisi keadaan masing-masing sel pada iterasi permainan berikutnya. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">life_step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X)</span></span></span><span class="hljs-function">:</span></span> live_neighbors = sum(np.roll(np.roll(X, i, <span class="hljs-number"><span class="hljs-number">0</span></span>), j, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> j != <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (live_neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) | (X &amp; (live_neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span>)).astype(int)</code> </pre> <br><h1 id="generaciya-igrovogo-polya">  Bermain generasi lapangan </h1><br><p>  Mengikuti logika game, kita membutuhkan cara untuk menghasilkan bidang game secara acak dan cara memvisualisasikannya. </p><br><p>  Fungsi <code>generate_frames</code> menciptakan <code>num_frames</code> bidang game acak dengan bentuk tertentu dan probabilitas yang telah ditentukan bahwa setiap sel akan "hidup", dan <code>render_frames</code> menggambar representasi gambar dari dua bidang game secara berdampingan untuk perbandingan (sel hidup berwarna putih dan sel mati berwarna hitam): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_frames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num_frames, board_shape=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">,</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span><span class="hljs-function"><span class="hljs-params">, prob_alive=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.15</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.array([ np.random.choice([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>], size=board_shape, p=[<span class="hljs-number"><span class="hljs-number">1</span></span>-prob_alive, prob_alive]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(num_frames) ]).astype(int) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_frames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(frame1, frame2)</span></span></span><span class="hljs-function">:</span></span> plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) plt.imshow(frame1.flatten().reshape(board_shape), cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) plt.imshow(frame2.flatten().reshape(board_shape), cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><p>  Mari kita lihat seperti apa bidang-bidang ini: </p><br><pre> <code class="python hljs">board_shape = (<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) board_size = board_shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] * board_shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] probability_alive = <span class="hljs-number"><span class="hljs-number">0.15</span></span> frames = generate_frames(<span class="hljs-number"><span class="hljs-number">10</span></span>, board_shape=board_shape, prob_alive=probability_alive) print(frames.shape) <span class="hljs-comment"><span class="hljs-comment"># (num_frames, board_w, board_h)</span></span></code> </pre> <br><pre> <code class="plaintext hljs">(10, 20, 20)</code> </pre> <br><pre> <code class="python hljs">print(frames[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre> <br><pre> <code class="plaintext hljs">[[0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0]])</code> </pre> <br><p>  Selanjutnya, representasi bilangan bulat dari bidang bermain diambil dan ditampilkan sebagai gambar. <br>  Keadaan lapangan bermain berikut juga ditampilkan di sebelah kanan menggunakan fungsi <code>life_step</code> : </p><br><pre> <code class="python hljs">ender_frames(frames[<span class="hljs-number"><span class="hljs-number">1</span></span>], life_step(frames[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/cf0/80f/cca/cf080fcca9b99fbad53e00abad7299a8.png"></p><br><h1 id="postroenie-obuchayuschego-i-testovogo-naborov">  Pelatihan bangunan dan set tes </h1><br><p>  Sekarang kita dapat menghasilkan data untuk pelatihan, verifikasi, dan pengujian. </p><br><p>  Setiap elemen dalam <code>y_train</code> / <code>y_val</code> / <code>y_test</code> akan mewakili bidang game berikutnya untuk setiap frame bidang dalam <code>X_train</code> / <code>X_val</code> / <code>X_test</code> . </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reshape_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.reshape(X.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], X.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], X.shape[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_dataset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num_frames, board_shape, prob_alive)</span></span></span><span class="hljs-function">:</span></span> X = generate_frames(num_frames, board_shape=board_shape, prob_alive=prob_alive) X = reshape_input(X) y = np.array([ life_step(frame) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> frame <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X ]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X, y train_size = <span class="hljs-number"><span class="hljs-number">70000</span></span> val_size = <span class="hljs-number"><span class="hljs-number">10000</span></span> test_size = <span class="hljs-number"><span class="hljs-number">20000</span></span></code> </pre> <br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Training Set:"</span></span>) X_train, y_train = generate_dataset(train_size, board_shape, probability_alive) print(X_train.shape) print(y_train.shape)</code> </pre> <br><pre> <code class="plaintext hljs">Training Set: (70000, 20, 20, 1) (70000, 20, 20, 1)</code> </pre> <br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Validation Set:"</span></span>) X_val, y_val = generate_dataset(val_size, board_shape, probability_alive) print(X_val.shape) print(y_val.shape)</code> </pre> <br><pre> <code class="plaintext hljs">Validation Set: (10000, 20, 20, 1) (10000, 20, 20, 1)</code> </pre> <br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Test Set:"</span></span>) X_test, y_test = generate_dataset(test_size, board_shape, probability_alive) print(X_test.shape) print(y_test.shape)</code> </pre> <br><pre> <code class="plaintext hljs">Test Set: (20000, 20, 20, 1) (20000, 20, 20, 1)</code> </pre> <br><h1 id="postroenie-svertochnoy-neyronnoy-seti">  Konstruksi jaringan saraf convolutional </h1><br><p>  Sekarang kita dapat mengambil langkah pertama menuju membangun jaringan saraf convolutional menggunakan Keras.  Titik kunci di sini adalah ukuran kernel (3, 3) dan langkah 1. Mereka memberitahu CNN untuk menggunakan matriks 3x3 sel di sekitarnya untuk setiap sel di bidang yang dilihatnya, termasuk sel saat ini. </p><br><p>  Misalnya, jika berikut ini adalah bidang permainan, dan kami berada di sel tengah <code>x</code> , dia akan melihat semua sel yang ditandai dengan tanda seru <code>!</code>  dan sel <code></code> .  Kemudian jaringan bergerak di sepanjang sel ke kanan dan melakukan hal yang sama, mengulanginya berulang-ulang sampai memproses setiap sel dan tetangganya di seluruh bidang. </p><br><pre> <code class="plaintext hljs">0 0 0 0 0 0! ! ! 0 0! x ! 0 0! ! ! 0 0 0 0 0 0</code> </pre> <br><p>  Sisa dari jaringan ini cukup sederhana, jadi saya tidak akan memerinci.  Jika Anda tertarik pada sesuatu, saya sarankan membaca dokumentasinya. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sequential <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dense, Dropout, Activation, Conv2D, MaxPool2D <span class="hljs-comment"><span class="hljs-comment"># CNN Properties filters = 50 kernel_size = (3, 3) # look at all 8 neighboring cells, plus itself strides = 1 hidden_dims = 100 model = Sequential() model.add(Conv2D( filters, kernel_size, padding='same', activation='relu', strides=strides, input_shape=(board_shape[0], board_shape[1], 1) )) model.add(Dense(hidden_dims)) model.add(Dense(1)) model.add(Activation('sigmoid')) model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])</span></span></code> </pre> <br><p>  Lihatlah output dari fungsi <code>summary</code> : </p><br><pre> <code class="python hljs">model.summary()</code> </pre> <br><pre> <code class="plaintext hljs">_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_9 (Conv2D) (None, 20, 20, 50) 500 _________________________________________________________________ dense_17 (Dense) (None, 20, 20, 100) 5100 _________________________________________________________________ dense_18 (Dense) (None, 20, 20, 1) 101 _________________________________________________________________ activation_9 (Activation) (None, 20, 20, 1) 0 ================================================================= Total params: 5,701 Trainable params: 5,701 Non-trainable params: 0 _________________________________________________________________</code> </pre> <br><h1 id="obuchenie-i-sohranenie-modeli">  Melatih dan menyimpan model </h1><br><p>  Setelah membangun CNN, mari latih model dan simpan ke disk: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, X_train, y_train, X_val, y_val, batch_size=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">50</span></span></span></span><span class="hljs-function"><span class="hljs-params">, epochs=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, filename_suffix=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> model.fit( X_train, y_train, batch_size=batch_size, epochs=epochs, validation_data=(X_val, y_val) ) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'cgol_cnn{}.json'</span></span>.format(filename_suffix), <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> file: file.write(model.to_json()) model.save_weights(<span class="hljs-string"><span class="hljs-string">'cgol_cnn{}.h5'</span></span>.format(filename_suffix)) train(model, X_train, y_train, X_val, y_val, filename_suffix=<span class="hljs-string"><span class="hljs-string">'_basic'</span></span>)</code> </pre> <br><pre> <code class="plaintext hljs">Train on 70000 samples, validate on 10000 samples Epoch 1/2 70000/70000 [==============================] - 27s 388us/step - loss: 0.1324 - acc: 0.9651 - val_loss: 0.0833 - val_acc: 0.9815 Epoch 2/2 70000/70000 [==============================] - 27s 383us/step - loss: 0.0819 - acc: 0.9817 - val_loss: 0.0823 - val_acc: 0.9816</code> </pre> <br><p>  Model ini memberikan akurasi lebih dari 98% untuk pelatihan dan set tes, yang sangat baik untuk lintasan pertama.  Mari kita coba mencari tahu di mana kita membuat kesalahan. </p><br><h1 id="probuem">  Coba </h1><br><p>  Mari kita lihat ramalan lapangan bermain acak dan cara kerjanya.  Pertama, buat satu bidang bermain dan lihat bingkai berikutnya yang benar: </p><br><pre> <code class="python hljs">X, y = generate_dataset(<span class="hljs-number"><span class="hljs-number">1</span></span>, board_shape=board_shape, prob_alive=probability_alive) render_frames(X[<span class="hljs-number"><span class="hljs-number">0</span></span>].flatten().reshape(board_shape), y)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/b46/554/cee/b46554cee0c2fe745dc741cc54377b84.png"></p><br><p>  Selanjutnya, mari kita lakukan prediksi dan lihat berapa banyak sel yang diprediksi secara salah: </p><br><pre> <code class="python hljs">pred = model.predict_classes(X) print(np.count_nonzero(pred.flatten() - y.flatten()), <span class="hljs-string"><span class="hljs-string">"incorrect cells."</span></span>)</code> </pre> <br><pre> <code class="plaintext hljs">4 incorrect cells.</code> </pre> <br><p>  Selanjutnya, mari kita bandingkan langkah selanjutnya yang benar dengan langkah yang diperkirakan: </p><br><pre> <code class="python hljs">render_frames(y, pred.flatten().reshape(board_shape))</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/f66/eb1/91ff66eb1a2ec723621b3f49c1d34b84.png"></p><br><p>  Itu tidak menakutkan, tetapi Anda melihat di mana prediksi gagal?  Tampaknya jaringan tidak dapat memprediksi sel di tepi lapangan bermain.  Mari kita lihat di mana nilai bukan nol menunjukkan prediksi yang salah: </p><br><pre> <code class="python hljs">print(pred.flatten().reshape(board_shape) - y.flatten().reshape(board_shape))</code> </pre> <br><pre> <code class="plaintext hljs">[[ 0 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 -1 -1 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0]]</code> </pre> <br><p>  Seperti yang Anda lihat, semua nilai bukan nol terletak di tepi lapangan bermain.  Mari kita lihat suite tes lengkap dan konfirmasikan bahwa pengamatan ini benar. </p><br><h1 id="prosmotr-oshibok-ispolzuya-testovyy-nabor">  Lihat bug menggunakan test suite </h1><br><p>  Kami akan menulis fungsi yang menampilkan peta panas yang menunjukkan di mana model melakukan kesalahan, dan menyebutnya dengan menggunakan seluruh rangkaian uji: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_prediction_errors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, X, y)</span></span></span><span class="hljs-function">:</span></span> y_pred = model.predict_classes(X) sum_y_pred = np.sum(y_pred, axis=<span class="hljs-number"><span class="hljs-number">0</span></span>).flatten().reshape(board_shape) sum_y = np.sum(y, axis=<span class="hljs-number"><span class="hljs-number">0</span></span>).flatten().reshape(board_shape) plt.imshow(sum_y_pred - sum_y, cmap=<span class="hljs-string"><span class="hljs-string">'hot'</span></span>, interpolation=<span class="hljs-string"><span class="hljs-string">'nearest'</span></span>) plt.show() view_prediction_errors(model, X_test, y_test)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/56a/177/360/56a17736048c4f2b817b8aca5615e6cb.png"></p><br><p>  Semua kesalahan ada di tepi dan sudut.  Yang logis, karena CNN tidak bisa melihat-lihat, tetapi logika permainan di <code>life_step</code> melakukan ini.  Sebagai contoh, pertimbangkan hal berikut.  Melihat sel tepi <code>x</code> bawah ini, CNN hanya melihat <code>x</code> dan <code>!</code>  sel: </p><br><pre> <code class="plaintext hljs">0 0 0 0 0 ! ! 0 0 0 x ! 0 0 0 ! ! 0 0 0 0 0 0 0 0</code> </pre> <br><p>  Tapi apa yang kita inginkan dan apa yang <code>life_step</code> lakukan adalah melihat sel-sel dari sisi yang berlawanan: </p><br><pre> <code class="plaintext hljs">0 0 0 0 0 ! ! 0 0 ! x ! 0 0 ! ! ! 0 0 ! 0 0 0 0 0</code> </pre> <br><p>  Situasi serupa di sudut: </p><br><pre> <code class="plaintext hljs">x ! 0 0 ! ! ! 0 0 ! 0 0 0 0 0 0 0 0 0 0 ! 0 0 0 !</code> </pre> <br><p>  Untuk memperbaikinya, <code>Conv2D</code> entah bagaimana harus melihat sisi berlawanan dari lapangan bermain.  Atau, setiap bidang input dapat diproses untuk mengisi tepi di sisi yang berlawanan, dan kemudian Conv2D dapat dengan mudah menghapus kolom dan baris pertama atau terakhir.  Karena kita berada pada belas kasihan Keras dan fungsionalitas isi yang disediakannya yang tidak mendukung apa yang kita cari, kita harus terpaksa menambahkan isi kita sendiri. </p><br><h1 id="ispravlenie-kraevyh-defektov-s-pomoschyu-zapolneniya">  Koreksi cacat tepi menggunakan pengisian </h1><br><p>  Kita perlu melengkapi setiap bidang bermain dengan nilai yang berlawanan untuk meniru bagaimana <code>life_step</code> bekerja untuk nilai tepi.  Kita dapat menggunakan <code>np.pad</code> dengan <code>mode = 'wrap'</code> untuk ini.  Sebagai contoh, pertimbangkan array berikut dan hasil tambahan di bawah ini: </p><br><pre> <code class="python hljs">x = np.array([ [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] ]) print(np.pad(x, (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), mode=<span class="hljs-string"><span class="hljs-string">'wrap'</span></span>))</code> </pre> <br><pre> <code class="plaintext hljs">[[9, 7, 8, 9, 7], [3, 1, 2, 3, 1], [6, 4, 5, 6, 4], [9, 7, 8, 9, 7], [3, 1, 2, 3, 1]]</code> </pre> <br><p>  Perhatikan bahwa kolom / baris pertama dan kolom / baris terakhir mencerminkan sisi berlawanan dari matriks asli, dan matriks 3x3 tengah adalah nilai <code>x</code> asli.  Misalnya, sel [1] [1] disalin di sisi yang berlawanan dalam sel [4] [1], dan seperti [0] [1] berisi [3] [1].  Di semua arah dan bahkan di sudut, array dikoreksi sehingga mengandung sisi yang berlawanan.  Ini akan memungkinkan CNN untuk meninjau seluruh lapangan bermain dan menangani kasus ekstrim dengan benar. </p><br><p>  Sekarang kita dapat menulis fungsi untuk mengisi semua matriks input kami: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pad_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reshape_input(np.array([ np.pad(x.reshape(board_shape), (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), mode=<span class="hljs-string"><span class="hljs-string">'wrap'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X ])) X_train_padded = pad_input(X_train) X_val_padded = pad_input(X_val) X_test_padded = pad_input(X_test) print(X_train_padded.shape) print(X_val_padded.shape) print(X_test_padded.shape)</code> </pre> <br><pre> <code class="plaintext hljs">(70000, 22, 22, 1) (10000, 22, 22, 1) (20000, 22, 22, 1)</code> </pre> <br><p>  Semua dataset sekarang dilengkapi dengan kolom / baris yang dibungkus, yang memungkinkan CNN untuk melihat sisi berlawanan dari lapangan bermain, seperti halnya <code>life_step</code> .  Karena itu, setiap lapangan bermain sekarang memiliki ukuran 22x22 bukan 20x20 asli. </p><br><p>  Kemudian, CNN harus dibangun kembali untuk membuang bantalan menggunakan <code>padding = 'valid'</code> (yang memberitahu Conv2D untuk membuang tepi, meskipun ini tidak segera jelas), dan menangani <code>input_shape</code> baru.  Jadi, ketika kita melewatkan bidang bermain dengan ukuran 22x22, kita masih mendapatkan ukuran 20x20 sebagai output, karena kita membuang kolom / baris pertama dan terakhir.  Sisanya tetap identik: </p><br><pre> <code class="python hljs">model_padded = Sequential() model_padded.add(Conv2D( filters, kernel_size, padding=<span class="hljs-string"><span class="hljs-string">'valid'</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, strides=strides, input_shape=(board_shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">2</span></span>, board_shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) )) model_padded.add(Dense(hidden_dims)) model_padded.add(Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>)) model_padded.add(Activation(<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>)) model_padded.compile(loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, optimizer=<span class="hljs-string"><span class="hljs-string">'adam'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>]) model_padded.summary()</code> </pre> <br><pre> <code class="plaintext hljs">_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_10 (Conv2D) (None, 20, 20, 50) 500 _________________________________________________________________ dense_19 (Dense) (None, 20, 20, 100) 5100 _________________________________________________________________ dense_20 (Dense) (None, 20, 20, 1) 101 _________________________________________________________________ activation_10 (Activation) (None, 20, 20, 1) 0 ================================================================= Total params: 5,701 Trainable params: 5,701 Non-trainable params: 0 _________________________________________________________________</code> </pre> <br><p>  Sekarang kita bisa belajar menggunakan bidang yang disejajarkan: </p><br><pre> <code class="plaintext hljs">train( model_padded, X_train_padded, y_train, X_val_padded, y_val, filename_suffix='_padded' )</code> </pre> <br><pre> <code class="plaintext hljs">Train on 70000 samples, validate on 10000 samples Epoch 1/2 70000/70000 [==============================] - 27s 389us/step - loss: 0.0604 - acc: 0.9807 - val_loss: 4.5475e-04 - val_acc: 1.0000 Epoch 2/2 70000/70000 [==============================] - 27s 382us/step - loss: 1.7058e-04 - acc: 1.0000 - val_loss: 5.9932e-05 - val_acc: 1.0000</code> </pre> <br><p>  Keakuratan prediksi adalah dari 98% hingga 100%, yang kami terima sebelum menambahkan lekukan.  Mari kita lihat kesalahan pada test case: </p><br><pre> <code class="python hljs">view_prediction_errors(model_padded, X_test_padded, y_test)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/0cb/98e/b36/0cb98eb36fe336df53afab15ed8209ab.png"></p><br><p>  Hebat!  Peta panas hitam menunjukkan bahwa tidak ada perbedaan dalam nilai, dan ini berarti bahwa kami telah berhasil memprediksi setiap sel untuk setiap game. </p><br><p>  Itu adalah latihan kecil yang menyenangkan untuk bermain dengan jaringan saraf convolutional tanpa menggunakan dataset besar.  <a href="https://github.com/KyleBanks/conways-gol-cnn" rel="nofollow">Silakan cek di GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481544/">https://habr.com/ru/post/id481544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481534/index.html">Is Delphi Dying - False</a></li>
<li><a href="../id481536/index.html">Sejarah sistem nama domain: protokol "perang"</a></li>
<li><a href="../id481538/index.html">20 mitos SEO untuk mati pada tahun 2020</a></li>
<li><a href="../id481540/index.html">Memuat ulang tekstur OpenGLESv2 melalui DMABUF</a></li>
<li><a href="../id481542/index.html">Verifikasi sirkuit digital. Ulasan</a></li>
<li><a href="../id481546/index.html">Sejarah mikroprosesor dan komputer pribadi: 1947-1974</a></li>
<li><a href="../id481548/index.html">Symbol.iterator dalam Javascript</a></li>
<li><a href="../id481550/index.html">Inmarsat: menerima dan mendekode sinyal satelit di rumah</a></li>
<li><a href="../id481552/index.html">PGConf.Russia 2020 Segera Hadir</a></li>
<li><a href="../id481554/index.html">Bagaimana cara saya menempuh Master Online Sains dalam Ilmu Komputer, dan kepada siapa ini mungkin tidak cocok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>