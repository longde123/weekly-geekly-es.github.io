<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏻 👨🏽‍🎓 ⏺️ 使用Web Crypto API为JS中的2FA生成一次性密码 🐬 🤵 💵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 如今，到处都有两因素身份验证。 多亏了她，要窃取帐户，仅提供密码是不够的。 并且，尽管它的存在不能保证您的帐户不会被删除，但是仍然需要进行更复杂的多层攻击。 如您所知，这个世界上的事物越复杂，它就越不可能起作用。 


我敢肯定，阅读本文的每个人在生活中至少都会使用过两次身份验证（以下...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Web Crypto API为JS中的2FA生成一次性密码</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462945/"><h2 id="vvedenie"> 引言 </h2><br><p> 如今，到处都有两因素身份验证。 多亏了她，要窃取帐户，仅提供密码是不够的。 并且，尽管它的存在不能保证您的帐户不会被删除，但是仍然需要进行更复杂的多层攻击。 如您所知，这个世界上的事物越复杂，它就越不可能起作用。 </p><br><p>我敢肯定，阅读本文的每个人在生活中至少都会使用过两次身份验证（以下称为2FA，一个痛苦的长短语）。 今天，我邀请您了解这项技术的工作原理，该技术每天保护无数帐户。 </p><br><p> 但是对于初学者来说，您可以看一下我们今天要做的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> 。 </p><a name="habracut"></a><br><h2 id="osnovy"> 基础知识 </h2><br><p> 值得一提的一次性密码的第一件事是它们有两种类型： <strong>HOTP</strong>和<strong>TOTP</strong> 。 即， <strong>基于HMAC的一次性密码</strong>和<strong>基于时间的OTP</strong> 。  TOTP只是HOTP的一个附加组件，因此让我们首先讨论一个更简单的算法。 </p><br><p>  HOTP由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC4226</a>规范描述。 它很小，只有35页，包含您需要的所有内容：正式说明，示例实现和测试数据。 让我们看一下基本概念。 </p><br><p> 首先，什么是<strong>HMAC</strong> ？  HMAC代表基于<strong>哈希的消息身份验证代码</strong> ，或俄语中的“使用哈希功能的消息身份验证代码”。  MAC是一种用于验证消息发件人的机制。  <strong>MAC</strong>算法使用仅发送方和接收方已知的密钥生成<strong>MAC标签</strong> 。 收到消息后，您可以自己生成MAC标签并比较两个标签。 如果它们重合-一切都井井有条，则通信过程不会受到干扰。 另外，您可以以相同的方式检查消息在传输过程中是否已损坏。 当然，将干扰与损坏区分开是行不通的，但是信息损坏的事实就足够了。 </p><br><p><img src="https://habrastorage.org/webt/ug/0m/yf/ug0myfmi3y1iwrq3csxfsp1j6c0.png" alt="MAC标签"></p><br><p> 什么是哈希？ 哈希是对消息应用哈希函数的结果。 哈希函数将数据取为固定长度的字符串。 一个很好的例子是众所周知的<strong>MD5</strong>功能，该功能已广泛用于验证文件完整性。 </p><br><p>  <strong>MAC</strong>本身不是特定的算法，而只是一个通用术语。 反过来， <strong>HMAC</strong>已经是一个具体的实现。 更具体地说，是HMAC- <em>X</em> ，其中X是加密哈希函数之一。  HMAC接受两个参数：密钥和消息，以某种方式将它们混合，两次应用所选的哈希函数，并返回MAC标签。 </p><br><p> 如果您目前正在考虑一次密码与这一切有什么关系，请放心，我们已接近要点。 </p><br><p> 根据规范，HOTP是基于两个值计算的： </p><br><ul><li>  K是客户端和服务器知道的<strong>秘密密钥</strong> 。 它的长度至少应为128位，最好为160位，并在配置2FA时创建。 </li><li>  <strong>C</strong>是<strong>柜台</strong> 。 </li></ul><br><p> 计数器是客户端和服务器之间同步的8字节值。 生成新密码时，它会更新。 在HOTP方案中，每次您生成新密码时，客户端计数器都会增加。 在服务器端，每次密码成功通过验证时。 由于可以生成而不使用密码，因此服务器允许计数器值在已建立的窗口中提前运行。 但是，如果您过多使用HOTP方案中的密码生成器，则必须再次进行同步。 </p><br><p> 这样啊 您可能已经注意到，HMAC还接受两个参数。  RFC4226定义了HOTP生成功能，如下所示： </p><br><pre><code class="plaintext hljs">HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))</code> </pre> <br><p> 可以预期的是， <strong>K被</strong>用作密钥。 计数器又用作消息。 在HMAC函数生成MAC标签之后，神秘的<code>Truncate</code>函数会提取出我们已经熟悉的一次性密码，您可以在生成器应用程序或令牌中看到该密码。 </p><br><p> 让我们开始编写代码，然后处理其余部分。 </p><br><h2 id="plan-realizacii"> 实施计划 </h2><br><p> 要获得一次性密码，我们需要执行以下步骤。 </p><br><p><img src="https://habrastorage.org/webt/tl/v7/br/tlv7brjdmq9e7s-1rmc2bxpkrfm.png" alt="实作"></p><br><ul><li> 根据<strong>K</strong>和<strong>C</strong>参数生成HMAC-SHA1哈希。 这将是一个20字节的字符串。 </li><li> 以特定方式从此字符串中提取4个字节。 </li><li> 将提取的值转换为数字，然后将其除以10 ^ n，其中n =一次性密码中的位数（通常为n = 6）。 最后，采用该部门的其余部分。 这将是我们的密码。 </li></ul><br><p> 听起来不太难，对吧？ 让我们从哈希生成开始。 </p><br><h2 id="generiruem-hmac-sha1"> 生成HMAC-SHA1 </h2><br><p> 这也许是上面列出的最简单的步骤。 我们不会尝试自己重新创建算法（我们永远不需要尝试自行实现加密技术）。 相反，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>Web Crypto API</strong></a> 。 小问题是该规范API仅在安全上下文（HTTPS）下可用。 对我们来说，这充满了一个事实，那就是如果不在开发服务器上设置HTTPS，就无法使用它。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>可以找到一些历史和关于如何做出正确决定的讨论。 </p><br><p> 幸运的是，在Firefox中，您<em>可以</em>在不安全的环境中使用Web Crypto，而不必重新发明轮子或拖拽第三方库。 因此，出于开发演示的目的，我建议使用FF。 </p><br><p>  Crypto API本身在<code>window.crypto.subtle</code>定义。 如果您对这个名称感到惊讶，请参考一下规范： </p><br><blockquote> 该API称为<code>SubtleCrypto</code> ，反映了许多算法都有特定的使用要求这一事实。 只有满足这些要求，它们才能保持其耐久性。 </blockquote><p> 让我们来看看我们需要的方法。 注意：这里提到的所有方法都是异步的，并返回<code>Promise</code> 。 </p><br><p> 首先，我们需要<code>importKey</code>方法，因为我们将使用私钥，而不是在浏览器中生成私钥。  <code>importKey</code>接受5个参数： </p><br><pre> <code class="javascript hljs">importKey( format, keyData, algorithm, extractable, usages );</code> </pre> <br><p> 在我们的情况下： </p><br><ul><li>  <code>format</code>将为<code>'raw'</code> ，即 我们将提供密钥作为<code>ArrayBuffer</code>字节数组。 </li><li>  <code>keyData</code>是相同的ArrayBuffer。 很快我们将讨论如何生成它。 </li><li> 根据规范， <code>algorithm</code>将为<code>HMAC-SHA1</code> 。 此参数必须与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HmacImportParams</a>的格式匹配。 </li><li>  <code>extractable</code>为false，因为我们没有计划导出密钥 </li><li> 最后，在所有<code>usages</code>我们只需要<code>'sign'</code> 。 </li></ul><br><p> 我们的密钥将是一个长随机字符串。 在现实世界中，这可能是一个字节序列，可能是无法打印的，但是为了方便起见，在本文中，我们将考虑一个字符串。 要将其转换为<code>ArrayBuffer</code>我们将使用<code>TextEncoder</code>接口。 有了它，就可以用两行代码来准备密钥： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextEncoder(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secretBytes = encoder.encode(secret);</code> </pre> <br><p> 现在，我们将它们放在一起： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Crypto = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.crypto.subtle; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextEncoder(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secretBytes = encoder.encode(secret); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Crypto.importKey( <span class="hljs-string"><span class="hljs-string">'raw'</span></span>, secretBytes, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'HMAC'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hash</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'SHA-1'</span></span> } }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, [<span class="hljs-string"><span class="hljs-string">'sign'</span></span>] );</code> </pre> <br><p> 太好了！ 准备了密码学。 现在，我们将处理柜台并最终在消息上签名。 </p><br><p> 根据规范，我们的计数器应为8个字节长。 我们将再次使用它，就像<code>ArrayBuffer</code> 。 为了将其转换为这种形式，我们将使用JS中通常使用的技巧将零保存在数字的高位数字中。 之后，我们将使用<code>DataView</code>将每个字节放入<code>ArrayBuffer</code> 。 请记住，根据规范，所有二进制数据的格式均为<strong>大端</strong>格式。 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">padCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ArrayBuffer</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DataView</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byteString = <span class="hljs-string"><span class="hljs-string">'0'</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 8 bytes const bCounter = (byteString + counter.toString(2)).slice(-64); for (let byte = 0; byte &lt; 64; byte += 8) { const byteValue = parseInt(bCounter.slice(byte, byte + 8), 2); bView.setUint8(byte / 8, byteValue); } return buffer; }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/w0/cs/uh/w0csuhhkbyxccigknindlgpf3t0.png" alt="垫子计数器"></p><br><p> 最后，准备好密钥和计数器后，就可以生成哈希了！ 为此，我们将使用<code>SubtleCrypto</code>的<code>sign</code>函数。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterArray = padCounter(counter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HS = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Crypto.sign(<span class="hljs-string"><span class="hljs-string">'HMAC'</span></span>, key, counterArray);</code> </pre> <br><p> 至此，我们已经完成了第一步。 在输出中，我们得到一个有点神秘的值，称为HS。 尽管这不是变量的最佳名称，但在规范中将其称为变量（以及以下某些变量）。 我们将保留这些名称，以便更轻松地与代码进行比较。 接下来是什么？ </p><br><blockquote> 步骤2：生成一个4字节的字符串（动态截断） <br> 令Sbits = DT（HS）// DT，定义如下， <br>  //返回一个31位的字符串 </blockquote><p>  DT代表动态截断。 这是它的工作方式： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DT</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HS</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// First we take the last byte of our generated HS and extract last 4 bits out of it. // This will be our _offset_, a number between 0 and 15. const offset = HS[19] &amp; 0b1111; // Next we take 4 bytes out of the HS, starting at the offset const P = ((HS[offset] &amp; 0x7f) &lt;&lt; 24) | (HS[offset + 1] &lt;&lt; 16) | (HS[offset + 2] &lt;&lt; 8) | HS[offset + 3] // Finally, convert it into a binary string representation const pString = P.toString(2); return pString; }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/80/0n/5x/800n5xjrszlpbiriupg6acom-oq.png" alt="截断"></p><br><p> 注意我们如何将“与”运算应用于HS的第一个字节。 二进制系统中的<code>0x7f</code>是<code>0b01111111</code> ，因此本质上我们只是丢弃第一位。 在JS中，此表达式的含义在此结束，但在其他语言中，它也将切断符号位以消除正/负数之间的混淆，并将此数字显示为无符号。 </p><br><p> 快完成了！ 剩下的只是将从DT获得的值转换为数字并前进到第三步。 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">truncate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Sbits = DT(uKey); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Snum = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(Sbits, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Snum; }</code> </pre> <br><p> 第三步也很小。 所有需要做的就是将结果数除以<code>10 ** (   )</code> ，然后进行该除法的其余部分。 因此，我们从该数字中切除了最后N个数字。 根据规范，我们的代码应该能够提取至少六位数的密码，并可能提取出七位数和八位数的密码。 从理论上讲，由于这是一个31位数字，因此我们可以提取9个字符，但实际上，我个人从来没有见过超过6个字符。 那你呢 </p><br><p> 最终功能的代码结合了所有先前的代码，在这种情况下，将类似于以下内容： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateHOTP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">secret, counter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> generateKey(secret, counter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(key); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Snum = truncate(uKey); <span class="hljs-comment"><span class="hljs-comment">// Make sure we keep leading zeroes const padded = ('000000' + (Snum % (10 ** 6))).slice(-6); return padded; }</span></span></code> </pre> <br><p> 万岁！ 但是，现在如何检查我们的代码是否正确？ </p><br><h2 id="testirovanie"> 测试中 </h2><br><p> 为了测试实现，我们将使用RFC中的示例。 附录D包含密钥<code>"12345678901234567890"</code>测试值和从0到9的计数器值。还包含HMAC哈希计数和Truncate函数的中间结果。 对于调试算法的所有步骤非常有用。 这是此表的一个小示例（仅保留计数器和HOTP）： </p><br><pre> <code class="plaintext hljs"> Count HOTP 0 755224 1 287082 2 359152 3 969429 ...</code> </pre> <br><p> 如果您尚未观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> ，那么现在是时候了。 您可以在其中驱动RFC中的值。 再回来，因为我们正在开始TOTP。 </p><br><h2 id="totp"> 托普 </h2><br><p> 因此，我们终于到了2FA的更现代的部分。 当您打开一次性密码生成器并看到一个小的计时器，该计时器会计算还有多少有效代码，那就是TOTP。 有什么区别？ </p><br><p>  <strong>基于时间的</strong>意思是当前时间代替静态值用作计数器。 或者，更准确地说，是“间隔”（时间步长）。 甚至是当前间隔的数量。 为了计算它，我们使用Unix时间（自UTC 1970年1月1日午夜以来的毫秒数），然后用窗口除以密码有效期（通常为30秒）。 由于时钟同步不完善，服务器通常容忍很小的偏差。 通常来回1个间隔，具体取决于配置。 </p><br><p> 显然，这比HOTP方案安全得多。 在有时间限制的方案中，即使未使用有效代码，它也会每30秒更改一次。 在原始算法中，有效密码由服务器+公差窗口上的当前计数器值确定。 如果您不进行身份验证，密码将不会无限期更改。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC6238中</a>阅读有关TOTP的更多信息。 </p><br><p> 由于基于时间的方案是原始算法的补充，因此我们无需更改原始实现。 我们将使用<code>requestAnimationFrame</code>并检查每个帧是否仍在时间间隔内。 如果不是，请生成一个新的计数器并再次计算HOTP。 省略所有控制代码，解决方案如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stepWindow = <span class="hljs-number"><span class="hljs-number">30</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 30 seconds in ms let lastTimeStep = 0; const updateTOTPCounter = () =&gt; { const timeSinceStep = Date.now() - lastTimeStep * stepWindow; const timeLeft = Math.ceil(stepWindow - timeSinceStep); if (timeLeft &gt; 0) { return requestAnimationFrame(updateTOTPCounter); } timeStep = getTOTPCounter(); lastTimeStep = timeStep; &lt;...update counter and regenerate...&gt; requestAnimationFrame(updateTOTPCounter); }</span></span></code> </pre> <br><h2 id="poslednie-shtrihi--podderzhka-qr-kodov"> 结束语-QR码支持 </h2><br><p> 通常，当我们配置2FA时，我们会使用QR码扫描初始参数。 它包含所有必要的信息：选定的方案，密钥，帐户名，提供者名称，密码中的位数。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中，</a>我讨论了如何使用<code>getDisplayMedia</code> API直接从屏幕扫描QR码。 根据这些资料，我制作了一个小图书馆，我们现在将使用它。 该库称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stream-display</a> ，此外，我们还使用了出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">jsQR</a>包。 </p><br><p>  QR编码的链接具有以下格式： </p><br><pre> <code class="plaintext hljs">otpauth://TYPE/LABEL?PARAMETERS</code> </pre> <br><p> 例如： </p><br><pre> <code class="plaintext hljs">otpauth://totp/label?secret=oyu55d4q5kllrwhy4euqh3ouw7hebnhm5qsflfcqggczoafxu75lsagt&amp;algorithm=SHA1&amp;digits=6&amp;period=30</code> </pre> <br><p> 我将省略设置启动屏幕捕获和识别过程的代码，因为所有这些都可以在文档中找到。 相反，这是解析此链接的方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setupFromQR = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(data); <span class="hljs-comment"><span class="hljs-comment">// drop the "//" and get TYPE and LABEL const [scheme, label] = url.pathname.slice(2).split('/'); const params = new URLSearchParams(url.search); const secret = params.get('secret'); let counter; if (scheme === 'hotp') { counter = params.get('counter'); } else { stepWindow = parseInt(params.get('period'), 10) * 1000; counter = getTOTPCounter(); } }</span></span></code> </pre> <br><p> 在现实世界中，秘密密钥将是一个以<strong>32</strong>为基数（！）的字符串，因为某些字节可能无法打印。 但是为了简化演示，我们忽略了这一点。 不幸的是，我找不到为什么使用base-32或仅使用这种格式的信息。 显然，此URL格式不存在官方规范，该格式本身由Google创造。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>阅读有关他的一些信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </p><br><p> 要生成测试QR码，我建议使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FreeOTP</a> 。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 仅此而已！ 再一次，不要忘记观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> 。 还有一个到存储库的链接，其背后是所有代码。 </p><br><p> 今天，我们已经分解了每天使用的一项相当重要的技术。 希望您自己学到了一些新知识。 这篇文章花了比我想象的更长的时间。 但是，将纸张规范变成可行且熟悉的东西非常有趣。 </p><br><p> 待会见！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462945/">https://habr.com/ru/post/zh-CN462945/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462933/index.html">Internet阻止的工作原理：以实际示例回顾现代方法</a></li>
<li><a href="../zh-CN462935/index.html">在开放式办公室工作时如何保持专注？</a></li>
<li><a href="../zh-CN462937/index.html">用于控制IT基础架构的持久性架构的概念</a></li>
<li><a href="../zh-CN462939/index.html">俄罗斯十大C ++报告和开放获取会议播放列表</a></li>
<li><a href="../zh-CN462943/index.html">搜寻Wumpus或体验编写经典的Android游戏</a></li>
<li><a href="../zh-CN462947/index.html">有关PVS-Studio如何在... PVS-Studio中使用的库中发现错误的故事</a></li>
<li><a href="../zh-CN462949/index.html">有关PVS-Studio如何在... PVS-Studio中使用的库中发现错误的故事</a></li>
<li><a href="../zh-CN462951/index.html">人看到形状的地方，人工智能看到纹理的地方</a></li>
<li><a href="../zh-CN462955/index.html">现场人员培训和认证的数字化转型</a></li>
<li><a href="../zh-CN462957/index.html">利弊：.org的价格门槛仍被取消</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>