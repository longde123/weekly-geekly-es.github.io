<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐭 🚯 ➗ Statisch sichere dynamische Eingabe à la Python 🤶🏿 👩🏼‍🤝‍👨🏽 👩🏿‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 


 Neulich entstand in einem meiner Hobbyprojekte die Aufgabe, ein Repository mit Metriken zu schreiben. 


 Die Aufgabe selbst ist sehr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Statisch sichere dynamische Eingabe à la Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457930/"><p>  Hallo Habr. </p><br><p>  Neulich entstand in einem meiner Hobbyprojekte die Aufgabe, ein Repository mit Metriken zu schreiben. </p><br><p>  Die Aufgabe selbst ist sehr einfach gelöst, aber mein Problem mit dem Haskell (insbesondere bei Projekten zu meiner eigenen Unterhaltung) ist, dass es unmöglich ist, das Problem einfach anzunehmen und zu lösen.  Es ist notwendig zu entscheiden, zu erweitern, zu abstrahieren, zu abstrahieren und dann weiter zu erweitern.  Daher wollte ich die Speicherung von Metriken erweiterbar machen, um nicht im Voraus anzugeben, welche dort vorhanden sein würden.  Dies an sich ist ein Thema für einen separaten Artikel, und heute werden wir eine kleine Zutat betrachten: das Schreiben eines typsicheren Wrappers für bisher unbekannte Typen.  So etwas wie dynamisches Tippen, aber mit statischen Garantien, dass wir keinen Unsinn machen. </p><br><p>  Ich denke, der Artikel wird erfahrenen Haskellisten nichts Neues eröffnen, aber jetzt werden wir zumindest diese Zutat aus der Verpackung nehmen und uns in den folgenden Artikeln nicht davon ablenken lassen.  Naja, oder du kannst nicht so bescheiden sein und sagen, dass ich mir schon ein ganzes Designmuster ausgedacht habe. </p><a name="habracut"></a><br><p>  Also formulieren wir zuerst das Problem.  Wir müssen in der Lage sein, einige Objekte mit Werten bisher unbekannter Typen zu verknüpfen.  Mit anderen Worten, es ist erforderlich, dass die Werte zuvor unbekannter Typen als Schlüssel in einer Art Karte fungieren. </p><br><p> Natürlich sind wir nicht verrückt und wir werden keine Unterstützung von Werten jeglicher Art benötigen.  Wir fordern, dass der Typ (auch wenn er unbekannt ist) den Vergleich im Sinne der Bestellung unterstützt.  In Haskell bedeutet dies, dass wir Typen <code>a</code> , die die <code>Ord a</code> Klasse implementieren. </p><br><p>  Beachten Sie, dass wir Unterstützung für die Erstellung eines Hashs und die Überprüfung der Gleichheit verlangen könnten, aber aus einer Reihe von Gründen wäre es bequemer und klarer, uns auf den Vergleich zu beschränken. </p><br><p>  Wenn es darum geht, Werte zu speichern, von denen bekannt ist, dass sie einen Klassentyp implementieren, werden in Haskell normalerweise existenzielle Typen verwendet: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkSomeOrd</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span></span></code> </pre> <br><p>  Wenn wir also ein Objekt vom Typ <code>SomeOrd</code> und dafür einen Mustervergleich durchgeführt haben: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bar</span></span> foo (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val) = ... (<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Dann wissen wir unter Punkt <code>(1)</code> nicht, welchen Typ <code>val</code> hat, aber wir wissen (und vor allem der Timer weiß auch), dass <code>val</code> die <code>Ord</code> Zeitklasse implementiert. </p><br><p>  Wenn die Typfunktionen der Klasse jedoch zwei (oder mehr) Argumente implizieren, ist die Verwendung eines solchen Datensatzes von geringem Nutzen: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tryCompare</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> tryCompare (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val1) (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val2) = ?</code> </pre> <br><p>  Um die <code>Ord</code> Methoden verwenden zu können, müssen <code>val</code> und <code>val2</code> gleichen Typ sein, dies muss jedoch überhaupt nicht erfolgen!  Es stellt sich heraus, dass unser <code>SomeOrd</code> nutzlos ist.  Was tun? </p><br><p>  Trotz der Tatsache, dass Haskell eine kompilierte Sprache mit aggressiver Typlöschung ist (nach der Kompilierung sind sie im Allgemeinen nicht vorhanden), kann der Compiler auf Anfrage immer noch Vertreter von Laufzeittypen generieren.  Die für Typ <code>a</code> repräsentative Rolle ist der Wert von Typ <code>TypeRep a</code> und <del>  Anfrage </del>  Die Generierung wird von Typeable Typeclass beantwortet. </p><br><div class="spoiler">  <b class="spoiler_title">Übrigens</b> <div class="spoiler_text"><p>  <code>a</code> muss übrigens kein Typ im üblichen Sinne sein, das heißt zu einer Sorte gehören <code>*</code> .  Es kann jede andere Art von <code>k</code> , die es Ihnen theoretisch ermöglicht, einige coole Dinge mit dem Speichern von Laufzeitvertretern der gelernten Typen und dergleichen zu tun, aber ich habe nicht herausgefunden, was genau. </p></div></div><br><p>  Wenn wir außerdem zwei verschiedene Instanzen von <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> , können wir sie vergleichen und prüfen, ob sie denselben Typ darstellen oder nicht.  Wenn sie tatsächlich denselben Typ darstellen, stimmt <code>b</code> offensichtlich mit <code>b</code> überein.  Und vor allem liefert die Funktion der Überprüfung von Typdarstellungen auf Gleichheit ein Ergebnis, das den Typcher davon überzeugen kann: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eqTypeRep</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> k1 k2 (a :: k1) (b :: k2). <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (a :~~: b)</code> </pre> <br><p>  Welcher Unsinn steht hier geschrieben? </p><br><p>  Erstens ist <code>eqTypeRep</code> eine Funktion. </p><br><p>  Zweitens ist es polymorph, aber nicht nur nach Typ, sondern auch nach Sorten dieser Typen.  Dies wird durch den Teil für alle <code>forall k1 k2 (a :: k1) (b :: k2)</code> angezeigt - dies bedeutet, dass <code>a</code> und <code>b</code> nicht nur gewöhnliche Typen wie <code>Int</code> oder <code>[String]</code> , sondern auch beispielsweise berüchtigte Konstruktoren (siehe DataKinds und andere Versuche, Haskell zertifizieren zu lassen).  Aber das alles brauchen wir nicht. </p><br><p>  Drittens werden zwei Laufzeitdarstellungen potenziell unterschiedlicher Typen akzeptiert, <code>TypeRep a</code> und <code>TypeRep b</code> . </p><br><p>  Viertens wird ein Wert vom Typ <code>Maybe (a :~~: b)</code> .  Das Interessanteste passiert hier. </p><br><p>  Wenn die Typen nicht übereinstimmen, gibt die Funktion das übliche <code>Nothing</code> und alles ist in Ordnung.  Wenn die Typen übereinstimmen, gibt die Funktion <code>Just val</code> , wobei <code>val</code> vom Typ <code>a :~~: b</code> .  Mal sehen, um welchen Typ es sich handelt: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Kind heterogeneous propositional equality. Like ':~:', @a :~~: b@ is -- inhabited by a terminating value if and only if @a@ is the same type as @b@. -- -- @since 4.10.0.0 data (a :: k1) :~~: (b :: k2) where HRefl :: a :~~: a</span></span></code> </pre> <br><p>  Jetzt lass uns reden.  Angenommen, wir erhalten einen Wert vom Typ <code>a :~~: b</code> .  Wie könnte es gebaut werden?  Der einzige Weg ist mit dem <code>HRefl</code> Konstruktor, und dieser Konstruktor erfordert, dass auf beiden Seiten des Symbols <code>:~~:</code> es dasselbe sein sollte.  Daher fällt a mit <code>b</code> .  Darüber hinaus, wenn wir zapternnom-match auf <code>val</code> , dann wird der taypcheker auch darüber wissen.  Daher gibt die Funktion <code>eqTypeRep</code> Beweis zurück, dass zwei potenziell unterschiedliche Typen gleich sind, wenn sie tatsächlich gleich sind. </p><br><p>  Im obigen Absatz habe ich jedoch gelogen.  Niemand hält uns davon <em>ab, so</em> etwas <em>in Haskell zu schreiben</em> </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = wrong <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre> <br><p>  oder </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = undefined</code> </pre> <br><p>  oder brechen Sie das System mit einer Reihe von etwas weniger offensichtlichen Möglichkeiten.  Dies ist eine der Manifestationen der in engen Kreisen bekannten, dass das Haskell als Logik inkonsistent ist.  In Sprachen mit stärkeren Typsystemen werden solche Definitionen nicht gestempelt. </p><br><p>  Aus diesem Grund wird in der oben zitierten Dokumentation der <em>Endwert</em> erwähnt.  Beide Varianten der Implementierung von <code>wrong</code> oben erzeugen nicht diesen sehr terminierenden Wert, was uns ein wenig Grund und Vertrauen gibt: Wenn unser Programm auf dem Haskell <em>beendet wurde</em> (und nicht <code>undefined</code> ), entspricht sein Ergebnis den geschriebenen Typen.  Hier gibt es jedoch einige Details im Zusammenhang mit Faulheit, aber wir werden dieses Thema nicht öffnen. </p><br><p>  <code>eqTypeRep</code> ist die zweite Manifestation der Haskell-Schwäche im obigen Code der Typ der <code>eqTypeRep</code> Funktion.  In stärkeren Sprachen würde es einen Wert eines stärkeren Typs zurückgeben, der nicht nur die Gleichheit der Typen beweisen würde, wenn sie tatsächlich gleich sind, sondern auch ihre <em>Ungleichheit</em> beweisen würde, wenn sie tatsächlich ungleich sind.  Die Inkonsistenz der Haskell-Logik macht solche Funktionen jedoch ein wenig sinnlos: Es ist alles wichtig, wenn Sie die Sprache als Beweis für Theoreme und nicht als Programmiersprache verwenden und Haskell nicht als Beweis verwenden. </p><br><p>  Na ja, genug von der Log- und Typentheorie, lassen Sie uns zu unseren Metriken zurückkehren. <del>  Jetzt zeichne einfach eine Eule </del>  Die obige Diskussion deutet darauf hin, dass es ausreicht, in unserem existenziellen Typ zu speichern. Dies ist auch die Laufzeitdarstellung des Typs, und alles wird in Ordnung sein. </p><br><p>  Dies führt uns zur folgenden Implementierung unseres Wrapper-Typs: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val</span></span></code> </pre> <br><p>  Jetzt schreiben wir eine Funktion, die Folgendes übernimmt: </p><br><ol><li>  zwei Werte vom Typ <code>Dyn</code> ; </li><li>  eine Funktion, die etwas für zwei Werte eines <em>beliebigen Typs erzeugt</em> , <br>  basierend nur auf den Konstanten, die beim Erstellen von <code>Dyn</code> ( <code>forall</code> ist dafür verantwortlich), <br>  und was aufgerufen wird, wenn beide <code>Dyn</code> Werte des gleichen Typs speichern; </li><li>  und die Fallback-Funktion, die anstelle der vorherigen aufgerufen wird, wenn die Typen noch unterschiedlich sind: </li></ol><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withDyns</span></span> :: (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Ord</span></span> a =&gt; a -&gt; a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; b withDyns f def (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty1 v1) (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty2 v2) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eqTypeRep ty1 ty2 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; def (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty1) (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty2) <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">HRefl</span></span> -&gt; f v1 v2</code> </pre> <br><p>  <code>SomeTypeRep</code> ist ein existenzieller Wrapper über <code>TypeRep a</code> für ein beliebiges <code>a</code> . </p><br><p>  Jetzt können wir zum Beispiel Gleichheitsprüfung und -vergleich implementieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  Hier haben wir die Tatsache <code>SomeTypeRep</code> , dass <code>SomeTypeRep</code> miteinander verglichen werden kann, sodass auch die Fallback-Funktion für die Bestellung <code>compare</code> . </p><br><p>  Fertig. </p><br><p>  Nur jetzt ist es eine Sünde, nicht zu verallgemeinern: Beachten <code>toDyn</code> , <code>withDyns</code> wir in <code>Dyn</code> , <code>toDyn</code> , <code>withDyns</code> <code>Ord</code> speziell verwenden. Dies kann jeder andere Satz von Konstanten sein, sodass wir die <code>ConstraintKinds</code> Erweiterung aktivieren und <em>verallgemeinern können,</em> indem wir <code>Dyn</code> bestimmten Satz von Einschränkungen parametrisieren, die wir verwenden benötigt für unsere spezifische Aufgabe: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: ctx a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val withDyns :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; b withDyns (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">) f def = case eqTypeRep ty1 ty2 of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> -&gt; def (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HRefl</span></span></span><span class="hljs-class"> -&gt; f v1 v2</span></span></code> </pre> <br><p>  Dann ist <code>Dyn Ord</code> unsere Art der <code>Dyn Monoid</code> , und mit <code>Dyn Monoid</code> können Sie beispielsweise beliebige Monoide speichern und mit ihnen etwas Monoidales tun. </p><br><p>  Schreiben wir die Instanzen, die wir für unsere neue <code>Dyn</code> benötigen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  ... nur das funktioniert nicht.  Der Schreibmaschine weiß nicht, dass <code>Dyn Ord</code> auch <code>Eq</code> . <br>  Daher müssen Sie die gesamte Hierarchie kopieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns d1 d2 compare compare</code> </pre> <br><p>  Nun sicher. </p><br><p>  ... vielleicht können Sie es in einem modernen Haskell so gestalten, dass der Timer selbst Instanzen des Formulars anzeigt </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_i</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_1</span></span></span><span class="hljs-class">, ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_n</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  Da dort etwas Prologisches herauskommt, aber ich es noch nicht getan habe, muss ich herum sitzen und es auswählen.  Bleib dran. </p><br><p>  Und wenn Sie vorsichtig blinzeln, können Sie auch sehen, dass unser <code>Dyn</code> verdächtig aussieht wie ein abhängiges Paar vom Typ <code>(ty : Type ** val : ty)</code> aus den kryptischen Sprachen.  Aber nur in mir bekannten Sprachen ist es unmöglich, den Typ zuzuordnen, weil die Parametrizität (die in diesem Fall IMHO zu weit ausgelegt wird), aber hier scheint es möglich. </p><br><p>  Aber das Wichtigste - jetzt können Sie sicher etwas wie <code>Map (Dyn Ord) SomeValue</code> und beliebige Werte als Schlüssel verwenden, solange sie selbst den Vergleich unterstützen.  Beispielsweise können Bezeichner mit Metrikbeschreibungen als Schlüssel verwendet werden. Dies ist jedoch ein Thema für den nächsten Artikel. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457930/">https://habr.com/ru/post/de457930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457910/index.html">WebFPGA - Verilog-Entwicklung im Browser</a></li>
<li><a href="../de457916/index.html">Die Lösung von WorldSkills-Aufgaben des Netzwerkmoduls in der Kompetenz von "CCA". Teil 2 - Grundeinstellung</a></li>
<li><a href="../de457920/index.html">Jet World: Freier freier Zugang zu den Berichten der Konferenz Joker 2018 + Überprüfung der Top Ten</a></li>
<li><a href="../de457926/index.html">Vergleich der agilen Zertifizierung, Teil 1 - ICAgile, Scrum.org, ScrumAlliance und PMI</a></li>
<li><a href="../de457928/index.html">Tiefes Ranking für den Vergleich zweier Bilder</a></li>
<li><a href="../de457932/index.html">Analyse des IDS Bypass-Wettbewerbs an den Positive Hack Days 9</a></li>
<li><a href="../de457936/index.html">Wir laden Sie zur ersten Zabbix-Konferenz in Russland ein</a></li>
<li><a href="../de457940/index.html">Wie man in die Gegenpartei blickt</a></li>
<li><a href="../de457942/index.html">Was ich über Optimierung in Python gelernt habe</a></li>
<li><a href="../de457946/index.html">10 besten JavaScript-Bibliotheken zur Visualisierung von Daten in Grafiken und Diagrammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>