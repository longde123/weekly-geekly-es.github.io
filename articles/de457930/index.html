<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≠ üöØ ‚ûó Statisch sichere dynamische Eingabe √† la Python ü§∂üèø üë©üèº‚Äçü§ù‚Äçüë®üèΩ üë©üèø‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 


 Neulich entstand in einem meiner Hobbyprojekte die Aufgabe, ein Repository mit Metriken zu schreiben. 


 Die Aufgabe selbst ist sehr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Statisch sichere dynamische Eingabe √† la Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457930/"><p>  Hallo Habr. </p><br><p>  Neulich entstand in einem meiner Hobbyprojekte die Aufgabe, ein Repository mit Metriken zu schreiben. </p><br><p>  Die Aufgabe selbst ist sehr einfach gel√∂st, aber mein Problem mit dem Haskell (insbesondere bei Projekten zu meiner eigenen Unterhaltung) ist, dass es unm√∂glich ist, das Problem einfach anzunehmen und zu l√∂sen.  Es ist notwendig zu entscheiden, zu erweitern, zu abstrahieren, zu abstrahieren und dann weiter zu erweitern.  Daher wollte ich die Speicherung von Metriken erweiterbar machen, um nicht im Voraus anzugeben, welche dort vorhanden sein w√ºrden.  Dies an sich ist ein Thema f√ºr einen separaten Artikel, und heute werden wir eine kleine Zutat betrachten: das Schreiben eines typsicheren Wrappers f√ºr bisher unbekannte Typen.  So etwas wie dynamisches Tippen, aber mit statischen Garantien, dass wir keinen Unsinn machen. </p><br><p>  Ich denke, der Artikel wird erfahrenen Haskellisten nichts Neues er√∂ffnen, aber jetzt werden wir zumindest diese Zutat aus der Verpackung nehmen und uns in den folgenden Artikeln nicht davon ablenken lassen.  Naja, oder du kannst nicht so bescheiden sein und sagen, dass ich mir schon ein ganzes Designmuster ausgedacht habe. </p><a name="habracut"></a><br><p>  Also formulieren wir zuerst das Problem.  Wir m√ºssen in der Lage sein, einige Objekte mit Werten bisher unbekannter Typen zu verkn√ºpfen.  Mit anderen Worten, es ist erforderlich, dass die Werte zuvor unbekannter Typen als Schl√ºssel in einer Art Karte fungieren. </p><br><p> Nat√ºrlich sind wir nicht verr√ºckt und wir werden keine Unterst√ºtzung von Werten jeglicher Art ben√∂tigen.  Wir fordern, dass der Typ (auch wenn er unbekannt ist) den Vergleich im Sinne der Bestellung unterst√ºtzt.  In Haskell bedeutet dies, dass wir Typen <code>a</code> , die die <code>Ord a</code> Klasse implementieren. </p><br><p>  Beachten Sie, dass wir Unterst√ºtzung f√ºr die Erstellung eines Hashs und die √úberpr√ºfung der Gleichheit verlangen k√∂nnten, aber aus einer Reihe von Gr√ºnden w√§re es bequemer und klarer, uns auf den Vergleich zu beschr√§nken. </p><br><p>  Wenn es darum geht, Werte zu speichern, von denen bekannt ist, dass sie einen Klassentyp implementieren, werden in Haskell normalerweise existenzielle Typen verwendet: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkSomeOrd</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span></span></code> </pre> <br><p>  Wenn wir also ein Objekt vom Typ <code>SomeOrd</code> und daf√ºr einen Mustervergleich durchgef√ºhrt haben: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bar</span></span> foo (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val) = ... (<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Dann wissen wir unter Punkt <code>(1)</code> nicht, welchen Typ <code>val</code> hat, aber wir wissen (und vor allem der Timer wei√ü auch), dass <code>val</code> die <code>Ord</code> Zeitklasse implementiert. </p><br><p>  Wenn die Typfunktionen der Klasse jedoch zwei (oder mehr) Argumente implizieren, ist die Verwendung eines solchen Datensatzes von geringem Nutzen: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tryCompare</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> tryCompare (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val1) (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val2) = ?</code> </pre> <br><p>  Um die <code>Ord</code> Methoden verwenden zu k√∂nnen, m√ºssen <code>val</code> und <code>val2</code> gleichen Typ sein, dies muss jedoch √ºberhaupt nicht erfolgen!  Es stellt sich heraus, dass unser <code>SomeOrd</code> nutzlos ist.  Was tun? </p><br><p>  Trotz der Tatsache, dass Haskell eine kompilierte Sprache mit aggressiver Typl√∂schung ist (nach der Kompilierung sind sie im Allgemeinen nicht vorhanden), kann der Compiler auf Anfrage immer noch Vertreter von Laufzeittypen generieren.  Die f√ºr Typ <code>a</code> repr√§sentative Rolle ist der Wert von Typ <code>TypeRep a</code> und <del>  Anfrage </del>  Die Generierung wird von Typeable Typeclass beantwortet. </p><br><div class="spoiler">  <b class="spoiler_title">√úbrigens</b> <div class="spoiler_text"><p>  <code>a</code> muss √ºbrigens kein Typ im √ºblichen Sinne sein, das hei√üt zu einer Sorte geh√∂ren <code>*</code> .  Es kann jede andere Art von <code>k</code> , die es Ihnen theoretisch erm√∂glicht, einige coole Dinge mit dem Speichern von Laufzeitvertretern der gelernten Typen und dergleichen zu tun, aber ich habe nicht herausgefunden, was genau. </p></div></div><br><p>  Wenn wir au√üerdem zwei verschiedene Instanzen von <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> , k√∂nnen wir sie vergleichen und pr√ºfen, ob sie denselben Typ darstellen oder nicht.  Wenn sie tats√§chlich denselben Typ darstellen, stimmt <code>b</code> offensichtlich mit <code>b</code> √ºberein.  Und vor allem liefert die Funktion der √úberpr√ºfung von Typdarstellungen auf Gleichheit ein Ergebnis, das den Typcher davon √ºberzeugen kann: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eqTypeRep</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> k1 k2 (a :: k1) (b :: k2). <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (a :~~: b)</code> </pre> <br><p>  Welcher Unsinn steht hier geschrieben? </p><br><p>  Erstens ist <code>eqTypeRep</code> eine Funktion. </p><br><p>  Zweitens ist es polymorph, aber nicht nur nach Typ, sondern auch nach Sorten dieser Typen.  Dies wird durch den Teil f√ºr alle <code>forall k1 k2 (a :: k1) (b :: k2)</code> angezeigt - dies bedeutet, dass <code>a</code> und <code>b</code> nicht nur gew√∂hnliche Typen wie <code>Int</code> oder <code>[String]</code> , sondern auch beispielsweise ber√ºchtigte Konstruktoren (siehe DataKinds und andere Versuche, Haskell zertifizieren zu lassen).  Aber das alles brauchen wir nicht. </p><br><p>  Drittens werden zwei Laufzeitdarstellungen potenziell unterschiedlicher Typen akzeptiert, <code>TypeRep a</code> und <code>TypeRep b</code> . </p><br><p>  Viertens wird ein Wert vom Typ <code>Maybe (a :~~: b)</code> .  Das Interessanteste passiert hier. </p><br><p>  Wenn die Typen nicht √ºbereinstimmen, gibt die Funktion das √ºbliche <code>Nothing</code> und alles ist in Ordnung.  Wenn die Typen √ºbereinstimmen, gibt die Funktion <code>Just val</code> , wobei <code>val</code> vom Typ <code>a :~~: b</code> .  Mal sehen, um welchen Typ es sich handelt: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Kind heterogeneous propositional equality. Like ':~:', @a :~~: b@ is -- inhabited by a terminating value if and only if @a@ is the same type as @b@. -- -- @since 4.10.0.0 data (a :: k1) :~~: (b :: k2) where HRefl :: a :~~: a</span></span></code> </pre> <br><p>  Jetzt lass uns reden.  Angenommen, wir erhalten einen Wert vom Typ <code>a :~~: b</code> .  Wie k√∂nnte es gebaut werden?  Der einzige Weg ist mit dem <code>HRefl</code> Konstruktor, und dieser Konstruktor erfordert, dass auf beiden Seiten des Symbols <code>:~~:</code> es dasselbe sein sollte.  Daher f√§llt a mit <code>b</code> .  Dar√ºber hinaus, wenn wir zapternnom-match auf <code>val</code> , dann wird der taypcheker auch dar√ºber wissen.  Daher gibt die Funktion <code>eqTypeRep</code> Beweis zur√ºck, dass zwei potenziell unterschiedliche Typen gleich sind, wenn sie tats√§chlich gleich sind. </p><br><p>  Im obigen Absatz habe ich jedoch gelogen.  Niemand h√§lt uns davon <em>ab, so</em> etwas <em>in Haskell zu schreiben</em> </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = wrong <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre> <br><p>  oder </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = undefined</code> </pre> <br><p>  oder brechen Sie das System mit einer Reihe von etwas weniger offensichtlichen M√∂glichkeiten.  Dies ist eine der Manifestationen der in engen Kreisen bekannten, dass das Haskell als Logik inkonsistent ist.  In Sprachen mit st√§rkeren Typsystemen werden solche Definitionen nicht gestempelt. </p><br><p>  Aus diesem Grund wird in der oben zitierten Dokumentation der <em>Endwert</em> erw√§hnt.  Beide Varianten der Implementierung von <code>wrong</code> oben erzeugen nicht diesen sehr terminierenden Wert, was uns ein wenig Grund und Vertrauen gibt: Wenn unser Programm auf dem Haskell <em>beendet wurde</em> (und nicht <code>undefined</code> ), entspricht sein Ergebnis den geschriebenen Typen.  Hier gibt es jedoch einige Details im Zusammenhang mit Faulheit, aber wir werden dieses Thema nicht √∂ffnen. </p><br><p>  <code>eqTypeRep</code> ist die zweite Manifestation der Haskell-Schw√§che im obigen Code der Typ der <code>eqTypeRep</code> Funktion.  In st√§rkeren Sprachen w√ºrde es einen Wert eines st√§rkeren Typs zur√ºckgeben, der nicht nur die Gleichheit der Typen beweisen w√ºrde, wenn sie tats√§chlich gleich sind, sondern auch ihre <em>Ungleichheit</em> beweisen w√ºrde, wenn sie tats√§chlich ungleich sind.  Die Inkonsistenz der Haskell-Logik macht solche Funktionen jedoch ein wenig sinnlos: Es ist alles wichtig, wenn Sie die Sprache als Beweis f√ºr Theoreme und nicht als Programmiersprache verwenden und Haskell nicht als Beweis verwenden. </p><br><p>  Na ja, genug von der Log- und Typentheorie, lassen Sie uns zu unseren Metriken zur√ºckkehren. <del>  Jetzt zeichne einfach eine Eule </del>  Die obige Diskussion deutet darauf hin, dass es ausreicht, in unserem existenziellen Typ zu speichern. Dies ist auch die Laufzeitdarstellung des Typs, und alles wird in Ordnung sein. </p><br><p>  Dies f√ºhrt uns zur folgenden Implementierung unseres Wrapper-Typs: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val</span></span></code> </pre> <br><p>  Jetzt schreiben wir eine Funktion, die Folgendes √ºbernimmt: </p><br><ol><li>  zwei Werte vom Typ <code>Dyn</code> ; </li><li>  eine Funktion, die etwas f√ºr zwei Werte eines <em>beliebigen Typs erzeugt</em> , <br>  basierend nur auf den Konstanten, die beim Erstellen von <code>Dyn</code> ( <code>forall</code> ist daf√ºr verantwortlich), <br>  und was aufgerufen wird, wenn beide <code>Dyn</code> Werte des gleichen Typs speichern; </li><li>  und die Fallback-Funktion, die anstelle der vorherigen aufgerufen wird, wenn die Typen noch unterschiedlich sind: </li></ol><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withDyns</span></span> :: (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Ord</span></span> a =&gt; a -&gt; a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; b withDyns f def (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty1 v1) (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty2 v2) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eqTypeRep ty1 ty2 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; def (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty1) (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty2) <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">HRefl</span></span> -&gt; f v1 v2</code> </pre> <br><p>  <code>SomeTypeRep</code> ist ein existenzieller Wrapper √ºber <code>TypeRep a</code> f√ºr ein beliebiges <code>a</code> . </p><br><p>  Jetzt k√∂nnen wir zum Beispiel Gleichheitspr√ºfung und -vergleich implementieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  Hier haben wir die Tatsache <code>SomeTypeRep</code> , dass <code>SomeTypeRep</code> miteinander verglichen werden kann, sodass auch die Fallback-Funktion f√ºr die Bestellung <code>compare</code> . </p><br><p>  Fertig. </p><br><p>  Nur jetzt ist es eine S√ºnde, nicht zu verallgemeinern: Beachten <code>toDyn</code> , <code>withDyns</code> wir in <code>Dyn</code> , <code>toDyn</code> , <code>withDyns</code> <code>Ord</code> speziell verwenden. Dies kann jeder andere Satz von Konstanten sein, sodass wir die <code>ConstraintKinds</code> Erweiterung aktivieren und <em>verallgemeinern k√∂nnen,</em> indem wir <code>Dyn</code> bestimmten Satz von Einschr√§nkungen parametrisieren, die wir verwenden ben√∂tigt f√ºr unsere spezifische Aufgabe: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: ctx a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val withDyns :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; b withDyns (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">) f def = case eqTypeRep ty1 ty2 of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> -&gt; def (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HRefl</span></span></span><span class="hljs-class"> -&gt; f v1 v2</span></span></code> </pre> <br><p>  Dann ist <code>Dyn Ord</code> unsere Art der <code>Dyn Monoid</code> , und mit <code>Dyn Monoid</code> k√∂nnen Sie beispielsweise beliebige Monoide speichern und mit ihnen etwas Monoidales tun. </p><br><p>  Schreiben wir die Instanzen, die wir f√ºr unsere neue <code>Dyn</code> ben√∂tigen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  ... nur das funktioniert nicht.  Der Schreibmaschine wei√ü nicht, dass <code>Dyn Ord</code> auch <code>Eq</code> . <br>  Daher m√ºssen Sie die gesamte Hierarchie kopieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns d1 d2 compare compare</code> </pre> <br><p>  Nun sicher. </p><br><p>  ... vielleicht k√∂nnen Sie es in einem modernen Haskell so gestalten, dass der Timer selbst Instanzen des Formulars anzeigt </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_i</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_1</span></span></span><span class="hljs-class">, ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_n</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  Da dort etwas Prologisches herauskommt, aber ich es noch nicht getan habe, muss ich herum sitzen und es ausw√§hlen.  Bleib dran. </p><br><p>  Und wenn Sie vorsichtig blinzeln, k√∂nnen Sie auch sehen, dass unser <code>Dyn</code> verd√§chtig aussieht wie ein abh√§ngiges Paar vom Typ <code>(ty : Type ** val : ty)</code> aus den kryptischen Sprachen.  Aber nur in mir bekannten Sprachen ist es unm√∂glich, den Typ zuzuordnen, weil die Parametrizit√§t (die in diesem Fall IMHO zu weit ausgelegt wird), aber hier scheint es m√∂glich. </p><br><p>  Aber das Wichtigste - jetzt k√∂nnen Sie sicher etwas wie <code>Map (Dyn Ord) SomeValue</code> und beliebige Werte als Schl√ºssel verwenden, solange sie selbst den Vergleich unterst√ºtzen.  Beispielsweise k√∂nnen Bezeichner mit Metrikbeschreibungen als Schl√ºssel verwendet werden. Dies ist jedoch ein Thema f√ºr den n√§chsten Artikel. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457930/">https://habr.com/ru/post/de457930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457910/index.html">WebFPGA - Verilog-Entwicklung im Browser</a></li>
<li><a href="../de457916/index.html">Die L√∂sung von WorldSkills-Aufgaben des Netzwerkmoduls in der Kompetenz von "CCA". Teil 2 - Grundeinstellung</a></li>
<li><a href="../de457920/index.html">Jet World: Freier freier Zugang zu den Berichten der Konferenz Joker 2018 + √úberpr√ºfung der Top Ten</a></li>
<li><a href="../de457926/index.html">Vergleich der agilen Zertifizierung, Teil 1 - ICAgile, Scrum.org, ScrumAlliance und PMI</a></li>
<li><a href="../de457928/index.html">Tiefes Ranking f√ºr den Vergleich zweier Bilder</a></li>
<li><a href="../de457932/index.html">Analyse des IDS Bypass-Wettbewerbs an den Positive Hack Days 9</a></li>
<li><a href="../de457936/index.html">Wir laden Sie zur ersten Zabbix-Konferenz in Russland ein</a></li>
<li><a href="../de457940/index.html">Wie man in die Gegenpartei blickt</a></li>
<li><a href="../de457942/index.html">Was ich √ºber Optimierung in Python gelernt habe</a></li>
<li><a href="../de457946/index.html">10 besten JavaScript-Bibliotheken zur Visualisierung von Daten in Grafiken und Diagrammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>