<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖ∞Ô∏è ü•í üßôüèΩ Buat penembak zombie orang ketiga dengan DOTS üõÑ üßîüèæ üêÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salute, Khabrovsk. Seperti yang sudah kami tulis, Januari kaya akan peluncuran baru dan hari ini kami mengumumkan satu set untuk kursus baru dari OTUS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat penembak zombie orang ketiga dengan DOTS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/484094/">  <i>Salute, Khabrovsk.</i>  <i>Seperti yang sudah kami tulis, Januari kaya akan peluncuran baru dan hari ini kami mengumumkan satu set untuk kursus baru dari OTUS - <a href="https://otus.pw/YRoY/">"Pengembang Game untuk Persatuan"</a> .</i>  <i>Untuk mengantisipasi dimulainya kursus, kami membagikan terjemahan materi yang menarik kepada Anda.</i> <i><br></i> <br><img src="https://habrastorage.org/webt/o-/2d/iz/o-2diz_bo0cjb7cksohmc8zeoxc.png"><br><br><hr><blockquote>  Kami sedang membangun kembali inti Persatuan dengan <a href="https://unity.com/dots%3F_ga%3D2.241875339.889742683.1579017753-927430519.1579017753">Stack Tech Berorientasi Data</a> kami.  Seperti banyak studio game, kami juga melihat keuntungan besar dalam menggunakan Entity Component System (ECS), C # Task System (C # Job System) dan Burst Compiler.  Di Unite Copenhagen, kami berkesempatan untuk mengobrol dengan Far North Entertainment dan mempelajari bagaimana mereka menerapkan fungsi DOTS ini dalam proyek-proyek tradisional Unity. </blockquote><a name="habracut"></a>  Far North Entertainment adalah studio Swedia yang dimiliki bersama oleh lima teman teknik.  Sejak merilis Down to Dungeon untuk Gear VR pada awal 2018, perusahaan telah mengerjakan sebuah game yang termasuk genre klasik game PC, yaitu game pasca-apokaliptik dalam mode bertahan zombie.  Apa yang membedakan proyek ini dari yang lain adalah jumlah zombie yang mengejar Anda.  Visi tim dalam hal ini menarik ribuan zombie lapar mengikuti Anda dalam gerombolan besar. <br><br>  Namun, mereka dengan cepat mengalami banyak masalah kinerja yang sudah pada tahap prototyping.  Menciptakan, mati, memperbarui, dan menjiwai semua jumlah musuh ini tetap menjadi hambatan utama, bahkan setelah tim mencoba untuk menyelesaikan masalah dengan <i>penyatuan pooling</i> dan <i>insting nimation</i> . <br><br>  Ini memaksa direktur teknis studio Andres Ericsson untuk mengalihkan perhatiannya ke DOTS dan mengubah pola pikir dari berorientasi objek menjadi berorientasi data.  "Gagasan utama yang membantu membawa perubahan ini adalah bahwa Anda harus berhenti memikirkan objek dan hierarki objek dan mulai berpikir tentang data, bagaimana transformasi, dan bagaimana mengaksesnya," katanya .  Kata-katanya berarti bahwa tidak perlu membangun arsitektur kode dengan memperhatikan objek kehidupan nyata sedemikian rupa sehingga memecahkan masalah yang paling umum dan abstrak.  Dia memiliki banyak tip untuk mereka yang, seperti dia, dihadapkan dengan perubahan pandangan dunia: <br><br>  <i>‚ÄúTanyakan pada diri Anda apa masalah sebenarnya yang Anda coba selesaikan, dan data apa yang penting untuk mendapatkan solusi.</i>  <i>Apakah Anda akan mengonversi data yang sama dengan cara yang sama berulang kali?</i>  <i>Berapa banyak data berguna yang dapat Anda masukkan dalam satu baris cache prosesor?</i>  <i>Jika Anda membuat perubahan pada kode yang ada, evaluasi berapa banyak data sampah yang Anda tambahkan ke baris cache.</i>  <i>Apakah mungkin untuk membagi perhitungan menjadi beberapa utas atau apakah saya perlu menggunakan aliran perintah tunggal?</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QGM4feh0fRA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Tim mulai memahami bahwa entitas dalam Sistem Komponen Persatuan hanyalah pengidentifikasi pencarian di aliran komponen.  Komponen hanyalah data, sementara sistem mengandung semua logika dan menyaring entitas dengan tanda tangan tertentu, yang dikenal sebagai arketipe.  ‚ÄúSaya pikir salah satu wawasan yang membantu kami memvisualisasikan ide-ide kami adalah memperkenalkan ECS sebagai database SQL.  Setiap arketipe adalah tabel di mana setiap kolom adalah komponen, dan setiap baris adalah entitas yang unik.  Intinya, Anda menggunakan sistem untuk membuat kueri untuk tabel pola dasar ini dan melakukan operasi pada entitas, ‚Äùkata Anders. <br><br><h3>  Memperkenalkan DOTS </h3><br>  Untuk mencapai pemahaman ini, ia mempelajari dokumentasi untuk sistem <a href="https://docs.unity3d.com/Packages/com.unity.entities%400.1/manual/index.html%3F_ga%3D2.233150103.889742683.1579017753-927430519.1579017753">Entity Component</a> , contoh <a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">ECS</a> , dan <a href="https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation">contoh</a> yang kami lakukan bersama dengan Nordeus dan disajikan di Unite Austin.  Informasi umum tentang arsitektur berorientasi data juga sangat membantu tim.  " <a href="https://www.youtube.com/watch%3Fv%3DrX0ItVEVjHc">Laporan Mike Acton</a> tentang arsitektur data-sentris dengan CppCon 2014 adalah apa yang pertama kali membuka mata kita pada cara pemrograman ini." <br><br>  Tim Far North menerbitkan apa yang mereka pelajari di <a href="http://www.farnorthentertainment.com/2019/04/10/what-we-have-been-up-to-why-ecs-is-the-way-to-gigantic-hordes/">Blog Dev</a> mereka, pada bulan September tahun ini mereka datang ke Kopenhagen untuk berbagi pengalaman mereka dengan transisi ke pendekatan berorientasi data di Unity. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yTGhg905SCs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Artikel ini didasarkan pada laporan, yang menjelaskan secara lebih rinci rincian penerapan ECS, Sistem Tugas C # dan kompiler Burst.  Far North juga dengan ramah membagikan banyak contoh kode dari proyek mereka. <br><br><h3>  Organisasi Data Zombie </h3><br>  "Masalah yang kami hadapi adalah menginterpolasi perpindahan dan rotasi untuk ribuan objek di sisi klien," kata Anders.  Pendekatan berorientasi objek awal mereka adalah untuk membuat skrip <i>ZombieView</i> abstrak yang mewarisi kelas induk <i>EntityView</i> generik.  <i>EntityView</i> adalah <i>MonoBehaviour yang</i> dilampirkan ke <i>GameObject</i> .  Karena berfungsi sebagai representasi visual dari model game.  Setiap <i>ZombieView</i> bertanggung jawab untuk menangani pergerakan dan interpolasi rotasi sendiri dalam fungsi <i>Pembaruannya</i> . <br><br>  Ini kedengarannya normal, sampai Anda memahami bahwa setiap entitas berada dalam memori di tempat yang sewenang-wenang.  Ini berarti bahwa jika Anda mengakses ribuan objek, CPU harus mengeluarkannya satu per satu, dan ini terjadi sangat lambat.  Jika Anda meletakkan data Anda dalam blok-blok rapi yang disusun secara seri, prosesor dapat men-cache sejumlah besar data secara bersamaan.  Sebagian besar prosesor modern dapat menerima sekitar 128 atau 256 bit dari cache dalam satu siklus. <br><br>  Tim memutuskan untuk mengubah musuh menjadi DOTS dengan harapan menyelesaikan masalah kinerja sisi klien.  Baris pertama adalah fungsi <i>Pembaruan</i> di <i>ZombieView</i> .  Tim menentukan bagian mana yang harus dibagi ke dalam sistem yang berbeda dan menentukan data yang diperlukan.  Hal pertama dan paling jelas adalah interpolasi posisi dan belokan, karena dunia game adalah kisi dua dimensi.  Dua variabel float bertanggung jawab atas ke mana zombie pergi, dan komponen terakhir adalah posisi target, ia melacak posisi server untuk musuh. <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> PositionData2D : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 Position; } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HeadingData2D : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 Heading; } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TargetPositionData : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 TargetPosition; }</code> </pre> <br>  Langkah selanjutnya adalah membuat pola dasar untuk musuh.  Pola dasar adalah seperangkat komponen yang dimiliki entitas tertentu, dengan kata lain, itu adalah tanda tangan komponen. <br><br>  Proyek ini menggunakan prefab untuk menentukan arketipe, karena musuh memerlukan lebih banyak komponen, dan beberapa dari mereka memerlukan tautan ke <i>GameObject</i> .  Ini berfungsi agar Anda bisa membungkus data komponen Anda di <i>ComponentDataProxy</i> , yang akan mengubahnya menjadi <i>MonoBehaviour</i> , yang pada gilirannya dapat dilampirkan ke cetakan.  Saat Anda membuat sebuah instance menggunakan <i>EntityManager</i> dan meneruskan prefab, itu membuat entitas dengan semua data komponen yang dilampirkan ke cetakan.  Semua data komponen disimpan dalam potongan memori 16 kilobyte yang disebut <i>ArchetypeChunk</i> . <br><br>  Berikut adalah visualisasi tentang bagaimana aliran komponen akan diatur dalam potongan pola dasar kami: <br><br><img src="https://habrastorage.org/webt/mh/cn/r9/mhcnr9qjgpsr6lkej2l0ezq0jmi.png"><br><br>  <i>‚ÄúSalah satu keuntungan utama dari pola dasar potongan adalah Anda tidak perlu sering mengalokasikan banyak ketika membuat objek baru, karena memori telah dialokasikan sebelumnya.</i>  <i>Ini berarti bahwa membuat entitas adalah menulis data ke akhir aliran komponen di dalam potongan pola dasar.</i>  <i>Satu-satunya kasus ketika perlu untuk melakukan alokasi tumpukan lagi adalah ketika membuat entitas yang tidak sesuai dengan batas-batas potongan.</i>  <i>Dalam hal ini, baik alokasi potongan baru dari pola dasar 16 KB dalam ukuran akan dimulai, atau jika ada fragmen kosong dari pola dasar yang sama, dapat digunakan kembali.</i>  <i>Kemudian data untuk objek baru akan direkam dalam aliran komponen chunk baru, ‚Äù</i> jelas Anders. <br><br><h3>  Multithreading zombie Anda </h3><br>  Sekarang setelah data dikemas dan ditempatkan dalam memori dengan cara yang mudah untuk caching, tim dapat dengan mudah menggunakan sistem tugas C # untuk menjalankan kode pada beberapa core CPU secara paralel. <br><br>  Langkah selanjutnya adalah membuat sistem yang memfilter semua entitas dari semua blok pola dasar yang memiliki <i>komponen</i> <i>PositionData2D</i> , <i>HeadingData2D,</i> dan <i>TargetPositionData</i> . <br><br>  Untuk melakukan ini, Anders dan timnya menciptakan <i>JobComponentSystem</i> dan membangun permintaan mereka dalam fungsi <i>OnCreate</i> .  Itu terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EntityQuery m_Group; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCreate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnCreate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntityQueryDesc { All = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { ComponentType.ReadWrite&lt;PositionData2D&gt;(), ComponentType.ReadWrite&lt;HeadingData2D&gt;(), ComponentType.ReadOnly&lt;TargetPositionData&gt;() }, }; m_Group = GetEntityQuery(query); }</code> </pre> <br>  Kode mengumumkan permintaan yang memfilter semua objek di dunia yang memiliki posisi, arah, dan tujuan.  Selanjutnya, mereka ingin menjadwalkan tugas untuk setiap frame menggunakan sistem tugas C # untuk mendistribusikan perhitungan di beberapa alur kerja. <br><br>  <i>‚ÄúHal paling keren tentang sistem tugas C # adalah bahwa itu adalah sistem yang sama yang digunakan Unity dalam kodenya, jadi kami tidak perlu khawatir tentang thread yang dapat dieksekusi memblokir satu sama lain, membutuhkan inti prosesor yang sama dan menyebabkan masalah kinerja . ‚Äù</i> Ucap Anders. <br><br>  Tim memutuskan untuk menggunakan <i>IJobChunk</i> , karena ribuan musuh menyiratkan adanya sejumlah besar potongan pola dasar yang harus sesuai dengan permintaan saat runtime.  <i>IJobChunk</i> mendistribusikan potongan yang benar di berbagai alur kerja. <br><br>  Setiap frame, tugas <i>UpdatePositionAndHeadingJob</i> baru <i>,</i> bertanggung jawab untuk menangani interpolasi posisi dan putaran musuh dalam permainan. <br><br>  Kode untuk tugas penjadwalan adalah sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> JobHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JobHandle inputDeps</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> positionDataType = GetArchetypeChunkComponentType&lt;PositionData2D&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headingDataType = GetArchetypeChunkComponentType&lt;HeadingData2D&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetPositionDataType = GetArchetypeChunkComponentType&lt;TargetPositionData&gt;(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updatePosAndHeadingJob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UpdatePositionAndHeadingJob { PositionDataType = positionDataType, HeadingDataType = headingDataType, TargetPositionDataType = targetPositionDataType, DeltaTime = Time.deltaTime, RotationLerpSpeed = <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, MovementLerpSpeed = <span class="hljs-number"><span class="hljs-number">4.0f</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updatePosAndHeadingJob.Schedule(m_Group, inputDeps); }</code> </pre> <br>  Seperti inilah tugasnya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> UpdatePositionAndHeadingJob : IJobChunk { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;PositionData2D&gt; PositionDataType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;HeadingData2D&gt; HeadingDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;TargetPositionData&gt; TargetPositionDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RotationLerpSpeed; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MovementLerpSpeed; }</code> </pre> <br>  Ketika pekerja thread mengambil tugas dari antriannya, itu memanggil inti dari tugas. <br><br>  Begini inti eksekusi: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArchetypeChunk chunk, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstEntityIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkPositionData = chunk.GetNativeArray(PositionDataType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkHeadingData = chunk.GetNativeArray(HeadingDataType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkTargetPositionData = chunk.GetNativeArray(TargetPositionDataType); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunk.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = chunkTargetPositionData[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> positionData = chunkPositionData[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headingData = chunkHeadingData[i]; float2 toTarget = target.TargetPosition - positionData.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = math.length(toTarget); headingData.Heading = math.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>( headingData.Heading, math.lerp(headingData.Heading, math.normalize(toTarget), math.mul(DeltaTime, RotationLerpSpeed)), distance &gt; <span class="hljs-number"><span class="hljs-number">0.008</span></span> ); positionData.Position = math.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>( target.TargetPosition, math.lerp( positionData.Position, target.TargetPosition, math.mul(DeltaTime, MovementLerpSpeed)), distance &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ); chunkPositionData[i] = positionData; chunkHeadingData[i] = headingData; } }</code> </pre><br>  <i>‚ÄúAnda mungkin memperhatikan bahwa kami menggunakan pilih daripada bercabang, ini memungkinkan kami untuk menyingkirkan efek yang disebut prediksi cabang salah.</i>  <i>Fungsi pilih akan mengevaluasi kedua ekspresi dan memilih yang sesuai dengan kondisi, dan jika ekspresi Anda tidak begitu sulit untuk dihitung, saya akan merekomendasikan menggunakan pilih, karena seringkali lebih murah daripada menunggu CPU pulih dari prediksi cabang yang salah. "</i> Anders. <br><br><h3>  Tingkatkan Produktivitas dengan Burst </h3><br>  Langkah terakhir dalam mengubah DOTS ke posisi musuh dan interpolasi saja adalah untuk mengaktifkan kompiler Burst.  Tugas itu tampaknya cukup sederhana untuk Anders: "Karena data terletak di array yang berdekatan dan karena kami menggunakan perpustakaan matematika baru dari Unity, yang harus kami lakukan adalah menambahkan atribut <i>BurstCompile</i> ke tugas kami." <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">BurstCompile</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> UpdatePositionAndHeadingJob : IJobChunk { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;PositionData2D&gt; PositionDataType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;HeadingData2D&gt; HeadingDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;TargetPositionData&gt; TargetPositionDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RotationLerpSpeed; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MovementLerpSpeed; }</code> </pre><br>  Compiler Burst memberi kita Single Instruction Multiple Data (SIMD);  instruksi mesin yang dapat bekerja dengan beberapa set data input dan membuat beberapa set data output hanya dengan satu instruksi.  Ini membantu kami mengisi lebih banyak tempat di bus cache 128-bit dengan data yang benar.  Kompiler Burst, dikombinasikan dengan komposisi data yang ramah terhadap cache dan sistem pekerjaan, memungkinkan tim untuk meningkatkan produktivitas secara signifikan.  Ini adalah tabel yang mereka kompilasi dengan mengukur kinerja setelah setiap langkah konversi. <br><br><img src="https://habrastorage.org/webt/bo/gu/8i/bogu8ir1i0apb5cwuhrjfjyk-bk.png"><br><br>  Ini berarti bahwa Far North sepenuhnya menyingkirkan masalah yang terkait dengan interpolasi posisi di sisi klien dan arah zombie.  Data mereka sekarang disimpan dalam bentuk yang nyaman untuk caching, dan garis cache hanya diisi dengan data yang berguna.  Beban didistribusikan ke semua core CPU, dan Burst compiler menghasilkan kode mesin yang sangat optimal dengan instruksi SIMD. <br><br><h4>  Far North Entertainment DOTS Tip dan Trik </h4><br><ul><li>  Mulai berpikir dalam hal aliran data, karena dalam ECS, entitas hanyalah indeks pencarian dalam aliran data komponen paralel. </li><li>  Bayangkan ECS sebagai basis data relasional di mana arketipe adalah tabel, komponen adalah kolom, dan entitas adalah indeks dalam tabel (baris). </li><li>  Atur data Anda menjadi array berurutan untuk menggunakan cache prosesor dan prefetch perangkat keras. </li><li>  Lupakan keinginan untuk membuat hierarki objek dan mencoba menemukan solusi bersama sebelum memahami masalah sebenarnya yang ingin Anda pecahkan. </li><li>  Pikirkan tentang pengumpulan sampah.  Hindari tumpukan yang terlalu banyak di area yang kritis terhadap kinerja.  Gunakan wadah asli Unity baru sebagai gantinya.  Tapi hati-hati, Anda harus berurusan dengan pembersihan manual. </li><li>  Ketahuilah nilai abstraksi Anda, waspadalah terhadap overhead dalam menjalankan fungsi virtual. </li><li>  Gunakan semua core CPU dengan sistem tugas C #. </li><li>  Menganalisis tingkat perangkat keras.  Apakah kompiler Burst benar-benar menghasilkan instruksi SIMD?  Gunakan Burst Inspector untuk analisis. </li><li>  Berhenti membuang-buang baris cache kosong.  Pikirkan pengemasan data ke dalam garis cache sebagai pengemasan data ke dalam paket UDP. </li></ul><br>  Saran utama yang ingin dibagikan Anders Ericsson adalah saran yang lebih umum untuk mereka yang proyeknya sedang dalam pengembangan: <i>‚ÄúCobalah untuk mengidentifikasi area spesifik dalam permainan Anda di mana Anda memiliki masalah kinerja dan lihat apakah Anda dapat menerapkan DOTS secara khusus di daerah terpencil ini.</i>  <i>Anda tidak perlu mengubah seluruh basis kode! "</i> <br><br><h3>  Rencana masa depan </h3><br>  ‚ÄúKami ingin menggunakan DOTS di area lain dari permainan kami, dan kami senang dengan pengumuman di Unite tentang animasi DOTS, Fisika Persatuan, dan Live Link.  Kami ingin mempelajari cara mengubah lebih banyak objek game menjadi objek ECS, dan tampaknya Unity telah membuat kemajuan signifikan dalam mengimplementasikan ini, ‚Äùsimpul Anders. <br><br>  Jika Anda memiliki pertanyaan tambahan untuk tim Far North, kami sarankan Anda bergabung dengan <a href="https://discord.gg/jXJyxUh">Perselisihan</a> mereka! <br>  Lihat daftar putar <a href="https://www.youtube.com/playlist%3Flist%3DPLX2vGYjWbI0S1wHRTyDiPtKLEPTWFi4cd">Unite Copenhagen DOTS</a> untuk mengetahui bagaimana studio game modern lainnya menggunakan DOTS untuk membuat game berkinerja tinggi yang hebat, dan bagaimana komponen berbasis DOTS seperti Fisika DOTS, Alur Kerja Konversi yang baru, dan kompiler Burst bekerja bersama. <br><br>  Terjemahan telah berakhir, dan kami <b>mengundang Anda untuk menghadiri <a href="https://otus.pw/YRoY/">webinar gratis</a> , di mana kami <i>akan memberi tahu Anda cara membuat penembak zombie Anda sendiri dalam satu jam</i> .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484094/">https://habr.com/ru/post/id484094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484076/index.html">Tempat menyimpan cryptocurrency: perpajakan cryptocurrency di berbagai negara</a></li>
<li><a href="../id484084/index.html">1C-Bitrix dan upaya untuk memperkenalkannya</a></li>
<li><a href="../id484088/index.html">Kata sandi hit parade (analisis ~ 5 miliar kata sandi dari kebocoran)</a></li>
<li><a href="../id484090/index.html">Infrastruktur TI baru untuk Pusat Data Pos Rusia</a></li>
<li><a href="../id484092/index.html">Agak berpakaian pangeran dan bangsawan</a></li>
<li><a href="../id484096/index.html">Pertempuran dua Yakozun, atau Cassandra vs HBase. Pengalaman tim Sberbank</a></li>
<li><a href="../id484100/index.html">Bekerja dengan antarmuka di Google Maps SDK untuk Android</a></li>
<li><a href="../id484102/index.html">PHP vs Python vs Ruby on Rails: Perbandingan Lengkap</a></li>
<li><a href="../id484106/index.html">MVCC di PostgreSQL-6. Vakum</a></li>
<li><a href="../id484108/index.html">Etherblade.net Encapsulator dan Substitusi Impor untuk Komponen Jaringan (Bagian Dua)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>