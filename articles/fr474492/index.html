<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘 🏗️ 💾 Réagissez au chat multi-utilisateurs avec le backend Chatix 🍈 🎬 👩🏼‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je vais maintenant vous montrer comment créer un chat pour l'équipe / utilisateurs / amis si vous n'avez pas votre backend ou si vous ne voulez pas pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Réagissez au chat multi-utilisateurs avec le backend Chatix</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474492/"><p><img src="https://habrastorage.org/getpro/habr/post_images/d7e/212/ac4/d7e212ac471c99b0cd61dd0e75aab281.png" alt="Salon de discussion chatix"></p><br><p>  Je vais maintenant vous montrer comment créer un chat pour l'équipe / utilisateurs / amis si vous n'avez pas votre backend ou si vous ne voulez pas passer du temps à le développer.  Nous ferons un simple chat textuel et cela nous prendra environ une heure. </p><br><p> Pour écrire un chat réseau fonctionnel sans backend est presque impossible, il doit être sous une forme ou une autre.  Nous utiliserons Chatix et son SDK JavaScript.  Chatix et SDK seront engagés dans le stockage des messages et les tâches réseau, et nous nous occuperons du front-end. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le code du projet terminé est disponible sur GitHub</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Démo</a> </p><a name="habracut"></a><br><h2 id="struktura-proekta">  Structure du projet </h2><br><ul><li>  App (le composant racine de l'application, agit en tant que dépositaire d'État, car dans cette leçon, nous n'ajouterons ni Redux ni aucun autre gestionnaire d'État) <br><ul><li>  En-tête (l'en-tête de notre application qui affiche le logo, le nom du chat et permet à l'utilisateur d'écrire son nom) </li><li>  LogoHeader </li><li>  Titre de la pièce </li><li>  Principal </li><li>  MemberList (liste de chat) <br><ul><li>  MemberItem [] </li></ul></li><li>  ChatField (un conteneur pour tout ce qui concerne les messages de chat) <br><ul><li>  Messagecontainer </li><li>  Message [] (présentation du message; dans cette leçon, nous ne travaillerons qu'avec des messages texte) </li><li>  SendMessageForm (formulaire pour envoyer un nouveau message de chat) </li></ul></li><li>  ChatixSDK (composant sans tête chargé de travailler avec le backend) </li></ul></li></ul><br><blockquote> Remarque importante sur le stockage d'état.  Bien sûr, il serait plus pratique d'ajouter Redux ici et de traiter les changements d'état, mais pour gagner du temps, nous stockons l'état dans le composant racine de l'application et transmettons les données aux composants enfants et appelons leurs parents à partir des méthodes enfants. <br>  Par exemple, lorsque nous aurons le nom du chat, nous l'enregistrerons dans l'état du composant App et le passerons par les <code>props</code> : <code>App → Header → RoomTitle</code> .  Lorsque l'utilisateur écrit un message, nous le transférons de SendMessageForm vers l'application: <code>SendMessageForm → ChatField → Main → App</code> . </blockquote><p>  Notre chat ressemblera à ceci dans la conception: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d1e/096/b73/d1e096b7349824c510542cc215ae437e.png" alt="chatix.io"></p><br><h2 id="vzaimodeystvie-mezhdu-komponentami">  Interaction entre les composants </h2><br><p>  Nos composants doivent se transmettre des données et pour que tout fonctionne comme il se doit, déterminons maintenant comment ils vont interagir les uns avec les autres. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fde/009/821/fde0098218938f714d32a58ad9776ec9.png" alt="Interaction des composants"></p><br><p>  Comme vous pouvez le voir sur la figure, le composant principal pour nous est l' <code>App</code> , qui fournit des données aux composants enfants (en raison de la réactivité, nous attribuons simplement <code>prop</code> et le composant enfant répondra aux changements), et les composants enfants transmettent successivement des appels de méthode à l' <code>App</code> .  Ce n'est pas la meilleure architecture qui puisse (et devrait) être faite pour un projet de production, mais elle fera l'affaire pour notre leçon. </p><br><h2 id="sozdanie-proekta">  Création de projet </h2><br><h3 id="sozdaem-vizualnye-komponenty">  Créer des composants visuels </h3><br><h4 id="shapka">  Chapeau </h4><br><ol><li><p>  Vous devez d'abord créer un nouveau projet, pour cela, nous utiliserons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">create-react-app</a> . </p><br><pre> <code class="plaintext hljs">npx create-react-app chatix-chatroom cd chatix-chatroom</code> </pre> <br><p>  Exécutez le projet avec la commande </p><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br></li><li><p>  Commençons par créer un en-tête. <br>  Tout d'abord, ajoutez un logo à l'en-tête.  Pour ce faire, dans le dossier src, créez le dossier des <strong>composants</strong> et dans celui-ci le dossier <strong>logo_header</strong> .  Nous téléchargeons le logo dans ce dossier et créons 2 <strong>fichiers</strong> <strong>LogoHeader.js</strong> et <strong>LogoHeader.css</strong> </p><br></li></ol><br><p>  <strong>LogoHeader.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react' import logo from './chatix_logo.svg'; import './LogoHeader.css'; function LogoHeader(){ return ( &lt;div className="LogoHeader"&gt; &lt;img src={logo} className="App-logo" alt="Chatix logo" /&gt; &lt;/div&gt; ); } export default LogoHeader;</code> </pre> <br><p>  <strong>LogoHeader.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.LogoHeader</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-number"><span class="hljs-number">200px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Tout est clair ici, dans ce composant un fichier avec un logo et des styles est simplement importé. </p><br><p>  Je n'ajouterai plus le code des feuilles de style ici, vous pouvez les voir sur la page du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet terminé</a> </p><br><p>  Affichez maintenant le nom du salon de discussion.  Pour ce faire, créez un dossier de <strong>titre de pièce</strong> et le composant <strong>RoomTitle</strong> .  Nous allons jeter le nom dans ce composant via des accessoires, nous écrivons donc <code>props.chatroomName</code> et maintenant nous allons le transférer ici. </p><br><p>  <strong>Titre de la pièce</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './RoomTitle.css'; function RoomTitle(props){ return ( &lt;div className="RoomTitle"&gt; &lt;h1&gt;{props.chatroomName}&lt;/h1&gt; &lt;/div&gt; ); } export default RoomTitle;</code> </pre> <br><p>  Ensuite, nous créons le composant d'en-tête lui-même et y plaçons le logo et le nom de la salle de chat.  Jetez immédiatement le nom du chat dans le composant enfant via prop <code>chatroomName</code> . </p><br><p>  Je vous rappelle que nous avons convenu que toutes les données (état de l'application) seront stockées par le composant racine de l' <strong>application</strong> .  De là, nous transférerons d'abord l'en- <strong>tête</strong> vers <strong>Header</strong> et de <strong>Header</strong> vers <strong>RoomTitle</strong> . </p><br><p>  <strong>composants \ header \ Header.js</strong> </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './Header.css' import LogoHeader from '../logo_header/LogoHeader'; import RoomTitle from '../room-title/RoomTitle'; function Header(props) { return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName} /&gt; &lt;/header&gt; ); } export default Header;</code> </pre> <br><p>  Ensuite, ouvrez le fichier <strong>App.js</strong> et ajoutez-y le composant <strong>Header.js</strong> . <br>  Ensuite, nous ajoutons le nom à l' <strong>état et le</strong> transmettons à l'en- <strong>tête</strong> via des <strong>accessoires</strong> . <br>  Dans l'en-tête, vous devez également ajouter le nom de l'utilisateur actuel.  Pour ce faire, ajoutez l'objet utilisateur à l'état et transférez-le de la même manière à l'en-tête </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './App.css'; import Header from './components/header/Header'; class App extends React.Component { constructor(props){ super(props); chatroomName: '-', me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;/div&gt; ); }; } export default App;</code> </pre> <br><p>  Maintenant, dans l'en-tête, vous devez ajouter une entrée avec le nom de l'utilisateur actuel et affecter le gestionnaire à modifier afin que nous puissions transférer le nouveau nom d'utilisateur vers le composant <strong>App</strong> . </p><br><p>  Pour cela, nous ajoutons la fonction <code>handleChangeName</code> <code>props.updateVisitor</code> à l'entrée avec le nom et appelons la fonction de rappel <code>props.updateVisitor</code> dans laquelle nous transmettons l'objet utilisateur avec le nom mis à jour. </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">function Header(props) { const [name, setName] = useState(props.me.name ? props.me.name : props.me.uuid.substr(-10)) const handleChangeName = (e) =&gt; { setName(e.target.value) let visitor = {...props.me}; visitor.name = e.target.value; props.updateVisitor(visitor) } return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName}/&gt; { props.me ? &lt;input className='name-input' value={name} placeholder=' ' onChange={(e) =&gt; handleChangeName(e)} /&gt; : null } &lt;/header&gt; ); }</code> </pre> <br><p>  Ajoutez maintenant cette fonction <code>props.updateVisitor</code> à l' <strong>application</strong> et <code>props.updateVisitor</code> -la à l'en- <code>props.updateVisitor</code> .  Jusqu'à présent, il met simplement à jour l'objet utilisateur dans l'état, mais ensuite, nous mettrons à jour l'utilisateur sur le serveur. </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (visitor) =&gt; { this.setState({me: visitor}) }</code> </pre> <br><p>  Donc, maintenant, notre application ressemble à ceci et ne sait pour l'instant que mettre à jour le nom.  Continuez </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/685/7ec/243/6857ec2435f476e8d6dad5201d7909a5.png" alt="En-tête de chat"></p><br><h4 id="saydbar">  Barre latérale </h4><br><p>  Passons maintenant à la création d'une barre latérale. <br>  La barre latérale sera située à l'intérieur du composant principal sur la page <strong>Main.js.</strong> <br>  Nous le créons <strong>components \ main \ Main.js</strong> , puis créons un composant avec une liste d'utilisateurs <strong>components \ member-list \ MemberList.js</strong> et créons immédiatement un composant qui affichera les utilisateurs eux-mêmes <strong>components \ member-item \ MemberItem.js</strong> . </p><br><p>  Pour clarifier la relation entre ces 3 composants, jetez un œil au plan du projet au début de l'article. </p><br><p>  Les composants sont créés, maintenant allons-y dans l'ordre. <br>  Tout d'abord, ajoutez le tableau d'utilisateurs à l'état du composant <strong>App</strong> et ajoutez le composant <strong>Main</strong> .  Ensuite, nous transmettrons ces utilisateurs dedans. </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">class App extends React.Component { constructor(props) { super(props); this.state = { chatroomName: '-', members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } }; } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;Main members={this.state.members} me={this.state.me} /&gt; &lt;/div&gt; ); }; }</code> </pre> <br><p>  Dans le composant <strong>principal</strong> , ajoutez le composant <strong>MemberList</strong> et transférez-y le tableau d'utilisateurs. </p><br><p>  <strong>Main.js</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList members={props.members} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Et dans le composant <strong>MemberList,</strong> nous <strong>parcourons</strong> tous les utilisateurs et pour chaque retour le composant <strong>MemberItem</strong> et lui passons l'objet utilisateur. </p><br><p>  <strong>MemberList.js</strong> </p><br><pre> <code class="plaintext hljs">function MemberList(props) { const members = props.members.map((member) =&gt; &lt;MemberItem key={member.uuid} member={member} /&gt; ); return ( &lt;section className="MemberList"&gt; {members} &lt;/section&gt; ); }</code> </pre> <br><p>  Le composant <strong>MemberItem affiche</strong> déjà directement l'utilisateur dans la barre latérale.  Nous y vérifions le nom de l'utilisateur, s'il n'est pas installé, puis affichons les 10 premiers caractères de l'identifiant.  Nous vérifions également le statut en ligne / hors ligne et comparons l'identifiant avec l'identifiant de l'utilisateur actuel, de sorte qu'en face de lui pour afficher la marque "(You)". </p><br><pre> <code class="plaintext hljs">function MemberItem(props) { function getName(){ let name = '' if (props.member.uuid === props.me.uuid) { if(props.me.name) { name = props.me.name } else { name = props.me.uuid.substring(props.me.uuid.length-10, props.me.uuid.length); } } else { if(props.member.name){ name = props.member.name } else { name = props.member.uuid.substring(props.member.uuid.length-10, props.member.uuid.length); } } return name; } return( &lt;div className="MemberItem"&gt; &lt;img src={ icon } alt={ props.member.name }/&gt; &lt;span&gt; { getName() } { props.member.uuid === props.me.uuid &amp;&amp; " () " } &lt;/span&gt; { props.member.is_online &amp;&amp; &lt;span className="online"&gt;•&lt;/span&gt; } &lt;/div&gt; ); }</code> </pre> <br><p>  C'est fait.  Maintenant, l'application ressemble déjà à ceci </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/512/a8b/eba512a8bca7de4b1487567775f7742b.png" alt="En-tête de chat"></p><br><h4 id="spisok-soobscheniy-i-forma-otpravki">  Liste des messages et formulaire de soumission </h4><br><p>  Nous allons maintenant traiter de la liste des messages et de la forme d'envoi. <br>  Tout d'abord, ajoutez un tableau avec des messages à l'état du composant <strong>App</strong> . </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">this.state = { chatroomName: '-', messages: [ { content: " 1", sender_id: "mnzxcv97zx6chvo", uuid: "dg897sdfg" }, { content: " 2", sender_id: "98s7dfh9a8s7dhf", uuid: "8723hernm" }, { content: "  ", sender_id: "mnzxcv97zx6chvo", uuid: "435nbcv98234" } ], members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } };</code> </pre> <br><p>  Et les transmettre au composant <strong>principal</strong> </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs"> &lt;Main members={this.state.members} messages={this.state.messages} me={this.state.me} /&gt;</code> </pre> <br><p>  Créez maintenant les composants composant <strong>/ chat-field / ChatField.js</strong> <br>  Connectez-le à <strong>Main</strong> et transférez-y les messages. </p><br><p>  <strong>Principal</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Ensuite, créez le composant <strong>conponents / message-container / MessageContainer.js</strong> <br>  Connectez-le à <strong>ChatField</strong> et <strong>transférez</strong> -y également des messages. </p><br><p>  <strong>Chatfield</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Ensuite, nous parcourrons tous les messages et pour chaque retour le composant qui le montrera. <br>  Créons-le <strong>conponents / message / Message.js</strong> .  Nous y affichons l'icône du visiteur, son nom ou son identifiant si aucun nom n'est spécifié et le texte du message lui-même. </p><br><p>  <strong>Message</strong> </p><br><pre> <code class="plaintext hljs">function Message(props) { const getSenderName = () =&gt; { if (props.sender) { return props.sender.name ? props.sender.name : props.sender.uuid.substr(-10); } return "Unknown sender"; }; return( &lt;div className="Message"&gt; &lt;div className="message-sender-icon"&gt; &lt;img src={icon} alt="visitor icon"/&gt; &lt;/div&gt; &lt;div className="message-bubble"&gt; &lt;div className="message-sender-name"&gt;{getSenderName()}&lt;/div&gt; &lt;div className="message-content"&gt;{props.message.content}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }</code> </pre> <br><p>  Maintenant, dans un <strong>MessageContainer, nous</strong> parcourons tous les messages et pour chaque retour le composant <strong>Message</strong> auquel nous passons l'objet message </p><br><p>  <strong>Messagecontainer</strong> </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Maintenant, le projet ressemble à ceci: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/cad/f22/74dcadf22a3086fa2d7182e1aa791cab.png" alt="Messages de chat"></p><br><p>  Créez maintenant un composant avec un formulaire pour envoyer des messages <strong>composants / send-message-form / SendMessageForm.js</strong> .  Dans celui-ci, nous allons créer une entrée et un bouton pour l'envoi.  Lorsque l'entrée est modifiée, son texte est écrit dans l'état et lorsque vous cliquez sur le bouton, nous appelons la fonction de rappel <code>onSendNewMessage</code> et transférons le message de l'état vers celui-ci.  <code>onSendNewMessage</code> allons créer la fonction <code>onSendNewMessage</code> un peu plus tard dans le composant <strong>App</strong> et la transmettre via des accessoires. </p><br><p>  <strong>Sendmessageform</strong> </p><br><pre> <code class="plaintext hljs">class SendMessageForm extends React.Component { constructor(props) { super(props); this.state = { message: '' }; } currentMessageChanged = (e) =&gt; { this.setState({message: e.target.value }); } sendMessageClicked = async (e) =&gt; { e.preventDefault(); if (this.state.message.length &gt; 0) { await this.props.onSendNewMessage(this.state.message); this.setState({...this.state, ...{message : ''}}); } } render(){ return ( &lt;section className="SendMessageForm"&gt; &lt;form&gt; &lt;input type="text" value={this.state.message} onChange={this.currentMessageChanged} placeholder="Type message to send"/&gt; &lt;button type="submit" onClick={this.sendMessageClicked} &gt; Send &lt;/button&gt; &lt;/form&gt; &lt;/section&gt; ); } }</code> </pre> <br><p>  Placez maintenant le composant <strong>SendMessageForm</strong> à l'intérieur de <strong>ChatField</strong> . </p><br><p>  <strong>Chatfield</strong> </p><br><pre> <code class="plaintext hljs">function ChatField(props) { return( &lt;section className="ChatField"&gt; &lt;MessageContainer members={props.members} messages={props.messages} /&gt; &lt;SendMessageForm onSendNewMessage={props.onSendNewMessage}/&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Dans le composant <strong>principal</strong> , nous <code>onSendNewMessage</code> également <code>onSendNewMessage</code> fonction <code>onSendNewMessage</code> dans <strong>ChatField</strong> . </p><br><p>  <strong>Principal</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatField members={props.members} messages={props.messages} onSendNewMessage={props.onSendNewMessage} /&gt;</code> </pre> <br><p>  Créez maintenant cette fonction dans l' <strong>application</strong> et transférez-la à <strong>Main</strong> . </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { console.log(message) }</code> </pre> <br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">&lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt;</code> </pre> <br><p>  C'est fait.  Maintenant, lorsque vous cliquez sur le bouton Envoyer un message, il sera transféré vers le composant <strong>App</strong> . <br>  Maintenant, l'application ressemble à ceci: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/89e/d31/e5389ed317bd0fb4bf87db34b05f57a6.png" alt="Fin du chat"></p><br><p>  Donc, maintenant tout est affiché dans notre application et tout fonctionne comme il se doit, mais jusqu'à présent avec des données statiques, et afin de revitaliser notre chat, vous devez l'associer au backend. </p><br><h4 id="podklyuchenie-bekenda">  Connexion backend </h4><br><p>  Pour ce faire, la première chose que vous devez faire est d'installer le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package chatix-core</a> . </p><br><pre> <code class="plaintext hljs">npm i chatix-core</code> </pre> <br><p>  Créez ensuite un compte sur <strong>chatix</strong> et créez une salle de chat.  Pour ce faire, allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chatix.io</a> et inscrivez-vous. <br>  Après l'enregistrement, vous pouvez voir l' <strong>identifiant du</strong> site <strong>websiteId</strong> dans l'interface d'administration sur la page des paramètres de chat. </p><br><p>  Nous créons maintenant une nouvelle salle de chat avec laquelle nous allons travailler. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/38b/26d/034/38b26d03464c1b236beff17c4118ba00.png" alt="Création d'une salle de chat"></p><br><p>  Nous revenons à notre projet et créons un nouveau composant à travers lequel nous travaillerons avec le serveur. <br>  <strong>composants \ chatix \ ChatixSDK.js</strong> </p><br><p>  Nous y importons <strong>ChatixCore.</strong> </p><br><pre> <code class="plaintext hljs">import ChatixCore from 'chatix-core';</code> </pre> <br><p>  Dans le composant <strong>ChatixSDK,</strong> créez une instance de la classe <strong>ChatixCore</strong> et passez <strong>websiteId</strong> comme argument. </p><br><pre> <code class="plaintext hljs">const websiteId = "_WEBSITE_ID"; this.sdk = new ChatixCore(websiteId);</code> </pre> <br><p>  Maintenant, dans <strong>this.sdk,</strong> vous pouvez utiliser les méthodes de travail avec la salle de chat.  Vous pouvez afficher la liste des méthodes sur la page du projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chatix-core</a> </p><br><p>  Ensuite, nous devons nous connecter au serveur et obtenir des données sur la salle de discussion créée précédemment.  Il existe des méthodes asynchrones <strong>start ()</strong> et <strong>getChatroom () pour cela</strong> . </p><br><p>  Après avoir reçu l'objet de la salle de conversation, prenons immédiatement son nom et le transférons vers l' <strong>application</strong> .  Pour ce faire, ajoutez la fonction de rappel <code>updateChatroomTitle(chatroom.title)</code> dans l' <strong>application</strong> et appelez-la dans <strong>ChatixSDK</strong> . </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">class ChatixSDK extends React.Component { constructor(props){ super(props); const websiteId = "_WEBSITE_ID"; this.chatroomId = "_CHATROOM_ID"; this.sdk = new ChatixCore(websiteId); this.sdk.start() .then( async () =&gt; { try { // refresh information about chatroom and call passed handler const chatroom = await this.sdk.getChatroom(this.chatroomId); if (props.updateChatroomTitle) { props.updateChatroomTitle(chatroom.title); } } catch (err) { console.error(err); } }) .catch((e) =&gt; { console.error(e); }); } render(){ return null; } }</code> </pre> <br><p>  vous pouvez regarder <code>this.chatroomId</code> dans l'interface du gestionnaire en ouvrant la salle de chat souhaitée. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/57d/309/a77/57d309a77bb226589ba225c52cfe37d6.png" alt="ChatroomID"></p><br><p>  Maintenant, dans l' <strong>application,</strong> nous allons connecter le composant <strong>ChatixSDK</strong> et y ajouter la fonction updateChatroomTitle, qui mettra à jour le nom du chat.  Nous y ajoutons également un lien <code>ref</code> afin de pouvoir accéder à ce composant. </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">this.chatixSDK = React.createRef();</code> </pre> <br><pre> <code class="plaintext hljs">setChatroomTitle = (newName) =&gt; { const newStateFragment = { chatroomName: newName}; this.setState({...this.state, ...newStateFragment}); };</code> </pre> <br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  C'est fait.  Maintenant, juste après la connexion au serveur, nous demandons des données de discussion, obtenons son nom et l'écrivons à l'état du composant <strong>App</strong> , et puisque les changements d'état provoquent le rendu du composant, le nom dans l'en-tête sera mis à jour automatiquement.  Maintenant, le nom par défaut de l'état peut être remplacé par une chaîne vide. </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">chatroomName: ''</code> </pre> <br><p>  Remplissons maintenant la barre latérale avec de vrais utilisateurs. <br>  Mais avant d'obtenir la liste des utilisateurs dont vous avez besoin pour vous connecter au chat, pour cela, dans le <strong>ChatixSDK</strong> à l'intérieur de la fonction <code>this.sdk.start()</code> , nous obtenons une liste de toutes les salles de chat de l'utilisateur, vérifiez si elle est connectée à la salle actuelle et sinon, connectez-la. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">const myChatrooms = await this.sdk.getMyChatrooms(); if (myChatrooms.filter(x =&gt; x.id===this.chatroomId).length === 0) { await this.sdk.connectToChatroom(this.chatroomId); }</code> </pre> <br><p>  Après nous être assurés que notre utilisateur est connecté à la salle de chat, nous pouvons obtenir une liste des participants à ce chat. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets get all chatroom members using infinite loop with break on empty server response let membersPage = 1; let allChatroomMembers = []; while(true) { let pagedMembers = await this.sdk.getChatroomMembers(this.chatroomId, membersPage++, 10); allChatroomMembers = [...allChatroomMembers, ...pagedMembers]; if (pagedMembers.length === 0) { break; } }</code> </pre> <br><p>  Ici, dans une boucle infinie, nous demandons aux utilisateurs page par page jusqu'à ce que nous obtenions tout le monde, dès que nous obtenons tout le monde, nous rompons la boucle.  Après cela, tout comme le nom de la salle de conversation, nous le transmettons au composant parent à l'aide de la fonction de rappel. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">if (props.setChatroomMembers) { props.setChatroomMembers(allChatroomMembers); }</code> </pre> <br><p>  Maintenant, dans le composant <strong>App</strong> , créez cette fonction de rappel <code>setChatroomMembers</code> qui <code>setChatroomMembers</code> utilisateurs par leur état en ligne / hors ligne et par ordre alphabétique et les enregistrera dans l'état. </p><br><p>  <strong>App.js</strong> </p><br><pre> <code class="plaintext hljs">setChatroomMembers = (members) =&gt; { members.sort(this.sortMembers); const newStateFragment = { members: members}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Ajouter la fonction de tri <strong>sortMembers</strong> .  Il trie les utilisateurs par statut et par ordre alphabétique. </p><br><p>  <strong>App.js</strong> </p><br><pre> <code class="plaintext hljs">sortMembers(a, b) { if (a.is_online === true &amp;&amp; b.is_online === false) { return -1; } else if (b.is_online === true &amp;&amp; a.is_online === false) { return 1; } else { if (a.name &amp;&amp; b.name) { if (a.name.toLocaleUpperCase() &gt; b.name.toLocaleUpperCase()) { return 1; } else if (a.name.toLocaleUpperCase() &lt; b.name.toLocaleUpperCase()) { return -1; } } else if (a.name &amp;&amp; !b.name) { return -1; } else if (!a.name &amp;&amp; b.name) { return 1; } if (a.uuid &gt; b.uuid) { return -1; } else { return 1; } } }</code> </pre> <br><p>  Ensuite, nous transmettons la fonction setChatroomMembers dans <strong>ChatixSDK</strong> . </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  Maintenant, juste après la connexion au serveur, ainsi qu'avec l'en-tête, nous demandons une liste de tous les utilisateurs connectés et l'écrivons dans l'état du composant <strong>App</strong> .  Et modifiez également la valeur par défaut de la liste des utilisateurs dans l'état. </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">members: []</code> </pre> <br><p>  Maintenant, selon exactement le même principe, nous obtenons l'objet de l'utilisateur actuel et un tableau de messages et les écrivons également dans l'état <strong>App</strong> </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets load 100 last messages from current chatroom const lastMessages = await this.sdk.getChatroomMessages(this.chatroomId, null, 100); if (props.setChatroomMessages) { props.setChatroomMessages(lastMessages); } if (props.setMe) { const me = this.sdk.getVisitor(); this.props.setMe(me); }</code> </pre> <br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} setChatroomMessages={this.setChatroomMessages} /&gt;</code> </pre> <br><p>  Ensuite, nous enverrons des messages. </p><br><p>  Nous dans l' <strong>application</strong> avons déjà une fonction <code>onSendNewMessage</code> qui affiche envoyer un message à la console.  Au lieu de cela, nous appellerons simplement la méthode <code>sendChatroomMessage</code> pour envoyer un message à partir de <strong>ChatixSDK</strong> . <br>  Il s'agit d'une méthode asynchrone et elle renvoie l'objet du message envoyé dans la réponse, que nous ajoutons immédiatement au tableau de messages dans l'état.  Soit dit en passant, veuillez noter que nous <code>this.chatixSDK</code> lien <code>this.chatixSDK</code> créé précédemment. </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { let receivedMsg = await this.chatixSDK.current.sendChatroomMessage(message); const currentMessages = this.state.messages; currentMessages.push(receivedMsg); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Étant donné qu'un changement d'état entraîne son nouveau rendu, la liste des messages sera mise à jour automatiquement.  Mais nous devons nous assurer que lors de l'ajout de messages, le défilement dans le bloc de messages descend. </p><br><p>  Pour ce faire, ouvrez le composant <strong>MessageContainer</strong> et à l'aide du hook <strong>useEffect,</strong> surveillez la modification dans le tableau de messages, et dès qu'il a changé et que les messages ont été ajoutés, nous obtenons un bloc <strong>scrollHeight</strong> avec des messages et le <strong>faisons</strong> défiler de la même quantité </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messagesContainer = React.createRef(); useEffect(() =&gt; { messagesContainer.current.scrollTop = messagesContainer.current.scrollHeight }, [props, messagesContainer]); const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Terminons maintenant la mise à jour du nom d'utilisateur.  Nous avons déjà créé une entrée dans l'en-tête et lorsque nous la modifions, nous transmettons l'objet utilisateur mis à jour au composant <strong>App</strong> et nous l'avons affiché dans la console.  Terminons cette fonction.  Pour ce faire, ajoutez-y la méthode appelée <code>this.chatixSDK.current.updateVisitor(user)</code> , cela mettra à jour les données sur le serveur.  Et il suffit de mettre à jour les données dans l'état local, pour cela, nous mettons à jour l'objet <code>this.state.me</code> et dans le tableau <code>this.state.members</code> , <code>this.state.members</code> trouvons également l'utilisateur actuel et le <code>this.state.members</code> jour.  Cela est nécessaire pour mettre à jour le nom de l'utilisateur actuel dans les messages qui lui sont envoyés. </p><br><p>  <strong>L'appli</strong> </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (user) =&gt; { this.chatixSDK.current.updateVisitor(user) this.setMe(user) let currentUser = this.state.members.find((member) =&gt; (member.uuid === user.uuid)) let currentUserIndex = this.state.members.indexOf(currentUser) let newMembers = [...this.state.members] newMembers[currentUserIndex] = user; this.setState({ members: newMembers }) }</code> </pre> <br><p>  Nous devons maintenant apprendre à répondre aux messages entrants, à connecter / déconnecter les utilisateurs et à modifier les informations et les utilisateurs connectés. </p><br><p>  Pour ce faire, dans le fichier <strong>ChatixSDK.js</strong> du constructeur, nous devons remplacer les fonctions de rappel.  Vous pouvez voir la liste complète des fonctions et des arguments sur la page du projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chatix-core</a> . </p><br><p>  Nous sommes <strong>actuellement</strong> intéressés par <strong>onChatroomMessageReceived</strong> , <strong>onMemberConnectedToChatroom</strong> , <strong>onMemberDisconnectedFromChatroom</strong> et <strong>onApplyVisitorInfo</strong> . </p><br><p>  Nous les redéfinissons et pour chaque fonction nous appelons notre rappel que nous allons créer dans l' <strong>App</strong> . </p><br><pre> <code class="plaintext hljs">this.sdk.onChatroomMessageReceived = (chatroomId, message) =&gt; { if (chatroomId === this.chatroomId) { this.props.onNewMessageReceived(message); } }; this.sdk.onMemberConnectedToChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.addChatroomMember) { this.props.addChatroomMember(member); } }; this.sdk.onMemberDisconnectedFromChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.removeChatroomMember) { this.props.removeChatroomMember(member); } }; this.sdk.onApplyVisitorInfo = (visitor) =&gt; { this.props.onMemberUpdated(visitor) }</code> </pre> <br><p>  Ensuite, accédez à l' <strong>application</strong> et créez ces fonctions. </p><br><p>  <strong>onNewMessageReceived (message)</strong> <br>  Cette fonction prend un objet de message et l'ajoute simplement à l'état avec le reste des messages.          ,        . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onNewMessageReceived = (message) =&gt; { const currentMessages = this.state.messages; currentMessages.push(message); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>addChatroomMember(member)</strong> <br>            state     members.              . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">addChatroomMember = (member) =&gt; { const newStateFragment = {}; const currentMembers = this.state.members; currentMembers.push(member); currentMembers.sort(this.sortMembers); newStateFragment.members = currentMembers; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>removeChatroomMember(memberId)</strong> <br>         state     <strong>members</strong>  <strong>state</strong> . </p><br><pre> <code class="plaintext hljs">removeChatroomMember = (memberId) =&gt; { const currentMembers = this.state.members; const filteredMembers = currentMembers.filter(x=&gt; x.uuid !== memberId); const newStateFragment = {members: filteredMembers}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>onMemberUpdated(updatedMember)</strong> <br>      .        .       <strong>state</strong>     . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onMemberUpdated = (updatedMember) =&gt; { let oldMember = this.state.members.find(member =&gt; member.uuid === updatedMember.uuid); oldMember = this.state.members.indexOf(oldMember); let newStateMembers = this.state.members; newStateMembers[oldMember] = updatedMember; this.setState({ members: newStateMembers }) }</code> </pre> <br><p>      <strong>ChatixSDK</strong> </p><br><p> <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} addChatroomMember={this.addChatroomMember} removeChatroomMember={this.removeChatroomMember} setChatroomMessages={this.setChatroomMessages} onNewMessageReceived={this.onNewMessageReceived} onMemberUpdated={this.onMemberUpdated} /&gt;</code> </pre> <br><p>  C'est fait!       \ ,   ,    /   . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">alekseyso</a> <br>  Matériaux supplémentaires: <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SDK Chatix ()</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SDK Chatix (npm)</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">192   -</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474492/">https://habr.com/ru/post/fr474492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474478/index.html">Synopsis sur l'apprentissage automatique. Statistiques mathématiques. Méthode du maximum de vraisemblance</a></li>
<li><a href="../fr474480/index.html">Comment éduquer les enfants à utiliser correctement la technologie si ce n’était pas dans votre enfance?</a></li>
<li><a href="../fr474484/index.html">La maquette n'est pas une béquille, la maquette est une spécification</a></li>
<li><a href="../fr474488/index.html">Diffusion gratuite de DotNext et HolyJS</a></li>
<li><a href="../fr474490/index.html">Le moment est venu: Présentation de l'aspirateur nasal Coclean</a></li>
<li><a href="../fr474494/index.html">Comment s'est passé le Zabbix Summit 2019</a></li>
<li><a href="../fr474496/index.html">Bases de données sur HighLoad ++ 2019</a></li>
<li><a href="../fr474498/index.html">Tutoriel JavaFX: Hello World</a></li>
<li><a href="../fr474500/index.html">Développement de plugins pour Grafana: l'histoire des cônes pleins</a></li>
<li><a href="../fr474502/index.html">Analyse d'Odnoklassniki au Joker 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>