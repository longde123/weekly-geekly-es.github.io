<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèØ üëÉüèæ üíÜ Bei der Leistung geht es nicht nur um die CPU: Erstellen Sie Ihre eigenen Profiler f√ºr Python ü§µ üë¥üèº üòò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angenommen, Ihr Python-Programm ist langsam und Sie stellen fest, dass dies nur teilweise auf einen Mangel an Prozessorressourcen zur√ºckzuf√ºhren ist ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bei der Leistung geht es nicht nur um die CPU: Erstellen Sie Ihre eigenen Profiler f√ºr Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/464133/">  Angenommen, Ihr Python-Programm ist langsam und Sie stellen fest, dass dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur teilweise auf einen Mangel an Prozessorressourcen zur√ºckzuf√ºhren ist</a> .  Wie finde ich heraus, welche Teile des Codes gezwungen sind, etwas zu erwarten, das nicht f√ºr die CPU gilt? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/wn/6y/su/wn6ysu4kf3msvehbatwsovabdeg.jpeg"></a> <br><br>  Nachdem Sie das Material gelesen haben, dessen √úbersetzung wir heute ver√∂ffentlichen, lernen Sie, wie Sie Ihre eigenen Profiler f√ºr Python-Code schreiben.  Es handelt sich um Tools, mit denen inaktive Stellen im Code erkannt werden, w√§hrend auf die Freigabe bestimmter Ressourcen gewartet wird.  Insbesondere werden wir hier Folgendes diskutieren: <br><br><ul><li>  Was kann das Programm erwarten? </li><li>  Profilierung der Verwendung von Ressourcen, die keine CPU-Ressourcen sind. </li><li>  Profilerstellung f√ºr unbeabsichtigte Kontextwechsel. </li></ul><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was erwartet das Programm?</font> </h2><br>  In jenen Momenten, in denen das Programm nicht mit intensiven Berechnungen unter Verwendung des Prozessors besch√§ftigt ist, scheint es auf etwas zu warten.  Dies kann zu Unt√§tigkeit des Programms f√ºhren: <br><br><ul><li>  Netzwerkressourcen.  Dies kann das Warten auf den Abschluss von DNS-Suchvorg√§ngen, das Warten auf eine Antwort von einer Netzwerkressource, das Warten auf das Ende des Ladens einiger Daten usw. umfassen. </li><li>  Festplatte.  Das Lesen von Daten von der Festplatte kann einige Zeit dauern.  Gleiches gilt f√ºr das Schreiben auf die Festplatte.  Manchmal werden Lese- oder Schreibvorg√§nge nur mit einem im RAM befindlichen Cache ausgef√ºhrt.  Mit diesem Ansatz geht alles ziemlich schnell.  Wenn ein Programm jedoch direkt mit einer Festplatte interagiert, sind solche Vorg√§nge manchmal recht langsam. </li><li>  Schl√∂sser.  Ein Programm kann warten, um einen Thread oder Prozess zu entsperren. </li><li>  Aussetzung der Arbeit.  Manchmal kann ein Programm die Arbeit absichtlich unterbrechen, z. B. zwischen Versuchen, eine Aktion auszuf√ºhren. </li></ul><br>  Wie finde ich Orte von Programmen, an denen etwas passiert, das die Leistung stark beeintr√§chtigt? <br><br><h2>  <font color="#3AC1EF">Methode Nr. 1: Analyse der Zeit, in der das Programm den Prozessor nicht verwendet</font> </h2><br>  Der in Python integrierte Profiler <code>cProfile</code> kann Daten zu vielen verschiedenen Indikatoren sammeln, die sich auf den Betrieb von Programmen beziehen.  Aus diesem Grund kann damit ein Tool erstellt werden, mit dem Sie die Zeit analysieren k√∂nnen, in der das Programm keine Prozessorressourcen verwendet. <br><br>  Das Betriebssystem kann uns genau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagen</a> , wie viel Prozessorzeit das Programm verwendet hat. <br><br>  Stellen Sie sich vor, wir erstellen ein Single-Thread-Programm.  Multithread-Programme sind schwieriger zu profilieren, und die Beschreibung dieses Prozesses ist ebenfalls nicht einfach.  Wenn das Programm 9 Sekunden lang ausgef√ºhrt wurde und gleichzeitig den Prozessor 7,5 Sekunden lang verwendet wurde, bedeutet dies, dass 1,5 Sekunden gewartet wurde. <br><br>  Erstellen Sie zun√§chst einen Timer, der das Timeout misst: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">not_cpu_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    times = os.times()    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> times.elapsed - (times.system + times.user)</code> </pre> <br>  Erstellen Sie dann einen Profiler, der diese Zeit analysiert: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cProfile, pstats <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">profile_not_cpu_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>    prof = cProfile.Profile(not_cpu_time)    prof.runcall(f, *args, **kwargs)    result = pstats.Stats(prof)    result.sort_stats(<span class="hljs-string"><span class="hljs-string">"time"</span></span>)    result.print_stats()</code> </pre> <br>  Danach k√∂nnen Sie verschiedene Funktionen profilieren: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>profile_not_cpu_time( ...   <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: urlopen(<span class="hljs-string"><span class="hljs-string">"https://pythonspeed.com"</span></span>).read()) ncalls tottime percall filename:lineno(function)    <span class="hljs-number"><span class="hljs-number">3</span></span>  <span class="hljs-number"><span class="hljs-number">0.050</span></span>  <span class="hljs-number"><span class="hljs-number">0.017</span></span> _ssl._SSLSocket.read    <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.040</span></span>  <span class="hljs-number"><span class="hljs-number">0.040</span></span> _socket.getaddrinfo    <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.020</span></span>  <span class="hljs-number"><span class="hljs-number">0.020</span></span> _socket.socket.connect    <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.010</span></span>  <span class="hljs-number"><span class="hljs-number">0.010</span></span> _ssl._SSLSocket.do_handshake  <span class="hljs-number"><span class="hljs-number">342</span></span>  <span class="hljs-number"><span class="hljs-number">0.010</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> find.str  <span class="hljs-number"><span class="hljs-number">192</span></span>  <span class="hljs-number"><span class="hljs-number">0.010</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> append.list</code> </pre> <br>  Die Ergebnisse lassen den Schluss zu, dass die meiste Zeit mit dem Lesen von Daten aus dem Socket verbracht wurde. Es dauerte jedoch einige Zeit, um eine DNS-Suche ( <code>getaddrinfo</code> ) sowie einen TCP-Handshake ( <code>connect</code> ) und einen TLS / SSL-Handshake durchzuf√ºhren. <br><br>  Da wir uns bem√ºht haben, die Zeitr√§ume des Programmbetriebs zu untersuchen, in denen keine Prozessorressourcen verwendet werden, wissen wir, dass dies alles reine Wartezeit ist, dh die Zeit, in der das Programm nicht mit Berechnungen besch√§ftigt ist. <br><br>  Warum wird Zeit f√ºr <code>str.find</code> und <code>list.append</code> ?  Bei der Ausf√ºhrung solcher Operationen muss das Programm nicht warten, daher erscheint die Erkl√§rung plausibel, wonach es sich um eine Situation handelt, in der nicht der gesamte Prozess ausgef√ºhrt wurde.  Vielleicht - auf den Abschluss eines anderen Prozesses warten oder auf den Abschluss des Ladens von Daten aus der Auslagerungsdatei in den Speicher.  Dies zeigt an, dass einige Zeit f√ºr die Ausf√ºhrung dieser Vorg√§nge aufgewendet wurde, was nicht Teil der Prozessorzeit ist. <br><br>  Au√üerdem m√∂chte ich darauf hinweisen, dass ich Berichte gesehen habe, die kleine negative Zeitfragmente enthalten.  Dies deutet auf eine gewisse Diskrepanz zwischen der verstrichenen Zeit und der Prozessorzeit hin, aber ich erwarte nicht, dass dies einen signifikanten Einfluss auf die Analyse komplexerer Programme hat. <br><br><h2>  <font color="#3AC1EF">Methode Nummer 2: Analyse der Anzahl der absichtlichen Kontextwechsel</font> </h2><br>  Das Problem bei der Messung der Zeit, die das Programm f√ºr das Warten auf etwas ben√∂tigt, besteht darin, dass bei der Durchf√ºhrung verschiedener Messsitzungen f√ºr dasselbe Programm die Zeit variieren kann, die au√üerhalb des Programmumfangs liegt.  Manchmal k√∂nnen DNS-Abfragen langsamer als gew√∂hnlich sein.  Manchmal werden einige Daten langsamer als gew√∂hnlich geladen.  Daher w√§re es n√ºtzlich, einige besser vorhersehbare Indikatoren zu verwenden, die nicht an die Geschwindigkeit der Umgebung des Programms gebunden sind. <br><br>  Eine M√∂glichkeit, dies zu tun, besteht darin, zu berechnen, wie viele Operationen, die warten m√ºssen, den Prozess abgeschlossen haben.  Das hei√üt, wir sprechen √ºber die Berechnung der Anzahl der Wartezeiten und nicht √ºber die Zeit, die f√ºr das Warten auf etwas aufgewendet wird. <br><br>  Ein Prozess kann die Verwendung von Prozessorressourcen aus zwei Gr√ºnden einstellen: <br><br><ol><li>  Jedes Mal, wenn ein Prozess eine Operation ausf√ºhrt, die nicht sofort beendet wird, z. B. Daten aus einem Socket liest, pausiert usw., entspricht dies den Angaben zum Betriebssystem: "Weck mich auf, wenn ich weiterarbeiten kann."  Dies ist der sogenannte ‚Äûabsichtliche Kontextwechsel‚Äú: Der Prozessor kann zu einem anderen Prozess wechseln, bis die Daten auf dem Socket angezeigt werden oder bis unser Prozess den Standby-Modus verl√§sst, sowie in anderen √§hnlichen F√§llen. </li><li>  "Unbeabsichtigtes Umschalten des Kontexts" ist eine Situation, in der das Betriebssystem einen Prozess vor√ºbergehend stoppt, sodass ein anderer Prozess die Prozessorressourcen nutzen kann. </li></ol><br>  Wir werden absichtliche Kontextwechsel profilieren. <br><br>  Schreiben wir einen Profiler, der absichtliche Kontextwechsel mithilfe der <code>psutil</code> Bibliothek z√§hlt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> psutil _current_process = psutil.Process() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">profile_voluntary_switches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>    prof = cProfile.Profile(        <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: _current_process.num_ctx_switches().voluntary)    prof.runcall(f, *args, **kwargs)    result = pstats.Stats(prof)    result.sort_stats(<span class="hljs-string"><span class="hljs-string">"time"</span></span>)    result.print_stats()</code> </pre> <br>  Lassen Sie uns nun den Code profilieren, der wieder mit dem Netzwerk funktioniert: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>profile_voluntary_switches( ...   <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: urlopen(<span class="hljs-string"><span class="hljs-string">"https://pythonspeed.com"</span></span>).read()) ncalls tottime percall filename:lineno(function)     <span class="hljs-number"><span class="hljs-number">3</span></span>  <span class="hljs-number"><span class="hljs-number">7.000</span></span>  <span class="hljs-number"><span class="hljs-number">2.333</span></span> _ssl._SSLSocket.read     <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">2.000</span></span>  <span class="hljs-number"><span class="hljs-number">2.000</span></span> _ssl._SSLSocket.do_handshake     <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">2.000</span></span>  <span class="hljs-number"><span class="hljs-number">2.000</span></span> _socket.getaddrinfo     <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">1.000</span></span>  <span class="hljs-number"><span class="hljs-number">1.000</span></span> _ssl._SSLContext.set_default_verify_path     <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">1.000</span></span>  <span class="hljs-number"><span class="hljs-number">1.000</span></span> _socket.socket.connect</code> </pre> <br>  Anstelle von Wartezeitdaten k√∂nnen wir jetzt Informationen √ºber die Anzahl der beabsichtigten Kontextwechsel anzeigen, die aufgetreten sind. <br><br>  Beachten Sie, dass Sie manchmal absichtliche Kontextwechsel an unerwarteten Stellen sehen k√∂nnen.  Ich glaube, dies passiert, wenn Daten aus der Auslagerungsdatei aufgrund von Speicherseitenfehlern geladen werden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Die Verwendung der hier beschriebenen Code-Profiling-Technik f√ºhrt zu einer gewissen zus√§tzlichen Belastung des Systems, die das Programm erheblich verlangsamt.  In den meisten F√§llen sollte dies jedoch nicht zu einer signifikanten Verzerrung der Ergebnisse f√ºhren, da wir den Einsatz von Prozessorressourcen nicht analysieren. <br><br>  Im Allgemeinen kann festgestellt werden, dass sich messbare Indikatoren im Zusammenhang mit der Arbeit des Programms f√ºr die Profilerstellung eignen.  Zum Beispiel Folgendes: <br><br><ul><li>  Die Anzahl der <code>psutil.Process().read_count</code> ( <code>psutil.Process().read_count</code> ) und Schreibvorg√§nge ( <code>psutil.Process().write_count</code> ). </li><li>  Unter Linux die Gesamtzahl der gelesenen und geschriebenen Bytes (psutil. <code>Process().read_chars</code> ). </li><li>  Speicherzuweisungsindikatoren (die Durchf√ºhrung einer solchen Analyse erfordert einige Anstrengungen; dies kann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jemalloc erfolgen</a> ). </li></ul><br>  Details zu den ersten beiden Elementen dieser Liste finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">psutil-</a> Dokumentation. <br><br>  <b>Liebe Leser!</b>  Wie profilieren Sie Ihre Python-Anwendungen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464133/">https://habr.com/ru/post/de464133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464121/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 376 (12. - 18. August 2019)</a></li>
<li><a href="../de464125/index.html">Geheime Internetgeschichte in der Datenschutzrichtlinie von Google mit 4.000 W√∂rtern</a></li>
<li><a href="../de464127/index.html">Entwicklung animierter Favicons</a></li>
<li><a href="../de464129/index.html">JavaScript-Innovationen: Ergebnisse von Google I / O 2019 Teil 1</a></li>
<li><a href="../de464131/index.html">JavaScript-Innovationen: Ergebnisse von Google I / O 2019 Teil 2</a></li>
<li><a href="../de464137/index.html">Technischer Support Miran: wie es funktioniert</a></li>
<li><a href="../de464141/index.html">Fantasien zum Thema Metaklassen in C #</a></li>
<li><a href="../de464143/index.html">Pers√∂nliche Krebsheilung. Wie Patientengene den Behandlungserfolg beeinflussen</a></li>
<li><a href="../de464145/index.html">CMake: Der Fall, in dem die Qualit√§t des Projekts unverzeihlich ist</a></li>
<li><a href="../de464147/index.html">CMake: Der Fall, in dem das Projekt unverzeihlich ist, ist die Qualit√§t seines Codes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>