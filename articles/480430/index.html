<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåû üçÜ üè≥Ô∏è‚Äçüåà C√≥mo funciona el c√≥dec de video. Parte 2. Qu√©, por qu√©, c√≥mo üå≠ üë®üèæ‚ÄçüöÄ üç±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte I: Conceptos b√°sicos de video e imagen 

  

 Que? Un c√≥dec de video es una pieza de software / hardware que comprime y / o descomprime video di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona el c√≥dec de video. Parte 2. Qu√©, por qu√©, c√≥mo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/480430/"><h3>  Parte I: <a href="https://habr.com/ru/company/edison/blog/481418/">Conceptos b√°sicos de video e imagen</a> </h3><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/480430/"><img src="https://habrastorage.org/webt/ta/r8/lt/tar8ltvwz2ubkwwudgcjws-sa9a.png" alt="La historia de Kodek"></a> <br><br>  <b>Que?</b>  Un c√≥dec de video es una pieza de software / hardware que comprime y / o descomprime video digital. <br><br>  <b>Para que?</b>  A pesar de ciertas limitaciones en t√©rminos de ancho de banda, <br>  y en t√©rminos de la cantidad de espacio de almacenamiento, el mercado requiere m√°s y m√°s videos de alta calidad.  ¬øRecuerdas c√≥mo en la √∫ltima publicaci√≥n calculamos el m√≠nimo necesario para 30 fotogramas por segundo, 24 bits por p√≠xel, con una resoluci√≥n de 480x240?  Recibi√≥ 82.944 Mbps sin compresi√≥n.  La compresi√≥n es la √∫nica forma de transferir HD / FullHD / 4K a pantallas de TV e Internet.  ¬øC√≥mo se logra esto?  Ahora consideraremos brevemente los m√©todos principales. <a name="habracut"></a><blockquote> <a href="https://www.edsd.ru/" title="Software EDISON - desarrollo web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Software EDISON - desarrollo web"></a> <br clear="right">  La traducci√≥n se realiz√≥ con el apoyo del software EDISON. <br><br>  Nos dedicamos a la <a href="https://www.edsd.ru/integratsiya-sistem-videonablyudeniya-axxon-next-i-sureview-immix">integraci√≥n de sistemas de videovigilancia</a> , as√≠ como al <a href="https://www.edsd.ru/prilozhenie-dlya-mikrotomografa">desarrollo de una microtomograf√≠a</a> . </blockquote><h3>  C√≥dec vs Contenedor </h3><br>  Un error com√∫n de los novatos es confundir un c√≥dec de video digital y un contenedor de video digital.  Un contenedor tiene cierto formato.  Un contenedor que contiene metadatos de video (y posiblemente audio).  El video comprimido se puede considerar como una carga √∫til de contenedor. <br><br>  Por lo general, una extensi√≥n de archivo de video indica un tipo de contenedor.  Por ejemplo, el archivo video.mp4 es probablemente un <i>contenedor MPEG-4 Parte 14</i> , y el archivo llamado video.mkv es probablemente una <a href="https://ru.wikipedia.org/wiki/Matroska">mu√±eca</a> rusa.  Para tener plena confianza en el c√≥dec y el formato del contenedor, puede usar <a href="https://www.ffmpeg.org/">FFmpeg</a> o <a href="https://mediaarea.net/ru/MediaInfo">MediaInfo</a> . <br><br><h3>  Un poco de historia </h3><br>  Antes de llegar a <b>¬øC√≥mo?</b>  , profundicemos un poco en la historia para comprender un poco mejor algunos c√≥decs antiguos. <br><br>  El c√≥dec de video <b>H.261</b> apareci√≥ en 1990 (t√©cnicamente, en 1988) y fue creado para trabajar con una velocidad de transferencia de datos de 64 Kbps.  Ya ha utilizado ideas como submuestreo de color, macrobloques, etc.  En 1995, se public√≥ el est√°ndar de c√≥dec de video <b>H.263</b> , que se desarroll√≥ hasta 2001. <br><br>  En 2003, se complet√≥ la primera versi√≥n de <b>H.264 / AVC</b> .  En el mismo a√±o, TrueMotion lanz√≥ su c√≥dec de video gratuito que comprime el video con p√©rdida llamado <b>VP3</b> .  En 2008, Google compr√≥ esta compa√±√≠a, lanzando <b>VP8</b> en el mismo a√±o.  En diciembre de 2012, Google lanz√≥ <b>VP9</b> , y es compatible en aproximadamente ¬æ del mercado de navegadores (incluidos los dispositivos m√≥viles). <br><br>  <b>AV1</b> es un nuevo c√≥dec de video de c√≥digo abierto gratuito desarrollado <b>por Open Media Alliance</b> ( <b>AOMedia</b> ), que incluye compa√±√≠as conocidas como Google, Mozilla, Microsoft, Amazon, Netflix, AMD, ARM, NVidia, Intel y Cisco .  La primera versi√≥n del c√≥dec 0.1.0 se public√≥ el 7 de abril de 2016. <br><br><h3>  Nacimiento de AV1 </h3><br>  A principios de 2015, Google trabaj√≥ en <b>VP10</b> , Xiph (que pertenece a Mozilla) trabaj√≥ en <b>Daala</b> y Cisco cre√≥ su c√≥dec de video gratuito llamado <b>Thor</b> . <br><br>  Luego, <b>MPEG LA</b> anunci√≥ por primera vez los l√≠mites anuales para <b>HEVC</b> ( <b>H.265</b> ) y una tarifa 8 veces mayor que para H.264, pero pronto cambiaron las reglas nuevamente: <br><br>  sin l√≠mite anual, <br>  tarifa de contenido (0.5% de los ingresos) y <br>  los costos unitarios son aproximadamente 10 veces m√°s altos que para H.264. <br><br>  <i>Open Media Alliance</i> fue creada por empresas de diversos campos: fabricantes de equipos (Intel, AMD, ARM, Nvidia, Cisco), proveedores de contenido (Google, Netflix, Amazon), fabricantes de navegadores (Google, Mozilla) y otros. <br><br>  Las compa√±√≠as ten√≠an un objetivo com√∫n: un c√≥dec de video sin regal√≠as.  Luego viene <b>AV1</b> con una licencia de patente mucho m√°s simple.  Timothy B. Terriberry hizo una presentaci√≥n sorprendente, que se convirti√≥ en la fuente del concepto actual de AV1 y su modelo de licencia. <br><br>  Te sorprender√° saber que puedes analizar el c√≥dec AV1 a trav√©s de un navegador (los interesados ‚Äã‚Äãpueden ir a <a href="http://aomanalyzer.org/">aomanalyzer.org</a> ). <br><br><img src="https://habrastorage.org/webt/wa/zz/tv/wazztvoifpc4l11k2_8jzdmiffk.png" alt="imagen"><br><br><h3>  C√≥dec universal </h3><br>  Analicemos los mecanismos b√°sicos que subyacen al c√≥dec de video universal.  La mayor√≠a de estos conceptos son √∫tiles y se utilizan en c√≥decs modernos como <b>VP9</b> , <b>AV1</b> y <b>HEVC</b> .  Te advierto que muchas cosas explicadas se simplificar√°n.  A veces se usar√°n ejemplos del mundo real (como es el caso con H.264) para demostrar la tecnolog√≠a. <br><br><h3>  1er paso: dividir la imagen </h3><br>  El primer paso es dividir el marco en varias secciones, subsecciones y m√°s. <br><br><img width="420" height="238" src="https://habrastorage.org/webt/lo/ze/q1/lozeq18ppa9po16q2ykeiazibpk.png" alt="imagen"><br><br>  Para que?  Hay muchas razones  Cuando dividimos la imagen, podemos predecir con mayor precisi√≥n el vector de movimiento utilizando peque√±as secciones para peque√±as partes m√≥viles.  Mientras que para un fondo est√°tico, puede restringirse a secciones m√°s grandes. <br><br>  Normalmente, los c√≥decs organizan estas secciones en secciones (o fragmentos), macrobloques (o bloques de un √°rbol de codificaci√≥n) y muchas subsecciones.  El tama√±o m√°ximo de estas particiones var√≠a, HEVC establece 64x64, mientras que AVC usa 16x16, y las subsecciones se pueden dividir hasta 4x4. <br><br>  ¬øRecuerdas las variedades de marcos del √∫ltimo art√≠culo?  Lo mismo se puede aplicar a los bloques, por lo tanto, podemos tener un fragmento I, un bloque B, un macrobloque P, etc. <br><br>  Para aquellos que quieran practicar, miren c√≥mo se dividir√° la imagen en secciones y subsecciones.  Para hacer esto, puede usar el <a href="https://software.intel.com/en-us/video-pro-analyzer">analizador Intel Video Pro</a> ya mencionado en el art√≠culo anterior (el que se paga, pero con una versi√≥n de prueba gratuita, que tiene un l√≠mite en los primeros 10 cuadros).  Las secciones de <b>VP9</b> se analizan aqu√≠: <br><br><img width="711" height="370" src="https://habrastorage.org/webt/ub/n1/yh/ubn1yh-_d5n68swbd0bgc-lxbha.png" alt="imagen"><br><br><h3>  2do paso - pron√≥stico </h3><br>  Tan pronto como tengamos secciones, podemos hacer pron√≥sticos <s>astrol√≥gicos</s> sobre ellas.  Para <b>la predicci√≥n INTER,</b> es necesario transferir los <b>vectores de movimiento</b> y el resto, y para la predicci√≥n INTRA, se transmiten la <b>direcci√≥n del pron√≥stico</b> y el resto. <br><br><h3>  3er paso - conversi√≥n </h3><br>  Despu√©s de obtener el bloque residual (la secci√≥n predicha ‚Üí la secci√≥n real), es posible transformarlo de tal manera que sepa qu√© p√≠xeles se pueden descartar, manteniendo la calidad general.  Hay algunas transformaciones que proporcionan un comportamiento preciso. <br><br>  Aunque existen otros m√©todos, consideremos con m√°s detalle la <b>transformada discreta del coseno</b> ( <b>DCT</b> - de la <i>transformada discreta del coseno</i> ).  Caracter√≠sticas clave de DCT: <br><br><ul><li>  Convierte bloques de p√≠xeles en bloques de coeficientes de frecuencia de igual tama√±o. </li><li>  Sella la potencia, ayudando a eliminar la redundancia espacial. </li><li>  Proporciona reversibilidad. </li></ul><br>  2 de febrero de 2017 Sintra R.J.  (Cintra, RJ) y Bayer F.M.  (Bayer FM) public√≥ un art√≠culo sobre conversi√≥n tipo DCT para la compresi√≥n de im√°genes, que requiere solo 14 adiciones. <br><br>  No se preocupe si no comprende los beneficios de cada art√≠culo.  Ahora, con ejemplos concretos, verificaremos su valor real. <br><br>  Tomemos un bloque de 8x8 p√≠xeles como este: <br><br><img width="354" height="139" src="https://habrastorage.org/webt/tf/di/up/tfdiuplow4tut1aww2lrfydamyi.png" alt="imagen"><br><br>  Este bloque se representa en la siguiente imagen de 8 por 8 p√≠xeles: <br><br><img width="362" height="380" src="https://habrastorage.org/webt/rq/gj/hj/rqgjhjuplvgdadziupv-ogpdazo.png" alt="imagen"><br><br>  Aplique DCT a este bloque de p√≠xeles y obtenga un bloque de coeficientes de tama√±o 8x8: <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="imagen"><br><br>  Y si representamos este bloque de coeficientes, obtenemos la siguiente imagen: <br><br><img width="401" height="328" src="https://habrastorage.org/webt/np/b0/v2/npb0v2_58_1hxinqekagzf6phzi.png" alt="imagen"><br><br>  Como puede ver, esto no es como la imagen original.  Puede notar que el primer coeficiente es muy diferente de todos los dem√°s.  Este primer coeficiente se conoce como un coeficiente DC que representa todas las muestras en la matriz de entrada, algo similar al valor promedio. <br><br>  Este bloque de coeficientes tiene una propiedad interesante: separa los componentes de alta frecuencia de los de baja frecuencia. <br><br><img width="293" height="129" src="https://habrastorage.org/webt/n0/4u/1z/n04u1zqlixaeggiw_yfg3umocsy.jpeg" alt="imagen"><br><br>  En la imagen, la mayor parte de la potencia se concentra a frecuencias m√°s bajas, por lo tanto, si convierte la imagen en sus componentes de frecuencia y descarta los coeficientes de frecuencia m√°s altos, puede reducir la cantidad de datos necesarios para describir la imagen sin sacrificar demasiado la calidad de la imagen. <blockquote>  Frecuencia significa qu√© tan r√°pido cambia la se√±al. </blockquote>  Intentemos aplicar el conocimiento adquirido en el ejemplo de prueba convirtiendo la imagen original a su frecuencia (bloque de coeficientes) usando DCT, y luego descartando algunos de los coeficientes menos importantes. <br><br>  Primero, convi√©rtalo al dominio de frecuencia. <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="imagen"><br><br>  A continuaci√≥n, descartamos parte (67%) de los coeficientes, principalmente el lado inferior derecho. <br><br><img width="624" height="139" src="https://habrastorage.org/webt/h5/dq/ww/h5dqwwheilwuuasgm7xxijdxmt8.png" alt="imagen"><br><br>  Finalmente, restauramos la imagen de este bloque de coeficientes descartado (recuerde, debe ser reversible) y lo comparamos con el original. <br><br><img src="https://habrastorage.org/webt/6j/c6/1z/6jc61zgpg5r-vxxh3j0dxjeatha.png" alt="imagen"><br><br>  Vemos que se parece a la imagen original, pero hay muchas diferencias con respecto a la original.  Lanzamos 67.1875% y todav√≠a obtuvimos algo que se parece a la fuente original.  Podr√≠as descartar m√°s deliberadamente los coeficientes para obtener una imagen de mejor calidad, pero este es el siguiente tema. <blockquote><h4>  Cada coeficiente se genera utilizando todos los p√≠xeles. </h4><br><br>  Importante: cada coeficiente no se muestra directamente en un p√≠xel, sino que es una suma ponderada de todos los p√≠xeles.  Este sorprendente gr√°fico muestra c√≥mo se calculan los coeficientes primero y segundo utilizando pesos √∫nicos para cada √≠ndice. <br><br><img width="381" height="550" src="https://habrastorage.org/webt/ix/uv/hw/ixuvhwvqvclyzq6astn1d5vsaac.jpeg" alt="imagen"><br><br>  Tambi√©n puede intentar visualizar DCT mirando im√°genes simples basadas en √©l.  Por ejemplo, aqu√≠ est√° el s√≠mbolo A generado usando cada peso de coeficiente: <br><br><img width="241" height="81" src="https://habrastorage.org/webt/oq/ua/3t/oqua3tnacmh7nsucvodymeqzqa0.gif" alt="imagen"></blockquote><br><br><h3>  4to paso - cuantizaci√≥n </h3><br>  Despu√©s de arrojar algunos coeficientes en el paso anterior, en el √∫ltimo paso (transformaci√≥n), producimos una forma especial de cuantizaci√≥n.  En este punto, est√° permitido perder informaci√≥n.  O, m√°s simplemente, cuantificaremos los coeficientes para lograr la compresi√≥n. <br><br>  ¬øC√≥mo se puede cuantificar un bloque de coeficientes?  Uno de los m√©todos m√°s simples ser√° la cuantizaci√≥n uniforme, cuando tomamos un bloque, lo dividimos por un valor (por 10) y redondeamos lo que sucedi√≥. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/i8/1a/os/i81aosymefwhnp0jboibq0dd_4i.png" alt="imagen"><br><br>  ¬øPodemos revertir este bloque de coeficientes?  S√≠, podemos multiplicar por el mismo valor por el que dividimos. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/ys/vs/51/ysvs514v-u_hrteesekxdrkjp9c.png" alt="imagen"><br><br>  Este enfoque no es el mejor, ya que no tiene en cuenta la importancia de cada coeficiente.  Se podr√≠a usar la matriz cuantificadora en lugar de un solo valor, y esta matriz podr√≠a usar la propiedad DCT, cuantificando la mayor parte de la parte inferior derecha y una minor√≠a de la parte superior izquierda. <br><br><h3>  5 pasos - codificaci√≥n de entrop√≠a </h3><br>  Despu√©s de cuantificar los datos (bloques de imagen, fragmentos, cuadros), a√∫n podemos comprimirlos sin p√©rdida.  Hay muchas formas algor√≠tmicas para comprimir datos.  Vamos a conocer brevemente algunos de ellos, para una comprensi√≥n m√°s profunda, puede leer el libro " <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Comprender la compresi√≥n: compresi√≥n de datos para desarrolladores modernos</a> " (" <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Comprender la compresi√≥n: compresi√≥n de datos para desarrolladores modernos</a> "). <br><br><h3>  Codificaci√≥n de video con VLC </h3><br>  Supongamos que tenemos una secuencia de caracteres: <b>a</b> , <b>e</b> , <b>r</b> y <b>t</b> .  En esta tabla se presenta la probabilidad (que var√≠a de 0 a 1) de la frecuencia con la que cada s√≠mbolo ocurre en la secuencia. <div class="scrollable-table"><table><tbody><tr><th></th><th>  un </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Probabilidad </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0.2 0.2 </td><td align="center">  0.2 0.2 </td></tr></tbody></table></div>  Podemos asignar c√≥digos binarios √∫nicos (preferiblemente peque√±os) a los m√°s probables, y c√≥digos m√°s grandes menos probables. <div class="scrollable-table"><table><tbody><tr><th></th><th>  un </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Probabilidad </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0.2 0.2 </td><td align="center">  0.2 0.2 </td></tr><tr><th>  C√≥digo binario </th><td align="center">  0 0 </td><td align="center">  10 </td><td align="center">  110 </td><td align="center">  1110 </td></tr></tbody></table></div>  Comprimimos la secuencia, suponiendo que al final gastemos 8 bits para cada personaje.  Sin compresi√≥n en un personaje, se necesitar√≠an 24 bits.  Si cada personaje se reemplaza con su c√≥digo, ¬°obtenemos ahorros! <br><br>  El primer paso es codificar el car√°cter <b>e</b> , que es 10, y el segundo car√°cter es <b>a</b> , que se agrega (no matem√°ticamente): [10] [0], y finalmente, el tercer car√°cter <b>t</b> , que hace que nuestro flujo de bits comprimido final sea igual [10] [0] [1110] o <b>1001110</b> , que requiere solo 7 bits (3,4 veces menos espacio que en el original). <br><br>  Tenga en cuenta que cada c√≥digo debe ser un c√≥digo √∫nico con un prefijo.  <a href="https://en.wikipedia.org/wiki/Huffman_coding">El algoritmo de Huffman</a> ayudar√° a encontrar estos n√∫meros.  Aunque este m√©todo no est√° exento de fallas, hay c√≥decs de video que a√∫n ofrecen este m√©todo algor√≠tmico para la compresi√≥n. <br><br>  Tanto el codificador como el decodificador deben tener acceso a la tabla de s√≠mbolos con sus c√≥digos binarios.  Por lo tanto, tambi√©n es necesario enviar una tabla en la entrada. <br><br><h3>  Codificaci√≥n aritm√©tica </h3><br>  Supongamos que tenemos una secuencia de caracteres: <b>a</b> , <b>e</b> , <b>r</b> , <b>syt</b> , y su probabilidad est√° representada por esta tabla. <div class="scrollable-table"><table><tbody><tr><th></th><th>  un </th><th>  e </th><th>  r </th><th>  s </th><th>  t </th></tr><tr><th>  Probabilidad </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,15 </td><td align="center">  0,05 </td><td align="center">  0.2 0.2 </td></tr></tbody></table></div>  Con esta tabla, construimos rangos que contienen todos los caracteres posibles, ordenados por el n√∫mero m√°s grande. <br><br><img width="713" height="86" src="https://habrastorage.org/webt/v2/et/wv/v2etwv7gqr0imlymbanupu6k3fw.png" alt="imagen"><br><br>  Ahora codifiquemos una secuencia de tres caracteres: <b>comer</b> . <br><br>  Primero, seleccione el primer car√°cter <b>e</b> , que est√° en el sub-rango de 0.3 a 0.6 (sin incluir).  Tomamos este subrango y lo dividimos nuevamente en las mismas proporciones que antes, pero ya para este nuevo rango. <br><br><img width="731" height="86" src="https://habrastorage.org/webt/fv/ra/lx/fvralxpih4rt9d6zowmweah5r8m.png" alt="imagen"><br><br>  Sigamos codificando nuestra secuencia de <b>comer</b> .  Ahora tomamos el segundo s√≠mbolo <b>a</b> , que est√° en el nuevo subrango de 0.3 a 0.39, y luego tomamos nuestro √∫ltimo s√≠mbolo <b>t</b> y, repitiendo el mismo proceso nuevamente, obtenemos el √∫ltimo subrango de 0.354 a 0.372. <br><br><img width="735" height="388" src="https://habrastorage.org/webt/eh/bj/nz/ehbjnz3uckrkkfoei5bt2gqh1zk.png" alt="imagen"><br><br>  Solo necesitamos seleccionar un n√∫mero en el √∫ltimo subrango de 0.354 a 0.372.  Elijamos 0.36 (pero puede elegir cualquier otro n√∫mero en este subrango).  Solo con este n√∫mero podemos restaurar nuestro flujo original.  Es como si estuvi√©ramos dibujando una l√≠nea dentro de los rangos para codificar nuestra secuencia. <br><br><img width="712" height="231" src="https://habrastorage.org/webt/a2/y2/ye/a2y2yerdhz8bied1n-4o8pqfiic.png" alt="imagen"><br><br>  La operaci√≥n inversa (es decir, la <i>decodificaci√≥n</i> ) es igual de simple: con nuestro n√∫mero 0.36 y nuestro rango inicial, podemos comenzar el mismo proceso.  Pero ahora, usando este n√∫mero, revelamos la secuencia codificada usando este n√∫mero. <br><br>  Con el primer rango, notamos que nuestro n√∫mero corresponde a un segmento, por lo tanto, este es nuestro primer car√°cter.  Ahora, de nuevo, compartimos esta subbanda, realizando el mismo proceso que antes.  Aqu√≠ puede ver que 0.36 corresponde al car√°cter <b>a</b> , y despu√©s de repetir el proceso, llegamos al √∫ltimo car√°cter <b>t</b> (formando nuestro flujo codificado original como <b>comer</b> ). <br><br>  Tanto el codificador como el decodificador deben tener una tabla de probabilidades de s√≠mbolos, por lo tanto, es necesario enviarlo en los datos de entrada. <br><br>  Bastante elegante, ¬øno es as√≠?  Alguien a quien se le ocurri√≥ esta soluci√≥n fue muy inteligente.  Algunos c√≥decs de video usan esta t√©cnica (o, en cualquier caso, la ofrecen como una opci√≥n). <br><br>  La idea es comprimir un flujo de bits cuantificado sin p√©rdidas.  Seguramente en este art√≠culo no hay toneladas de detalles, razones, compromisos, etc.  Pero usted, si es desarrollador, deber√≠a saber m√°s.  Los nuevos c√≥decs est√°n intentando utilizar diferentes algoritmos de codificaci√≥n de entrop√≠a, como <b>ANS</b> . <br><br><h3>  6 pasos - formato de flujo de bits </h3><br>  Despu√©s de hacer todo esto, queda por desempaquetar los cuadros comprimidos en el contexto de los pasos tomados.  El decodificador debe ser informado expl√≠citamente de las decisiones tomadas por el codificador.  Se debe proporcionar al decodificador toda la informaci√≥n necesaria: profundidad de bits, espacio de color, resoluci√≥n, informaci√≥n de pron√≥stico (vectores de movimiento, predicci√≥n INTER direccional), perfil, nivel, velocidad de cuadros, tipo de cuadro, n√∫mero de cuadro y mucho m√°s. <br><br>  Echaremos un vistazo al flujo de bits <b>H.264</b> .  Nuestro primer paso es crear un flujo de bits H.264 m√≠nimo (FFmpeg por defecto agrega todos los par√°metros de codificaci√≥n, como <b>SEI NAL</b> ; un poco m√°s, descubriremos de qu√© se trata).  Podemos hacer esto usando nuestro propio repositorio y FFmpeg. <br><br> <code>./s/ffmpeg -i /files/i/minimal.png -pix_fmt yuv420p /files/v/minimal_yuv420.h264</code> <br> <br>  Este comando generar√° un flujo de bits <b>H.264 sin</b> formato con un cuadro, resoluci√≥n 64x64, con el espacio de color <b>YUV420</b> .  La siguiente imagen se usa como marco. <br><br><img width="64" height="64" src="https://habrastorage.org/webt/dk/94/2b/dk942bnujajisjouk6zpwy9p5i8.png" alt="imagen"><br><br><h3>  H.264 Bitstream </h3><br>  El <b>est√°ndar AVC</b> ( <b>H.264</b> ) define que la informaci√≥n se enviar√° en marcos macro (en la comprensi√≥n de la red) llamada <b>NAL</b> (este es un nivel de abstracci√≥n de red).  El objetivo principal de NAL es proporcionar una presentaci√≥n de video "amigable para la red".  Este est√°ndar deber√≠a funcionar en televisores (basados ‚Äã‚Äãen transmisiones), en Internet (basados ‚Äã‚Äãen paquetes). <br><br><img width="484" height="41" src="https://habrastorage.org/webt/rd/8r/ag/rd8rag_9adq5fnhkh3bp1l84ljw.png" alt="imagen"><br><br>  Hay un marcador de sincronizaci√≥n para definir los l√≠mites de los elementos NAL.  Cada marcador de sincronizaci√≥n contiene el valor <nobr><b>0x00 0x00 0x01,</b></nobr> con la excepci√≥n del primero, que es <nobr><b>0x00 0x00 0x00 0x01.</b></nobr>  Si ejecutamos <b>hexdump</b> para el flujo de bits H.264 generado, identificaremos al menos tres patrones NAL al comienzo del archivo. <br><br><img width="451" height="250" src="https://habrastorage.org/webt/ow/vk/uj/owvkujuxd9qw-yft0b2tecxp3oq.png" alt="imagen"><br><br>  Como se indic√≥, el decodificador debe conocer no solo los datos de la imagen, sino tambi√©n los detalles del video, el marco, el color, los par√°metros utilizados y mucho m√°s.  El primer byte de cada NAL define su categor√≠a y tipo. <div class="scrollable-table"><table><tbody><tr><th>  Identificador de tipo NAL </th><th>  Descripci√≥n </th></tr><tr><td align="center">  0 0 </td><td>  Tipo desconocido </td></tr><tr><td align="center">  1 </td><td>  Fragmento de imagen codificada sin IDR </td></tr><tr><td align="center">  2 </td><td>  Secci√≥n de datos codificada del segmento <b>A</b> </td></tr><tr><td align="center">  3 </td><td>  Secci√≥n <b>B</b> codificada de datos de la secci√≥n </td></tr><tr><td align="center">  4 4 </td><td>  Secci√≥n de datos de corte codificada en <b>C</b> </td></tr><tr><td align="center">  5 5 </td><td>  Fragmento IDR codificado de una imagen IDR </td></tr><tr><td align="center">  6 6 </td><td>  Informaci√≥n adicional sobre la extensi√≥n SEI </td></tr><tr><td align="center">  7 7 </td><td>  Conjunto de par√°metros de secuencia SPS </td></tr><tr><td align="center">  8 </td><td>  Conjunto de par√°metros de imagen PPS </td></tr><tr><td align="center">  9 9 </td><td>  Delimitador de acceso </td></tr><tr><td align="center">  10 </td><td>  Fin de secuencia </td></tr><tr><td align="center">  11 </td><td>  Fin de la corriente </td></tr><tr><td align="center">  ... </td><td>  ... </td></tr></tbody></table></div>  Por lo general, el primer flujo de bits NAL es <b>SPS</b> .  Este tipo de NAL es responsable de informar variables de codificaci√≥n comunes, como perfil, nivel, resoluci√≥n y m√°s. <br><br>  Si omitimos el primer token de sincronizaci√≥n, podemos decodificar el primer byte para averiguar qu√© tipo de NAL es el primero. <br><br>  Por ejemplo, el primer byte despu√©s del marcador de sincronizaci√≥n es <i>01100111</i> , donde el primer bit ( <i>0</i> ) est√° en el campo f <i>orbidden_zero_bit</i> .  Los siguientes 2 bits ( <i>11</i> ) nos <i>indican el</i> campo <i>nal_ref_idc,</i> que indica si este NAL es un campo de referencia o no.  Y los 5 bits restantes ( <i>00111</i> ) nos <i>indican el</i> campo <i>nal_unit_type,</i> en este caso es un bloque <i>NPS</i> SPS ( <i>7</i> ). <br><br>  El segundo byte ( <i>binario</i> = <i>01100100</i> , <i>hexadecimal</i> = <i>0x64</i> , <i>dec</i> = <i>100</i> ) en el SPS NAL es el campo <i>profile_idc,</i> que muestra el perfil que utiliz√≥ el codificador.  En este caso, se utiliz√≥ un perfil alto limitado (es decir, un perfil alto sin soporte para un segmento B bidireccional). <br><br><img src="https://habrastorage.org/webt/xo/zt/wl/xoztwl_amtveehtmceuijr3wdsm.png" alt="imagen"><br><br>  Si nos familiarizamos con la especificaci√≥n del flujo de bits <b>H.264</b> para SPS NAL, encontraremos muchos valores para el nombre, la categor√≠a y la descripci√≥n del par√°metro.  Por ejemplo, veamos los <i>campos</i> <i>pic_width_in_mbs_minus_1</i> y <i>pic_height_in_map_units_minus_1</i> . <div class="scrollable-table"><table><tbody><tr><th>  Nombre del par√°metro </th><th>  Categor√≠a </th><th>  Descripci√≥n </th></tr><tr><td>  pic_width_in_mbs_minus_1 </td><td align="center">  0 0 </td><td align="center">  ue (v) </td></tr><tr><td>  pic_height_in_map_units_minus_1 </td><td align="center">  0 0 </td><td align="center">  ue (v) </td></tr></tbody></table></div>  Si realizamos algunas operaciones matem√°ticas con los valores de estos campos, obtendremos permiso.  Puede imaginar <nobr>1920 x 1080</nobr> usando <i>pic_width_in_mbs_minus_1</i> con un valor de <nobr>119 ((119 + 1) * macroblock_size = 120 * 16 = 1920)</nobr> .  Nuevamente, ahorrando espacio, en lugar de codificar 1920 lo hicieron con 119. <br><br>  Si continuamos verificando nuestro video creado en forma binaria (por ejemplo: <nobr><i>xxd -b -c 11 v / minimal_yuv420.h264</i></nobr> ), entonces podemos ir al √∫ltimo NAL, que es el marco en s√≠. <br><br><img src="https://habrastorage.org/webt/fc/wt/ru/fcwtruw1ol7zkpc4osveloks_ri.png" alt="imagen"><br><br>  Aqu√≠ vemos sus primeros valores de 6 bytes: <i>01100101 10001000 10000100 00000000 00100001 11111111</i> .  Como se sabe que el primer byte indica el tipo de NAL, en este caso ( <i>00101</i> ) este es un fragmento IDR (5), y luego ser√° posible estudiarlo m√°s a fondo: <br><br><img width="604" height="458" src="https://habrastorage.org/webt/ip/67/gh/ip67gh7uuxizfnt_5oko5oowohk.png" alt="imagen"><br><br>  Usando la informaci√≥n de especificaci√≥n, ser√° posible decodificar el tipo de fragmento ( <i>slice_type</i> ) y el n√∫mero de cuadro ( <i>frame_num</i> ) entre otros campos importantes. <br><br>  Para obtener los valores de algunos campos ( <i>ue</i> ( <i>v</i> ), <i>me</i> ( <i>v</i> ), <i>se</i> ( <i>v</i> ) o <i>te</i> ( <i>v</i> )), necesitamos decodificar el fragmento utilizando un decodificador especial basado en el <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4_%25D0%2593%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B0">c√≥digo exponencial de Golomb</a> .  Este m√©todo es muy efectivo para codificar valores variables, especialmente cuando hay muchos valores predeterminados. <br><br>  Los valores <i>slice_type</i> y <i>frame_num</i> de este video son 7 (fragmento I) y 0 (primer fotograma). <br><br>  Bitstream puede considerarse como un protocolo.  Si desea saber m√°s sobre el flujo de bits, debe consultar la especificaci√≥n <b>ITU H.264</b> .  Aqu√≠ hay una macro que muestra d√≥nde est√°n los datos de la imagen ( <b>YUV</b> en forma comprimida). <br><br><img src="https://habrastorage.org/webt/sh/ka/sf/shkasfvpn80vva4jfeoxk2be1pe.png" alt="imagen"><br><br>  Puede explorar otros flujos de bits, como <b>VP9</b> , <b>H.265</b> ( <b>HEVC</b> ), o incluso nuestro nuevo mejor flujo de bits <b>AV1</b> .  ¬øSon todos iguales?  No, pero haber tratado con al menos uno es mucho m√°s f√°cil de entender el resto. <blockquote><h4>  ¬øQuieres practicar?  Explore el flujo de bits H.264 </h4><br>  Puede generar video de un solo cuadro y usar MediaInfo para examinar el flujo de bits <b>H.264</b> .  De hecho, nada le impide siquiera mirar el c√≥digo fuente que analiza el flujo de bits <b>H.264</b> ( <b>AVC</b> ). <br><br><img src="https://habrastorage.org/webt/b0/n5/7v/b0n57v_h_gb2l2m0evkrhkukr_s.png" alt="imagen"><br><br>  Para practicar, puede usar Intel Video Pro Analyzer (ya dije que el programa es de pago, pero ¬øhay una versi√≥n de prueba gratuita con un l√≠mite de 10 fotogramas?). <br><br><img src="https://habrastorage.org/webt/l9/63/ni/l963nix2wqornscrgdpzechdjq8.png" alt="imagen"></blockquote><h3>  Revisar </h3><br>  Tenga en cuenta que muchos c√≥decs modernos usan el mismo modelo que acaban de aprender.  Aqu√≠, echemos un vistazo al diagrama de bloques del c√≥dec de video <b>Thor</b> .  Contiene todos los pasos que hemos tomado.  El objetivo de esta publicaci√≥n es que al menos comprenda mejor las innovaciones y la documentaci√≥n en esta √°rea. <br><br><img width="574" height="507" src="https://habrastorage.org/webt/7q/go/1s/7qgo1so0_mld4wglqvhan3ttwei.png" alt="imagen"><br><br>  Anteriormente, se estimaba que se necesitar√≠an 139 GB de espacio en disco para almacenar un archivo de video que dura una hora con una calidad de 720p y 30 fps.  Si usa los m√©todos que se discutieron en este art√≠culo (pron√≥sticos internos y entre cuadros, conversi√≥n, cuantizaci√≥n, codificaci√≥n de entrop√≠a, etc.), entonces puede lograr (suponiendo que gastemos 0.031 bits por p√≠xel), el video es de una calidad bastante satisfactoria, que ocupa solo 367.82 MB, no 139 GB de memoria. <br><br><h3>  ¬øC√≥mo logra H.265 una mejor relaci√≥n de compresi√≥n que H.264? </h3><br>  Ahora que sabe m√°s sobre c√≥mo funcionan los c√≥decs, es m√°s f√°cil entender c√≥mo los nuevos c√≥decs pueden proporcionar una resoluci√≥n m√°s alta con menos bits. <br><br>  Al comparar <b>AVC</b> y <b>HEVC</b> , no debe olvidar que esto casi siempre es una elecci√≥n entre una mayor carga de CPU y una relaci√≥n de compresi√≥n. <br><br>  <b>HEVC</b> tiene m√°s opciones para secciones (y subsecciones) que <b>AVC</b> , m√°s instrucciones para pron√≥sticos internos, codificaci√≥n de entrop√≠a mejorada y mucho m√°s.  Todas estas mejoras hicieron que <b>H.265 fuera</b> capaz de comprimir un 50% m√°s que <b>H.264</b> . <br><br><img src="https://habrastorage.org/webt/m3/jj/x8/m3jjx88-ppzrakex1sjxlinwjx8.png" alt="imagen"><br><br><hr><br><h3>  Parte I: <a href="https://habr.com/ru/company/edison/blog/481418/">Conceptos b√°sicos de video e imagen</a> </h3><br><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/485460/"><img align="right" width="404" height="150" src="https://habrastorage.org/webt/2b/9i/gm/2b9igmgpbxunecpetjj6hhqsa9m.png"></a> <br clear="left"><h4>  Lee tambi√©n el blog <br>  Empresa EDISON: </h4><br>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>20 bibliotecas para</b></a> <a href="https://habr.com/ru/company/edison/blog/485460/"><b><br></b></a>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>espectacular aplicaci√≥n para iOS</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480430/">https://habr.com/ru/post/480430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480414/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 393 (9 al 15 de diciembre de 2019)</a></li>
<li><a href="../480416/index.html">Matem√°ticas gen√©ricas inseguras en C #</a></li>
<li><a href="../480420/index.html">Entrevista con Matthew "Oki" O'Connor sobre la aterosclerosis y su tratamiento</a></li>
<li><a href="../480422/index.html">Gu√≠a de estilo de Google en C ++. Parte 1</a></li>
<li><a href="../480424/index.html">Gu√≠a de estilo de Google en C ++. Parte 9</a></li>
<li><a href="../480432/index.html">El problema del primer espectador, o la dif√≠cil conversi√≥n de las transmisiones de video WebRTC a HLS</a></li>
<li><a href="../480438/index.html">Eventos digitales en Mosc√∫ del 16 al 22 de diciembre.</a></li>
<li><a href="../480440/index.html">Eventos digitales en San Petersburgo del 16 al 22 de diciembre.</a></li>
<li><a href="../480444/index.html">Detective Habra: 24 horas desde la vida de 24 publicaciones</a></li>
<li><a href="../480452/index.html">OWASP Moscow Meetup # 9: Registros de rendimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>