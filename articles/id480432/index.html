<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎤 ⤵️ 🥝 Masalah penampil pertama, atau sulitnya konversi aliran video WebRTC ke HLS 🗽 👨‍👩‍👧‍👦 👲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Egor menutup tutup laptop dan menggosok mata merahnya karena kurang tidur. "Pelanggan terus mengeluh tentang pembekuan aliran, paket perbaikan baru ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masalah penampil pertama, atau sulitnya konversi aliran video WebRTC ke HLS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/480432/"><p><img src="https://habrastorage.org/webt/af/bt/ar/afbtarp3iizqyc4vnhqj2dxxmte.jpeg"></p><br><p>  Egor menutup tutup laptop dan menggosok mata merahnya karena kurang tidur.  "Pelanggan terus mengeluh tentang pembekuan aliran, paket perbaikan baru tidak membantu sama sekali! Jadi apa yang harus dilakukan dengan HLS (disensor) ini?"  Dia mengatakan ke dalam kekosongan penelitian. </p><a name="habracut"></a><br><h2 id="brauzer-eto-ne-tolko-gipertekst-no-i-strimer">  Browser tidak hanya hypertext, tetapi juga streamer </h2><br><p>  Browser telah memperoleh pemain untuk waktu yang lama, tetapi dengan encoder video dan streaming ceritanya berbeda.  Sekarang, di hampir semua peramban versi terbaru, Anda dapat menemukan modul untuk penyandian, pengaliran, pengodean dan pemutaran.  Fungsi-fungsi ini tersedia melalui JavaScript API, dan implementasinya disebut Web Real Time Communications atau WebRTC.  Pustaka yang dibangun dalam peramban ini dapat melakukan banyak hal: mengambil video dari kamera internal, virtual atau USB, kompres dengan codec H.264, VP8, VP9, ​​mengirimkannya ke jaringan melalui protokol SRTP, mis.  berfungsi sebagai encoder streamer video perangkat lunak.  Sebagai hasilnya, kami melihat browser yang memiliki sesuatu yang mirip dengan ffmpeg atau gstreamer di bawah kap, yang memampatkan video dengan baik, stream pada RTP dan memainkan stream video. </p><br><p>  WebRTC memberi Anda kebebasan untuk menerapkan berbagai kasus streaming dalam JavaScript: </p><br><ul><li>  streaming aliran dari browser ke server untuk merekam dan distribusi selanjutnya </li><li>  peer-to-peer </li><li>  putar aliran pengguna lain dan kirim sendiri (obrolan video) </li><li>  konversi protokol lain oleh server, misalnya RTMP, RTSP, dll., dan mainkan di browser sebagai WebRTC </li></ul><br><p>  Skrip kontrol aliran yang disempurnakan mungkin terlihat seperti ini: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      session.createStream({name:”mystream”}).publish(); //   session.createStream({name:”mystream”}).play();</span></span></code> </pre> <br><h2 id="hls-rabotaet-tam-gde-ne-rabotaet-webrtc">  HLS Bekerja Di Mana WebRTC Tidak Bekerja </h2><br><p>  WebRTC berfungsi di versi browser terbaru, namun ada dua faktor berikut: 1) Tidak semua pengguna memperbarui browser secara tepat waktu dan mungkin duduk di semacam Chrome selama tiga tahun.  2) Hampir seminggu sekali pembaruan dirilis dan browser baru, WebView, serta klien lain dan pengirim pesan instan yang dapat menjelajahi Internet.  Tidak perlu dikatakan, tidak semua dari mereka memiliki dukungan WebRTC, dan jika ya, itu bisa sangat terpotong.  Lihat bagaimana keadaannya sekarang: </p><br><p><img src="https://habrastorage.org/webt/r8/wf/y8/r8wfy8p3nvyulliesmqnwhurhcw.png"></p><br><p>  Pisahkan sakit kepala - perangkat apel favorit semua orang.  Mereka baru-baru ini menerima dukungan untuk WebRTC dan, kadang-kadang, mengejutkan dalam perilaku mereka dibandingkan dengan browser webkit Orthodox.  Dan di mana WebRTC tidak berfungsi atau tidak bekerja dengan baik, HLS berfungsi dengan baik.  Dalam hal ini, kompatibilitas diperlukan, dan sesuatu seperti konverter yang akan mengkonversi WebRTC ke HLS dan memutarnya di hampir semua perangkat. </p><br><p>  Awalnya, HLS tidak dirancang untuk streaming real-time.  Memang, apa yang bisa menjadi waktu video melalui HTTP?  Tugas HLS adalah memotong video menjadi potongan-potongan dan mengirimkannya ke pemutar dengan lancar, tanpa terburu-buru, dengan mengunduh satu per satu.  Pemain HLS mengharapkan aliran video yang terbentuk dengan lembut dan halus.  Dan di sini konflik muncul, karena WebRTC, sebaliknya, dapat membiarkan dirinya kehilangan paket karena persyaratan waktu nyata dan latensi rendah dan memiliki FPS / GOP mengambang dan bit rate variabel - untuk menjadi kebalikan dari HLS dalam hal prediksi dan dimensi aliran. </p><br><p>  Pendekatan yang jelas - depacketization WebRTC (SRTP) dan <a href="https://flashphoner.com/vosproizvedenie-webrtc-i-rtmp-videopotokov-po-hls/%3Flang%3Dru">konversi</a> berikutnya ke HLS, mungkin tidak berfungsi di pemutar HLS Apple asli atau bekerja dalam bentuk yang tidak sesuai untuk produksi dengan jalur.  Pemain asli di sini berarti pemain yang digunakan di Apple iOS Safari, Mac OS Safari, Apple TV. </p><br><p>  Oleh karena itu, jika Anda melihat heksing HLS pada pemain asli, mungkin ini dia, dan sumber alirannya adalah WebRTC atau aliran dinamis lain dengan markup yang tidak rata.  Selain itu, dalam implementasi pemain Apple asli ada perilaku yang hanya bisa dipahami secara empiris.  Misalnya, server harus mulai mengirim segmen HLS segera, segera setelah daftar putar m3u8 dikembalikan.  Keterlambatan per detik mengancam dengan pembekuan.  Jika konfigurasi bitstream telah berubah dalam proses (yang merupakan kejadian yang cukup umum dengan streaming WebRTC), juga akan ada dekorasi. </p><br><h2 id="borba-s-frizami-v-nativnyh-pleerah">  Bertarung melawan jalur pemain asli </h2><br><p>  Dengan demikian, depacketisasi dan paketisasi WebRTC langsung dan jujur ​​di HLS umumnya tidak bekerja.  Di server video streaming <a href="https://flashphoner.com/">Web Call Server (WCS)</a> , kami memecahkan masalah dengan dua cara, dan kami menawarkan yang ketiga sebagai alternatif: </p><br><p>  1) Transcoding. </p><br><p>  Ini adalah cara paling andal untuk menyelaraskan aliran WebRTC ke persyaratan HLS, mengatur GOP, FPS yang diinginkan, dll.  Namun, dalam beberapa kasus, transcoding bukanlah solusi yang baik, misalnya transcoding 4k stream video VR adalah ide yang begitu-begitu.  Aliran berat seperti itu sangat mahal untuk ditranskrip dalam hal waktu CPU atau sumber daya GPU. </p><br><p><img src="https://habrastorage.org/webt/lk/sb/ap/lksbapmjw9cmefbwccx6l7vx3xs.png"></p><br><p>  2) Adaptasi dan penyelarasan aliran WebRTC dengan cepat di bawah persyaratan HLS. </p><br><p>  Ini adalah parser khusus yang menganalisis bitstream H.264 dan memperbaikinya untuk fitur / bug pemain HLS Apple asli.  Di sini kita harus mengakui bahwa pemain non-asli seperti video.js dan hls.js lebih toleran terhadap stream dengan bitrate dinamis dan FPS, yang merupakan WebRTC dan tidak melambat di mana implementasi referensi Apple HLS pada dasarnya jatuh ke dalam pembekuan abadi. </p><br><p><img src="https://habrastorage.org/webt/hh/c0/0j/hhc00j_fa7tj6frr5tme-rkqojg.png"></p><br><p>  3) Gunakan RTMP sebagai sumber aliran alih-alih WebRTC. </p><br><p>  Terlepas dari kenyataan bahwa flashdisk dihentikan, protokol RTMP secara aktif digunakan untuk streaming, mengambil OBS Studio yang sama.  Dan saya harus mengakui bahwa encoders RTMP secara umum menghasilkan lebih banyak stream daripada WebRTC dan oleh karena itu praktis tidak menghasilkan jalur di HLS, mis.  Mengkonversi RTMP&gt; HLS dari sudut pandang jalur terlihat jauh lebih cocok, termasuk di pemain HLS asli.  Karena itu, jika streaming dilakukan dari desktop dan OBS, maka lebih baik menggunakannya untuk konversi ke HLS.  Jika sumbernya adalah browser Chrome, maka RTMP tidak dapat digunakan tanpa menginstal plugin, dan di sini hanya WebRTC. </p><br><p><img src="https://habrastorage.org/webt/tm/ne/i2/tmnei2sj-cuw2fpw0wajlyxuz7m.png"></p><br><p>  Ketiga metode yang dijelaskan di atas diuji dan berfungsi, sehingga ada peluang untuk memilih berdasarkan kondisi tugas. </p><br><h2 id="webrtc-v-hls-na-cdn">  WebRTC ke HLS di CDN </h2><br><p>  Beberapa masalah dapat menunggu dalam sistem terdistribusi ketika beberapa server pengiriman aliran WebRTC terletak antara sumber aliran WebRTC dan pemain HLS, yaitu <a href="https://flashphoner.com/cdn-dlya-striminga-webrtc-s-nizkoj-zaderzhkoj/%3Flang%3Dru">CDN</a> , dalam kasus kami, berdasarkan pada server WCS.  Ini terlihat seperti ini: ada Origin - server yang menerima aliran WebRTC, ada Edge - server yang mendistribusikan aliran ini termasuk HLS.  Mungkin ada banyak server, yang memungkinkan penskalaan horizontal sistem.  Misalnya, 1000 server HLS dapat dihubungkan ke satu server Origin, dalam hal ini kapasitas sistem diskalakan 1000 kali. </p><br><p><img src="https://habrastorage.org/webt/nq/hq/fq/nqhqfqm9_lzyrpxtofqk89jzw6u.png"></p><br><p>  Masalahnya telah diidentifikasi sedikit lebih tinggi, dan masalah ini biasanya muncul pada pemain asli: iOS Safari, Mac OS Safari, Apple TV.  Maksud kami adalah pemain yang bekerja dengan indikasi langsung dari url daftar putar dalam tag, misalnya, <code>&lt;video src="https://host/test.m3u8"/&gt;</code> .  Segera setelah pemain meminta daftar putar, dan tindakan ini sebenarnya adalah langkah pertama dalam memainkan aliran HLS, server harus segera, tanpa penundaan, mulai mengirimkan segmen video HLS.  Jika server tidak segera mulai memberikan segmen, pemain memutuskan bahwa ia telah ditipu dan berhenti bermain.  Sekali lagi, perilaku ini adalah tipikal dari pemain HLS asli Apple, tetapi kami tidak dapat memberi tahu pengguna - “tolong jangan gunakan iPhone Mac dan Apple TV untuk memutar stream HLS”, pengguna tidak akan mengerti. </p><br><p>  Jadi, ketika Anda mencoba memainkan aliran HLS di server Edge, server harus segera mulai mengembalikan segmen, tetapi bagaimana ia akan melakukannya jika tidak memiliki aliran?  Memang, ketika mencoba memainkan streaming di server ini hilang.  Logika CDN bekerja berdasarkan prinsip Pemuatan Malas - kami tidak akan mengarahkan aliran ke server sampai seseorang meminta aliran ini di server ini.  Ada masalah yang menghubungkan pertama - yang pertama yang meminta aliran HLS dari server Edge dan memiliki kecerobohan untuk melakukan ini dari pemain asli Apple akan menerima dekorasi karena alasan bahwa butuh waktu untuk memesan aliran ini dari server Origin, untuk mendapatkannya pada Edge dan lanjutkan dengan mengiris HLS.  Bahkan jika itu membutuhkan tiga detik, pemain tidak akan menyimpannya.  Dia akan pergi ke dekorasi. </p><br><p><img src="https://habrastorage.org/webt/g9/he/wh/g9hewhbfu04ypt81daubg0qouvy.png"></p><br><p>  Di sini sekali lagi ada dua keputusan: satu adalah normal, yang lain tidak terlalu.  Seseorang dapat meninggalkan pendekatan Pemuatan Malas di CDN dan mengirim lalu lintas ke semua node, terlepas dari apakah ada pemirsa di sana atau tidak.  Sebuah solusi, mungkin cocok untuk mereka yang tidak terbatas pada sumber daya lalu lintas dan komputasi.  Asal akan mengarahkan lalu lintas ke semua server Edge, sebagai akibatnya, semua server dan jaringan di antara mereka akan terus dimuat.  Mungkin skema ini hanya cocok untuk beberapa solusi spesifik dengan sejumlah kecil arus masuk.  Saat mereplikasi sejumlah besar utas, skema semacam itu jelas akan tidak efisien sumber daya.  Dan jika Anda ingat bahwa kami hanya menyelesaikan "masalah koneksi pertama dari peramban asli", maka jelas bahwa itu tidak layak. </p><br><p><img src="https://habrastorage.org/webt/dx/n4/yf/dxn4yf28u8gtrczrshxc-smjjuq.png"></p><br><p>  Pilihan kedua lebih elegan, tetapi juga solusinya.  Kami memberi pengguna pertama gambar video yang terhubung, tetapi ini masih bukan aliran yang ingin dilihatnya - ini adalah preloader.  Karena kita harus memberikan sesuatu sekarang dan melakukannya segera, tetapi kami tidak memiliki aliran sumber (masih dipesan dan dikirim dari Asal), kami memutuskan untuk meminta klien untuk menunggu sedikit dan menunjukkan kepadanya video preloader dengan animasi bergerak.  Pengguna menunggu beberapa detik, preloader berputar, dan ketika aliran nyata tiba, pengguna mulai menunjukkan aliran nyata.  Akibatnya, pengguna pertama melihat preloader, dan yang berikutnya yang terhubung pada akhirnya melihat aliran HLS normal yang berasal dari CDN, bekerja berdasarkan prinsip Lazy Loading.  Masalah teknik diselesaikan. </p><br><h2 id="no-ne-do-konca">  Tetapi tidak sampai akhir </h2><br><p>  Tampaknya semuanya bekerja dengan baik.  CDN berfungsi, aliran HLS diambil dari server Edge edge dan masalah koneksi pertama terpecahkan.  Dan inilah jebakan lain - kami memberikan preloader dalam rasio aspek tetap 16: 9, dan CDN dapat menyertakan aliran format apa pun: 16: 9, 4: 3, 2: 1 (video VR).  Dan ini adalah masalah, karena jika Anda memberi pemain preloader dalam format 16: 9, dan aliran yang dipesan akan dalam format 4: 3, maka pemain asli lagi menunggu dekorasi. </p><br><p>  Oleh karena itu, tugas baru muncul - Anda perlu tahu dengan rasio aspek apa aliran memasuki CDN dan memberikan preloader dalam rasio yang sama.  Fitur aliran WebRTC adalah pelestarian aspek rasio ketika mengubah resolusi dan selama transcoding - jika browser memutuskan untuk menurunkan resolusi, itu menurunkannya dalam rasio yang sama.  Jika server memutuskan untuk mentranskode aliran, itu menjaga rasio aspek dalam proporsi yang sama.  Oleh karena itu, masuk akal jika kita ingin menunjukkan preloader untuk HLS, kami menunjukkannya dalam rasio aspek yang sama di mana aliran masuk. </p><br><p><img src="https://habrastorage.org/webt/kn/ee/dr/kneedrbpqw4mfyrvrnpxufev0ui.png"></p><br><p>  CDN berfungsi sebagai berikut: ketika lalu lintas memasuki server Origin, ia menginformasikan server lain di jaringan, termasuk server Edge, tentang aliran baru.  Masalahnya adalah bahwa pada titik ini, resolusi aliran sumber mungkin belum diketahui.  Resolusi dilakukan oleh konfigurasi H.264 bitstream bersama dengan bingkai kunci.  Oleh karena itu, dapat terjadi bahwa server Edge menerima informasi bahwa ada aliran, tetapi tidak akan tahu tentang resolusi dan rasio aspeknya, yang tidak akan memungkinkannya untuk menghasilkan preloader dengan benar.  Dalam hal ini, perlu memberi sinyal keberadaan aliran di CDN hanya jika ada bingkai kunci - ini dijamin untuk memberikan informasi ukuran server Edge dan memungkinkan preloader yang benar dihasilkan untuk mencegah "masalah penampil yang terhubung pertama". </p><br><p><img src="https://habrastorage.org/webt/vh/uy/aw/vhuyawuhtqsmyc8zg806egppu6i.png"></p><br><h2 id="itogi">  Ringkasan </h2><br><p>  Konversi WebRTC ke HLS umumnya memberikan jalur ketika diputar di pemain Apple asli.  Masalahnya diselesaikan dengan menganalisis dan menyesuaikan bitstream H.264 dengan persyaratan HLS Apple, baik transcoding, atau menggunakan migrasi ke protokol RTMP dan encoder sebagai sumber aliran.  Dalam jaringan terdistribusi dengan lazy loading stream, ada masalah dengan viewer pertama yang terhubung, yang diselesaikan menggunakan preloader dan menentukan resolusi di sisi server Origin - titik masuk dari stream di CDN. </p><br><h2 id="ssylki">  Referensi </h2><br><p>  <a href="https://flashphoner.com/">Server Panggilan Web</a> - Server WebRTC </p><br><p>  <a href="https://flashphoner.com/cdn-dlya-striminga-webrtc-s-nizkoj-zaderzhkoj/%3Flang%3Dru">Latensi Rendah WebRTC Streaming</a> CDN - CDN Berbasis WCS </p><br><p>  <a href="https://flashphoner.com/vosproizvedenie-webrtc-i-rtmp-videopotokov-po-hls/%3Flang%3Dru">Putar stream video WebRTC dan RTMP melalui HLS</a> - Fungsi server untuk mengonversi streaming dari berbagai sumber ke HLS </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480432/">https://habr.com/ru/post/id480432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480420/index.html">Wawancara dengan Matthew "Oki" O'Connor tentang Atherosclerosis dan Perawatannya</a></li>
<li><a href="../id480422/index.html">Panduan Gaya Google di C ++. Bagian 1</a></li>
<li><a href="../id480424/index.html">Panduan Gaya Google di C ++. Bagian 9</a></li>
<li><a href="../id480428/index.html">Metode steno paling sederhana. Alfabet dan font untuknya.</a></li>
<li><a href="../id480430/index.html">Cara kerja codec video. Bagian 2. Apa, mengapa, bagaimana</a></li>
<li><a href="../id480440/index.html">Acara digital di St. Petersburg dari 16 hingga 22 Desember</a></li>
<li><a href="../id480444/index.html">Detektif Habra: 24 jam dari kehidupan 24 publikasi</a></li>
<li><a href="../id480446/index.html">Menulis reverse proxy Grafana on Go</a></li>
<li><a href="../id480452/index.html">Pertemuan # 9 OWASP Moscow: Catatan Kinerja</a></li>
<li><a href="../id480454/index.html">Hack The Box - Smasher2 Walkthrough Labu, WAF, dan LPE melalui driver pwn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>