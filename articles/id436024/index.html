<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘§ ğŸ¤¾ğŸ» ğŸ–ï¸ Bagaimana tidak membuang sampah sembarangan di Jawa ğŸ™‡ğŸ¼ ğŸ³ï¸â€ğŸŒˆ ğŸ•¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada kesalahpahaman yang populer bahwa jika Anda tidak suka pengumpulan sampah, maka Anda perlu menulis bukan di Jawa, tetapi di C / C ++. Selama tiga ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana tidak membuang sampah sembarangan di Jawa</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436024/"><p>  Ada kesalahpahaman yang populer bahwa jika Anda tidak suka pengumpulan sampah, maka Anda perlu menulis bukan di Jawa, tetapi di C / C ++.  Selama tiga tahun terakhir saya telah menulis kode Java latensi rendah untuk perdagangan mata uang, dan saya harus menghindari membuat objek yang tidak perlu dalam segala hal.  Sebagai hasilnya, saya merumuskan beberapa aturan sederhana untuk diri saya sendiri, bagaimana mengurangi alokasi di Jawa, jika tidak ke nol, kemudian ke beberapa minimum yang masuk akal, tanpa menggunakan manajemen memori manual.  Mungkin itu juga akan berguna bagi seseorang dari komunitas. </p><a name="habracut"></a><br><h2>  Mengapa menghindari sampah sama sekali </h2><br><p>  Tentang apa itu GC dan bagaimana mengkonfigurasinya, katanya dan banyak ditulis.  Tetapi pada akhirnya, tidak peduli bagaimana Anda mengatur GC, kode yang membuang sampah akan bekerja secara optimal.  Selalu ada trade-off antara throughput dan latensi.  Menjadi tidak mungkin untuk memperbaiki yang satu tanpa memperburuk yang lain.  Sebagai aturan, overhead GC diukur dengan mempelajari log - Anda dapat memahami dari mereka pada saat-saat apa ada jeda dan berapa banyak waktu yang dibutuhkan.  Namun, log GC tidak mengandung semua informasi tentang overhead ini.  Objek yang dibuat oleh utas secara otomatis ditempatkan di cache L1 inti prosesor di mana utas berjalan.  Ini mengarah pada crowding out dari data lain yang berpotensi berguna.  Dengan sejumlah besar alokasi, data yang berguna juga dapat didorong keluar dari cache L3.  Lain kali utas mengakses data ini, akan terjadi cache yang hilang, yang akan menyebabkan keterlambatan dalam pelaksanaan program.  Selain itu, karena cache L3 adalah umum untuk semua core dalam prosesor yang sama, aliran sampah akan mendorong data dan utas / aplikasi lain dari cache L3, dan mereka sudah akan mengalami kegagalan cache yang lebih mahal, bahkan jika mereka ditulis dalam bare C dan jangan membuat sampah.  Tidak ada pengaturan, tidak ada pengumpul sampah (baik C4, maupun ZGC) tidak akan membantu mengatasi masalah ini.  Satu-satunya cara untuk memperbaiki situasi secara keseluruhan adalah dengan tidak membuat objek yang tidak perlu.  Java, tidak seperti C ++, tidak memiliki banyak sekali mekanisme untuk bekerja dengan memori, namun demikian, ada sejumlah cara untuk meminimalkan alokasi.  Mereka akan dibahas. </p><br><div class="spoiler">  <b class="spoiler_title">Penyimpangan liris</b> <div class="spoiler_text"><p>  Tentu saja, Anda tidak perlu menulis semua kode bebas sampah.  Hal tentang bahasa Jawa adalah Anda dapat sangat menyederhanakan hidup Anda hanya dengan membuang sumber sampah utama.  Anda juga tidak dapat menangani reklamasi memori yang aman saat menulis algoritma bebas kunci.  Jika kode tertentu dijalankan hanya sekali pada saat startup aplikasi, maka kode tersebut dapat mengalokasikan sebanyak yang Anda suka, dan itu bukan masalah besar.  Dan tentu saja, alat kerja utama untuk membuang kelebihan sampah adalah pengalokasian alokasi. </p></div></div><br><h2>  Menggunakan tipe primitif </h2><br><p> Hal paling sederhana yang dapat dilakukan dalam banyak kasus adalah menggunakan tipe primitif daripada tipe objek.  JVM memiliki sejumlah optimisasi untuk meminimalkan overhead tipe objek, seperti caching nilai kecil tipe integer dan inlining kelas sederhana.  Tetapi optimisasi ini tidak selalu layak untuk diandalkan, karena mereka mungkin tidak berhasil: nilai integer mungkin tidak di-cache, dan inlining mungkin tidak terjadi.  Selain itu, ketika bekerja dengan Integer bersyarat, kami dipaksa untuk mengikuti tautan, yang berpotensi mengarah pada cache miss.  Juga, semua objek memiliki tajuk yang mengambil ruang ekstra di cache, memadatkan data lain dari sana.  Mari kita ambil: int primitif membutuhkan 4 byte.  Object <code>Integer</code> menempati 16 byte + ukuran tautan ke Integer ini adalah minimum 4 byte (dalam kasus oops terkompresi).  Secara total, ternyata <code>Integer</code> membutuhkan lima (!) Kali lebih banyak ruang daripada <code>int</code> .  Karena itu, lebih baik menggunakan tipe primitif sendiri.  Saya akan memberikan beberapa contoh. </p><br><h3>  Contoh 1. Perhitungan konvensional </h3><br><p>  Katakanlah kita memiliki fungsi reguler yang hanya menghitung sesuatu. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer a, Integer b, Integer c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><p>  Kode seperti itu cenderung menjadi sebaris (baik metode dan kelas) dan tidak akan mengarah pada alokasi yang tidak perlu, tetapi Anda tidak dapat memastikan hal ini.  Bahkan jika ini terjadi, akan ada masalah dengan fakta bahwa <code>NullPointerException</code> bisa terbang keluar dari sini.  Salah satu cara atau yang lain, JVM harus memasukkan cek <code>null</code> bawah tenda, atau entah bagaimana memahami dari konteks bahwa <code>null</code> tidak dapat datang sebagai argumen.  Bagaimanapun, lebih baik menulis kode yang sama pada primitif. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><h3>  Contoh 2. Lambdas </h3><br><p>  Terkadang benda diciptakan tanpa sepengetahuan kita.  Misalnya, jika kita meneruskan tipe primitif ke tempat tipe objek diharapkan.  Ini sering terjadi ketika menggunakan ekspresi lambda. <br>  Bayangkan kita memiliki kode ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;Integer&gt; calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Terlepas dari kenyataan bahwa variabel x adalah primitif, objek bertipe Integer akan dibuat, yang akan diteruskan ke kalkulator.  Untuk menghindarinya, gunakan <code>IntConsumer</code> sebagai ganti <code>Consumer&lt;Integer&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IntConsumer calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Kode semacam itu tidak akan lagi mengarah pada penciptaan objek tambahan.  Java.util.function memiliki seluruh rangkaian antarmuka standar yang disesuaikan untuk menggunakan tipe primitif: <code>DoubleSupplier</code> , <code>LongFunction</code> , dll.  Nah, jika ada sesuatu yang hilang, maka Anda selalu dapat menambahkan antarmuka yang diinginkan dengan primitif.  Misalnya, alih-alih <code>BiConsumer&lt;Integer, Double&gt;</code> Anda bisa menggunakan antarmuka buatan. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntDoubleConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>; }</code> </pre> <br><h3>  Contoh 3. Koleksi </h3><br><p>  Menggunakan tipe primitif bisa jadi sulit karena variabel tipe ini ada dalam koleksi.  Misalkan kita memiliki beberapa <code>List&lt;Integer&gt;</code> dan kami ingin mengetahui angka apa yang ada di dalamnya dan menghitung berapa kali masing-masing angka diulang.  Untuk ini, kami menggunakan <code>HashMap&lt;Integer, Integer&gt;</code> .  Kode ini terlihat seperti ini: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Map&lt;Integer, Integer&gt; counters = new HashMap&lt;&gt;(); for (Integer x : numbers) { counters.compute(x, (k, v) -&gt; v == null ? 1 : v + 1); }</span></span></code> </pre> <br><p>  Kode ini buruk dalam beberapa cara sekaligus.  Pertama, ia menggunakan struktur data perantara, yang mungkin bisa dilakukan tanpa.  Baiklah, oke, untuk kesederhanaan, kita mengasumsikan bahwa daftar ini akan dibutuhkan nanti, mis.  Anda tidak dapat sepenuhnya menghapusnya.  Kedua, objek <code>Integer</code> digunakan di kedua tempat bukan <code>int</code> primitif.  Ketiga, ada banyak alokasi dalam metode <code>compute</code> .  Keempat, iterator dialokasikan.  Alokasi ini cenderung menjadi inline, namun demikian.  Bagaimana mengubah kode ini menjadi kode bebas sampah?  Anda hanya perlu menggunakan koleksi pada primitif dari beberapa perpustakaan pihak ketiga.  Ada sejumlah perpustakaan yang berisi koleksi seperti itu.  Sepotong kode berikut menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">agrona</a> . </p><br><pre> <code class="java hljs">IntArrayList numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntArrayList(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Int2IntCounterMap counters = new Int2IntCounterMap(0); for (int i = 0; i &lt; numbers.size(); i++) { counters.incrementAndGet(numbers.getInt(i)); }</span></span></code> </pre> <br><p>  Objek yang dibuat di sini adalah dua koleksi dan dua <code>int[]</code> , yang terletak di dalam koleksi ini.  Kedua koleksi dapat digunakan kembali dengan memanggil metode <code>clear()</code> pada mereka.  Menggunakan koleksi pada primitif, kami tidak mempersulit kode kami (dan bahkan menyederhanakannya dengan menghapus metode komputasi dengan lambda kompleks di dalamnya) dan menerima bonus tambahan berikut dibandingkan dengan menggunakan koleksi standar: </p><br><ol><li>  Hampir tidak ada alokasi sama sekali.  Jika koleksi digunakan kembali, maka tidak akan ada alokasi sama sekali. </li><li>  Penghematan memori yang signifikan ( <code>IntArrayList</code> membutuhkan ruang sekitar lima kali lebih sedikit daripada <code>ArrayList&lt;Integer&gt;</code> . Seperti yang telah disebutkan, kami peduli tentang penggunaan cache prosesor yang ekonomis, bukan RAM. </li><li>  Akses serial ke memori.  Banyak yang telah ditulis pada topik mengapa ini penting, jadi saya tidak akan berhenti di situ.  Berikut adalah beberapa artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Martin Thompson</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ulrich Drepper</a> . </li></ol><br><p>  Komentar kecil lainnya tentang koleksi.  Mungkin ternyata koleksi tersebut berisi nilai dari tipe yang berbeda, dan oleh karena itu tidak mungkin untuk menggantinya dengan koleksi dengan primitif.  Menurut pendapat saya, ini adalah tanda desain yang buruk dari struktur data atau algoritma secara keseluruhan.  Kemungkinan besar dalam hal ini, alokasi objek tambahan bukanlah masalah utama. </p><br><h2>  Benda yang bisa berubah </h2><br><p>  Tetapi bagaimana jika primitif tidak dapat ditiadakan?  Sebagai contoh, jika metode yang kita butuhkan harus mengembalikan beberapa nilai.  Jawabannya sederhana - gunakan benda yang bisa berubah. </p><br><div class="spoiler">  <b class="spoiler_title">Penyimpangan kecil</b> <div class="spoiler_text"><p>  Beberapa bahasa menekankan penggunaan objek yang tidak dapat diubah, misalnya dalam Scala.  Argumen utama yang mendukung mereka adalah bahwa penulisan kode multithread sangat disederhanakan.  Namun, ada juga overhead yang terkait dengan alokasi sampah yang berlebihan.  Jika kita ingin menghindarinya, maka kita seharusnya tidak membuat objek abadi yang berumur pendek. </p></div></div><br><p>  Seperti apa praktiknya?  Misalkan kita perlu menghitung hasil bagi dan sisa divisi.  Dan untuk ini kami menggunakan kode berikut. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } <span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Bagaimana cara menyingkirkan alokasi dalam kasus ini?  Itu benar, lulus <code>IntPair</code> sebagai argumen dan tulis hasilnya di sana.  Dalam hal ini, Anda perlu menulis javadoc terperinci, dan bahkan lebih baik lagi, menggunakan semacam konvensi untuk nama variabel, di mana hasilnya ditulis.  Misalnya, mereka dapat mulai dengan awalan keluar.  Kode bebas sampah dalam hal ini akan terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor, IntPair outResult)</span></span></span><span class="hljs-function"> </span></span>{ outResult.x = value / divisor; outResult.y = value % divisor; }</code> </pre> <br><p>  Saya ingin mencatat bahwa metode <code>divide</code> tidak boleh menyimpan tautan untuk memasangkan di mana saja atau meneruskannya ke metode yang dapat melakukan ini, jika tidak kita mungkin memiliki masalah besar.  Seperti yang dapat kita lihat, objek yang dapat berubah lebih sulit digunakan daripada tipe primitif, jadi jika Anda dapat menggunakan primitif, maka lebih baik melakukannya.  Faktanya, dalam contoh kami, kami memindahkan masalah alokasi dari dalam metode pembagian ke luar.  Di semua tempat di mana kita memanggil metode ini, kita perlu memiliki beberapa boneka <code>IntPair</code> , yang akan kita <code>divide</code> untuk <code>divide</code> .  Cukup sering untuk menyimpan boneka ini di bidang <code>final</code> objek, dari mana kita memanggil metode <code>divide</code> .  Izinkan saya memberi Anda sebuah contoh yang tidak masuk akal: misalkan program kami hanya berurusan dengan menerima aliran angka melalui jaringan, membaginya, dan mengirimkan hasilnya ke soket yang sama. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SocketListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntPair pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BufferedReader in; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PrintWriter out; SocketListener(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Socket socket) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> IOException { in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(socket.getInputStream())); out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(socket.getOutputStream(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); divide(value, divisor, pair); out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  Untuk singkatnya, saya tidak menulis kode "ekstra" untuk penanganan kesalahan, penghentian program yang benar, dll.  Ide utama dari potongan kode ini adalah bahwa objek <code>IntPair</code> kita <code>IntPair</code> dibuat satu kali dan disimpan di bidang <code>final</code> . </p><br><h2>  Kolam objek </h2><br><p>  Ketika kita menggunakan objek yang bisa berubah, pertama-tama kita harus mengambil objek kosong dari suatu tempat, kemudian menulis data yang kita butuhkan, menggunakannya di suatu tempat, dan kemudian mengembalikan objek "di tempat".  Dalam contoh di atas, objek selalu "di tempat", mis.  di bidang <code>final</code> .  Sayangnya, ini tidak selalu mungkin dilakukan dengan cara yang sederhana.  Sebagai contoh, kita mungkin tidak tahu sebelumnya berapa banyak objek yang kita butuhkan.  Dalam hal ini, kumpulan objek datang untuk membantu kami.  Ketika kita membutuhkan objek kosong, kita mendapatkannya dari kumpulan objek, dan ketika itu tidak lagi dibutuhkan, kita mengembalikannya ke sana.  Jika tidak ada objek gratis di kolam, maka kolam menciptakan objek baru.  Ini sebenarnya manajemen memori manual dengan semua konsekuensi berikutnya.  Dianjurkan untuk tidak menggunakan metode ini jika dimungkinkan untuk menggunakan metode sebelumnya.  Apa yang bisa salah? </p><br><ul><li>  Kita bisa lupa mengembalikan objek ke kolam, dan kemudian sampah ("kebocoran memori") akan dibuat.  Ini adalah masalah kecil - kinerja akan sedikit menurun, tetapi GC akan berhasil dan program akan terus bekerja. </li><li>  Kita dapat mengembalikan objek ke kolam, tetapi menyimpan tautan ke suatu tempat.  Maka orang lain akan mendapatkan objek dari kolam, dan pada titik ini dalam program kami sudah ada dua tautan ke objek yang sama.  Ini adalah masalah klasik setelah penggunaan gratis.  Sulit untuk debut karena  tidak seperti C ++, program tidak akan macet dan akan terus bekerja secara <em>salah</em> . </li></ul><br><p>  Untuk mengurangi kemungkinan melakukan kesalahan di atas, Anda dapat menggunakan konstruk try-with-resources standar.  Ini mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T object)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STORAGE.get(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  Metode pembagian mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = IntPair.create(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Dan metode <code>listenSocket</code> seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IntPair pair = divide(value, divisor)) { out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  Dalam IDE, Anda biasanya dapat mengonfigurasi sorotan semua kasus ketika objek <code>AutoCloseable</code> digunakan di luar blok coba-dengan-sumber daya.  Tapi ini bukan pilihan mutlak, karena  menyoroti dalam IDE hanya bisa dimatikan.  Oleh karena itu, ada cara lain untuk menjamin kembalinya objek ke inversi kontrol kolam.  Saya akan memberi contoh: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;IntPair&gt; consumer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>(IntPair pair = STORAGE.get()) { consumer.accept(pair); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  Dalam hal ini, pada dasarnya kami tidak dapat mengakses objek dari kelas <code>IntPair</code> luar.  Sayangnya, metode ini juga tidak selalu berhasil.  Misalnya, itu tidak akan berfungsi jika satu utas mengambil objek dari pool dan menempatkannya dalam antrian, dan utas lainnya mengeluarkannya dari antrian dan kembali ke pool. </p><br><p>  Jelas, jika kita tidak menyimpan objek generik di kumpulan, tetapi beberapa objek perpustakaan yang tidak mengimplementasikan <code>AutoCloseable</code> , maka opsi coba-dengan-sumber daya tidak akan berfungsi baik. </p><br><p>  Masalah tambahan di sini adalah multithreading.  Implementasi pool objek harus sangat cepat, yang cukup sulit untuk dicapai.  Kolam yang lambat bisa lebih merusak kinerja daripada kebaikan.  Pada gilirannya, alokasi objek baru di TLAB sangat cepat, jauh lebih cepat daripada malloc di C. Menulis kumpulan objek cepat adalah topik terpisah yang tidak ingin saya kembangkan sekarang.  Saya hanya bisa mengatakan bahwa saya belum melihat implementasi "siap pakai" yang bagus. </p><br><h2>  Alih-alih sebuah kesimpulan </h2><br><p>  Singkatnya, menggunakan kembali objek dengan kolam objek adalah wasir yang serius.  Untungnya, hampir selalu Anda dapat melakukannya tanpanya.  Pengalaman pribadi saya adalah bahwa penggunaan objek yang berlebihan menandakan masalah dengan arsitektur aplikasi.  Sebagai aturan, satu contoh objek yang di-cache di bidang <code>final</code> sudah cukup bagi kita.  Tetapi bahkan ini berlebihan jika memungkinkan untuk menggunakan tipe primitif. </p><br><h2>  Perbarui: </h2><br><p>  Ya, saya ingat cara lain bagi mereka yang tidak takut dengan perubahan bitwise: mengemas beberapa tipe primitif kecil menjadi yang besar.  Misalkan kita perlu mengembalikan dua <code>int</code> .  Dalam kasus khusus ini, Anda tidak dapat menggunakan objek <code>IntPair</code> , tetapi mengembalikan satu <code>long</code> , 4 byte pertama di mana akan sesuai dengan <code>int</code> pertama, dan yang kedua 4 byte ke yang kedua.  Kode mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)left &lt;&lt; Integer.SIZE) | (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)right &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFFL</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(value &gt;&gt;&gt; Integer.SIZE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = value / divisor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> combine(left, right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> xy = divide(value, divisor); out.print(getLeft(xy)); out.print(getRight(xy)); } }</code> </pre> <br><p>  Metode seperti itu, tentu saja, perlu diuji secara menyeluruh, karena cukup mudah untuk menuliskannya.  Tapi kemudian gunakan saja. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436024/">https://habr.com/ru/post/id436024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436012/index.html">Saya idiot yang tidak berguna, jadi saya ingin berhenti dari pekerjaan saya: 10 pertanyaan untuk pengembang perangkat lunak, episode percontohan</a></li>
<li><a href="../id436014/index.html">Model Matematika Kekacauan</a></li>
<li><a href="../id436016/index.html">Asterisk Voice Recognition IVR - Cepat, Mudah, Gratis</a></li>
<li><a href="../id436020/index.html">Magento 2: mengimpor produk dari sumber eksternal</a></li>
<li><a href="../id436022/index.html">Bagaimana Kami Mengembangkan Librem 5 DevKit Sepenuhnya dalam Perangkat Lunak Bebas</a></li>
<li><a href="../id436026/index.html">Info Desk: "Internet Archive" - â€‹â€‹proyek sejarah, misi dan anak perusahaan</a></li>
<li><a href="../id436028/index.html">Pengantar Kubernetes untuk pengguna VMware. Bagian 1. Teori</a></li>
<li><a href="../id436032/index.html">Bereaksi Tutorial Bagian 9: Properti Komponen</a></li>
<li><a href="../id436036/index.html">Bisakah para peneliti kecerdasan buatan mempercayakannya pada tes pekerjaan mereka?</a></li>
<li><a href="../id436038/index.html">Suara kesunyian: berapa banyak gadget gila yang diperlukan untuk mencapai lingkungan yang optimal untuk tidur?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>