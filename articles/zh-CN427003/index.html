<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏾 🤞🏿 🌻 Unity中的六边形地图：战争迷雾，地图研究，程序生成 🎉 🤴 👩🏼‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第1-3部分：网格，颜色和像元高度 

 第4-7部分：颠簸，河流和道路 

 第8-11部分：水，地貌和城墙 

 第12-15部分：保存和加载，纹理，距离 

 第16-19部分：找到道路，队员，动画 

 第20-23部分：战争迷雾，地图研究，程序生成 

 第24-27部分：水循环，侵蚀，生...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity中的六边形地图：战争迷雾，地图研究，程序生成</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427003/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1-3部分：网格，颜色和像元高度</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4-7部分：颠簸，河流和道路</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8-11部分：水，地貌和城墙</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第12-15部分：保存和加载，纹理，距离</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第16-19部分：找到道路，队员，动画</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20-23部分：战争迷雾，地图研究，程序生成</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24-27部分：水循环，侵蚀，生物群落，圆柱图</a> <br><br><h1> 第20部分：战争迷雾 </h1><br><ul><li> 将单元格数据保存在纹理中。 </li><li> 更改浮雕类型而无需三角剖分。 </li><li> 我们跟踪可见度。 </li><li> 使所有看不见的东西变暗。 </li></ul><br> 在这一部分中，我们将向地图添加战争迷雾效果。 <br><br> 现在，该系列将在Unity 2017.1.0上创建。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg"></div><br>  <i>现在我们看到可以看到，不能看到。</i> <br><a name="habracut"></a><br><h2> 着色器中的单元数据 </h2><br> 许多策略游戏都使用战争迷雾概念。 这意味着玩家的视力受到限制。 他只能看到靠近他的单位或控制区域的东西。 尽管我们可以看到救济，但我们不知道那里发生了什么。 通常，看不见的地形会变暗。 为了实现这一点，我们需要跟踪单元的可见性并进行相应渲染。 <br><br> 更改隐藏单元格外观的最简单方法是向网格数据添加可见性度量。 但是，与此同时，我们将不得不开始新的浮雕三角剖分，以改变可见度。 这是一个错误的决定，因为在游戏过程中可见性一直在变化。 <br><br> 通常使用在半透明表面的地形上渲染的技术，该技术部分掩盖了玩家看不见的单元。 该方法适用于相对平坦的地形，并具有有限的视角。 但是，由于我们的地形可以包含高度不同的高度和可以从不同角度查看的对象，因此，我们需要一个高度详细的网格，以匹配地形的形状。 该方法将比上述最简单的方法昂贵。 <br><br> 另一种方法是在与浮雕网格物体分开渲染时将单元的数据传输到着色器。 这将使我们仅执行一次三角剖分。 可以使用纹理传输单元格数据。 更改纹理比对地形进行三角剖分要简单得多。 此外，执行多个其他纹理样本比渲染单个半透明层要快。 <br><br><div class="spoiler">  <b class="spoiler_title">使用着色器数组怎么办？</b> <div class="spoiler_text"> 您还可以使用向量数组将单元格数据传输到着色器。 但是，着色器阵列有大小限制，以数千个字节为单位，并且纹理可以包含数百万个像素。 为了支持大型地图，我们将使用纹理。 </div></div><br><h3> 细胞数据管理 </h3><br> 我们需要一种方法来控制包含单元格数据的纹理。 让我们创建一个新的<code>HexCellShaderData</code>组件来执行此操作。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; }</code> </pre> <br> 在创建或加载新地图时，我们需要创建具有正确尺寸的新纹理。 因此，我们添加了一个初始化方法来为其创建纹理。 我们使用没有Mip纹理和线性色彩空间的RGBA纹理。 我们不需要混合单元格数据，因此我们使用点过滤。 此外，数据不应折叠。 纹理中的每个像素将包含来自一个单元的数据。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">纹理大小是否应与地图大小匹配？</b> <div class="spoiler_text"> 不，它只需要有足够的像素来容纳所有单元。 与地图的大小完全匹配时，很可能会创建大小不是2的幂（非2的幂，NPOT）的纹理，并且这种纹理格式不是最有效的。 尽管我们可以将代码配置为使用2的幂的纹理进行处理，但这是次要的优化，这使对单元数据的访问变得复杂。 </div></div><br> 实际上，我们不必每次创建新地图时都创建新纹理。 如果纹理已经存在，则足以调整其大小。 我们甚至不需要检查我们是否已经具有合适的尺寸，因为<code>Texture2D.Resize</code>足够聪明地为我们做到这一点。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( cellCountX, cellCountZ, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; } }</code> </pre> <br> 我们使用颜色缓冲区并一次应用所有单元的数据，而不是一次应用一个像素的单元数据。 为此，我们将使用<code>Color32</code>数组。 如有必要，我们将在<code>Initialize</code>的末尾创建一个新的数组实例。 如果我们已经有一个正确大小的数组。 然后我们清除其内容。 <br><br><pre> <code class="cs hljs"> Texture2D cellTexture; Color32[] cellTextureData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || cellTextureData.Length != x * z) { cellTextureData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32[x * z]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellTextureData.Length; i++) { cellTextureData[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">什么是color32？</b> <div class="spoiler_text"> 标准的未压缩RGBA纹理包含四个字节的像素。 四个颜色通道的每个接收一个字节，即它们具有256个可能的值。 使用Unity <code>Color</code>结构时，其在区间0–1中的浮点分量将转换为在区间0–255中的字节。 采样时，GPU执行逆变换。 <br><br>  <code>Color32</code>结构直接与字节一起使用，因此它们占用的空间更少，并且不需要转换，从而提高了使用效率。 由于我们存储的是单元格数据而不是颜色，因此直接使用原始纹理数据而不是使用<code>Color</code>更加合乎逻辑。 </div></div><br>  <code>HexGrid</code>应该处理着色器中这些单元的创建和初始化。 因此，我们将向其添加一个<code>cellShaderData</code>字段，并在<code>Awake</code>创建一个组件。 <br><br><pre> <code class="cs hljs"> HexCellShaderData cellShaderData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); CreateMap(cellCountX, cellCountZ); }</code> </pre> <br> 创建新地图时，还应<code>cellShaderData</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; cellShaderData.Initialize(cellCountX, cellCountZ); CreateChunks(); CreateCells(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3> 编辑单元格数据 </h3><br> 到目前为止，在更改单元格的属性时，有必要更新一个或几个片段，但是现在可能有必要更新单元格的数据。 这意味着单元必须具有指向着色器中单元数据的链接。 为此，向<code>HexCell</code>添加一个属性。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCellShaderData ShaderData { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br> 在<code>HexGrid.CreateCell</code>我们<code>HexGrid.CreateCell</code>为该属性分配一个着色器数据组件。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.ShaderData = cellShaderData; … }</code> </pre> <br> 现在我们可以使单元更新其着色器数据。 虽然我们不跟踪可见性，但可以将着色器数据用于其他用途。 单元的浮雕类型确定用于渲染它的纹理。 它不会影响像元的几何形状，因此我们可以将高程类型索引存储在像元数据中，而不是存储在网格数据中。 这将使我们在更改单元格拓扑的类型时无需进行三角剖分。 <br><br> 向<code>RefreshTerrain</code>添加<code>HexCellShaderData</code>方法可简化特定单元格的此任务。 让我们暂时将此方法留空。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br> 更改<code>HexCell.TerrainTypeIndex</code>以便它<code>HexCell.TerrainTypeIndex</code>此方法，并且不按顺序更新片段。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Refresh(); ShaderData.RefreshTerrain(this); } } }</span></span></code> </pre> <br> 收到单元格的地形类型后，我们还将在<code>HexCell.Load</code>中将其<code>HexCell.Load</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); RefreshPosition(); … }</code> </pre> <br><h3> 细胞指数 </h3><br> 要更改这些单元格，我们需要知道单元格的索引。 最简单的方法是将<code>Index</code>属性添加到<code>HexCell</code> 。 它将指示贴图的单元格列表中该单元格的索引，该索引与其在着色器中给定单元格中的索引相对应。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br> 该索引已经在<code>HexGrid.CreateCell</code> ，因此只需将其分配给创建的单元格即可。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; … }</code> </pre> <br> 现在<code>HexCellShaderData.RefreshTerrain</code>可以使用此索引来指定单元格数据。 通过简单地将类型转换为字节，让我们将高程类型索引保存在其像素的alpha分量中。 这将支持多达256种地形，对我们而言已经足够。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; }</code> </pre> <br> 要将数据应用于纹理并将其传递给GPU，我们需要调用<code>Texture2D.SetPixels32</code> ，然后调用<code>Texture2D.Apply</code> 。 与片段的情况一样，我们将这些操作推迟到<code>LateUpdate</code>以使它们每帧最多可以执行一次，而与更改的单元格数量无关。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 为确保在创建新映射后将更新数据，请在初始化后启用组件。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3> 三角化细胞指数 </h3><br> 由于我们现在将高程类型索引存储在这些单元格中，因此不再需要在三角测量过程中包括它们。 但是，为了使用单元数据，着色器必须知道要使用哪些索引。 因此，您需要将单元格索引存储在网格数据中，以替换高程类型索引。 另外，使用这些像元时，我们仍然需要网格的颜色通道来混合像元。 <br><br> 我们<code>useTerrainTypes</code> <code>HexMesh</code>过时的公共字段<code>useColors</code>和<code>useTerrainTypes</code> 。 用一个<code>useCellData</code>字段替换它们。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public bool useCollider, useColors, useUVCoordinates, useUV2Coordinates; // public bool useTerrainTypes; public bool useCollider, useCellData, useUVCoordinates, useUV2Coordinates;</span></span></code> </pre><br> 我们将<code>terrainTypes</code>列表的重命名重构为<code>cellIndices</code> 。 让我们也将<code>colors</code>重构为<code>cellWeights</code>这个名称会更好。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes; // [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;Vector3&gt; vertices, cellIndices; [NonSerialized] List&lt;Color&gt; cellWeights; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; [NonSerialized] List&lt;int&gt; triangles;</span></span></code> </pre><br> 更改<code>Clear</code>以便在使用这些单元格时将两个列表放在一起，而不是分开。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { cellWeights = ListPool&lt;Color&gt;.Get(); cellIndices = ListPool&lt;Vector3&gt;.Get(); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // colors = ListPool&lt;Color&gt;.Get(); // } if (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } if (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } // if (useTerrainTypes) { // terrainTypes = ListPool&lt;Vector3&gt;.Get(); // } triangles = ListPool&lt;int&gt;.Get(); }</span></span></code> </pre> <br> 在<code>Apply</code>执行相同的分组。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { hexMesh.SetColors(cellWeights); ListPool&lt;Color&gt;.Add(cellWeights); hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, cellIndices); ListPool&lt;Vector3&gt;.Add(cellIndices); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // hexMesh.SetColors(colors); // ListPool&lt;Color&gt;.Add(colors); // } if (useUVCoordinates) { hexMesh.SetUVs(0, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } if (useUV2Coordinates) { hexMesh.SetUVs(1, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } // if (useTerrainTypes) { // hexMesh.SetUVs(2, terrainTypes); // ListPool&lt;Vector3&gt;.Add(terrainTypes); // } hexMesh.SetTriangles(triangles, 0); ListPool&lt;int&gt;.Add(triangles); hexMesh.RecalculateNormals(); if (useCollider) { meshCollider.sharedMesh = hexMesh; } }</span></span></code> </pre> <br> 让我们删除所有的<code>AddTriangleColor</code>和<code>AddTriangleTerrainTypes</code> 。 将它们替换为适当的<code>AddTriangleCellData</code>方法，该方法一次添加索引和权重。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddTriangleCellData(indices, weights, weights, weights); }</code> </pre> <br> 在适当的<code>AddQuad</code>方法中执行相同的<code>AddQuad</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3, Color weights4 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); cellWeights.Add(weights4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2 </span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights1, weights1, weights2, weights2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights, weights, weights, weights); }</code> </pre> <br><h3>  HexGridChunk重构 </h3><br> 在此阶段，我们在<code>HexGridChunk</code>中遇到了许多需要<code>HexGridChunk</code>的编译器错误。 但是首先，为了保持一致，我们将静态颜色重构为重物。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br> 让我们从修复<code>TriangulateEdgeFan</code>开始。 他曾经需要一个类型，但是现在他需要一个单元格索引。  <code>AddTriangleColor</code>相应的<code>AddTriangleCellData</code>代码<code>AddTriangleColor</code>和<code>AddTriangleCellData</code>代码。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); terrain.AddTriangle(center, edge.v2, edge.v3); terrain.AddTriangle(center, edge.v3, edge.v4); terrain.AddTriangle(center, edge.v4, edge.v5); Vector3 indices; indices.x = indices.y = indices.z = index; terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = type; // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br> 在很多地方都调用此方法。 让我们遍历它们，确保将单元格的索引转移到那里，而不是地形的类型。 <br><br><pre> <code class="cs hljs"> TriangulateEdgeFan(center, e, cell.Index);</code> </pre> <br> 接下来是<code>TriangulateEdgeStrip</code> 。 这里的一切都比较复杂，但是我们使用相同的方法。 还将参数名称<code>c1</code>和<code>c2</code>重构为<code>w1</code>和<code>w2</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color w1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, EdgeVertices e2, Color w2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); Vector3 indices; indices.x = indices.z = index1; indices.y = index2; terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // Vector3 types; // types.x = types.z = type1; // types.y = type2; // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); if (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</span></span></code> </pre> <br> 更改对此方法的调用，以便将单元格索引传递给他们。 我们还保持变量名称的一致性。 <br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip( m, weights1, cell.Index, e, weights1, cell.Index ); … TriangulateEdgeStrip( e1, weights1, cell.Index, e2, weights2, neighbor.Index, hasRoad ); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w2 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i1 = beginCell.Index; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i2 = endCell.Index; TriangulateEdgeStrip(begin, weights1, i1, e2, w2, i2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color w1 = w2; e2 = EdgeVertices.TerraceLerp(begin, end, i); w2 = HexMetrics.TerraceLerp(weights1, weights2, i); TriangulateEdgeStrip(e1, w1, i1, e2, w2, i2, hasRoad); } TriangulateEdgeStrip(e2, w2, i1, end, weights2, i2, hasRoad); }</code> </pre> <br> 现在我们继续角度方法。 这些更改很简单，但是需要使用大量代码进行。 首先是<code>TriangulateCorner</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); Vector3 indices; indices.x = bottomCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangleCellData(indices, weights1, weights2, weights3); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, weights2, weights3); // Vector3 types; // types.x = bottomCell.TerrainTypeIndex; // types.y = leftCell.TerrainTypeIndex; // types.z = rightCell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</span></span></code> </pre> <br> 来到<code>TriangulateCornerTerraces</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w3 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w4 = HexMetrics.TerraceLerp(weights1, weights3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleCellData(indices, weights1, w3, w4); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, w3, w4); // terrain.AddTriangleTerrainTypes(indices); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color w1 = w3; Color w2 = w4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); w3 = HexMetrics.TerraceLerp(weights1, weights2, i); w4 = HexMetrics.TerraceLerp(weights1, weights3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadCellData(indices, w1, w2, w3, w4); // terrain.AddQuadColor(w1, w2, w3, w4); // terrain.AddQuadTerrainTypes(indices); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadCellData(indices, w3, w4, weights2, weights3); // terrain.AddQuadColor(w3, w4, weights2, weights3); // terrain.AddQuadTerrainTypes(indices); }</span></span></code> </pre> <br> 然后在<code>TriangulateCornerTerracesCliff</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryWeights = Color.Lerp(weights1, weights3, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( begin, weights1, left, weights2, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryColor); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br> 与<code>TriangulateCornerCliffTerraces</code>有所不同。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryWeights = Color.Lerp(weights1, weights2, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( right, weights3, begin, weights1, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryWeights); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br> 前两种方法使用<code>TriangulateBoundaryTriangle</code> ，这也需要更新。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginWeights, Vector3 left, Color leftWeights, Vector3 boundary, Color boundaryWeights, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleCellData(indices, beginWeights, w2, boundaryWeights); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(beginColor, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color w1 = w2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleCellData(indices, w1, w2, boundaryWeights); // terrain.AddTriangleColor(c1, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleCellData(indices, w2, leftWeights, boundaryWeights); // terrain.AddTriangleColor(c2, leftColor, boundaryColor); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br> 最后需要更改的方法是<code>TriangulateWithRiver</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangle(centerL, m.v1, m.v2); terrain.AddQuad(centerL, center, m.v2, m.v3); terrain.AddQuad(center, centerR, m.v3, m.v4); terrain.AddTriangle(centerR, m.v4, m.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; terrain.AddTriangleCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = cell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); … }</span></span></code> </pre> <br> 为了使一切正常工作，我们需要指出，我们将使用单元数据作为预制碎片浮雕的子元素。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/b8c/731/919b8c7317b2aa3c06f1077eef27fe96.png"></div><br>  <i>救济使用单元格数据。</i> <br><br> 在此阶段，网格包含单元索引而不是高程类型索引。 由于高程着色器仍将它们解释为高程索引，因此我们将看到第一个像元是使用第一个纹理渲染的，依此类推，直到到达最后一个浮雕纹理为止。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/a23/ce8/8a5a23ce850af789e759dde6879f93eb.png"></div><br>  <i>使用像元索引作为高程纹理索引。</i> <br><br><div class="spoiler">  <b class="spoiler_title">我无法使重构代码正常工作。</b>  <b class="spoiler_title">我做错了什么？</b> <div class="spoiler_text"> 一次，我们更改了大量的三角剖分代码，因此很可能出现错误或疏忽。 如果找不到错误，请尝试从本节下载程序包并提取适当的文件。 您可以将它们导入一个单独的项目中，并与自己的代码进行比较。 </div></div><br><h3> 将单元格数据传输到着色器 </h3><br> 要使用这些单元，地形着色器必须可以访问它们。 可以通过shader属性实现。 这将需要<code>HexCellShaderData</code>设置浮雕的材质属性。 或者，我们可以使所有着色器全局可见这些单元的纹理。 这很方便，因为我们需要多个着色器，所以我们将使用此方法。 <br><br> 创建单元纹理后，调用静态<code>Shader.SetGlobalTexture</code>方法以使其全局可见为<em>_HexCellData</em> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } … }</code> </pre> <br> 使用shader属性时，Unity通过<em>textureName_TexelSize</em>变量使纹理大小可用于着色器。 这是一个四分量矢量化器，包含与宽度和高度以及宽度和高度本身相反的值。 但是在设置全局纹理时，不会执行此操作。 因此，在创建或调整纹理大小之后，我们将使用<code>Shader.SetGlobalVector</code>自己进行处理。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } Shader.SetGlobalVector( <span class="hljs-string"><span class="hljs-string">"_HexCellData_TexelSize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(<span class="hljs-number"><span class="hljs-number">1f</span></span> / x, <span class="hljs-number"><span class="hljs-number">1f</span></span> / z, x, z) );</code> </pre> <br><h3> 着色器数据访问 </h3><br> 在名为<em>HexCellData</em>的材质文件夹中创建一个新的着色器包含文件。 在其中，我们定义变量以获取有关这些单元的纹理和大小的信息。 我们还创建了一个函数来获取给定顶点网格数据的像元数据。 <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _HexCellData; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> _HexCellData_TexelSize; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> GetCellData (appdata_full v) { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/604/dbc/a64604dbc7d3ad5ff1e1578bd0c84eec.png"></div><br>  <i>新的包含文件。</i> <br><br> 像地形类型<code>v.texcoord2</code> ，单元<code>v.texcoord2</code>存储在<code>v.texcoord2</code> 。 让我们从第一个索引<code>v.texcoord2.x</code> 。 不幸的是，我们不能直接使用索引来采样这些单元的纹理。 我们将不得不将其转换为UV坐标。 <br><br> 创建U坐标的第一步是将单元格索引除以纹理的宽度。 我们可以通过将其乘以<code>_HexCellData_TexelSize.x</code> 。 <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">appdata_full v</span></span></span><span class="hljs-function">)</span></span> { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果将是ZU形式的数字，其中Z是行索引，U是U单元的坐标。</font><font style="vertical-align: inherit;">我们可以通过将数字四舍五入然后从数字中减去来获得U坐标来提取字符串。</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V坐标将线除以纹理的高度。 </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们正在采样纹理，因此需要在像素中心而不是边缘使用坐标。</font><font style="vertical-align: inherit;">这样，我们保证可以对正确的像素进行采样。</font><font style="vertical-align: inherit;">因此，除以纹理大小后，加½。</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = (v.texcoord2.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这为顶点数据中存储的第一个单元格的索引提供了正确的UV坐标。</font><font style="vertical-align: inherit;">但最重要的是，我们最多可以有三个不同的索引。</font><font style="vertical-align: inherit;">因此，我们将使其</font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适用于任何索引。</font><font style="vertical-align: inherit;">向其添加一个整数参数</font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们将使用该</font><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">访问带有单元格索引的向量分量。</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们已经拥有了这些单元格的所有必要坐标，我们可以进行采样</font></font><code>_HexCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于我们正在顶点程序中对纹理进行采样，因此我们需要显式告诉着色器要使用哪个mip纹理。</font><font style="vertical-align: inherit;">这可以使用</font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要四个纹理坐标的</font><font style="vertical-align: inherit;">函数来完成</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于这些单元格没有mip纹理，因此我们将零值分配给额外的坐标。</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> data = tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四个数据组件包含一个高程类型索引，我们直接将其存储为字节。</font><font style="vertical-align: inherit;">但是，GPU会自动将其转换为0-1范围内的浮点值。</font><font style="vertical-align: inherit;">要将其转换回正确的值，请乘以255。之后，您可以返回数据。</font></font><br><br><pre> <code class="hljs kotlin"> float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = tex2Dlod(_HexCellData, float4(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.w *= <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用此功能，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器中</font><em><font style="vertical-align: inherit;">启用HexCellData</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于我将此着色器放置在“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">材质/地形”中</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此需要使用相对路径</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">../HexCellData.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs lisp"> #include <span class="hljs-string"><span class="hljs-string">"../HexCellData.cginc"</span></span> UNITY_DECLARE_TEX2DARRAY(<span class="hljs-name"><span class="hljs-name">_MainTex</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在顶点程序中，我们获取存储在顶点数据中的所有三个像元索引的像元数据。</font><font style="vertical-align: inherit;">然后分配</font></font><code>data.terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其海拔指数。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); // data.terrain = v.texcoord2.xyz; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.terrain.x = cell0.w; data.terrain.y = cell1.w; data.terrain.z = cell2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此时，地图再次开始显示正确的地形。</font><font style="vertical-align: inherit;">最大的区别在于，仅编辑地形类型将不再导致新的三角剖分。</font><font style="vertical-align: inherit;">如果在编辑期间更改了其他任何单元格数据，则将照常执行三角剖分。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 能见度 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建了这些单元的基础之后，我们可以继续支持可见性。</font><font style="vertical-align: inherit;">为此，我们使用着色器，单元格本身以及确定可见性的对象。</font><font style="vertical-align: inherit;">请注意，三角剖分过程对此一无所知。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从告诉</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地形</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">可见性开始。</font><font style="vertical-align: inherit;">它将从顶点程序接收可见性数据，并使用该结构将其传递给片段程序</font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于我们传递了三个单独的海拔指数，因此我们还将传递三个可见性值。</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float4 color : <span class="hljs-type"><span class="hljs-type">COLOR</span></span>; float3 worldPos; float3 terrain; float3 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了存储可见性，我们使用这些单元格的第一个组件。 </font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { UNITY_INITIALIZE_OUTPUT(Input, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); float4 cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); float4 cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); float4 cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.x = cell0.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.y = cell1.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.z = cell2.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可见性0表示该单元格当前不可见。</font><font style="vertical-align: inherit;">如果可见，它将具有可见性1的值。因此，我们可以通过将结果乘以</font></font><code>GetTerrainColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相应的可见性矢量</font><font style="vertical-align: inherit;">来使地形变暗</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我们分别调整每个混合单元的浮雕颜色。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/183/e69/1bf183e695a42f4691f63cec72255993.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细胞变成黑色。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难道我们不能在顶点程序中结合可见性吗？</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这也是可能的，在这种情况下，片段程序只需要传输一个可见性指示器。</font><font style="vertical-align: inherit;">当为参与混合的每个小区传输指标时，三个地形样本将被单独混合。</font><font style="vertical-align: inherit;">结果，可见细胞将对混合区域做出更大贡献。</font><font style="vertical-align: inherit;">使用一个指标时，必须首先执行混合，然后应用最终的内插可见性。</font><font style="vertical-align: inherit;">两种方法都可以使用，但是在视觉上它们是不同的。</font></font></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全黑暗是暂时看不见细胞的半身像。</font><font style="vertical-align: inherit;">为了我们仍然可以看到缓解，我们需要增加用于隐藏单元格的指标。</font><font style="vertical-align: inherit;">让我们从0–1移至¼– 1，这可以使用</font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顶点程序末尾</font><font style="vertical-align: inherit;">的函数来完成</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/090/3e2/a200903e2f31f3bdcd0c996d42f91a02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阴影细胞。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单元可见性跟踪 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使可见性起作用，单元必须跟踪其可见性。但是细胞如何确定它是否可见？我们可以通过跟踪看到它的实体数量来做到这一点。当某人开始看到一个单元格时，他必须报告该单元格。当某人停止看到牢房时，还必须通知她。该单元只是跟踪观察者的数量，无论这些实体是什么。如果单元格的可见性值至少为1，则它是可见的，否则它是不可见的。为了实现此行为，我们向</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">添加了</font><font style="vertical-align: inherit;">两个方法和一个属性。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visibility; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，添加到</font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它与的功能相同</font></font><code>RefreshTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，只是为了可见。</font><font style="vertical-align: inherit;">将数据保存在数据单元的组件R中。</font><font style="vertical-align: inherit;">由于我们使用的字节将被转换为值0-1，因此我们用来表示可见性</font></font><code>(byte)255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将通过增加和减少可见性（在0到1之间更改值）来调用此方法。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建班组可见度 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们使它们能够看到它们所占据的单元。</font><font style="vertical-align: inherit;">这可以通过</font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在任务执行期间</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">单元的新位置来完成</font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们还要求使用旧位置（如果存在）</font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.IncreaseVisibility(); transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/f95/a07/7bcf95a07fdf4c10ed1d53055dddf6a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单位可以看到他们在哪里。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们使用可见性！</font><font style="vertical-align: inherit;">单位添加到地图后，其单元格将可见。</font><font style="vertical-align: inherit;">此外，它们的范围在移动到新位置时会被传送。</font><font style="vertical-align: inherit;">但是，从地图上删除单位时，它们的作用域仍然有效。</font><font style="vertical-align: inherit;">为了解决这个问题，我们将在销毁单位时降低其位置的可见性。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); } location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 能见度范围 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们仅看到分离所在的单元，这限制了可能性。至少我们需要看到相邻的单元格。在一般情况下，单位可以看到一定距离内的所有单元，具体取决于单位。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们添加到该</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法中，以考虑到范围，找到一个单元格中所有可见的单元格。我们可以通过复制和更改来创建此方法</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。更改其参数，并使其返回可以使用列表池的单元格列表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每次迭代时，当前单元格都会添加到列表中。最终单元不再存在，因此搜索到此为止将永远不会结束。我们还摆脱了移动的逻辑和移动的成本。制作属性</font></font><code>PathFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们不再被问到是因为我们不需要它们，我们也不想干扰沿着网格的路径。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每一步中，距离仅增加1。如果超出范围，则跳过该单元格。</font><font style="vertical-align: inherit;">而且，我们不需要搜索启发式算法，因此可以将其初始化为0值。也就是说，实质上，我们返回了Dijkstra算法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; visibleCells = ListPool&lt;HexCell&gt;.Get(); searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; visibleCells.Add(current); <span class="hljs-comment"><span class="hljs-comment">// if (current == toCell) { // return true; // } // int currentTurn = (current.Distance - 1) / speed; for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); if ( neighbor == null || neighbor.SearchPhase &gt; searchFrontierPhase ) { continue; } // … // int moveCost; // … int distance = current.Distance + 1; if (distance &gt; range) { continue; } // int turn = (distance - 1) / speed; // if (turn &gt; currentTurn) { // distance = turn * speed + moveCost; // } if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; // neighbor.PathFrom = current; neighbor.SearchHeuristic = 0; searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); } } } return visibleCells; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不能使用更简单的算法来查找范围内的所有像元吗？</font></font></b> <div class="spoiler_text"> ,          ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还要添加</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他们获取单元格和范围，获取相应单元格的列表，并增加/减少其可见性。</font><font style="vertical-align: inherit;">完成后，他们应将列表返回到其池中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].IncreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].DecreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用这些方法，</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要访问网格，因此请向其添加一个属性</font></font><code>Grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将小队添加到网格时，它将为该属性分配一个网格</font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，三个单元格的可见范围就足够了。</font><font style="vertical-align: inherit;">为此，我们添加了</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常量，将来它总是可以变成变量。</font><font style="vertical-align: inherit;">然后，我们将使小队针对网格</font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">调用方法，</font><font style="vertical-align: inherit;">并</font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递其可见性范围，而不仅仅是到这个地方。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visionRange = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { <span class="hljs-comment"><span class="hljs-comment">// location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); location.Unit = null; } location = value; value.Unit = this; // value.IncreaseVisibility(); Grid.IncreaseVisibility(value, visionRange); transform.localPosition = value.Position; } } … public void Die () { if (location) { // location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); } location.Unit = null; Destroy(gameObject); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/c45/ccb/8cdc45ccb01449b3c7d50a7bef9b249c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能见度范围可以重叠的单位。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 移动时能见度 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此刻，移动命令后的班组可见区域立即传送到终点。</font><font style="vertical-align: inherit;">如果该单元及其可见区域一起移动，则效果会更好。</font><font style="vertical-align: inherit;">第一步是我们将不再设置属性</font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexUnit.Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">相反，我们将直接更改字段</font></font><code>location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，避免使用属性代码。</font><font style="vertical-align: inherit;">因此，我们将手动清除旧位置并配置新位置。</font><font style="vertical-align: inherit;">可见性将保持不变。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Location = path[path.Count - 1]; location.Unit = null; location = path[path.Count - 1]; location.Unit = this; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在协程内部，</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有完成后</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">我们才会降低第一个单元格的可见性</font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">之后，在移至新单元之前，我们将增加该单元的可见性。</font><font style="vertical-align: inherit;">完成此操作后，我们再次降低了可见度。</font><font style="vertical-align: inherit;">最后，增加最后一个单元格的可见性。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// transform.localPosition = c; yield return LookAt(pathToTravel[1].Position); Grid.DecreaseVisibility(pathToTravel[0], visionRange); float t = Time.deltaTime * travelSpeed; for (int i = 1; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - 1].Position; c = (b + pathToTravel[i].Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= 1f; } a = c; b = location.Position; // We can simply use the destination here. c = b; Grid.IncreaseVisibility(location, visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动中的可见性。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有这一切都有效，除了在分队移动时发出新订单时。</font><font style="vertical-align: inherit;">这导致隐形传态，这也应适用于能见度。</font><font style="vertical-align: inherit;">为了实现这一点，我们需要在移动时跟踪小队的当前位置。</font></font><br><br><pre> <code class="cs hljs"> HexCell location, currentTravelLocation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每当我们在移动中命中一个新单元时，我们都会更新此位置，直到班长到达最后一个单元为止。</font><font style="vertical-align: inherit;">然后必须将其重置。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + currentTravelLocation.Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Grid.IncreaseVisibility(pathToTravel[i], visionRange); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在完成上交之后，</font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以检查路径的旧中间位置是否已知。</font><font style="vertical-align: inherit;">如果是，那么您需要降低此单元格中的可见性，而不是路径的开头。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; Grid.DecreaseVisibility( currentTravelLocation ? currentTravelLocation : pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>], visionRange ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还需要校正小队移动期间重新编译后的可见性。</font><font style="vertical-align: inherit;">如果中间位置仍然是已知的，则减小其中的可见性并增加端点处的可见性，然后重置中间位置。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTravelLocation) { Grid.IncreaseVisibility(location, visionRange); Grid.DecreaseVisibility(currentTravelLocation, visionRange); currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 道路和水的可见性 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管浮雕颜色的更改基于可见性，但这不会影响道路和水。</font><font style="vertical-align: inherit;">对于看不见的细胞，它们看起来太亮了。</font><font style="vertical-align: inherit;">若要将可见性应用于道路和水，我们需要在其网格数据中添加像元索引和混合权重。</font><font style="vertical-align: inherit;">因此，我们将检查</font><font style="vertical-align: inherit;">预制碎片</font><font style="vertical-align: inherit;">的</font><em><font style="vertical-align: inherit;">河流</font></em><font style="vertical-align: inherit;">，</font><em><font style="vertical-align: inherit;">道路</font></em><font style="vertical-align: inherit;">，</font><em><font style="vertical-align: inherit;">水</font></em><font style="vertical-align: inherit;">，</font><em><font style="vertical-align: inherit;">水岸</font></em><font style="vertical-align: inherit;">和</font><em><font style="vertical-align: inherit;">河口</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用单元数据</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的子级</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 道路 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将从道路开始。</font><font style="vertical-align: inherit;">该方法</font></font><code>HexGridChunk.TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于在单元中心创建道路的一小部分，因此它需要一个单元索引。</font><font style="vertical-align: inherit;">向其添加参数并生成三角形的单元格数据。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); Vector3 indices; indices.x = indices.y = indices.z = index; roads.AddTriangleCellData(indices, weights1); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建道路的另一种简单方法是</font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它在单元内部和单元之间使用，因此应与两个不同的索引一起使用。</font><font style="vertical-align: inherit;">为此，使用索引向量参数很方便。</font><font style="vertical-align: inherit;">由于路段可以是壁架的一部分，因此权重也必须通过参数传递。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6, Color w1, Color w2, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadCellData(indices, w1, w2); roads.AddQuadCellData(indices, w1, w2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们继续到</font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它会在单元内部创建道路。</font><font style="vertical-align: inherit;">它还需要一个索引参数。</font><font style="vertical-align: inherit;">他将此数据传递给他调用的道路方法，并将其添加到他创建的三角形中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 indices; indices.x = indices.y = indices.z = index; Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment( mL, mC, mR, e.v2, e.v3, e.v4, weights1, weights1, indices ); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleCellData(indices, weights1); roads.AddTriangleCellData(indices, weights1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR, index); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它仍然添加所需的方法参数</font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纠正所有的编译器错误。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction), cell.Index ); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL, cell.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center, cell.Index); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> … </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment( e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4, w1, w2, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在网格数据正确，我们将继续使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它需要一个顶点程序，并且必须包含</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">decal</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:blend</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">HexCellData</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cginc</span></span>"</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 由于我们没有混合几种材料，因此将一个可见性指标传递给片段程序就足够了。 </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> {</span></span> float2 uv_MainTex; float3 worldPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个新的顶点程序足以从两个单元中接收数据。</font><font style="vertical-align: inherit;">我们立即混合它们的可见性，对其进行调整并添加到输出中。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在片段程序中，我们只需要增加颜色的可见性即可。 </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/92f/46e/af892f46e364906cc547aaecb4e50e3a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有能见度的道路。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开水 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可见性似乎已经影响了水，但这只是浸入水中的地形表面。</font><font style="vertical-align: inherit;">让我们从对开放水域应用可见性开始。</font><font style="vertical-align: inherit;">为此，我们需要改变</font></font><code>HexGridChunk.TriangulateOpenWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, c1, c2); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … water.AddQuad(c1, c2, e1, e2); indices.y = neighbor.Index; water.AddQuadCellData(indices, weights1, weights2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { … water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); indices.z = nextNeighbor.Index; water.AddTriangleCellData( indices, weights1, weights2, weights3 ); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们还需要向靠近海岸的三角形的扇形添加单元数据。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要以与“ </font><em><font style="vertical-align: inherit;">道路”</font></em><font style="vertical-align: inherit;">着色器相同的方式更改</font><font style="vertical-align: inherit;">“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色</font><font style="vertical-align: inherit;">器</font><font style="vertical-align: inherit;">，但是它需要合并的可视性不是两个，而是三个单元。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/c52/36c/6a4c5236c52eaae78cbde54fb2fdeeac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开阔水面能见度。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 海岸和河口 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了支持海岸，我们需要再次改变</font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们已经创建了索引向量，但是对于开放水域，我们仅使用了一个细胞索引。</font><font style="vertical-align: inherit;">海岸也需要邻居索引，因此请更改代码。</font></font><br><br><pre> <code class="cs hljs"> Vector3 indices; <span class="hljs-comment"><span class="hljs-comment">// indices.x = indices.y = indices.z = cell.Index; indices.x = indices.z = cell.Index; indices.y = neighbor.Index;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将像元数据添加到海岸的四边形和三角形。</font><font style="vertical-align: inherit;">我们还会在通话中传递索引</font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … waterShore.AddTriangleUV( … ); indices.z = nextNeighbor.Index; waterShore.AddTriangleCellData( indices, weights1, weights2, weights3 ); }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向海岸和河口</font><font style="vertical-align: inherit;">添加必要的参数</font><font style="vertical-align: inherit;">并照顾这些细胞。</font><font style="vertical-align: inherit;">不要忘记，嘴是梯形的，侧面有两个三角形的海岸。</font><font style="vertical-align: inherit;">我们确保权重以正确的顺序传输。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadCellData( indices, weights2, weights1, weights2, weights1 ); estuaries.AddTriangleCellData(indices, weights1, weights2, weights2); estuaries.AddQuadCellData(indices, weights1, weights2); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WaterShore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器中，</font><em><font style="vertical-align: inherit;">您</font></em><font style="vertical-align: inherit;">需要进行与</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器相同的更改</font><font style="vertical-align: inherit;">，同时混合三个单元的可见性。</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢德</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">河口</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个细胞混合的知名度，以及着色</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路概述</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他已经有了一个顶点程序，因为我们需要他来传输河流的UV坐标。</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.visibility = cell0.x * v.color.x + cell1.x * v.color.y; o.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, o.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88f/829/254/88f829254235a293040ac755d8318bc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">海岸和河口具有可见性。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河流 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后可以使用的水域是河流。</font><font style="vertical-align: inherit;">将</font></font><code>HexGridChunk.TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">索引向量</font><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">参数并将其添加到网格，以便它可以保持两个像元的可见性。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed, indices); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br> <code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建在单元格中心具有四边形和三角形的河流端点。</font><font style="vertical-align: inherit;">为此添加必要的单元格数据。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; Vector3 indices; indices.x = indices.y = indices.z = cell.Index; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); … rivers.AddTriangleCellData(indices, weights1); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经有这些单元格索引</font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此我们只在调用时传递它们</font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed, indices ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们还为倒入深水的瀑布添加了索引支持。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，对其进行更改，</font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便将必要的索引传递给河流和瀑布方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { e2.v3.y = neighbor.StreamBedY; Vector3 indices; indices.x = indices.z = cell.Index; indices.y = neighbor.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY, indices ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY, indices ); } } … }</code> </pre> <br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">需要进行与</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器相同的更改</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ef/db6/76a/1efdb676afe28b61b73f317d25158505.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有能见度的河流。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对象和可见性 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，可见性适用于整个过程生成的地形，但是到目前为止，它不影响地形特征。建筑物，农场和树木是由预制件而非程序几何创建的，因此我们无法添加单元索引并将权重与其顶点混合。由于这些对象仅属于一个单元格，因此我们需要确定它们位于哪个单元格中。如果可以做到这一点，那么我们将可以访问相应单元格的数据并应用可见性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经可以将世界的XZ位置转换为单元格索引。此转换用于编辑地形和管理小队。但是，相应的代码并不简单。它使用整数运算，并且需要逻辑来处理边。这对于着色器来说是不切实际的，因此我们可以烘焙纹理中的大部分逻辑并使用它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经在使用具有六边形图案的纹理来将网格投影到地形上。此纹理定义了2×2的单元格区域。因此，我们可以轻松计算出我们在哪个区域。之后，您可以为该区域中的单元格应用包含X和Z偏移量的纹理，并使用此数据来计算我们所在的单元格。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是类似的纹理。 X偏移量存储在其红色通道中，Z偏移量存储在绿色通道中。由于它覆盖2×2单元的面积，因此我们需要从0和2开始的偏移量。此类数据无法存储在颜色通道中，因此偏移量减少了一半。我们不需要透明的单元格边缘，因此小的纹理就足够了。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/63c/d3c/79563cd3c22e7aa2ca66e40b5ffe3f7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格坐标的纹理。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向项目添加纹理。</font><font style="vertical-align: inherit;">设置其“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包裹模式”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，就像其他网格纹理一样。</font><font style="vertical-align: inherit;">我们不需要任何混合，因此对于</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合模式，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将选择</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同时关闭</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">压缩</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以使数据不失真。</font><font style="vertical-align: inherit;">关闭</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sRGB</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式，</font><font style="vertical-align: inherit;">以便在线性模式下渲染时，不执行颜色空间转换。</font><font style="vertical-align: inherit;">最后，我们不需要MIP纹理。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/866/aa9/de3/866aa9de36f6953f54d4fb8197fb75ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理导入选项。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 具有可见性的对象着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个新的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特征</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">以向对象添加可见性支持。</font><font style="vertical-align: inherit;">这是带有顶点程序的简单表面着色器。</font><font style="vertical-align: inherit;">向其中添加</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将可见性指示器传递给片段程序，然后像往常一样将其视为彩色。</font><font style="vertical-align: inherit;">区别在于我们无法使用</font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它，因为所需的网格数据不存在。</font><font style="vertical-align: inherit;">相反，我们在世界上占有一席之地。</font><font style="vertical-align: inherit;">但是，暂时将可见度设置为1。</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Feature" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [NoTilingOffset] _GridCoordinates ("Grid Coordinates", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" sampler2D _MainTex, _GridCoordinates; half _Glossiness; half _Metallic; fixed4 _Color; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更改对象的所有材质，以使它们使用新的着色器并为其分配网格坐标的纹理。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/fad/546/e35fad5469e6c9e5c6a31626ba182ec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城市与网格纹理。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 访问单元格数据 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了在顶点程序中采样网格坐标的纹理，我们再次需要</font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个四分量纹理坐标向量。</font><font style="vertical-align: inherit;">前两个坐标是XZ世界的位置。</font><font style="vertical-align: inherit;">如前所述，其他两个等于零。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器中一样</font><font style="vertical-align: inherit;">，我们拉伸UV坐标，以使纹理具有与六边形网格相对应的正确纵横比。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过取四舍五入的UV坐标值，可以找出2×2单元格中的哪个部分。</font><font style="vertical-align: inherit;">这构成了细胞坐标的基础。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); float2 cellDataCoordinates = floor(gridUV.xy);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了找到我们所在的单元的坐标，我们添加了存储在纹理中的位移。 </font></font><br><br><pre> <code class="hljs pgsql"> float2 cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 由于网格的一部分大小为2×2，并且偏移量减半，因此我们需要将结果加倍以获得最终坐标。 </font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">float2</span></span> cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg; <span class="hljs-attribute"><span class="hljs-attribute">cellDataCoordinates</span></span> *= <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了单元格的XZ坐标，我们需要将其转换为这些单元的UV坐标。</font><font style="vertical-align: inherit;">这可以通过简单地移动到像素的中心，然后将它们划分为纹理大小来完成。</font><font style="vertical-align: inherit;">因此，我们</font><font style="vertical-align: inherit;">为此</font><font style="vertical-align: inherit;">添加一个</font><font style="vertical-align: inherit;">功能到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含文件中</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">也将处理采样。</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { float2 uv = cellDataCoordinates + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; uv.x *= _HexCellData_TexelSize.x; uv.y *= _HexCellData_TexelSize.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以在顶点着色器程序使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的功能</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs haskell"> cellDataCoordinates *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCellData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cellDataCoordinates</span></span></span><span class="hljs-class">).x; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/9c9/7ed/1ed9c97ed37aa88aaee6c0efd9d075d7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有可见性的对象。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，可见性会影响整个地图，但始终可见的单位除外。由于我们确定每个顶点的对象的可见性，因此对于穿过单元格边界的对象，将关闭其关闭的单元格的可见性。但是物体是如此之小，以至于即使考虑到位置的变形，它们也始终保留在其内部。但是，有些可能是另一个单元中顶点的一部分。因此，我们的方法便宜但不完善。这在墙壁的情况下最为明显，墙壁的可见性在相邻单元的可见性之间变化。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/1c7/f7d/4211c7f7dea80bbbd13664586074c43a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能见度不断变化的墙。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于墙段是按程序生成的，因此我们可以将单元格数据添加到其网格中，并使用用于浮雕的方法。</font><font style="vertical-align: inherit;">不幸的是，这些塔是预制的，因此我们仍然会有不一致之处。</font><font style="vertical-align: inherit;">概括而言，对于我们使用的简单几何图形，现有方法看起来足够好。</font><font style="vertical-align: inherit;">将来，我们将考虑更详细的模型和墙，因此，我们将改进混合其可见性的方法。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第21部分：地图研究 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在编辑过程中显示所有内容。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们跟踪调查的细胞。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们隐藏了仍然未知的东西。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们强迫部队避开未开发的区域。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在上一部分中，我们添加了战争迷雾，现在将对其进行细化以实施地图研究。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81d/40e/bff/81d40ebff615fc7c4e39a15d88da016d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们准备探索世界。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在编辑模式下显示整个地图 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该研究的意义在于，直到看不见细胞之前，都被认为是未知的，因此是不可见的。</font><font style="vertical-align: inherit;">它们不应被遮盖，但根本不显示。</font><font style="vertical-align: inherit;">因此，在添加研究支持之前，我们将在编辑模式下启用可见性。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可见性切换 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用关键字控制着色器是否使用可见性，就像在网格上进行覆盖一样。</font><font style="vertical-align: inherit;">让我们使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键字来</font><font style="vertical-align: inherit;">指示编辑模式的状态。</font><font style="vertical-align: inherit;">由于一些着色器应该知道此关键字，因此我们将使用静态方法</font></font><code>Shader.EnableKeyWord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和进行</font><font style="vertical-align: inherit;">全局定义</font></font><code>Shader.DisableKeyword</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>HexGameUI.SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改编辑模式时，</font><font style="vertical-align: inherit;">我们将调用适当的方法</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toggle) { Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Shader.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编辑模式着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定着色器会忽略外观。</font><font style="vertical-align: inherit;">这归结为一个事实，即单元格可见性将始终被视为等于1。让我们添加一个</font><font style="vertical-align: inherit;">函数，以根据</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> include-file开头</font><font style="vertical-align: inherit;">的关键字来过滤单元格的数据。</font></font><br><br><pre> <code class="hljs kotlin">sampler2D _HexCellData; float4 _HexCellData_TexelSize; float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在返回它之前</font><font style="vertical-align: inherit;">，我们将这两个函数的结果传递给该函数</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(data); } <span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使一切正常工作，所有的着色器都必须接收multi_compile指令才能创建选项，以防</font><font style="vertical-align: inherit;">定义</font><font style="vertical-align: inherit;">了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键字</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在目标指令和第一个include指令之间，</font><font style="vertical-align: inherit;">将适当的行添加到着色器</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，当切换到地图编辑模式时，战争迷雾将消失。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 细胞研究 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，应将单元格视为未开发单元。</font><font style="vertical-align: inherit;">当小队看到他们时，他们就会被探索。</font><font style="vertical-align: inherit;">此后，如果分队可以看到他们，他们将继续接受调查。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 追踪学习状态 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了增加对监视研究状态的支持，我们在</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规属性中</font><font style="vertical-align: inherit;">添加</font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研究的状态由细胞本身决定。</font><font style="vertical-align: inherit;">因此，应仅设置此属性</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要添加此限制，我们将设置器设置为私有。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元格的可见性首次大于零时，便开始考虑对该单元格进行调查，因此</font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应分配一个值</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际上，当可见性增加到1时，仅将单元标记为已检查就足够了。这必须在call之前完成</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { IsExplored = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将研究状态转移到着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与细胞可见性一样，我们通过着色器数据将其研究状态转移到着色器。</font><font style="vertical-align: inherit;">最后，这只是可见性的另一种类型。</font></font><code>HexCellShaderData.RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将可见性状态存储在数据通道R中。</font><font style="vertical-align: inherit;">让我们将研究状态保留在G通道数据中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 黑色未开发的浮雕 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以使用着色器来可视化细胞研究的状态。</font><font style="vertical-align: inherit;">为了确保一切正常，我们将未开发的地形设为黑色。</font><font style="vertical-align: inherit;">但是首先，要使编辑模式起作用，请对其进行更改，</font></font><code>FilterCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以过滤出研究数据。</font></font><br><br><pre> <code class="hljs kotlin">float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.xy = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地形</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">将所有三个可能单元的可见性数据传递给片段程序。</font><font style="vertical-align: inherit;">在研究状态下，我们将它们合并到顶点程序中，并将唯一的值转移到片段程序中。</font><font style="vertical-align: inherit;">将</font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四个组件</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">到</font><font style="vertical-align: inherit;">输入中，</font><font style="vertical-align: inherit;">以便为此放置一个位置。</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; <span class="hljs-type"><span class="hljs-type">float4</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在顶点程序中，当我们更改可见性索引时，必须显式访问</font></font><code>data.visibility.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { … data.visibility.xyz = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.xyz); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后，我们结合研究状态并将结果写入</font></font><code>data.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这类似于在其他着色器中合并可见性，但使用这些单元的分量Y。</font></font><br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.xyz = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xyz</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.w = cell0.y * v.color.x + cell1.y * v.color.y + cell2.y * v.color.z;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在可以通过片段程序获得研究状态</font></font><code>IN.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在反照率的计算中考虑它。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/de4/c18/b2dde4c1831a9ecc637550b2b8e2e134.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未开发的地形现在为黑色。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，未开发的单元的浮雕为黑色。</font><font style="vertical-align: inherit;">但这尚未影响物体，道路和水。</font><font style="vertical-align: inherit;">但是，这足以确保研究能够进行。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存和加载研究状态 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们已经添加了研究支持，我们需要确保在保存和加载地图时考虑到研究状态。</font><font style="vertical-align: inherit;">因此，我们需要将地图文件的版本增加到3。为了使这些更改更方便，让我们为此添加一个</font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常量。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当向中写入文件版本</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及在中检查文件支持</font><font style="vertical-align: inherit;">时，我们将使用此常量</font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(mapFileVersion); hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= mapFileVersion) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一步，</font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们记录研究状态。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { … writer.Write(IsExplored); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在最后阅读它</font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此后，</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果研究状态与先前的状态不同</font><font style="vertical-align: inherit;">，我们将打电话给我们</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = reader.ReadBoolean(); ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了保持与旧保存文件的向后兼容性，如果文件版本小于3，则需要跳过读取保存状态。在这种情况下，默认情况下，单元格的状态为“未探索”。</font><font style="vertical-align: inherit;">为此，我们需要将</font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标头数据</font><font style="vertical-align: inherit;">添加为参数</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = header &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将必须传入</font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标头数据。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在保存和加载地图时，将考虑细胞的探索状态。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隐藏未知的单元格 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在当前阶段，未探索的细胞会通过黑色浮雕视觉显示。</font><font style="vertical-align: inherit;">但实际上，我们希望这些细胞不可见，因为它们是未知的。</font><font style="vertical-align: inherit;">我们可以使不透明的几何体透明，从而使其不可见。</font><font style="vertical-align: inherit;">但是，在开发Unity表面着色器框架时并未考虑到这种可能性。</font><font style="vertical-align: inherit;">代替使用真实的透明度，我们将更改着色器以匹配背景，这也将使它们不可见。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使救济真正变黑 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管研究的浮雕是黑色的，但我们仍然可以识别它，因为它仍然具有镜面照明。要摆脱照明，我们需要使其完全为哑光黑色。为了不影响其他表面特性，最容易将镜面颜色更改为黑色。如果您使用可与高光配合使用的表面着色器，则可以这样做，但是现在我们使用标准金属材质。因此，让我们从将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器切换</font><font style="vertical-align: inherit;">为高光开始。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更换颜色属性</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Metallic</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物业</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。默认情况下，其颜色值应等于（0.2，0.2，0.2）。因此，我们保证它会与金属版本的外观匹配。</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还更改相应的着色器变量。</font><font style="vertical-align: inherit;">镜面曲面着色器的颜色定义为</font></font><code>fixed3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此让我们使用它。</font></font><br><br><pre> <code class="hljs objectivec"> half _Glossiness; <span class="hljs-comment"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将编译指示曲面从</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改</font><font style="vertical-align: inherit;">为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardSpecular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这将强制Unity使用高光生成着色器。</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，该函数</font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要第二个参数为type </font></font><code>SurfaceOutputStandardSpecular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，现在您需要分配的值不是</font></font><code>o.Metallic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是</font></font><code>o.Specular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; // o.Metallic = _Metallic; o.Specular = _Specular; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以考虑</font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">镜面反射的颜色来遮挡高光。</font></font><br><br><pre> <code class="hljs"> o.Specular = _Specular * explored;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/d05/128/289d0512816a7d6f692b0e7639e882eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未开发的地形，无反射光。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您在图片中所看到的，现在未开发的浮雕看起来暗淡的黑色。</font><font style="vertical-align: inherit;">但是，当以切线角度查看时，这些表面会变成一面镜子，因此，浮雕开始反射环境，即天空盒。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么表面变成镜子？</font></font></b> <div class="spoiler_text">    .  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rendering</a> . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/255/d63/627/255d636278eb947c27117d6c596a9489.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未开发的区域仍然反映环境。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了消除这些反射，我们将完全屏蔽未开发的浮雕。</font><font style="vertical-align: inherit;">这是通过</font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为遮挡参数</font><font style="vertical-align: inherit;">分配一个值来实现的</font><font style="vertical-align: inherit;">，我们将其用作反射蒙版。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/ab6/a5a/118ab6a5a91711eda2165433a7b99513.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未开发，无思考。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 配套背景 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在未开发的地形会忽略所有照明，您需要使其与背景匹配。</font><font style="vertical-align: inherit;">由于我们的相机始终从上方看，因此背景始终为灰色。</font><font style="vertical-align: inherit;">要告诉</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地形</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">使用哪种颜色，请添加</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_BackgroundColor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">默认为黑色。</font></font><br><br><pre> <code class="hljs dos"> Properties { … _BackgroundColor ("Background <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>", <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) } … half _Glossiness; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用此颜色，我们将其添加为发射光。</font><font style="vertical-align: inherit;">这是</font></font><code>o.Emission</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过指定背景色值乘以探索的一减来实现的。</font></font><br><br><pre> <code class="hljs"> o.Occlusion = explored; o.Emission = _BackgroundColor * (1 - explored);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们使用默认的天空盒，因此可见的背景颜色实际上并不相同。</font><font style="vertical-align: inherit;">通常，略带红色的灰色是最好的颜色。</font><font style="vertical-align: inherit;">设置浮雕材料时，可以将</font><font style="vertical-align: inherit;">代码68615BFF </font><font style="vertical-align: inherit;">用于</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六进制颜色</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/307/7dd/eeb3077dd097a7649575a371cbb361f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">救济材料具有灰色背景色。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总的来说，这是可行的，尽管如果您知道从哪里看，您会注意到轮廓很弱。</font><font style="vertical-align: inherit;">为了使播放器看不到它们，您可以为相机分配统一的背景色68615BFF，而不是向天盒。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/8cc/ec9/7b98ccec9228ac333cc23ec19cc6f28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相机具有统一的背景色。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么不删除天空盒？</font></font></b> <div class="spoiler_text">   ,   ,     environmental lighting .     ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们无法找到背景和未开发单元格之间的差异。</font><font style="vertical-align: inherit;">较高的未勘探地形仍可以在低摄像机角度掩盖较低的勘探地形。</font><font style="vertical-align: inherit;">此外，未勘探的零件仍在勘探对象上留下阴影。</font><font style="vertical-align: inherit;">但是这些最小的线索可以忽略。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f88/764/d67/f88764d67aec0bf90267d273e1a248d5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未探索的单元格不再可见。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您不使用统一的背景色怎么办？</font></font></b> <div class="spoiler_text">    ,        ,      .        .      ,          .       ,     ,  ,  UV-           . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隐藏救济对象 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们只隐藏了浮雕的网格。</font><font style="vertical-align: inherit;">其余的研究状态尚未受影响。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/282/c0c/a0f/282c0ca0fb55bf26ee0bb1d43cadd42f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，只有救济是隐藏的。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们更改</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">，它是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain之</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的不透明着色器</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将其变成镜面反射着色器，并为其添加背景色。</font><font style="vertical-align: inherit;">让我们从属性开始。</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [NoScaleOffset] _GridCoordinates (<span class="hljs-string"><span class="hljs-string">"Grid Coordinates"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 像以前一样进一步编译杂物表面和变量。 </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert … half _Glossiness; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</span></span></span></span></code> </pre> <br> <code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还需要一个组件。</font><font style="vertical-align: inherit;">由于“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结合了每个顶点的可见性，因此仅需要一个浮点值。</font><font style="vertical-align: inherit;">现在我们需要两个。</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float2 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对其进行更改，</font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使其明确用于可见性数据</font></font><code>data.visibility.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后分配</font></font><code>data.visibility.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研究数据</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值。</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … float4 cellData = GetCellData(cellDataCoordinates); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cellData.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cellData.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对其进行更改，</font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使其使用新数据，例如</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x * explored); // o.Metallic = _Metallic; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Emission = _BackgroundColor * (<span class="hljs-number"><span class="hljs-number">1</span></span> - explored); o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/863/dc6/d13863dc60bbb92750cd5c8f8b69d82b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏的救济物。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隐藏水 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来是“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水岸”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先将它们转换为镜面着色器。</font><font style="vertical-align: inherit;">但是，它们不需要背景色，因为它们是透明的着色器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换后，再添加</font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个组件并相应地进行更改</font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">两个着色器组合来自三个单元的数据。</font></font><br><br><pre> <code class="hljs dos"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, out Input data) { … data.visibility.x = cell0.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; data.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.x); data.visibility.y = cell0.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; }</code> </pre> <br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行</font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的操作，但以相同的方式设置其表面属性。</font><font style="vertical-align: inherit;">由于它们是透明的，因此我们将</font></font><code>explore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Alpha通道中加以考虑，并且不会设置发射。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/e39/390/15ae39390ccbe91f3d12f068992a7c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏的水。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们隐藏河口，河流和道路 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还有</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">河口</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">河流</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道路</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的着色器</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这三个都是透明的，并且合并了两个单元格的数据。</font><font style="vertical-align: inherit;">将它们全部切换为镜面反射，然后将它们添加到</font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研究数据中。</font></font><br><br><pre> <code class="hljs kotlin"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x * v.color.x + cell1.x * v.color.y; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell0.y * v.color.x + cell1.y * v.color.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改</font><em><font style="vertical-align: inherit;">河口</font></em><font style="vertical-align: inherit;">和</font><em><font style="vertical-align: inherit;">河流</font></em></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">的功能，以</font><font style="vertical-align: inherit;">使其使用新数据。</font><font style="vertical-align: inherit;">两者都需要进行相同的更改。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有所不同，因为它使用了额外的混合指标。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x); <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend *= noise.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend); <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = blend * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/1d2/c65/1c61d2c652b436385b42188c39476c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切都是隐藏的。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免未开发的细胞 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管所有未知的内容都在视觉上隐藏了，但是在搜索路径时不会考虑研究状态。</font><font style="vertical-align: inherit;">结果，可以命令单位在未探索的单元之间移动，神奇地确定了移动的方向。</font><font style="vertical-align: inherit;">我们需要强迫部队避免未开发的细胞。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca9/eb9/f22/ca9eb9f22cd36b917bd5f0c38028bce7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览未开发的单元格。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 小队决定搬家的成本 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前进入未开发的电池，让我们返工的代码转移成本的运动</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这将简化对具有不同移动规则的单位的支持。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">确定移动成本</font><font style="vertical-align: inherit;">的</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用方法</font></font><code>GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中。</font><font style="vertical-align: inherit;">他需要知道哪些单元格在它们之间移动以及方向。</font><font style="vertical-align: inherit;">我们复制相应的代码，以支付从</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迁移到此方法</font><font style="vertical-align: inherit;">的成本，</font><font style="vertical-align: inherit;">并更改变量名称。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该方法应返回移动成本。</font><font style="vertical-align: inherit;">我使用旧代码跳过无效动作</font></font><code>continue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是这种方法在这里行不通。</font><font style="vertical-align: inherit;">如果无法移动，那么我们将退回移动的负成本。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要知道何时查找路径，不仅是速度，还包括所选单位。</font><font style="vertical-align: inherit;">相应地更改</font></font><code>HexGameUI.DoPathFinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, selectedUnit); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们仍然需要使用小队速度，因此我们将添加到</font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性中</font></font><code>Speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">虽然它将返回一个恒定值24。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Speed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变化</font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使他们能够与我们的新方法的工作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, unit); ShowPath(unit.Speed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> speed = unit.Speed; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们将从</font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定是否可以移动到下一个单元格以及移动成本是多少</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">旧代码中</font><font style="vertical-align: inherit;">删除</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">相反，我们将调用</font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>HexUnit.GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果移动成本为负，我们将跳过该单元格。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (neighbor.IsUnderwater || neighbor.Unit) { // continue; // } // HexEdgeType edgeType = current.GetEdgeType(neighbor); // if (edgeType == HexEdgeType.Cliff) { // continue; // } // int moveCost; // if (current.HasRoadThroughEdge(d)) { // moveCost = 1; // } // else if (current.Walled != neighbor.Walled) { // continue; // } // else { // moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; // moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + // neighbor.PlantLevel; // } if (!unit.IsValidDestination(neighbor)) { continue; } int moveCost = unit.GetMoveCost(current, neighbor, d); if (moveCost &lt; 0) { continue; } int distance = current.Distance + moveCost; int turn = (distance - 1) / speed; if (turn &gt; currentTurn) { distance = turn * speed + moveCost; } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 绕过未开发的区域 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了避免未探索的细胞，对于我们来说确保</font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查细胞是否已检查</font><font style="vertical-align: inherit;">就足够</font><font style="vertical-align: inherit;">了。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.IsExplored &amp;&amp; !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/831/2c6/a848312c6231a168a966e4cdafc2df38.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多单位将无法进入未开发的单元。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于未开发的单元不再是有效的端点，因此小队在移至端点时会避免使用它们。</font><font style="vertical-align: inherit;">就是说，未开发的区域充当了阻碍路径的障碍，甚至延长了路径的可能性。</font><font style="vertical-align: inherit;">为了首先探索该地区，我们将不得不使这些单位靠近未知的地形。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在移动过程中出现一条较短的路径怎么办？</font></font></b> <div class="spoiler_text">                .           ,        .       . <br><br>   ,        ,            .            ,    . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第22部分：增强的可见性 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 平稳地更改可见性。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用单元格的高度确定范围。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隐藏地图的边缘。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过增加对地图探索的支持，我们将改善范围的计算和转换。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/c4a/793/2d2c4a7939e75fe09298f96ff6125478.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要看得更远，请爬上更高的位置。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可见性转换 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该单元格是可见的还是不可见的，因为它是否在分离范围之内。</font><font style="vertical-align: inherit;">即使该单元似乎需要一些时间在单元之间移动，它的视场也会立即在单元之间跳跃。</font><font style="vertical-align: inherit;">结果，周围细胞的可见性急剧变化。</font><font style="vertical-align: inherit;">小队的移动似乎很平稳，但是能见度的变化却是突然的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想情况下，可见性也应平稳变化。</font><font style="vertical-align: inherit;">进入可见区域后，应逐渐照亮细胞，并使其逐渐变暗。</font><font style="vertical-align: inherit;">还是您更喜欢即时转换？</font><font style="vertical-align: inherit;">让我们添加到</font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切换即时转换</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">属性。</font><font style="vertical-align: inherit;">默认情况下，过渡是平滑的。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 过渡细胞追踪 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即使显示平滑的过渡，真实的可见性数据仍然保持二进制，即效果只是视觉上的。</font><font style="vertical-align: inherit;">这意味着必须处理可见性转换</font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将为其提供执行转换的单元格列表。</font><font style="vertical-align: inherit;">确保在每次初始化时为空。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; Color32[] cellTextureData; List&lt;HexCell&gt; transitioningCells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … transitioningCells.Clear(); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前，我们正在</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接</font><font style="vertical-align: inherit;">设置单元格数据</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于即时过渡模式，这仍然是正确的，但是当禁用它时，必须将一个单元格添加到过渡单元格列表中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可见性似乎不再起作用，因为到目前为止，我们不对列表中的单元格做任何事情。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 循环遍历单元格 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是立即将相应的值设置为255或0，我们将逐渐增大/减小这些值。</font><font style="vertical-align: inherit;">过渡的平滑度取决于变化率。</font><font style="vertical-align: inherit;">它不应该很快也不应该很慢。</font><font style="vertical-align: inherit;">漂亮的过渡与游戏便利性之间的一个很好的折衷是在一秒钟内改变。</font><font style="vertical-align: inherit;">让我们为此设置一个常量，以使其更容易更改。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transitionSpeed = <span class="hljs-number"><span class="hljs-number">255f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，</font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以定义应用于值的增量。</font><font style="vertical-align: inherit;">为此，将时间增量乘以速度。</font><font style="vertical-align: inherit;">它必须是整数，因为我们不知道它的大小。</font><font style="vertical-align: inherit;">帧速率的急剧下降会使增量超过255。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，在有过渡单元的情况下，我们需要进行更新。</font><font style="vertical-align: inherit;">因此，当列表中包含某些内容时，应包括该代码。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = transitioningCells.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理论上也可能非常高的帧速率。</font><font style="vertical-align: inherit;">结合较低的过渡速度，这可以使我们得到0的变化量。要进行更改，我们将变化量最小值最小值设为1。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到增量后，我们可以在所有过渡单元周围循环并更新其数据。</font><font style="vertical-align: inherit;">假设我们有一个方法</font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其参数是相应的像元和增量。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { UpdateCellData(transitioningCells[i], delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在某个时候，单元格过渡应该完成。</font><font style="vertical-align: inherit;">假定该方法返回有关过渡是否仍在进行的信息。</font><font style="vertical-align: inherit;">当它停止进行时，我们可以从列表中删除该单元格。</font><font style="vertical-align: inherit;">之后，我们必须减小迭代器，以免跳过单元格。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells.RemoveAt(i--); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过渡单元的处理顺序并不重要。</font><font style="vertical-align: inherit;">因此，我们不必删除当前索引处的单元格，这将迫使</font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有单元格</font><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">其后移动。</font><font style="vertical-align: inherit;">相反，我们将最后一个单元格移到当前索引，然后删除最后一个。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells[i--] = transitioningCells[transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; transitioningCells.RemoveAt(transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们必须创建一个方法</font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要完成他的工作，他将需要一个索引和单元格数据，因此让我们从获取它们开始。</font><font style="vertical-align: inherit;">它还应确定是否继续更新单元。</font><font style="vertical-align: inherit;">默认情况下，我们将假定没有必要。</font><font style="vertical-align: inherit;">工作完成后，有必要应用更改的数据并返回状态“更新正在继续”。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; Color32 data = cellTextureData[index]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更新单元格数据 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此阶段，我们有一个正在过渡或已经完成的单元。</font><font style="vertical-align: inherit;">首先，让我们检查单元探针的状态。</font><font style="vertical-align: inherit;">如果检查了该单元格，但其G值尚未等于255，则它处于转换过程中，因此我们将对其进行监视。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } cellTextureData[index] = data;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了执行过渡，我们将向该单元格的G值添加一个增量。</font><font style="vertical-align: inherit;">算术运算不适用于字节，它们首先转换为整数。</font><font style="vertical-align: inherit;">因此，总和将为整数格式，必须将其转换为字节。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是在转换之前，您需要确保该值不超过255。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接下来，我们需要对可见性进行相同的操作，它使用R的值。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible &amp;&amp; data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 由于单元格可以再次变为不可见，因此我们需要检查是否有必要减小R的值。当单元格不可见但R大于零时，会发生这种情况。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r - delta; data.r = t &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在已经</font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备就绪，可见性转换已正确执行。</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可见性转换。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 防止重复的过渡元素 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换有效，但重复的项目可能会出现在列表中。</font><font style="vertical-align: inherit;">如果单元格的可见状态在转换过程中发生变化，就会发生这种情况。</font><font style="vertical-align: inherit;">例如，当小队移动期间仅在短时间内可见该单元格时。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于出现了重复的元素，因此每帧会对单元格过渡进行几次更新，从而加快了过渡速度并增加了工作量。</font><font style="vertical-align: inherit;">我们可以通过在添加单元格之前检查它是否已经在列表中来防止这种情况。</font><font style="vertical-align: inherit;">但是，每个电话都会进行列表搜索</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成本很高，尤其是在执行多个单元转换时。</font><font style="vertical-align: inherit;">相反，让我们使用另一个尚未用于指示单元格是否处于过渡过程中的通道，例如值B.将单元格添加到列表时，我们将为其分配值255，并仅添加值不等于255的那些单元格。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData[index].b != <span class="hljs-number"><span class="hljs-number">255</span></span>) { cellTextureData[index].b = <span class="hljs-number"><span class="hljs-number">255</span></span>; transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为此，我们需要在单元格转换完成后重置B的值。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stillUpdating) { data.b = <span class="hljs-number"><span class="hljs-number">0</span></span>; } cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有重复的过渡。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 即时加载可见性 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，即使在加载地图时，可见性更改也始终是渐进的。</font><font style="vertical-align: inherit;">这是不合逻辑的，因为地图描述了已经可见细胞的状态，因此此处的过渡是不合适的。</font><font style="vertical-align: inherit;">此外，对大型地图的许多可见单元执行过渡可能会减慢加载后的游戏速度。</font><font style="vertical-align: inherit;">因此，在加载像元和小队之前，让我们切换</font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到即时转换模式。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们将重新定义即时过渡模式的初始设置，无论它是什么。</font><font style="vertical-align: inherit;">也许它已经被关闭，或者有一个配置选项，所以我们会记住初始模式，并在工作完成后切换到它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> originalImmediateMode = cellShaderData.ImmediateMode; cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … cellShaderData.ImmediateMode = originalImmediateMode; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 高度范围 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们对所有单元都使用了恒定的三个范围，但实际上更复杂。在一般情况下，由于两个原因，我们无法看到对象：某个障碍阻止了我们看到它，或者对象太小或太远。在我们的游戏中，我们仅实现范围限制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看不到地球另一侧的事物，因为行星使我们蒙昧。我们只能看到地平线。由于行星可以近似地视为球体，因此视角越高，我们可以看到的表面越多，也就是说，地平线取决于高度。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/788/208/0717882082a42e92b14e158876c6e28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地平线取决于视点的高度。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们单位的能见度有限，模仿了地球曲率产生的地平线效应。</font><font style="vertical-align: inherit;">他们的审查范围取决于行星的大小和地图的比例。</font><font style="vertical-align: inherit;">至少这是合乎逻辑的解释。</font><font style="vertical-align: inherit;">但是缩小范围的主要原因是游戏玩法，这就是所谓的战争迷局。</font><font style="vertical-align: inherit;">但是，了解了视场的物理原理后，我们可以得出结论，高视点应该具有战略价值，因为它可以移动视野并允许您查看较低的障碍。</font><font style="vertical-align: inherit;">但是到目前为止，我们还没有实现它。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 审查高度 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在确定范围时要考虑高度，我们需要知道高度。</font><font style="vertical-align: inherit;">这将是通常的水位或水位，具体取决于陆地细胞还是水。</font><font style="vertical-align: inherit;">让我们将其添加到</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ViewElevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation &gt;= waterLevel ? elevation : waterLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果高度影响范围，则随着单元格观察高度的变化，可见性状况也可能发生变化。</font><font style="vertical-align: inherit;">由于单元格已阻止或正在阻止多个单元的作用域，因此确定需要更改的内容并非那么容易。</font><font style="vertical-align: inherit;">单元本身将无法解决此问题，因此请让其报告情况的变化</font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">假设您</font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一种方法</font></font><code>ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如有必要，</font><font style="vertical-align: inherit;">我们将在分配后称呼它</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样的道理</font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ValidateRivers(); Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 重置可见性 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要创建一个方法</font></font><code>HexCellShaderData.ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">确定一般可见性情况如何变化是一项复杂的任务，尤其是在同时更改多个单元格时。</font><font style="vertical-align: inherit;">因此，我们不会提出任何技巧，而只是计划重置所有单元的可见性。</font><font style="vertical-align: inherit;">添加一个布尔字段以跟踪是否执行此操作。</font><font style="vertical-align: inherit;">在方法内部，我们将简单地将其设置为true并包含组件。</font><font style="vertical-align: inherit;">无论同时更改了多少个单元，这都会导致一次复位。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> needsVisibilityReset; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewElevationChanged</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要重置所有单元格的可见性值，您必须有权访问它们，而您</font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有</font><font style="vertical-align: inherit;">访问权限</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，让我们委派这个责任</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此，您需要添加到</font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性，该属性允许您引用网格。</font><font style="vertical-align: inherit;">然后，我们可以使用它</font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来请求重置。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsVisibilityReset) { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Grid.ResetVisibility(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们继续</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建着色器数据后，</font><font style="vertical-align: inherit;">设置到网格的链接</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); cellShaderData.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; CreateMap(cellCountX, cellCountZ); }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还应该获得一种</font></font><code>ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丢弃所有单元格</font><font style="vertical-align: inherit;">的方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">只需使其遍历循环中的所有单元，然后将重置委托给它自己即可。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要添加该</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>ResetVisibilty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它将简单地将可见性归零并触发可见性更新。</font><font style="vertical-align: inherit;">当单元格可见性大于零时，必须执行此操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { visibility = <span class="hljs-number"><span class="hljs-number">0</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重置所有可见性数据后，</font></font><code>HexGrid.ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他必须再次将可见性应用于所有小队，为此他需要了解每个小队的范围。</font><font style="vertical-align: inherit;">假设可以使用属性获得它</font></font><code>VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { HexUnit unit = units[i]; IncreaseVisibility(unit.Location, unit.VisionRange); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我们将重命名</font></font><code>HexUnit.visionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font><font style="vertical-align: inherit;">重构并将</font></font><code>HexUnit.VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其转换为属性。</font><font style="vertical-align: inherit;">虽然它将收到3的恒定值，但是将来它将改变。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VisionRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，在更改单元格的查看高度后，可见性数据将被重置并保持正确。</font><font style="vertical-align: inherit;">但是我们可能会更改确定范围的规则，并在“播放”模式下运行重新编译。</font><font style="vertical-align: inherit;">为了使范围独立更改，让我们</font></font><code>HexGrid.OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在检测到重新编译时</font><font style="vertical-align: inherit;">进行一次重置</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { … ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，您可以更改范围代码并查看结果，同时保持在“播放”模式下。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 扩大视野 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定范围的计算</font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了使高度影响范围，我们可以通过</font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">临时重新定义透射区域</font><font style="vertical-align: inherit;">来简单地使用查看高度</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我们可以轻松检查是否可行。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { … range = fromCell.ViewElevation; fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/032/6d3/7270326d379796f2b4f2f3c3ca65512c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用高度作为范围。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可见性障碍 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅当所有其他单元格的高度都为零时，才能将查看高度用作范围。</font><font style="vertical-align: inherit;">但是，如果所有像元的高度都与视点相同，则视场应为零。</font><font style="vertical-align: inherit;">此外，高度较高的牢房应遮挡后面的矮牢房的可见性。</font><font style="vertical-align: inherit;">到目前为止，这还没有实现。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/7be/a6f/de87bea6f4b88cd61765450a63f738f9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">范围不干涉。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定范围的最正确方法是通过射线的发射进行检查，但是这种方法很快会变得昂贵，并且仍然会产生奇怪的结果。</font><font style="vertical-align: inherit;">我们需要一种快速的解决方案，它可以产生足够好的结果，而不必是完美的。</font><font style="vertical-align: inherit;">另外，重要的是，确定范围的规则对于玩家来说必须简单，直观和可预测。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的解决方案如下-确定单元格的可见性时，我们会将相邻单元格的可视高度添加到覆盖距离内。</font><font style="vertical-align: inherit;">实际上，当我们查看这些单元格时，这会缩小范围，并且如果跳过它们，则将不允许我们到达它们后面的单元格。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/44c/efe/77444cefe82d428ee32e094213e82a1a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高格挡视线。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不应该在远处看到高大的细胞吗？</font></font></b> <div class="spoiler_text">      ,     ,   ,   .       ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不要四处寻找 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，似乎高的单元格将视线降低到低点，但有时示波器会穿透它们，尽管似乎不应该如此。</font><font style="vertical-align: inherit;">发生这种情况是因为搜索算法仍然绕过阻塞单元格找到了这些单元格的路径。</font><font style="vertical-align: inherit;">结果，看起来我们的可见范围可以绕过障碍。</font><font style="vertical-align: inherit;">为了避免这种情况，我们需要确保在确定像元可见性时仅考虑最短路径。</font><font style="vertical-align: inherit;">这可以通过删除比所需时间更长的路径来完成。</font></font><br><br><pre> <code class="cs hljs"> HexCoordinates fromCoordinates = fromCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range || distance &gt; fromCoordinates.DistanceTo(neighbor.coordinates) ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/bfa/1c2/30dbfa1c2df2fb6119249f00cdc3d8d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅使用最短的路径。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们修复了大多数明显错误的情况。对于附近的小区，此方法效果很好，因为只有最短的路径可以到达它们。距离更远的单元具有更多的路径选择；因此，在长距离上，可见范围仍然可能发生。如果可见区域保持较小并且相邻高度之间的差异不太大，这将不是问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们没有取代透射的视野，而是增加了视野的高度。该小队自己的视野表明其高度，飞行高度或侦察能力。</font></font><br><br><pre> <code class="cs hljs"> range += fromCell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ff/1ce/a2b/3ff1cea2b833bda69990576fa8323aec.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以低视角查看完整视野。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，考虑到相对于视点的像元高度差异，沿着可见光的最短路径移动时，视觉的最终规则适用于视觉。</font><font style="vertical-align: inherit;">当单元超出范围时，它将阻止通过它的所有路径。</font><font style="vertical-align: inherit;">结果，没有任何阻碍视线的高观察点就具有了战略上的价值。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻碍对象的可见性呢？</font></font></b> <div class="spoiler_text">  ,        ,  . ,  ,        .          . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无法探索的细胞 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可见性的最后一个问题涉及地图的边缘。</font><font style="vertical-align: inherit;">浮雕突然过渡并且没有过渡结束，因为边缘的单元没有邻居。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/217/fbb/587217fbb248ae8a13759a33e22e25ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图的标记边缘。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想情况下，未勘探区域和地图边缘的视觉显示应相同。我们可以通过在对边缘进行三角测量时（当它们没有邻居时）添加特殊情况来实现此目的，但这将需要附加的逻辑，并且我们将不得不处理缺少的像元。因此，这种解决方案是不平凡的。一种替代方法是强制地图的边界像元处于探索范围之内，而对其进行探索。这种方法要简单得多，所以让我们使用它。它还允许您将标记为未探索的单元格和其他单元格，从而更容易实现地图不均匀边缘的创建。此外，边缘处的隐藏单元格使您可以创建进入和离开河流和道路地图的道路和河流，因为它们的端点将不在范围内。另外，借助此解决方案，您可以添加进入和离开地图的单位。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将细胞标记为已调查 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要指示可以检查一个单元格，请添加到</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性中</font></font><code>Explorable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Explorable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，如果一个单元格是经过调查的单元格，则可以看到它，因此</font></font><code>IsVisible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将</font><font style="vertical-align: inherit;">更改属性</font><font style="vertical-align: inherit;">以考虑到这一点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Explorable; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样适用于</font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，为此，我们调查了标准属性。</font><font style="vertical-align: inherit;">我们需要将其转换为显式属性，以便能够更改其吸气剂的逻辑。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> explored &amp;&amp; Explorable; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { explored = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> explored;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隐藏地图的边缘 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在方法中隐藏矩形地图的边缘</font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对不在边缘的单元进行调查，其余所有单元均未开发。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，卡的边缘变暗，在它们后面隐藏了巨大的未开发空间。</font><font style="vertical-align: inherit;">结果，研究的地图区域的大小在每个维度上减小了两倍。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/19f/353/59419f35345fa4eac3380c4e16461baf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图的未开发边缘。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否可以使研究状态可编辑？</font></font></b> <div class="spoiler_text"> ,  ,     .          . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未开发的细胞会阻碍可见性 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，如果无法检查细胞，那么它将干扰可见性。</font><font style="vertical-align: inherit;">进行更改</font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以考虑到这一点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase || !neighbor.Explorable ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第23部分：产生土地 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用生成的景观填充新地图。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在水上耕种土地，在一些地方充水。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们控制已创建土地的数量，其高度和不平坦度。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们增加了对各种配置选项的支持，以创建变量映射。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们这样做是为了可以再次生成相同的地图。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本教程的这一部分将是过程图生成系列的开始。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这部分是在Unity 2017.1.0中创建的。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/798/7bb/99e7987bbcb46f1f961b72ba76a78aa0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">众多生成的地图之一。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 卡生成 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们可以创建任何地图，但需要花费很多时间。如果该应用程序可以通过为设计师生成卡片来帮助设计师，然后他可以根据自己的喜好对其进行修改，则将很方便。您可以采取另一步，完全摆脱手动创建设计的过程，将生成最终地图的责任完全转移到应用程序。因此，每次可以使用新卡玩游戏，并且每次游戏会话都不同。为了使所有这些成为可能，我们必须创建一个地图生成算法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要的生成算法的类型取决于您需要的卡的类型。没有正确的方法，您总是必须在信誉和可玩性之间寻求折衷方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使一张纸牌令人信服，对于玩家来说，它必须看起来很有可能且真实。这并不意味着地图应该看起来像我们星球的一部分。它可能是不同的星球，也可能是完全不同的现实。但是，如果它应该表示地球的解脱，那么它必须至少部分类似于地球。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可玩性与纸牌如何与游戏玩法相关。有时，它与可信度冲突。例如，尽管山脉看起来很美，但同时它们极大地限制了单位的移动和视野。如果这是不可取的，那么您就必须在没有障碍的情况下做，这会降低信誉并限制游戏的表现力。或者，我们可以拯救山脉，但减少它们对游戏玩法的影响，这也可以降低信誉。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，必须考虑可行性。例如，您可以通过模拟构造板块，侵蚀，降雨，火山喷发，陨石和月球的影响等来创建一个非常逼真的类地球行星。但是开发这样的系统将需要大量时间。此外，生成这样的星球可能要花费很长时间，并且玩家也不想在开始新游戏之前等待几分钟。也就是说，模拟是一个强大的工具，但它有代价。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏通常会在可信度，可玩性和可行性之间进行权衡。有时，这种折衷是看不见​​的，看起来完全是正常的，而有时，它们看起来是随机的，不一致的或混乱的，具体取决于开发过程中做出的决定。这不仅适用于卡生成，而且在开发程序卡生成器时，您需要特别注意这一点。您可能需要花费大量时间来创建一种算法，该算法可以生成漂亮的卡片，这些卡片对于您正在创建的游戏毫无用处。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本教程系列中，我们将创建一个类似土地的浮雕。</font><font style="vertical-align: inherit;">它看起来应该很有趣，具有很大的可变性并且没有较大的均匀区域。</font><font style="vertical-align: inherit;">救济规模将很大，地图将覆盖一个或多个大洲，海洋区域，甚至整个星球。</font><font style="vertical-align: inherit;">我们需要控制地理环境，包括土地质量，气候，区域数量和地形颠簸。</font><font style="vertical-align: inherit;">在这一部分中，我们将为创建寿司奠定基础。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在编辑模式下入门 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将专注于地图，而不是游戏玩法，因此在编辑模式下启动应用程序会更加方便。</font><font style="vertical-align: inherit;">因此，我们可以立即看到卡片。</font><font style="vertical-align: inherit;">因此，我们将通过</font></font><code>HexMapEditor.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将编辑模式设置为true并打开此模式的shader关键字来进行</font><font style="vertical-align: inherit;">更改</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 卡生成器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于生成过程图需要大量代码，因此我们不会将其直接添加到中</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">相反，我们将创建一个新组件</font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不知道它。</font><font style="vertical-align: inherit;">如果需要，这将简化向另一种算法的过渡。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器需要一个到网格的链接，因此我们将向它添加一个常规字段。</font><font style="vertical-align: inherit;">此外，我们添加了一种通用方法</font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来处理算法的工作。</font><font style="vertical-align: inherit;">我们将为它提供地图的尺寸​​作为参数，然后强制将其用于创建新的空地图。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将具有组件的对象添加到场景</font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其连接到网格。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/b6e/fd2/932b6efd2dd1809893af27ec7a91c620.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图生成器对象。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更改新地图的菜单 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将对其进行更改，</font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便它可以生成卡片，而不仅仅是创建空卡片。</font><font style="vertical-align: inherit;">我们将通过布尔字段</font></font><code>generateMaps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（默认情况下具有一个值）</font><font style="vertical-align: inherit;">来控制其功能</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们创建一个设置此字段的通用方法，就像我们切换options一样</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将适当的开关添加到菜单并将其连接到方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> generateMaps = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleMapGeneration</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { generateMaps = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc9/9c7/0c9/fc99c70c99095b3565104ef42254859d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有开关的新卡的菜单。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在菜单上提供指向地图生成器的链接。</font><font style="vertical-align: inherit;">然后，如果需要</font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">我们将强制其调用</font><font style="vertical-align: inherit;">generator </font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，而不仅仅是执行</font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMapGenerator mapGenerator; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/e98/3d9/7d1e983d927d912b75d9b245219659f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接到发电机。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单元访问 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使生成器正常工作，它需要访问单元。</font><font style="vertical-align: inherit;">我们</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经有常用的方法</font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，需要或位置矢量，或六边形坐标。</font><font style="vertical-align: inherit;">生成器不需要使用任何一种，因此我们添加了两种方便的方法</font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它们将与像元的偏移量或索引的坐标一起使用。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zOffset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[xOffset + zOffset * cellCountX]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[cellIndex]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在它</font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以直接接收细胞。</font><font style="vertical-align: inherit;">例如，创建新地图后，他可以使用草坐标将草设置为单元格中间列的浮雕。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; z; i++) { grid.GetCell(x / <span class="hljs-number"><span class="hljs-number">2</span></span>, i).TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/aee/119/860aee119f0e000ef290f6c87e61ad05.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">草的专栏在一张小地图的。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 做寿司 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成地图时，我们完全没有土地。</font><font style="vertical-align: inherit;">可以想象，整个世界被一片巨大的海洋淹没。</font><font style="vertical-align: inherit;">当海底的一部分被推得太多以至于它上升到水面之上时，就会产生一块土地。</font><font style="vertical-align: inherit;">我们需要确定应以这种方式创建多少土地，它会出现在何处以及形状如何。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 减轻压力 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从小处开始-在水面上方举起一块土地。</font><font style="vertical-align: inherit;">为此，我们创建了一个</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有参数</font><font style="vertical-align: inherit;">的方法</font><font style="vertical-align: inherit;">来控制绘图的大小。</font><font style="vertical-align: inherit;">在中调用此方法</font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以替换先前的测试代码。</font><font style="vertical-align: inherit;">让我们从由七个单元组成的一小块土地开始。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; z; i++) { // grid.GetCell(x / 2, i).TerrainTypeIndex = 1; // } RaiseTerrain(7); } void RaiseTerrain (int chunkSize) {}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们使用“草”类浮雕来表示高地，原始的“沙”类浮雕是指海洋。</font><font style="vertical-align: inherit;">让我们</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择一个随机单元，并更改其救济的类型，直到获得适当数量的土地为止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了获得随机单元格，我们添加了一种</font></font><code>GetRandomCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定随机单元格索引并从网格中获取相应单元格的方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunkSize; i++) { GetRandomCell().TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, grid.cellCountX * grid.cellCountZ)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/fb8/ce6/396fb8ce67de74961b31562e275bd81a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">七个随机的寿司室。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于最终我们可能需要大量随机单元格或遍历所有单元格几次，因此让我们跟踪单元格本身中单元格的数量</font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; … } … <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellCount)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建一个站点 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们正在将七个随机小区变成陆地，它们可以在任何地方。</font><font style="vertical-align: inherit;">它们很可能没有形成一个单一的土地区域。</font><font style="vertical-align: inherit;">此外，我们可以多次选择相同的像元，因此可以减少土地面积。</font><font style="vertical-align: inherit;">为了同时解决这两个问题，我们将仅选择第一个单元格。</font><font style="vertical-align: inherit;">在那之后，我们应该只选择那些与先前选择的单元格相邻的单元格。</font><font style="vertical-align: inherit;">这些限制类似于路径搜索的限制，因此我们在此处使用相同的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们添加</font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了自己的属性以及搜索边界阶段的计数器，就像在中一样</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在需要优先级队列之前，请先检查它是否存在。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建新地图后，所有像元的搜索边界均为零。但是，如果我们要在地图生成过程中搜索像元，那么我们将在此过程中增加它们的搜索边界。如果我们执行许多搜索操作，它们可能会超出记录的搜索边界的阶段</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这可能会干扰对单位路径的搜索。为避免这种情况，在地图生成过程结束时，我们会将所有像元的搜索阶段重置为零。</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须寻找适当的单元格，而不是随机选择它们。此过程与中的搜索方法非常相似</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，我们访问单元格不会超过一次，因此，将搜索边界的相位增加1而不是2，就足够了。然后，我们使用随机选择的第一个单元格初始化边界。与往常一样，除了设置其搜索阶段外，我们还将其距离和启发式方法分配为零。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; chunkSize; i++) { // GetRandomCell().TerrainTypeIndex = 1; // } searchFrontierPhase += 1; HexCell firstCell = GetRandomCell(); firstCell.SearchPhase = searchFrontierPhase; firstCell.Distance = 0; firstCell.SearchHeuristic = 0; searchFrontier.Enqueue(firstCell); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在那之后，搜索循环将是我们最熟悉的。</font><font style="vertical-align: inherit;">另外，要继续搜索直到边界为空，我们需要在片段达到所需大小时停止，因此我们将对其进行跟踪。</font><font style="vertical-align: inherit;">在每次迭代时，我们将从队列中提取下一个单元格，设置其释放类型，增加大小，然后绕过该单元格的邻居。</font><font style="vertical-align: inherit;">如果尚未将所有邻居添加到边界，则仅将其添加到边界。</font><font style="vertical-align: inherit;">我们不需要进行任何更改或比较。</font><font style="vertical-align: inherit;">完成后，您需要清除边框。</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } } searchFrontier.Clear();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97a/f44/023/97af440236cb6909130d6a8bfaab3f5a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一排细胞。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到了一个合适大小的地块。</font><font style="vertical-align: inherit;">仅当没有足够数量的单元格时，它才会更小。</font><font style="vertical-align: inherit;">由于边界的填充方式，地块始终由西北延伸的线组成。</font><font style="vertical-align: inherit;">仅当到达地图边缘时，它才会改变方向。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们连接细胞 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">陆地区域很少像线一样，如果确实如此，它们的方向不一定总是相同。</font><font style="vertical-align: inherit;">要更改站点的形状，我们需要更改单元的优先级。</font><font style="vertical-align: inherit;">第一个随机像元可以用作图的中心。</font><font style="vertical-align: inherit;">然后到所有其他像元的距离将相对于此点。</font><font style="vertical-align: inherit;">因此，我们将为靠近中心的单元格赋予更高的优先级，因此该站点将不会以一条线的形式增长，而是会以中心为中心。</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); HexCoordinates center = firstCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/117/149/84111714960a293415b1d24edf92f56b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细胞的积累。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，如果中心单元格没有出现在地图边缘，那么现在我们的七个单元格将被精美地包装在一个紧凑的六角形区域中。</font><font style="vertical-align: inherit;">现在让我们尝试使用30的地块大小。</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/893/c36/13e/893c3613edfe02b457cc4ee6d191072c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30格中的寿司块。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管没有足够的单元格来获得正确的六边形，但我们再次得到了相同的形状。</font><font style="vertical-align: inherit;">由于图的半径较大，因此它很可能靠近地图的边缘，这将迫使其采取其他形状。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 寿司随机化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不希望所有区域看起来都一样，因此我们将略微更改单元格的优先级。</font><font style="vertical-align: inherit;">每次我们向边界添加一个相邻的单元格时，如果下一个数字</font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小于某个阈值，则此单元格的试探法将变为0，而不是1。让我们使用值0.5作为阈值，也就是说，它很可能会影响一半的单元格。</font></font><br><br><pre> <code class="cs hljs"> neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/aec/793/43eaec79315f68e0618fe71c0f93c3f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扭曲的区域。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过增加单元的搜索启发式，我们使它的访问比预期的晚。同时，距离中心更远一步的其他单元将被更早访问，除非它们也增加了启发式方法。这意味着，如果我们将所有单元的试探法增加一个值，那么这将不会影响地图。也就是说，阈值1不会产生影响，就像阈值0一样。阈值0.8等于0.2。也就是说，概率为0.5会使搜索过程最“发抖”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适当的振荡量取决于所需的地形类型，因此让它可自定义。将</font></font><code>jitterProbability</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有属性</font><font style="vertical-align: inherit;">的通用float字段添加到生成器</font></font><code>Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制在0-0.5范围内。</font><font style="vertical-align: inherit;">让我们给它一个默认值，等于该间隔的平均值，即0.25。</font><font style="vertical-align: inherit;">这将使我们能够在Unity inspector窗口中配置生成器。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitterProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/b50/381/795b50381d8c9cda219ff092cf64cee5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 波动的可能性。 </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在游戏界面中自定义它吗？</font></font></b> <div class="spoiler_text">  ,       .           UI,       .          ,      UI.  ,     .         ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，要确定启发式算法何时应等于1，我们使用概率而不是常数。 </font></font><br><br><pre> <code class="cs hljs"> neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; jitterProbability ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们使用0和1的启发式值。尽管可以使用更大的值，但这将大大恶化截面的变形，最有可能将其变成一堆条纹。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 筹集土地 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将不仅限于一块土地。</font><font style="vertical-align: inherit;">例如，我们将一个调用</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放在循环中以获取五个部分。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d42/83f/acd/d4283facd88705107d705290c3d8e78b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">五块土地。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管现在我们正在生成五张图，每张图各有30个像元，但不一定能准确得到150个像元的土地。</font><font style="vertical-align: inherit;">由于每个站点都是单独创建的，因此它们彼此之间并不了解，因此它们可以相交。</font><font style="vertical-align: inherit;">这是正常现象，因为它可以创建比一组单独的部分更多的有趣风景。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了增加土地的可变性，我们还可以更改每个地块的大小。</font><font style="vertical-align: inherit;">添加两个整数字段以控制图的最小和最大大小。</font><font style="vertical-align: inherit;">给它们分配足够大的时间间隔，例如20-200。</font><font style="vertical-align: inherit;">我将使标准最小值等于30，使标准最大值等于100。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(20, 200)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMin = <span class="hljs-number"><span class="hljs-number">30</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMax = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/026/e43/9ea026e43e949f571be0358332447de5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上浆间隔。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当调用时，我们使用这些字段随机确定区域的大小</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/124/dab/0df124dab1f706825f75304d2862aea3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中间地图上有五个随机大小的部分。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 制作足够的寿司 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然我们不能特别控制产生的土地数量。</font><font style="vertical-align: inherit;">尽管我们可以为图的数量添加配置选项，但图本身的大小是随机的，可能会略有重叠或紧密重叠。</font><font style="vertical-align: inherit;">因此，地点的数量并不能保证在地图上显示所需土地的数量。</font><font style="vertical-align: inherit;">让我们添加一个选项来直接控制以整数表示的土地百分比。</font><font style="vertical-align: inherit;">由于100％的土地或水不是很有趣，因此我们将其限制为5–95，默认值为50。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(5, 95)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/281/912/21e281912ad5a4a5378c5e55514c639c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寿司的百分比。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了保证创建适量的土地，我们只需要继续提高地形区域，直到获得足够的土地。</font><font style="vertical-align: inherit;">为此，我们需要控制流程，这会使土地的产生变得复杂。</font><font style="vertical-align: inherit;">因此，让我们通过调用新方法来替换现有的饲养场周期</font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此方法要做的第一件事是计算应变为陆地的像元数。</font><font style="vertical-align: inherit;">这将是我们寿司单元的总和。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; 5; i++) { // RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + 1)); // } CreateLand(); for (int i = 0; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = 0; } } void CreateLand () { int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f); }</span></span></code> </pre> <br> <code>CreateLand</code><font style="vertical-align: inherit;"></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到我们用完所有细胞后</font><font style="vertical-align: inherit;">才会导致</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了不超过金额，我们进行了更改，</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便它接收金额作为附加参数。</font><font style="vertical-align: inherit;">完成工作后，他必须退还剩余的款项。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void RaiseTerrain (int chunkSize) { int RaiseTerrain (int chunkSize, int budget) { … return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每次将牢房从边界移开并转换为土地时，数量应减少。</font><font style="vertical-align: inherit;">如果这之后全部花光了，那么我们必须停止搜索并完成站点。</font><font style="vertical-align: inherit;">此外，仅当当前单元尚未着陆时，才应执行此操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，它</font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以耕种土地，直到花完整个牢房。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { landBudget = RaiseTerrain( Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>), landBudget ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d15/34e/7f4/d1534e7f47ba4cf87f3dbeed60aa7d00.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恰好一半的地图变成了土地。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 考虑高度 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">土地不仅是一块平坦的土地，还受到海岸线的限制。</font><font style="vertical-align: inherit;">她的身高不断变化，其中包括丘陵，山脉，山谷，湖泊等。</font><font style="vertical-align: inherit;">由于缓慢移动的构造板块的相互作用，存在高度差异。</font><font style="vertical-align: inherit;">尽管我们不会对其进行模拟，但我们的陆地区域应在某种程度上类似于此类板块。</font><font style="vertical-align: inherit;">站点不移动，但可能相交。</font><font style="vertical-align: inherit;">我们可以利用这一点。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 推高土地 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个地块代表从海底推出的一部分土地。</font><font style="vertical-align: inherit;">因此，让我们不断增加当前单元格的高度，</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看看会发生什么。</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f6e/d3e/b3cf6ed3e71eb737ea7246c92bdd5624.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高地着陆。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们达到了顶峰，但很难看到。</font><font style="vertical-align: inherit;">如果您对每个高度级别使用自己的地形类型，例如地理分层，则可以使它们更加清晰。</font><font style="vertical-align: inherit;">我们只会这样做，以使高度更引人注目，因此您可以简单地将高度级别用作高程索引。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果高度超过地形类型的数量会怎样？</font></font></b> <div class="spoiler_text">        .        ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们创建一个单独的方法</font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来仅设置一次所有地形类型</font><font style="vertical-align: inherit;">，而不是随高度的变化来更新单元的</font><font style="vertical-align: inherit;">地形类型。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); cell.TerrainTypeIndex = cell.Elevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建寿司后，我们将调用此方法。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateLand(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在他</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能应付那种救济，而专注于身高。</font><font style="vertical-align: inherit;">为此，您需要更改其逻辑。</font><font style="vertical-align: inherit;">如果当前单元格的新高度为1，则它刚好变为陆地，因此单元格的总和已减少，这可能导致该站点的增长完成。</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (current.TerrainTypeIndex == 0) { // current.TerrainTypeIndex = 1; // if (--budget == 0) { // break; // } // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/eec/b9e/ee0eecb9e59f527bd27f0275e230de0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">层的分层。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 加水 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们明确指出哪些单元格是水或陆地，将所有单元格的水位设置为1。</font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在创建陆地之前</font><font style="vertical-align: inherit;">执行此操作</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = <span class="hljs-number"><span class="hljs-number">1</span></span>; } CreateLand(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，对于土地层的指定，我们可以使用所有类型的地形。</font><font style="vertical-align: inherit;">所有的海底细胞以及最低的陆地细胞都将保持沙子。</font><font style="vertical-align: inherit;">这可以通过从高度减去水位并将该值用作浮雕类型的指数来完成。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { cell.TerrainTypeIndex = cell.Elevation - cell.WaterLevel; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b5/449/bc3/1b5449bc37b1c677d908484c7bcd0286.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">土地和水。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 提高水位 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不仅限于一个水位。</font><font style="vertical-align: inherit;">让我们使用间隔为1–5且默认值为3的公共字段来自定义它。</font><font style="vertical-align: inherit;">初始化单元格时使用此级别。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 5)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/9cf/82f/c329cf82f9a847ac01f2754cc3252500.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/c9d/fe4/850c9dfe4694834486bf4be64ac1783a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水位3。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当水位为3时，我们得到的土地少于我们的预期。</font><font style="vertical-align: inherit;">这是因为它</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然认为水位是1。让我们对其进行修复。</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用较高的水位会导致这种情况。</font><font style="vertical-align: inherit;">牢房不会立即变成土地。</font><font style="vertical-align: inherit;">当水位为2时，第一部分仍将留在水下。</font><font style="vertical-align: inherit;">海洋底部已经上升，但仍然留在水下。</font><font style="vertical-align: inherit;">仅在至少两个部分的相交处形成平台。</font><font style="vertical-align: inherit;">水位越高，就越需要越多的场地来创造土地。</font><font style="vertical-align: inherit;">因此，随着水位的升高，土地变得更加混乱。</font><font style="vertical-align: inherit;">另外，当需要更多的地块时，它们更有可能在已经存在的土地上相交，这就是为什么在使用较小的地块的情况下，山地将变得更常见，而平地则更少。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c39/f02/abf/c39f02abf2bfa93f01395208da92ae9a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/01f/4e2/5a901f4e2785456e0784f33508be4ede.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/816/cc1/863816cc19c0fd7cbf172905962970d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/412/190/fd041219043df072443b00d6799f3946.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水位为2–5，寿司始终为50％。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 垂直运动 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 到目前为止，我们一次将情节提高了一层，但我们不必局限于此。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 高地 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管每个部分将其单元格的高度增加了一个级别，但可能会发生剪裁。</font><font style="vertical-align: inherit;">当两个部分的边缘接触时，会发生这种情况。</font><font style="vertical-align: inherit;">这可以创建孤立的悬崖，但是长长的悬崖线将很少见。</font><font style="vertical-align: inherit;">我们可以通过将图的高度增加一级以上来增加其出现的频率。</font><font style="vertical-align: inherit;">但这仅需要在一定比例的站点中完成。</font><font style="vertical-align: inherit;">如果所有区域都升高，则很难沿着地形移动。</font><font style="vertical-align: inherit;">因此，让我们使用默认值为0.25的概率字段使此参数可自定义。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highRiseProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/485/8d7/cb64858d7531bb31842aebdd49b68304.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细胞强烈上升的可能性。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们可以在高处使用任何增加的高度，但这很快就失去了控制。</font><font style="vertical-align: inherit;">高度差2已经产生了悬崖，所以这就足够了。</font><font style="vertical-align: inherit;">由于您可以跳过等于水位的高度，因此我们需要更改确定单元是否已着陆的方式。</font><font style="vertical-align: inherit;">如果水位低于水位，而现在又等于或高于水位，则我们创建了一个新的陆地单元。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rise = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; current.Elevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b31/8c1/ea5/b318c1ea557ced17d2cb0d9a951bcfc3.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ba/353/78b/4ba35378bc60e74b624e136b90a4a7eb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/8ac/b0a/ea38acb0a5cf12835c2ba177e41d6178.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/018/0df/bd9/0180dfbd9869a0d0e0d5a1712af34fb3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度急剧增加的概率为0.25、0.50、0.75和1。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 降低土地 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">土地并不总是会上升，有时会下降。</font><font style="vertical-align: inherit;">当土地降到足够低时，水就会填满，土地就会流失。</font><font style="vertical-align: inherit;">到目前为止，我们还没有这样做。</font><font style="vertical-align: inherit;">由于我们仅将区域向上推，因此土地通常看起来像是一组相当圆形的区域，混合在一起。</font><font style="vertical-align: inherit;">如果有时将面积降低，则会得到更多变化的形式。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/95e/d81/9e495ed818dfffc39e5a238f273c8c5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有沉没的寿司的大地图。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用另一个概率场来控制地面沉降的频率。</font><font style="vertical-align: inherit;">由于降低可能会破坏土地，因此降低的可能性应始终低于提高的可能性。</font><font style="vertical-align: inherit;">否则，可能需要很长时间才能获得正确比例的土地。</font><font style="vertical-align: inherit;">因此，让我们使用最大降低概率0.4和默认值0.2。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.4f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sinkProbability = <span class="hljs-number"><span class="hljs-number">0.2f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/997/e82/a11997e824700a045e9faaedaafeb121.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低的可能性。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低场地类似于升高场地，但有所不同。</font><font style="vertical-align: inherit;">因此，我们复制该方法</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其名称更改为</font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">除了确定上升幅度之外，我们需要一个可以使用相同逻辑的下降值。</font><font style="vertical-align: inherit;">同时，需要进行比较以检查我们是否已经穿过水面。</font><font style="vertical-align: inherit;">此外，降低浮雕时，我们不限于单元格的总和。</font><font style="vertical-align: inherit;">相反，每个丢失的寿司单元都会返回花费在其上的金额，因此我们将其增加并继续工作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; current.Elevation &lt; waterLevel <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; --budget == 0 ) { // break; budget += 1; } size += 1; … } searchFrontier.Clear(); return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在内部的每次迭代中，</font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们必须根据降低的可能性降低或升高土地。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/c5e/762/d6bc5e76274e4aa9c8a692f90fde3646.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/8ae/3e3/c2f8ae3e3a4b814b6ae954d40225149e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/f5d/461/1e3f5d461421feddbb145d4e1d56c000.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33b/39d/462/33b39d462682688fc2a8094556e4fc91.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掉落的概率为0.1、0.2、0.3和0.4。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 极限高度 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在当前阶段，我们可能会重叠许多部分，有时会增加一些高度，其中一些可能会下降然后再次上升。</font><font style="vertical-align: inherit;">同时，我们可以创建很高的高度，有时还可以创建非常低的高度，尤其是在需要大量土地的情况下。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/c2e/359/f3fc2e359db04b4411f2bcd06b81888b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在90％的土地上都很高。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了限制高度，让我们添加一个自定义的最小值和最大值。</font><font style="vertical-align: inherit;">合理的最小值应介于-4和0之间，可接受的最大值可以在6-10之间。</font><font style="vertical-align: inherit;">假设默认值为−2和8。当手动编辑地图时，它们将超出允许的限制，因此您可以更改UI编辑器的滑块，也可以保持不变。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(-4, 0)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMinimum = <span class="hljs-number"><span class="hljs-number">-2</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMaximum = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/20b/efc/bcb20befc496cd2c5bffbc94b0a9d267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小和最大高度。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，</font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们必须确保高度不超过允许的最大值。</font><font style="vertical-align: inherit;">这可以通过检查当前单元格是否太高来完成。</font><font style="vertical-align: inherit;">如果是这样，那么我们将跳过它们而不更改其高度并添加其邻居。</font><font style="vertical-align: inherit;">这将导致以下事实：陆地区域将避开已达到最大高度的区域，并在其周围生长。</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &gt; elevationMaximum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; newElevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在中进行相同的操作</font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但最小高度。</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = current.Elevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &lt; elevationMinimum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; newElevation &lt; waterLevel ) { budget += <span class="hljs-number"><span class="hljs-number">1</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/cbe/339/4afcbe339d0d697779ff0649f6c2c125.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度限制为90％。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 负海拔保护 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此时，保存和加载代码无法处理负高度，因为我们将高度存储为字节。</font><font style="vertical-align: inherit;">保存为大正数时将转换为负数。</font><font style="vertical-align: inherit;">因此，在保存和加载生成的地图时，可能会出现很高的位置，以代替原始的水下单元。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过将其存储为整数而不是字节来增加对负高度的支持。</font><font style="vertical-align: inherit;">但是，我们仍然不需要支持多个高度级别。</font><font style="vertical-align: inherit;">另外，我们可以通过加127来抵消存储的值。这将使我们能够在一个字节内正确存储在-127–128范围内的高度。</font><font style="vertical-align: inherit;">相应地更改</font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(elevation + <span class="hljs-number"><span class="hljs-number">127</span></span>)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们更改了保存地图数据的方式，因此</font></font><code>SaveLoadMenu.mapFileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">其</font><font style="vertical-align: inherit;">增加到4。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，对其进行更改，</font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使其从版本4文件加载的高度中减去127。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { elevation -= <span class="hljs-number"><span class="hljs-number">127</span></span>; } … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 重新创建相同的地图 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以创建各种各样的地图。</font><font style="vertical-align: inherit;">生成每个新结果时将是随机的。</font><font style="vertical-align: inherit;">我们只能使用配置选项来控制卡的特性，而不能控制最准确的形式。</font><font style="vertical-align: inherit;">但是有时我们需要再次重新创建完全相同的地图。</font><font style="vertical-align: inherit;">例如，与朋友分享精美的地图，或者在手动编辑后重新开始。</font><font style="vertical-align: inherit;">它在游戏开发过程中也很有用，所以让我们添加此功能。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用种子 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使地图生成过程不可预测，我们使用</font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要再次获得相同的伪随机数字序列，您需要使用相同的种子值。</font><font style="vertical-align: inherit;">在之前，我们已经采用了类似的方法</font></font><code>HexMetrics.InitializeHashGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它首先保存用特定种子值初始化的数字生成器的当前状态，然后恢复其原始状态。</font><font style="vertical-align: inherit;">我们可以对使用相同的方法</font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们可以再次记住旧状态，并在完成后将其还原，以免干扰使用的任何其他状态</font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; … Random.state = originalRandomState; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们需要提供用于生成最后一张卡片的种子。</font><font style="vertical-align: inherit;">这是通过使用公共整数字段完成的。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/3b5/538/41d3b553898698698636b6bada081aa6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示种子。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要种子值来初始化</font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要创建随机卡片，您需要使用随机种子。</font><font style="vertical-align: inherit;">最简单的方法是使用任意种子值生成</font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了不影响初始随机状态，我们需要在保存后执行此操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); Random.InitState(seed); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于完成后我们将恢复随机状态，因此如果立即生成另一张卡，结果将获得相同的种子值。</font><font style="vertical-align: inherit;">另外，我们不知道初始随机状态是如何初始化的。</font><font style="vertical-align: inherit;">因此，尽管它可以作为任意起点，但是我们需要更多的东西才能在每次调用时将其随机化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有多种初始化随机数生成器的方法。</font><font style="vertical-align: inherit;">在这种情况下，您可以简单地组合多个在很大范围内变化的任意值，也就是说，重新生成同一张卡的可能性很低。</font><font style="vertical-align: inherit;">例如，我们使用系统时间的低32位（以周期表示）加上应用程序的当前运行时。</font><font style="vertical-align: inherit;">使用按位异或运算将这些值组合在一起，以使结果不是很大。</font></font><br><br><pre> <code class="cs hljs"> seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果数字可能为负，这对于公共价值种子而言似乎不是很好。</font><font style="vertical-align: inherit;">我们可以通过使用最大整数值的按位屏蔽来使它严格为正，这将重置符号位。</font></font><br><br><pre> <code class="cs hljs"> seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; Random.InitState(seed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可重复使用的种子 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仍然会生成随机卡，但是现在我们可以看到每个卡使用了什么种子值。</font><font style="vertical-align: inherit;">要再次重新创建相同的地图，我们必须命令生成器再次使用相同的种子值，而不是创建新的种子值。</font><font style="vertical-align: inherit;">我们将通过使用布尔字段添加一个开关来做到这一点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useFixedSeed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/200/4c6/eed/2004c6eed8c2244bdfe660bf477d2fa3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择使用恒定种子。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果选择了常量种子，那么我们只需跳过中的生成新种子</font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们不手动更改种子字段，那么结果将再次是同一张地图。</font></font><br><br><pre> <code class="cs hljs"> Random.State originalRandomState = Random.state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!useFixedSeed) { seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.time; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以复制所需地图的种子值并将其保存在某个位置，以便将来再次生成它。</font><font style="vertical-align: inherit;">不要忘了，只有使用完全相同的生成器参数（即，相同的卡大小以及所有其他配置选项）时，我们才能获得同一张卡。</font><font style="vertical-align: inherit;">即使这些概率发生很小的变化，也可以创建完全不同的地图。</font><font style="vertical-align: inherit;">因此，除了种子之外，我们还需要记住所有设置。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/cd2/279/7ffcd2279b4dd882db924d8e1fc61d0e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/6db/156/4866db15628d75936b7e19fa4841f2f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">种子值为0和929396788的大型卡，标准参数。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427003/">https://habr.com/ru/post/zh-CN427003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426991/index.html">创业文摘：莫斯科即将举行的10个IT事件</a></li>
<li><a href="../zh-CN426993/index.html">我需要学习C才能理解计算机的工作原理吗？</a></li>
<li><a href="../zh-CN426995/index.html">回收会危害产品和员工</a></li>
<li><a href="../zh-CN426997/index.html">如何使用MaterialShapeDrawable创建自定义形状</a></li>
<li><a href="../zh-CN426999/index.html">顺应趋势，或转向RxJava和LiveData</a></li>
<li><a href="../zh-CN427005/index.html">AI开发人员-百万富翁的职业？</a></li>
<li><a href="../zh-CN427009/index.html">电子的“行走”：对不饱和键结构内部的电荷的操纵</a></li>
<li><a href="../zh-CN427011/index.html">我的“ Hello World！” 在FPGA或UART的下一版本上</a></li>
<li><a href="../zh-CN427013/index.html">面对面的NeoQUEST-2018：还记得吗</a></li>
<li><a href="../zh-CN427015/index.html">为什么商业智能数据中心需要智能PDU？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>