<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó°Ô∏è üî¥ üîº Migrar un esquema de base de datos sin tiempo de inactividad para postgresql usando django como ejemplo üë©üèª üíû üéÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Hola Habr! 


 Quiero compartir la experiencia de escribir migraciones para postgres y django. Esto ser√° principalmente sobre postgre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migrar un esquema de base de datos sin tiempo de inactividad para postgresql usando django como ejemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425063/"><h1 id="vvedenie">  Introduccion </h1><br><p>  Hola Habr! </p><br><p>  Quiero compartir la experiencia de escribir migraciones para postgres y django.  Esto ser√° principalmente sobre postgres, django es una buena adici√≥n aqu√≠, ya que tiene una migraci√≥n autom√°tica del esquema de datos para cambios de modelo listos para usar, es decir, tiene una lista bastante completa de operaciones de trabajo para cambiar el esquema.  Django se puede reemplazar con cualquier marco / biblioteca favorito: los enfoques probablemente ser√°n similares. </p><br><p>  No describir√© c√≥mo llegu√© a esto, pero ahora que leo la documentaci√≥n me doy cuenta de que era necesario hacer esto antes con m√°s cuidado y conciencia, por lo que lo recomiendo encarecidamente. </p><br><p>  Antes de continuar, d√©jame hacer las siguientes suposiciones. </p><br><p>  Puede dividir la l√≥gica de trabajar con la base de datos de la mayor√≠a de las aplicaciones en 3 partes: </p><br><ol><li> Migraciones: al cambiar el esquema de la base de datos (tablas), supongamos que siempre las ejecutamos en un hilo. </li><li>  L√≥gica empresarial: el trabajo directo con datos (en tablas de usuario), trabaja con los mismos datos de forma constante y competitiva. </li><li>  Migraciones de datos: no cambien los esquemas de datos, funcionan esencialmente como la l√≥gica de negocios, de forma predeterminada, cuando hablamos de l√≥gica de negocios, tambi√©n nos referiremos a las migraciones de datos. </li></ol><br><p>  El tiempo de inactividad es un estado en el que parte de nuestra l√≥gica empresarial no est√° disponible / cae / se carga durante un tiempo notable para el usuario, supongamos que esto es un par de segundos. </p><br><p>  La ausencia de tiempo de inactividad puede ser una condici√≥n cr√≠tica para un negocio, que debe ser respetada por cualquier esfuerzo. <a name="habracut"></a></p><br><h1 id="process-vykatki">  Proceso de despliegue </h1><br><p>  Los principales requisitos al implementar: </p><br><ol><li>  Tenemos una base de trabajo. </li><li>  Tenemos varias m√°quinas donde la l√≥gica de negocios gira. </li><li>  Los autos con l√≥gica de negocios est√°n ocultos detr√°s del balanceador. </li><li>  nuestra aplicaci√≥n funciona bien antes, durante y despu√©s de la migraci√≥n continua (el c√≥digo antiguo funciona correctamente con el esquema de base de datos antiguo y nuevo). </li><li>  Nuestra aplicaci√≥n funciona bien antes, durante y despu√©s de actualizar el c√≥digo en los autom√≥viles (el c√≥digo antiguo y el nuevo funcionan correctamente con el esquema de base de datos actual). </li></ol><br><p>  Si hay una gran cantidad de cambios y el despliegue deja de satisfacer estas condiciones, entonces se divide en el n√∫mero requerido de despliegues m√°s peque√±os que satisfacen estas condiciones, de lo contrario, tenemos un tiempo de inactividad. </p><br><p>  Orden de despliegue directo: </p><br><ol><li>  inund√≥ la migraci√≥n; </li><li>  quit√≥ una m√°quina del equilibrador, actualiz√≥ la m√°quina y reinici√≥, devolvi√≥ la m√°quina al equilibrador; </li><li>  repiti√≥ el paso anterior para actualizar todos los autos. </li></ol><br><p>  El orden de despliegue inverso es relevante para eliminar tablas y columnas en una tabla, cuando creamos autom√°ticamente migraciones de acuerdo con el esquema modificado y validamos la presencia de todas las migraciones a CI: </p><br><ol><li>  quit√≥ una m√°quina del equilibrador, actualiz√≥ la m√°quina y reinici√≥, devolvi√≥ la m√°quina al equilibrador; </li><li>  repiti√≥ el paso anterior para actualizar todos los autos; </li><li>  inund√≥ la migraci√≥n. </li></ol><br><h1 id="teoriya">  Teor√≠a </h1><br><p>  Postgres es una excelente base de datos, podemos escribir una aplicaci√≥n que escribir√° y leer√° los mismos datos en cientos y miles de flujos, y con una alta probabilidad podemos estar seguros de que nuestros datos seguir√°n siendo v√°lidos y no se da√±ar√°n, en general, ACID completo.  Postgres implementa varios mecanismos para lograr esto; uno de ellos es el bloqueo. </p><br><p>  Postgres tiene varios tipos de bloqueos, puede ver m√°s detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , como parte del tema, solo cubrir√© los bloqueos de tabla y escritura. </p><br><h2 id="blokirovki-na-urovne-tablicy">  Cerraduras a nivel de mesa </h2><br><p>  A nivel de tabla, postgres tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varios tipos de bloqueos</a> , la caracter√≠stica principal es que tienen conflictos, es decir, dos operaciones con bloqueos en conflicto no se pueden realizar simult√°neamente: </p><br><table><thead><tr><th></th><th><code>ACCESS SHARE</code> </th> <th> <code>ROW SHARE</code> </th> <th> <code>ROW EXCLUSIVE</code> </th> <th> <code>SHARE UPDATE EXCLUSIVE</code> </th> <th> <code>SHARE</code> </th> <th> <code>SHARE ROW EXCLUSIVE</code> </th> <th> <code>EXCLUSIVE</code> </th> <th> <code>ACCESS EXCLUSIVE</code> </th> </tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>ROW SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE ROW EXCLUSIVE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>EXCLUSIVE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p>  Por ejemplo, <code>ALTER TABLE tablename ADD COLUMN newcolumn integer</code> y <code>SELECT COUNT(*) FROM tablename</code> deben ejecutarse estrictamente uno por uno, de lo contrario no podemos averiguar qu√© columnas volver a <code>COUNT(*)</code> . </p><br><p>  En las migraciones de django (lista completa a continuaci√≥n), existen las siguientes operaciones y sus bloqueos correspondientes: </p><br><table><thead><tr><th>  bloqueo </th><th>  operaciones </th></tr></thead><tbody><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> , <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>SHARE</code> </td> <td> <code>CREATE INDEX</code> </td> </tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td>  <code>CREATE INDEX CONCURRENTLY</code> , <code>DROP INDEX CONCURRENTLY</code> , <code>ALTER TABLE VALIDATE CONSTRAINT</code> </td></tr></tbody></table><br><p>  De los comentarios, no todas las <code>ALTER TABLE</code> tienen un <code>ACCESS EXCLUSIVE</code> bloqueo, tampoco las migraciones de django no tienen <code>CREATE INDEX CONCURRENTLY</code> y <code>ALTER TABLE VALIDATE CONSTRAINT</code> , pero ser√°n necesarias para una alternativa m√°s segura a las operaciones est√°ndar un poco m√°s tarde. </p><br><p>  Si las migraciones se realizan en un hilo secuencialmente, entonces todo se ve bien, ya que la migraci√≥n no entrar√° en conflicto con otra migraci√≥n, pero nuestra l√≥gica de negocios funcionar√° solo durante la migraci√≥n y el conflicto. </p><br><table><thead><tr><th>  bloqueo </th><th>  operaciones </th><th>  conflictos con cerraduras </th><th>  conflictos con operaciones </th></tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td> <code>SELECT</code> </td> <td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> <code>ALTER TABLE</code> <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW SHARE</code> </td> <td> <code>SELECT FOR UPDATE</code> </td> <td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> <code>ALTER TABLE</code> <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td>  <code>INSERT</code> , <code>UPDATE</code> , <code>DELETE</code> </td><td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> , <code>SHARE ROW EXCLUSIVE</code> , <code>SHARE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> , <code>CREATE INDEX</code> </td></tr></tbody></table><br><p>  Aqu√≠ se pueden resumir dos puntos: </p><br><ol><li>  Si hay una alternativa con un bloqueo m√°s f√°cil, puede usarla como <code>CREATE INDEX</code> y <code>CREATE INDEX CONCURRENTLY</code> . </li><li>  la mayor√≠a de las migraciones para cambiar el esquema de datos entran en conflicto con la l√≥gica comercial, adem√°s, entran en conflicto con <code>ACCESS EXCLUSIVE</code> , es decir, ni siquiera podremos <code>SELECT</code> mientras mantenemos este bloqueo y posiblemente esperamos un tiempo de inactividad aqu√≠, excepto en el caso en que esta operaci√≥n no funcione instant√°neamente y nuestro tiempo de inactividad ser√° Un par de segundos. </li></ol><br><p>  Debe haber una opci√≥n, o siempre evitamos <code>ACCESS EXCLUSIVE</code> , es decir, creamos nuevas placas y copiamos los datos all√≠, de manera confiable, pero durante mucho tiempo para una gran cantidad de datos, o hacemos <code>ACCESS EXCLUSIVE</code> m√°s r√°pido posible y hacemos advertencias adicionales contra el tiempo de inactividad: es potencialmente peligroso, pero r√°pido. </p><br><h2 id="blokirovki-na-urovne-zapisi">  Grabar cerraduras </h2><br><p>  En el nivel de grabaci√≥n, tambi√©n hay bloqueos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS</a> , tambi√©n entran en conflicto, pero solo afectan nuestra l√≥gica comercial: </p><br><table><thead><tr><th></th><th> <code>FOR KEY SHARE</code> </th> <th> <code>FOR SHARE</code> </th> <th> <code>FOR NO KEY UPDATE</code> </th> <th> <code>FOR UPDATE</code> </th> </tr></thead><tbody><tr><td> <code>FOR KEY SHARE</code> </td> <td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>FOR SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR NO KEY UPDATE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR UPDATE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p>  Este es el punto principal en las migraciones de datos, es decir, si <code>UPDATE</code> la migraci√≥n de datos en toda la placa, entonces el resto de la l√≥gica de negocios, que actualiza los datos, esperar√° a que se libere el bloqueo y puede exceder nuestro umbral de tiempo de inactividad, por lo tanto, es mejor hacer actualizaciones en partes para migraciones de datos.  Tambi√©n vale la pena se√±alar que cuando se usan consultas sql m√°s complejas para migraciones de datos, la divisi√≥n en partes puede funcionar m√°s r√°pido, ya que puede usar un plan e √≠ndices m√°s √≥ptimos. </p><br><h2 id="ocheryodnost-vypolneniya-operaciy">  El orden de las operaciones </h2><br><p>  Otro conocimiento importante es c√≥mo se realizar√°n las operaciones, cu√°ndo y c√≥mo toman y liberan bloqueos: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/889/8f9/adb/8898f9adbf4eab0350517d07177b7257.png" alt="imagen"></p><br><p>  Aqu√≠ puede resaltar los siguientes elementos: </p><br><ol><li>  tiempo de ejecuci√≥n de la operaci√≥n: para la migraci√≥n, es el momento de mantener el bloqueo, si el bloqueo pesado se mantiene durante mucho tiempo, tendremos un tiempo de inactividad, por ejemplo, puede ser con <code>CREATE INDEX</code> o <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> (en postgres 11 esto es mejor). </li><li>  el tiempo de espera para bloqueos en conflicto, es decir, la migraci√≥n espera hasta que todas las solicitudes en conflicto funcionen, y en este momento las nuevas solicitudes esperar√°n nuestra migraci√≥n, las solicitudes lentas pueden ser muy peligrosas aqu√≠, ya sea simplemente no √≥ptimas o anal√≠ticas, por lo que no deber√≠a haber solicitudes lentas durante migraci√≥n </li><li>  la cantidad de solicitudes por segundo: si tenemos muchas solicitudes funcionando durante mucho tiempo, las conexiones gratuitas pueden finalizar r√°pidamente y, en lugar de un lugar problem√°tico, toda la base de datos puede entrar en tiempo de inactividad (solo habr√° un l√≠mite de conexi√≥n para el superusuario), aqu√≠ debe evitar solicitudes lentas, reducir la cantidad de solicitudes por ejemplo, inicie las migraciones durante la carga m√≠nima, separe los componentes cr√≠ticos en diferentes servicios con sus propias bases de datos. </li><li>  hay muchas operaciones de migraciones en una transacci√≥n: cuantas m√°s operaciones se realicen en una transacci√≥n, m√°s tiempo se mantendr√° el bloqueo pesado, por lo tanto, es mejor separar las operaciones pesadas, sin <code>ALTER TABLE VALIDATE CONSTRAINT</code> o migraciones de datos en una transacci√≥n con un bloqueo pesado. </li></ol><br><h2 id="taymauty">  Tiempos de espera </h2><br><p>  <code>lock_timeout</code> tiene configuraciones como <code>lock_timeout</code> y <code>statement_timeout</code> , que pueden proteger el inicio de las migraciones, tanto de la migraci√≥n mal escrita como de las malas condiciones en las que se puede desencadenar la migraci√≥n.  Se pueden instalar tanto globalmente como para la conexi√≥n actual. </p><br><p>  <code>SET lock_timeout TO '2s'</code> evitar√° el tiempo de inactividad mientras espera solicitudes / transacciones lentas antes de la migraci√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT</a> . </p><br><p>  <code>SET statement_timeout TO '2s'</code> evitar√° el tiempo de inactividad al comenzar una migraci√≥n pesada con un bloqueo pesado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT</a> . </p><br><h2 id="dedloki">  Puntos muertos </h2><br><p>  Los puntos muertos en las migraciones no tienen que ver con el tiempo de inactividad, pero no es agradable cuando se escribe la migraci√≥n, funciona bien en un entorno de prueba, pero atrapa los puntos muertos al rodar en el producto.  Las principales fuentes de problemas pueden ser una gran cantidad de operaciones en una transacci√≥n y una clave externa, ya que crea bloqueos en ambas tablas, por lo que es mejor separar las operaciones de migraci√≥n, cuanto m√°s at√≥micas, mejor. </p><br><h2 id="hranenie-zapisey">  Almacenamiento de registros </h2><br><p>  Postgres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">almacena valores de diferentes tipos de diferentes maneras</a> : si los tipos se almacenan de diferentes maneras, la conversi√≥n entre ellos requerir√° una reescritura completa de todos los valores, afortunadamente, algunos tipos se almacenan de la misma manera y no necesitan reescribirse cuando se cambian.  Por ejemplo, las filas se almacenan de la misma manera, independientemente del tama√±o, y la disminuci√≥n / aumento de la dimensi√≥n de una fila no requerir√° reescritura, pero la disminuci√≥n requiere verificar que todas las filas no excedan un tama√±o menor.  Otros tipos tambi√©n pueden almacenarse de manera similar y tener caracter√≠sticas similares. </p><br><h2 id="multiversion-concurrency-control-mvcc">  Control de concurrencia multiversional (MVCC) </h2><br><p>  Seg√∫n la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> , la consistencia de postgres se basa en la multiversion de datos, es decir, cada transacci√≥n y operaci√≥n ve su propia versi√≥n de los datos.  Esta caracter√≠stica hace frente al acceso competitivo y tambi√©n tiene un efecto interesante cuando el cambio de un esquema como agregar y eliminar columnas solo cambia el esquema, si no hay operaciones adicionales para cambiar datos, √≠ndices o constantes, despu√©s de lo cual las operaciones de inserci√≥n y actualizaci√≥n a un nivel bajo crear√°n nuevas registros con todos los valores necesarios, la eliminaci√≥n marcar√° el registro correspondiente eliminado.  VACUUM o AUTO VACUUM es responsable de limpiar los restos restantes. </p><br><h1 id="primer-django">  Ejemplo de Django </h1><br><p>  Ahora tenemos una idea de qu√© tiempo de inactividad puede depender y c√≥mo evitarlo, pero antes de aplicar el conocimiento, puede ver lo que django ofrece de inmediato ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/django/django/blob/2.1.2/django /db/backends/base/schema.py</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/django/django/blob/2.1.2/django/db/backends/postgresql/schema.py</a> ): </p><br><table><thead><tr><th></th><th>  operaci√≥n </th></tr></thead><tbody><tr><td>  1 </td><td> <code>CREATE SEQUENCE</code> </td> </tr><tr><td>  2 </td><td> <code>DROP SEQUENCE</code> </td> </tr><tr><td>  3 </td><td> <code>CREATE TABLE</code> </td> </tr><tr><td>  4 4 </td><td> <code>DROP TABLE</code> </td> </tr><tr><td>  5 5 </td><td> <code>ALTER TABLE RENAME TO</code> </td> </tr><tr><td>  6 6 </td><td> <code>ALTER TABLE SET TABLESPACE</code> </td> </tr><tr><td>  7 7 </td><td> <code>ALTER TABLE ADD COLUMN [SET DEFAULT] [SET NOT NULL] [PRIMARY KEY] [UNIQUE]</code> </td> </tr><tr><td>  8 </td><td> <code>ALTER TABLE ALTER COLUMN [TYPE] [SET NOT NULL|DROP NOT NULL] [SET DEFAULT|DROP DEFAULT]</code> </td> </tr><tr><td>  9 9 </td><td> <code>ALTER TABLE DROP COLUMN</code> </td> </tr><tr><td>  10 </td><td> <code>ALTER TABLE RENAME COLUMN</code> </td> </tr><tr><td>  11 </td><td> <code>ALTER TABLE ADD CONSTRAINT CHECK</code> </td> </tr><tr><td>  12 </td><td> <code>ALTER TABLE DROP CONSTRAINT CHECK</code> </td> </tr><tr><td>  13 </td><td> <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  14 </td><td> <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  15 </td><td> <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  16 </td><td> <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  17 </td><td> <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  18 a√±os </td><td> <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  19 </td><td> <code>CREATE INDEX</code> </td> </tr><tr><td>  20 </td><td> <code>DROP INDEX</code> </td> </tr></tbody></table><br><p>  Django cubre mis necesidades de migraci√≥n muy bien, ahora podemos discutir operaciones seguras y peligrosas para migraciones sin tiempo de inactividad con nuestro conocimiento. </p><br><p>  Llamaremos migraciones m√°s seguras con el bloqueo <code>SHARE UPDATE EXCLUSIVE</code> o <code>ACCESS EXCLUSIVE</code> , que funciona al instante. <br>  Llamaremos migraciones peligrosas con los bloqueos <code>SHARE</code> y <code>ACCESS EXCLUSIVE</code> , lo que lleva un tiempo considerable. </p><br><p>  Dejar√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> √∫til <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a la documentaci√≥n</a> por adelantado con excelentes ejemplos. </p><br><h2 id="sozdanie-i-udalenie-tablicy">  Crear y eliminar una tabla </h2><br><p>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> puede llamarse seguro, ya que la l√≥gica de negocios ya no funciona con la tabla migrada, el comportamiento de eliminar una tabla con FOREIGN KEY ser√° un poco m√°s tarde. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochih-tablicah">  Operaciones de hoja de trabajo muy compatibles </h2><br><p>  <code>ALTER TABLE RENAME TO</code> - No puedo llamarlo seguro, ya que es dif√≠cil escribir una l√≥gica que funcione con una tabla as√≠ antes y despu√©s de la migraci√≥n. </p><br><p>  <code>ALTER TABLE SET TABLESPACE</code> - inseguro, ya que mueve f√≠sicamente la placa, y esto puede llevar mucho tiempo en un gran volumen. </p><br><p>  Por otro lado, estas operaciones son bastante raras, como alternativa, puede ofrecer la creaci√≥n de una nueva tabla y copiar datos en ella. </p><br><h2 id="sozdanie-i-udalenie-kolonki">  Crear y eliminar columnas </h2><br><p>  <code>ALTER TABLE ADD COLUMN</code> , <code>ALTER TABLE DROP COLUMN</code> : se puede llamar seguro (creaci√≥n sin DEFAULT / NOT NULL / PRIMARY KEY / UNIQUE), porque la l√≥gica de negocios ya no funciona con una columna migrada, el comportamiento de eliminar una columna con FOREIGN KEY, otras constantes e √≠ndices vendr√°n despu√©s. </p><br><p>  <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> , <code>ALTER TABLE ADD COLUMN SET NOT NULL</code> , <code>ALTER TABLE ADD COLUMN PRIMARY KEY</code> , <code>ALTER TABLE ADD COLUMN UNIQUE</code> - operaciones inseguras, porque agregan una columna y, sin liberar bloqueos, actualizan datos con valores predeterminados o crean construcciones como alternativas, columnas anulables y m√°s cambios. </p><br><p>  Vale la pena mencionar el <code>SET DEFAULT</code> m√°s r√°pido en postgres 11, puede considerarse seguro, pero no es muy √∫til en django, ya que django usa <code>SET DEFAULT</code> solo para llenar la columna y luego hace <code>DROP DEFAULT</code> , y en el intervalo entre la migraci√≥n y la actualizaci√≥n de las m√°quinas con l√≥gica empresarial, se pueden crear registros en los que el valor predeterminado estar√° ausente, es decir, de todos modos, realizar la migraci√≥n de datos. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochey-tablice">  Operaciones fuertemente soportadas en una hoja de trabajo </h2><br><p>  <code>ALTER TABLE RENAME COLUMN</code> : tampoco puedo llamarlo seguro, ya que es dif√≠cil escribir una l√≥gica que funcione con una columna de este tipo antes y despu√©s de la migraci√≥n.  Por el contrario, esta operaci√≥n tampoco ser√° frecuente, ya que se puede proponer una alternativa para crear una nueva columna y copiarle datos. </p><br><h2 id="izmenenie-kolonki">  Cambio de columna </h2><br><p>  <code>ALTER TABLE ALTER COLUMN TYPE</code> : la operaci√≥n puede ser peligrosa y segura.  Seguro si postgres cambia solo el esquema, y ‚Äã‚Äãlos datos ya est√°n almacenados en el formato requerido y no se necesitan verificaciones de tipo adicionales, por ejemplo: </p><br><ul><li>  cambio de tipo de <code>varchar(LESS)</code> a <code>varchar(MORE)</code> ; </li><li>  cambio de tipo de <code>varchar(ANY)</code> a <code>text</code> ; </li><li>  escriba cambio de <code>numeric(LESS, SAME)</code> a <code>numeric(MORE, SAME)</code> . </li></ul><br><p>  <code>ALTER TABLE ALTER COLUMN SET NOT NULL</code> es peligroso porque pasa a trav√©s de los datos en el interior y verifica NULL, afortunadamente esta construcci√≥n puede ser reemplazada por otra <code>CHECK IS NOT NULL</code> .  Vale la pena se√±alar que este reemplazo conducir√° a un esquema diferente, pero con propiedades id√©nticas. </p><br><p>  <code>ALTER TABLE ALTER COLUMN DROP NOT NULL</code> , <code>ALTER TABLE ALTER COLUMN SET DEFAULT</code> , <code>ALTER TABLE ALTER COLUMN DROP DEFAULT</code> </p><br><h2 id="sozdanie-i-udalenie-indeksov-i-konstreyntov">  Crear y eliminar √≠ndices y constantes </h2><br><p>  <code>ALTER TABLE ADD CONSTRAINT CHECK</code> y <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> son operaciones inseguras, pero se pueden declarar como <code>NOT VALID</code> y luego <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> y <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> no <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> seguros, ya que crean un √≠ndice √∫nico en su interior, pero puede crear un √≠ndice √∫nico como <code>CONCURRENTLY</code> , luego cree la constante correspondiente utilizando un √≠ndice listo a trav√©s de <code>USING INDEX</code> . </p><br><p>  <code>CREATE INDEX</code> es una operaci√≥n insegura, pero se puede crear un √≠ndice como <code>CONCURRENTLY</code> . </p><br><p>  <code>ALTER TABLE DROP CONSTRAINT CHECK</code> <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> , <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> , <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> , <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> , <code>DROP INDEX</code> DE <code>DROP INDEX</code> - operaciones seguras </p><br><p>  Vale la pena se√±alar que <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> y <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> bloquean dos tablas a la vez. </p><br><h2 id="primenyaem-znaniya-v-django">  Aplicando conocimiento en django </h2><br><p>  Django tiene una operaci√≥n en migraciones para ejecutar cualquier SQL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://docs.djangoproject.com/en/2.1/ref/migration-operations/#django.db.migrations.operations.RunSQL</a> .  A trav√©s de √©l, puede establecer los tiempos de espera necesarios y aplicar operaciones alternativas para las migraciones, indicando <code>state_operations</code> , la migraci√≥n que estamos reemplazando. </p><br><p>  Esto funciona bien para su c√≥digo, aunque requiere escritura adicional, pero puede dejar el trabajo sucio en el backend de db, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/tbicr/django-pg-zero-downtime-migrations/blob/master/django_zero_downtime_migrations_postgres_backend/schema .py</a> recopila las pr√°cticas descritas y reemplaza las operaciones inseguras con contrapartes seguras, y esto funcionar√° para bibliotecas de terceros. </p><br><h1 id="naposledok">  Al final </h1><br><p>  Estas pr√°cticas me permitieron obtener un esquema id√©ntico creado por django fuera de la caja, con la excepci√≥n de reemplazar la construcci√≥n <code>CHECK IS NOT NULL</code> lugar de <code>NOT NULL</code> y algunos nombres de construcci√≥n (por ejemplo, para <code>ALTER TABLE ADD COLUMN UNIQUE</code> y una alternativa).  Otra compensaci√≥n puede ser la falta de transaccionalidad para las operaciones de migraci√≥n alternativas, especialmente donde <code>ALTER TABLE VALIDATE CONSTRAINT</code> <code>CREATE INDEX CONCURRENTLY</code> y <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  Si no va m√°s all√° de postgres, puede haber muchas opciones para cambiar el esquema de datos, y se pueden variar en combinaci√≥n bajo condiciones espec√≠ficas: </p><br><ul><li>  usando jsonb como soluci√≥n schamaless </li><li>  la oportunidad de ir al tiempo de inactividad </li><li>  requisito para realizar migraciones sin tiempo de inactividad </li></ul><br><p>  En cualquier caso, espero que el material haya resultado √∫til para aumentar el tiempo de actividad o para expandir la conciencia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425063/">https://habr.com/ru/post/es425063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425053/index.html">SSR: cu√°ndo, por qu√© y para qu√©. En el ejemplo de Vue</a></li>
<li><a href="../es425055/index.html">B√∫squeda de Oculus</a></li>
<li><a href="../es425057/index.html">Pr√©stamo preferencial para educaci√≥n para todos los programas GeekUniversity de GeekBrains y Alfa Bank</a></li>
<li><a href="../es425059/index.html">Hackathon No. 1 en Tinkoff.ru</a></li>
<li><a href="../es425061/index.html">CodeRainbow: aprendizaje interactivo de c√≥digo y documentaci√≥n</a></li>
<li><a href="../es425069/index.html">Probar un presentador usando PromiseKit</a></li>
<li><a href="../es425071/index.html">¬øC√≥mo protegerse contra el desbordamiento de la pila (en Cortex M)?</a></li>
<li><a href="../es425073/index.html">Creaci√≥n f√°cil del repositorio git en OneDrive</a></li>
<li><a href="../es425075/index.html">Visi√≥n artificial: instalaci√≥n, configuraci√≥n y uso de Google Cloud Vision en PHP</a></li>
<li><a href="../es425077/index.html">Kotlin debajo del cap√≥: vea el c√≥digo de bytes descompilado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>