<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🥝 🧕🏼 ZIO & Cats Effect: uma aliança de sucesso 👂🏽 🛌 👩🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Cats Effect se tornou uma espécie de “Fluxos Reativos” para o mundo funcional do Scala, permitindo combinar todo o ecossistema diversificado de bibl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO & Cats Effect: uma aliança de sucesso</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  O Cats Effect se tornou uma espécie de “Fluxos Reativos” para o mundo funcional do Scala, permitindo combinar todo o ecossistema diversificado de bibliotecas. <br><br>  Muitas excelentes bibliotecas: http4s, fs2, doobie - são implementadas apenas com base nas classes de tipo do Cats Effect.  E bibliotecas como ZIO e Monix, por sua vez, fornecem instâncias dessas classes de tipos para seus tipos de efeitos.  Apesar de alguns problemas que serão corrigidos na versão 3.0, o Cats Effect ajuda muitos colaboradores de código aberto a dar suporte orgânico a todo o ecossistema funcional da linguagem Scala.  Os desenvolvedores que usam o Cats Effect enfrentam uma escolha difícil: qual implementação de efeitos usar em seus aplicativos. <br><br>  Hoje existem três alternativas: <br><br><ul><li>  Cats IO, implementação de referência; </li><li>  Monix, o tipo de dados Task e sua reatividade no código; </li><li>  ZIO, o tipo de dados ZIO e seu escopo de segmentação cruzada. </li></ul><br>  Neste post, tentarei provar a você que, para criar seu aplicativo usando o Cats Effect, o ZIO é uma boa escolha com soluções e recursos de design bastante diferentes da implementação de referência no Cats IO. <br><a name="habracut"></a><br><h2>  1. Melhor arquitetura MTL / sem tags-final </h2><br>  MTL (Monad Transformers Library) é um estilo de programação no qual as funções são polimórficas por seu tipo de efeito e expressam seus requisitos por meio de uma "restrição de classe de tipo".  Em Scala, isso geralmente é chamado de estilo final sem etiqueta (embora não seja a mesma coisa), especialmente quando a classe de tipo não possui leis. <br><br>  É sabido que é impossível definir uma instância global para classes clássicas de tipo MTL como Writer e State, bem como para tipos de efeito como Cats IO.  O problema é que instâncias dessas classes de tipos para esses tipos de efeitos requerem acesso a um estado mutável, que não pode ser criado globalmente, porque a criação de um estado mutável também é um efeito. <br><br>  Para um melhor desempenho, no entanto, é importante evitar "transformadores de mônada" e fornecer a implementação Write e State diretamente, além do tipo de efeito principal. <br><br>  Para conseguir isso, os programadores Scala usam um truque: eles criam instâncias (mas limpas) no nível superior de seus programas com efeitos e, em seguida, as fornecem no programa como implicações locais: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  Apesar de útil, esse truque ainda é uma "muleta".  Em um mundo ideal, todas as instâncias de classes de tipos podem ser coerentes (uma instância por tipo) e não serem criadas localmente, gerando efeitos, e então se envolvem magicamente em valores implícitos para uso por métodos subseqüentes. <br><br>  Um ótimo recurso do MTL / tagless-final é que você pode definir diretamente a maioria das instâncias sobre o tipo de dados ZIO usando o ambiente ZIO. <br><br>  Aqui está uma maneira de criar uma definição global do MonadState para um tipo de dados ZIO: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Uma instância agora é definida globalmente para qualquer ambiente que suporte pelo menos <code>State[S]</code> . <br><br>  Da mesma forma para <code>FunctorListen</code> , também conhecido como <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  E, é claro, podemos fazer o mesmo com o <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Essa técnica é facilmente aplicável a outras classes de tipos, incluindo classes de tipo final sem tag, instâncias das quais pode exigir efeitos de geração (alterações, configurações), funções de teste que geram efeitos (combinando efeitos do ambiente com final sem tag) ou qualquer outra coisa facilmente acessível a partir do ambiente . <br><br>  Não há mais transformações monádicas lentas!  Digamos "não" para criar efeitos ao inicializar instâncias da classe de classe, para implicações locais.  Não são necessárias mais muletas.  Imersão direta em pura programação funcional. <br><br><h2>  2. Economizando recursos para meros mortais </h2><br>  Um dos primeiros recursos do ZIO foi a intercepção - a capacidade do tempo de execução do ZIO interromper instantaneamente qualquer efeito executável e garantir a liberação de todos os recursos.  Uma implementação grosseira desse recurso atingiu o Cats IO. <br><br>  Haskell chamou essa funcionalidade de exceção assíncrona, que permite criar e usar com eficiência a latência, operações paralelas e competitivas eficientes e cálculos globalmente ideais.  Essas interrupções não apenas trazem grandes benefícios, mas também representam tarefas complexas no campo de suporte ao acesso seguro aos recursos. <br><br>  Programadores são usados ​​para rastrear erros em programas através de análises simples.  Isso também pode ser feito com o ZIO, que usa um sistema de tipos para ajudar a detectar erros.  Mas interrupção é outra coisa.  Um efeito criado a partir de muitos outros efeitos pode ser interrompido em qualquer borda. <br><br>  Considere o seguinte efeito: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  A maioria dos desenvolvedores não ficará surpresa com esse cenário: <code>closeFile</code> não será executado se o <code>readFile</code> travar.  Felizmente, o sistema de efeitos tem uma <code>ensuring</code> ( <code>guarantee</code> no Efeito Gatos) que permite adicionar um manipulador final ao efeito finalizador, semelhante ao finalmente. <br><br>  Portanto, o principal problema do código acima pode ser facilmente resolvido: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Agora, o efeito tornou-se "resistente a quedas", no sentido de que, se o <code>readFile</code> interrompido, o arquivo ainda será fechado.  E se o <code>readFile</code> for bem-sucedido, o arquivo também será fechado.  Em todos os casos, o arquivo será fechado. <br><br>  Mas ainda não é bem assim.  Interrupção significa que o efeito pode ser interrompido em qualquer lugar, mesmo entre <code>openFile</code> e <code>openFile</code> .  Se isso acontecer, o arquivo aberto não será fechado e ocorrerá um vazamento de recursos. <br><br>  O padrão de obter e liberar um recurso é tão amplo que o ZIO introduziu um operador de bracket, que também apareceu no Cats Effect 1.0.  A instrução Bracket protege contra interrupções: se o recurso for recebido com êxito, a liberação ocorrerá mesmo que o efeito do recurso seja interrompido.  Além disso, nem o recebimento nem a liberação do recurso podem ser interrompidos, garantindo assim a segurança do recurso. <br><br>  Usando o colchete, o exemplo acima ficaria assim: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Infelizmente, o colchete encapsula apenas um padrão de consumo de recursos (bastante geral).  Existem muitos outros, especialmente com estruturas de dados competitivas, cujo acesso deve estar acessível para interrupções; caso contrário, são possíveis vazamentos. <br><br>  Em geral, todo o trabalho de interrupção se resume a duas coisas principais: <br><br><ul><li>  evitar interrupções em algumas áreas que podem ser interrompidas; </li><li>  permitir a interrupção em áreas que podem congelar. </li></ul><br>  O ZIO tem a capacidade de implementar ambos.  Por exemplo, podemos desenvolver nossa própria versão do bracket usando abstrações ZIO de baixo nível: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  Nesse código, <code>use(a)</code> é a única parte que pode ser interrompida.  O código circundante garante a execução da <code>release</code> em qualquer caso. <br><br>  A qualquer momento, você pode verificar se há uma oportunidade para interrupções.  Para isso, são necessárias apenas duas operações primitivas (o restante é derivado delas). <br><br>  Esse modelo de interrupção composicional com recursos completos permite implementar não apenas uma implementação de colchete simples, mas também implementar outros cenários no gerenciamento de recursos, nos quais é encontrado um equilíbrio entre as vantagens e desvantagens das interrupções. <br><br>  O Cats IO fornece apenas uma operação para controlar interrupções: o combinador não cancelável.  Faz todo o bloco de código ininterrupto.  Embora essa operação raramente seja usada, pode levar a um vazamento ou bloqueio de recursos. <br><br>  Ao mesmo tempo, é possível definir um primitivo dentro do Cats IO, que permite obter mais controle sobre interrupções.  A implementação muito complicada de Fabio Labella acabou sendo extremamente lenta. <br><br>  O ZIO permite escrever código com interrupções, operando em um nível alto com operadores declarativos compostos, e não força você a escolher entre complexidade severa combinada com baixo desempenho e vazamentos de bloqueio. <br><br>  Além disso, a recém-adicionada memória transacional de software no ZIO permite ao usuário escrever declarativamente estruturas de dados e códigos que são automaticamente assíncronos, competitivos e permitem interrupções. <br><br><h2>  3. Finalizadores garantidos </h2><br>  O bloco try / finalmente em muitas linguagens de programação fornece as garantias necessárias para escrever código síncrono sem vazar recursos. <br><br>  Em particular, esse bloco garante o seguinte: se um bloco try iniciar a execução, o bloco final será executado quando o try parar. <br><br>  Esta garantia se aplica a: <br><br><ul><li>  existem blocos "try / finally" aninhados; </li><li>  há erros no "bloco try"; </li><li>  há erros no bloco finalmente aninhado. </li></ul><br>  A operação de "garantia" do ZIO pode ser usada como try / finalmente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  O ZIO fornece as seguintes garantias para "effect.ensuring (finalizer)": se "effect" começar a ser executado, o "finalizer" começará a execução quando "effect" parar. <br><br>  Como try / finalmente, essas garantias permanecem nos seguintes casos: <br><br><ul><li>  Existem composições "garantidas" aninhadas; </li><li>  há erros no "efeito"; </li><li>  há erros no "finalizador" aninhado. </li></ul><br>  Além disso, a garantia é mantida mesmo que o efeito seja interrompido (as garantias no “suporte” são semelhantes, de fato, o “suporte” é implementado em “garantia”). <br><br>  O tipo de dados Cats IO fornece outra garantia mais fraca.  Para "effect.guarantee (finalizer)", ele é enfraquecido da seguinte forma: se "effect" começar a ser executado, "finalizer" começará a execução quando "effect" parar, se o efeito do problema não for inserido em "effect". <br><br>  Uma garantia mais fraca também é encontrada na implementação do "suporte" no Cats IO. <br><br>  Para obter um vazamento de recurso, basta usar o efeito usado dentro do efeito "garante" ou "bracket.use", componha-o com algo como isto: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Quando bigTrouble é inserido dessa maneira em outro efeito, o efeito se torna ininterrupto - nenhum "finalizador" definido na "garantia" ou a limpeza de recursos através do "colchete" não será executada.  Tudo isso leva a uma drenagem de recursos, mesmo quando há um "finalizador" no bloco. <br><br>  Por exemplo, o "finalizador" no código a seguir nunca começará a execução: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!«)))</span></span></code> </pre> <br>  Avaliando o código sem levar em consideração o contexto global, é impossível determinar se um efeito, como "bigTrouble", será inserido em qualquer lugar do efeito "use" da operação "bracket" ou dentro do bloco "finalizer". <br><br>  Portanto, você não poderá descobrir se o programa Cats IO funcionará com vazamentos de recursos ou com blocos "finalizadores" ausentes sem avaliar o programa inteiro.  O programa inteiro só pode ser avaliado manualmente e esse processo é sempre acompanhado por erros que não podem ser verificados pelo compilador.  Além disso, esse processo deve ser repetido sempre que ocorrerem alterações importantes no código. <br><br>  O ZIO possui uma implementação personalizada de "garantia" do Cats Effect, "GuaranteCase" e "bracket".  As implementações usam semântica ZIO nativa (não semântica de IO de gatos), o que nos permite avaliar possíveis problemas com vazamentos de recursos aqui e agora, sabendo que em todas as situações os finalizadores serão iniciados e os recursos serão liberados. <br><br><h2>  4. Comutação estável </h2><br>  O Efeito Cats tem o método "evalOn" de "ContextShift", que permite mover a execução de algum código para outro contexto de execução. <br><br>  Isso é útil por vários motivos: <br><br><ul><li>  muitas bibliotecas clientes forçam você a fazer algum trabalho no pool de threads; </li><li>  As bibliotecas da interface do usuário exigem que algumas atualizações ocorram no encadeamento da interface do usuário; </li><li>  alguns efeitos requerem isolamento em conjuntos de encadeamentos adaptados a seus recursos específicos. </li></ul><br>  A operação "EvalOn" executa o efeito onde deve ser executada e, em seguida, retorna ao contexto de execução original.  Por exemplo: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Nota: O Cats IO possui uma construção semelhante de "deslocamento", que permite alternar para um contexto diferente sem voltar atrás, mas, na prática, esse comportamento raramente é necessário; portanto, "evalOn" é o preferido. <br><br>  A implementação do ZIO do “evalOn” (feita no “bloqueio” primitivo do ZIO) fornece as garantias necessárias para entender exclusivamente onde o efeito funciona - o efeito sempre será executado em um contexto específico. <br><br>  O Cats IO tem uma garantia diferente e mais fraca - o efeito será executado em um determinado contexto até a primeira operação assíncrona ou comutação interna. <br><br>  Considerando um pequeno pedaço de código, é impossível saber com certeza se um efeito assíncrono (ou comutação aninhada) será incorporado ao efeito que será alternado, porque a assincronia não é exibida nos tipos. <br><br>  Portanto, como no caso de segurança de recursos, para entender onde o efeito Cats IO será lançado, é necessário estudar todo o programa.  Na prática, e pela minha experiência, os usuários de Cats IO ficam surpresos quando, ao usar o "evalOn" em um contexto, é descoberto subseqüentemente que a maior parte do efeito foi acidentalmente executada em outro. <br><br>  O ZIO permite que você determine onde os efeitos devem ser acionados e confie que isso acontecerá em todos os casos, não importa como os efeitos sejam incorporados a outros efeitos. <br><br><h2>  5. Segurança de mensagens de erro </h2><br>  Qualquer efeito que suporte simultaneidade, simultaneidade ou acesso seguro a recursos será executado em um modelo de erro linear: em geral, nem todos os erros podem ser salvos. <br><br>  Isso é válido para o `Throwable`, um tipo de erro fixo incorporado no Cats IO e o tipo de erro polimórfico suportado pelo ZIO. <br><br>  Exemplos de situações com vários erros únicos: <br><br><ul><li>  O finalizador lança uma exceção; </li><li>  dois efeitos (decrescentes) são combinados em execução paralela; </li><li>  dois efeitos (caindo) em um estado de corrida; </li><li>  o efeito interrompido cai antes de deixar a seção protegida contra interrupções. </li></ul><br>  Como nem todos os erros são salvos, o ZIO fornece uma estrutura de dados "Causa [E]" com base em um semi-anel livre (uma abstração da álgebra abstrata, seu conhecimento não é suposto aqui), o que permite conectar erros seriais e paralelos a qualquer tipo de erro.  Durante todas as operações (incluindo limpeza para um efeito caído ou interrompido), o ZIO agrega erros na estrutura de dados “Causa [E]”.  Essa estrutura de dados está disponível a qualquer momento.  Como resultado, o ZIO sempre armazena todos os erros: eles estão sempre disponíveis, podem ser registrados, estudados e transformados conforme exigido pelos requisitos de negócios. <br><br>  Gatos IO escolheu um modelo com informações de perda de erro.  Enquanto o ZIO conectará os dois erros por meio da Causa [E], o Cats IO "perderá" uma das mensagens de erro, por exemplo, chamando "e.printStackTrace ()" no erro que ocorrer. <br><br>  Por exemplo, um erro no "finalizador" neste código será perdido. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2«)))</span></span></code> </pre> <br>  Essa abordagem para rastrear erros significa que você não pode localizar e processar localmente todo o espectro de erros que ocorrem devido à combinação de efeitos.  O ZIO permite que você use qualquer tipo de erro, incluindo "Jogável" (ou subtipos mais específicos, como "IOExceptio" ou outra hierarquia de exceção personalizada), garantindo que nenhum erro seja perdido durante a execução do programa. <br><br><h2>  6. Assincronia sem deadlocks </h2><br>  O ZIO e o Cats IO fornecem um construtor que permite que você pegue o código com um retorno de chamada e envolva-o com efeito <br><br>  Esse recurso é fornecido através da classe de pipe Async no Cats Effect: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Isso cria um efeito assíncrono que, quando executado, espera até que o valor apareça e depois continua, e tudo isso será óbvio para o usuário do efeito.  Portanto, a programação funcional é tão atraente para o desenvolvimento de código assíncrono. <br><br>  Observe que, assim que o código de retorno de chamada se torna um efeito, a função de retorno de chamada (aqui é chamada `k`) é chamada.  Essa função de retorno de chamada é encerrada com um valor de sucesso / erro.  Quando essa função de retorno de chamada é chamada, a execução do efeito (pausada anteriormente) é retomada. <br><br>  O ZIO garante que o efeito continuará a execução no conjunto de encadeamentos de tempo de execução se o efeito não tiver sido atribuído a nenhum contexto especial específico ou a outro contexto ao qual o efeito foi anexado. <br><br>  Cats IO retoma o efeito no thread de retorno de chamada.  A diferença entre essas opções é bastante profunda: o encadeamento que causa o retorno de chamada não espera que o código de retorno de chamada seja executado para sempre, mas permite apenas um pequeno atraso antes do retorno do controle.  Por outro lado, o Cats IO não oferece tal garantia: o encadeamento de chamada, o retorno de chamada de lançamento, podem congelar, aguardando um tempo indefinido quando o controle de execução retornar. <br><br>  As versões anteriores das estruturas de dados competitivas no Cats Effect ("Adiado", "Semáforo") retomaram os efeitos que não retornavam o controle da execução ao segmento de chamada.  Como resultado, problemas relacionados a conflitos e um agendador de execução quebrado foram descobertos neles.  Embora todos esses problemas tenham sido encontrados, eles são corrigidos apenas para estruturas de dados competitivas no Cats Effect. <br><br>  O código do usuário que usa uma abordagem semelhante à do Cats IO enfrentará esses problemas, porque essas tarefas são não determinísticas, os erros podem ocorrer muito raramente, em tempo de execução, tornando a depuração e a detecção de problemas um processo difícil. <br><br>  O ZIO oferece proteção imediata e um agendador de tarefas normal e também faz com que o usuário escolha explicitamente o comportamento do Cats IO (por exemplo, usando "unsafeRun" em "Promise", que terminou com um efeito assíncrono retomado). <br><br>  Embora nenhuma das soluções seja adequada para absolutamente todos os casos, e o ZIO e o Cats IO forneçam flexibilidade suficiente para resolver todas as situações (de maneiras diferentes), escolher o ZIO significa usar o "Async" sem preocupações e forçar você a colocar o código do problema em "unsafeRun", que é conhecido por causar impasse <br><br><h2>  7. Compatível com o futuro </h2><br>  O uso de "Future" da biblioteca padrão Scala é uma realidade para um grande número de bases de código.  O ZIO vem com um método "fromFuture", que fornece um contexto de execução pronto: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Quando esse método é usado para envolver o Future em um efeito, o ZIO pode definir onde o Future será executado e outros métodos, como evalOn, transferirão o Future corretamente para o contexto de execução desejado.  O Cats IO aceita "Future", que foi criado com um "ExecutionContext" externo.  Isso significa que o Cats IO não pode mover a execução do Future de acordo com os requisitos dos métodos evalOn ou shift.  Além disso, isso sobrecarrega o usuário na determinação do contexto de execução para o futuro, o que significa seleção restrita e um ambiente separado. <br><br>  Como o ExecutionContext fornecido pode ser ignorado, o ZIO pode ser representado como a soma dos recursos de E / S de gatos, garantindo uma interação mais suave e precisa com o Future no caso geral, mas ainda existem exceções. <br><br><h2>  8. Bloqueio de E / S </h2><br>  Como foi mostrado no artigo “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pool de threads.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Práticas recomendadas com o ZIO</a> ”, para aplicativos de servidor, são necessários pelo menos dois conjuntos separados para obter a máxima eficiência: <br><br><ul><li>  pool fixo para efeitos assíncronos / da CPU; </li><li>  dinâmico, com a possibilidade de aumentar o número de threads de bloqueio. </li></ul><br>  A decisão de executar todos os efeitos em um conjunto de encadeamentos fixo levará um dia a um impasse, enquanto o acionamento de todos os efeitos em um conjunto dinâmico pode levar à perda de desempenho. <br><br>  Na JVM, o ZIO fornece duas operações que suportam efeitos de bloqueio: <br><br><ul><li>  Operador "Blocking (effect"), que alterna a execução de um certo efeito no pool de threads de bloqueio que possuem boas predefinições que podem ser alteradas, se desejado); </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "EffectBlocking (effect)" é um operador que converte um código de bloqueio com efeitos colaterais em um efeito puro, cuja interrupção interrompe a execução da maior parte do código de bloqueio. </font></font></li></ul><br>     ,     ,       ,       «blocking».   ,    -    ,  ,       «effectBlocking»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     «blocking»,    «evalOn», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> «ReaderT»/ «Kleisli»,       ; </li><li> «EitherT»,      ( «OptionT»,     «EitherT»   «Unit»    ). </li></ul><br>    ,          (, http4s   «Kleisli»  «OptionT»).        («effect totation»), ZIO   «reader»  «typed error»      ZIO.         «reader»  «typed error» , ZIO    ,    . , «Task[A]»,    «reader»  «typed errors». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   «reader»  «typed errors»      «state», «writer»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    «typed errors»  ,       —     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : «ZIO. succeed»  «Applicative[F].pure», «zip»  «Apply[F].product», «ZIO.foreach»  «Traverse[F].traverse». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  «Runtime»,      Cats Effect  -   Cats Effect).  —        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazy«. <br></li><li>      ,        «».   ZIO    IDE. </li><li>      Scala  ZIO  : «ZIO.fromFuture», «ZIO.fromOption», «ZIO.fromEither», «ZIO.fromTry». </li><li>         «». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO —  - ,           . <br><br>     : <br><br><ul><li>     ,  «Ref», «Promise», «Queue», «Semaphore»   «Stream»    //; </li><li> STM,       , ,     ; </li><li> «Schedule»,    ; </li><li>    «Clock», «Random», «Console»  «System» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  Conclusão </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você quiser saber mais sobre as tecnologias e ferramentas de programação Scala ou descobrir mais detalhes importantes - ótimas notícias para você. </font><font style="vertical-align: inherit;">No final de novembro, Moscou sediará a primeira conferência na Rússia dedicada inteiramente a Scala. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Agenda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ScalaConf já foi publicada, contém 18 relatórios interessantes de especialistas reconhecidos, incluindo John A De Goes pessoalmente.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472386/">https://habr.com/ru/post/pt472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472372/index.html">Automação Android Guia super fácil para criar seu primeiro teste de café expresso</a></li>
<li><a href="../pt472374/index.html">Por que transferimos servidores para a Islândia</a></li>
<li><a href="../pt472378/index.html">Confiabilidade do flash: esperado e inesperado. Parte 2. XIV conferência da associação USENIX. Tecnologias de armazenamento de arquivos</a></li>
<li><a href="../pt472380/index.html">MIRO - uma plataforma de robô indoor aberta</a></li>
<li><a href="../pt472384/index.html">Um olhar sobre as atualizações do Android da perspectiva de um desenvolvedor</a></li>
<li><a href="../pt472388/index.html">Walmart declara guerra de preços na Amazon</a></li>
<li><a href="../pt472392/index.html">A ascensão, queda e possível retorno de fitas de áudio - lidamos com mitos e fornecemos uma visão geral da situação</a></li>
<li><a href="../pt472394/index.html">Avaliando o impacto da inteligência artificial em petróleo e gás offshore</a></li>
<li><a href="../pt472396/index.html">Em todo o mundo em 4 segundos no Columnstore (parte 1)</a></li>
<li><a href="../pt472402/index.html">Streaming de chamadas de vídeo RTMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>