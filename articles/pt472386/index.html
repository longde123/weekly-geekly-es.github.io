<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ‰ ğŸ¥ ğŸ§•ğŸ¼ ZIO & Cats Effect: uma alianÃ§a de sucesso ğŸ‘‚ğŸ½ ğŸ›Œ ğŸ‘©ğŸ¿â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Cats Effect se tornou uma espÃ©cie de â€œFluxos Reativosâ€ para o mundo funcional do Scala, permitindo combinar todo o ecossistema diversificado de bibl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO & Cats Effect: uma alianÃ§a de sucesso</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  O Cats Effect se tornou uma espÃ©cie de â€œFluxos Reativosâ€ para o mundo funcional do Scala, permitindo combinar todo o ecossistema diversificado de bibliotecas. <br><br>  Muitas excelentes bibliotecas: http4s, fs2, doobie - sÃ£o implementadas apenas com base nas classes de tipo do Cats Effect.  E bibliotecas como ZIO e Monix, por sua vez, fornecem instÃ¢ncias dessas classes de tipos para seus tipos de efeitos.  Apesar de alguns problemas que serÃ£o corrigidos na versÃ£o 3.0, o Cats Effect ajuda muitos colaboradores de cÃ³digo aberto a dar suporte orgÃ¢nico a todo o ecossistema funcional da linguagem Scala.  Os desenvolvedores que usam o Cats Effect enfrentam uma escolha difÃ­cil: qual implementaÃ§Ã£o de efeitos usar em seus aplicativos. <br><br>  Hoje existem trÃªs alternativas: <br><br><ul><li>  Cats IO, implementaÃ§Ã£o de referÃªncia; </li><li>  Monix, o tipo de dados Task e sua reatividade no cÃ³digo; </li><li>  ZIO, o tipo de dados ZIO e seu escopo de segmentaÃ§Ã£o cruzada. </li></ul><br>  Neste post, tentarei provar a vocÃª que, para criar seu aplicativo usando o Cats Effect, o ZIO Ã© uma boa escolha com soluÃ§Ãµes e recursos de design bastante diferentes da implementaÃ§Ã£o de referÃªncia no Cats IO. <br><a name="habracut"></a><br><h2>  1. Melhor arquitetura MTL / sem tags-final </h2><br>  MTL (Monad Transformers Library) Ã© um estilo de programaÃ§Ã£o no qual as funÃ§Ãµes sÃ£o polimÃ³rficas por seu tipo de efeito e expressam seus requisitos por meio de uma "restriÃ§Ã£o de classe de tipo".  Em Scala, isso geralmente Ã© chamado de estilo final sem etiqueta (embora nÃ£o seja a mesma coisa), especialmente quando a classe de tipo nÃ£o possui leis. <br><br>  Ã‰ sabido que Ã© impossÃ­vel definir uma instÃ¢ncia global para classes clÃ¡ssicas de tipo MTL como Writer e State, bem como para tipos de efeito como Cats IO.  O problema Ã© que instÃ¢ncias dessas classes de tipos para esses tipos de efeitos requerem acesso a um estado mutÃ¡vel, que nÃ£o pode ser criado globalmente, porque a criaÃ§Ã£o de um estado mutÃ¡vel tambÃ©m Ã© um efeito. <br><br>  Para um melhor desempenho, no entanto, Ã© importante evitar "transformadores de mÃ´nada" e fornecer a implementaÃ§Ã£o Write e State diretamente, alÃ©m do tipo de efeito principal. <br><br>  Para conseguir isso, os programadores Scala usam um truque: eles criam instÃ¢ncias (mas limpas) no nÃ­vel superior de seus programas com efeitos e, em seguida, as fornecem no programa como implicaÃ§Ãµes locais: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  Apesar de Ãºtil, esse truque ainda Ã© uma "muleta".  Em um mundo ideal, todas as instÃ¢ncias de classes de tipos podem ser coerentes (uma instÃ¢ncia por tipo) e nÃ£o serem criadas localmente, gerando efeitos, e entÃ£o se envolvem magicamente em valores implÃ­citos para uso por mÃ©todos subseqÃ¼entes. <br><br>  Um Ã³timo recurso do MTL / tagless-final Ã© que vocÃª pode definir diretamente a maioria das instÃ¢ncias sobre o tipo de dados ZIO usando o ambiente ZIO. <br><br>  Aqui estÃ¡ uma maneira de criar uma definiÃ§Ã£o global do MonadState para um tipo de dados ZIO: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Uma instÃ¢ncia agora Ã© definida globalmente para qualquer ambiente que suporte pelo menos <code>State[S]</code> . <br><br>  Da mesma forma para <code>FunctorListen</code> , tambÃ©m conhecido como <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  E, Ã© claro, podemos fazer o mesmo com o <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Essa tÃ©cnica Ã© facilmente aplicÃ¡vel a outras classes de tipos, incluindo classes de tipo final sem tag, instÃ¢ncias das quais pode exigir efeitos de geraÃ§Ã£o (alteraÃ§Ãµes, configuraÃ§Ãµes), funÃ§Ãµes de teste que geram efeitos (combinando efeitos do ambiente com final sem tag) ou qualquer outra coisa facilmente acessÃ­vel a partir do ambiente . <br><br>  NÃ£o hÃ¡ mais transformaÃ§Ãµes monÃ¡dicas lentas!  Digamos "nÃ£o" para criar efeitos ao inicializar instÃ¢ncias da classe de classe, para implicaÃ§Ãµes locais.  NÃ£o sÃ£o necessÃ¡rias mais muletas.  ImersÃ£o direta em pura programaÃ§Ã£o funcional. <br><br><h2>  2. Economizando recursos para meros mortais </h2><br>  Um dos primeiros recursos do ZIO foi a intercepÃ§Ã£o - a capacidade do tempo de execuÃ§Ã£o do ZIO interromper instantaneamente qualquer efeito executÃ¡vel e garantir a liberaÃ§Ã£o de todos os recursos.  Uma implementaÃ§Ã£o grosseira desse recurso atingiu o Cats IO. <br><br>  Haskell chamou essa funcionalidade de exceÃ§Ã£o assÃ­ncrona, que permite criar e usar com eficiÃªncia a latÃªncia, operaÃ§Ãµes paralelas e competitivas eficientes e cÃ¡lculos globalmente ideais.  Essas interrupÃ§Ãµes nÃ£o apenas trazem grandes benefÃ­cios, mas tambÃ©m representam tarefas complexas no campo de suporte ao acesso seguro aos recursos. <br><br>  Programadores sÃ£o usados â€‹â€‹para rastrear erros em programas atravÃ©s de anÃ¡lises simples.  Isso tambÃ©m pode ser feito com o ZIO, que usa um sistema de tipos para ajudar a detectar erros.  Mas interrupÃ§Ã£o Ã© outra coisa.  Um efeito criado a partir de muitos outros efeitos pode ser interrompido em qualquer borda. <br><br>  Considere o seguinte efeito: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  A maioria dos desenvolvedores nÃ£o ficarÃ¡ surpresa com esse cenÃ¡rio: <code>closeFile</code> nÃ£o serÃ¡ executado se o <code>readFile</code> travar.  Felizmente, o sistema de efeitos tem uma <code>ensuring</code> ( <code>guarantee</code> no Efeito Gatos) que permite adicionar um manipulador final ao efeito finalizador, semelhante ao finalmente. <br><br>  Portanto, o principal problema do cÃ³digo acima pode ser facilmente resolvido: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Agora, o efeito tornou-se "resistente a quedas", no sentido de que, se o <code>readFile</code> interrompido, o arquivo ainda serÃ¡ fechado.  E se o <code>readFile</code> for bem-sucedido, o arquivo tambÃ©m serÃ¡ fechado.  Em todos os casos, o arquivo serÃ¡ fechado. <br><br>  Mas ainda nÃ£o Ã© bem assim.  InterrupÃ§Ã£o significa que o efeito pode ser interrompido em qualquer lugar, mesmo entre <code>openFile</code> e <code>openFile</code> .  Se isso acontecer, o arquivo aberto nÃ£o serÃ¡ fechado e ocorrerÃ¡ um vazamento de recursos. <br><br>  O padrÃ£o de obter e liberar um recurso Ã© tÃ£o amplo que o ZIO introduziu um operador de bracket, que tambÃ©m apareceu no Cats Effect 1.0.  A instruÃ§Ã£o Bracket protege contra interrupÃ§Ãµes: se o recurso for recebido com Ãªxito, a liberaÃ§Ã£o ocorrerÃ¡ mesmo que o efeito do recurso seja interrompido.  AlÃ©m disso, nem o recebimento nem a liberaÃ§Ã£o do recurso podem ser interrompidos, garantindo assim a seguranÃ§a do recurso. <br><br>  Usando o colchete, o exemplo acima ficaria assim: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Infelizmente, o colchete encapsula apenas um padrÃ£o de consumo de recursos (bastante geral).  Existem muitos outros, especialmente com estruturas de dados competitivas, cujo acesso deve estar acessÃ­vel para interrupÃ§Ãµes; caso contrÃ¡rio, sÃ£o possÃ­veis vazamentos. <br><br>  Em geral, todo o trabalho de interrupÃ§Ã£o se resume a duas coisas principais: <br><br><ul><li>  evitar interrupÃ§Ãµes em algumas Ã¡reas que podem ser interrompidas; </li><li>  permitir a interrupÃ§Ã£o em Ã¡reas que podem congelar. </li></ul><br>  O ZIO tem a capacidade de implementar ambos.  Por exemplo, podemos desenvolver nossa prÃ³pria versÃ£o do bracket usando abstraÃ§Ãµes ZIO de baixo nÃ­vel: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  Nesse cÃ³digo, <code>use(a)</code> Ã© a Ãºnica parte que pode ser interrompida.  O cÃ³digo circundante garante a execuÃ§Ã£o da <code>release</code> em qualquer caso. <br><br>  A qualquer momento, vocÃª pode verificar se hÃ¡ uma oportunidade para interrupÃ§Ãµes.  Para isso, sÃ£o necessÃ¡rias apenas duas operaÃ§Ãµes primitivas (o restante Ã© derivado delas). <br><br>  Esse modelo de interrupÃ§Ã£o composicional com recursos completos permite implementar nÃ£o apenas uma implementaÃ§Ã£o de colchete simples, mas tambÃ©m implementar outros cenÃ¡rios no gerenciamento de recursos, nos quais Ã© encontrado um equilÃ­brio entre as vantagens e desvantagens das interrupÃ§Ãµes. <br><br>  O Cats IO fornece apenas uma operaÃ§Ã£o para controlar interrupÃ§Ãµes: o combinador nÃ£o cancelÃ¡vel.  Faz todo o bloco de cÃ³digo ininterrupto.  Embora essa operaÃ§Ã£o raramente seja usada, pode levar a um vazamento ou bloqueio de recursos. <br><br>  Ao mesmo tempo, Ã© possÃ­vel definir um primitivo dentro do Cats IO, que permite obter mais controle sobre interrupÃ§Ãµes.  A implementaÃ§Ã£o muito complicada de Fabio Labella acabou sendo extremamente lenta. <br><br>  O ZIO permite escrever cÃ³digo com interrupÃ§Ãµes, operando em um nÃ­vel alto com operadores declarativos compostos, e nÃ£o forÃ§a vocÃª a escolher entre complexidade severa combinada com baixo desempenho e vazamentos de bloqueio. <br><br>  AlÃ©m disso, a recÃ©m-adicionada memÃ³ria transacional de software no ZIO permite ao usuÃ¡rio escrever declarativamente estruturas de dados e cÃ³digos que sÃ£o automaticamente assÃ­ncronos, competitivos e permitem interrupÃ§Ãµes. <br><br><h2>  3. Finalizadores garantidos </h2><br>  O bloco try / finalmente em muitas linguagens de programaÃ§Ã£o fornece as garantias necessÃ¡rias para escrever cÃ³digo sÃ­ncrono sem vazar recursos. <br><br>  Em particular, esse bloco garante o seguinte: se um bloco try iniciar a execuÃ§Ã£o, o bloco final serÃ¡ executado quando o try parar. <br><br>  Esta garantia se aplica a: <br><br><ul><li>  existem blocos "try / finally" aninhados; </li><li>  hÃ¡ erros no "bloco try"; </li><li>  hÃ¡ erros no bloco finalmente aninhado. </li></ul><br>  A operaÃ§Ã£o de "garantia" do ZIO pode ser usada como try / finalmente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  O ZIO fornece as seguintes garantias para "effect.ensuring (finalizer)": se "effect" comeÃ§ar a ser executado, o "finalizer" comeÃ§arÃ¡ a execuÃ§Ã£o quando "effect" parar. <br><br>  Como try / finalmente, essas garantias permanecem nos seguintes casos: <br><br><ul><li>  Existem composiÃ§Ãµes "garantidas" aninhadas; </li><li>  hÃ¡ erros no "efeito"; </li><li>  hÃ¡ erros no "finalizador" aninhado. </li></ul><br>  AlÃ©m disso, a garantia Ã© mantida mesmo que o efeito seja interrompido (as garantias no â€œsuporteâ€ sÃ£o semelhantes, de fato, o â€œsuporteâ€ Ã© implementado em â€œgarantiaâ€). <br><br>  O tipo de dados Cats IO fornece outra garantia mais fraca.  Para "effect.guarantee (finalizer)", ele Ã© enfraquecido da seguinte forma: se "effect" comeÃ§ar a ser executado, "finalizer" comeÃ§arÃ¡ a execuÃ§Ã£o quando "effect" parar, se o efeito do problema nÃ£o for inserido em "effect". <br><br>  Uma garantia mais fraca tambÃ©m Ã© encontrada na implementaÃ§Ã£o do "suporte" no Cats IO. <br><br>  Para obter um vazamento de recurso, basta usar o efeito usado dentro do efeito "garante" ou "bracket.use", componha-o com algo como isto: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Quando bigTrouble Ã© inserido dessa maneira em outro efeito, o efeito se torna ininterrupto - nenhum "finalizador" definido na "garantia" ou a limpeza de recursos atravÃ©s do "colchete" nÃ£o serÃ¡ executada.  Tudo isso leva a uma drenagem de recursos, mesmo quando hÃ¡ um "finalizador" no bloco. <br><br>  Por exemplo, o "finalizador" no cÃ³digo a seguir nunca comeÃ§arÃ¡ a execuÃ§Ã£o: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!Â«)))</span></span></code> </pre> <br>  Avaliando o cÃ³digo sem levar em consideraÃ§Ã£o o contexto global, Ã© impossÃ­vel determinar se um efeito, como "bigTrouble", serÃ¡ inserido em qualquer lugar do efeito "use" da operaÃ§Ã£o "bracket" ou dentro do bloco "finalizer". <br><br>  Portanto, vocÃª nÃ£o poderÃ¡ descobrir se o programa Cats IO funcionarÃ¡ com vazamentos de recursos ou com blocos "finalizadores" ausentes sem avaliar o programa inteiro.  O programa inteiro sÃ³ pode ser avaliado manualmente e esse processo Ã© sempre acompanhado por erros que nÃ£o podem ser verificados pelo compilador.  AlÃ©m disso, esse processo deve ser repetido sempre que ocorrerem alteraÃ§Ãµes importantes no cÃ³digo. <br><br>  O ZIO possui uma implementaÃ§Ã£o personalizada de "garantia" do Cats Effect, "GuaranteCase" e "bracket".  As implementaÃ§Ãµes usam semÃ¢ntica ZIO nativa (nÃ£o semÃ¢ntica de IO de gatos), o que nos permite avaliar possÃ­veis problemas com vazamentos de recursos aqui e agora, sabendo que em todas as situaÃ§Ãµes os finalizadores serÃ£o iniciados e os recursos serÃ£o liberados. <br><br><h2>  4. ComutaÃ§Ã£o estÃ¡vel </h2><br>  O Efeito Cats tem o mÃ©todo "evalOn" de "ContextShift", que permite mover a execuÃ§Ã£o de algum cÃ³digo para outro contexto de execuÃ§Ã£o. <br><br>  Isso Ã© Ãºtil por vÃ¡rios motivos: <br><br><ul><li>  muitas bibliotecas clientes forÃ§am vocÃª a fazer algum trabalho no pool de threads; </li><li>  As bibliotecas da interface do usuÃ¡rio exigem que algumas atualizaÃ§Ãµes ocorram no encadeamento da interface do usuÃ¡rio; </li><li>  alguns efeitos requerem isolamento em conjuntos de encadeamentos adaptados a seus recursos especÃ­ficos. </li></ul><br>  A operaÃ§Ã£o "EvalOn" executa o efeito onde deve ser executada e, em seguida, retorna ao contexto de execuÃ§Ã£o original.  Por exemplo: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Nota: O Cats IO possui uma construÃ§Ã£o semelhante de "deslocamento", que permite alternar para um contexto diferente sem voltar atrÃ¡s, mas, na prÃ¡tica, esse comportamento raramente Ã© necessÃ¡rio; portanto, "evalOn" Ã© o preferido. <br><br>  A implementaÃ§Ã£o do ZIO do â€œevalOnâ€ (feita no â€œbloqueioâ€ primitivo do ZIO) fornece as garantias necessÃ¡rias para entender exclusivamente onde o efeito funciona - o efeito sempre serÃ¡ executado em um contexto especÃ­fico. <br><br>  O Cats IO tem uma garantia diferente e mais fraca - o efeito serÃ¡ executado em um determinado contexto atÃ© a primeira operaÃ§Ã£o assÃ­ncrona ou comutaÃ§Ã£o interna. <br><br>  Considerando um pequeno pedaÃ§o de cÃ³digo, Ã© impossÃ­vel saber com certeza se um efeito assÃ­ncrono (ou comutaÃ§Ã£o aninhada) serÃ¡ incorporado ao efeito que serÃ¡ alternado, porque a assincronia nÃ£o Ã© exibida nos tipos. <br><br>  Portanto, como no caso de seguranÃ§a de recursos, para entender onde o efeito Cats IO serÃ¡ lanÃ§ado, Ã© necessÃ¡rio estudar todo o programa.  Na prÃ¡tica, e pela minha experiÃªncia, os usuÃ¡rios de Cats IO ficam surpresos quando, ao usar o "evalOn" em um contexto, Ã© descoberto subseqÃ¼entemente que a maior parte do efeito foi acidentalmente executada em outro. <br><br>  O ZIO permite que vocÃª determine onde os efeitos devem ser acionados e confie que isso acontecerÃ¡ em todos os casos, nÃ£o importa como os efeitos sejam incorporados a outros efeitos. <br><br><h2>  5. SeguranÃ§a de mensagens de erro </h2><br>  Qualquer efeito que suporte simultaneidade, simultaneidade ou acesso seguro a recursos serÃ¡ executado em um modelo de erro linear: em geral, nem todos os erros podem ser salvos. <br><br>  Isso Ã© vÃ¡lido para o `Throwable`, um tipo de erro fixo incorporado no Cats IO e o tipo de erro polimÃ³rfico suportado pelo ZIO. <br><br>  Exemplos de situaÃ§Ãµes com vÃ¡rios erros Ãºnicos: <br><br><ul><li>  O finalizador lanÃ§a uma exceÃ§Ã£o; </li><li>  dois efeitos (decrescentes) sÃ£o combinados em execuÃ§Ã£o paralela; </li><li>  dois efeitos (caindo) em um estado de corrida; </li><li>  o efeito interrompido cai antes de deixar a seÃ§Ã£o protegida contra interrupÃ§Ãµes. </li></ul><br>  Como nem todos os erros sÃ£o salvos, o ZIO fornece uma estrutura de dados "Causa [E]" com base em um semi-anel livre (uma abstraÃ§Ã£o da Ã¡lgebra abstrata, seu conhecimento nÃ£o Ã© suposto aqui), o que permite conectar erros seriais e paralelos a qualquer tipo de erro.  Durante todas as operaÃ§Ãµes (incluindo limpeza para um efeito caÃ­do ou interrompido), o ZIO agrega erros na estrutura de dados â€œCausa [E]â€.  Essa estrutura de dados estÃ¡ disponÃ­vel a qualquer momento.  Como resultado, o ZIO sempre armazena todos os erros: eles estÃ£o sempre disponÃ­veis, podem ser registrados, estudados e transformados conforme exigido pelos requisitos de negÃ³cios. <br><br>  Gatos IO escolheu um modelo com informaÃ§Ãµes de perda de erro.  Enquanto o ZIO conectarÃ¡ os dois erros por meio da Causa [E], o Cats IO "perderÃ¡" uma das mensagens de erro, por exemplo, chamando "e.printStackTrace ()" no erro que ocorrer. <br><br>  Por exemplo, um erro no "finalizador" neste cÃ³digo serÃ¡ perdido. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2Â«)))</span></span></code> </pre> <br>  Essa abordagem para rastrear erros significa que vocÃª nÃ£o pode localizar e processar localmente todo o espectro de erros que ocorrem devido Ã  combinaÃ§Ã£o de efeitos.  O ZIO permite que vocÃª use qualquer tipo de erro, incluindo "JogÃ¡vel" (ou subtipos mais especÃ­ficos, como "IOExceptio" ou outra hierarquia de exceÃ§Ã£o personalizada), garantindo que nenhum erro seja perdido durante a execuÃ§Ã£o do programa. <br><br><h2>  6. Assincronia sem deadlocks </h2><br>  O ZIO e o Cats IO fornecem um construtor que permite que vocÃª pegue o cÃ³digo com um retorno de chamada e envolva-o com efeito <br><br>  Esse recurso Ã© fornecido atravÃ©s da classe de pipe Async no Cats Effect: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Isso cria um efeito assÃ­ncrono que, quando executado, espera atÃ© que o valor apareÃ§a e depois continua, e tudo isso serÃ¡ Ã³bvio para o usuÃ¡rio do efeito.  Portanto, a programaÃ§Ã£o funcional Ã© tÃ£o atraente para o desenvolvimento de cÃ³digo assÃ­ncrono. <br><br>  Observe que, assim que o cÃ³digo de retorno de chamada se torna um efeito, a funÃ§Ã£o de retorno de chamada (aqui Ã© chamada `k`) Ã© chamada.  Essa funÃ§Ã£o de retorno de chamada Ã© encerrada com um valor de sucesso / erro.  Quando essa funÃ§Ã£o de retorno de chamada Ã© chamada, a execuÃ§Ã£o do efeito (pausada anteriormente) Ã© retomada. <br><br>  O ZIO garante que o efeito continuarÃ¡ a execuÃ§Ã£o no conjunto de encadeamentos de tempo de execuÃ§Ã£o se o efeito nÃ£o tiver sido atribuÃ­do a nenhum contexto especial especÃ­fico ou a outro contexto ao qual o efeito foi anexado. <br><br>  Cats IO retoma o efeito no thread de retorno de chamada.  A diferenÃ§a entre essas opÃ§Ãµes Ã© bastante profunda: o encadeamento que causa o retorno de chamada nÃ£o espera que o cÃ³digo de retorno de chamada seja executado para sempre, mas permite apenas um pequeno atraso antes do retorno do controle.  Por outro lado, o Cats IO nÃ£o oferece tal garantia: o encadeamento de chamada, o retorno de chamada de lanÃ§amento, podem congelar, aguardando um tempo indefinido quando o controle de execuÃ§Ã£o retornar. <br><br>  As versÃµes anteriores das estruturas de dados competitivas no Cats Effect ("Adiado", "SemÃ¡foro") retomaram os efeitos que nÃ£o retornavam o controle da execuÃ§Ã£o ao segmento de chamada.  Como resultado, problemas relacionados a conflitos e um agendador de execuÃ§Ã£o quebrado foram descobertos neles.  Embora todos esses problemas tenham sido encontrados, eles sÃ£o corrigidos apenas para estruturas de dados competitivas no Cats Effect. <br><br>  O cÃ³digo do usuÃ¡rio que usa uma abordagem semelhante Ã  do Cats IO enfrentarÃ¡ esses problemas, porque essas tarefas sÃ£o nÃ£o determinÃ­sticas, os erros podem ocorrer muito raramente, em tempo de execuÃ§Ã£o, tornando a depuraÃ§Ã£o e a detecÃ§Ã£o de problemas um processo difÃ­cil. <br><br>  O ZIO oferece proteÃ§Ã£o imediata e um agendador de tarefas normal e tambÃ©m faz com que o usuÃ¡rio escolha explicitamente o comportamento do Cats IO (por exemplo, usando "unsafeRun" em "Promise", que terminou com um efeito assÃ­ncrono retomado). <br><br>  Embora nenhuma das soluÃ§Ãµes seja adequada para absolutamente todos os casos, e o ZIO e o Cats IO forneÃ§am flexibilidade suficiente para resolver todas as situaÃ§Ãµes (de maneiras diferentes), escolher o ZIO significa usar o "Async" sem preocupaÃ§Ãµes e forÃ§ar vocÃª a colocar o cÃ³digo do problema em "unsafeRun", que Ã© conhecido por causar impasse <br><br><h2>  7. CompatÃ­vel com o futuro </h2><br>  O uso de "Future" da biblioteca padrÃ£o Scala Ã© uma realidade para um grande nÃºmero de bases de cÃ³digo.  O ZIO vem com um mÃ©todo "fromFuture", que fornece um contexto de execuÃ§Ã£o pronto: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Quando esse mÃ©todo Ã© usado para envolver o Future em um efeito, o ZIO pode definir onde o Future serÃ¡ executado e outros mÃ©todos, como evalOn, transferirÃ£o o Future corretamente para o contexto de execuÃ§Ã£o desejado.  O Cats IO aceita "Future", que foi criado com um "ExecutionContext" externo.  Isso significa que o Cats IO nÃ£o pode mover a execuÃ§Ã£o do Future de acordo com os requisitos dos mÃ©todos evalOn ou shift.  AlÃ©m disso, isso sobrecarrega o usuÃ¡rio na determinaÃ§Ã£o do contexto de execuÃ§Ã£o para o futuro, o que significa seleÃ§Ã£o restrita e um ambiente separado. <br><br>  Como o ExecutionContext fornecido pode ser ignorado, o ZIO pode ser representado como a soma dos recursos de E / S de gatos, garantindo uma interaÃ§Ã£o mais suave e precisa com o Future no caso geral, mas ainda existem exceÃ§Ãµes. <br><br><h2>  8. Bloqueio de E / S </h2><br>  Como foi mostrado no artigo â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pool de threads.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PrÃ¡ticas recomendadas com o ZIO</a> â€, para aplicativos de servidor, sÃ£o necessÃ¡rios pelo menos dois conjuntos separados para obter a mÃ¡xima eficiÃªncia: <br><br><ul><li>  pool fixo para efeitos assÃ­ncronos / da CPU; </li><li>  dinÃ¢mico, com a possibilidade de aumentar o nÃºmero de threads de bloqueio. </li></ul><br>  A decisÃ£o de executar todos os efeitos em um conjunto de encadeamentos fixo levarÃ¡ um dia a um impasse, enquanto o acionamento de todos os efeitos em um conjunto dinÃ¢mico pode levar Ã  perda de desempenho. <br><br>  Na JVM, o ZIO fornece duas operaÃ§Ãµes que suportam efeitos de bloqueio: <br><br><ul><li>  Operador "Blocking (effect"), que alterna a execuÃ§Ã£o de um certo efeito no pool de threads de bloqueio que possuem boas predefiniÃ§Ãµes que podem ser alteradas, se desejado); </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "EffectBlocking (effect)" Ã© um operador que converte um cÃ³digo de bloqueio com efeitos colaterais em um efeito puro, cuja interrupÃ§Ã£o interrompe a execuÃ§Ã£o da maior parte do cÃ³digo de bloqueio. </font></font></li></ul><br>     ,     ,       ,       Â«blockingÂ».   ,    -    ,  ,       Â«effectBlockingÂ»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     Â«blockingÂ»,    Â«evalOnÂ», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> Â«ReaderTÂ»/ Â«KleisliÂ»,       ; </li><li> Â«EitherTÂ»,      ( Â«OptionTÂ»,     Â«EitherTÂ»   Â«UnitÂ»    ). </li></ul><br>    ,          (, http4s   Â«KleisliÂ»  Â«OptionTÂ»).        (Â«effect totationÂ»), ZIO   Â«readerÂ»  Â«typed errorÂ»      ZIO.         Â«readerÂ»  Â«typed errorÂ» , ZIO    ,    . , Â«Task[A]Â»,    Â«readerÂ»  Â«typed errorsÂ». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   Â«readerÂ»  Â«typed errorsÂ»      Â«stateÂ», Â«writerÂ»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    Â«typed errorsÂ»  ,       â€”     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : Â«ZIO. succeedÂ»  Â«Applicative[F].pureÂ», Â«zipÂ»  Â«Apply[F].productÂ», Â«ZIO.foreachÂ»  Â«Traverse[F].traverseÂ». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  Â«RuntimeÂ»,      Cats Effect  -   Cats Effect).  â€”        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazyÂ«. <br></li><li>      ,        Â«Â».   ZIO    IDE. </li><li>      Scala  ZIO  : Â«ZIO.fromFutureÂ», Â«ZIO.fromOptionÂ», Â«ZIO.fromEitherÂ», Â«ZIO.fromTryÂ». </li><li>         Â«Â». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO â€”  - ,           . <br><br>     : <br><br><ul><li>     ,  Â«RefÂ», Â«PromiseÂ», Â«QueueÂ», Â«SemaphoreÂ»   Â«StreamÂ»    //; </li><li> STM,       , ,     ; </li><li> Â«ScheduleÂ»,    ; </li><li>    Â«ClockÂ», Â«RandomÂ», Â«ConsoleÂ»  Â«SystemÂ» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  ConclusÃ£o </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se vocÃª quiser saber mais sobre as tecnologias e ferramentas de programaÃ§Ã£o Scala ou descobrir mais detalhes importantes - Ã³timas notÃ­cias para vocÃª. </font><font style="vertical-align: inherit;">No final de novembro, Moscou sediarÃ¡ a primeira conferÃªncia na RÃºssia dedicada inteiramente a Scala. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Agenda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ScalaConf jÃ¡ foi publicada, contÃ©m 18 relatÃ³rios interessantes de especialistas reconhecidos, incluindo John A De Goes pessoalmente.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472386/">https://habr.com/ru/post/pt472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472372/index.html">AutomaÃ§Ã£o Android Guia super fÃ¡cil para criar seu primeiro teste de cafÃ© expresso</a></li>
<li><a href="../pt472374/index.html">Por que transferimos servidores para a IslÃ¢ndia</a></li>
<li><a href="../pt472378/index.html">Confiabilidade do flash: esperado e inesperado. Parte 2. XIV conferÃªncia da associaÃ§Ã£o USENIX. Tecnologias de armazenamento de arquivos</a></li>
<li><a href="../pt472380/index.html">MIRO - uma plataforma de robÃ´ indoor aberta</a></li>
<li><a href="../pt472384/index.html">Um olhar sobre as atualizaÃ§Ãµes do Android da perspectiva de um desenvolvedor</a></li>
<li><a href="../pt472388/index.html">Walmart declara guerra de preÃ§os na Amazon</a></li>
<li><a href="../pt472392/index.html">A ascensÃ£o, queda e possÃ­vel retorno de fitas de Ã¡udio - lidamos com mitos e fornecemos uma visÃ£o geral da situaÃ§Ã£o</a></li>
<li><a href="../pt472394/index.html">Avaliando o impacto da inteligÃªncia artificial em petrÃ³leo e gÃ¡s offshore</a></li>
<li><a href="../pt472396/index.html">Em todo o mundo em 4 segundos no Columnstore (parte 1)</a></li>
<li><a href="../pt472402/index.html">Streaming de chamadas de vÃ­deo RTMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>