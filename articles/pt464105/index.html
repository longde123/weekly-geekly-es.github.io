<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👢 👴🏽 👩🏼‍🎤 Servidor Commento nativo com Docker Compose 👍 🙆🏾 🌮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota: esta é uma tradução da minha postagem (em inglês), descrevendo a implementação do servidor de comentários usado no mesmo site em que o original ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Servidor Commento nativo com Docker Compose</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464105/"><p>  <em>Nota: esta é uma tradução da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minha postagem</a> (em inglês), descrevendo a implementação do servidor de comentários usado no mesmo site em que o original está localizado.</em> </p><br><blockquote>  Versão TL; DR: Desenvolvi a configuração do servidor Commento, que é fácil e simplesmente implementada no modo semiautomático.  Copie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este repositório</a> para você do GitHub e siga as instruções no <a href="">README</a> . </blockquote><p>  Há algum tempo, eu queria irresistivelmente mudar o Disqus - que é talvez o sistema mais comum para adicionar comentários às páginas - para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Commento</a> gratuito e aberto. </p><br><h2 id="pochemu-imenno-commento">  Por que Commento? </h2><br><p> O problema com o Disqus, como muitos outros produtos "gratuitos", é que, nesse caso, o produto é o usuário - ou seja, você.  Além disso, o Disqus “enriquece” todas as páginas em que é usado com megabytes de scripts e mais de <em>cem</em> solicitações HTTP adicionais. </p><br><p>  Além disso, sua versão gratuita mostra anúncios dos quais você pode pagar "apenas" por US $ 9 por mês (plano Plus).  Isso por si só é suficiente para querer encontrar algo melhor. </p><br><p>  Em algum momento, me deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este post</a> e descobri a existência de um servidor de comentários gratuito chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Commento</a> .  Por uma coincidência de sorte, o Commento recentemente se tornou completamente aberto - antes de estar disponível em duas versões, <em>Comunidade</em> gratuita e <em>Empresa</em> comercial.  Graças ao seu desenvolvedor Adhityaa Chandrasekar. </p><a name="habracut"></a><br><p>  O Commento tem <em>ordens de magnitude</em> mais eficientes que o Disqus, o tamanho típico da carga adicional é de cerca de <strong>11 KB</strong> , além dos próprios comentários, é claro.  Aproximadamente a mesma situação com as solicitações HTTP necessárias. </p><br><p>  Outra vantagem do servidor Commento é que ele é muito rápido, como está escrito em Go. </p><br><p>  Bem, como uma cereja no bolo, ele tem uma importação de comentários do Disqus, com o que mais ele poderia sonhar? </p><br><h2 id="varianty-ispolzovaniya-commento">  Casos de uso para o Commento </h2><br><p>  Para usuários não avançados (tecnicamente), o Commento possui um serviço de nuvem pronto para uso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">commento.io</a> .  O autor oferece a você a escolha da taxa mensal, mas ela não pode ser inferior a US $ 3 "por razões técnicas". </p><br><p>  O Sr. Chandrasekar também oferece generosamente uma conta gratuita no Commento.io em troca de "patches não triviais" para o produto. </p><br><p>  Bem, eu escolhi a terceira opção: aumentar o servidor Commento.  Nesse caso, você não depende de ninguém (além do hoster, é claro), e eu amo a independência. </p><br><h2 id="trudnosti">  Dificuldades </h2><br><p>  Sou um grande fã dos contêineres do Docker e também uso frequentemente o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker Compose</a> , uma ferramenta para gerenciar grupos de vários contêineres relacionados.  O Commento possui uma imagem do Docker pronta para uso no registro de contêiner do GitLab. </p><br><p>  Portanto, a decisão de usar contêineres amadureceu por si só - mas primeiro algumas coisas tiveram que ser decididas. </p><br><h3 id="trudnost-1-postgresql">  Dificuldade Nº 1: PostgreSQL </h3><br><p>  O Commento requer uma versão bastante recente do servidor PostgreSQL, infelizmente nenhum outro servidor SQL é suportado. </p><br><p>  Bem, ainda executamos tudo em contêineres, então é bem simples. </p><br><h3 id="trudnost-2-net-podderzhki-https">  Dificuldade # 2: Não há suporte para HTTPS </h3><br><p>  O Commento em si é um servidor da Web, mas suporta apenas o protocolo HTTP inseguro. </p><br><p>  Deve-se notar que essa prática é bastante comum atualmente: nesse caso, o servidor está oculto atrás do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">proxy reverso</a> , que também executa a descarga de SSL.  O fato é que o suporte a SSL / HTTPS é absolutamente obrigatório nesse caso, afinal de contas, no pátio de 2019 e procurar tentativas de autorizar um usuário usando um protocolo de Internet inseguro será muito distorcido. </p><br><p>  Decidi usar o servidor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nginx</a> ; primeiro, tive uma experiência considerável trabalhando com ele; segundo, é muito rápido, econômico e estável.  E publica as versões oficiais das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagens</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> . </p><br><p>  O segundo ingrediente na receita HTTPS é o certificado SSL para o domínio.  Sou eternamente grato à EFF e à Mozilla por criar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Let's Encrypt</a> Certificate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Authority</a> , que emite milhões de certificados gratuitos todos os meses. </p><br><p>  O Let's Encrypt também fornece um utilitário de linha de comando gratuito chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">certbot</a> , que simplifica bastante o processo de obtenção e atualização de um certificado.  Bem, e - é claro - uma imagem do Docker para ele! </p><br><h3 id="trudnost-3-problema-kuricy-yayca-certbot">  Dificuldade # 3: Problema do ovo de galinha Certbot </h3><br><p>  Mas esse truque é mais complicado. </p><br><p>  Queremos nos referir ao certificado SSL na configuração de nosso proxy reverso no Nginx, o que significa que, sem um certificado, ele simplesmente se recusa a iniciar.  Ao mesmo tempo, para <em>obter um</em> certificado SSL para um domínio, você precisa de um servidor HTTP que funcione, o Let's Encrypt irá provar sua propriedade desse domínio. </p><br><p>  Consegui resolver esse problema e, ao que me parece, com bastante elegância: </p><br><ol><li>  Primeiro, é gerado um certificado inválido e fictício, cujo único objetivo é permitir que o Nginx inicie. </li><li>  Nginx e certbot recebem em conjunto um novo certificado agora válido. </li><li>  Assim que o certificado é recebido, o certbot entra em "modo de espera", acordando a cada 12 horas para verificar se precisa ser atualizado - de acordo com as recomendações do Let's Encrypt. </li><li>  Quando chegar o momento e o certificado for renovado, o certbot sinalizará ao Nginx para reiniciar. </li></ol><br><h3 id="trudnost-4-chto-to-dolzhno-sohranyatsya">  Dificuldade nº 4: algo deve ser preservado </h3><br><p>  Suspeito fortemente que você deseja que os comentários do usuário sejam salvos após uma reinicialização ou atualização do sistema. </p><br><p>  Além disso, para que o Let's Encrypt não o bane devido a solicitações muito frequentes, seria bom manter os certificados recebidos por toda a data de validade. </p><br><p> Ambos os pontos foram resolvidos na configuração proposta usando os volumes do Docker, criados automaticamente pelo <em>systemd</em> quando o Commento foi lançado.  Como os volumes são marcados como "externos", o Docker os ignora ao remover contêineres usando <code>docker-compose down -v</code> . </p><br><h2 id="svodim-vsyo-voedino">  Junte tudo </h2><br><p>  Agora você pode ver como tudo funciona juntos. </p><br><p>  A figura abaixo mostra a interação e o tráfego entre os quatro contêineres: </p><br><p><img src="https://habrastorage.org/webt/zl/kr/y3/zlkry3l9lxx8mfwzzlsnuvubi6a.png"></p><br><p>  Eu apliquei a opção <code>depends_on</code> Docker Compose <code>depends_on</code> para garantir que os contêineres iniciem na ordem correta. </p><br><p>  Se você deseja iniciar apenas seu próprio servidor Commento, pode pular o restante do artigo e ir diretamente para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código no GitHub</a> . </p><br><p>  Bem, falarei mais sobre essa implementação em mais detalhes posteriormente. </p><br><h2 id="kak-eto-vsyo-rabotaet">  Como tudo isso funciona </h2><br><h3 id="fayl-compose">  Redigir arquivo </h3><br><p>  Como você pode ver na figura acima, minha “composição” consiste em quatro serviços: </p><br><ol><li>  <code>certbot</code> - utilitário <code>certbot</code> da EFF </li><li>  <code>nginx</code> - proxy reverso implementando descarregamento de SSL </li><li>  <code>app</code> - servidor Commento </li><li>  <code>postgres</code> - banco de dados PostgreSQL </li></ol><br><p>  O <a href=""><code>docker-compose.yml</code></a> contém declarações de sua própria rede Docker, chamada <code>commento_network</code> , e três volumes, dos quais dois são externos (ou seja, devem ser criados fora do Compose): </p><br><ul><li>  <code>commento_postgres_volume</code> armazena dados do servidor PostgreSQL para o Commento: usuários, moderadores, comentários, etc. </li><li>  <code>certbot_etc_volume</code> contém certificados recebidos pelo <code>certbot</code> . </li></ul><br><h3 id="nginx">  Nginx </h3><br><p>  O contêiner Nginx é baseado em uma imagem oficial leve baseada no Alpine e usa o seguinte script para executar: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait for the certificate file to arrive wait_for_certs() { echo 'Waiting for config files from certbot...' i=0 while [[ ! -f /etc/letsencrypt/options-ssl-nginx.conf ]]; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo 'No files after 10 seconds, aborting' &amp;&amp; exit 2 done } # Watches for a "reload flag" (planted by certbot container) file and reloads nginx config once it's there watch_restart_flag() { while :; do [[ -f /var/www/certbot/.nginx-reload ]] &amp;&amp; rm -f /var/www/certbot/.nginx-reload &amp;&amp; echo 'Reloading nginx' &amp;&amp; nginx -s reload sleep 10 done } # Wait for certbot wait_for_certs # Start "reload flag" watcher watch_restart_flag &amp; # Run nginx in the foreground echo 'Starting nginx' exec nginx -g 'daemon off;'</span></span></code> </pre> <br><ul><li>  Linha <strong>3</strong> ( <em>ARRGHHH, Habr não suporta a exibição de números de linha no código - aprox. Transl.</em> ) Um manipulador de interrupção é registrado para que o Nginx e o processo de monitoramento em segundo plano concluam com êxito o trabalho quando o contêiner para. </li><li>  A linha <strong>27</strong> chama a função de espera, que interrompe o processo de inicialização do Nginx até que os arquivos de configuração SSL criados pelo contêiner <code>certbot</code> .  Sem isso, o Nginx se recusaria a começar. </li><li>  A linha <strong>30</strong> cria um processo em segundo plano que regularmente, a cada dez segundos, verifica a presença de um arquivo de sinalizador chamado <code>.nginx-reload</code> e, assim que é detectado, instrui o Nginx a recarregar a configuração.  Este arquivo também cria o certbot quando o certificado é atualizado. </li><li>  A linha <strong>34</strong> inicia o Nginx no modo normal.  Nesse caso, <code>exec</code> significa que o processo atual do shell é <em>substituído pelo</em> processo Nginx. </li></ul><br><p>  Outro arquivo importante nesta imagem é a configuração do servidor virtual Commento, que força o Nginx a encaminhar solicitações HTTPS para o contêiner do <code>commento</code> : </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">443</span></span> ssl ipv6only=<span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">443</span></span> ssl; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/html; <span class="hljs-attribute"><span class="hljs-attribute">index</span></span> index.html index.htm index.nginx-debian.html; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://app:8080/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$http_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-variable"><span class="hljs-variable">$proxy_add_x_forwarded_for</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /etc/letsencrypt/live/__DOMAIN__/fullchain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /etc/letsencrypt/live/__DOMAIN__/privkey.pem; <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="hljs-attribute"><span class="hljs-attribute">ssl_dhparam</span></span> /etc/letsencrypt/ssl-dhparams.pem; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /.well-known/acme-challenge/ { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/certbot; } <span class="hljs-comment"><span class="hljs-comment"># Redirect to HTTPS on port 80 location / { return 301 https://$host$request_uri; } }</span></span></code> </pre> <br><p>  O primeiro bloco do servidor (linhas <strong>1-21</strong> ) descreve como trabalhar com HTTPS e a regra de encaminhamento.  É aqui que os arquivos do certificado Let's Encrypt são mencionados (ou stubs usados). </p><br><p>  O domínio atendido pelo servidor é passado como argumento ao criar a imagem;  ele substitui a linha <code>__DOMAIN__</code> na configuração do servidor. </p><br><p>  O segundo bloco (linhas <strong>23-38</strong> ) é a configuração do servidor HTTP, que é usada pelo certbot para confirmar a propriedade do domínio (o chamado "desafio da ACME").  Todos os outros pedidos causam um redirecionamento para o endereço correspondente via HTTPS. </p><br><h3 id="certbot">  certbot </h3><br><p>  Nossa imagem certbot é baseada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compilação oficial</a> com o seguinte script: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait until nginx is up and running, up to 10 seconds wait_for_nginx() { echo 'Waiting for nginx...' i=0 while ! nc -z nginx 80 &amp;&gt;/dev/null; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo "nginx isn't online after 10 seconds, aborting" &amp;&amp; exit 4 done echo 'nginx is up and running' } # Check vars [[ -z "$DOMAIN" ]] &amp;&amp; echo "Environment variable 'DOMAIN' isn't defined" &amp;&amp; exit 2 [[ -z "$EMAIL" ]] &amp;&amp; echo "Environment variable 'EMAIL' isn't defined" &amp;&amp; exit 2 TEST="${TEST:-false}" # Check external mounts data_dir='/etc/letsencrypt' www_dir='/var/www/certbot' [[ ! -d "$data_dir" ]] &amp;&amp; echo "Directory $data_dir must be externally mounted" [[ ! -d "$www_dir" ]] &amp;&amp; echo "Directory $www_dir must be externally mounted" # If the config/certificates haven't been initialised yet if [[ ! -e "$data_dir/options-ssl-nginx.conf" ]]; then # Copy config over from the initial location echo 'Initialising nginx config' cp /conf/options-ssl-nginx.conf /conf/ssl-dhparams.pem "$data_dir/" # Copy dummy certificates mkdir -p "$data_dir/live/$DOMAIN" cp /conf/privkey.pem /conf/fullchain.pem "$data_dir/live/$DOMAIN/" # Wait for nginx wait_for_nginx # Remove dummy certificates rm -rf "$data_dir/live/$DOMAIN/" # Run certbot to validate/renew certificate test_arg= $TEST &amp;&amp; test_arg='--test-cert' certbot certonly --webroot -w /var/www/certbot -n -d "$DOMAIN" $test_arg -m "$EMAIL" --rsa-key-size 4096 --agree-tos --force-renewal # Reload nginx config touch /var/www/certbot/.nginx-reload # nginx config has been already initialised - just give nginx time to come up else wait_for_nginx fi # Run certbot in a loop for renewals while :; do certbot renew # Reload nginx config touch /var/www/certbot/.nginx-reload sleep 12h done</span></span></code> </pre> <br><p>  Um breve tour por suas linhas: </p><br><ul><li>  A linha <strong>3</strong> , como no script anterior, é necessária para a conclusão regular do contêiner. </li><li>  As linhas <strong>17-19</strong> verificam as variáveis ​​necessárias. </li><li>  E nas linhas <strong>22-25</strong> - que os diretórios necessários para que o certbot funcione sejam montados corretamente. </li><li>  O garfo segue: <br><ul><li>  As linhas <strong>30-50</strong> são executadas apenas no primeiro início do contêiner: <br><ul><li>  Um certificado fictício é copiado, permitindo que o Nginx inicie normalmente. </li><li>  Enquanto isso, o Nginx aguarda o final desse processo, após o qual continua o download. </li><li>  Depois que o Nginx é iniciado, o certbot inicia o processo de obtenção de um certificado válido no Let's Encrypt. </li><li>  E, finalmente, assim que o certificado é recebido, o arquivo <code>.nginx-reload</code> é criado, sugerindo ao Nginx que é hora de recarregar a configuração. </li></ul></li><li>  A linha <strong>54</strong> aguarda o início do Nginx - no caso em que um certificado completo já esteja disponível. </li></ul></li><li>  Depois de tudo isso (linhas <strong>58-63</strong> ), ele continua o ciclo, uma vez a cada 12 horas, verificando a necessidade de renovar o certificado e sinalizando ao Nginx para reiniciar. </li></ul><br><h3 id="commento-i-postgresql">  Commento e PostgreSQL </h3><br><p>  Os contêineres do <code>app</code> e do <code>postgres</code> usam as imagens originais fornecidas pelos desenvolvedores sem nenhuma alteração. </p><br><h3 id="servis-systemd">  Serviço Systemd </h3><br><p>  A última parte deste quebra-cabeça é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivo da unidade systemd</a> <code>commento.service</code> , no qual você precisa criar um link simbólico em <code>/etc/systemd/system/commento.service</code> para que ele inicie em um bom momento quando o sistema for iniciado: </p><br><pre> <code class="plaintext hljs">[Unit] Description=Commento server [Service] TimeoutStopSec=30 WorkingDirectory=/opt/commento ExecStartPre=-/usr/bin/docker volume create commento_postgres_volume ExecStartPre=-/usr/bin/docker volume create certbot_etc_volume ExecStartPre=-/usr/local/bin/docker-compose -p commento down -v ExecStart=/usr/local/bin/docker-compose -p commento up --abort-on-container-exit ExecStop=/usr/local/bin/docker-compose -p commento down -v [Install] WantedBy=multi-user.target</code> </pre> <br><p>  Linhas: </p><br><ul><li>  A linha <strong>6</strong> implica que o código do projeto é clonado no diretório <code>/opt/commento</code> - isso é muito mais simples. </li><li>  As linhas <strong>7-8</strong> criam volumes externos, se ainda não estiverem. </li><li>  Na linha <strong>9</strong> , os possíveis restos dos contêineres anteriores são excluídos.  Os volumes externos são preservados. </li><li>  A linha <strong>10</strong> marca o lançamento real do Docker Compose.  O <code>--abort-on-container-exit</code> todo o bando de contêineres quando algum deles é <code>--abort-on-container-exit</code> .  Graças a isso, o systemd estará ciente de que o serviço está parado. </li><li>  A linha <strong>11</strong> está novamente limpando e excluindo contêineres, redes e volumes. </li></ul><br><h2 id="ishodnyy-kod">  Código fonte </h2><br><p>  Uma implementação totalmente funcional, exigindo apenas a configuração de variáveis ​​no <code>docker-compose.yml</code> , está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no GitHub</a> .  Você só precisa seguir cuidadosamente as etapas descritas em <a href="">README</a> . </p><br><p>  O código está sujeito à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">licença MIT</a> . </p><br><p>  Obrigado por ler neste lugar, os comentários são freneticamente bem-vindos! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464105/">https://habr.com/ru/post/pt464105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464093/index.html">Bens digitais: o que fazer se um cliente vier buscar uma compra em um ano?</a></li>
<li><a href="../pt464095/index.html">Getters e Setters em Dart and Flutter</a></li>
<li><a href="../pt464097/index.html">A evolução da inteligência: por que os robôs precisam de emoções</a></li>
<li><a href="../pt464099/index.html">Análise da linguagem VKScript: JavaScript, e você?</a></li>
<li><a href="../pt464103/index.html">Rascunho do padrão nacional de IoT do OpenUNB: revisão crítica</a></li>
<li><a href="../pt464107/index.html">Eventos digitais em Moscou, de 19 a 25 de agosto</a></li>
<li><a href="../pt464109/index.html">Pára-quedas supersônicos do espaço</a></li>
<li><a href="../pt464111/index.html">Natas Web. Passagem da plataforma CTF destinada a explorar vulnerabilidades da Web</a></li>
<li><a href="../pt464113/index.html">"CAD para todos, de graça, e não deixe ninguém ir ..." ou os primeiros passos na programação do FreeCAD em Python</a></li>
<li><a href="../pt464115/index.html">Como fazer amigos para um designer, designer de layout e “Figma” usando um sistema de design, pé de cabra e algum tipo de mãe ™</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>