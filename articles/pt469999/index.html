<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèæ üï£ üë©üèº Como os servidores negociam entre si: algoritmo de consenso distribu√≠do Raft üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üñïüèª ‚ò¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando os clusters atingem centenas e, √†s vezes, milhares de m√°quinas, surge a quest√£o da consist√™ncia dos estados do servidor em rela√ß√£o um ao outro....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como os servidores negociam entre si: algoritmo de consenso distribu√≠do Raft</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/469999/">  Quando os clusters atingem centenas e, √†s vezes, milhares de m√°quinas, surge a quest√£o da consist√™ncia dos estados do servidor em rela√ß√£o um ao outro.  O algoritmo de consenso distribu√≠do da jangada fornece a garantia de consist√™ncia mais rigorosa poss√≠vel.  Neste artigo, consideraremos o Raft do ponto de vista de um engenheiro e tentaremos responder √†s perguntas "Como?"  e "por que?"  ele est√° trabalhando. <br><br><img src="https://habrastorage.org/webt/e7/yf/fs/e7yffsk5gyqcjqxclgt9oqvnyrs.png"><br><br><a name="habracut"></a><br><blockquote>  Autor do artigo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dmitry Pavlushin</a> (desenvolvedor Dodo Pizza Engineering). </blockquote><br>  O Raft √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um algoritmo de consenso distribu√≠do</a> que √© necess√°rio para que v√°rios participantes possam decidir em conjunto se um evento ocorreu ou n√£o e o que se seguiu. <br><br>  Os dados fornecidos pelo cluster Raft s√£o um log que consiste em registros.  Quando um usu√°rio deseja alterar os dados armazenados em um cluster, ele tenta adicionar um novo registro ao log com o comando: <br><br><img src="https://habrastorage.org/webt/vo/wu/sl/vowusleov4a4bpnob0koux_7vns.png"><br>  Esses comandos s√£o executados por m√°quinas de estado distribu√≠das.  Por simplicidade e clareza, na estrutura deste artigo, assumiremos que esses registros s√£o fornecidos simplesmente ao ler para um cliente que, com base nos eventos ocorridos, restaura o estado atual do sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(consulte Origem do evento)</a> . <br><br>  Para garantir consenso no Raft, primeiro √© selecionado um l√≠der, no qual ser√° respons√°vel pelo gerenciamento do log distribu√≠do.  O l√≠der aceita solicita√ß√µes de clientes e as replica para outros servidores no cluster.  Se o l√≠der falhar, um novo l√≠der ser√° selecionado no cluster.  Isso ocorre por um tempo em tr√™s frases.  Detalhes seguir√£o. <br><br><h2>  Conceitos b√°sicos </h2><br><ol><li> <b>Estados do servidor</b>  No cluster Raft, cada servidor em um determinado momento est√° em um dos tr√™s estados: <br><ul><li>  L√≠der (l√≠der) - processa todas as solicita√ß√µes do cliente, √© a fonte da verdade de todos os dados no log, suporta o log do seguidor. </li><li>  O seguidor (seguidor) √© um servidor passivo que apenas "escuta" novas entradas de log do l√≠der e redireciona todas as solicita√ß√µes recebidas dos clientes para o l√≠der.  Na verdade, √© uma r√©plica do l√≠der em espera. </li><li>  Candidato (candidato) √© um estado especial do servidor, poss√≠vel apenas durante a sele√ß√£o de um novo l√≠der. </li></ul><br>  Durante a opera√ß√£o normal em um cluster, apenas um servidor √© o l√≠der e o restante s√£o seus seguidores. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre o assincronismo</b> <div class="spoiler_text">  Vale a pena notar aqui que condi√ß√£o √© um conceito relativo.  Devido ao fato de os servidores se comunicarem de forma ass√≠ncrona, servidores diferentes podem observar as transi√ß√µes de outros servidores de um estado para outro em momentos diferentes. <br></div></div></li><li>  <b>A jangada divide o tempo em segmentos de comprimento arbitr√°rio, chamados prazos</b> .  Cada termo tem um n√∫mero crescente monotonicamente.  O termo come√ßa com a elei√ß√£o de um l√≠der quando um ou mais servidores se tornam candidatos.  Se o candidato recebe a maioria dos votos, ele se torna um l√≠der at√© o final deste per√≠odo.  Se os votos forem divididos e nenhum dos candidatos conseguir a maioria dos votos, um tempo limite √© acionado e esse per√≠odo termina.  Depois disso, um novo mandato come√ßa com novos candidatos e elei√ß√µes.  Essa situa√ß√£o √© chamada de vota√ß√£o por partes.  Um exemplo √© ilustrado pelo termo n√∫mero tr√™s no diagrama a seguir: <br><br><img src="https://habrastorage.org/webt/uw/uj/cr/uwujcro7y3jflbpmc1y2iek_wlg.png"><br>  O n√∫mero do termo serve como um carimbo de data / hora l√≥gico no cluster Raft.  Ajuda os servidores a determinar quais informa√ß√µes s√£o mais relevantes no momento. <br><br><div class="spoiler">  <b class="spoiler_title">Regras e termos de intera√ß√£o do servidor</b> <div class="spoiler_text"><ul><li>  Cada servidor controla o n√∫mero do seu termo atual. </li><li>  O servidor inclui seu n√∫mero de expira√ß√£o em cada mensagem enviada. </li><li>  Se o servidor receber uma mensagem com um n√∫mero de termo menor que o seu, ignorar√° essa mensagem. </li><li>  Se o servidor receber uma mensagem com um n√∫mero de prazo mais longo que o seu, ele atualizar√° seu n√∫mero de prazo para corresponder ao n√∫mero recebido. </li><li>  Se um candidato ou l√≠der recebe uma mensagem com um n√∫mero de prazo mais longo que o seu, ele entende que outros servidores j√° iniciaram um novo prazo, e seu prazo n√£o √© mais relevante.  Portanto, passa do estado atual para o estado ‚Äúseguidor‚Äù, al√©m de atualizar seu n√∫mero. </li></ul></div></div><br></li><li>  <b>Comunica√ß√£o do servidor.</b>  Os servidores no Raft interagem trocando solicita√ß√µes e respostas.  O algoritmo b√°sico usa apenas dois tipos de chamadas: <br><br><ul><li>  <b>O RequestVote √©</b> usado pelos candidatos durante as elei√ß√µes.  A solicita√ß√£o cont√©m o n√∫mero do termo do candidato e os metadados sobre o log do candidato, discutidos em mais detalhes abaixo.  A resposta cont√©m o n√∫mero do prazo final do servidor que responde e o valor "true" se o servidor votar no candidato;  Falso se o servidor votar contra o candidato. </li><li>  <b>AppendEntries √©</b> usado pelo l√≠der para replica√ß√£o de log, bem como para o mecanismo de pulsa√ß√£o.  A solicita√ß√£o cont√©m o n√∫mero do termo do l√≠der, uma cole√ß√£o de entradas que precisam ser adicionadas ao log (ou uma cole√ß√£o vazia no caso de pulsa√ß√£o), alguns metadados sobre o log do l√≠der, tamb√©m discutidos em mais detalhes abaixo.  A resposta cont√©m o n√∫mero do termo do seguidor e o valor "true" se o seguidor tiver adicionado com √™xito entradas ao seu log;  ‚ÄúFalse‚Äù se a adi√ß√£o de entradas de log falhar. </li></ul></li></ol><br><h2>  Algoritmo de trabalho </h2><br><h4>  1. Escolha um l√≠der </h4><br>  Para determinar quando √© hora de iniciar uma nova elei√ß√£o, o Raft depende dos batimentos card√≠acos.  O seguidor permanece o seguidor at√© receber mensagens do l√≠der ou candidato atual.  O l√≠der envia periodicamente pulsa√ß√µes para todos os outros servidores. <br><br>  Se o seguidor n√£o receber nenhuma mensagem por algum tempo, ele naturalmente assumir√° que o l√≠der est√° morto, o que significa que √© hora de tomar a iniciativa em suas m√£os.  Nesse ponto, o ex-seguidor inicia a elei√ß√£o. <br><br>  Para iniciar a elei√ß√£o, o seguidor aumenta seu n√∫mero de mandato, alterna para o estado "candidato", vota em si mesmo e envia a solicita√ß√£o "RequestVote" para todos os outros servidores.  Depois disso, o candidato aguarda um dos tr√™s eventos: <br><br><ol><li>  <b>O candidato recebe a maioria dos votos (incluindo os seus) e vence a elei√ß√£o.</b>  Cada servidor vota apenas uma vez em cada mandato, para que o primeiro candidato seja alcan√ßado (com algumas exce√ß√µes, discutidas abaixo); portanto, apenas um candidato pode obter a maioria dos votos em um termo espec√≠fico.  O servidor vencedor se torna o l√≠der, come√ßa a enviar pulsa√ß√£o e a atender solicita√ß√µes de clientes ao cluster. </li><li>  <b>O candidato recebe uma mensagem do l√≠der atual do termo atual ou de qualquer servidor com um termo mais antigo</b> .  Nesse caso, o candidato entende que as elei√ß√µes nas quais ele dirige n√£o s√£o mais relevantes.  Ele n√£o tem escolha a n√£o ser reconhecer um novo l√≠der / novo termo e entrar em um estado de seguidor. </li><li>  <b>Um candidato n√£o recebe a maioria dos votos por um certo tempo limite.</b>  Isso pode acontecer quando v√°rios seguidores se tornam candidatos e os votos s√£o divididos entre eles para que nenhum deles obtenha a maioria.  Nesse caso, o mandato termina sem um l√≠der e o candidato inicia imediatamente novas elei√ß√µes para o pr√≥ximo mandato. </li></ol><br><h4>  2. N√≥s replicamos logs </h4><br>  Quando um l√≠der √© selecionado, ele √© respons√°vel por gerenciar o log distribu√≠do.  O l√≠der aceita solicita√ß√µes de clientes que cont√™m algumas equipes.  O l√≠der coloca em seu log um novo registro contendo o comando e envia "AppendEntries" a todos os seguidores para replicar o registro com o novo registro. <br><br>  Quando o registro √© replicado com sucesso na maioria dos servidores, o l√≠der come√ßa a considerar o registro fechado e responde ao cliente.  O l√≠der controla qual √© o √∫ltimo registro.  Ele envia o n√∫mero desse registro para AppendEntries (incluindo pulsa√ß√£o) para que os seguidores possam confirmar o registro para si mesmos. <br><br>  Caso o l√≠der n√£o consiga alcan√ßar alguns seguidores, ele retornar√° as AppendEntries ao infinito.  A figura a seguir mostra como os logs s√£o organizados no cluster Raft: <br><br><img src="https://habrastorage.org/webt/s3/2l/-z/s32l-zuwjn3u0eoz83j8pysn_uc.png"><br><br>  Cada caixa √© uma entrada no log.  Cada registro armazena um comando, por exemplo, x ‚Üê 3 atribui o valor 3 √† chave x.  O registro tamb√©m armazena o n√∫mero do termo em que foi gerado.  Na figura, isso √© indicado por um n√∫mero no topo do quadrado.  A exibi√ß√£o em cores dos quadrados tamb√©m significa o n√∫mero do termo.  Cada registro possui um n√∫mero de s√©rie (√≠ndice de log). <br><br><h4>  3. Garantimos a confiabilidade do algoritmo </h4><br>  At√© agora, pelo que examinamos, n√£o est√° claro como o Raft pode dar pelo menos algumas garantias.  No entanto, o algoritmo fornece um conjunto de propriedades que juntas garantem a confiabilidade de sua execu√ß√£o: <br><br><ul><li>  <b>Seguran√ßa Eleitoral</b> : n√£o √© poss√≠vel selecionar mais de um l√≠der em um √∫nico mandato.  Essa propriedade decorre do fato de que cada servidor vota em cada mandato apenas uma vez e, para a forma√ß√£o de um l√≠der, √© necess√°ria a maioria dos votos. </li><li>  <b>Somente acr√©scimo de</b> l√≠der: o l√≠der nunca substitui ou apaga, n√£o move entradas em seu log, apenas adiciona novas entradas.  Essa propriedade segue diretamente da descri√ß√£o do algoritmo - a √∫nica opera√ß√£o que um l√≠der pode executar com seu log √© adicionar entradas ao final.  E √© isso. </li><li>  <b>Correspond√™ncia de Log:</b> se os logs de dois servidores contiverem uma entrada com o mesmo n√∫mero de √≠ndice e expira√ß√£o, os dois logs ser√£o id√™nticos at√© e incluindo esse registro. <br><br><div class="spoiler">  <b class="spoiler_title">Prova usando indu√ß√£o matem√°tica e imagens</b> <div class="spoiler_text">  A indu√ß√£o matem√°tica √© uma maneira de provar quando o primeiro passo √© provar uma afirma√ß√£o para um caso simples.  Na segunda etapa, aceitamos a afirma√ß√£o verdadeira para alguns casos X. Com base nisso, tentamos provar a afirma√ß√£o para alguns casos vizinhos X + 1.  Juntas, essas duas etapas ajudam a provar a afirma√ß√£o para todos os casos. <br><br>  Na nossa situa√ß√£o, um caso simples s√£o logs vazios.  N√£o h√° registros, portanto, n√£o h√° nada para violar a propriedade. <br><br>  Agora vamos tentar assumir que existem algumas entradas nos logs que correspondem √† nossa propriedade.  O Raft possui um mecanismo que impede a quebra da propriedade quando qualquer log √© alterado.  Esse mecanismo √© chamado de <b>verifica√ß√£o de consist√™ncia</b> .  Vejamos os exemplos imediatamente. <br><br>  <b>Bom exemplo</b>  H√° um l√≠der, por exemplo, do quarto mandato, h√° um seguidor.  Ambos t√™m registros correspondentes de tr√™s entradas. <br><br><img src="https://habrastorage.org/webt/ob/kl/qj/obklqjfsspdfwyxwmpodpyvc-ia.png"><br><br>  Uma solicita√ß√£o do cliente chega ao l√≠der, ele adiciona uma entrada ao seu log. <br><br><img src="https://habrastorage.org/webt/e9/d0/_x/e9d0_xsxyddboyfr9yjjdfake8m.png"><br><br>  O l√≠der envia AppendEntries para o seguidor.  Mas, al√©m do registro mais adicionado, o l√≠der tamb√©m indica na solicita√ß√£o que o registro deve ser adicionado no √≠ndice 4 e no √≠ndice 3, √† frente dele, deve haver um registro do termo 2. <br><br><img src="https://habrastorage.org/webt/eo/7l/x0/eo7lx0m8xul1tmtzqfkk4cgjdic.png"><br><br>  A entrada de log no √≠ndice 3 no log do seguidor corresponde √† especificada na solicita√ß√£o; portanto, o seguidor adiciona a entrada ao log e responde com sucesso ao l√≠der.  O fim <br><br><img src="https://habrastorage.org/webt/ef/e8/kg/efe8kg2uspvnflbnx6mnkx5-1ko.png"><br><br>  <b>Tamb√©m √© um bom exemplo, mas com um come√ßo tr√°gico.</b>  Agora, o registro do seguidor √© diferente do registro do l√≠der atual. <br><br><img src="https://habrastorage.org/webt/t8/5d/ae/t85daek6x0n9spztxu-jeu5qee8.png"><br><br>  Quando o l√≠der recebe uma solicita√ß√£o para adicionar uma entrada ao log, ele envia as mesmas AppendEntries que no exemplo anterior. <br><br><img src="https://habrastorage.org/webt/ka/q5/gw/kaq5gw5c0ezpdflgrdinqmpbmmk.png"><br><br>  No entanto, desta vez, como o seguidor n√£o corresponde ao registro anterior, o seguidor falha. <br><br><img src="https://habrastorage.org/webt/41/wk/zf/41wkzfixq1dr2x8artbwph2s3jw.png"><br><br>  O que o l√≠der faz neste caso?  O l√≠der simplesmente retrocede um pouco e tenta alimentar o seguidor com o registro que ele pr√≥prio considera no √≠ndice 3. Ele tamb√©m inclui o registro anterior na solicita√ß√£o. <br><br><img src="https://habrastorage.org/webt/y_/gw/br/y_gwbrjzohvl83zh-e2hploan5m.png"><br><br>  Agora o seguidor responde com sucesso e sobrescreve as entradas em seu log, come√ßando no √≠ndice 3. <br><br><img src="https://habrastorage.org/webt/8l/oa/wp/8loawpe9iqskomaw0p7zbwek9f8.png"><br><br>  O registro do seguidor pode ser diferente do registro do l√≠der, conforme desejado.  Pode n√£o haver entradas suficientes, mas pode haver entradas extras.  De qualquer forma, a verifica√ß√£o de consist√™ncia garante que os registros dos seguidores, mais cedo ou mais tarde, coincidam com o registro do l√≠der. <br></div></div><br></li><li>  <b>Conclus√£o do l√≠der</b> : se a entrada do log for confirmada em um determinado momento, os logs dos l√≠deres de todos os per√≠odos subsequentes incluir√£o esse registro.  Esta propriedade fornece garantias de durabilidade. <br><br><div class="spoiler">  <b class="spoiler_title">Prova e Imagens</b> <div class="spoiler_text">  Considere a seguinte situa√ß√£o: tr√™s servidores em um cluster.  O servidor S1 √© o l√≠der do primeiro mandato atual.  Todos os servidores t√™m tr√™s entradas de log. <br><br><img src="https://habrastorage.org/webt/g6/c9/zb/g6c9zbx5fsewp_4nn0komxcnikm.png"><br><br>  O l√≠der S1 recebe uma solicita√ß√£o do cliente e adiciona um novo registro ao seu log, envia AppendEntries para outros servidores S2 e S3. <br><br><img src="https://habrastorage.org/webt/rz/ki/gf/rzkigfvgmygzxg4qbwy9tfgf914.png"><br><br>  O registro alcan√ßa S2 com √™xito, mas a rede entre S1 e S3 pisca e a solicita√ß√£o √© perdida.  Como o S1 sabe que o registro est√° presente em dois dos tr√™s servidores, ele pode determinar que o registro foi confirmado e responder com √™xito ao cliente. <br><br>  O S1 tamb√©m tentar√° adicionar uma entrada ao S3 at√© que seja bem-sucedida.  Mas o que acontece se S1 falhar e desligar?  Al√©m disso, o que acontecer√° se o S3 for o primeiro a se cansar de esperar e se tornar um candidato?  S2 votar√° a favor, S3 se tornar√° o l√≠der do segundo mandato e, na pr√≥xima solicita√ß√£o para adicionar um registro, S3 substituir√° nosso registro gravado? <br><br><img src="https://habrastorage.org/webt/_g/ij/l3/_gijl3pklfn6g5xme0ta7-svaus.png"><br><br>  De fato, essa situa√ß√£o n√£o pode acontecer no cluster Raft.  O problema aqui √© que o S2 n√£o votaria no S3.  Porque  Como o log do servidor S3 no momento da vota√ß√£o √© menos relevante que o log do servidor S2.  Esse mecanismo √© chamado de <b>restri√ß√£o de elei√ß√£o</b> - o servidor votar√° em outro servidor apenas se o registro do candidato n√£o for menos relevante que o registro do eleitor. <br><br>  O Raft compara a relev√¢ncia dos logs de duas maneiras: <br><br><ul><li>  N√∫mero da data do √∫ltimo registro </li><li>  Comprimento do registro </li></ul><br>  Os candidatos incluem esses dois par√¢metros na solicita√ß√£o RequestVote para que os seguidores possam comparar a relev√¢ncia de seu log com o log do candidato. <br><br>  "Mais importante" √© o log no qual o √∫ltimo registro √© mais antigo. <br><br><img src="https://habrastorage.org/webt/7o/2a/-v/7o2a-vpncoa6z4qwmn-xdgckh1m.png"><br><br>  Se os n√∫meros do termo das √∫ltimas entradas coincidirem, o "principal" ser√° o log mais longo. <br><br><img src="https://habrastorage.org/webt/qf/kx/nk/qfkxnk-qv4py6t6lvw3i8wuphu4.png"><br><br>  Se os dois coincidirem, os logs ser√£o igualmente relevantes e tamb√©m, como segue a propriedade anterior, s√£o absolutamente id√™nticos. <br><br><img src="https://habrastorage.org/webt/hp/ej/x8/hpejx8hkcwkm-fjs7qs98gzn8pc.png"><br><br>  Acontece que o log do servidor no qual existe um registro protegido sempre ser√° mais relevante do que o log no qual n√£o √©.  E um servidor que possui um registro seguro n√£o votar√° em um servidor que n√£o o possui.  E como h√° um registro gravado na maioria dos servidores, um candidato sem esse registro n√£o poder√° obter a maioria dos votos e se tornar um l√≠der para remover esse registro de outros servidores. <br></div></div><br></li><li>  <b>Seguran√ßa de m√°quinas de estado</b> : essa propriedade √© descrita no original em termos de m√°quinas de estado distribu√≠das; em termos de nosso artigo, essa propriedade pode ser descrita da seguinte maneira: quando um servidor confirma um registro com um determinado √≠ndice, nenhum outro servidor confirma outro registro para esse √≠ndice. <br><br>  Esta propriedade segue do passado.  Se o seguidor confirmar algum registro no √≠ndice N, o registro dele ser√° id√™ntico ao registro do l√≠der at√© e incluindo N.  A propriedade Conclus√£o do l√≠der garante que todos os l√≠deres subsequentes tamb√©m contenham esse registro seguro no √≠ndice N, o que significa que os seguidores que confirmaram um registro no √≠ndice N em per√≠odos subsequentes confirmar√£o o mesmo valor. <br></li></ul><br><h2>  Links para materiais para estudos adicionais </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O algoritmo de consenso da jangada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Em busca de um algoritmo de consenso compreens√≠vel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consenso: Bridging Theory and Practice</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gato de Schrodinger sem caixa: o problema do consenso em sistemas distribu√≠dos</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469999/">https://habr.com/ru/post/pt469999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469987/index.html">As 20 principais empresas de desenvolvimento de mercado de todo o mundo</a></li>
<li><a href="../pt469989/index.html">C # Regex em exemplos</a></li>
<li><a href="../pt469991/index.html">Processamos pedidos da loja on-line usando RabbitMQ e TypeScript</a></li>
<li><a href="../pt469995/index.html">Analisador Python SAX vs analisador DOM python. Casas FIAS Parsim</a></li>
<li><a href="../pt469997/index.html">Quais manchetes t√™m maior probabilidade de atrair aten√ß√£o ou an√°lise do HabraHabr</a></li>
<li><a href="../pt470001/index.html">Dicas e truques do Linux: servidor, aberto</a></li>
<li><a href="../pt470003/index.html">F # 1: Ol√° mundo</a></li>
<li><a href="../pt470005/index.html">Controle remoto do computador via navegador</a></li>
<li><a href="../pt470009/index.html">Classifique fotos por dados do EXIF ‚Äã‚Äã+ PHP</a></li>
<li><a href="../pt470011/index.html">Laborat√≥rio interativo de termodin√¢mica como um meio eficaz de treinamento em simula√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>