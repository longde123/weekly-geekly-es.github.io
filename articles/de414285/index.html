<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏾 🍶 🆘 Wir verwenden einen 433-MHz-Funkschalter zur Steuerung des PCs 🍃 🐲 🎫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Geektimes Habr. 

 Bei mir zu Hause haben sich mehrere Funkschalter mit 433 MHz angesammelt. Es wurde interessant, ob sie für Aufgaben verwendet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verwenden einen 433-MHz-Funkschalter zur Steuerung des PCs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414285/">  Hallo <s>Geektimes</s> Habr. <br><br>  Bei mir zu Hause haben sich mehrere Funkschalter mit 433 MHz angesammelt. Es wurde interessant, ob sie für Aufgaben verwendet werden können, zum Beispiel zur Steuerung eines Computers oder zur Integration eines „Smart Home“ in das System. <br><br>  Diese Schalter sind praktisch für ihre geringen Kosten und ihren stabilen Betrieb. Sie sehen ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/up/tt/p4/upttp4hzw_us_v2bb0kdliszify.jpeg"><br><br>  Wie es funktioniert und was mit ihnen gemacht werden kann (Husaren schweigen :), Details unter dem Schnitt. <a name="habracut"></a><br><br><h2>  Theorie </h2><br>  Ich muss sofort sagen, wie ein solcher Schalter funktioniert, ich weiß es nicht, obwohl ich es vermute.  Sie müssen also ein wenig Reverse Engineering durchführen. <br><br>  Zunächst muss das Signal empfangen werden, für das wir den bereits bekannten RTL-SDR-Empfänger verwenden, der für Funkamateure oft einfach als „Pfeife“ bezeichnet wird.  Mit diesem Gerät für nur 10 US-Dollar können Sie Funksignale im Bereich von etwa 50 bis 1250 MHz empfangen, was wir brauchen.  Das Thema ist alt, aber wenn jemand es nicht gelesen hat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie es</a> . <br><br>  Wir machen den ersten Schritt der Analyse - wir schauen uns den Schalter genau an.  Wir finden, dass auf der Rückseite des Gehäuses „Made in China“ steht (wer hätte das gedacht?). Und was noch wichtiger ist, die Frequenz 433 MHz ist angegeben.  Jetzt können Sie den SDR-Empfänger anschließen, SDR # starten und sicherstellen, dass die Daten tatsächlich übertragen werden. <br><br><img src="https://habrastorage.org/webt/qd/wd/hd/qdwdhdd9acsjgl1rp5cbobpb-qg.jpeg"><br><br>  Die Symmetrie des Signals im Spektrum deutet auf das Vorhandensein einer AM-Modulation hin.  Übrigens ist rechts ein schwächeres „Alien“ -Signal sichtbar - sie können auch empfangen und dekodiert werden, sie werden separat näher erläutert.  Zurück zum Signal.  Wir nehmen es im üblichen WAV-Format auf und drücken die Tasten auf der Fernbedienung - zum Beispiel habe ich die EIN- und AUS-Tasten auf Kanal „1“ gedrückt. <br><br>  Öffnen Sie die Audiodatei in einem beliebigen Audio-Editor und vergleichen Sie die Signale mit einem anderen professionellen Analysetool, Paint.  Wir platzieren 2 Signale von verschiedenen Tasten übereinander, um den Unterschied zu sehen: <br><br><img src="https://habrastorage.org/webt/hy/s5/8c/hys58cp3y1f0dujky-3kzjxxb1y.png"><br><br>  Es ist leicht zu erkennen, dass wir die übliche Bitfolge haben, deren Unterschied nur in einem Bit liegt und der EIN- oder AUS-Taste entspricht.  Während die Taste gedrückt wird, wiederholt der Schalter diese Sequenz einfach zyklisch in der Luft mit einer Geschwindigkeit von 20 Mal pro Sekunde.  Günstig und einfach, auch wenn eine Sequenz während der Übertragung verzerrt ist, wird die andere akzeptiert. <br><br>  Daraus kann übrigens eine wichtige Schlussfolgerung gezogen werden: Die Signale solcher Switches (es handelt sich um billige Modelle) werden "wie sie sind" ohne Authentifizierung, Schutz oder Verschlüsselung übertragen.  Ein solcher Schalter oder eine Funksteckdose mit einem solchen Schalter sollte nicht für einige wichtige Funktionen verwendet werden, z. B. zum Einschalten leistungsfähiger Heizungen oder noch mehr zum Öffnen der Vordertür oder der Garage.  Es geht nicht einmal um Hacker (die Wahrscheinlichkeit, dass jemand drahtlos in mein Haus eindringt, schätze ich weniger als die Wahrscheinlichkeit, auf mein ISS-Haus zu fallen), sondern dass ein Nachbar versehentlich denselben Schalter kaufen kann und die Codes möglicherweise übereinstimmen ( Am Schalter besteht jedoch die Wahl zwischen 4 Kanälen.  Nach meiner Erfahrung hat der Leistungsschalter 2-3 Mal im Jahr „sich selbst“ eingeschaltet, entweder ein Hindernis oder ein entferntes Signal vom selben Modell wurde tatsächlich empfangen. <br><br>  Dies gilt natürlich nicht für komplexere Systeme wie Lora oder Philips Hue. Mit der Verschlüsselung ist alles in Ordnung. <br><br>  Zurück zu unserer Aufgabe.  Sie können einen Decoder solcher Signale selbst schreiben, aber zum Glück wurde dies bereits vor uns in einem Projekt namens "rtl_433" durchgeführt.  Das Programm wurde ursprünglich für Linux erstellt, die Windows-Version kann unter Linux heruntergeladen werden. Die Version kann von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> heruntergeladen werden. <br><br>  Wir starten das Programm über die Kommandozeile: "rtl_433.exe -F json" <br><br><img src="https://habrastorage.org/webt/op/en/qn/openqnlud5suc071yu4_ja_ro-a.png"><br><br>  Wir haben die Daten, es bleibt ein Programm für deren Verarbeitung zu schreiben. <br><br><h2>  Himbeer pi </h2><br>  Das erste, was interessant ist, ist der Raspberry Pi.  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rtl_433</a> auf Raspbian zu installieren, entpacken Sie das <a href="">Archiv</a> und führen Sie die folgenden Befehle aus. <br><br><pre><code class="bash hljs">sudo apt-get install libtool libusb-1.0.0-dev librtlsdr-dev rtl-sdr build-essential autoconf cmake pkg-config <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rtl_433/ autoreconf --install ./configure make make install</code> </pre> <br>  Der zweite Schritt besteht darin, ein Programm zu schreiben, das diese Daten empfängt, und abhängig davon die erforderlichen Aktionen auszuführen.  Python-Code ist ziemlich einfach: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os, sys, io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess print(<span class="hljs-string"><span class="hljs-string">"RTLSDR listening started"</span></span>) transmitter_name = <span class="hljs-string"><span class="hljs-string">"Waveman Switch Transmitter"</span></span> transmitter_channel = <span class="hljs-number"><span class="hljs-number">1</span></span> proc = subprocess.Popen([<span class="hljs-string"><span class="hljs-string">"rtl_433 -F json"</span></span>], stdout=subprocess.PIPE, shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: line = proc.stdout.readline().encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>,<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>) proc.poll() data = json.loads(line) print(data) m,st,ch,btn= data[<span class="hljs-string"><span class="hljs-string">'model'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'state'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'channel'</span></span>],data[<span class="hljs-string"><span class="hljs-string">'button'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m==transmitter_name <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ch==transmitter_channel <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> btn==<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> st==<span class="hljs-string"><span class="hljs-string">'on'</span></span>: print(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> m==transmitter_name <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ch==transmitter_channel <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> btn==<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> st==<span class="hljs-string"><span class="hljs-string">'off'</span></span>: print(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> print(<span class="hljs-string"><span class="hljs-string">"RTLSDR listening done"</span></span>)</code> </pre> <br>  Um den Code auszuführen, müssen Sie ihn in einer Datei (z. B. rtl_listen.py) speichern und den Befehl "python rtl_listen.py" ausführen. <br><br>  Wie Sie sehen können, startet das Programm den Prozess mit subprocess.Popen und liest Daten daraus.  Dann ist alles einfach, der Code ist gut lesbar und es wird nicht schwierig sein, Änderungen vorzunehmen.  Wenn in diesem Beispiel die Taste „1“ gedrückt wird, wird der Nachrichtendruck („EIN“) angezeigt. Stattdessen können Sie etwas anderes tun, z. B. den GPIO-Pin aktivieren, das Relais einschalten, Daten an den Server senden usw. Bevor Sie ihn verwenden können, müssen Sie ihn gleichzeitig ändern Name Sendername im Namen des Modells der Konsole, die verwendet werden soll. <br><br>  Übrigens sieht der RTL-SDR-Empfänger selbst im Vergleich zum Raspberry Pi folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/ju/yp/eo/juypeoflpdtecvmhvtjpc4hrx2y.jpeg"><br><br><h2>  Windows </h2><br>  Leider hat der obige Code unter Windows 10 nicht funktioniert.  Wie eine Suche in Github nahe legt, funktioniert das asynchrone Lesen von Daten aus einem separaten Stream.  Warum so, es war zu faul, um herauszufinden, ich werde nur den Arbeitscode unter den Spoiler bringen. <br><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os, sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Queue <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsynchronousFileReader</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(threading.Thread)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Helper class to implement asynchronous reading def __init__(self, fd, queue): assert isinstance(queue, Queue.Queue) assert callable(fd.readline) threading.Thread.__init__(self) self._fd = fd self._queue = queue def run(self): # The body of the tread: read lines and put them on the queue. for line in iter(self._fd.readline, ''): self._queue.put(line) def eof(self): # Check whether there is no more content to expect return not self.is_alive() and self._queue.empty() def replace(string): while ' ' in string: string = string.replace(' ', ' ') return string def read_rtl_data(): process = subprocess.Popen(["rtl_433.exe", "-F", "json"], stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Launch the asynchronous readers of stdout and stderr. stdout_queue = Queue.Queue() stdout_reader = AsynchronousFileReader(process.stdout, stdout_queue) stdout_reader.start() stderr_queue = Queue.Queue() stderr_reader = AsynchronousFileReader(process.stderr, stderr_queue) stderr_reader.start() transmitter_name = "Waveman Switch Transmitter" transmitter_channel = 1 # Check the queues if we received some output while not stdout_reader.eof() or not stderr_reader.eof(): # Show what we received from standard output. while not stdout_queue.empty(): line = stdout_queue.get() print("Line1:", repr(line)) data = json.loads(line) # print("Data:", repr(line)) m,st,ch,btn= data['model'],data['state'],data['channel'],data['button'] if m==transmitter_name and ch==transmitter_channel and btn==1 and st=='on': print("ON") elif m==transmitter_name and ch==transmitter_channel and btn==1 and st=='off': print("OFF") # Show what we received from standard error. while not stderr_queue.empty(): line = replace(stderr_queue.get()) print("Line2:", line) # Sleep a bit before asking the readers again. time.sleep(0.1) stdout_reader.join() stderr_reader.join() # Close subprocess' file descriptors. process.stdout.close() process.stderr.close() if __name__ == '__main__': print("RTLSDR listening started") read_rtl_data() print("RTLSDR listening done")</span></span></code> </pre><br></div></div><br>  Mit diesem Code können wir alle Aktionen im Handler verwenden. Die Logik ist dieselbe wie im Code auf dem Raspberry Pi. <br><br>  <b>Beispiel</b> : Angenommen, wir haben einen Computer für ein Heimkino und möchten ihn durch Drücken der Taste auf der Fernbedienung ausschalten.  Ersetzen Sie den Code 'print ("OFF")' durch <br><br><pre> <code class="python hljs"> os.system(<span class="hljs-string"><span class="hljs-string">'shutdown -s'</span></span>) sys.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Danach schaltet sich der Computer durch Drücken der entsprechenden Taste aus.  Zusätzlich zu "shutdown -s" können Sie natürlich auch jeden anderen Windows-Befehl verwenden. Sie müssen lediglich berücksichtigen, dass die Befehle wiederholt gesendet werden, während die Fernbedienungstaste gedrückt wird. Um solche Duplikate zu vermeiden, müssen Sie den Code verbessern. <br><br><h2>  Fazit </h2><br>  Wie Sie sehen, ist alles ziemlich einfach und es gibt Raum zum Experimentieren.  Zum Schluss noch ein kleiner Bonus für diejenigen, die bis hierher gelesen haben.  Bei 433 MHz gibt es eine große Anzahl verschiedener Geräte, die rtl_433 dekodieren kann. Sie können das Programm einfach mehrere Stunden lang laufen lassen und sehen, was „fängt“.  Unter dem Spoiler ein Beispiel für ein solches Protokoll, das zuvor aufgezeichnet wurde: <br><br><div class="spoiler">  <b class="spoiler_title">Protokoll</b> <div class="spoiler_text"> <code>2018-01-10 21:15:17 : Prologue sensor : 5 : 15 <br> Channel: 1 <br> Battery: OK <br> Button: 0 <br> Temperature: 6.00 C <br> Humidity: 11 % <br> <br> 2018-01-10 21:15:28 : inFactory sensor <br> ID: 71 <br> Temperature: 6.67 °C <br> Humidity: 99 % <br> <br> 2018-01-10 21:16:07 : Toyota : TPMS : 61511475 : 60e5006b : CRC <br> <br> 2018-01-10 21:20:33 : Prologue sensor : 5 : 15 <br> Channel: 1 <br> Battery: OK <br> Button: 0 <br> Temperature: 6.00 C <br> Humidity: 11 % <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: on <br> <br> 2018-01-10 21:21:21 : Akhan 100F14 remote keyless entry <br> ID (20bit): 0x41 <br> Data (4bit): 0x4 (Mute) <br> : Waveman Switch Transmitter <br> id: A <br> channel: 2 <br> button: 1 <br> state: off <br> <br> 2018-01-10 21:32:31 : Ford : TPMS : 00268b1f : a34a0e : CHECKSUM <br> 2018-01-10 21:32:32 : Ford : TPMS : 00268a5c : 9c440e : CHECKSUM <br> 2018-01-10 21:32:37 : Ford : TPMS : 016dbfce : 99430e : CHECKSUM <br> 2018-01-10 21:32:39 : Ford : TPMS : 002671a0 : 9c4a0e : CHECKSUM</code> <br> </div></div><br>  Es gibt interessante Daten, zum Beispiel den Reifendruck des Autos eines Nachbarn (TPMS, Reifendrucküberwachungssystem) oder die Außentemperatur +6 vom Sensor eines anderen.  Dies ermöglicht beispielsweise die Anzeige der Außentemperatur, wenn die Nachbarn versehentlich eine mit diesem Protokoll kompatible Wetterstation haben. <br><br>  Alle erfolgreichen Experimente. <br><br>  <b>Haftungsausschluss</b> : Offensichtlich ist die Verwendung von SDR und digitaler Verarbeitung zum Lesen von OOK-Modulationssignalen im Wesentlichen ein Schuss auf Spatzen.  Vielleicht gibt es bei aliexpress handelsübliche Empfänger für 1 bis 2 US-Dollar, die das Gleiche tun, mit geringeren Kosten und geringerem Stromverbrauch.  Wenn jemand solche Modelle kennt, schreibe in die Kommentare. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414285/">https://habr.com/ru/post/de414285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414273/index.html">Was Sie wissen müssen, bevor Sie einen Backtester für eine Handelsstrategie entwickeln: typische Probleme, Systemtypen und deren Parameter</a></li>
<li><a href="../de414277/index.html">Der Mensch, seine Umwelt und das Internet der Dinge</a></li>
<li><a href="../de414279/index.html">Abstimmung für Berichte beim achten DIY-Meeting in der Mail.Ru Group (07.07.2018)</a></li>
<li><a href="../de414281/index.html">Entwicklung eines Fahrradtachometers basierend auf einem Display des Nokia 3310</a></li>
<li><a href="../de414283/index.html">Unterscheiden von Kryptowährung von Nicht-Kryptowährung</a></li>
<li><a href="../de414289/index.html">SpaceX hat eine Stelle als Raketeningenieur für die Erstellung eines BFR eröffnet</a></li>
<li><a href="../de414293/index.html">Das dritte jährliche ReactOS Hackfest findet vom 14. bis 21. August 2018 in Berlin statt</a></li>
<li><a href="../de414295/index.html">"Es war möglich": ungewöhnliche, aber effektive Möglichkeiten, "Audio" -Technologien einzusetzen</a></li>
<li><a href="../de414299/index.html">Aktualisieren Sie den Roomba 780</a></li>
<li><a href="../de414303/index.html">Großbritannien gibt 6 Millionen Pfund für Datenwissenschaftler aus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>