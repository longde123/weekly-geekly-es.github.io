<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº üßóüèª üë¢ Comment enseigner √† un r√©seau de neurones √† reproduire la physique des jeux üôÖüèº üö¥üèø üèÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans presque tous les jeux informatiques modernes, la pr√©sence d'un moteur physique est une condition pr√©alable. Drapeaux et lapins flottant au vent, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment enseigner √† un r√©seau de neurones √† reproduire la physique des jeux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/479292/"> Dans presque tous les jeux informatiques modernes, la pr√©sence d'un moteur physique est une condition pr√©alable.  Drapeaux et lapins flottant au vent, bombard√©s de balles - tout cela n√©cessite une bonne ex√©cution.  Et, bien s√ªr, m√™me si tous les h√©ros ne portent pas d'imperm√©ables ... mais ceux qui portent ont vraiment besoin d'une simulation ad√©quate de tissu flottant. <br><br><img src="https://habrastorage.org/webt/5-/tq/jb/5-tqjb5ugkqhg77mf9vr1lfzz9o.png"><br><br>  N√©anmoins, la mod√©lisation physique compl√®te de telles interactions devient souvent impossible, car elle est beaucoup plus lente que n√©cessaire pour les jeux en temps r√©el.  Cet article propose une nouvelle m√©thode de mod√©lisation qui peut acc√©l√©rer les simulations physiques, les rendre 300 √† 5000 fois plus rapides.  Son but est d'essayer d'enseigner √† un r√©seau neuronal de simuler des forces physiques. <br><a name="habracut"></a><br>  Les progr√®s dans le d√©veloppement de moteurs physiques sont d√©termin√©s √† la fois par la puissance de calcul croissante des √©quipements techniques et par le d√©veloppement de m√©thodes de mod√©lisation rapides et stables.  Ces m√©thodes incluent, par exemple, la mod√©lisation en d√©coupant l'espace en sous-espaces et les approches bas√©es sur les donn√©es - c'est-√†-dire bas√©es sur les donn√©es.  Les premiers ne fonctionnent que dans un sous-espace r√©duit ou comprim√©, o√π seules quelques formes de d√©formations sont prises en compte.  Pour les grands projets, cela peut entra√Æner une augmentation significative des exigences techniques.  Les approches bas√©es sur les donn√©es utilisent la m√©moire du syst√®me et les donn√©es pr√©calcul√©es qui y sont stock√©es, ce qui r√©duit ces exigences. <br><br>  Nous examinons ici une approche qui combine les deux m√©thodes: de cette mani√®re, elle vise √† capitaliser sur les forces des deux.  Une telle m√©thode peut √™tre interpr√©t√©e de deux mani√®res: soit comme une m√©thode de mod√©lisation sous-espace param√©tr√©e par un r√©seau de neurones, soit comme une m√©thode DD bas√©e sur la mod√©lisation sous-spatiale pour construire un support simul√© compress√©. <br><br>  Son essence est la suivante: nous collectons d'abord des donn√©es de simulation de haute pr√©cision √† l'aide de <abbr title="Maya nCloth - bo√Æte √† outils int√©gr√©e pour cr√©er des images graphiques tr√®s r√©alistes Autodesk Maya, qui vous permet de cr√©er un tissu r√©aliste et d'autres mat√©riaux d√©formables.">Maya nCloth</abbr> , puis nous calculons le sous-espace lin√©aire en utilisant <abbr title="L'analyse en composantes principales (ACP) est l'un des principaux moyens de r√©duire la dimensionnalit√© des donn√©es, tout en perdant le moins d'informations. D'un point de vue math√©matique, cette m√©thode est une transformation lin√©aire orthogonale qui mappe les donn√©es de l'espace d'entit√© d'origine vers un nouvel espace de dimension inf√©rieure. Dans ce cas, le premier axe du nouveau syst√®me de coordonn√©es est construit de mani√®re √† ce que la dispersion des donn√©es le long de celui-ci soit maximale. Le deuxi√®me axe est construit orthogonalement au premier de sorte que la variance des donn√©es le long de celui-ci soit √©galement le maximum du reste possible, et ainsi de suite. Ainsi, le sens de la m√©thode r√©side dans le fait que chaque composante principale est associ√©e √† une certaine fraction de la variance totale de l'ensemble de donn√©es d'origine. √Ä son tour, la variance, qui est une mesure de la variabilit√© des donn√©es, peut refl√©ter le niveau de leur contenu d'information.">la m√©thode des composants principaux (PCA)</abbr> .  Dans l'√©tape suivante, nous utilisons l'apprentissage automatique bas√© sur le mod√®le de r√©seau de neurones classique et notre nouvelle m√©thodologie, apr√®s quoi nous introduisons le mod√®le entra√Æn√© dans un algorithme interactif avec plusieurs optimisations, comme un algorithme de d√©compression efficace par un GPU et une m√©thode pour approximer les normales des sommets. <br><br><img src="https://habrastorage.org/webt/6n/_a/1u/6n_a1urmdl9_nqjackk2iwmvuag.png"><br>  <i>Figure 1. Le sch√©ma structurel de la m√©thode</i> <br><br><h3>  Donn√©es d'entra√Ænement </h3><br>  De mani√®re g√©n√©rale, la seule entr√©e pour cette m√©thode est les horodatages bruts des positions image par image des sommets de l'objet.  Ensuite, nous d√©crivons le processus de collecte de ces donn√©es. <br><br>  Nous effectuons la simulation dans Maya nCloth, capturant des donn√©es √† une vitesse de 60 images par seconde, avec 5 ou 20 sous-√©tapes et 10 ou 25 it√©rations limites, selon la stabilit√© de la simulation.  Pour les tissus, prenez un mod√®le de T-shirt avec une l√©g√®re augmentation du poids du mat√©riau et de sa r√©sistance √† l'√©tirement, et pour les objets d√©formables, du caoutchouc dur √† frottement r√©duit.  Nous effectuons des collisions externes en heurtant des triangles de g√©om√©trie externe, des auto-collisions - des sommets avec des sommets pour le tissu et des triangles avec des triangles pour le caoutchouc.  Dans tous les cas, nous utilisons une √©paisseur de collision assez importante - de l'ordre de 5 cm - pour assurer la stabilit√© du mod√®le et √©viter les pincements et d√©chirures du tissu. <br><br>  <i>Tableau 1. Param√®tres des objets mod√©lis√©s</i> <br><img src="https://habrastorage.org/webt/dw/ag/tf/dwagtfbbptnhiioq-2gutci9ung.png"><br><br>  Pour diff√©rents types d'interaction d'objets simples (par exemple, des sph√®res), nous g√©n√©rerons leur mouvement de mani√®re al√©atoire en recadrant des coordonn√©es al√©atoires √† des moments al√©atoires.  Pour simuler l'interaction des tissus avec un personnage, nous utilisons une base de donn√©es de capture de mouvement de 6,5 √ó 10 <sup>5</sup> images, qui sont une grande animation.  Une fois la simulation termin√©e, nous v√©rifions le r√©sultat et excluons les trames pr√©sentant un comportement instable ou m√©diocre.  Pour la sc√®ne avec la jupe, on retire les mains du personnage, car elles se croisent souvent avec la g√©om√©trie du maillage des jambes et sont d√©sormais insignifiantes. <br><br><img src="https://habrastorage.org/webt/0r/aa/ug/0raaugw5jdlmj9aqrzac7uj14-e.gif"><br>  <i>Figure 2. Les deux premi√®res sc√®nes du tableau</i> <br><br>  Habituellement, nous avons besoin de 10 <sup>5</sup> -10 <sup>6</sup> images de donn√©es d'entra√Ænement.  D'apr√®s notre exp√©rience, dans la plupart des cas, 10 <sup>5</sup> images suffisent pour les tests, tandis que les meilleurs r√©sultats sont obtenus avec 10 <sup>6</sup> images. <br><br><h3>  La formation </h3><br>  Ensuite, nous parlerons du processus d'apprentissage automatique: du param√©trage dans notre r√©seau de neurones, de l'architecture du r√©seau et directement de la technique elle-m√™me. <br><br><h4>  Param√©trisation </h4><br>  Afin d'obtenir un ensemble de donn√©es d'apprentissage, nous collectons les coordonn√©es des sommets de chaque image <i>t</i> dans un vecteur <i>x <sub>t</sub></i> , puis combinons ces vecteurs image par image dans une grande matrice X. Cette matrice d√©crit les √©tats de l'objet mod√©lis√©.  De plus, il faut avoir une id√©e de l'√©tat des objets externes dans chaque trame.  Pour les objets simples (tels que les balles), vous pouvez utiliser leurs coordonn√©es tridimensionnelles, tandis que l'√©tat des mod√®les complexes (personnage) est d√©crit par la position de chaque articulation par rapport au point de r√©f√©rence: dans le cas d'une jupe, un tel support sera l'articulation de la hanche, dans le cas d'une cape - le cou.  Pour les objets avec un syst√®me de r√©f√©rence en mouvement, la position de la Terre par rapport √† elle doit √™tre prise en compte: alors notre syst√®me conna√Ætra la direction de la gravit√©, ainsi que sa vitesse lin√©aire, son acc√©l√©ration, sa vitesse de rotation et son acc√©l√©ration de rotation.  Pour le drapeau, nous prendrons en compte la vitesse et la direction du vent.  En cons√©quence, pour chaque objet, nous obtenons un grand vecteur qui d√©crit l'√©tat de l'objet externe, et tous ces vecteurs sont √©galement combin√©s dans la matrice Y. <br><br>  Maintenant, nous appliquons l'ACP √† la matrice X et Y, et utilisons les matrices de transformation r√©sultantes Z et W pour construire l'image du sous-espace.  Si la proc√©dure PCA n√©cessite trop de m√©moire, √©chantillonnez d'abord nos donn√©es. <br><br>  La compression PCA entra√Æne in√©vitablement une perte de d√©tails, en particulier pour les objets pr√©sentant de nombreuses conditions potentielles, tels que des plis fins de tissu.  Cependant, si le sous-espace se compose de 256 vecteurs de base, cela aide g√©n√©ralement √† pr√©server la plupart des d√©tails.  Vous trouverez ci-dessous des animations de la physique standard de la cape et des mod√®les avec 256, 128 et 64 vecteurs de base, respectivement. <br><br><img src="https://habrastorage.org/webt/yt/gg/7a/ytgg7aiprksj0qtezlvbpy2qcs4.gif"><br>  <i>Figure 3. Comparaison du mod√®le de contr√¥le (standard) avec les mod√®les obtenus par notre m√©thode dans des espaces avec des bases de dimensions diff√©rentes</i> <br><br><h4>  Source et mod√®le √©tendu </h4><br>  Il √©tait n√©cessaire de d√©velopper un mod√®le qui pourrait pr√©dire l'√©tat des vecteurs du mod√®le dans les futures trames.  Et comme les objets mod√©lis√©s sont g√©n√©ralement caract√©ris√©s par une inertie ayant tendance √† un certain √©tat de repos moyen (apr√®s la proc√©dure PCA, l'objet prend un tel √©tat √† des valeurs nulles), un bon mod√®le initial serait l'expression repr√©sent√©e par la ligne 9 de l'algorithme de la figure 4. Ici, Œ± et Œ≤ sont les param√®tres du mod√®le, ‚äô est un produit √©clat√©.  Les valeurs de ces param√®tres seront obtenues √† partir des donn√©es sources en r√©solvant individuellement l' <abbr title="La m√©thode des moindres carr√©s est une m√©thode math√©matique utilis√©e pour r√©soudre divers probl√®mes, bas√©e sur la minimisation de la somme des √©carts au carr√© de certaines fonctions par rapport aux variables souhait√©es.">√©quation des moindres carr√©s lin√©aires</abbr> pour Œ± et Œ≤: <br><br><img src="https://habrastorage.org/webt/4g/ml/d1/4gmld1lrufdu-hdusjpuerfmb6w.png"><br><br>  Voici ‚Ä† la <abbr title="A + est appel√©e matrice pseudo-inverse pour une matrice A si elle satisfait aux crit√®res suivants: A A + A = A; A + A A + = A +; (A A +) * = A A +; (A + A) * = A + A.">transformation pseudoinverse de la matrice</abbr> . <br><br>  √âtant donn√© qu'une telle pr√©diction n'est qu'une approximation tr√®s approximative et ne prend pas en compte l'influence des objets externes w, elle ne sera √©videmment pas en mesure de mod√©liser avec pr√©cision les donn√©es d'apprentissage.  Par cons√©quent, nous formons le r√©seau neuronal Œ¶ d'approximation des effets r√©siduels du mod√®le conform√©ment √† la 11e ligne de l'algorithme.  Ici, nous param√©trons un <abbr title="Le r√©seau neuronal √† action directe est un r√©seau neuronal dans lequel un signal se propage strictement de la couche d'entr√©e √† la couche de sortie et ne se propage pas dans la direction oppos√©e.">r√©seau de neurones √† distribution directe</abbr> standard avec 10 couches, pour chaque couche (sauf la sortie) en utilisant la fonction d'activation <abbr title="La fonction d'activation d√©termine la valeur de sortie d'un neurone en fonction du r√©sultat d'une somme pond√©r√©e d'entr√©es et d'une valeur de seuil. La fonction d'activation ReLu renvoie x si x est positif et 0 sinon.">ReLU</abbr> .  En excluant les couches d'entr√©e et de sortie, nous avons d√©fini le nombre d'unit√©s cach√©es sur chaque couche restante √©gal √† une fois et demie la taille des donn√©es PCA, ce qui a conduit √† un bon compromis entre l'espace occup√© sur le disque dur et les performances. <br><br><img src="https://habrastorage.org/webt/re/7_/ii/re7_iisbng_s83ibdfmcn32idf8.png"><br>  <i>Figure 4. Algorithme d'apprentissage du r√©seau neuronal</i> <br><br><h3>  Formation au r√©seau de neurones </h3><br>  Une fa√ßon standard de former un r√©seau de neurones serait d'it√©rer sur l'ensemble des donn√©es et d'entra√Æner le r√©seau √† faire des pr√©dictions pour chaque trame.  Bien s√ªr, une telle approche entra√Ænera une faible erreur d'apprentissage, mais le retour dans une telle pr√©diction entra√Ænera un comportement instable de son r√©sultat.  Par cons√©quent, pour assurer une pr√©diction stable √† long terme, notre algorithme utilise la <abbr title="La propagation en arri√®re de l'erreur est un moyen de former un r√©seau neuronal. La formation avec cet algorithme implique deux passages √† travers toutes les couches du r√©seau: direct et inverse. Avec un passage direct, le vecteur d'entr√©e est envoy√© √† la couche d'entr√©e du r√©seau neuronal, apr√®s quoi il se propage √† travers le r√©seau d'une couche √† l'autre. En cons√©quence, un ensemble de signaux de sortie est g√©n√©r√©, qui est la r√©ponse r√©elle du r√©seau √† une image d'entr√©e donn√©e. Lors d'un passage direct, tous les poids nets synaptiques sont fixes. Au cours de l'inverse, ils sont configur√©s conform√©ment √† la r√®gle de correction d'erreurs: la sortie r√©elle du r√©seau est soustraite de la souhait√©e, √† la suite de quoi un signal d'erreur est g√©n√©r√©. Ce signal se propage ensuite √† travers le r√©seau dans la direction oppos√©e √† la direction des connexions synaptiques. Les poids synaptiques sont ajust√©s pour maximiser la sortie du r√©seau au niveau souhait√©.">m√©thode de r√©tro-propagation des erreurs</abbr> tout au long de la proc√©dure d'int√©gration. <br><br>  En g√©n√©ral, cela fonctionne comme ceci: √† partir d'une petite fen√™tre de donn√©es d'apprentissage <i>z</i> et <i>w,</i> nous prenons les deux premi√®res images <i>z <sub>0</sub></i> et <i>z <sub>1</sub></i> et leur ajoutons un peu de bruit <i>r <sub>0</sub></i> , <i>r <sub>1</sub></i> , afin de perturber l√©g√®rement le parcours d'apprentissage.  Ensuite, pour pr√©dire les trames suivantes, nous ex√©cutons l'algorithme plusieurs fois, en revenant aux r√©sultats pr√©c√©dents des pr√©dictions √† chaque nouveau pas de temps.  D√®s que nous obtenons une pr√©diction de la trajectoire enti√®re, nous calculons l'erreur de coordonn√©es moyenne, puis la transmettons √† l'optimiseur AmsGrad en utilisant les d√©riv√©es automatiques calcul√©es √† l'aide de TensorFlow. <br><br>  Nous allons r√©p√©ter cet algorithme sur des mini-√©chantillons de 16 images, en utilisant des fen√™tres superpos√©es de 32 images, pendant 100 √©poques ou jusqu'√† ce que la formation converge.  Nous utilisons le taux d'apprentissage de 0,0001, le coefficient d'att√©nuation du taux d'apprentissage de 0,999 et l'√©cart-type du bruit calcul√© √† partir des trois premi√®res composantes de l'espace PCA.  Cette formation dure de 10 √† 48 heures, selon la complexit√© de l'installation et la taille des donn√©es PCA. <br><br><img src="https://habrastorage.org/webt/k4/fe/in/k4feinopgrygcqm6p3dkrjk1pcu.gif"><br>  <i>Figure 5. Comparaison visuelle de la jupe de r√©f√©rence et de celle que notre r√©seau de neurones a appris √† construire</i> <br><br><h3>  Impl√©mentation du syst√®me </h3><br>  Nous d√©crirons en d√©tail la mise en ≈ìuvre de notre m√©thode dans un environnement interactif, y compris l'√©valuation d'un r√©seau de neurones, le calcul des normales aux surfaces des objets pour le rendu, et comment nous traitons les intersections visibles. <br><br><h4>  Application de rendu </h4><br>  Nous rendons les mod√®les r√©sultants dans une simple application 3D interactive √©crite en C ++ et DirectX: nous impl√©mentons √† nouveau les pr√©-processus et les op√©rations du r√©seau neuronal en code C ++ monothread et chargeons les poids de r√©seau binaires obtenus lors de notre formation.  Ensuite, nous appliquons quelques optimisations simples pour l'estimation de r√©seau, en particulier, la r√©utilisation de tampons de m√©moire et de donn√©es matricielles √©parses, ce qui devient possible gr√¢ce √† la pr√©sence de z√©ro unit√©s cach√©es obtenues gr√¢ce √† la fonction d'activation ReLU. <br><br><h4>  D√©compression GPU </h4><br>  Envoyez des donn√©es d'√©tat z compress√©es au GPU et d√©compressez-les pour un rendu suppl√©mentaire.  √Ä cette fin, nous utilisons un shader de calcul simple, qui calcule pour chaque sommet de l'objet le produit ponctuel du vecteur z et les trois premi√®res lignes de la matrice U <sup>T</sup> correspondant aux coordonn√©es de ce sommet, apr√®s quoi nous ajoutons la valeur moyenne <i>x <sub>¬µ</sub></i> .  Cette approche pr√©sente deux avantages par rapport √† la <abbr title="La m√©thode na√Øve est une m√©thode probabiliste simple bas√©e sur l'application du th√©or√®me de Bayes avec des hypoth√®ses strictes (na√Øves) sur l'ind√©pendance. Selon la nature exacte du mod√®le probabiliste, les classificateurs bay√©siens na√Øfs peuvent √™tre form√©s tr√®s efficacement. Dans de nombreuses applications pratiques, la m√©thode du maximum de vraisemblance est utilis√©e pour estimer les param√®tres des mod√®les bay√©siens na√Øfs.">m√©thode de</abbr> d√©compression <abbr title="La m√©thode na√Øve est une m√©thode probabiliste simple bas√©e sur l'application du th√©or√®me de Bayes avec des hypoth√®ses strictes (na√Øves) sur l'ind√©pendance. Selon la nature exacte du mod√®le probabiliste, les classificateurs bay√©siens na√Øfs peuvent √™tre form√©s tr√®s efficacement. Dans de nombreuses applications pratiques, la m√©thode du maximum de vraisemblance est utilis√©e pour estimer les param√®tres des mod√®les bay√©siens na√Øfs.">na√Øve</abbr> .  Premi√®rement, le parall√©lisme du GPU acc√©l√®re consid√©rablement le calcul du vecteur d'√©tat du mod√®le, ce qui peut prendre jusqu'√† 1 ms.  Deuxi√®mement, il r√©duit le temps de transfert de donn√©es entre le central et le GPU d'un ordre de grandeur, ce qui est particuli√®rement important pour les plates-formes sur lesquelles le transfert de l'√©tat entier de l'objet entier est trop lent. <br><br><h4>  Vertex Normal Prediction </h4><br>  Pendant le rendu, il ne suffit pas d'avoir acc√®s uniquement aux coordonn√©es des sommets - des informations sur les d√©formations de leurs normales sont √©galement n√©cessaires.  Habituellement, dans un moteur physique, omettez ce calcul ou effectuez un recalcul na√Øf image par image des normales avec leur redistribution ult√©rieure aux sommets voisins.  Cela peut s'av√©rer inefficace, car la mise en ≈ìuvre de base du processeur central, en plus des co√ªts de d√©compression et de transfert de donn√©es, n√©cessite encore 150 Œºs pour une telle proc√©dure.  Et bien que ce calcul puisse √™tre effectu√© sur le GPU, il s'av√®re plus difficile √† mettre en ≈ìuvre en raison de la n√©cessit√© d'op√©rations parall√®les. <br><br>  Au lieu de cela, nous effectuons une r√©gression lin√©aire de l'√©tat du sous-espace vers des vecteurs normaux √† l'√©tat complet sur le shader GPU.  Connaissant les valeurs des normales des sommets dans chaque trame, nous calculons la matrice Q, qui repr√©sente le mieux la repr√©sentation du sous-espace sur les normales des sommets. <br><br>  √âtant donn√© que la pr√©diction des normales dans notre m√©thode n'a jamais √©t√© pr√©sent√©e auparavant, il n'y a aucune garantie que cette approche sera exacte, mais en pratique, elle s'est av√©r√©e tr√®s bonne, comme le montre la figure ci-dessous. <br><br><img src="https://habrastorage.org/webt/ex/mn/ef/exmnefvyrkox7j-mcl7brp2vyog.png"><br>  <i>Figure 6. Comparaison des mod√®les calcul√©s par notre m√©thode et de la r√©f√©rence (v√©rit√© terrain), ainsi que la diff√©rence entre eux</i> <br><br><h4>  Combat d'intersection </h4><br>  Notre r√©seau de neurones apprend √† effectuer efficacement des collisions, cependant, en raison d'inexactitudes dans les pr√©dictions et d'erreurs caus√©es par la compression du sous-espace, des intersections peuvent se produire entre des objets externes et des objets simul√©s.  De plus, comme nous reportons le calcul de l'√©tat complet de la sc√®ne jusqu'au tout d√©but du rendu, il n'y a aucun moyen de r√©soudre efficacement ces probl√®mes √† l'avance.  Par cons√©quent, pour maintenir des performances √©lev√©es, l'√©limination de ces intersections est n√©cessaire lors du rendu. <br><br>  Nous avons trouv√© une solution simple et efficace √† cela, consistant dans le fait que des sommets se croisant sont projet√©s sur la surface des primitives dont nous constituons le personnage.  Cette projection est facile √† faire sur le GPU en utilisant le m√™me shader de calcul qui d√©compresse le tissu et calcule l'ombrage normal. <br><br>  Donc, tout d'abord, nous allons composer le personnage √† partir des objets proxy connect√©s aux sommets avec diff√©rents rayons initiaux et finaux, apr√®s quoi nous transf√©rerons des informations sur les coordonn√©es et les rayons de ces objets au shader de calcul.  Encore une fois, v√©rifiez les coordonn√©es de chaque sommet pour l'intersection avec l'objet proxy correspondant et, si c'est le cas, projetez ce sommet sur la surface de l'objet proxy.  On ne corrige donc que la position du sommet, sans toucher √† la normale elle-m√™me, afin de ne pas endommager l'ombrage. <br><br>  Cette approche supprimera les petites intersections visibles d'objets, √† condition que les erreurs de d√©placement du sommet ne soient pas si importantes que la projection se trouve du c√¥t√© oppos√© de l'objet proxy correspondant. <br><br><img src="https://habrastorage.org/webt/ef/9q/al/ef9qal2u48v_kwy6q8pqdspe9qi.png"><br>  <i>Figure 7. Mod√®le de caract√®res compos√© d'objets proxy et r√©sultats de l'√©limination des intersections visibles √† l'aide de notre m√©thode: avant et apr√®s</i> <br><br><h3>  Analyse des r√©sultats </h3><br>  Ainsi, nos sc√®nes de test incluent: <br><br><ul><li> ,     ; </li><li> ,    ,    ; </li><li> ,   ; </li><li>      ,  ; </li><li> ,    ; </li><li> ,    . </li></ul><br>        ,   . <br><br>    -         16 ,         120  240   . <br><br><img src="https://habrastorage.org/webt/m8/ls/dz/m8lsdz-6i0bgaghswhtf8luequg.gif"><br> <i> 8.   16 . Party time!</i> <br><br><h4>    </h4><br> ,       , ,        ,       . <br><br>   ,          PCA.   ,        ,             ,   . <br><br><img src="https://habrastorage.org/webt/0o/mb/js/0ombjsge3myljg4b2ieuzr0seic.png"><br> <i> 9.   ,    ,  ‚Äì </i> <br><br><h4>  Ex√©cution </h4><br>          ‚Äï     ,     .         ,     .        300-5000      ,   .           ,   <abbr title=" -   ‚Äî       ,       (Projective Dynamics)       ."> -   (HRPD)</abbr> , <abbr title="   (Long short-term memory) ‚Äî      ,     .      ,                 .  LSTM      ,   (gates) ¬´¬ª.">   (LSTM)</abbr>  <abbr title="    ‚Äî    LSTM-.            ¬´ ¬ª (update gate).  ,       .       ,   LSTM-.">   (GRU)</abbr> . <br><br>      ,          .        Intel Xeon E5-1650 3.5 GHz    GeForce GTX 1080 Titan. <br><br> <i> 2.    </i> <br><img src="https://habrastorage.org/webt/io/ax/rw/ioaxrwaeedpn506pzo7sv857as4.png"><br><br><h3>      </h3><br> ,         ,   .      ,                  . <br><br>    data-driven ,     . ,   ,         ,           ,    ,       .  ,      ,        ‚Äï ,       . <br><br>     ,      ,         ,         . <br><br>         ,      .      data-driven ,     ‚Äï ,       .        ,   ,    ,      .        , ,            ,       . <br><br>       ,         .        . <br><br>       , , ,      .   ,   , ‚Äï    ,       . -,         ,   ,    -      .                . <br><br> ,       ,       ,     ,     .    ,     ,      ,      , ‚Äï         ,       ,     .        . <br><br>        <a href="https://www.youtube.com/watch%3Fv%3DatcKO15YVD8"></a> . <br><br><img src="https://habrastorage.org/webt/1i/hx/uf/1ihxuf4flcfzfps0xuw6sk9p8ts.gif"><br> <i> 10.  vs : choose your fighter</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479292/">https://habr.com/ru/post/fr479292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479282/index.html">Si les donn√©es ne tiennent pas en m√©moire. M√©thodes les plus simples</a></li>
<li><a href="../fr479284/index.html">La maison que le robot a construite</a></li>
<li><a href="../fr479286/index.html">√âcriture d'une application Web simple √† l'aide de Spring MVC, Spring Data JPA et Hibernate</a></li>
<li><a href="../fr479288/index.html">Pourquoi impl√©menter Service Desk et comment choisir une solution pour votre entreprise</a></li>
<li><a href="../fr479290/index.html">Algorithmes de recherche du volume et du centre de masse d'un poly√®dre</a></li>
<li><a href="../fr479294/index.html">Sortie de GitLab 12.5 avec la cr√©ation de clusters EKS et le panneau environnement</a></li>
<li><a href="../fr479296/index.html">Comment j'ai arr√™t√© de ha√Ør et suis tomb√© amoureux du d√©veloppement</a></li>
<li><a href="../fr479298/index.html">Antipatterns PostgreSQL: CTE x CTE</a></li>
<li><a href="../fr479300/index.html">√âcologie et centres de donn√©es. Comme en Russie et √† l'√©tranger, les ¬´donn√©es vertes¬ª</a></li>
<li><a href="../fr479302/index.html">Unity Shader Graph Basics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>