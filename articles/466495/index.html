<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéæ üõ∑ ü§õüèæ C√≥mo no equivocarse con la competencia en Go ‚ñ´Ô∏è üë®üèæ‚Äç‚öïÔ∏è üòÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øPor qu√© incluso queremos escribir c√≥digo competitivo? Porque los procesadores dejaron de crecer a lo largo de las inmersiones y comenzaron a crecer a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo no equivocarse con la competencia en Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/466495/"><p>  ¬øPor qu√© incluso queremos escribir c√≥digo competitivo?  Porque los procesadores dejaron de crecer a lo largo de las inmersiones y comenzaron a crecer a lo largo de los n√∫cleos.  La cantidad de n√∫cleos de procesador aumenta cada a√±o, y queremos utilizarlos de manera efectiva.  Ir es el lenguaje creado para esto.  La documentaci√≥n lo dice. </p><br><p> Tomamos Go, comenzamos a escribir c√≥digo competitivo.  Por supuesto, esperamos que podamos frenar f√°cilmente la potencia de cada n√∫cleo de nuestro procesador.  Es asi? </p><br><p>  <em>Me llamo Artemy.</em>  <em>Esta publicaci√≥n es una transcripci√≥n gratuita de mi charla con GopherCon Rusia.</em>  <em>Apareci√≥ como un intento de dar impulso a las personas que quieren descubrir c√≥mo escribir un c√≥digo bueno y competitivo.</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4U3EaVufuW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Video de la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GopherCon Rusia</a></em> </p><a name="habracut"></a><br><h1 id="modeli-vzaimodeystviya">  Modelos de interacci√≥n </h1><br><p>  Para comprender si Go realmente nos lo facilita, veamos dos modelos de interacci√≥n: <strong>Memoria compartida</strong> y <strong>Transmisi√≥n de mensajes</strong> . </p><br><p><img src="https://habrastorage.org/webt/xv/09/f1/xv09f1rq3eum5hnsuwdqdgrj97m.png"></p><br><ul><li><p>  <strong>La memoria compartida</strong> se trata de la memoria compartida que utilizan varios subprocesos para intercambiar datos.  El acceso a la memoria debe estar sincronizado.  Esta sincronizaci√≥n generalmente se implementa mediante alg√∫n tipo de bloqueos.  Este enfoque se considera comunicaci√≥n impl√≠cita. </p><br></li><li><p>  <strong>El paso de mensajes</strong> dice que interactuaremos expl√≠citamente, y para esto utilizaremos los canales en los que enviaremos mensajes.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CSP</a> ( <em>procesos secuenciales de comunicaci√≥n</em> ) y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo de actor</a> se basan en este enfoque. </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/wi/ss/jr/wissjrv4uu2-3ng62qsdtjbunbk.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rob Pike</a> , quien es el padre fundador de Go, dice que debe abandonar la programaci√≥n de bajo nivel utilizando la <strong>memoria compartida</strong> y utilizar el enfoque de <strong>paso de mensajes</strong> .  Este enfoque lo ayudar√° a escribir c√≥digo de manera m√°s f√°cil, m√°s eficiente y, lo m√°s importante, con menos errores.  Go elige el enfoque <strong>CSP</strong> .  El mismo enfoque influy√≥ mucho en el desarrollo de un lenguaje como Erlang. </p><br><p>  Pregunta: ¬øEs cierto que si tomamos Go, todo estar√° bien? </p><br><p><img src="https://habrastorage.org/webt/ld/uc/px/lducpx4ezb14rvygaamxzz0_-vy.png"></p><br><p>  Me encontr√© con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estudio</a> en el que se encontr√≥ esta tableta.  La tableta muestra los motivos y la cantidad de errores relacionados con las cerraduras.  La primera columna muestra los productos que se tomaron en el estudio.  Estos son los productos m√°s populares escritos en Go.  La columna Memoria compartida muestra el n√∫mero de errores que surgen debido al uso incorrecto de la Memoria compartida, y la columna Paso de mensaje, respectivamente, muestra el n√∫mero de errores debido al Paso de mensaje. </p><br><p>  Lo m√°s importante en este plato es la l√≠nea <strong>Total</strong> .  Si lo mira, notar√° que hay m√°s errores al usar <strong>Pasar mensajes</strong> que al usar <strong>Memoria compartida</strong> .  Estoy seguro de que las personas que escriben Kubernetes, Docker o etcd son desarrolladores bastante experimentados, pero incluso su <strong>Pase de mensajes</strong> no se salva de errores, y no hay menos que estos errores que con la Memoria compartida. </p><br><p>  Por lo tanto, tomar Go y comenzar a escribir c√≥digo sin errores fallar√°. </p><br><h1 id="concurrency-i-parallelism">  Concurrencia y paralelismo </h1><br><p>  Cuando comenzamos a hablar sobre el desarrollo de subprocesos m√∫ltiples, necesitamos introducir conceptos como <strong>Concurrencia</strong> y <strong>Paralelismo</strong> .  En el mundo de Go, existe la expresi√≥n <em>"La concurrencia no es paralelismo"</em> .  La conclusi√≥n es que la <strong>concurrencia</strong> se trata de dise√±o, es decir, c√≥mo dise√±amos nuestro programa.  <strong>El paralelismo</strong> es solo una forma de ejecutar nuestro c√≥digo. </p><br><p><img src="https://habrastorage.org/webt/uk/tr/es/uktresizsgqpphu4mkmjlep00fe.png"></p><br><p>  Si tenemos varios hilos de instrucciones que se ejecutan simult√°neamente, entonces ejecutamos el c√≥digo en paralelo.  El paralelismo requiere competencia.  No ser√° posible paralelizar un programa sin un dise√±o competitivo, mientras que la competitividad no requiere paralelismo, porque un programa que puede funcionar en muchos n√∫cleos, de hecho, puede funcionar en un n√∫cleo. </p><br><p>  Go es un lenguaje que nos ayuda a escribir programas competitivos, nos ayuda a construir dise√±o.  Le permite pensar un poco menos sobre cosas de bajo nivel. </p><br><h1 id="zakon-amdala">  Ley de Amdahl </h1><br><p>  Queremos utilizar los n√∫cleos del procesador, escribimos un c√≥digo para esto.  Pero surge la pregunta: qu√© tipo de aumento en la productividad obtenemos con un aumento en el n√∫mero de n√∫cleos.  Entonces, la aceleraci√≥n que podemos obtener est√°, de hecho, limitada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por la ley de Amdal</a> . </p><br><p><img src="https://habrastorage.org/webt/dz/cc/bu/dzccbu8elu2vaogt54-u_gg4m4w.png"></p><br><p>  ¬øQu√© es la aceleraci√≥n?  La aceleraci√≥n es el tiempo que un programa se ejecuta en un √∫nico procesador dividido por el tiempo que un programa se ejecuta en procesadores <strong>P.</strong>  La letra <strong>F</strong> ( <em>Fracci√≥n</em> ) denota la parte del programa que debe ejecutarse secuencialmente.  Y aqu√≠ ni siquiera es necesario profundizar en la f√≥rmula, lo principal es tener en cuenta que la aceleraci√≥n m√°xima que obtenemos con un aumento en el n√∫mero de n√∫cleos depende de <strong>F.</strong>  Echa un vistazo a la gr√°fica para visualizar esta relaci√≥n. </p><br><p><img src="https://habrastorage.org/webt/uw/c7/bn/uwc7bn5ngru2scvqaphzayuvboc.png"></p><br><p>  Incluso si solo tenemos el 5% del programa que se ejecutar√° secuencialmente, la aceleraci√≥n m√°xima que obtenemos disminuir√° considerablemente con un aumento en el n√∫mero de n√∫cleos.  Puedes estimar cu√°les son las partes que aumentan <strong>F.</strong> </p><br><p><img src="https://habrastorage.org/webt/4o/pu/a8/4opua82_adysln9-enejf9-m-iu.png"></p><br><h1 id="cpu-bound-vs-io-bound">  CPU enlazada vs E / S enlazada </h1><br><p>  No siempre tiene sentido usar subprocesos m√∫ltiples.  Primero debes mirar el tipo de carga.  Hay dos tipos de carga: <strong>CPU Bound</strong> y <strong>I / O Bound</strong> .  La diferencia es que con CPU Bound estamos limitados por el rendimiento del procesador, y con I / O Bound estamos limitados por la velocidad de nuestro subsistema de E / S.  Ni siquiera la velocidad, sino el tiempo de espera de una respuesta.  Conectarse en l√≠nea, esperando una respuesta, yendo al disco, nuevamente esperando una respuesta.  ¬øCu√°l es la diferencia, cu√°ntos n√∫cleos hay, si la mayor√≠a de las veces esperamos una respuesta? </p><br><p><img src="https://habrastorage.org/webt/xp/dk/yl/xpdkylyp6etnvk2qlw0txhjktby.png"></p><br><p>  Por lo tanto, un n√∫cleo o mil, no obtendremos un aumento en el rendimiento bajo la carga limitada de E / S.  Pero si tenemos una carga CPU Bound, entonces existe la posibilidad de acelerar cuando paralelizamos nuestro programa. </p><br><p>  Aunque hay situaciones en las que se carga la CPU Bound aparente, en realidad degenera en una E / S Bound.  Si, por ejemplo, queremos tomar y sumar todos los elementos de una gran matriz, ¬øqu√© haremos?  Escribiremos un ciclo, todo funcionar√°.  Luego pensamos: ‚ÄúEntonces tenemos un mont√≥n de n√∫cleos.  Vamos a tomarlo, dividir la matriz en trozos y paralelizar todo ‚Äù.  ¬øCu√°l ser√° el resultado? </p><br><p><img src="https://habrastorage.org/webt/5z/hy/zo/5zhyzoxnnpay_wnc1ypjmwesxeo.png"></p><br><p>  El resultado es una situaci√≥n en la que nuestro procesador procesa datos m√°s r√°pido de lo que logran venir de la memoria.  En este caso, la mayor√≠a de las veces esperamos los datos de la memoria, y la carga, que parec√≠a estar unida a la CPU, en realidad resulta estar unida a la E / S. </p><br><h1 id="false-sharing">  Intercambio falso </h1><br><p>  Adem√°s, hay una historia como <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">False Sharing</a></strong> .  False Sharing es una situaci√≥n en la que los n√∫cleos comienzan a interferir entre s√≠.  Hay un primer n√∫cleo, hay un segundo n√∫cleo, y cada uno de ellos tiene su propia <strong>cach√© L1</strong> .  La cach√© L1 se divide en l√≠neas ( <em>l√≠nea de cach√©</em> ) de 64 bytes.  Cuando obtenemos algunos datos de la memoria, siempre obtenemos no menos de 64 bytes.  Al cambiar estos datos, deshabilitamos las memorias cach√© de todos los n√∫cleos. </p><br><p><img src="https://habrastorage.org/webt/b4/ug/ne/b4ugnemfq4lkhv22yhxhuxeytdq.png"></p><br><p>  Resulta que si dos n√∫cleos cambian datos muy cercanos entre s√≠ ( <em>a una distancia de menos de 64 bytes</em> ), comienzan a interferir entre s√≠, invalidando las memorias cach√©.  En este caso, si el programa se escribiera secuencialmente, funcionar√≠a m√°s r√°pido que cuando se usan varios n√∫cleos que interfieren entre s√≠.  Cuantos m√°s n√∫cleos, menor es el rendimiento. </p><br><h1 id="schedulers">  Programadores </h1><br><p>  Nos elevaremos al siguiente nivel de abstracci√≥n: a los planificadores. </p><br><p>  Cuando el trabajo comienza con un c√≥digo competitivo, aparecen los planificadores.  Go tiene un llamado <strong>planificador de espacio de usuario</strong> que opera en <strong>goroutines</strong> .  El sistema operativo tambi√©n tiene su propio <strong>programador</strong> , que funciona con <strong>subprocesos del sistema operativo</strong> .  E incluso el procesador no es tan simple.  Por ejemplo, los procesadores modernos tienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">predicci√≥n de ramas</a> y otras formas de estropear nuestra hermosa imagen de la linealizaci√≥n del mundo. </p><br><p><img src="https://habrastorage.org/webt/cf/dc/1k/cfdc1kw8l7axejmswctoqpawlmc.png"></p><br><p>  Los programadores se dividen por tipo de multitarea.  Hay <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multitarea cooperativa</a></strong> y <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multitarea preventiva</a></strong> .  En el caso de la <strong>multitarea cooperativa</strong> , el <strong>proceso de</strong> ejecuci√≥n en <strong>s√≠ mismo decide</strong> cu√°ndo necesita transferir el control a otro proceso, y en el caso de la <strong>multitarea abarrotada,</strong> hay <strong>un componente externo</strong> : el planificador, que controla la cantidad de recursos asignados al proceso. </p><br><p><img src="https://habrastorage.org/webt/vo/o_/tx/voo_tx_4vfug0jinekpu5f-o-ha.png"></p><br><p>  La multitarea cooperativa permite que un proceso "monopolice" todo el recurso de la CPU.  En la multitarea preventiva, esto no suceder√°, porque hay un organismo controlador.  Pero con la multitarea cooperativa, el cambio de contexto es m√°s eficiente, porque el proceso sabe con certeza en qu√© momento es mejor dar el control a otro proceso.  En la multitarea preventiva, el planificador puede detener el proceso en cualquier momento; no es muy eficiente.  Al mismo tiempo, en la multitarea preventiva, podemos proporcionar el mismo recurso para cada proceso gracias a un planificador externo. </p><br><p>  El sistema operativo utiliza un planificador basado en la multitarea preventiva, ya que el sistema operativo es necesario para garantizar condiciones iguales para cada usuario.  ¬øQu√© hay de ir? </p><br><p><img src="https://habrastorage.org/webt/8d/ry/dd/8drydde54y4ytkr_t2qrcznevvy.png"></p><br><p>  Si leemos la documentaci√≥n, aprendemos que el planificador en Go es preventivo.  Pero, cuando comenzamos a entender, resulta que Go no tiene un planificador como componente externo.  En Go, el compilador establece puntos de cambio de contexto.  Y aunque nosotros, como desarrolladores, no necesitamos cambiar manualmente el contexto, el control de cambio no se lleva al componente externo.  Gracias a esto, Go es muy efectivo para cambiar una gorutina a otra.  Pero un malentendido de las caracter√≠sticas del trabajo de tal "planificador" puede conducir a un comportamiento inesperado.  Por ejemplo, ¬øqu√© generar√° este c√≥digo? </p><br><p><img src="https://habrastorage.org/webt/4p/7i/tm/4p7itmw8_pusfpg5whtkjawfqt4.png"></p><br><p>  Tal c√≥digo se congelar√°. </p><br><p> Por qu√©  Porque al principio, usando <code>GOMAXPROCS</code> , <code>GOMAXPROCS</code> al programa a usar solo un n√∫cleo.  Despu√©s de eso, se puso a la rutina en la cola, dentro de la cual deber√≠a funcionar un ciclo interminable.  Luego esperamos 500 ms e imprimimos <code>x</code> .  Despu√©s del <code>time.Sleep</code> Dormir <code>time.Sleep</code> rutina comenzar√° realmente, pero no habr√° forma de salir del bucle infinito, porque el compilador no pondr√° el punto de cambio de contexto.  El programa se congela. </p><br><p>  Y si agregamos <code>runtime.Gosched()</code> dentro del bucle, entonces todo estar√° bien, porque <code>runtime.Gosched()</code> expl√≠citamente que queremos cambiar el contexto. </p><br><p>  Tales caracter√≠sticas tambi√©n necesitan saber y recordar. </p><br><p>  Hablamos sobre el cambio de contexto, pero ¬ød√≥nde suele insertar Go los puntos de cambio? </p><br><p><img src="https://habrastorage.org/webt/8k/6k/bo/8k6kbop0qpvsimvezerzshdc0qm.png"></p><br><p>  <code>runtime.morestack()</code> y <code>runtime.newstack()</code> generalmente se insertan en el momento en que se llama a la funci√≥n.  <code>runtime.Goshed()</code> podemos suministrarnos nosotros mismos.  Y, por supuesto, el cambio de contexto ocurre durante bloqueos, subidas de red y llamadas al sistema.  Puedes ver este tema en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de Kirill Lashkevich</a> .  Muy bien, te aconsejo. </p><br><p>  Vayamos m√°s cerca del c√≥digo.  Veremos los errores. </p><br><h1 id="race-condition">  Condici√≥n de carrera </h1><br><p>  Uno de los errores m√°s populares que cometemos es la <code>Race Condition</code> .  La conclusi√≥n es que cuando hacemos, por ejemplo, un incremento, de hecho no hacemos una operaci√≥n, sino varias: el procesador lee los datos de la memoria para registrarse, actualiza el registro y escribe los datos en la memoria. </p><br><p><img src="https://habrastorage.org/webt/jf/ar/zs/jfarzsk1prxonyme8fx7b1yvg1s.png"></p><br><p>  Estas tres operaciones no se realizan at√≥micamente.  Por lo tanto, el planificador en cualquier momento, en cualquiera de estas operaciones, puede tomar y desplazar nuestro flujo.  Resulta que la acci√≥n no est√° terminada, y por eso atrapamos errores. </p><br><p>  Aqu√≠ hay un ejemplo de dicho c√≥digo (el <em>incremento se descompone inmediatamente en varias operaciones</em> ). </p><br><p><img src="https://habrastorage.org/webt/jt/kj/c9/jtkjc97ruwb4ejlt7btjhybjh0u.png"></p><br><p>  El planificador puede evitar el primer subproceso despu√©s de ejecutar la primera l√≠nea y el segundo subproceso despu√©s de verificar la condici√≥n.  En este caso, ambos flujos caer√°n en la secci√≥n cr√≠tica y, por lo tanto, es "cr√≠tico": no se pueden ingresar all√≠ simult√°neamente. </p><br><p>  Podemos bloquear usando <code>sync.Mutex</code> del paquete de <code>sync</code> est√°ndar.  El bloqueo de acceso nos permite indicar expl√≠citamente que el c√≥digo debe ser ejecutado por un hilo a la vez.  Con este c√≥digo, obtenemos lo que necesitamos. </p><br><p><img src="https://habrastorage.org/webt/5w/hf/2w/5whf2wr5xmhbkhxrnarppopowfe.png"></p><br><p>  Las cerraduras son una operaci√≥n bastante costosa.  Por lo tanto, hay operaciones at√≥micas a nivel de procesador.  En este caso, el incremento puede hacerse at√≥mico al reemplazarlo con la operaci√≥n <code>atomic.AddInt64</code> del paquete <code>atomic</code> . </p><br><p><img src="https://habrastorage.org/webt/-f/1o/rz/-f1orz2g4oar-_b0ef0vk7m4o6y.png"></p><br><p>  Si comenzamos a trabajar con instrucciones at√≥micas, entonces no solo debemos escribir at√≥micamente, sino tambi√©n leer at√≥micamente.  Si no lo hacemos, pueden surgir problemas. </p><br><h1 id="optimizacii--what-could-possibly-go-wrong">  Optimizaci√≥n: ¬øqu√© podr√≠a salir mal? </h1><br><p>  Las cerraduras son buenas, pero pueden ser caras.  Los at√≥micos son lo suficientemente baratos como para no preocuparse por el rendimiento. </p><br><p>  Entonces, aprendimos que las primitivas de sincronizaci√≥n introducen sobrecarga y decidimos agregar optimizaci√≥n: verificaremos el indicador sin tener en cuenta el subprocesamiento m√∫ltiple y luego verificaremos nuevamente usando primitivas de sincronizaci√≥n.  Todo se ve bien y deber√≠a funcionar. </p><br><p><img src="https://habrastorage.org/webt/jq/9u/cm/jq9ucmurmj-x9y4i9eu8ojzkfem.png"></p><br><p>  Todo est√° bien, excepto que el compilador est√° tratando de optimizar nuestro c√≥digo.  Que esta haciendo el  √âl intercambia las instrucciones de asignaci√≥n, y obtenemos un comportamiento no v√°lido, porque nuestro <code>done</code> hace <code>true</code> antes de que se asigne el valor de la variable " <code></code> ". </p><br><p>  No intente hacer tales optimizaciones, debido a ellas obtendr√° muchos problemas.  Le aconsejo que lea la especificaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Go Memory Model</a> y un art√≠culo de Dmitry Vyukova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@dvyukov</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Razas de datos benignas: ¬øqu√© podr√≠a</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">salir</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mal?</a>  para entender mejor los problemas. </p><br><p>  Si realmente conf√≠a en el rendimiento de las cerraduras, escriba c√≥digo sin bloqueo, pero no necesita hacer un acceso no sincronizado a la memoria. </p><br><h1 id="deadlock">  Punto muerto </h1><br><p>  El siguiente problema que enfrentaremos es Deadlock.  Puede parecer que todo es bastante trivial aqu√≠.  Hay dos recursos, por ejemplo, dos <code>Mutex</code> .  En el primer hilo, primero capturamos el primer <code>Mutex</code> , y en el segundo hilo primero capturamos el segundo <code>Mutex</code> .  Adem√°s, vamos a querer tomar el segundo <code>Mutex</code> en el primer hilo, pero no podremos hacerlo porque ya est√° bloqueado.  En el segundo hilo, intentaremos tomar, respectivamente, el primer <code>Mutex</code> y tambi√©n bloquear.  Ah√≠ est√°, Deadlock. </p><br><p><img src="https://habrastorage.org/webt/pe/vk/y1/pevky1zcbkqtftopczdgbg2_xuu.png"></p><br><p>  Ninguno de estos dos hilos podr√° avanzar m√°s, porque ambos esperar√°n el recurso.  ¬øC√≥mo se resuelve esto?  Intercambiamos cerraduras, y luego no surgen problemas.  Por supuesto, es f√°cil de decir, pero mantener esta regla durante toda la vida del producto no es f√°cil.  Si es posible, h√°galo: <strong>tome y d√© las cerraduras en el mismo orden</strong> . </p><br><p>  Puede parecer que los desarrolladores experimentados no encuentran tales errores, pero aqu√≠ hay un ejemplo de un punto muerto del c√≥digo del proyecto, etc. </p><br><p><img src="https://habrastorage.org/webt/iq/8l/pe/iq8lpexqj2xc_ykt2qzzgbxxiwu.png"></p><br><p>  Aqu√≠ el problema principal es que escribir en un canal sin b√∫fer es bloquear; para escribir, por otro lado, necesita un lector.  Tomando el mutex, el primer hilo espera a que aparezca el lector.  El segundo hilo ya no puede capturar el mutex.  Punto muerto </p><br><p>  Te aconsejo que pruebes el emocionante juego <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Deadlock Empire</a> .  En este juego, act√∫as como un programador que debe cambiar el contexto para evitar que el c√≥digo se ejecute correctamente. </p><br><h1 id="sort-of-problems">  Tipo de problemas </h1><br><p>  ¬øQu√© problemas existen todav√≠a?  Comenzamos con las <strong>condiciones de carrera</strong> .  Luego miramos <strong>Deadlock</strong> (todav√≠a hay una variante de <strong>Livelock</strong> , esto es cuando no podemos capturar el recurso, pero no hay bloqueos expl√≠citos).  Hay <strong>hambre</strong> , es cuando vamos a la impresora para imprimir un trozo de papel, y hay una cola, y no podemos acceder al recurso.  Observamos el comportamiento del programa con <strong>False Sharing</strong> .  Todav√≠a hay un problema: <strong>bloqueo de contenci√≥n</strong> , cuando el rendimiento se degrada debido a una gran competencia por un recurso (por ejemplo, un mutex que necesitan una gran cantidad de subprocesos). </p><br><p><img src="https://habrastorage.org/webt/yo/5x/dz/yo5xdzb1iqwunpsqjitejygw_ji.png"></p><br><h1 id="race-detection">  Detecci√≥n de carrera </h1><br><p>  Go es potente con la caja de herramientas provista de f√°brica.  <strong>Race Detector</strong> es una de esas herramientas.  Usarlo es simple: escribimos pruebas o lo ejecutamos en una carga de combate y detectamos errores. <br>  Puede leer m√°s sobre el uso del Detector de carreras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentaci√≥n</a> , pero recuerde que tiene limitaciones.  Deteng√°monos en ellos con m√°s detalle. </p><br><p><img src="https://habrastorage.org/webt/sq/ft/kq/sqftkq68nj93cffxblalpvqss9s.png"></p><br><p>  En primer lugar, el c√≥digo que no se ejecut√≥ no es verificado por el detector de carreras.  Por lo tanto, la cobertura de la prueba debe ser alta.  Adem√°s, el Detector de carreras recuerda el historial de llamadas a cada palabra en la memoria, pero este historial de llamadas tiene profundidad.  En Go, por ejemplo, esta profundidad es cuatro: cuatro elementos, cuatro accesos.  Si el Detector de carreras no ha atrapado una carrera dentro de esta profundidad, cree que no hay carrera.  Por lo tanto, aunque el Detector de carrera nunca se equivoca, no detectar√° todos los errores.  Puede esperar el Detector de carreras, pero debe recordar sus limitaciones.  Por separado, puede leer sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo de trabajo</a> . </p><br><h1 id="block-profile">  Perfil de bloque </h1><br><p>  <strong>El perfil de bloqueo</strong> es otra herramienta que nos permite encontrar y solucionar problemas de bloqueo. </p><br><p><img src="https://habrastorage.org/webt/hg/ex/ft/hgexftmdroak4fgg0udjq4s4vow.png"></p><br><p>  Se puede usar tanto en el nivel de prueba de referencia como durante la carga de combate.  Por lo tanto, si est√° buscando problemas asociados con la sincronizaci√≥n de acceso a datos, intente comenzar con el Detector de carrera y contin√∫e usando el Perfil de bloque. </p><br><h1 id="primer-programmy">  Programa ejemplo </h1><br><p>  Veamos el c√≥digo real con el que podemos tropezar.  Escribiremos una funci√≥n que simplemente tome una matriz de solicitudes e intente ejecutarlas: cada solicitud en secuencia.  Si alguna de las solicitudes devuelve un error, la funci√≥n termina la ejecuci√≥n. </p><br><p><img src="https://habrastorage.org/webt/r_/kl/3w/r_kl3wjbfxfsfa5dvbs34afvtww.png"></p><br><p>  Si escribimos en Go, debemos usar todo el poder del lenguaje.  Lo intentamos  Obtenemos tres veces m√°s c√≥digo. </p><br><p><img src="https://habrastorage.org/webt/nc/qt/_q/ncqt_qwhoahbahx9tdmuspt1_1c.png"></p><br><p>  Pregunta: ¬øhay alg√∫n error en el c√≥digo? </p><br><p>  Por supuesto!  Veamos cu√°les. </p><br><p>  En el circuito corremos goroutines.  Para la orquestaci√≥n de goroutine, utilizamos <code>sync.WaitGroup</code> .  ¬øPero qu√© estamos haciendo mal?  Ya dentro de la rutina de ejecuci√≥n, llamamos <code>wg.Add(1)</code> , es decir, agregamos una nueva rutina para esperar.  Y usando <code>wg.Wait()</code> , estamos esperando que se completen todas las gorutinas.  Pero puede suceder que cuando se <code>wg.Wait()</code> , no se inicie ni una sola rutina.  En este caso, <code>wg.Wait()</code> considerar√° que todo est√° hecho, <code>wg.Wait()</code> el canal y saldremos de la funci√≥n sin errores, creyendo que todo est√° bien. </p><br><p><img src="https://habrastorage.org/webt/o1/wv/7m/o1wv7mielcch1r4k3zmdgfksbk4.png"></p><br><p>  ¬øQu√© pasar√° despu√©s?  Luego comenzar√°n las rutinas, se ejecutar√° el c√≥digo y quiz√°s una de las solicitudes devolver√° un error.  Se escribe un error en un canal cerrado, y escribir en un canal cerrado es p√°nico.  Nuestra aplicaci√≥n se bloquear√°.  Es poco probable que esto sea lo que quer√≠a obtener, por lo que lo corregimos indicando de antemano cu√°ntas gorutinas lanzaremos. </p><br><p><img src="https://habrastorage.org/webt/ly/re/v6/lyrev61roq8cswx4q0itv12reyy.png"></p><br><p>  Tal vez todav√≠a hay algunos problemas? </p><br><p>  Hay un error relacionado con c√≥mo aparece el objeto <code>req</code> dentro de la funci√≥n.  La variable <code>req</code> act√∫a como un iterador del ciclo, y no sabemos qu√© valor tendr√° en el momento del lanzamiento de la rutina. </p><br><p><img src="https://habrastorage.org/webt/wi/xc/m2/wixcm2d3adxkmbqobaoapwm4ofq.png"></p><br><p>  En la pr√°ctica, en este c√≥digo, el valor <code>req</code> probablemente ser√° igual al √∫ltimo elemento de la matriz.  Por lo tanto, solo env√≠a la misma solicitud N veces.  Soluci√≥n: expl√≠citamente pasa nuestra solicitud como argumento a la funci√≥n. </p><br><p><img src="https://habrastorage.org/webt/3g/gq/ty/3ggqtyg5-pgxmfhfkwruozrajyg.png"></p><br><p>  Echemos un vistazo m√°s de cerca a c√≥mo manejamos los errores.  Declaramos un canal almacenado en una ranura.  Cuando ocurre un error, lo enviamos a este canal.  Todo parece estar bien: se produjo un error; devolvimos este error de una funci√≥n. </p><br><p><img src="https://habrastorage.org/webt/3_/5-/ku/3_5-kufkknuxpfmc1tpsqn_aqr4.png"></p><br><p>  Pero, ¬øqu√© pasa si todas las solicitudes regresan con un error? </p><br><p>  Luego, escribir en el canal obtendr√° solo el primer error, el resto bloquear√° la ejecuci√≥n de goroutines.  Como no habr√° m√°s lecturas del canal al momento de salir de la funci√≥n de lectura, tenemos una fuga de rutina.  Es decir, todos esos gorutinos que no pudieron escribir el error en el canal simplemente se quedan en la memoria. </p><br><p>  Lo arreglamos de manera muy simple: seleccionamos en el canal de ranura el n√∫mero de solicitudes.  Esto resuelve nuestro problema de memoria poco eficiente, porque si tenemos mil millones de solicitudes, necesitamos asignar mil millones de ranuras. </p><br><p><img src="https://habrastorage.org/webt/qe/nm/te/qenmteeutwuvzmmlu_lqjrnrhgy.png"></p><br><p>  Solucionamos los problemas.  El c√≥digo ahora es competitivo.  Pero el problema es la legibilidad: en comparaci√≥n con la versi√≥n s√≠ncrona del c√≥digo, hay muchos.  Y esto no es bueno, porque el desarrollo de programas competitivos ya es dif√≠cil, ¬øpor qu√© lo complicamos con mucho c√≥digo? </p><br><p><img src="https://habrastorage.org/webt/ww/jx/v3/wwjxv3vhcewmqajtzlsrgqrsbli.png"></p><br><h1 id="errgroup">  Errgroup </h1><br><p>  Sugiero aumentar la legibilidad del c√≥digo. </p><br><p>  Me gusta usar el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errgroup en</a> lugar de <code>sync.WaitGroup</code> .  Este paquete no requiere especificar cu√°ntas gorutinas esperar y le permite ignorar la colecci√≥n de errores.  As√≠ es como se ver√° nuestra funci√≥n cuando use <code>errgroup</code> : </p><br><p><img src="https://habrastorage.org/webt/p4/da/no/p4danooucpgyforvks7qd4eqmmi.png"></p><br><p>  Adem√°s, <code>errgroup</code> permite orquestar convenientemente los componentes de nuestro programa usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">context.Context</a> .  A que me refiero </p><br><p>  Supongamos que tenemos varios componentes de nuestro programa, si al menos uno de ellos falla, queremos terminar cuidadosamente todos los dem√°s.  Entonces <code>errgroup</code> cuando <code>errgroup</code> un error, completa el <code>context</code> y, por lo tanto, todos los componentes reciben una notificaci√≥n sobre la necesidad de completar el trabajo. </p><br><p><img src="https://habrastorage.org/webt/5l/gb/95/5lgb95elqafmsoakuaktm1_nn2u.png"></p><br><p>  Esto se puede usar para construir programas complejos de m√∫ltiples componentes que se comporten de manera predecible. </p><br><h1 id="vyvody">  Conclusiones </h1><br><p>  Hazlo lo m√°s simple posible.  Mejor sincr√≥nicamente.  El desarrollo de programas multiproceso es generalmente un proceso complejo, que conduce a la aparici√≥n de errores desagradables. </p><br><p><img src="https://habrastorage.org/webt/by/bl/nz/byblnzeor9pzwpraobylgc5yfme.png"></p><br><p>  No use la sincronizaci√≥n impl√≠cita.  Si realmente descans√≥ en √©l, piense en c√≥mo deshacerse de los bloqueos, c√≥mo hacer un algoritmo sin bloqueo. </p><br><p>  Go es un buen lenguaje para escribir programas que funcionan efectivamente con una gran cantidad de n√∫cleos, pero no es mejor que todos los dem√°s idiomas, y siempre aparecer√°n errores.  Por lo tanto, incluso armado con Go, trata de comprender varios niveles de abstracciones inferiores a lo que trabajas. </p><br><p><img src="https://habrastorage.org/webt/ze/i7/rd/zei7rd4-t5-oxw-imkx2is7qlrc.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466495/">https://habr.com/ru/post/466495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466479/index.html">Uso de PVS-Studio al verificar proyectos de Unreal Engine en el sistema operativo Windows</a></li>
<li><a href="../466485/index.html">Coches el√©ctricos de los a√±os 90. Parte 1. Hermanos Citroen y Peugeot</a></li>
<li><a href="../466489/index.html">Los ingenieros coreanos sugieren usar Hololens como alternativa a las particiones de oficina</a></li>
<li><a href="../466491/index.html">Proyecto de entrenamiento en Godot - Pong (Parte 2) Creaci√≥n y configuraci√≥n de la pelota</a></li>
<li><a href="../466493/index.html">Docker: para comenzar. Atencion Implementar</a></li>
<li><a href="../466497/index.html">Entorno moderno para aplicaciones React Native</a></li>
<li><a href="../466499/index.html">C / C ++ de Python (ctypes)</a></li>
<li><a href="../466501/index.html">Acciones de Github y construcci√≥n multiplataforma</a></li>
<li><a href="../466503/index.html">Slurm DevOps. Segundo dia IaC, pruebas de infraestructura y "¬°Slurm inspira!"</a></li>
<li><a href="../466505/index.html">YIMP - Panel de control para Yii 2 en Bootstrap 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>