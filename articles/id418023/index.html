<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚀 🧤 🧜🏼 Pointer dalam C lebih abstrak dari yang Anda kira 🕺🏻 🌁 🚗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pointer mengacu pada sel memori, dan penunjuk referensi berarti membaca nilai sel yang ditentukan. Nilai dari pointer itu sendiri adalah alamat sel me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pointer dalam C lebih abstrak dari yang Anda kira</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418023/">  Pointer <i>mengacu</i> pada sel memori, dan penunjuk referensi berarti membaca nilai sel yang ditentukan.  Nilai dari pointer itu sendiri adalah alamat sel memori.  Standar bahasa C tidak menentukan formulir untuk mewakili alamat memori.  Ini adalah poin yang sangat penting, karena arsitektur yang berbeda dapat menggunakan model pengalamatan yang berbeda.  Sebagian besar arsitektur modern menggunakan ruang alamat linear atau serupa.  Namun, bahkan pertanyaan ini tidak ditentukan secara ketat, karena alamat dapat berupa fisik atau virtual.  Beberapa arsitektur menggunakan representasi non-numerik sama sekali.  Jadi, Symbolics Lisp Machine beroperasi dengan tupel formulir <i>(objek, offset)</i> sebagai alamat. <br><a name="habracut"></a><table><tbody><tr><td>  Beberapa waktu kemudian, setelah publikasi terjemahan tentang Habré, penulis membuat modifikasi besar pada teks artikel.  Memperbarui terjemahan pada Habré bukanlah ide yang baik, karena beberapa komentar akan kehilangan maknanya atau akan terlihat tidak pada tempatnya.  Saya tidak ingin menerbitkan teks sebagai artikel baru.  Oleh karena itu, kami baru saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperbarui terjemahan artikel</a> di viva64.com, dan di sini kami meninggalkan semuanya apa adanya.  Jika Anda seorang pembaca baru, saya sarankan membaca terjemahan yang lebih baru di situs kami dengan mengklik tautan di atas. </td></tr></tbody></table><br>  Standar tidak menetapkan bentuk penyajian pointer, tetapi menetapkan - pada tingkat yang lebih besar atau lebih kecil - operasi dengan mereka.  Di bawah ini kami mempertimbangkan operasi ini dan fitur dari definisi mereka dalam standar.  Mari kita mulai dengan contoh berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  Jika kami mengkompilasi kode GCC ini dengan level optimasi 1 dan menjalankan program di Linux x86-64, itu akan mencetak yang berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Perhatikan bahwa pointer <i>p</i> dan <i>q</i> merujuk ke alamat yang sama.  Namun, hasil dari ekspresi <i>p == q</i> <i>salah</i> , dan ini sekilas tampak aneh.  Bukankah dua pointer ke alamat yang sama harus sama? <br><br>  Inilah cara standar C mendefinisikan hasil pemeriksaan dua petunjuk untuk persamaan: <br><table><tbody><tr><td>  <b>C11 § 6.5.9 paragraf 6</b> <br><br>  Dua pointer sama jika dan hanya jika keduanya nol, baik menunjuk ke objek yang sama (termasuk pointer ke objek dan sub-objek pertama di objek) atau fungsi, atau arahkan ke posisi setelah elemen terakhir array, atau satu pointer merujuk ke posisi setelah elemen terakhir dari array, dan yang lainnya merujuk ke awal array lain segera setelah yang pertama di ruang alamat yang sama. </td></tr></tbody></table><br>  Pertama-tama, muncul pertanyaan: apa itu "objek <i>"</i> ?  Karena kita berbicara tentang bahasa C, jelas bahwa di sini objek tidak ada hubungannya dengan objek dalam bahasa OOP seperti C ++.  Dalam standar C, konsep ini tidak sepenuhnya didefinisikan: <br><table><tbody><tr><td>  <b>C11 § 3.15</b> <br><br>  Objek adalah area penyimpanan runtime yang isinya dapat digunakan untuk mewakili nilai <br><br>  CATATAN Ketika disebutkan, suatu objek dapat dianggap memiliki jenis tertentu;  lihat 6.3.2.1. </td></tr></tbody></table><br>  Mari kita perbaiki.  Variabel integer 16-bit adalah kumpulan data dalam memori yang dapat mewakili nilai integer 16-bit.  Oleh karena itu, variabel semacam itu adalah objek.  Akankah dua pointer sama jika salah satu dari mereka merujuk ke byte pertama dari integer yang diberikan, dan yang kedua ke byte kedua dari angka yang sama?  Komite standardisasi bahasa, tentu saja, tidak bermaksud sama sekali.  Tetapi di sini perlu dicatat bahwa dalam hal ini dia tidak memiliki penjelasan yang jelas, dan kita dipaksa untuk menebak apa yang sebenarnya dimaksud. <br><br><h3>  Ketika kompiler menghalangi </h3><br>  Mari kita kembali ke contoh pertama kita.  Pointer <i>p</i> diperoleh dari objek <i>a</i> , dan pointer <i>q</i> dari objek <i>b</i> .  Dalam kasus kedua, aritmatika alamat digunakan, yang didefinisikan untuk operator plus dan minus sebagai berikut: <br><table><tbody><tr><td>  <b>C11 § 6.5.6 klausa 7</b> <br><br>  Ketika digunakan dengan operator ini, sebuah penunjuk ke objek yang bukan merupakan elemen dari array berperilaku seperti penunjuk ke awal array dengan panjang satu elemen, tipe yang sesuai dengan jenis objek asli. </td></tr></tbody></table><br>  Karena setiap pointer ke objek yang bukan array <i>sebenarnya</i> menjadi pointer ke array dengan panjang satu elemen, standar mendefinisikan aritmatika alamat hanya untuk pointer ke array - ini adalah poin 8. Kami tertarik pada bagian berikut: <br><table><tbody><tr><td>  <b>C11 § 6.5.6 klausa 8</b> <br><br>  Jika ekspresi integer ditambahkan atau dikurangi dari pointer, pointer yang dihasilkan adalah jenis yang sama dengan pointer asli.  Jika pointer sumber merujuk ke elemen array dan array memiliki panjang yang cukup, maka sumber dan elemen yang dihasilkan dipisahkan satu sama lain sehingga perbedaan antara indeks mereka sama dengan nilai ekspresi integer.  Dengan kata lain, jika ekspresi <i>P</i> menunjuk ke elemen ke-l dari array, ekspresi <i>(P) + N</i> (atau <i>N + (P)</i> ) dan <i>(P) -N</i> (dimana <i>N</i> memiliki nilai n) menunjukkan masing-masing (i + n) elemen th dan (i - n) dari array, asalkan ada.  Selain itu, jika ekspresi <i>P</i> menunjuk ke elemen terakhir dari array, maka ekspresi <i>(P) +1</i> menunjukkan posisi setelah elemen terakhir dari array, dan jika ekspresi <i>Q</i> menunjukkan posisi setelah elemen terakhir dari array, maka ekspresi <i>(Q) -1</i> menunjukkan elemen terakhir array  Jika sumber dan pointer yang dihasilkan merujuk ke elemen array yang sama atau ke posisi setelah elemen terakhir array, maka overflow dikecualikan;  jika tidak, perilaku tidak terdefinisi.  Jika pointer yang dihasilkan merujuk ke posisi setelah elemen terakhir dari array, operator unary <i>*</i> tidak dapat diterapkan padanya. </td></tr></tbody></table><br>  Oleh karena itu, hasil dari ekspresi <i>&amp; b + 1</i> pastilah alamat, dan oleh karena itu <i>p</i> dan <i>q</i> adalah pointer yang valid.  Biarkan saya mengingatkan Anda bagaimana kesetaraan dua pointer dalam standar didefinisikan: " <i>Dua pointer sama jika dan hanya jika [...] satu pointer merujuk ke posisi setelah elemen terakhir dari array, dan yang lainnya ke awal array lain segera setelah yang pertama di sama. address space "</i> (C11 § 6.5.9 klausa 6).  Inilah tepatnya yang kita amati dalam contoh kita.  Pointer q mengacu pada posisi setelah objek b, segera diikuti oleh objek a, ke mana pointer p merujuk.  Jadi, apakah ada bug di GCC?  Kontradiksi ini digambarkan pada tahun 2014 sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug # 61502</a> , tetapi pengembang GCC tidak menganggapnya sebagai bug dan karenanya tidak akan memperbaikinya. <br><br>  Masalah serupa ditemui pada tahun 2016 oleh programmer Linux.  Pertimbangkan kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Simbol <i>_mulai</i> dan <i>_end</i> tentukan batas-batas area memori.  Karena mereka ditransfer ke file eksternal, kompiler tidak tahu bagaimana sebenarnya array berada di memori.  Untuk alasan ini, ia harus berhati-hati di sini dan melanjutkan dari asumsi bahwa mereka mengikuti satu sama lain di ruang alamat.  Namun, GCC mengkompilasi kondisi loop sehingga selalu benar, yang membuat loop tidak terbatas.  Masalah ini dijelaskan di sini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di LKML</a> - sebuah fragmen kode serupa digunakan di sana.  Tampaknya dalam kasus ini, penulis GCC tetap memperhitungkan komentar dan mengubah perilaku kompiler.  Setidaknya saya tidak dapat mereproduksi kesalahan ini dalam GCC versi 7.3.1 di Linux x86_64. <br><br><h3>  Solusi - dalam laporan bug # 260? </h3><br>  Kasus kami dapat mengklarifikasi laporan bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 260</a> .  Ini lebih tentang nilai-nilai yang tidak pasti, tetapi Anda dapat menemukan komentar penasaran dari panitia di dalamnya: <br><br>  <i>Implementasi kompiler [...] juga dapat membedakan pointer yang diperoleh dari objek yang berbeda, bahkan jika pointer ini memiliki set bit yang sama.</i> <br><br>  Jika kita mengambil komentar ini secara harfiah, maka logis bahwa hasil dari ekspresi <i>p == q</i> adalah "false," karena <i>p</i> dan <i>q</i> diperoleh dari objek yang berbeda yang tidak terhubung dengan cara apa pun.  Sepertinya kita semakin dekat dengan kebenaran - atau tidak?  Sejauh ini, kami telah berurusan dengan operator kesetaraan, tetapi bagaimana dengan operator hubungan? <br><br><h3>  Petunjuk terakhir ada pada operator relasi? </h3><br>  Definisi <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> dan <i>&gt; =</i> operator hubungan dalam konteks perbandingan pointer berisi satu pemikiran yang aneh: <br><table><tbody><tr><td>  <b>C11 § 6.5.8 paragraf 5</b> <br><br>  Hasil membandingkan dua pointer tergantung pada posisi relatif dari objek yang ditunjukkan dalam ruang alamat.  Jika dua pointer ke tipe objek merujuk ke objek yang sama, atau keduanya merujuk ke posisi setelah elemen terakhir dari array yang sama, maka pointer tersebut sama.  Jika objek yang ditunjukkan adalah anggota dari objek komposit yang sama, maka pointer ke anggota struktur yang dideklarasikan lebih dari pointer ke anggota yang dideklarasikan sebelumnya, dan pointer ke elemen array dengan indeks lebih tinggi lebih dari pointer ke elemen array yang sama dengan indeks lebih rendah.  Semua petunjuk untuk anggota dari asosiasi yang sama adalah sama.  Jika ekspresi <i>P</i> menunjuk ke elemen array, dan ekspresi <i>Q</i> menunjuk ke elemen terakhir dari array yang sama, maka nilai pointer-ekspresi <i>Q + 1</i> lebih besar dari nilai ekspresi <i>P.</i>  Dalam semua kasus lain, perilaku tidak didefinisikan. </td></tr></tbody></table><br>  Menurut definisi ini, hasil membandingkan pointer ditentukan hanya jika pointer diperoleh dari objek yang <i>sama</i> .  Kami menunjukkan ini dengan dua contoh. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Di sini, pointer <i>p</i> dan <i>q</i> merujuk ke dua objek berbeda yang tidak saling berhubungan.  Oleh karena itu, hasil perbandingannya tidak ditentukan.  Namun dalam contoh berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  pointer <i>p</i> dan <i>q</i> merujuk ke objek yang sama dan, oleh karena itu, saling berhubungan.  Jadi, mereka dapat dibandingkan - kecuali <i>malloc</i> mengembalikan nilai nol. <br><br><h3>  Ringkasan </h3><br>  Standar C11 tidak cukup menggambarkan perbandingan pointer.  Titik paling bermasalah yang kami temui adalah paragraf 6 § 6.5.9, di mana secara eksplisit diizinkan untuk membandingkan dua petunjuk yang merujuk dua array yang berbeda.  Ini bertentangan dengan komentar dari laporan bug # 260.  Namun, di sana kita berbicara tentang makna yang tidak terbatas, dan saya tidak ingin membangun alasan saya hanya berdasarkan komentar ini dan menafsirkannya dalam konteks lain.  Ketika membandingkan pointer, operator hubungan didefinisikan sedikit berbeda dari operator kesetaraan - yaitu, operator hubungan didefinisikan hanya jika kedua pointer diperoleh dari objek yang <i>sama</i> . <br><br>  Jika kita mengabaikan teks standar dan bertanya apakah mungkin untuk membandingkan dua petunjuk yang diperoleh dari dua objek yang berbeda, maka dalam hal apa pun jawabannya kemungkinan besar akan "tidak".  Contoh di awal artikel menunjukkan masalah teoretis.  Karena variabel <i>a</i> dan <i>b</i> memiliki durasi penyimpanan otomatis, asumsi kami tentang penempatannya di memori tidak dapat diandalkan.  Dalam beberapa kasus, kita dapat menebak, tetapi jelas bahwa kode semacam itu tidak dapat porting dengan aman, dan Anda dapat mengetahui arti dari program hanya dengan menyusun dan menjalankan atau membongkar kode, dan ini bertentangan dengan paradigma pemrograman yang serius. <br><br>  Namun, secara umum, saya tidak puas dengan kata-kata dalam standar C11, dan karena beberapa orang telah mengalami masalah ini, pertanyaannya tetap: mengapa tidak merumuskan aturan lebih jelas? <br><br><h3>  Selain itu <br>  Pointer ke posisi setelah elemen terakhir dari array </h3><br>  Adapun aturan tentang membandingkan dan mengatasi aritmatika pointer ke posisi setelah elemen terakhir dari array, Anda sering dapat menemukan pengecualian untuk itu.  Asumsikan bahwa standar tidak akan memungkinkan membandingkan dua petunjuk yang diperoleh dari array yang <i>sama</i> , meskipun setidaknya satu dari mereka merujuk pada posisi di luar akhir array.  Maka kode berikut tidak akan berfungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Menggunakan loop, kita berkeliling seluruh <i>x</i> array, yang terdiri dari 64 elemen, yaitu  loop body harus dieksekusi tepat 64 kali.  Tetapi pada kenyataannya, kondisi diperiksa 65 kali - satu kali lebih banyak dari jumlah elemen dalam array.  Dalam 64 iterasi pertama, pointer <i>saya</i> selalu merujuk ke bagian dalam array <i>x</i> , sedangkan ekspresi <i>&amp; x [num]</i> selalu menunjukkan posisi setelah elemen terakhir dari array.  Pada iterasi ke-65, pointer <i>i</i> juga akan merujuk ke posisi di luar akhir array <i>x</i> , karena kondisi loop menjadi salah.  Ini adalah cara yang nyaman untuk mem-bypass seluruh array, dan bergantung pada pengecualian pada aturan ketidakpastian dalam perilaku ketika membandingkan pointer tersebut.  Perhatikan bahwa standar hanya menggambarkan perilaku ketika membandingkan pointer;  dereferencing adalah masalah terpisah. <br><br>  Apakah mungkin untuk mengubah contoh kita sehingga tidak satu pun pointer menunjuk ke posisi setelah elemen terakhir dari array <i>x</i> ?  Itu mungkin, tetapi akan lebih sulit.  Kita harus mengubah kondisi loop dan melarang penambahan variabel <i>i</i> pada iterasi terakhir. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Kode ini penuh dengan seluk-beluk teknis, yang repot dengan yang mengalihkan dari tugas utama.  Selain itu, cabang tambahan muncul di badan loop.  Jadi saya merasa masuk akal bahwa standar memungkinkan pengecualian ketika membandingkan pointer posisi setelah elemen terakhir dari sebuah array. <br><br>  <b><i>Catatan Tim PVS-Studio</i></b> <br><br>  <i>Ketika mengembangkan alat analisa kode PVS-Studio, kita kadang-kadang harus berurusan dengan masalah halus untuk membuat diagnosa lebih akurat atau untuk memberikan konsultasi terperinci kepada klien kami.</i>  <i>Artikel ini tampaknya menarik bagi kami, karena menyentuh masalah di mana kita sendiri tidak sepenuhnya merasa percaya diri.</i>  <i>Karena itu, kami meminta penulis untuk mengirim terjemahannya.</i>  <i>Kami berharap bahwa lebih banyak programmer C dan C ++ akan mengenalnya dan memahami bahwa itu tidak begitu sederhana dan ketika penganalisa tiba-tiba menampilkan pesan aneh, Anda tidak perlu terburu-buru menganggapnya sebagai false positive :).</i> <br><br>  <i>Artikel ini pertama kali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>diterbitkan</i></a> dalam bahasa Inggris di stefansf.de.</i>  <i>Terjemahan diterbitkan dengan izin dari penulis.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418023/">https://habr.com/ru/post/id418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418009/index.html">Node.js dan rendering server dalam Airbnb</a></li>
<li><a href="../id418011/index.html">Halaman Tunggal dan SEO. Rahasia Optimasi</a></li>
<li><a href="../id418013/index.html">Intel Core i7-8086K (bagian 3)</a></li>
<li><a href="../id418015/index.html">Vasyuki baru. Perkembangan inovatif Moskow hingga 2100</a></li>
<li><a href="../id418017/index.html">Analisis perilaku Trojan Pegasus di jaringan</a></li>
<li><a href="../id418025/index.html">Buku “Belajar Java EE. Pemrograman modern untuk perusahaan besar "</a></li>
<li><a href="../id418027/index.html">Layanan Mikro Blitz</a></li>
<li><a href="../id418029/index.html">ReactOS 0.4.9: pembenci harus mencari argumen baru</a></li>
<li><a href="../id418031/index.html">Penumpukan massal model ML dalam produksi: nyata atau tidak?</a></li>
<li><a href="../id418035/index.html">Memperkenalkan Timeline di Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>