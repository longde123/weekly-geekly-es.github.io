<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏿 🧝🏻 🗽 至少一个您不知道的Vim技巧 💒 💯 👲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在Vim工作了八年，不断发现新东西。 它被认为是Vim的优点。 对我而言，这是缺乏开放性的：一堆隐藏函数隐藏得太深了。 

 他们谈论了模态编辑和文本对象的美丽，但在我看来，Vim的本质并非如此。 Vim是被其他工具阻塞的拼凑而成的子系统。 仅在普通编辑模式下，一百多个键盘快捷键！ 工具包的密集程...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>至少一个您不知道的Vim技巧</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454742/">我在Vim工作了八年，不断发现新东西。 它被认为是Vim的优点。 对我而言，这是缺乏开放性的：一堆隐藏函数隐藏得太深了。 <br><br> 他们谈论了模态编辑和文本对象的美丽，但在我看来，Vim的本质并非如此。  Vim是被其他工具阻塞的拼凑而成的子系统。 仅在普通编辑模式下，一百多个键盘快捷键！ 工具包的密集程度在很大程度上解释了Vim为什么如此有用。 如果“显示关键字的所有标签”仅为<code>g]</code> ，则此命令将更频繁地使用。 <br><br> 在缺乏开放性的系统中，必须依靠领导才能。 但是对于Vim来说，并不是很多。 有适合初学者的文章，例如<code>ciw</code> （请勿与CIA混淆， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CIA手册针对Vim</a> ）等。 并且有沉浸在子系统中的专家文章。 但是没有人真正谈论让您惊叹的这些特殊技巧：该死的，因为过去六年中我需要它！ <br><a name="habracut"></a><br> 本文是关于我在Vim中使用的一些小技巧。 它们都不是所有细节都可以分解的，因此，如果有兴趣，我建议您挖掘其他信息。 它们也彼此不相关。 但这是正常的。 总的来说，有太多的东西可以真正帮助几乎每个人。 <br><br><h1> 文章结构 </h1><br>  Vim用户非常粗鲁，分为两类。  <b>纯粹主义者</b>赞赏其体积小和普遍存在。 通常，如果您必须在不熟悉的计算机上工作（例如，通过ssh），它们会最小化配置。 另一方面，扩展器在Vim中填充了插件，函数和本地映射，从而徒劳地假装使用Emacs。 如果您从他们那里取走vimrc，那么这些家伙将仍然完全无助。 <br><br> 您可能会猜到，与纯粹主义者相比，我更接近扩张者。 我根据基本Vim是否需要更改将技巧分为两部分。 <br><br><h1> 纯粹主义者 </h1><br> 对于模式命令，使用标准帮助视图，即<code>&lt;cr&gt;</code>表示按Enter键。 当您需要帮助时<code>:h</code>用于特定行，例如<code>:h E676</code> ，该行将放在括号中。 <br><br><h2> 普通模式下的各种命令 </h2><br><h4>  “：和@： </h4><br>  <code>":</code>是保存最后执行的命令的寄存器。您可以键入<code>":p</code>以将其打印到缓冲区。  <code>@:</code>重复最后一个命令。 <br><br><h4>  “ = </h4><br> 注册“表达式”。 在这里，您可以输入任何vimL表达式并将其插入并与ctrl-R一起使用，等等。因此，例如，通过键入<code>"=strftime("%c")&lt;cr&gt;p</code>来插入本地时间戳。 <br><br><h4> 毫安 </h4><br>  <code>m{letter}</code>将标记放置在光标位置。 然后<code>'{letter}</code>将转到此行。 对于小写字母，它作用在缓冲区上，因此适合导航。 它在全局上适用于大写字母：即使您在另一个文件中， <code>'A</code>也会转到标有<code></code>的文件中” <code></code> 您可以使用命令<code>:marks:</code>查看所有标签<code>:marks:</code> <br><br><h4>  ctrl-A和ctrl-X </h4><br> 在光标位置或其右侧的行中增加和减少下一个数字。 由于它会立即显示数字，因此可以在任何地方使用该组合。  <code>10c-A</code>比<code>wwwwwciw20</code>简单得多。 <br><br><h4> 问： </h4><br> 打开以前团队的历史。 您可以像处理任何Vim文本一样使用它，但是不会保存更改。 但是，您可以使用<code>&lt;CR&gt;</code>运行修改后的命令。 这使您可以非常快速地更改和重新启动命令，或查找旧命令以供重用。 <br><br><h4>  q /，q？ </h4><br> 与<code>q:</code>相同，但搜索除外。 <br><br><h4>  Ctrl-I，Ctrl-O </h4><br> 移动到跳转列表中的下一个或上一个位置。 用于快速检查然后回溯。 读取帮助文件非常好。 <br><br><h2> 巨集 </h2><br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇文章</a> ，以更深入地了解宏的使用。 <br><br><h2> 视觉模式 </h2><br><h4>  gv </h4><br> 选择上一个视觉项目。 <br><br><h4>  v_o </h4><br> 转到可视块的另一侧。 如果您开始的行太低或类似的情况很有用。 在块模式下，它将变为相反的对角，并使用<code>v_O</code>切换到相反的<code>v_O</code> 。 <br><br><h4>  g ctrl-A / ctrl-X </h4><br> 在可视模式下，Ctrl-A只是增加每行的第一个数字。 另一方面， <code>g ctrl-A</code>每行将增加一行。 在表中更容易解释： <br><br><div class="scrollable-table"><table><thead><tr><th>  <strong>已选</strong> </th><th> <code>ctrl-A</code> </th> <th> <code>g ctrl-A</code> </th> <th> <code>2 g ctrl-A</code> </th> </tr></thead><tbody><tr><td><pre>  0
 00
 ç
 0天 </pre></td><td><pre>  1
 11
 ç
 1天 </pre></td><td><pre>  1
 b 2
 ç
 3天 </pre></td><td><pre> 一个2
 b 4
 ç
第6天 </pre></td></tr></tbody></table></div><br><h4> 运算子：v，V，cv（：h o_v） </h4><br> 您可能知道，在可视模式下可以选择字符（v），行（V）和块（ctrl-V）。 但是这三个组合可以用作相应片段的运动运算符。 例如，您具有以下文本： <br><br> <code>abc <br> abc <br> abc</code> <br> <br> 如果将光标放在顶部<code>b</code>并按<code>d2j</code> ，它将删除所有三行，因为<code>j</code>逐行移动。 如果改为按<code>d&lt;cV&gt;2j</code> ，则移动将逐块进行，仅删除带有三个字母<code>b</code>的中间列。 <br><br> 一种用例是在搜索中删除。 正常<code>d/</code>逐个字符移动。 因此，我将<code>dV/</code>用于逐行删除运动。 还有另一种方法： <br><br><h4>  /正则表达式/ {n} </h4><br> 在匹配项下移动n行，如果该值为负，则向上移动多行。 作为副作用，移动是逐行发生的。 因此，如果要删除与<code>regex</code>对应的第一行， <code>regex</code>可以输入<code>d/regex//0</code> 。 <br><br><h2> 前队 </h2><br> 您可以在命令模式下输入前命令，例如，命令<code>:s</code> 。 除了替换以外，还有许多其他有用的命令。 所有这些示例都需要一个范围，例如<code>%</code> 。 <br><br><h4>  ：g / regex / ex </h4><br> 仅在与正则表达式匹配的行上运行命令。 例如，您可以输入<code>g/regex/d</code>删除所有与regex匹配的行。  <code>v</code>命令类似于<code>g</code> ，但可在所有<i>不</i>匹配正则表达式的行上使用。 <br><br> 技巧随着规范和其他方面变得更加强大。 <br><br><h4>  ：规范{Vim} </h4><br> 就像您在范围的每一行上运行{Vim}一样。 例如， <code>g/regex/norm f dw</code>将删除与regex正则表达式对应的每一行中第一个空格之后的第一个单词。 这通常比宏简单得多。 <br><br>  <code>norm</code>遵循您的所有比较。 例如，如果您在插入模式下将<code>jk</code>分配给<code>&lt;esc&gt;</code> ，则<code>norm I jk$diw</code>将<code>norm I jk$diw</code>的开头添加一个空格， <i>离开insert模式</i> ，然后删除该行的最后一个单词。 我真的很喜欢此功能，但是如果您不想使用映射，则可以应用<code>norm!</code>  。 <br><br><h4>  ：公司 </h4><br> 将范围复制到当前行。 您还可以指定任意值而不是句点，例如<code>+3</code>或<code>'a. mv</code>  <code>'a. mv</code>移动。 <br><br><h4>  ：y {reg} </h4><br> 将范围复制到<code>{reg}</code>寄存器。 如果<code>{reg}</code>大写，则将其添加到现有案例中。 即这样的团队 <br><br> <code>let @a = '' | %g/regex/y A</code> <br> <br> 将复制到整个文件中与<code>regex</code>对应<code>a</code>所有行。 这有助于从文件中提取损坏的文本并将其复制到系统剪贴板（使用<code>let @+ = @a</code> ）。 <br><br><h4>  ：windo {ex} </h4><br> 在所有窗口中运行命令。 例如<code>:windo $</code>向下<code>:windo $</code>所有窗口。 有<code>bufdo</code> ， <code>cdo</code> ， <code>tabdo</code>等。 <br><br> 与<code>g</code>和<code>s</code>配合得很好。 要将所有<code>AA</code>组合替换为<code>BB</code>并提供替换预览，您可以通过将所有匹配项加载到quickfix中来输入<code>vimgrep AA</code> ，然后使用<code>cdo s/AA/BB/cge</code>搜索/替换所有匹配项。 <br><br><h2>  Vim的扩展 </h2><br> 这里列出了一些技巧，需要保存设置或更改Vim会话。 假设地，它们可以仅通过输入命令就可以在“清教徒”模式下使用，但是有些涉及相当严重的变化，与清教徒的精神背道而驰。 <br><br> 这只是最不寻常的。 许多人将<code>H</code>分配给cap <code>^</code> ，所以这些事情不值得一提。 另外，谈论<code>vim-sensible</code>或<code>vim-surround</code>毫无意义，而只谈论更多奇特的插件。 <br><br> 如果您一直在配置vimrc，请您自己做，并为此添加一个单独的命令： <br><br> <code>command! Vimrc :vs $MYVIMRC</code> <br> <br><h2> 设定值 </h2><br> 我将所有设置，按键绑定和功能存储在单个vimrc文件中。 拆分成多个文件使搜索变得困难。 <br><br> 大多数设置实际上并不是任何“技巧”。 最好看一下适合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vim的内容</a> ：几乎所有在那里的设置都适合您的vimrc。 <br><br><h4> 设置lazyredraw </h4><br> 不要在宏中间重画屏幕（以提高性能）。 <br><br><h4> 设置smartcase / ignorecase </h4><br> 使用这两个设置，不使用大写字母的搜索将不区分大小写，而使用大写字母的搜索将区分大小写。 <br><br><h4> 设置撤消文件 </h4><br> 即使关闭并打开Vim，也要保存操作，以使撤消操作始终可用。 与undotree插件结合使用非常方便。 <br><br><h4> 设置foldcolumn = {n} </h4><br> 带有折叠块的侧柱。  <code>n</code>越大，该列中折叠的块越多，其余数字则用数字表示。 <br><br><h4>  set suffixesadd = {str} </h4><br>  <code>gf</code>通常表示“转到光标下的文件”，但该行中需要文件扩展名。  <code>suffixesadd</code>添加指定的扩展名。 如果<code>suffixesadd=.md</code> ，则在'foo'行上的<code>gf</code>命令将查找文件<code>foo</code>和<code>foo.md</code> <br><br><h4> 设置inccommand = nosplit </h4><br> 仅适用于Neovim。  <code>incommand</code>实时显示团队将进行哪些更改。 当前仅支持<code>s</code> ，但即使这样也非常有用。 如果输入<code>:s/regex</code> ， <code>:s/regex</code>所有匹配项都突出显示。 如果您随后添加<code>/change</code> ，它将显示所有替换项。 适用于所有正则表达式属性，包括反向链接和组。 <br><br><h3> 设置状态行（：h状态行） </h3><br> 确定在每个窗口底部的面板中显示什么。 与其他设置相比，此处的格式要复杂得多，而且比较挑剔，因此您必须花一些时间来解释它。 有一些简单的技巧。 首先，查看默认的Vim状态栏： <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P</code> <br> <br> 在这里，最容易替换<code>%P</code> （光标上的文件百分比）。 状态栏格式是百分号后的值。 因此，对于Markdown文件，您可以这样编写： <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %{wordcount()[\"words\"]}</code> <br> <br> 并用文档中的单词数替换文件的百分比。 <br><br> 或安装<code>tabline</code> 。 如果您不使用制表符，则可以将该行设置为“全局状态行”。 举个例子 <br><br> <code>set tabline=%{strftime('%c')}</code> <br> <br> 将始终在顶部显示日期。 <br><br><h2> 按键绑定 </h2><br> 我有<i>很多</i>绑定。 <br><br> 默认情况下，愚蠢地分配了Vim中许多方便的键。 例如，保存击键<code>s</code>与<code>cl</code> （保存一个击键）是同义词，并且<code>U</code>与<code>u</code>相同，除了将undo作为新更改写入，这在功能上是无用的。  <code>Q</code>与<code>gQ</code>相同，并且在任何情况下都是一个巨大的陷阱。  <code>Z</code>仅用于<code>ZZ</code>和<code>ZQ</code> 。 天哪，甚至Vim手册也建议将<code>_</code>和键重新分配给某些功能，因为“您可能永远不会使用它们”。 我不想保存一键，而是要向键盘添加全新的功能。 这是我的一些绑定： <br><br><h4>  nnoremap Q @@ </h4><br> 在不减慢向ex模式的过渡的情况下，重复最后一个宏。 <br><br><h4>  nnoremap s“ _d </h4><br> 它使<code>s</code>键（具有<code>ss</code>和<code>S</code>的适当设置）的工作方式与d相似，只是不将已删除的文本保存在寄存器中。 有用以免阻塞寄存器。 <br><br><h4>  nnoremap &lt;cj&gt; &lt;cw&gt; j </h4><br> 转到下面的窗口。  <code>h</code> ， <code>k</code> ， <code>l</code>适当分配。 使用Windows更容易。 <br><br><h4>  nnoremap &lt;leader&gt; e：exe getline（行（'。'））&lt;cr&gt; </h4><br> 像命令一样运行当前行。 在实验中，它通常比<code>q:</code>更方便<code>q:</code> <br><br><h2> 特殊参数（：h map-arguments） </h2><br>  <code>map &lt;buffer&gt; lhs rhs</code>激活此缓冲区的键映射。 它确实可以方便地与自动命令一起用作临时键组合，或者在通过函数定义分配时使用。 缓冲区分配优先于全局分配，也就是说，您可以覆盖在特定情况下更有用的常规命令。 <br><br>  <code>map &lt;expr&gt; {lhs} {expr}</code>检查<code>{expr}</code>并将返回值用作键的最终重映射。 一个简单的用例是根据条件进行绑定。 我有这些： <br><br> <code>nnoremap &lt;expr&gt; k (v:count == 0 ? 'gk' : 'k') <br> nnoremap &lt;expr&gt; j (v:count == 0 ? 'gj' : 'j')</code> <br> <br> 这使得<code>j</code>和<code>k</code>沿着直线移动， <i>直到</i>找到<i>一个</i>数字，然后取消该键。 因此，我可以浏览散文的较长段落而不会破坏<code>10j</code>组合。 <br><br>  <code>&lt;silent&gt;</code>参数有助于在任何绑定中运行ex命令。 <br><br><h2>  inoremaps </h2><br> 感谢<code>inoremap</code>绑定可以在插入模式下工作。 他们在那里开始工作，因此是<code>inoremap ;a aaaa</code>将引入'aaaa'而不是'; a'。 如果要在普通模式下执行某些操作，请使用<code>&lt;cO&gt;</code> 。 例如，如果我们有 <br><br> <code>inoremap ;1 &lt;co&gt;ma</code> <br> <br> 然后<code>;1</code>设置<code>'a</code> 。 <br><br> 我喜欢指定使用分号作为重新分配的键，因为在普通文本中，分号后几乎总是有空格或换行符。 <br><br><h2> 自动命令 </h2><br> 自动命令非常适合配置。 通常，您可以这样配置它们： <br><br><pre> <code class="plaintext hljs">augroup {name} autocmd! " Prevents duplicate autocommands au {events} {file regex} {command} augroup END</code> </pre> <br> 然后，如果{file regex}文件中发生任何{events}事件，则将触发{command}命令。 事件被列出<code>:h event</code> 。 例如，如果您写 <br><br><pre> <code class="plaintext hljs">augroup every autocmd! au InsertEnter * set norelativenumber au InsertLeave * set relativenumber augroup END</code> </pre> <br> 然后vim将仅在插入模式下禁用relativenumber。 <br><br>  <code>au {event} &lt;buffer&gt; {ex}</code>命令仅将auto命令应用于当前缓冲区。 有时，我使用它向特定文件添加短期事件处理程序。 <br><br><h3>  BufNewFile，BufRead </h3><br>  <code>BufnewFile</code>在创建新文件<code>BufnewFile</code>时启动-首次打开缓冲区时。 它们通常用于向特定文件类型添加参数和重新映射。 我有一个这样的： <br><br><pre> <code class="plaintext hljs">augroup md autocmd! au BufNewFile,BufRead *.md syntax keyword todo TODO au BufNewFile,BufRead *.md inoremap &lt;buffer&gt; ;` ```&lt;cr&gt;&lt;cr&gt;```&lt;Up&gt;&lt;Up&gt; augroup END</code> </pre> <br> 仅在Markdown文件中突出显示TODO行，并且在插入模式下的字符<code>;`</code>会添加代码符号。 <br><br> 自动团队可以让您做更复杂的事情。 例如，用于<code>BufWriteCmd</code> <code>au</code>会覆盖标准保存，从而允许您实现自定义逻辑。 这超出了“技巧”，而进入了“黑暗魔术”的领域。 <br><br><h2> 外挂程式 </h2><br> 大多数人都知道流行的插件，例如<code>vim-surround</code>和<code>NERDtree</code> 。 这是一些我认为非常有用的鲜为人知的列表。 <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">撤销树</a> </h3><br> 在大多数文本编辑器中，撤消操作是线性发生的。 如果对A进行更改，请撤消它，然后对B进行更改，那么A将永远丢失。 但是，Vim存储整个未完成操作的树。  <code>u</code>命令回滚当前树分支中的操作，并且<code>g</code>转到先前的<i>时间顺序</i>版本。 您可以使用以下命令查看已取消操作的列表<code>:undolist</code> 。 <br><br> 但是这种格式不是很清楚。 最好查看实际的树。 这正是<code>Undotree</code>所做的：它以便捷的导航方式对取消的动作树进行了良好的ASCII表示。 <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交换</a> </h3><br> 该插件提供用于交换参数的命令，因此您可以通过几次击键将<code>(a, f(b, c))</code>替换为<code>(f(b, c), a)</code> 。 我经常必须进行此类编辑，因此这是生活质量的重大改善。 <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新学期</a> </h3><br> 将更高级别的API连接到neo / vim嵌入式终端。 例如<code>:T {text}</code>将{text}发送到控制台。 非常适合创建交互式环境。 <br><br><h2>  “ TODO {{{ </h2><br> 本文不讨论许多主题，因为它们过于技术性或需要详细解释，例如函数编写或语法系统。 而且我了解不多。 我想更详细地研究以下主题： <br><br><h3> 预览，快速修复和列表窗口 </h3><br> 我有时会在这些窗口上使用工具，但是我不知道如何操作它们。 我想在我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TLA +插件中</a>添加quickfix错误。 我也喜欢将支持信息和回调命令放在预览窗口中的想法。 这提供了一些很难在IDE中重现的可能性。 <br><br><h2>  Neovim API </h2><br>  Neovim提供了用于将Vim与外部程序集成的高级API。 您的Python脚本可以将命令发送到Neovim实例，例如，您可以通过服务器控制编辑器。 我看到了一些很酷的概念演示，其中基于浏览器中的信息进行自动完成。 看起来很酷！ <br><br><h2> 文字对象 </h2><br> 从来没有创造这样的。 <br><br><hr><br> 因此，这是Vim某些隐式功能的简要概述。 希望您发现有用的东西！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454742/">https://habr.com/ru/post/zh-CN454742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454732/index.html">为IT团队提供的5种可靠的优先级排序技术</a></li>
<li><a href="../zh-CN454734/index.html">备份，第4部分：概述和测试zbackup，restic，borgbackup</a></li>
<li><a href="../zh-CN454736/index.html">在PVS-Studio中支持Visual Studio 2019</a></li>
<li><a href="../zh-CN454738/index.html">PVS-Studio中的Visual Studio 2019支持</a></li>
<li><a href="../zh-CN454740/index.html">2019年5月Joomla摘要</a></li>
<li><a href="../zh-CN454744/index.html">RigaDevDays会议的Java跟踪报告概述</a></li>
<li><a href="../zh-CN454748/index.html">MongoDB生存指南</a></li>
<li><a href="../zh-CN454750/index.html">Swift UI-在欧洲驰gall</a></li>
<li><a href="../zh-CN454754/index.html">什么时候值得检验有效性不减的假设？</a></li>
<li><a href="../zh-CN454756/index.html">检查网站的有效性和广告设置，吸引批发公司客户的成本</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>