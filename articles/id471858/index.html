<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âŒ ğŸ‘¸ğŸ¿ ğŸ‘¨â€ğŸš’ RabbitMQ vs Kafka: Kegagalan dan Ketersediaan Tinggi di Cluster ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ‘ğŸ½ ğŸ¤¶ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Toleransi kesalahan dan ketersediaan tinggi adalah topik besar, sehingga RabbitMQ dan Kafka akan mencurahkan artikel terpisah. Artikel ini tentang Rab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs Kafka: Kegagalan dan Ketersediaan Tinggi di Cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/471858/"><img src="https://habrastorage.org/webt/hr/j2/oy/hrj2oyxwqv8-wo-vpmagx_dwmia.jpeg"><br><br>  Toleransi kesalahan dan ketersediaan tinggi adalah topik besar, sehingga RabbitMQ dan Kafka akan mencurahkan artikel terpisah.  Artikel ini tentang RabbitMQ, dan yang berikutnya adalah tentang Kafka, dibandingkan dengan RabbitMQ.  Artikelnya panjang, jadi buat dirimu nyaman. <br><br>  Pertimbangkan strategi untuk toleransi kesalahan, konsistensi, dan ketersediaan tinggi (HA), serta pengorbanan yang harus dilakukan masing-masing strategi.  RabbitMQ dapat berjalan di sekelompok node - dan kemudian diklasifikasikan sebagai sistem terdistribusi.  Ketika datang ke sistem terdistribusi, kita sering berbicara tentang konsistensi dan aksesibilitas. <br><br>  Konsep-konsep ini menggambarkan bagaimana sistem berperilaku jika terjadi kegagalan.  Kegagalan koneksi jaringan, kegagalan server, kegagalan hard disk, tidak tersedianya server sementara karena pengumpulan sampah, kehilangan paket atau perlambatan koneksi jaringan.  Semua ini dapat menyebabkan kehilangan data atau konflik.  Ternyata hampir tidak mungkin untuk meningkatkan sistem yang keduanya sepenuhnya konsisten (tanpa kehilangan data, tanpa perbedaan data), dan dapat diakses (akan menerima operasi baca dan tulis) untuk semua jenis kegagalan. <br><a name="habracut"></a><br>  Kita akan melihat bahwa konsistensi dan aksesibilitas berada di ujung spektrum yang berbeda, dan Anda perlu memilih cara mana untuk mengoptimalkan.  Berita baiknya adalah bahwa dengan RabbitMQ pilihan seperti itu dimungkinkan.  Anda memiliki semacam leverage "Nerd" untuk menggeser keseimbangan menuju koherensi yang lebih besar atau aksesibilitas yang lebih besar. <br><br>  Kami akan memberikan perhatian khusus pada konfigurasi apa yang menyebabkan hilangnya data karena catatan yang dikonfirmasi.  Ada rantai tanggung jawab antara penerbit, broker, dan konsumen.  Setelah pesan dikirimkan ke broker, tugasnya adalah untuk tidak kehilangan pesan.  Ketika pialang mengkonfirmasi kepada penerbit penerimaan pesan, kami tidak berharap itu hilang.  Tetapi kami akan melihat bahwa ini benar-benar dapat terjadi tergantung pada konfigurasi broker dan penerbit Anda. <br><br><h1>  Primitif stabilitas satu node </h1><br><h3>  Antrian / Routing Berkelanjutan </h3><br>  Ada dua jenis antrian di RabbitMQ: tahan lama / tidak tahan lama.  Semua antrian disimpan dalam basis data Mnesia.  Antrian persisten dideklarasikan ulang ketika node mulai dan dengan demikian selamat dari restart, sistem crash, atau server crash (selama data disimpan).  Ini berarti bahwa saat Anda mendeklarasikan perutean (pertukaran) dan antrian tangguh, infrastruktur antrian / perutean akan kembali ke mode online. <br><br>  Antrian dan perutean yang mudah dihapus dihapus ketika host memulai kembali. <br><br><h3>  Posting persisten </h3><br>  Hanya karena antriannya panjang tidak berarti bahwa semua pesannya akan selamat dari simpul restart.  Hanya pesan yang ditetapkan oleh penerbit sebagai persisten yang akan dipulihkan.  Pesan yang terus-menerus memang membuat beban tambahan pada broker, tetapi jika kehilangan pesan tidak dapat diterima, maka tidak ada cara lain. <br><br><img src="https://habrastorage.org/webt/hl/nv/gv/hlnvgvt20t-fbikkajwnkirflyo.png"><br>  <i>Fig.</i>  <i>1. Matriks stabilitas</i> <br><br><h1>  Antrian Mirroring Clustering </h1><br>  Untuk bertahan dari kehilangan broker, kita perlu redundansi.  Kita bisa menggabungkan beberapa node RabbitMQ menjadi sebuah cluster, dan kemudian menambahkan redundansi tambahan dengan mereplikasi antrian di antara beberapa node.  Dengan demikian, jika satu node jatuh, kami tidak kehilangan data dan tetap tersedia. <br><br>  Mirroring Antrian: <br><br><ul><li>  satu antrian utama (master), yang menerima semua perintah tulis dan baca <br></li><li>  satu atau lebih mirror yang menerima semua pesan dan metadata dari antrian utama.  Cermin ini tidak ada untuk penskalaan, tetapi hanya untuk redundansi. </li></ul><br><img src="https://habrastorage.org/webt/am/-b/ol/am-boljly334-fiqfajsoowe3iu.png"><br>  <i>Fig.</i>  <i>2. Mencerminkan antrian</i> <br><br>  Mirroring diatur oleh kebijakan yang sesuai.  Di dalamnya, Anda dapat memilih tingkat replikasi dan bahkan node di mana antrian harus ditempatkan.  Contoh: <br><br><ul><li><code>ha-mode: all</code> <br> </li><li>  <code>ha-mode: exactly, ha-params: 2</code> (satu master dan satu mirror) <br></li><li> <code>ha-mode: nodes, ha-params: rabbit@node1, rabbit@node2</code> </li> </ul><br><h1>  Konfirmasi kepada penerbit </h1><br>  Untuk mencapai rekaman berurutan, Konfirmasi Penerbit harus dikonfirmasi.  Tanpa mereka, ada kemungkinan kehilangan pesan.  Konfirmasi dikirim ke penerbit setelah menulis pesan ke disk.  RabbitMQ menulis pesan ke disk bukan pada saat diterima, tetapi secara berkala, di wilayah beberapa ratus milidetik.  Ketika antrian dicerminkan, konfirmasi dikirim hanya setelah semua mirror juga menulis salinan pesan mereka ke disk.  Ini berarti bahwa penggunaan ucapan terima kasih menambah keterlambatan, tetapi jika keamanan data penting, maka itu perlu. <br><br><h1>  Antrian Failover </h1><br>  Ketika broker dimatikan atau crash, semua antrian (master) terkemuka pada simpul ini jatuh bersamanya.  Cluster kemudian memilih cermin tertua dari masing-masing master dan mempromosikannya sebagai master baru. <br><br><img src="https://habrastorage.org/webt/pq/v_/_a/pqv__ahffpye5i6h_2pdzozyrgi.png"><br>  <i>Fig.</i>  <i>3. Beberapa antrian cermin dan kebijakan mereka</i> <br><br>  Broker 3 tetes.  Perhatikan bahwa mirror Antrian C pada Broker 2 ditingkatkan ke master.  Perhatikan juga bahwa mirror baru telah dibuat untuk Antrian C pada Broker 1. RabbitMQ selalu berusaha untuk mempertahankan tingkat replikasi yang ditentukan dalam kebijakan Anda. <br><br><img src="https://habrastorage.org/webt/df/e7/la/dfe7laf8pyg0pobmrkgteky-wsw.png"><br>  <i>Fig.</i>  <i>4. Broker 3 jatuh, menyebabkan antrian C gagal</i> <br><br>  Broker 1 berikutnya jatuh!  Kami hanya memiliki satu broker yang tersisa.  Cermin Antrian B naik ke master. <br><br><img src="https://habrastorage.org/webt/b2/bd/qi/b2bdqi_lz21qoe8hcdmsjy8g5kc.png"><br>  <i>Fig.</i>  <i>5</i> <br><br>  Kami mengembalikan Broker 1. Tidak peduli seberapa berhasil data selamat dari kehilangan dan pemulihan broker, semua pesan antrian cermin dibuang setelah dimulai ulang.  Ini penting untuk dicatat, karena akan ada konsekuensinya.  Kami akan segera mempertimbangkan konsekuensi ini.  Dengan demikian, Broker 1 sekarang menjadi anggota cluster, dan cluster berusaha untuk mematuhi kebijakan dan karenanya menciptakan mirror pada Broker 1. <br><br>  Dalam hal ini, hilangnya Broker 1 selesai, serta data, sehingga Antrian D yang tidak mirroring benar-benar hilang. <br><br><img src="https://habrastorage.org/webt/wi/ql/68/wiql68dzsoerzuibhspllun85ec.png"><br>  <i>Fig.</i>  <i>6. Broker 1 kembali beroperasi</i> <br><br>  Broker 3 kembali online, jadi jalur A dan B membuat mirror dibuat kembali sesuai dengan kebijakan HA mereka.  Tapi sekarang semua jalur utama ada di satu simpul!  Ini tidak ideal, distribusi seragam antara node lebih baik.  Sayangnya, tidak ada opsi khusus untuk menyeimbangkan master.  Kami akan kembali ke masalah ini nanti, karena kami harus mempertimbangkan sinkronisasi antrian terlebih dahulu. <br><br><img src="https://habrastorage.org/webt/bg/hj/4n/bghj4n6pdd5ki4oideq7zbwmasi.png"><br>  <i>Fig.</i>  <i>7. Broker 3 kembali beroperasi.</i>  <i>Semua antrian utama pada satu simpul!</i> <br><br>  Dengan demikian, Anda sekarang harus memiliki ide tentang bagaimana mirror memberikan redundansi dan toleransi kesalahan.  Ini memastikan ketersediaan jika terjadi kegagalan simpul tunggal dan melindungi terhadap kehilangan data.  Tapi kami belum selesai, karena pada kenyataannya semuanya jauh lebih rumit. <br><br><h1>  Sinkronkan </h1><br>  Saat membuat cermin baru, semua pesan baru akan selalu direplikasi ke cermin ini dan yang lainnya.  Sedangkan untuk data yang ada dalam antrian utama, kita dapat mereplikasi dalam mirror baru, yang menjadi salinan master lengkap.  Kami juga tidak dapat mereplikasi pesan yang ada dan memungkinkan antrian utama dan mirror baru untuk menyatu pada waktunya ketika pesan baru tiba di ekor dan pesan yang ada meninggalkan kepala antrian utama. <br><br>  Sinkronisasi ini dilakukan secara otomatis atau manual dan dikendalikan menggunakan kebijakan antrian.  Pertimbangkan sebuah contoh. <br><br>  Kami memiliki dua garis cermin.  Antrian A menyinkronkan secara otomatis, dan Antrian B secara manual.  Kedua baris masing-masing memiliki sepuluh pesan. <br><br><img src="https://habrastorage.org/webt/vz/zm/5x/vzzm5x_2w3tphqi09kn6h_9_e1c.png"><br>  <i>Fig.</i>  <i>8. Dua antrian dengan mode sinkronisasi yang berbeda</i> <br><br>  Sekarang kita kehilangan Broker 3. <br><br><img src="https://habrastorage.org/webt/5x/wp/ki/5xwpki1aoj_-e1hdt0i-gswn-nu.png"><br>  <i>Fig.</i>  <i>9. Broker 3 jatuh</i> <br><br>  Broker 3 kembali beroperasi.  Cluster menciptakan cermin untuk setiap antrian pada node baru dan secara otomatis menyinkronkan Antrian A baru dengan master.  Namun, cermin dari Turn B yang baru tetap kosong.  Dengan demikian, kami memiliki redundansi lengkap untuk Antrian A dan hanya satu cermin untuk pesan Antrian B. <br><br><img src="https://habrastorage.org/webt/zo/hb/ha/zohbhaicbgsjdynexgjhuh70ujg.png"><br>  <i>Fig.</i>  <i>10. Mirror baru dari Queue A menerima semua pesan yang ada, tetapi mirror baru dari Queue B tidak</i> <br><br>  Kedua baris menerima sepuluh pesan lagi.  Kemudian Broker 2 jatuh, dan Queue A kembali ke mirror tertua, yang terletak di Broker 1. Jika terjadi kegagalan, tidak ada kehilangan data.  Ada dua puluh pesan dalam Antrian B di wisaya dan hanya sepuluh di cermin, karena antrian ini tidak pernah mereplikasi sepuluh pesan asli. <br><br><img src="https://habrastorage.org/webt/yy/hc/sz/yyhcszfowfi6eiidhubgqfy1zry.png"><br>  <i>Fig.</i>  <i>11. Jalur A digulung kembali ke Broker 1 tanpa kehilangan pesan</i> <br><br>  Kedua baris menerima sepuluh pesan lagi.  Broker 1 sekarang macet. Antrian A beralih ke cermin tanpa masalah tanpa kehilangan pesan.  Namun, Antrian B memiliki masalah.  Pada titik ini, kita dapat mengoptimalkan aksesibilitas atau konsistensi. <br><br>  Jika kita ingin mengoptimalkan aksesibilitas, maka kebijakan <b><i>ha-promot-on-failure</i></b> harus ditetapkan <b><i>selalu</i></b> .  Ini adalah nilai default, jadi Anda bisa menghilangkan kebijakan sama sekali.  Dalam hal ini, pada kenyataannya, kami mengizinkan kegagalan pada mirror yang tidak disinkronkan.  Ini akan menyebabkan hilangnya pesan, tetapi antrian tetap dapat dibaca dan ditulis. <br><br><img src="https://habrastorage.org/webt/4h/hv/_n/4hhv_n4seyvz33pq_sk3my2bnmk.png"><br>  <i>Fig.</i>  <i>12. Jalur A digulung kembali ke Broker 3 tanpa kehilangan pesan.</i>  <i>Jalur B kembali ke Broker 3 dengan hilangnya sepuluh pesan</i> <br><br>  Kami juga dapat mengatur <code>ha-promote-on-failure</code> menjadi <code>when-synced</code> .  Dalam hal ini, alih-alih memutar kembali ke cermin, antrian akan menunggu sampai Broker 1 dengan datanya kembali ke mode online.  Setelah kembali, antrian utama kembali muncul di Broker 1 tanpa kehilangan data.  Aksesibilitas dikorbankan untuk keamanan data.  Tapi ini adalah mode berisiko, yang bahkan dapat menyebabkan hilangnya data, yang akan kami pertimbangkan dalam waktu dekat. <br><br><img src="https://habrastorage.org/webt/fk/mx/gx/fkmxgxilgyi8bp_n_-osz6q8be0.png"><br>  <i>Fig.</i>  <i>13. Jalur B tetap tidak tersedia setelah kehilangan Pialang 1</i> <br><br>  Anda dapat mengajukan pertanyaan: "Mungkin lebih baik tidak pernah menggunakan sinkronisasi otomatis?".  Jawabannya adalah sinkronisasi adalah operasi pemblokiran.  Selama sinkronisasi, antrian utama tidak dapat melakukan operasi baca atau tulis! <br><br>  Pertimbangkan sebuah contoh.  Sekarang kami memiliki garis yang sangat panjang.  Bagaimana mereka bisa tumbuh dengan ukuran ini?  Karena beberapa alasan: <br><br><ul><li>  Antrian tidak digunakan secara aktif. <br></li><li>  Ini adalah jalur kecepatan tinggi, dan saat ini konsumen lambat <br></li><li>  Ini adalah antrian berkecepatan tinggi, kegagalan telah terjadi dan konsumen mengejar ketinggalan </li></ul><br><img src="https://habrastorage.org/webt/es/6q/gy/es6qgy7p-1cu0avxb1xivijyjii.png"><br>  <i>Fig.</i>  <i>14. Dua antrian besar dengan mode sinkronisasi yang berbeda</i> <br><br>  Sekarang Broker 3 mogok. <br><br><img src="https://habrastorage.org/webt/vg/ta/ue/vgtauedea7kaitatv7oshzottps.png"><br>  <i>Fig.</i>  <i>15. Broker 3 jatuh, meninggalkan satu master dan cermin di setiap antrian</i> <br><br>  Broker 3 kembali, dan mirror baru dibuat.  Antrian Utama A mulai mereplikasi pesan yang ada ke mirror baru, dan selama ini, Antrian A tidak tersedia.  Replikasi data membutuhkan dua jam, menghasilkan dua jam downtime untuk Antrian ini! <br><br>  Namun, Jalur B tetap tersedia sepanjang seluruh periode.  Dia mengorbankan beberapa redundansi demi aksesibilitas. <br><br><img src="https://habrastorage.org/webt/qn/rd/ep/qnrdep5m7sszgxjesb_kfwuw-zw.png"><br>  <i>Fig.</i>  <i>16. Antrian tetap tidak tersedia selama sinkronisasi</i> <br><br>  Setelah dua jam, Antrian A juga tersedia dan dapat kembali menerima operasi baca dan tulis. <br><br><h3>  Pembaruan </h3><br>  Perilaku pemblokiran ini selama sinkronisasi membuatnya sulit untuk meningkatkan cluster dengan antrian yang sangat besar.  Pada titik tertentu, node dengan wizard perlu direstart, yang berarti beralih ke mirror atau mematikan antrian selama pembaruan server.  Jika kami memilih transisi, kami akan kehilangan pesan jika mirror tidak disinkronkan.  Secara default, selama pemutusan broker, transisi ke mirror yang tidak disinkronkan tidak dilakukan.  Ini berarti bahwa segera setelah broker kembali, kami tidak kehilangan pesan apa pun, satu-satunya kerusakan hanyalah antrian sederhana.  Calon <code>ha-promote-on-shutdown</code> diatur oleh kebijakan <code>ha-promote-on-shutdown</code> .  Anda dapat menetapkan salah satu dari dua nilai: <br><br><ul><li>  <code>always</code> = diaktifkan untuk beralih ke mirror yang tidak disinkronkan <br></li><li>  <code>when-synced</code> = beralih hanya ke cermin yang disinkronkan, jika tidak, antrian menjadi tidak dapat diakses untuk membaca dan menulis.  Antrian kembali segera setelah broker kembali </li></ul><br>  Dengan satu atau lain cara, dengan antrian yang besar, Anda harus memilih antara kehilangan data dan tidak dapat diaksesnya. <br><br><h3>  Ketika Ketersediaan Meningkatkan Keamanan Data </h3><br>  Sebelum membuat keputusan, satu komplikasi lagi harus diperhitungkan.  Meskipun sinkronisasi otomatis lebih baik untuk redundansi, bagaimana pengaruhnya terhadap keamanan data?  Tentu saja, berkat redundansi yang lebih baik, RabbitMQ cenderung kehilangan pesan yang ada, tetapi bagaimana dengan pesan baru dari penerbit? <br><br>  Di sini Anda perlu mempertimbangkan yang berikut: <br><ul><li>  Bisakah penerbit hanya mengembalikan kesalahan, dan layanan yang lebih tinggi atau pengguna akan mencoba lagi nanti? <br></li><li>  Bisakah penerbit menyimpan pesan secara lokal atau dalam database untuk mencoba lagi nanti? </li></ul><br>  Jika penerbit hanya dapat menjatuhkan pesan, maka, pada kenyataannya, meningkatkan aksesibilitas juga meningkatkan keamanan data. <br><br>  Dengan demikian, Anda perlu mencari keseimbangan, dan keputusan tergantung pada situasi tertentu. <br><br><h1>  Masalah dengan ha-promot-on-failure = saat-disinkronkan </h1><br>  Gagasan <i><b>ha-promot-on-failure</b></i> = <i><b>saat-disinkronkan</b></i> adalah bahwa kami mencegah beralih ke cermin yang tidak disinkronkan dan dengan demikian menghindari kehilangan data.  Antrian tetap tidak dapat diakses untuk membaca atau menulis.  Alih-alih, kami mencoba mengembalikan broker yang jatuh dengan data yang tidak rusak sehingga kembali berfungsi sebagai master tanpa kehilangan data. <br><br>  Tapi (dan ini besar tapi) jika broker kehilangan datanya, maka kita memiliki masalah besar: antriannya hilang!  Semua data hilang!  Bahkan jika Anda memiliki cermin yang pada dasarnya mengejar ketinggalan dengan antrian utama, cermin ini juga dibuang. <br><br>  Untuk menambahkan kembali sebuah node dengan nama yang sama, kami memberitahu cluster untuk melupakan node yang hilang (dengan perintah <i>rabbitmqctl forget_cluster_node</i> ) dan memulai broker baru dengan nama host yang sama.  Selama cluster mengingat simpul yang hilang, ia mengingat antrian lama dan cermin yang tidak disinkronkan.  Ketika sebuah cluster diberitahu untuk melupakan simpul yang hilang, antrian ini juga dilupakan.  Sekarang Anda perlu mendeklarasikannya kembali.  Kami kehilangan semua data, meskipun kami memiliki cermin dengan kumpulan data parsial.  Akan lebih baik untuk beralih ke cermin yang tidak disinkronkan! <br><br>  Oleh karena itu, sinkronisasi manual (dan kegagalan sinkronisasi) dalam kombinasi dengan <code>ha-promote-on-failure=when-synced</code> , menurut saya, cukup berisiko.  Dokumen mengatakan opsi ini ada untuk keamanan data, tapi itu pisau bermata dua. <br><br><h1>  Master Penyeimbang </h1><br>  Seperti yang dijanjikan, kita kembali ke masalah akumulasi semua master pada satu atau lebih node.  Ini dapat terjadi bahkan sebagai akibat dari bergulirnya pembaruan kluster bergulir.  Dalam sebuah cluster dengan tiga node, semua antrian utama akan terakumulasi pada satu atau dua node. <br><br>  Master Rebalancing dapat bermasalah karena dua alasan: <br><br><ul><li>  Tidak ada alat penyeimbang yang baik </li><li>  Sinkronisasi Antrian </li></ul><br>  Untuk penyeimbangan kembali, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin</a> pihak ketiga yang tidak didukung secara resmi.  Mengenai plug-in pihak ketiga, manual RabbitMQ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> : â€œPlug-in menyediakan beberapa konfigurasi tambahan dan alat pelaporan, tetapi tidak didukung dan tidak diuji oleh tim RabbitMQ.  Gunakan dengan risiko Anda sendiri. " <br><br>  Ada trik lain untuk memindahkan antrian utama melalui kebijakan HA.  Manual menyebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naskah</a> untuk ini.  Ia bekerja sebagai berikut: <br><br><ul><li>  Menghapus semua mirror menggunakan kebijakan sementara dengan prioritas lebih tinggi dari kebijakan HA yang ada. <br></li><li>  Mengubah kebijakan sementara HA untuk menggunakan mode node dengan node yang harus dipindahkan dari antrian utama. <br></li><li>  Menyinkronkan antrian untuk migrasi paksa. <br></li><li>  Setelah migrasi selesai, hapus kebijakan sementara.  Kebijakan awal HA mulai berlaku dan jumlah cermin yang diperlukan dibuat. </li></ul><br>  Kerugiannya adalah bahwa pendekatan ini mungkin tidak berfungsi jika Anda memiliki antrian yang besar atau persyaratan redundansi yang ketat. <br><br>  Sekarang mari kita lihat bagaimana cluster RabbitMQ bekerja dengan partisi jaringan. <br><br><h1>  Gangguan konektivitas </h1><br>  Node dari sistem terdistribusi dihubungkan oleh tautan jaringan, dan tautan jaringan dapat dan akan terputus.  Frekuensi pemadaman tergantung pada infrastruktur lokal atau keandalan cloud yang dipilih.  Bagaimanapun, sistem terdistribusi harus dapat menanganinya.  Sekali lagi kami memiliki pilihan antara aksesibilitas dan konsistensi, dan sekali lagi berita baiknya adalah bahwa RabbitMQ menyediakan keduanya (hanya saja tidak pada saat yang bersamaan). <br><br>  Dengan RabbitMQ, kami memiliki dua opsi utama: <br><br><ul><li>  Biarkan pemisahan logis (otak-terpisah).  Ini memberikan aksesibilitas, tetapi dapat menyebabkan kehilangan data. <br></li><li>  Larang pemisahan logis.  Dapat mengakibatkan hilangnya ketersediaan jangka pendek tergantung pada bagaimana klien terhubung ke cluster.  Hal ini juga dapat menyebabkan tidak dapat diaksesnya secara penuh dalam sekelompok dua node. </li></ul><br>  Tetapi apakah pemisahan logis itu?  Ini adalah ketika sebuah cluster terbelah dua karena kehilangan koneksi jaringan.  Di setiap sisi, cermin naik ke master, jadi pada akhirnya, ada beberapa master di setiap belokan. <br><br><img src="https://habrastorage.org/webt/mi/4f/bb/mi4fbbuk9maj487alkqsbbykkns.png"><br>  <i>Fig.</i>  <i>17. Garis utama dan dua mirror, masing-masing pada node yang terpisah.</i>  <i>Kemudian terjadi kegagalan jaringan dan satu cermin terpisah.</i>  <i>Node terpisah melihat bahwa dua lainnya jatuh, dan memajukan mirror-nya ke master.</i>  <i>Sekarang kami memiliki dua baris utama, dan keduanya memungkinkan menulis dan membaca.</i> <br><br>  Jika penerbit mengirim data ke kedua master, kami mendapatkan dua salinan antrian yang berbeda. <br><br>  Berbagai mode RabbitMQ menyediakan aksesibilitas atau konsistensi. <br><br><h3>  Mode abaikan (default) </h3><br>  Mode ini menyediakan aksesibilitas.  Setelah kehilangan konektivitas, pemisahan logis terjadi.  Setelah menyambung kembali, administrator harus memutuskan partisi mana yang lebih disukai.  Sisi yang hilang akan direstart, dan semua data yang terakumulasi dari sisi ini akan hilang. <br><br><img src="https://habrastorage.org/webt/ih/rj/ow/ihrjow-ceolx0wy8y2o-cn2yiuk.png"><br>  <i>Fig.</i>  <i>18. Tiga penerbit dikaitkan dengan tiga broker.</i>  <i>Secara internal, kluster meneruskan semua permintaan ke antrian utama di Broker 2.</i> <br><br>  Sekarang kita kehilangan Broker 3. Dia melihat bahwa broker lain telah jatuh, dan memindahkan cerminnya ke master.  Ini adalah pemisahan yang logis. <br><br><img src="https://habrastorage.org/webt/u_/l8/af/u_l8af-qqcyv4ldqdgwrn4t22ei.png"><br>  <i>Fig.</i>  <i>19. Pemisahan logis (split-otak).</i>  <i>Catatan masuk dalam dua baris utama, dan dua salinan berbeda.</i> <br><br>  Konektivitas dipulihkan, tetapi pemisahan logis tetap ada.  Administrator harus secara manual memilih sisi yang kalah.  Dalam kasus berikut, administrator me-reboot Broker 3. Semua pesan yang tidak berhasil ia kirimkan hilang. <br><br><img src="https://habrastorage.org/webt/_o/a9/ft/_oa9ftbuvl6dwnewtgfkrhkyva4.png"><br>  <i>Fig.</i>  <i>20. Administrator menonaktifkan Broker 3.</i> <br><br><img src="https://habrastorage.org/webt/ni/y_/xq/niy_xqsgzuvf5ktcta35z98zzxs.png"><br>  <i>Fig.</i>  <i>21. Administrator memulai Broker 3, dan ia bergabung dengan cluster, kehilangan semua pesan yang tersisa di sana.</i> <br><br>  Selama kehilangan konektivitas dan setelah pemulihannya, cluster dan antrian ini tersedia untuk membaca dan menulis. <br><br><h3>  Mode Autoheal </h3><br>  Ini bekerja mirip dengan mode Abaikan, kecuali bahwa cluster itu sendiri secara otomatis memilih sisi yang hilang setelah pemisahan dan memulihkan konektivitas.  Sisi yang hilang kembali ke cluster kosong, dan antrian kehilangan semua pesan yang dikirim hanya ke sisi itu. <br><br><h3>  Jeda Mode Minoritas </h3><br>  Jika kita tidak ingin mengizinkan pemisahan logis, maka satu-satunya pilihan kita adalah menolak untuk membaca dan menulis di sisi yang lebih kecil setelah partisi gugus.  Ketika seorang broker melihat bahwa dia berada di pihak yang lebih rendah, dia berhenti sebentar, yaitu, menutup semua koneksi yang ada dan menolak yang baru.  Sekali per detik, ia memeriksa koneksi ulang.  Setelah konektivitas dipulihkan, ia kembali berfungsi dan bergabung dengan cluster. <br><br><img src="https://habrastorage.org/webt/xl/cc/af/xlccafaylyx2nrsz5scaafo1h6u.png"><br>  <i>Fig.</i>  <i>22. Tiga penerbit dikaitkan dengan tiga broker.</i>  <i>Secara internal, kluster meneruskan semua permintaan ke antrian utama di Broker 2.</i> <br><br>  Kemudian Pialang 1 dan 2 dipisahkan dari Pialang 3. Alih-alih memutakhirkan cermin mereka ke master, Pialang 3 berhenti dan menjadi tidak dapat diakses. <br><br><img src="https://habrastorage.org/webt/8h/0_/hc/8h0_hc8vj99u6zaht7cgymlckve.png"><br>  <i>Fig.</i>  <i>23. Pialang 3 menjeda, memutus semua klien, dan menolak permintaan koneksi.</i> <br><br>  Setelah konektivitas dipulihkan, ia kembali ke cluster. <br><br>  Mari kita lihat contoh lain, di mana jalur utama ada di Broker 3. <br><br><img src="https://habrastorage.org/webt/rs/0s/if/rs0siffyxwpdc8imasvfvkapykw.png"><br>  <i>Fig.</i>  <i>24. Jalur utama di Broker 3.</i> <br><br>  Kemudian hilangnya konektivitas yang sama terjadi.  Broker 3 berhenti karena berada di sisi yang lebih kecil.  Di sisi lain, node melihat bahwa Broker 3 telah jatuh, sehingga cermin yang lebih tua dari Broker 1 dan 2 naik ke master. <br><br><img src="https://habrastorage.org/webt/ba/o3/gr/bao3gr7y31x5ljbbpkqkretaaty.png"><br>  <i>Fig.</i>  <i>25. Transisi ke Broker 2 jika Broker 3 tidak tersedia.</i> <br><br>  Ketika konektivitas dipulihkan, Broker 3 akan bergabung dengan kluster. <br><br><img src="https://habrastorage.org/webt/3z/rp/3k/3zrp3knvfoew7m25bg6bg4dlhju.png"><br>  <i>Fig.</i>  <i>26. Cluster kembali ke operasi normal.</i> <br><br>  Penting untuk dipahami bahwa kami mendapatkan konsistensi, tetapi kami juga dapat memperoleh aksesibilitas <i><b>jika kami</b></i> berhasil mentransfer klien ke sebagian besar bagian.  Untuk sebagian besar situasi, saya pribadi akan memilih mode Jeda Minoritas, tetapi itu benar-benar tergantung pada kasus tertentu. <br><br>  Untuk memastikan ketersediaan, penting untuk memastikan bahwa klien berhasil terhubung ke situs.  Pertimbangkan opsi kami. <br><br><h1>  Konektivitas Pelanggan </h1><br>  Kami memiliki beberapa opsi untuk bagaimana, setelah kehilangan konektivitas, mengirim klien ke bagian utama cluster atau ke node yang berfungsi (setelah kegagalan satu node).  Pertama, mari kita ingat bahwa antrian tertentu di-host pada host tertentu, tetapi perutean dan kebijakan direplikasi pada semua host.  Klien dapat terhubung ke simpul apa pun, dan perutean internal akan mengarahkan mereka jika perlu.  Tetapi ketika sebuah node ditangguhkan, ia menolak koneksi, sehingga klien harus terhubung ke node lain.  Jika sebuah simpul jatuh, ia dapat melakukan sedikit sekali. <br><br>  Pilihan kami: <br><br><ul><li>  Cluster diakses menggunakan penyeimbang beban, yang hanya siklus melalui node dan klien melakukan upaya berulang untuk menghubungkan sampai mereka berhasil diselesaikan.      ,        ,        (  ).         ,    . <br></li><li>         /   ,    .    ,        ,     . <br></li><li>      ,          .       ,       ,   . <br></li><li>    /    DNS.      TTL. </li></ul><br><h1>  Kesimpulan </h1><br>   RabbitMQ    .      , : <br><br><ul><li>        ; <br></li><li>      . </li></ul><br>         .   RabbitMQ      ,     .        ,     .         RabbitMQ        .      RabbitMQ     : <br><br><ul><li>  . <br></li><li>  . <br></li><li>   . </li></ul><br>      ,   : <br><br><ul><li> <code>ha-promote-on-failure=always</code> <br> </li><li> <code>ha-sync-mode=manual</code> <br> </li><li> <code>cluster_partition_handling=ignore</code> ( <code>autoheal</code> ) <br></li><li>   <br></li><li> ,      ,  -     </li></ul><br>   ( )   : <br><br><ul><li> Publisher Confirms  Manual Acknowledgements    <br></li><li> <code>ha-promote-on-failure=when-synced</code> ,              !   <code>=always</code> . <br></li><li> <code>ha-sync-mode=automatic</code> (        ;  , ,       ) <br></li><li>  Pause Minority <br></li><li>   </li></ul><br>          ; ,      (,   ).        Shovel. <br><br>    - , ,  . <br><br> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,       RabbitMQ   Docker  Blockade,      ,    . <br><br>   : <br> â„–1 â€” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/company/itsumma/blog/416629</a> <br> â„–2 â€” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/company/itsumma/blog/418389</a> <br> â„–3 â€” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/company/itsumma/blog/437446</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471858/">https://habr.com/ru/post/id471858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471840/index.html">Mengapa pergi ke wawancara</a></li>
<li><a href="../id471844/index.html">5 alasan untuk mengunjungi EPAM INSIDER di Kazakhstan</a></li>
<li><a href="../id471852/index.html">Berita dari dunia OpenStreetMap No. 481 (10/01/2019 - 07/10/2019)</a></li>
<li><a href="../id471854/index.html">Heat Death 5G</a></li>
<li><a href="../id471856/index.html">Kami memecahkan semua 42 versi dari teka-teki ramuan Harry Potter</a></li>
<li><a href="../id471860/index.html">Pengurai pasak</a></li>
<li><a href="../id471862/index.html">Implementasi parser PEG</a></li>
<li><a href="../id471864/index.html">Generasi parser PEG</a></li>
<li><a href="../id471866/index.html">Visualisasi parser PEG</a></li>
<li><a href="../id471868/index.html">Genetika cinta: konflik antar gender sebagai dasar kerja sama dalam pasangan burung monogami</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>