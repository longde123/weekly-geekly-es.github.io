<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌍 🏂🏼 💆🏽 Fortgeschrittene Nutzung von Geeta oder wie man sechs Monate früher in den Ruhestand geht? 🍞 👩🏻‍🚒 👦🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich weiß nicht, in welcher Programmiersprache Sie schreiben, aber ich bin sicher, dass Sie Geet während der Entwicklung verwenden. Es gibt immer mehr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fortgeschrittene Nutzung von Geeta oder wie man sechs Monate früher in den Ruhestand geht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420529/"><p><img src="https://habrastorage.org/webt/g_/v7/lg/g_v7lgawugfumbtsi3edevsencc.png"></p><br><p> Ich weiß nicht, in welcher Programmiersprache Sie schreiben, aber ich bin sicher, dass Sie Geet während der Entwicklung verwenden.  Es gibt immer mehr Tools zur Unterstützung der Entwicklung, aber selbst beim kleinsten Testprojekt beginne ich immer mit dem Befehl <code>git init</code> .  Und während des Arbeitstages tippe ich durchschnittlich weitere 80 Teams ein, die sich auf dieses Versionskontrollsystem beziehen. </p><br><p>  Ich war sehr nervös, als ich anfing, die Zehn-Finger-Druckmethode neu zu lernen.  Am Ende war dies die beste Entscheidung, um Ihren persönlichen Workflow zu verbessern.  Zu den nächstwichtigsten Optimierungen gehört die Weiterentwicklung des Geeta. </p><br><p>  Viele Artikel über Gita wurden über Habr geschrieben, aber sie gehen nicht über die offizielle Dokumentation hinaus, und die Autoren schlagen vor, die Arbeit mit selbst hergestellten Krücken zu vereinfachen.  Ich bin sicher, dass es notwendig ist, das Geet an konkreten Beispielen von Aufgaben zu studieren und die Effizienz der Arbeit mit standardisierten Mitteln zu steigern. </p><br><h2 id="komu-budet-polezna-eta-statya">  Wer wird von diesem Artikel profitieren? </h2><br><p>  Haben Sie das Gita-Set des Gentlemans bereits gemeistert und sind Sie bereit, weiterzumachen?  Es gibt zwei Möglichkeiten: </p><br><ol><li>  <strong>Master abgekürzte Befehle - Aliase.</strong>  Sie sind fast immer mnemonisch und leicht zu merken.  Das Vergessen der ursprünglichen Befehle ist problematisch, ich tippe sie bei Bedarf einfach ein.  Außerdem bin ich nicht verwirrt, wenn ich beim Schreiben von Code etwas in der Gita überprüfe. </li><li>  <strong>Erfahren Sie mehr über zusätzliche Flaggen für Teams sowie deren Integration untereinander.</strong>  Ich verstehe, dass jemand das Schneiden hasst.  Auch für Sie enthält der Artikel interessantes Material - <em>wie Sie den Nutzen und die Bequemlichkeit der Befehlsausgabe erhöhen und nicht die trivialsten, aber in der Praxis häufig auftretenden Probleme lösen können</em> . </li></ol><br><p>  Wenden Sie heute ein paar Stunden auf die im Artikel beschriebenen Experimente auf und sparen Sie durch ungefähre Berechnungen sechs Monate Arbeitszeit. </p><br><p>  Willkommen bei Katze! </p><a name="habracut"></a><br><h2 id="podgotovka">  Vorbereitung </h2><br><p>  Unter Entwicklern ist der Standard für die <code>Bash</code> Alternative <code>Zsh</code> , eine fortschrittliche Software-Shell, die die Feinabstimmung unterstützt.  Und unter <code>Zsh</code> Benutzern besteht der Standard darin, <code>Oh My Zsh</code> , eine Reihe vordefinierter Einstellungen für <code>Zsh</code> .  Nachdem wir dieses Kit installiert haben, erhalten wir eine Reihe von Hacks, die die Community im Laufe der Jahre für uns gesammelt und entwickelt hat. </p><br><p>  Es ist sehr wichtig zu beachten, dass <code>Zsh</code> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mac</a> und sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows</a> <code>Zsh</code> ist. </p><br><p>  <strong>Installieren Sie <code>Zsh</code> und <code>Oh My Zsh</code></strong> </p><br><p>  Installieren Sie <code>Zsh</code> und <code>Oh My Zsh</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemäß den Anweisungen mit</a> einem Befehl: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># macOS brew install zsh zsh-completions &amp;&amp; sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" # Ubuntu, Debian, ... apt install zsh &amp;&amp; sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span></span></code> </pre> <br><p>  Da die Aufgabe darin besteht, <em>die Interaktion mit dem Geet</em> zu <em>optimieren</em> , werden wir <code>Zsh</code> einige Plug-Ins <code>Zsh</code> .  Öffnen Sie die <code>~/.zshrc</code> und fügen Sie der Liste <code>plugins</code> : </p><br><pre> <code class="hljs lisp">plugins=(<span class="hljs-name"><span class="hljs-name">git</span></span> gitfast)</code> </pre> <br><p>  Gesamt: </p><br><ul><li>  <code>git</code> - eine Reihe von Aliasen und Hilfsfunktionen; </li><li>  <code>gitfast</code> - verbesserte automatische Vervollständigung für Gita. </li></ul><br><p>  <strong><code>tig</code> Einstellung</strong> </p><br><p>  Der letzte Schliff ist die Installation des Dienstprogramms <code>tig</code> console: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># macOS brew install tig # Ubuntu, Debian, ... # https://jonas.github.io/tig/INSTALL.html</span></span></code> </pre> <br><p>  Wir werden weiter darüber reden. </p><br><h2 id="git-na-praktike">  Git in der Praxis </h2><br><p>  Der Umgang mit Geeta erfolgt am besten durch Lösen spezifischer Probleme.  Als nächstes betrachten wir Aufgaben aus der täglichen Praxis und Optionen für ihre bequeme Lösung.  Betrachten Sie dazu ein bestimmtes Repository mit Textdateien. </p><br><blockquote>  <strong>Die gelben Blöcke geben den Hauptalias zur Lösung des Problems aus dem Abschnitt an.</strong>  <strong>Lerne nur es und überlasse alles andere der allgemeinen Entwicklung.</strong> </blockquote><br><h3 id="proveryaem-sostoyanie-rabochey-direktorii">  Überprüfen Sie den Status des Arbeitsverzeichnisses </h3><br><p>  Beginnen wir mit der grundlegendsten Sache.  Wir haben ein wenig gearbeitet und jetzt wollen wir sehen, was im Arbeitsverzeichnis passiert: </p><br><pre> <code class="bash hljs">$ git status On branch master Changes to be committed: (use <span class="hljs-string"><span class="hljs-string">"git reset HEAD &lt;file&gt;..."</span></span> to unstage) new file: e.md Changes not staged <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit: (use <span class="hljs-string"><span class="hljs-string">"git add &lt;file&gt;..."</span></span> to update what will be committed) (use <span class="hljs-string"><span class="hljs-string">"git checkout -- &lt;file&gt;..."</span></span> to discard changes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> working directory) modified: b.md Untracked files: (use <span class="hljs-string"><span class="hljs-string">"git add &lt;file&gt;..."</span></span> to include <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> what will be committed) d.md</code> </pre> <br><p>  Der aktuelle Status aller Dateien wird ausführlich beschrieben, zusätzliche Handlungsanweisungen werden gegeben.  Es ist zunächst sehr nützlich, wenn Sie Geeta verwenden, aber für die tägliche Arbeit ist viel überflüssig.  Lassen Sie uns den Geräuschpegel mit zusätzlichen Tasten senken: </p><br><pre> <code class="bash hljs">$ git status -sb <span class="hljs-comment"><span class="hljs-comment">## master M b.md A e.md ?? d.md</span></span></code> </pre> <br><p>  Ja, wir befinden uns im Hauptzweig, haben die <code>b.md</code> ( <code>M-odified</code> ) geändert und zwei Dateien erstellt, wobei die erste dem Geeta-Index ( <code>A-dded</code> ) <code>A-dded</code> und die zweite aus dem Index entfernt wurde ( <code>??</code> ).  Kurz und klar. </p><br><p>  Es bleibt die endlose Eingabe dieses Befehls durch den Alias <em>" <strong>g</strong> it <strong>s</strong> tatus with <strong>b</strong> ranch"</em> zu optimieren: </p><br><blockquote>  <strong>Status des verkürzten Arbeitsverzeichnisses anzeigen</strong> <br><br><pre> <code class="bash hljs">$ gsb <span class="hljs-comment"><span class="hljs-comment"># git status -sb</span></span></code> </pre> <br></blockquote><br><h3 id="sozdayom-kommit">  Erstellen Sie ein Commit </h3><br><p>  Wir fahren fort. </p><br><p>  Natürlich können Sie Commits machen.  Aber versuchen wir, die Lösung dieser einfachen Aufgabe zu optimieren.  Fügen Sie alle Änderungen zum Index mit dem Alias <em>" <strong>g</strong> it <strong>a</strong> dd <strong>a</strong> ll" hinzu</em> : </p><br><pre> <code class="bash hljs">$ gaa <span class="hljs-comment"><span class="hljs-comment"># git add --all</span></span></code> </pre> <br><p>  Wir überprüfen, ob der Index genau das hat, was wir brauchen, indem wir den Alias <em>" <strong>g</strong> it <strong>d</strong> iff <strong>ca</strong> ched" verwenden</em> : </p><br><pre> <code class="diff hljs">$ gdca # git diff --cached diff --git a/b.md b/b.md index 698d533..cf20072 100644 --- a/b.md +++ b/b.md @@ -1,3 +1,3 @@ # Beta -Next step. +Next step really hard. diff --git a/d.md b/d.md new file mode 100644 index 0000000..9e3752e --- /dev/null +++ b/d.md @@ -0,0 +1,3 @@ +# Delta + +Body of article.</code> </pre> <br><p>  Hmm, Änderungen, die eine einzelne Aufgabe lösen, sollten in ein Commit fallen.  Hier sind die Änderungen beider Dateien in keiner Weise miteinander verbunden.  Lassen Sie uns <code>d.md</code> die Datei <code>d.md</code> mit dem Alias <em>" <strong>g</strong> it <strong>r</strong> eset <strong>u</strong> ndo"</em> aus dem Index <em>ausschließen</em> : </p><br><pre> <code class="hljs pgsql">$ gru d.md # git <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> <span class="hljs-comment"><span class="hljs-comment">-- d.md</span></span></code> </pre> <br><p>  Und erstellen Sie ein Commit mit dem Alias <em>" <strong>g</strong> it <strong>c</strong> ommit"</em> : </p><br><pre> <code class="hljs ruby">$ gc <span class="hljs-comment"><span class="hljs-comment"># git commit</span></span></code> </pre> <br><p>  Wir schreiben den Namen des Commits und speichern.  Und dann erstellen wir ein weiteres Commit für die Datei <code>d.md</code> bekannteren Befehl unter Verwendung des Alias <em>" <strong>g</strong> it <strong>c</strong> ommit <strong>m</strong> e <strong>s</strong> sa <strong>g</strong> e"</em> : </p><br><pre> <code class="bash hljs">$ gaa <span class="hljs-comment"><span class="hljs-comment">#    $ gcmsg "Add new file" # git commit -m "Add new file"</span></span></code> </pre> <br><p>  <strong>Und wir können ...</strong> </p><br><p>  ... geänderte Dateien aus dem Index mit einem Befehl festschreiben: </p><br><pre> <code class="bash hljs">$ gcam <span class="hljs-string"><span class="hljs-string">"Add changes"</span></span> <span class="hljs-comment"><span class="hljs-comment"># git commit -a -m "Add changes"</span></span></code> </pre> <br><p>  ... Änderungen durch Wörter anstelle von Zeilen sehen (sehr nützlich bei der Arbeit mit Text): </p><br><pre> <code class="bash hljs">$ gdw <span class="hljs-comment"><span class="hljs-comment"># git diff --word-diff</span></span></code> </pre> <br><p>  ... Dateien in Teilen hinzufügen (sehr nützlich, wenn Sie nur einen Teil der Änderungen aus der Datei zum Commit hinzufügen müssen): </p><br><pre> <code class="bash hljs">$ gapa <span class="hljs-comment"><span class="hljs-comment"># git add --patch</span></span></code> </pre> <br><p>  ... nur Dateien zum Index hinzufügen, die bereits unter der Aufsicht der Geeta stehen: </p><br><pre> <code class="bash hljs">$ gau <span class="hljs-comment"><span class="hljs-comment"># git add --update</span></span></code> </pre> <br><p>  Gesamt: </p><br><blockquote>  <strong>Zum Index hinzufügen / Commit erstellen</strong> <br><br><pre> <code class="bash hljs">$ ga <span class="hljs-comment"><span class="hljs-comment"># git add $ gc # git commit</span></span></code> </pre> <br></blockquote><br><h3 id="ispravlyaem-kommit">  Fix Commit </h3><br><p>  Der Name des letzten Commits erklärt nicht die Änderungen, die wir vorgenommen haben.  Lassen Sie uns neu formulieren: </p><br><pre> <code class="bash hljs">$ gc! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --amend</span></span></code> </pre> <br><p>  Und im Texteditor, der geöffnet wird, nennen wir es deutlicher: <code>"Add Delta article"</code> .  Ich bin sicher, dass Sie niemals den Schalter <code>-v</code> , obwohl beim Bearbeiten der Beschreibung des Commits alle vorgenommenen Änderungen angezeigt werden, was zu einer besseren Navigation beiträgt. </p><br><p>  <strong>Und wir können ...</strong> </p><br><p>  ... Änderungen an der Festschreibung vornehmen, aber die Beschreibung nicht berühren: </p><br><pre> <code class="bash hljs">$ gcn! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --no-edit --amend</span></span></code> </pre> <br><p>  ... alle Dateiänderungen sofort am Commit vornehmen, ohne zuerst den Index zu ergänzen: </p><br><pre> <code class="bash hljs">$ gca! <span class="hljs-comment"><span class="hljs-comment"># git commit -v -a --amend</span></span></code> </pre> <br><p>  ... kombinieren Sie die beiden vorherigen Befehle: </p><br><pre> <code class="bash hljs">$ gcan! <span class="hljs-comment"><span class="hljs-comment"># git commit -v -a --no-edit --amend</span></span></code> </pre> <br><p>  Nun, es ist noch einmal wichtig zu beachten, dass wir anstelle des vollständigen, regelmäßig verwendeten <code>git commit -v --amend</code> nur drei Zeichen schreiben: </p><br><blockquote>  <strong>Letzte Festschreibung ändern</strong> <br><br><pre> <code class="bash hljs">$ gc! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --amend</span></span></code> </pre> <br></blockquote><br><h3 id="nachinaem-rabotat-nad-novoy-fichey">  Erste Schritte mit einer neuen Funktion </h3><br><p>  Erstellen Sie einen neuen Zweig aus dem aktuellen Alias <em>" <strong>g</strong> it <strong>c</strong> heckout <strong>b</strong> ranch"</em> : </p><br><pre> <code class="bash hljs">$ gcb erlang <span class="hljs-comment"><span class="hljs-comment"># git checkout --branch erlang</span></span></code> </pre> <br><p>  Obwohl nein, ist es besser, einen Artikel über eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modernere Sprache von Elixir</a> alias <em>" <strong>g</strong> it <strong>b</strong> ranch with the key move" zu schreiben</em> (das Umbenennen in der Gita erfolgt durch <code>move</code> ): </p><br><pre> <code class="bash hljs">$ gb -m elixir <span class="hljs-comment"><span class="hljs-comment"># git branch -m elixir</span></span></code> </pre> <br><p>  Es wäre logisch, den Alias <code>gbmv</code> , aber leider wurde er noch nicht erfunden.  Eine gute Option für einen Beitrag. </p><br><p>  Wir nehmen Änderungen am Repository vor und erstellen ein Commit, wie wir bereits wissen: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"#  —     ."</span></span> &gt; e.md $ gaa &amp;&amp; gcmsg <span class="hljs-string"><span class="hljs-string">"Add article about Elixir"</span></span></code> </pre> <br><p>  Und denken Sie daran: </p><br><blockquote>  <strong>Erstellen Sie einen neuen Zweig</strong> <br><br><pre> <code class="bash hljs">$ gcb <span class="hljs-comment"><span class="hljs-comment"># git checkout --branch</span></span></code> </pre> <br></blockquote><br><h3 id="slivaem-izmeneniya">  Änderungen zusammenführen </h3><br><p>  Jetzt fügen wir unseren neuen Artikel über Elixier zum <code>master</code> .  <em>Wechseln Sie zunächst</em> mit dem Alias <em>" <strong>g</strong> it <strong>c</strong> heckout <strong>m</strong> aster" zum Hauptzweig</em> : </p><br><pre> <code class="bash hljs">$ gcm <span class="hljs-comment"><span class="hljs-comment"># git checkout master</span></span></code> </pre> <br><p>  Nein, wirklich.  Einer der am häufigsten verwendeten Befehle in drei leicht zu merkenden Zeichen.  Jetzt lautet die Zusammenführung der Aliasänderung <em>" <strong>g</strong> it <strong>m</strong> erge"</em> : </p><br><pre> <code class="bash hljs">$ gm elixir <span class="hljs-comment"><span class="hljs-comment"># git merge elixir</span></span></code> </pre> <br><p>  Ups, aber jemand hat es bereits geschafft, Änderungen am <code>master</code> vorzunehmen.  Und anstelle der schönen linearen Geschichte, die in unserem Projekt übernommen wurde, habe ich erstellt <del>  gehasst </del>  Merge Commit. </p><br><blockquote>  <strong>Zweige zusammenführen</strong> <br><br><pre> <code class="bash hljs">$ gm <span class="hljs-comment"><span class="hljs-comment"># git merge</span></span></code> </pre> <br></blockquote><br><h3 id="udalyaem-posledniy-kommit">  Löschen Sie das letzte Commit </h3><br><p>  Nichts Schlimmes!  Sie müssen nur das letzte Commit löschen und erneut versuchen, die Änderungen zusammenzuführen. <em>" <strong>G</strong> it <strong>r</strong> eset <strong>hh</strong> ard"</em> : </p><br><blockquote>  <strong>Letzte Festschreibung löschen</strong> <br><br><pre> <code class="bash hljs">$ grhh HEAD~ <span class="hljs-comment"><span class="hljs-comment"># git reset --hard HEAD~</span></span></code> </pre> <br></blockquote><br><h3 id="reshaem-konflikty">  Wir lösen Konflikte </h3><br><p>  Die Standard- <code>checkout – rebase – merge</code> Sequenz zum <code>checkout – rebase – merge</code> eines linearen Änderungsverlaufs wird von der folgenden Aliase-Sequenz ausgeführt: </p><br><pre> <code class="bash hljs">gco elixir <span class="hljs-comment"><span class="hljs-comment"># git checkout elixir grbm # git rebase master gcm # git checkout master gm elixir # git merge elixir</span></span></code> </pre> <br><p>  Alle von ihnen werden so oft verwendet, dass sie bereits von den Fingern wegfliegen, und bei solchen Operationen muss nicht überlegt werden, welche Buchstaben eingegeben werden sollen.  Und vergessen Sie nicht, dass Sie in <code>Zsh</code> die Namen von Zweigen mit der <code>Tab</code> ergänzen können. </p><br><blockquote>  <strong>Machen Sie eine Rebase</strong> <br><br><pre> <code class="bash hljs">$ grb <span class="hljs-comment"><span class="hljs-comment"># git rebase</span></span></code> </pre> <br></blockquote><br><h3 id="otpravka-izmeneniy-na-server">  Übermitteln von Änderungen an den Server </h3><br><p>  Zuerst fügen wir den <code>origin</code> Alias <em>" <strong>g</strong> it <strong>r</strong> emote <strong>a</strong> dd" hinzu</em> : </p><br><pre> <code class="bash hljs">$ gra origin git@github.com/... <span class="hljs-comment"><span class="hljs-comment"># git remote add origin git@github.com/...</span></span></code> </pre> <br><p>  Und dann senden wir die Änderungen direkt an den aktuellen Zweig des Repositorys ( <em>"gg"</em> - doppeltes <code>g</code> am Anfang des Befehls zeigt die Ausführung der Aktion im aktuellen Zweig an): </p><br><pre> <code class="bash hljs">$ ggpush <span class="hljs-comment"><span class="hljs-comment"># git push origin git_current_branch</span></span></code> </pre> <br><p>  <strong>Sie können auch ...</strong> </p><br><p>  ... senden Sie die Änderungen mit der <code>upstream</code> Installation des Alias <em>" <strong>g</strong> it <strong>p</strong> ush <strong>s</strong> et <strong>up</strong> stream"</em> an den Server: </p><br><pre> <code class="bash hljs">$ gpsup <span class="hljs-comment"><span class="hljs-comment"># git push --set-upstream origin $(git_current_branch)</span></span></code> </pre> <br><blockquote>  <strong>Senden Sie die Änderungen an den Server</strong> <br><br><pre> <code class="bash hljs">$ gp <span class="hljs-comment"><span class="hljs-comment"># git push</span></span></code> </pre> <br></blockquote><br><h3 id="poluchaem-izmeneniya-s-servera">  Wir erhalten Änderungen vom Server </h3><br><p>  Die Arbeit ist in vollem Gange.  Es ist uns gelungen, einen neuen Artikel <code>f.md</code> zum <code>master</code> hinzuzufügen, und unsere Kollegen haben den Artikel <code>a.md</code> geändert und diese Änderung an den Server gesendet.  Diese Situation ist auch sehr einfach zu lösen: </p><br><pre> <code class="bash hljs">$ gup <span class="hljs-comment"><span class="hljs-comment"># git pull --rebase</span></span></code> </pre> <br><p>  Dann können Sie sicher Änderungen an den Server senden.  Der Konflikt ist beigelegt. </p><br><blockquote>  <strong>Holen Sie sich Änderungen vom Server</strong> <br><br><pre> <code class="bash hljs">$ gl <span class="hljs-comment"><span class="hljs-comment"># git pull</span></span></code> </pre> <br></blockquote><br><h3 id="udalyaem-slitye-vetki">  Zusammengeführte Zweige löschen </h3><br><p>  Daher haben wir mehrere Zweige erfolgreich zu <code>master</code> , einschließlich des <code>elixir</code> aus dem vorherigen Beispiel.  Wir brauchen sie nicht mehr.  Sie können den Alias <em>" <strong>g</strong> it <strong>b</strong> ranch <strong>d</strong> elete <strong>a</strong> nother" entfernen</em> : </p><br><pre> <code class="bash hljs">$ gbda <span class="hljs-comment"><span class="hljs-comment"># git branch --no-color --merged | command grep -vE "^(\*|\s*(master|develop|dev)\s*$)" | command xargs -n 1 git branch -d</span></span></code> </pre> <br><p>  Sehr schönes und gerissenes Team.  Normalerweise vergesse ich, Zweige zu löschen, die an Relevanz verloren haben, und dieses anmutige Team ist eine echte Rettung.  Wenn Sie keinen Alias ​​verwenden möchten, kopieren Sie einfach die Vollversion des Befehls in Ihre Notizen und führen Sie ihn nach Bedarf aus. </p><br><h3 id="sozdayom-vremennyy-kommit">  Erstellen Sie ein temporäres Commit </h3><br><p>  Die Arbeit an einem neuen <code>h.md</code> Artikel über Haskell ist in vollem Gange.  Die Hälfte ist geschrieben und Sie müssen Feedback von einem Kollegen erhalten.  Ohne nachzudenken, geben wir den Alias <em>" <strong>g</strong> it <strong>w</strong> ork <strong>i</strong> n <strong>p</strong> rogress" ein</em> : </p><br><pre> <code class="bash hljs">$ gwip <span class="hljs-comment"><span class="hljs-comment"># git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m "--wip-- [skip ci]"</span></span></code> </pre> <br><p>  Anschließend wird ein Commit mit dem Namen <code>Work in Progress</code> , wobei CI übersprungen und die "zusätzlichen" Dateien gelöscht werden.  Wir senden den Zweig an den Server, sprechen über diesen Kollegen und warten auf die Überprüfung. </p><br><p>  Dann kann dieses Commit rückgängig gemacht und die Dateien in ihren ursprünglichen Zustand zurückversetzt werden: </p><br><pre> <code class="bash hljs">$ gunwip <span class="hljs-comment"><span class="hljs-comment"># git log -n 1 | grep -q -c "\-\-wip\-\-" &amp;&amp; git reset HEAD~1</span></span></code> </pre> <br><p>  Verwenden Sie den folgenden Befehl, um zu überprüfen, ob in Ihrer Zweigstelle <code>WIP</code> Commits vorhanden sind: </p><br><pre> <code class="bash hljs">$ work_in_progress</code> </pre> <br><p>  Der Befehl <code>gwip</code> ist ein ziemlich zuverlässiges Analogon von <code>stash</code> wenn Sie zu einem benachbarten Zweig wechseln müssen.  Aber in <code>Zsh</code> gibt es viele Aliase für <code>stash</code> . </p><br><blockquote>  <strong>Temporäres Commit hinzufügen / Temporäres Commit zurücksetzen</strong> <br><br><pre> <code class="bash hljs">$ gwip $ gunwip</code> </pre> <br></blockquote><br><h2 id="pryachem-izmeneniya">  Änderungen verbergen </h2><br><p>  <strong>Sie müssen mit diesem Befehl vorsichtig sein.</strong>  Dateien können ausgeblendet und dann mit einer unachtsamen Aktion vollständig gelöscht werden, da es ein <code>reflog</code> in dem Sie versuchen können, die verlorene Arbeit zu finden. </p><br><p>  Verstecken wir die Dateien, an denen wir arbeiten, mit dem Alias <em><strong>g</strong> it <strong>st</strong> ash <strong>a</strong> ll</em> : </p><br><pre> <code class="bash hljs">$ gsta <span class="hljs-comment"><span class="hljs-comment"># git stash save</span></span></code> </pre> <br><p>  Und geben Sie sie dann mit dem Alias <em>" <strong>g</strong> it <strong>st</strong> ash <strong>p</strong> op" zurück</em> : </p><br><pre> <code class="bash hljs">$ gstp <span class="hljs-comment"><span class="hljs-comment"># git stash pop</span></span></code> </pre> <br><p>  Oder die sicherere <em>Methode „ <strong>g</strong> it <strong>st</strong> ash <strong>a</strong> ll <strong>a</strong> pply“</em> : </p><br><pre> <code class="bash hljs">$ gstaa <span class="hljs-comment"><span class="hljs-comment"># git stash apply</span></span></code> </pre> <br><p>  <strong>Sie können auch ...</strong> </p><br><p>  ... sehen, was genau wir versteckt haben: </p><br><pre> <code class="bash hljs">gsts <span class="hljs-comment"><span class="hljs-comment"># git stash show --text</span></span></code> </pre> <br><p>  ... Abkürzungen für verwandte Befehle verwenden: </p><br><pre> <code class="bash hljs">gstc <span class="hljs-comment"><span class="hljs-comment"># git stash clear gstd # git stash drop gstl # git stash list</span></span></code> </pre> <br><blockquote>  <strong>Änderungen ausblenden / Änderungen abrufen</strong> <br><br><pre> <code class="bash hljs">$ gsta $ gstaa</code> </pre> <br></blockquote><br><h3 id="ischem-bag">  Auf der Suche nach einem Fehler </h3><br><p>  Das <code>git-bisect</code> Tool, das mir immer wieder das Leben gerettet hat, hat auch seine eigenen Aliase.  Wir beginnen mit dem Start der Prozedur "Binäre Fehlersuche" mit dem <em>Alias ​​" <strong>g</strong> it <strong>b</strong> i <strong>s</strong> ect <strong>s</strong> tart"</em> : </p><br><pre> <code class="bash hljs">$ gbss <span class="hljs-comment"><span class="hljs-comment"># git bisect start</span></span></code> </pre> <br><p>  Wir stellen fest, dass das aktuelle Commit als letztes in der Verzweigung einen Fehler mit dem Alias <em>" <strong>g</strong> it <strong>b</strong> i <strong>s</strong> ect <strong>b</strong> ad" enthält</em> : </p><br><pre> <code class="bash hljs">$ gbsb <span class="hljs-comment"><span class="hljs-comment"># git bisect bad</span></span></code> </pre> <br><p>  Jetzt markieren wir das Commit, das uns den Betriebszustand der Anwendung garantiert: <em>„ <strong>g</strong> it <strong>b</strong> i <strong>s</strong> ect <strong>g</strong> ood“</em> : </p><br><pre> <code class="bash hljs">$ gbsg HEAD~20 <span class="hljs-comment"><span class="hljs-comment"># git bisect good HEAD~20</span></span></code> </pre> <br><p>  Und jetzt bleibt es weiterhin, <code>gbsb</code> Fragen mit den Sätzen <code>gbsb</code> oder <code>gbsg</code> zu beantworten und nach dem Auffinden des <code>gbsg</code> das Verfahren zurückzusetzen: </p><br><pre> <code class="bash hljs">$ gbsr <span class="hljs-comment"><span class="hljs-comment"># git bisect reset</span></span></code> </pre> <br><p>  Und ich schreibe diese Abkürzungen wirklich, wenn ich dieses Werkzeug benutze. </p><br><blockquote>  <strong>Fehler beim Festschreiben der Suche</strong> <br><br><pre> <code class="bash hljs">$ gbss <span class="hljs-comment"><span class="hljs-comment"># git bisect start $ gbsb # git bisect bad $ gbsg # git bisect good $ gbsr # git bisect reset</span></span></code> </pre> <br></blockquote><br><h3 id="ischem-zachinschika-bespredela">  Wir suchen den Anstifter der Gesetzlosigkeit </h3><br><p>  Selbst bei einem hohen Prozentsatz der Codeabdeckung mit Tests ist niemand vor einer Situation gefeit, in der die Anwendung abstürzt und freundlicherweise auf eine bestimmte fehlerhafte Zeile zeigt.  In unserem Fall möchten wir beispielsweise herausfinden, wer in der zweiten Zeile der Datei <code>a.md</code> einen Fehler <code>a.md</code> .  Führen Sie dazu den folgenden Befehl aus: </p><br><pre> <code class="bash hljs">$ gbl a.md -L 2 <span class="hljs-comment"><span class="hljs-comment"># git blame -b -w a.md -L 2</span></span></code> </pre> <br><p>  Sie sehen, <code>Oh My Zsh</code> Mitarbeiter haben nicht nur einen Alias ​​für das <code>git blame</code> Team erstellt, sondern auch Schlüssel hinzugefügt, die es einfach machen, den Anstifter direkt zu finden. </p><br><h2 id="bonus">  Bonus </h2><br><h3 id="prosmotr-spiska-kommitov">  Zeigen Sie eine Liste der Commits an </h3><br><p>  Verwenden Sie zum Anzeigen der Liste der Commits den Befehl <code>git log</code> mit zusätzlichen Ausgabeformatierungsschlüsseln.  Normalerweise wird dieser Befehl zusammen mit den Schlüsseln in die benutzerdefinierten Aliase von Gita eingegeben.  Wir haben mehr Glück, wir haben bereits einen vorgefertigten Alias: <code>glog</code> .  Und wenn Sie das <code>tig</code> Dienstprogramm <code>tig</code> den Empfehlungen vom Anfang des Artikels installiert haben, sind Sie ein absoluter Champion. </p><br><p>  Um den Verlauf von Commits in der Konsole auf sehr bequeme Weise zu lernen, müssen Sie das Wort <code>git</code> umgekehrt eingeben: </p><br><pre> <code class="bash hljs">$ tig</code> </pre> <br><p>  Das Dienstprogramm bietet auch einige nützliche Ergänzungen, die nicht sofort in der Gita enthalten sind. </p><br><p>  Zunächst ein Befehl zum Durchsuchen des Inhalts einer Geschichte: </p><br><pre> <code class="bash hljs">$ tig grep</code> </pre> <br><p>  Zweitens: Anzeigen einer Liste aller Quellen, Zweige und Tags mit ihrem Verlauf: </p><br><pre> <code class="bash hljs">$ tig refs</code> </pre> <br><p>  Drittens finden Sie vielleicht etwas Interessantes für sich selbst: </p><br><pre> <code class="bash hljs">$ tig --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre> <br><h3 id="sluchayno-sdelal-git-reset---hard">  Versehentlich <code>git reset --hard</code> </h3><br><p>  Sie haben den ganzen Tag am <code>elixir</code> : </p><br><pre> <code class="hljs pgsql">$ glog * <span class="hljs-number"><span class="hljs-number">17</span></span>cb385 (HEAD -&gt; elixir) Refine Elixir article * c14b4dc <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> article about Elixir * db84d54 (master) Initial <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span></code> </pre> <br><p>  Und am Ende haben sie versehentlich alles gelöscht: </p><br><pre> <code class="bash hljs">$ grhh HEAD~2 HEAD is now at db84d54 Initial commit</code> </pre> <br><p>  Kein Grund zur Panik.  <strong>Die wichtigste Regel ist, die Ausführung von Befehlen in der Gita zu beenden und auszuatmen</strong> .  Alle Aktionen mit dem lokalen Repository werden in einem speziellen Protokoll- <code>reflog</code> .  Daraus können Sie den Hash des gewünschten Commits abrufen und im Arbeitsbaum wiederherstellen. </p><br><p>  Schauen wir uns das Reflog an, aber nicht auf die übliche Weise durch <code>git reflog</code> , sondern interessanter mit einem detaillierten Transkript: </p><br><pre> <code class="bash hljs">$ glg -g</code> </pre> <br><p>  Suchen Sie den Hash des gewünschten <code>17cb385</code> Commits und stellen Sie ihn wieder her: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#           $ gcb elixir-recover 17cb385 #    $ gbd elixir #     $ gb -m elixir</span></span></code> </pre> <br><h3 id="sluchayno-vmesto-sozdaniya-novogo-kommita-vnyos-izmeneniya-v-predyduschiy">  Anstatt ein neues Commit zu erstellen, habe ich zufällig Änderungen am vorherigen vorgenommen </h3><br><p>  Auch hier kommen wir zur Rettungshilfe um.  Wir finden den Hash des ursprünglichen <code>17cb385</code> Commits. Wenn wir den Commit sofort abbrechen, können wir anstelle des Hash den Quick-Link zu <code>HEAD@{1}</code> .  Als nächstes führen wir einen Soft-Reset durch, während der Index nicht zurückgesetzt wird: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      $ grh --soft HEAD@{1} # git reset -soft #   $ gcmsg "Commit description"</span></span></code> </pre> <br><h3 id="vetka-slishkom-silno-ustarela">  Der Zweig ist zu alt </h3><br><p>  Manchmal beginnt man mit der Arbeit an einem Feature, aber die Veröffentlichung wird auf unbestimmte Zeit verzögert.  Sie verpflichten sich und wechseln zu anderen Aufgaben.  Zusammen mit dem Team nehmen Sie eine Reihe von Änderungen am Master vor und kehren nach einer Weile mit Funktionen zum Zweig zurück.  Sie versuchen, die Basis neu zu bestimmen, aber er bietet an, Konflikte in einem Dutzend Commits zu analysieren.  Sie können versuchen, sie alle zu lösen oder es einfacher zu machen. </p><br><p>  Schauen wir uns ein Beispiel für einen Feature-Zweig namens <code>elixir</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   master $ gcm # git checkout master #        $ gcb elixir-new # git checkout --branch elixir-new #           $ gcp elixir@{0} # git cherry-pick elixir@{0}</span></span></code> </pre> <br><p>  Anstatt zu versuchen, den Zweig zu aktualisieren, nehmen wir ein einzelnes Commit ohne Probleme und übertragen es. </p><br><h3 id="udalenie-vazhnyh-dannyh-iz-repozitoriya">  Wichtige Daten aus dem Repository entfernen </h3><br><p>  Um wichtige Daten aus dem Repository zu löschen, habe ich das folgende Snippet gespeichert: </p><br><pre> <code class="bash hljs">$ git filter-branch --force --index-filter <span class="hljs-string"><span class="hljs-string">'git rm --cached --ignore-unmatch &lt;path-to-your-file&gt;'</span></span> --prune-empty --tag-name-filter cat -- --all &amp;&amp; git push origin --force --all</code> </pre> <br><p>  <strong>Wenn Sie diesen Befehl <code>stash</code> wird Ihr <code>stash</code> .</strong>  Vor der Ausführung wird empfohlen, alle versteckten Änderungen zu erhalten.  Lesen Sie hier mehr über diese Technik. </p><br><h3 id="obraschenie-k-predyduschey-vetke">  Bezugnehmend auf den vorherigen Zweig </h3><br><p>  Wenn Sie einige Befehle ausführen, bei denen die Eingabe eines Zweignamens erwartet wird, können Sie einen Bindestrich als Referenz auf den Zweig übergeben, mit dem wir gekommen sind.  Es ist besonders gut, diesen Checkout-Trick zu verwenden: </p><br><pre> <code class="bash hljs">$ gco - <span class="hljs-comment"><span class="hljs-comment"># git checkout - $ gm - # git merge - $ grb - # git rebase -</span></span></code> </pre> <br><h3 id="udalenie-vseh-faylov-otmechennyh-v-gitignore">  Löschen Sie alle in <code>.gitignore</code> markierten <code>.gitignore</code> </h3><br><p>  Ein weiterer häufiger Rückschlag ist zu spät, um unerwünschte Dateien oder Verzeichnisse zu <code>.gitignore</code> .  Um sie aus dem Repository zu bereinigen ( <strong>und von der Festplatte zu löschen</strong> ), gibt es bereits vorgefertigte Schlüssel für den Befehl <code>git clean</code> : </p><br><pre> <code class="bash hljs">$ gclean -X <span class="hljs-comment"><span class="hljs-comment"># git clean -Xfd</span></span></code> </pre> <br><p>  <strong>Seid vorsichtig!</strong> </p><br><p>  Lesen Sie weiter für den richtigen Weg. </p><br><h3 id="zachem-mnogim-komandam-nuzhen-klyuch---dry-run">  Warum brauchen viele Teams den Schalter <code>--dry-run</code> ? </h3><br><p>  Der <code>--dry-run</code> nur als Vorsichtsmaßnahme bei der Deinstallation und Aktualisierung benötigt.  Im vorherigen Abschnitt wurde beispielsweise beschrieben, wie Sie alles löschen, was in der <code>.gitignore</code> Datei angegeben ist.  Es ist besser, vorsichtig zu sein und den Schalter <code>--dry-run</code> , <code>--dry-run</code> Liste aller zu löschenden Dateien <code>--dry-run</code> und den Befehl erst dann ohne <code>--dry-run</code> . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Artikel zeigt einen Punkt zur Optimierung der Arbeit des Programmierers.  Denken Sie daran, 10-20 mnemonische Abkürzungen sind nicht schwierig, vergessen Sie, dass das ursprüngliche Team fast unmöglich ist.  Die Aliase sind standardisiert. Wenn Sie also das gesamte Team auf <code>Zsh</code> + <code>Oh My Zsh</code> , können Sie auch bei der <code>Oh My Zsh</code> mit der gleichen Geschwindigkeit und dem gleichen Komfort arbeiten. </p><br><h3 id="kuda-dvigatsya-dalshe">  Wohin als nächstes? </h3><br><p>  Ich biete folgende Optionen an: </p><br><ol><li>  Stellen Sie schließlich fest, wie das Geet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Inneren angeordnet ist</a> .  Es hilft zu verstehen, was Sie tun und warum das, was Sie tun möchten, nicht funktioniert. </li><li>  <code>git --help</code> Sie nicht faul, noch einmal die Dokumentation für die Befehle zu <code>git --help</code> : <code>git --help</code> oder <code>ghh</code> . </li><li>  Die vollständige Liste der Aliase finden Sie <a href="">unter dem Link</a> .  Der Versuch, sich an alle zu erinnern, ist verrückt, aber die Liste als Sammlung interessanter Befehle und Schlüssel zu verwenden, ist eine gute Idee. </li></ol><br><p>  Einige Aliase werden nicht trivial erstellt, erweisen sich jedoch in der Praxis als sehr nützlich.  Viele der vorgestellten Aliase sind nicht nur Abkürzungen, sondern kleine Funktionen, die die Arbeit weiter optimieren.  Die Verwendung von Git ist angenehmer geworden, die Qualität der Commits hat sich verbessert. </p><br><p>  Ich hoffe, das Material hat sich als nützlich erwiesen und Sie konnten etwas Neues für sich selbst lernen.  Oder vielleicht haben sie bereits begonnen, einen neuen Ansatz aktiv einzuführen.  Viel Glück </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420529/">https://habr.com/ru/post/de420529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420519/index.html">Popularisierung der Wissenschaft</a></li>
<li><a href="../de420521/index.html">Jetzt offiziell: TLS 1.3 als Standard anerkannt</a></li>
<li><a href="../de420523/index.html">Analyse von binären Optionsdiagrammen oder wie ich mir erneut bewiesen habe, dass es keine Werbegeschenke gibt</a></li>
<li><a href="../de420525/index.html">Netzwerke für die erfahrensten. Teil fünfzehn. QoS</a></li>
<li><a href="../de420527/index.html">Ein Lächeln kann klingen und es ist ansteckend</a></li>
<li><a href="../de420533/index.html">Emulieren von Eigenschaftsliteralen mit der Java 8-Methodenreferenz</a></li>
<li><a href="../de420537/index.html">Eine andere Geschichte darüber, wie Geld relativ ehrlich mit einem Megaphon aufgenommen wird</a></li>
<li><a href="../de420539/index.html">Benutzerdefinierter Ansatz zum Normalisieren und Zurücksetzen von Stilen (custom-reset.css)</a></li>
<li><a href="../de420541/index.html">Forscher von Carnegie Mellon haben die glaubwürdigsten „Deepfakes“ geschaffen</a></li>
<li><a href="../de420547/index.html">Wie ich schrieb und verteidigte ein Diplom in DEVOPS und Ingenieurspraktiken in 1C von Grund auf neu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>