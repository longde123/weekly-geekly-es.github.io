<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåç üèÇüèº üíÜüèΩ Fortgeschrittene Nutzung von Geeta oder wie man sechs Monate fr√ºher in den Ruhestand geht? üçû üë©üèª‚Äçüöí üë¶üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wei√ü nicht, in welcher Programmiersprache Sie schreiben, aber ich bin sicher, dass Sie Geet w√§hrend der Entwicklung verwenden. Es gibt immer mehr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fortgeschrittene Nutzung von Geeta oder wie man sechs Monate fr√ºher in den Ruhestand geht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420529/"><p><img src="https://habrastorage.org/webt/g_/v7/lg/g_v7lgawugfumbtsi3edevsencc.png"></p><br><p> Ich wei√ü nicht, in welcher Programmiersprache Sie schreiben, aber ich bin sicher, dass Sie Geet w√§hrend der Entwicklung verwenden.  Es gibt immer mehr Tools zur Unterst√ºtzung der Entwicklung, aber selbst beim kleinsten Testprojekt beginne ich immer mit dem Befehl <code>git init</code> .  Und w√§hrend des Arbeitstages tippe ich durchschnittlich weitere 80 Teams ein, die sich auf dieses Versionskontrollsystem beziehen. </p><br><p>  Ich war sehr nerv√∂s, als ich anfing, die Zehn-Finger-Druckmethode neu zu lernen.  Am Ende war dies die beste Entscheidung, um Ihren pers√∂nlichen Workflow zu verbessern.  Zu den n√§chstwichtigsten Optimierungen geh√∂rt die Weiterentwicklung des Geeta. </p><br><p>  Viele Artikel √ºber Gita wurden √ºber Habr geschrieben, aber sie gehen nicht √ºber die offizielle Dokumentation hinaus, und die Autoren schlagen vor, die Arbeit mit selbst hergestellten Kr√ºcken zu vereinfachen.  Ich bin sicher, dass es notwendig ist, das Geet an konkreten Beispielen von Aufgaben zu studieren und die Effizienz der Arbeit mit standardisierten Mitteln zu steigern. </p><br><h2 id="komu-budet-polezna-eta-statya">  Wer wird von diesem Artikel profitieren? </h2><br><p>  Haben Sie das Gita-Set des Gentlemans bereits gemeistert und sind Sie bereit, weiterzumachen?  Es gibt zwei M√∂glichkeiten: </p><br><ol><li>  <strong>Master abgek√ºrzte Befehle - Aliase.</strong>  Sie sind fast immer mnemonisch und leicht zu merken.  Das Vergessen der urspr√ºnglichen Befehle ist problematisch, ich tippe sie bei Bedarf einfach ein.  Au√üerdem bin ich nicht verwirrt, wenn ich beim Schreiben von Code etwas in der Gita √ºberpr√ºfe. </li><li>  <strong>Erfahren Sie mehr √ºber zus√§tzliche Flaggen f√ºr Teams sowie deren Integration untereinander.</strong>  Ich verstehe, dass jemand das Schneiden hasst.  Auch f√ºr Sie enth√§lt der Artikel interessantes Material - <em>wie Sie den Nutzen und die Bequemlichkeit der Befehlsausgabe erh√∂hen und nicht die trivialsten, aber in der Praxis h√§ufig auftretenden Probleme l√∂sen k√∂nnen</em> . </li></ol><br><p>  Wenden Sie heute ein paar Stunden auf die im Artikel beschriebenen Experimente auf und sparen Sie durch ungef√§hre Berechnungen sechs Monate Arbeitszeit. </p><br><p>  Willkommen bei Katze! </p><a name="habracut"></a><br><h2 id="podgotovka">  Vorbereitung </h2><br><p>  Unter Entwicklern ist der Standard f√ºr die <code>Bash</code> Alternative <code>Zsh</code> , eine fortschrittliche Software-Shell, die die Feinabstimmung unterst√ºtzt.  Und unter <code>Zsh</code> Benutzern besteht der Standard darin, <code>Oh My Zsh</code> , eine Reihe vordefinierter Einstellungen f√ºr <code>Zsh</code> .  Nachdem wir dieses Kit installiert haben, erhalten wir eine Reihe von Hacks, die die Community im Laufe der Jahre f√ºr uns gesammelt und entwickelt hat. </p><br><p>  Es ist sehr wichtig zu beachten, dass <code>Zsh</code> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mac</a> und sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows</a> <code>Zsh</code> ist. </p><br><p>  <strong>Installieren Sie <code>Zsh</code> und <code>Oh My Zsh</code></strong> </p><br><p>  Installieren Sie <code>Zsh</code> und <code>Oh My Zsh</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gem√§√ü den Anweisungen mit</a> einem Befehl: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># macOS brew install zsh zsh-completions &amp;&amp; sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" # Ubuntu, Debian, ... apt install zsh &amp;&amp; sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span></span></code> </pre> <br><p>  Da die Aufgabe darin besteht, <em>die Interaktion mit dem Geet</em> zu <em>optimieren</em> , werden wir <code>Zsh</code> einige Plug-Ins <code>Zsh</code> .  √ñffnen Sie die <code>~/.zshrc</code> und f√ºgen Sie der Liste <code>plugins</code> : </p><br><pre> <code class="hljs lisp">plugins=(<span class="hljs-name"><span class="hljs-name">git</span></span> gitfast)</code> </pre> <br><p>  Gesamt: </p><br><ul><li>  <code>git</code> - eine Reihe von Aliasen und Hilfsfunktionen; </li><li>  <code>gitfast</code> - verbesserte automatische Vervollst√§ndigung f√ºr Gita. </li></ul><br><p>  <strong><code>tig</code> Einstellung</strong> </p><br><p>  Der letzte Schliff ist die Installation des Dienstprogramms <code>tig</code> console: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># macOS brew install tig # Ubuntu, Debian, ... # https://jonas.github.io/tig/INSTALL.html</span></span></code> </pre> <br><p>  Wir werden weiter dar√ºber reden. </p><br><h2 id="git-na-praktike">  Git in der Praxis </h2><br><p>  Der Umgang mit Geeta erfolgt am besten durch L√∂sen spezifischer Probleme.  Als n√§chstes betrachten wir Aufgaben aus der t√§glichen Praxis und Optionen f√ºr ihre bequeme L√∂sung.  Betrachten Sie dazu ein bestimmtes Repository mit Textdateien. </p><br><blockquote>  <strong>Die gelben Bl√∂cke geben den Hauptalias zur L√∂sung des Problems aus dem Abschnitt an.</strong>  <strong>Lerne nur es und √ºberlasse alles andere der allgemeinen Entwicklung.</strong> </blockquote><br><h3 id="proveryaem-sostoyanie-rabochey-direktorii">  √úberpr√ºfen Sie den Status des Arbeitsverzeichnisses </h3><br><p>  Beginnen wir mit der grundlegendsten Sache.  Wir haben ein wenig gearbeitet und jetzt wollen wir sehen, was im Arbeitsverzeichnis passiert: </p><br><pre> <code class="bash hljs">$ git status On branch master Changes to be committed: (use <span class="hljs-string"><span class="hljs-string">"git reset HEAD &lt;file&gt;..."</span></span> to unstage) new file: e.md Changes not staged <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit: (use <span class="hljs-string"><span class="hljs-string">"git add &lt;file&gt;..."</span></span> to update what will be committed) (use <span class="hljs-string"><span class="hljs-string">"git checkout -- &lt;file&gt;..."</span></span> to discard changes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> working directory) modified: b.md Untracked files: (use <span class="hljs-string"><span class="hljs-string">"git add &lt;file&gt;..."</span></span> to include <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> what will be committed) d.md</code> </pre> <br><p>  Der aktuelle Status aller Dateien wird ausf√ºhrlich beschrieben, zus√§tzliche Handlungsanweisungen werden gegeben.  Es ist zun√§chst sehr n√ºtzlich, wenn Sie Geeta verwenden, aber f√ºr die t√§gliche Arbeit ist viel √ºberfl√ºssig.  Lassen Sie uns den Ger√§uschpegel mit zus√§tzlichen Tasten senken: </p><br><pre> <code class="bash hljs">$ git status -sb <span class="hljs-comment"><span class="hljs-comment">## master M b.md A e.md ?? d.md</span></span></code> </pre> <br><p>  Ja, wir befinden uns im Hauptzweig, haben die <code>b.md</code> ( <code>M-odified</code> ) ge√§ndert und zwei Dateien erstellt, wobei die erste dem Geeta-Index ( <code>A-dded</code> ) <code>A-dded</code> und die zweite aus dem Index entfernt wurde ( <code>??</code> ).  Kurz und klar. </p><br><p>  Es bleibt die endlose Eingabe dieses Befehls durch den Alias <em>" <strong>g</strong> it <strong>s</strong> tatus with <strong>b</strong> ranch"</em> zu optimieren: </p><br><blockquote>  <strong>Status des verk√ºrzten Arbeitsverzeichnisses anzeigen</strong> <br><br><pre> <code class="bash hljs">$ gsb <span class="hljs-comment"><span class="hljs-comment"># git status -sb</span></span></code> </pre> <br></blockquote><br><h3 id="sozdayom-kommit">  Erstellen Sie ein Commit </h3><br><p>  Wir fahren fort. </p><br><p>  Nat√ºrlich k√∂nnen Sie Commits machen.  Aber versuchen wir, die L√∂sung dieser einfachen Aufgabe zu optimieren.  F√ºgen Sie alle √Ñnderungen zum Index mit dem Alias <em>" <strong>g</strong> it <strong>a</strong> dd <strong>a</strong> ll" hinzu</em> : </p><br><pre> <code class="bash hljs">$ gaa <span class="hljs-comment"><span class="hljs-comment"># git add --all</span></span></code> </pre> <br><p>  Wir √ºberpr√ºfen, ob der Index genau das hat, was wir brauchen, indem wir den Alias <em>" <strong>g</strong> it <strong>d</strong> iff <strong>ca</strong> ched" verwenden</em> : </p><br><pre> <code class="diff hljs">$ gdca # git diff --cached diff --git a/b.md b/b.md index 698d533..cf20072 100644 --- a/b.md +++ b/b.md @@ -1,3 +1,3 @@ # Beta -Next step. +Next step really hard. diff --git a/d.md b/d.md new file mode 100644 index 0000000..9e3752e --- /dev/null +++ b/d.md @@ -0,0 +1,3 @@ +# Delta + +Body of article.</code> </pre> <br><p>  Hmm, √Ñnderungen, die eine einzelne Aufgabe l√∂sen, sollten in ein Commit fallen.  Hier sind die √Ñnderungen beider Dateien in keiner Weise miteinander verbunden.  Lassen Sie uns <code>d.md</code> die Datei <code>d.md</code> mit dem Alias <em>" <strong>g</strong> it <strong>r</strong> eset <strong>u</strong> ndo"</em> aus dem Index <em>ausschlie√üen</em> : </p><br><pre> <code class="hljs pgsql">$ gru d.md # git <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> <span class="hljs-comment"><span class="hljs-comment">-- d.md</span></span></code> </pre> <br><p>  Und erstellen Sie ein Commit mit dem Alias <em>" <strong>g</strong> it <strong>c</strong> ommit"</em> : </p><br><pre> <code class="hljs ruby">$ gc <span class="hljs-comment"><span class="hljs-comment"># git commit</span></span></code> </pre> <br><p>  Wir schreiben den Namen des Commits und speichern.  Und dann erstellen wir ein weiteres Commit f√ºr die Datei <code>d.md</code> bekannteren Befehl unter Verwendung des Alias <em>" <strong>g</strong> it <strong>c</strong> ommit <strong>m</strong> e <strong>s</strong> sa <strong>g</strong> e"</em> : </p><br><pre> <code class="bash hljs">$ gaa <span class="hljs-comment"><span class="hljs-comment">#    $ gcmsg "Add new file" # git commit -m "Add new file"</span></span></code> </pre> <br><p>  <strong>Und wir k√∂nnen ...</strong> </p><br><p>  ... ge√§nderte Dateien aus dem Index mit einem Befehl festschreiben: </p><br><pre> <code class="bash hljs">$ gcam <span class="hljs-string"><span class="hljs-string">"Add changes"</span></span> <span class="hljs-comment"><span class="hljs-comment"># git commit -a -m "Add changes"</span></span></code> </pre> <br><p>  ... √Ñnderungen durch W√∂rter anstelle von Zeilen sehen (sehr n√ºtzlich bei der Arbeit mit Text): </p><br><pre> <code class="bash hljs">$ gdw <span class="hljs-comment"><span class="hljs-comment"># git diff --word-diff</span></span></code> </pre> <br><p>  ... Dateien in Teilen hinzuf√ºgen (sehr n√ºtzlich, wenn Sie nur einen Teil der √Ñnderungen aus der Datei zum Commit hinzuf√ºgen m√ºssen): </p><br><pre> <code class="bash hljs">$ gapa <span class="hljs-comment"><span class="hljs-comment"># git add --patch</span></span></code> </pre> <br><p>  ... nur Dateien zum Index hinzuf√ºgen, die bereits unter der Aufsicht der Geeta stehen: </p><br><pre> <code class="bash hljs">$ gau <span class="hljs-comment"><span class="hljs-comment"># git add --update</span></span></code> </pre> <br><p>  Gesamt: </p><br><blockquote>  <strong>Zum Index hinzuf√ºgen / Commit erstellen</strong> <br><br><pre> <code class="bash hljs">$ ga <span class="hljs-comment"><span class="hljs-comment"># git add $ gc # git commit</span></span></code> </pre> <br></blockquote><br><h3 id="ispravlyaem-kommit">  Fix Commit </h3><br><p>  Der Name des letzten Commits erkl√§rt nicht die √Ñnderungen, die wir vorgenommen haben.  Lassen Sie uns neu formulieren: </p><br><pre> <code class="bash hljs">$ gc! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --amend</span></span></code> </pre> <br><p>  Und im Texteditor, der ge√∂ffnet wird, nennen wir es deutlicher: <code>"Add Delta article"</code> .  Ich bin sicher, dass Sie niemals den Schalter <code>-v</code> , obwohl beim Bearbeiten der Beschreibung des Commits alle vorgenommenen √Ñnderungen angezeigt werden, was zu einer besseren Navigation beitr√§gt. </p><br><p>  <strong>Und wir k√∂nnen ...</strong> </p><br><p>  ... √Ñnderungen an der Festschreibung vornehmen, aber die Beschreibung nicht ber√ºhren: </p><br><pre> <code class="bash hljs">$ gcn! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --no-edit --amend</span></span></code> </pre> <br><p>  ... alle Datei√§nderungen sofort am Commit vornehmen, ohne zuerst den Index zu erg√§nzen: </p><br><pre> <code class="bash hljs">$ gca! <span class="hljs-comment"><span class="hljs-comment"># git commit -v -a --amend</span></span></code> </pre> <br><p>  ... kombinieren Sie die beiden vorherigen Befehle: </p><br><pre> <code class="bash hljs">$ gcan! <span class="hljs-comment"><span class="hljs-comment"># git commit -v -a --no-edit --amend</span></span></code> </pre> <br><p>  Nun, es ist noch einmal wichtig zu beachten, dass wir anstelle des vollst√§ndigen, regelm√§√üig verwendeten <code>git commit -v --amend</code> nur drei Zeichen schreiben: </p><br><blockquote>  <strong>Letzte Festschreibung √§ndern</strong> <br><br><pre> <code class="bash hljs">$ gc! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --amend</span></span></code> </pre> <br></blockquote><br><h3 id="nachinaem-rabotat-nad-novoy-fichey">  Erste Schritte mit einer neuen Funktion </h3><br><p>  Erstellen Sie einen neuen Zweig aus dem aktuellen Alias <em>" <strong>g</strong> it <strong>c</strong> heckout <strong>b</strong> ranch"</em> : </p><br><pre> <code class="bash hljs">$ gcb erlang <span class="hljs-comment"><span class="hljs-comment"># git checkout --branch erlang</span></span></code> </pre> <br><p>  Obwohl nein, ist es besser, einen Artikel √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modernere Sprache von Elixir</a> alias <em>" <strong>g</strong> it <strong>b</strong> ranch with the key move" zu schreiben</em> (das Umbenennen in der Gita erfolgt durch <code>move</code> ): </p><br><pre> <code class="bash hljs">$ gb -m elixir <span class="hljs-comment"><span class="hljs-comment"># git branch -m elixir</span></span></code> </pre> <br><p>  Es w√§re logisch, den Alias <code>gbmv</code> , aber leider wurde er noch nicht erfunden.  Eine gute Option f√ºr einen Beitrag. </p><br><p>  Wir nehmen √Ñnderungen am Repository vor und erstellen ein Commit, wie wir bereits wissen: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"#  ‚Äî     ."</span></span> &gt; e.md $ gaa &amp;&amp; gcmsg <span class="hljs-string"><span class="hljs-string">"Add article about Elixir"</span></span></code> </pre> <br><p>  Und denken Sie daran: </p><br><blockquote>  <strong>Erstellen Sie einen neuen Zweig</strong> <br><br><pre> <code class="bash hljs">$ gcb <span class="hljs-comment"><span class="hljs-comment"># git checkout --branch</span></span></code> </pre> <br></blockquote><br><h3 id="slivaem-izmeneniya">  √Ñnderungen zusammenf√ºhren </h3><br><p>  Jetzt f√ºgen wir unseren neuen Artikel √ºber Elixier zum <code>master</code> .  <em>Wechseln Sie zun√§chst</em> mit dem Alias <em>" <strong>g</strong> it <strong>c</strong> heckout <strong>m</strong> aster" zum Hauptzweig</em> : </p><br><pre> <code class="bash hljs">$ gcm <span class="hljs-comment"><span class="hljs-comment"># git checkout master</span></span></code> </pre> <br><p>  Nein, wirklich.  Einer der am h√§ufigsten verwendeten Befehle in drei leicht zu merkenden Zeichen.  Jetzt lautet die Zusammenf√ºhrung der Alias√§nderung <em>" <strong>g</strong> it <strong>m</strong> erge"</em> : </p><br><pre> <code class="bash hljs">$ gm elixir <span class="hljs-comment"><span class="hljs-comment"># git merge elixir</span></span></code> </pre> <br><p>  Ups, aber jemand hat es bereits geschafft, √Ñnderungen am <code>master</code> vorzunehmen.  Und anstelle der sch√∂nen linearen Geschichte, die in unserem Projekt √ºbernommen wurde, habe ich erstellt <del>  gehasst </del>  Merge Commit. </p><br><blockquote>  <strong>Zweige zusammenf√ºhren</strong> <br><br><pre> <code class="bash hljs">$ gm <span class="hljs-comment"><span class="hljs-comment"># git merge</span></span></code> </pre> <br></blockquote><br><h3 id="udalyaem-posledniy-kommit">  L√∂schen Sie das letzte Commit </h3><br><p>  Nichts Schlimmes!  Sie m√ºssen nur das letzte Commit l√∂schen und erneut versuchen, die √Ñnderungen zusammenzuf√ºhren. <em>" <strong>G</strong> it <strong>r</strong> eset <strong>hh</strong> ard"</em> : </p><br><blockquote>  <strong>Letzte Festschreibung l√∂schen</strong> <br><br><pre> <code class="bash hljs">$ grhh HEAD~ <span class="hljs-comment"><span class="hljs-comment"># git reset --hard HEAD~</span></span></code> </pre> <br></blockquote><br><h3 id="reshaem-konflikty">  Wir l√∂sen Konflikte </h3><br><p>  Die Standard- <code>checkout ‚Äì rebase ‚Äì merge</code> Sequenz zum <code>checkout ‚Äì rebase ‚Äì merge</code> eines linearen √Ñnderungsverlaufs wird von der folgenden Aliase-Sequenz ausgef√ºhrt: </p><br><pre> <code class="bash hljs">gco elixir <span class="hljs-comment"><span class="hljs-comment"># git checkout elixir grbm # git rebase master gcm # git checkout master gm elixir # git merge elixir</span></span></code> </pre> <br><p>  Alle von ihnen werden so oft verwendet, dass sie bereits von den Fingern wegfliegen, und bei solchen Operationen muss nicht √ºberlegt werden, welche Buchstaben eingegeben werden sollen.  Und vergessen Sie nicht, dass Sie in <code>Zsh</code> die Namen von Zweigen mit der <code>Tab</code> erg√§nzen k√∂nnen. </p><br><blockquote>  <strong>Machen Sie eine Rebase</strong> <br><br><pre> <code class="bash hljs">$ grb <span class="hljs-comment"><span class="hljs-comment"># git rebase</span></span></code> </pre> <br></blockquote><br><h3 id="otpravka-izmeneniy-na-server">  √úbermitteln von √Ñnderungen an den Server </h3><br><p>  Zuerst f√ºgen wir den <code>origin</code> Alias <em>" <strong>g</strong> it <strong>r</strong> emote <strong>a</strong> dd" hinzu</em> : </p><br><pre> <code class="bash hljs">$ gra origin git@github.com/... <span class="hljs-comment"><span class="hljs-comment"># git remote add origin git@github.com/...</span></span></code> </pre> <br><p>  Und dann senden wir die √Ñnderungen direkt an den aktuellen Zweig des Repositorys ( <em>"gg"</em> - doppeltes <code>g</code> am Anfang des Befehls zeigt die Ausf√ºhrung der Aktion im aktuellen Zweig an): </p><br><pre> <code class="bash hljs">$ ggpush <span class="hljs-comment"><span class="hljs-comment"># git push origin git_current_branch</span></span></code> </pre> <br><p>  <strong>Sie k√∂nnen auch ...</strong> </p><br><p>  ... senden Sie die √Ñnderungen mit der <code>upstream</code> Installation des Alias <em>" <strong>g</strong> it <strong>p</strong> ush <strong>s</strong> et <strong>up</strong> stream"</em> an den Server: </p><br><pre> <code class="bash hljs">$ gpsup <span class="hljs-comment"><span class="hljs-comment"># git push --set-upstream origin $(git_current_branch)</span></span></code> </pre> <br><blockquote>  <strong>Senden Sie die √Ñnderungen an den Server</strong> <br><br><pre> <code class="bash hljs">$ gp <span class="hljs-comment"><span class="hljs-comment"># git push</span></span></code> </pre> <br></blockquote><br><h3 id="poluchaem-izmeneniya-s-servera">  Wir erhalten √Ñnderungen vom Server </h3><br><p>  Die Arbeit ist in vollem Gange.  Es ist uns gelungen, einen neuen Artikel <code>f.md</code> zum <code>master</code> hinzuzuf√ºgen, und unsere Kollegen haben den Artikel <code>a.md</code> ge√§ndert und diese √Ñnderung an den Server gesendet.  Diese Situation ist auch sehr einfach zu l√∂sen: </p><br><pre> <code class="bash hljs">$ gup <span class="hljs-comment"><span class="hljs-comment"># git pull --rebase</span></span></code> </pre> <br><p>  Dann k√∂nnen Sie sicher √Ñnderungen an den Server senden.  Der Konflikt ist beigelegt. </p><br><blockquote>  <strong>Holen Sie sich √Ñnderungen vom Server</strong> <br><br><pre> <code class="bash hljs">$ gl <span class="hljs-comment"><span class="hljs-comment"># git pull</span></span></code> </pre> <br></blockquote><br><h3 id="udalyaem-slitye-vetki">  Zusammengef√ºhrte Zweige l√∂schen </h3><br><p>  Daher haben wir mehrere Zweige erfolgreich zu <code>master</code> , einschlie√ülich des <code>elixir</code> aus dem vorherigen Beispiel.  Wir brauchen sie nicht mehr.  Sie k√∂nnen den Alias <em>" <strong>g</strong> it <strong>b</strong> ranch <strong>d</strong> elete <strong>a</strong> nother" entfernen</em> : </p><br><pre> <code class="bash hljs">$ gbda <span class="hljs-comment"><span class="hljs-comment"># git branch --no-color --merged | command grep -vE "^(\*|\s*(master|develop|dev)\s*$)" | command xargs -n 1 git branch -d</span></span></code> </pre> <br><p>  Sehr sch√∂nes und gerissenes Team.  Normalerweise vergesse ich, Zweige zu l√∂schen, die an Relevanz verloren haben, und dieses anmutige Team ist eine echte Rettung.  Wenn Sie keinen Alias ‚Äã‚Äãverwenden m√∂chten, kopieren Sie einfach die Vollversion des Befehls in Ihre Notizen und f√ºhren Sie ihn nach Bedarf aus. </p><br><h3 id="sozdayom-vremennyy-kommit">  Erstellen Sie ein tempor√§res Commit </h3><br><p>  Die Arbeit an einem neuen <code>h.md</code> Artikel √ºber Haskell ist in vollem Gange.  Die H√§lfte ist geschrieben und Sie m√ºssen Feedback von einem Kollegen erhalten.  Ohne nachzudenken, geben wir den Alias <em>" <strong>g</strong> it <strong>w</strong> ork <strong>i</strong> n <strong>p</strong> rogress" ein</em> : </p><br><pre> <code class="bash hljs">$ gwip <span class="hljs-comment"><span class="hljs-comment"># git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m "--wip-- [skip ci]"</span></span></code> </pre> <br><p>  Anschlie√üend wird ein Commit mit dem Namen <code>Work in Progress</code> , wobei CI √ºbersprungen und die "zus√§tzlichen" Dateien gel√∂scht werden.  Wir senden den Zweig an den Server, sprechen √ºber diesen Kollegen und warten auf die √úberpr√ºfung. </p><br><p>  Dann kann dieses Commit r√ºckg√§ngig gemacht und die Dateien in ihren urspr√ºnglichen Zustand zur√ºckversetzt werden: </p><br><pre> <code class="bash hljs">$ gunwip <span class="hljs-comment"><span class="hljs-comment"># git log -n 1 | grep -q -c "\-\-wip\-\-" &amp;&amp; git reset HEAD~1</span></span></code> </pre> <br><p>  Verwenden Sie den folgenden Befehl, um zu √ºberpr√ºfen, ob in Ihrer Zweigstelle <code>WIP</code> Commits vorhanden sind: </p><br><pre> <code class="bash hljs">$ work_in_progress</code> </pre> <br><p>  Der Befehl <code>gwip</code> ist ein ziemlich zuverl√§ssiges Analogon von <code>stash</code> wenn Sie zu einem benachbarten Zweig wechseln m√ºssen.  Aber in <code>Zsh</code> gibt es viele Aliase f√ºr <code>stash</code> . </p><br><blockquote>  <strong>Tempor√§res Commit hinzuf√ºgen / Tempor√§res Commit zur√ºcksetzen</strong> <br><br><pre> <code class="bash hljs">$ gwip $ gunwip</code> </pre> <br></blockquote><br><h2 id="pryachem-izmeneniya">  √Ñnderungen verbergen </h2><br><p>  <strong>Sie m√ºssen mit diesem Befehl vorsichtig sein.</strong>  Dateien k√∂nnen ausgeblendet und dann mit einer unachtsamen Aktion vollst√§ndig gel√∂scht werden, da es ein <code>reflog</code> in dem Sie versuchen k√∂nnen, die verlorene Arbeit zu finden. </p><br><p>  Verstecken wir die Dateien, an denen wir arbeiten, mit dem Alias <em><strong>g</strong> it <strong>st</strong> ash <strong>a</strong> ll</em> : </p><br><pre> <code class="bash hljs">$ gsta <span class="hljs-comment"><span class="hljs-comment"># git stash save</span></span></code> </pre> <br><p>  Und geben Sie sie dann mit dem Alias <em>" <strong>g</strong> it <strong>st</strong> ash <strong>p</strong> op" zur√ºck</em> : </p><br><pre> <code class="bash hljs">$ gstp <span class="hljs-comment"><span class="hljs-comment"># git stash pop</span></span></code> </pre> <br><p>  Oder die sicherere <em>Methode ‚Äû <strong>g</strong> it <strong>st</strong> ash <strong>a</strong> ll <strong>a</strong> pply‚Äú</em> : </p><br><pre> <code class="bash hljs">$ gstaa <span class="hljs-comment"><span class="hljs-comment"># git stash apply</span></span></code> </pre> <br><p>  <strong>Sie k√∂nnen auch ...</strong> </p><br><p>  ... sehen, was genau wir versteckt haben: </p><br><pre> <code class="bash hljs">gsts <span class="hljs-comment"><span class="hljs-comment"># git stash show --text</span></span></code> </pre> <br><p>  ... Abk√ºrzungen f√ºr verwandte Befehle verwenden: </p><br><pre> <code class="bash hljs">gstc <span class="hljs-comment"><span class="hljs-comment"># git stash clear gstd # git stash drop gstl # git stash list</span></span></code> </pre> <br><blockquote>  <strong>√Ñnderungen ausblenden / √Ñnderungen abrufen</strong> <br><br><pre> <code class="bash hljs">$ gsta $ gstaa</code> </pre> <br></blockquote><br><h3 id="ischem-bag">  Auf der Suche nach einem Fehler </h3><br><p>  Das <code>git-bisect</code> Tool, das mir immer wieder das Leben gerettet hat, hat auch seine eigenen Aliase.  Wir beginnen mit dem Start der Prozedur "Bin√§re Fehlersuche" mit dem <em>Alias ‚Äã‚Äã" <strong>g</strong> it <strong>b</strong> i <strong>s</strong> ect <strong>s</strong> tart"</em> : </p><br><pre> <code class="bash hljs">$ gbss <span class="hljs-comment"><span class="hljs-comment"># git bisect start</span></span></code> </pre> <br><p>  Wir stellen fest, dass das aktuelle Commit als letztes in der Verzweigung einen Fehler mit dem Alias <em>" <strong>g</strong> it <strong>b</strong> i <strong>s</strong> ect <strong>b</strong> ad" enth√§lt</em> : </p><br><pre> <code class="bash hljs">$ gbsb <span class="hljs-comment"><span class="hljs-comment"># git bisect bad</span></span></code> </pre> <br><p>  Jetzt markieren wir das Commit, das uns den Betriebszustand der Anwendung garantiert: <em>‚Äû <strong>g</strong> it <strong>b</strong> i <strong>s</strong> ect <strong>g</strong> ood‚Äú</em> : </p><br><pre> <code class="bash hljs">$ gbsg HEAD~20 <span class="hljs-comment"><span class="hljs-comment"># git bisect good HEAD~20</span></span></code> </pre> <br><p>  Und jetzt bleibt es weiterhin, <code>gbsb</code> Fragen mit den S√§tzen <code>gbsb</code> oder <code>gbsg</code> zu beantworten und nach dem Auffinden des <code>gbsg</code> das Verfahren zur√ºckzusetzen: </p><br><pre> <code class="bash hljs">$ gbsr <span class="hljs-comment"><span class="hljs-comment"># git bisect reset</span></span></code> </pre> <br><p>  Und ich schreibe diese Abk√ºrzungen wirklich, wenn ich dieses Werkzeug benutze. </p><br><blockquote>  <strong>Fehler beim Festschreiben der Suche</strong> <br><br><pre> <code class="bash hljs">$ gbss <span class="hljs-comment"><span class="hljs-comment"># git bisect start $ gbsb # git bisect bad $ gbsg # git bisect good $ gbsr # git bisect reset</span></span></code> </pre> <br></blockquote><br><h3 id="ischem-zachinschika-bespredela">  Wir suchen den Anstifter der Gesetzlosigkeit </h3><br><p>  Selbst bei einem hohen Prozentsatz der Codeabdeckung mit Tests ist niemand vor einer Situation gefeit, in der die Anwendung abst√ºrzt und freundlicherweise auf eine bestimmte fehlerhafte Zeile zeigt.  In unserem Fall m√∂chten wir beispielsweise herausfinden, wer in der zweiten Zeile der Datei <code>a.md</code> einen Fehler <code>a.md</code> .  F√ºhren Sie dazu den folgenden Befehl aus: </p><br><pre> <code class="bash hljs">$ gbl a.md -L 2 <span class="hljs-comment"><span class="hljs-comment"># git blame -b -w a.md -L 2</span></span></code> </pre> <br><p>  Sie sehen, <code>Oh My Zsh</code> Mitarbeiter haben nicht nur einen Alias ‚Äã‚Äãf√ºr das <code>git blame</code> Team erstellt, sondern auch Schl√ºssel hinzugef√ºgt, die es einfach machen, den Anstifter direkt zu finden. </p><br><h2 id="bonus">  Bonus </h2><br><h3 id="prosmotr-spiska-kommitov">  Zeigen Sie eine Liste der Commits an </h3><br><p>  Verwenden Sie zum Anzeigen der Liste der Commits den Befehl <code>git log</code> mit zus√§tzlichen Ausgabeformatierungsschl√ºsseln.  Normalerweise wird dieser Befehl zusammen mit den Schl√ºsseln in die benutzerdefinierten Aliase von Gita eingegeben.  Wir haben mehr Gl√ºck, wir haben bereits einen vorgefertigten Alias: <code>glog</code> .  Und wenn Sie das <code>tig</code> Dienstprogramm <code>tig</code> den Empfehlungen vom Anfang des Artikels installiert haben, sind Sie ein absoluter Champion. </p><br><p>  Um den Verlauf von Commits in der Konsole auf sehr bequeme Weise zu lernen, m√ºssen Sie das Wort <code>git</code> umgekehrt eingeben: </p><br><pre> <code class="bash hljs">$ tig</code> </pre> <br><p>  Das Dienstprogramm bietet auch einige n√ºtzliche Erg√§nzungen, die nicht sofort in der Gita enthalten sind. </p><br><p>  Zun√§chst ein Befehl zum Durchsuchen des Inhalts einer Geschichte: </p><br><pre> <code class="bash hljs">$ tig grep</code> </pre> <br><p>  Zweitens: Anzeigen einer Liste aller Quellen, Zweige und Tags mit ihrem Verlauf: </p><br><pre> <code class="bash hljs">$ tig refs</code> </pre> <br><p>  Drittens finden Sie vielleicht etwas Interessantes f√ºr sich selbst: </p><br><pre> <code class="bash hljs">$ tig --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre> <br><h3 id="sluchayno-sdelal-git-reset---hard">  Versehentlich <code>git reset --hard</code> </h3><br><p>  Sie haben den ganzen Tag am <code>elixir</code> : </p><br><pre> <code class="hljs pgsql">$ glog * <span class="hljs-number"><span class="hljs-number">17</span></span>cb385 (HEAD -&gt; elixir) Refine Elixir article * c14b4dc <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> article about Elixir * db84d54 (master) Initial <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span></code> </pre> <br><p>  Und am Ende haben sie versehentlich alles gel√∂scht: </p><br><pre> <code class="bash hljs">$ grhh HEAD~2 HEAD is now at db84d54 Initial commit</code> </pre> <br><p>  Kein Grund zur Panik.  <strong>Die wichtigste Regel ist, die Ausf√ºhrung von Befehlen in der Gita zu beenden und auszuatmen</strong> .  Alle Aktionen mit dem lokalen Repository werden in einem speziellen Protokoll- <code>reflog</code> .  Daraus k√∂nnen Sie den Hash des gew√ºnschten Commits abrufen und im Arbeitsbaum wiederherstellen. </p><br><p>  Schauen wir uns das Reflog an, aber nicht auf die √ºbliche Weise durch <code>git reflog</code> , sondern interessanter mit einem detaillierten Transkript: </p><br><pre> <code class="bash hljs">$ glg -g</code> </pre> <br><p>  Suchen Sie den Hash des gew√ºnschten <code>17cb385</code> Commits und stellen Sie ihn wieder her: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#           $ gcb elixir-recover 17cb385 #    $ gbd elixir #     $ gb -m elixir</span></span></code> </pre> <br><h3 id="sluchayno-vmesto-sozdaniya-novogo-kommita-vnyos-izmeneniya-v-predyduschiy">  Anstatt ein neues Commit zu erstellen, habe ich zuf√§llig √Ñnderungen am vorherigen vorgenommen </h3><br><p>  Auch hier kommen wir zur Rettungshilfe um.  Wir finden den Hash des urspr√ºnglichen <code>17cb385</code> Commits. Wenn wir den Commit sofort abbrechen, k√∂nnen wir anstelle des Hash den Quick-Link zu <code>HEAD@{1}</code> .  Als n√§chstes f√ºhren wir einen Soft-Reset durch, w√§hrend der Index nicht zur√ºckgesetzt wird: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      $ grh --soft HEAD@{1} # git reset -soft #   $ gcmsg "Commit description"</span></span></code> </pre> <br><h3 id="vetka-slishkom-silno-ustarela">  Der Zweig ist zu alt </h3><br><p>  Manchmal beginnt man mit der Arbeit an einem Feature, aber die Ver√∂ffentlichung wird auf unbestimmte Zeit verz√∂gert.  Sie verpflichten sich und wechseln zu anderen Aufgaben.  Zusammen mit dem Team nehmen Sie eine Reihe von √Ñnderungen am Master vor und kehren nach einer Weile mit Funktionen zum Zweig zur√ºck.  Sie versuchen, die Basis neu zu bestimmen, aber er bietet an, Konflikte in einem Dutzend Commits zu analysieren.  Sie k√∂nnen versuchen, sie alle zu l√∂sen oder es einfacher zu machen. </p><br><p>  Schauen wir uns ein Beispiel f√ºr einen Feature-Zweig namens <code>elixir</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   master $ gcm # git checkout master #        $ gcb elixir-new # git checkout --branch elixir-new #           $ gcp elixir@{0} # git cherry-pick elixir@{0}</span></span></code> </pre> <br><p>  Anstatt zu versuchen, den Zweig zu aktualisieren, nehmen wir ein einzelnes Commit ohne Probleme und √ºbertragen es. </p><br><h3 id="udalenie-vazhnyh-dannyh-iz-repozitoriya">  Wichtige Daten aus dem Repository entfernen </h3><br><p>  Um wichtige Daten aus dem Repository zu l√∂schen, habe ich das folgende Snippet gespeichert: </p><br><pre> <code class="bash hljs">$ git filter-branch --force --index-filter <span class="hljs-string"><span class="hljs-string">'git rm --cached --ignore-unmatch &lt;path-to-your-file&gt;'</span></span> --prune-empty --tag-name-filter cat -- --all &amp;&amp; git push origin --force --all</code> </pre> <br><p>  <strong>Wenn Sie diesen Befehl <code>stash</code> wird Ihr <code>stash</code> .</strong>  Vor der Ausf√ºhrung wird empfohlen, alle versteckten √Ñnderungen zu erhalten.  Lesen Sie hier mehr √ºber diese Technik. </p><br><h3 id="obraschenie-k-predyduschey-vetke">  Bezugnehmend auf den vorherigen Zweig </h3><br><p>  Wenn Sie einige Befehle ausf√ºhren, bei denen die Eingabe eines Zweignamens erwartet wird, k√∂nnen Sie einen Bindestrich als Referenz auf den Zweig √ºbergeben, mit dem wir gekommen sind.  Es ist besonders gut, diesen Checkout-Trick zu verwenden: </p><br><pre> <code class="bash hljs">$ gco - <span class="hljs-comment"><span class="hljs-comment"># git checkout - $ gm - # git merge - $ grb - # git rebase -</span></span></code> </pre> <br><h3 id="udalenie-vseh-faylov-otmechennyh-v-gitignore">  L√∂schen Sie alle in <code>.gitignore</code> markierten <code>.gitignore</code> </h3><br><p>  Ein weiterer h√§ufiger R√ºckschlag ist zu sp√§t, um unerw√ºnschte Dateien oder Verzeichnisse zu <code>.gitignore</code> .  Um sie aus dem Repository zu bereinigen ( <strong>und von der Festplatte zu l√∂schen</strong> ), gibt es bereits vorgefertigte Schl√ºssel f√ºr den Befehl <code>git clean</code> : </p><br><pre> <code class="bash hljs">$ gclean -X <span class="hljs-comment"><span class="hljs-comment"># git clean -Xfd</span></span></code> </pre> <br><p>  <strong>Seid vorsichtig!</strong> </p><br><p>  Lesen Sie weiter f√ºr den richtigen Weg. </p><br><h3 id="zachem-mnogim-komandam-nuzhen-klyuch---dry-run">  Warum brauchen viele Teams den Schalter <code>--dry-run</code> ? </h3><br><p>  Der <code>--dry-run</code> nur als Vorsichtsma√ünahme bei der Deinstallation und Aktualisierung ben√∂tigt.  Im vorherigen Abschnitt wurde beispielsweise beschrieben, wie Sie alles l√∂schen, was in der <code>.gitignore</code> Datei angegeben ist.  Es ist besser, vorsichtig zu sein und den Schalter <code>--dry-run</code> , <code>--dry-run</code> Liste aller zu l√∂schenden Dateien <code>--dry-run</code> und den Befehl erst dann ohne <code>--dry-run</code> . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Artikel zeigt einen Punkt zur Optimierung der Arbeit des Programmierers.  Denken Sie daran, 10-20 mnemonische Abk√ºrzungen sind nicht schwierig, vergessen Sie, dass das urspr√ºngliche Team fast unm√∂glich ist.  Die Aliase sind standardisiert. Wenn Sie also das gesamte Team auf <code>Zsh</code> + <code>Oh My Zsh</code> , k√∂nnen Sie auch bei der <code>Oh My Zsh</code> mit der gleichen Geschwindigkeit und dem gleichen Komfort arbeiten. </p><br><h3 id="kuda-dvigatsya-dalshe">  Wohin als n√§chstes? </h3><br><p>  Ich biete folgende Optionen an: </p><br><ol><li>  Stellen Sie schlie√ülich fest, wie das Geet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Inneren angeordnet ist</a> .  Es hilft zu verstehen, was Sie tun und warum das, was Sie tun m√∂chten, nicht funktioniert. </li><li>  <code>git --help</code> Sie nicht faul, noch einmal die Dokumentation f√ºr die Befehle zu <code>git --help</code> : <code>git --help</code> oder <code>ghh</code> . </li><li>  Die vollst√§ndige Liste der Aliase finden Sie <a href="">unter dem Link</a> .  Der Versuch, sich an alle zu erinnern, ist verr√ºckt, aber die Liste als Sammlung interessanter Befehle und Schl√ºssel zu verwenden, ist eine gute Idee. </li></ol><br><p>  Einige Aliase werden nicht trivial erstellt, erweisen sich jedoch in der Praxis als sehr n√ºtzlich.  Viele der vorgestellten Aliase sind nicht nur Abk√ºrzungen, sondern kleine Funktionen, die die Arbeit weiter optimieren.  Die Verwendung von Git ist angenehmer geworden, die Qualit√§t der Commits hat sich verbessert. </p><br><p>  Ich hoffe, das Material hat sich als n√ºtzlich erwiesen und Sie konnten etwas Neues f√ºr sich selbst lernen.  Oder vielleicht haben sie bereits begonnen, einen neuen Ansatz aktiv einzuf√ºhren.  Viel Gl√ºck </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420529/">https://habr.com/ru/post/de420529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420519/index.html">Popularisierung der Wissenschaft</a></li>
<li><a href="../de420521/index.html">Jetzt offiziell: TLS 1.3 als Standard anerkannt</a></li>
<li><a href="../de420523/index.html">Analyse von bin√§ren Optionsdiagrammen oder wie ich mir erneut bewiesen habe, dass es keine Werbegeschenke gibt</a></li>
<li><a href="../de420525/index.html">Netzwerke f√ºr die erfahrensten. Teil f√ºnfzehn. QoS</a></li>
<li><a href="../de420527/index.html">Ein L√§cheln kann klingen und es ist ansteckend</a></li>
<li><a href="../de420533/index.html">Emulieren von Eigenschaftsliteralen mit der Java 8-Methodenreferenz</a></li>
<li><a href="../de420537/index.html">Eine andere Geschichte dar√ºber, wie Geld relativ ehrlich mit einem Megaphon aufgenommen wird</a></li>
<li><a href="../de420539/index.html">Benutzerdefinierter Ansatz zum Normalisieren und Zur√ºcksetzen von Stilen (custom-reset.css)</a></li>
<li><a href="../de420541/index.html">Forscher von Carnegie Mellon haben die glaubw√ºrdigsten ‚ÄûDeepfakes‚Äú geschaffen</a></li>
<li><a href="../de420547/index.html">Wie ich schrieb und verteidigte ein Diplom in DEVOPS und Ingenieurspraktiken in 1C von Grund auf neu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>