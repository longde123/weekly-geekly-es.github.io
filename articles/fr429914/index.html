<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùÔ∏è üë∏üèø üêÆ OpenSceneGraph: graphique de sc√®ne et pointeurs intelligents ‚òÑÔ∏è üí° ‚ôæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Dans un article pr√©c√©dent, nous avons examin√© l'assemblage OpenSceneGraph √† partir de la source et √©crit un exemple √©l√©mentaire dans le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: graphique de sc√®ne et pointeurs intelligents</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429914/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><br><h1>  Pr√©sentation </h1><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent,</a> nous avons examin√© l'assemblage OpenSceneGraph √† partir de la source et √©crit un exemple √©l√©mentaire dans lequel un plan gris se bloque dans un monde violet vide.  Je suis d'accord, pas trop impressionnant.  Cependant, comme je l'ai dit plus t√¥t, dans ce petit exemple, il existe les principaux concepts sur lesquels ce moteur graphique est bas√©.  Examinons-les plus en d√©tail.  Le mat√©riel ci-dessous utilise des illustrations du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexander Bobkov sur OSG</a> (c'est dommage que l'auteur ait abandonn√© d'√©crire sur OSG ...).  L'article est √©galement bas√© sur du mat√©riel et des exemples du livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSceneGraph 3.0.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide du d√©butant</a> <br><br>  Je dois dire que la publication pr√©c√©dente a fait l'objet de certaines critiques, avec lesquelles je suis partiellement d'accord - le mat√©riel est sorti non dit et sorti de son contexte.  Je vais essayer de corriger cette omission sous la coupe. <br><a name="habracut"></a><br><h1>  1. En bref sur le graphique de la sc√®ne et ses n≈ìuds </h1><br>  Le concept central du moteur est le soi-disant <i>graphe de sc√®ne</i> (ce n'est pas un hasard s'il s'est coinc√© au nom du cadre lui-m√™me) - une structure arborescente hi√©rarchique qui vous permet d'organiser une repr√©sentation logique et spatiale d'une sc√®ne en trois dimensions.  Le graphe de sc√®ne contient le n≈ìud racine et ses n≈ìuds ou <i>n≈ìuds</i> interm√©diaires et terminaux associ√©s. <br><br>  Par exemple <br><br><img src="https://habrastorage.org/webt/va/m7/l4/vam7l4ap2qwqgyev2ofzlcbt-vo.png"><br><br>  Ce graphique repr√©sente une sc√®ne compos√©e d'une maison et d'une table.  La maison a une certaine repr√©sentation g√©om√©trique et est situ√©e d'une certaine mani√®re dans l'espace par rapport √† un certain syst√®me de coordonn√©es de base associ√© au n≈ìud racine (racine).  Le tableau est √©galement d√©crit par une g√©om√©trie, situ√©e d'une certaine mani√®re par rapport √† la maison, et avec la maison - par rapport au n≈ìud racine.  Tous les n≈ìuds, ayant une propri√©t√© commune, car ils h√©ritent d'une classe osg :: Node, sont divis√©s en types selon leur fonction <br><br><ol><li>  Les n≈ìuds de groupe (osg :: Group) - sont la classe de base pour tous les n≈ìuds interm√©diaires et sont con√ßus pour combiner d'autres n≈ìuds en groupes </li><li>  Noeuds de transformation (osg :: Transform et ses descendants) - con√ßus pour d√©crire la transformation des coordonn√©es d'objet </li><li>  Noeuds g√©om√©triques (osg :: Geode) - noeuds terminaux (feuilles) du graphe de sc√®ne contenant des informations sur un ou plusieurs objets g√©om√©triques. </li></ol><br>  La g√©om√©trie des objets de sc√®ne dans OSG est d√©crite dans son propre syst√®me de coordonn√©es local de l'objet.  Les n≈ìuds de transformation situ√©s entre cet objet et le n≈ìud racine impl√©mentent des transformations de coordonn√©es matricielles pour obtenir la position de l'objet dans le syst√®me de coordonn√©es de base. <br><br>  Les n≈ìuds remplissent de nombreuses fonctions importantes, en particulier, stockent l'√©tat de l'affichage des objets, et cet √©tat affecte uniquement le sous-graphique associ√© √† ce n≈ìud.  Plusieurs rappels peuvent √™tre associ√©s aux n≈ìuds du graphe de sc√®ne, des gestionnaires d'√©v√©nements qui vous permettent de modifier l'√©tat du n≈ìud et le sous-graphique qui lui est associ√©. <br><br>  Toutes les op√©rations globales sur le graphe de sc√®ne associ√©es √† l'obtention du r√©sultat final √† l'√©cran sont effectu√©es automatiquement par le moteur, en parcourant p√©riodiquement le graphe en profondeur. <br><br>  Dans l'exemple examin√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">derni√®re fois</a> , notre sc√®ne consistait en un seul objet - un mod√®le d'avion charg√© √† partir d'un fichier.  En regardant tr√®s loin, je dirai que ce mod√®le est le n≈ìud feuille du graphe de sc√®ne.  Il est √©troitement soud√© au syst√®me de coordonn√©es de base global du moteur. <br><br><h1>  2. Gestion de la m√©moire OSG </h1><br>  √âtant donn√© que les n≈ìuds du graphe de sc√®ne stockent beaucoup de donn√©es sur les objets de sc√®ne et les op√©rations sur eux, il est n√©cessaire d'allouer de la m√©moire, y compris de mani√®re dynamique, pour stocker ces donn√©es.  Dans ce cas, lors de la manipulation du graphique de la sc√®ne et, par exemple, de la suppression de certains de ses n≈ìuds, vous devez surveiller attentivement que les n≈ìuds supprim√©s du graphique ne sont plus trait√©s.  Ce processus s'accompagne toujours d'erreurs et d'un d√©bogage long, car il est assez difficile pour le d√©veloppeur de suivre les pointeurs vers les objets qui font r√©f√©rence aux donn√©es existantes et ceux qui doivent √™tre supprim√©s.  Sans une gestion efficace de la m√©moire, les erreurs de segmentation et les fuites de m√©moire sont plus susceptibles de se produire. <br><br>  La gestion de la m√©moire est une t√¢che critique dans OSG et son concept repose sur deux points: <br><br><ol><li>  Allocation de m√©moire: assurer l'allocation de la quantit√© de m√©moire n√©cessaire au stockage d'un objet. <br></li><li>  Lib√©rez de la m√©moire: renvoyez la m√©moire allou√©e au syst√®me lorsqu'elle n'est pas n√©cessaire. <br></li></ol><br>  De nombreux langages de programmation modernes, tels que C #, Java, Visual Basic .Net et similaires, utilisent le soi-disant garbage collector pour lib√©rer la m√©moire allou√©e.  Le concept du langage C ++ ne pr√©voit pas une telle approche, cependant, nous pouvons l'imiter en utilisant les soi-disant pointeurs intelligents. <br><br>  Aujourd'hui, C ++ a des pointeurs intelligents dans son arsenal, qui est appel√© ¬´pr√™t √† l'emploi¬ª (et la norme C ++ 17 a d√©j√† r√©ussi √† d√©barrasser le langage de certains types obsol√®tes de pointeurs intelligents), mais ce n'√©tait pas toujours le cas.  La premi√®re des versions officielles de l'OSG num√©rot√©e 0,9 est n√©e en 2002, et il restait trois ans avant la premi√®re version officielle.  √Ä cette √©poque, la norme C ++ ne pr√©voyait pas encore de pointeurs intelligents, et m√™me si vous croyez √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une digression historique</a> , le langage lui-m√™me traversait des moments difficiles.  Ainsi, l'apparition d'un v√©lo sous la forme de ses propres pointeurs intelligents, qui sont mis en ≈ìuvre dans OSG, n'est pas du tout surprenante.  Ce m√©canisme est profond√©ment int√©gr√© dans la structure du moteur, il est donc absolument n√©cessaire de comprendre son fonctionnement d√®s le d√©but. <br><br><h1>  3. Les classes osg :: ref_ptr &lt;&gt; et osg :: Referenced </h1><br>  OSG fournit son propre m√©canisme de pointeur intelligent bas√© sur la classe de mod√®le osg :: ref_ptr &lt;&gt; pour impl√©menter le garbage collection automatique.  Pour son bon fonctionnement, OSG fournit une autre classe osg :: Referenced pour g√©rer les blocs de m√©moire dont la r√©f√©rence est compt√©e. <br><br>  La classe osg :: ref_ptr &lt;&gt; fournit plusieurs op√©rateurs et m√©thodes. <br><br><ul><li>  get () est une m√©thode publique qui renvoie un pointeur brut, par exemple, lorsque vous utilisez le mod√®le osg :: Node comme argument, cette m√©thode renvoie osg :: Node *. <br></li><li>  L'op√©rateur * () est en fait l'op√©rateur de d√©r√©f√©rence. <br></li><li>  operator -&gt; () et operator = () - vous permettent d'utiliser osg :: ref_ptr &lt;&gt; comme pointeur classique lors de l'acc√®s aux m√©thodes et propri√©t√©s des objets d√©crits par ce pointeur. <br></li><li>  operator == (), operator! = () et operator! () - vous permettent d'effectuer des op√©rations de comparaison sur des pointeurs intelligents. <br></li><li>  valid () est une m√©thode publique qui renvoie true si le pointeur g√©r√© a la valeur correcte (pas NULL).  L'expression some_ptr.valid () est √©quivalente √† l'expression some_ptr! = NULL si some_ptr est un pointeur intelligent. <br></li><li>  release () est une m√©thode publique, utile lorsque vous souhaitez renvoyer une adresse g√©r√©e √† partir d'une fonction.  √Ä ce sujet sera d√©crit plus en d√©tail ult√©rieurement. <br></li></ul><br>  La classe osg :: Referenced est la classe de base pour tous les √©l√©ments du graphique de sc√®ne, tels que les n≈ìuds, la g√©om√©trie, les √©tats de rendu et les autres objets plac√©s sur la sc√®ne.  Ainsi, en cr√©ant le n≈ìud racine de la sc√®ne, nous h√©ritons indirectement de toutes les fonctionnalit√©s fournies par la classe osg :: Referenced.  Par cons√©quent, dans notre programme, il y a une annonce <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root;</code> </pre> <br>  La classe osg :: Referenced contient un compteur entier pour les r√©f√©rences au bloc de m√©moire allou√©.  Ce compteur est initialis√© √† z√©ro dans le constructeur de classe.  Il est incr√©ment√© de un lorsque l'objet osg :: ref_ptr &lt;&gt; est cr√©√©.  Ce compteur diminue d√®s que toute r√©f√©rence √† l'objet d√©crit par ce pointeur est supprim√©e.  Un objet est automatiquement d√©truit lorsqu'un pointeur intelligent cesse de le r√©f√©rencer. <br><br>  La classe osg :: Referenced a trois m√©thodes publiques: <br><br><ul><li>  ref () est une m√©thode publique qui incr√©mente de 1 r√©f√©rence. <br></li><li>  unref () est une m√©thode publique, diminuant d'un d√©compte de r√©f√©rences. <br></li><li>  referenceCount () est une m√©thode publique qui renvoie la valeur actuelle du compteur de r√©f√©rence, ce qui est utile lors du d√©bogage du code. <br></li></ul><br>  Ces m√©thodes sont disponibles dans toutes les classes d√©riv√©es de osg :: Referenced.  Cependant, il faut se rappeler que le contr√¥le manuel du compteur de liens peut entra√Æner des cons√©quences impr√©visibles, et en l'utilisant, vous devez comprendre clairement ce que vous faites. <br><br><h1>  4. Comment OSG collecte les ordures et pourquoi est-il n√©cessaire </h1><br>  Il existe plusieurs raisons pour lesquelles des pointeurs intelligents et la r√©cup√©ration de place doivent √™tre utilis√©s: <br><br><ul><li>  Minimisation des erreurs critiques: l'utilisation de pointeurs intelligents vous permet d'automatiser l'allocation et la lib√©ration de m√©moire.  Il n'y a pas de pointeurs bruts dangereux. <br></li><li>  Gestion efficace de la m√©moire: la m√©moire allou√©e √† l'objet est lib√©r√©e imm√©diatement, d√®s que l'objet devient inutile, ce qui conduit √† une utilisation √©conomique des ressources syst√®me. <br></li><li>  Facilitation du d√©bogage d'application: ayant la capacit√© de suivre clairement le nombre de liens vers un objet, nous avons des opportunit√©s pour diff√©rents types d'optimisations et d'exp√©riences. <br></li></ul><br>  Supposons qu'un graphe de sc√®ne se compose d'un n≈ìud racine et de plusieurs niveaux de n≈ìuds enfants.  Si le n≈ìud racine et tous les n≈ìuds enfants sont g√©r√©s √† l'aide de la classe osg :: ref_ptr &lt;&gt;, l'application peut uniquement suivre le pointeur vers le n≈ìud racine.  La suppression de ce n≈ìud entra√Ænera une suppression s√©quentielle et automatique de tous les n≈ìuds enfants. <br><br><img src="https://habrastorage.org/webt/5r/az/ri/5razrigi8nvg-75jwcm4vhhurda.png"><br><br>  Les pointeurs intelligents peuvent √™tre utilis√©s comme variables locales, variables globales, membres de classe et diminuer automatiquement le nombre de r√©f√©rences lorsque le pointeur intelligent sort de la port√©e. <br><br>  Les pointeurs intelligents sont fortement recommand√©s par les d√©veloppeurs OSG pour une utilisation dans les projets, mais il y a quelques points fondamentaux auxquels vous devez faire attention: <br><br><ul><li>  Les instances d'osg :: Referenced et ses d√©riv√©s peuvent √™tre cr√©√©s exclusivement sur le tas.  Ils ne peuvent pas √™tre cr√©√©s sur la pile en tant que variables locales, car les destructeurs de ces classes sont d√©clar√©s prot√©g√©s.  Par exemple <br></li></ul><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  osg::Node node; // </span></span></code> </pre><br><ul><li>  Vous pouvez cr√©er des n≈ìuds de sc√®ne temporaires √† l'aide de pointeurs C ++ normaux, mais cette approche n'est pas s√ªre.  Il est pr√©f√©rable d'utiliser des pointeurs intelligents pour vous assurer que le graphique de la sc√®ne est correctement g√©r√©. <br></li></ul><br><pre> <code class="cpp hljs">osg::Node *tmpNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  ,  ... osg::ref_ptr&lt;osg::Node&gt; node = tmpNode; //         !</span></span></code> </pre><br><ul><li>  Vous ne devez en aucun cas utiliser des sc√®nes de liens cycliques dans l'arborescence lorsque le n≈ìud se r√©f√®re directement ou indirectement √† plusieurs niveaux <br></li></ul><br><img src="https://habrastorage.org/webt/ds/af/er/dsafertsy4m2doboaeb9cgjdzyk.png"><br><br>  Dans l'exemple de graphique du graphique de sc√®ne, le n≈ìud Child 1.1 se r√©f√®re √† lui-m√™me et le n≈ìud Child 2.2 fait √©galement r√©f√©rence au n≈ìud Child 1.2.  Ce type de liens peut entra√Æner un calcul incorrect du nombre de liens et un comportement ind√©fini du programme. <br><br><h1>  5. Suivi des objets g√©r√©s </h1><br>  Pour illustrer le fonctionnement du m√©canisme de pointeur intelligent dans OSG, nous √©crivons l'exemple synth√©tique suivant <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ref_ptr&gt; #include &lt;osg/Referenced&gt; #include &lt;iostream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class MonitoringTarget : public osg::Referenced { public: MonitoringTarget(int id) : _id(id) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Constructing target " &lt;&lt; _id &lt;&lt; std::endl; } protected: virtual ~MonitoringTarget() { std::cout &lt;&lt; "Dsetroying target " &lt;&lt; _id &lt;&lt; std::endl; } int _id; }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;MonitoringTarget&gt; target = new MonitoringTarget(0); std::cout &lt;&lt; "Referenced count before referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target; std::cout &lt;&lt; "Referenced count after referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Nous cr√©ons une classe descendante osg :: Referenced qui ne fait rien sauf dans le constructeur et le destructeur qu'elle signale que son instance est cr√©√©e et affiche l'identifiant qui est d√©termin√© lors de la cr√©ation de l'instance.  Cr√©er une instance de la classe √† l'aide du m√©canisme de pointeur intelligent <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Ensuite, nous affichons le compteur de r√©f√©rence pour l'objet cible <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count before referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Apr√®s cela, cr√©ez un nouveau pointeur intelligent, en lui affectant la valeur du pointeur pr√©c√©dent <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target;</code> </pre><br>  et afficher √† nouveau le compteur de r√©f√©rence <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count after referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Voyons ce que nous avons obtenu en analysant la sortie du programme <br><br><pre> <code class="plaintext hljs">15:42:39:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Dsetroying target 0 15:42:42:  </code> </pre><br>  Lorsque le constructeur de classe d√©marre, un message correspondant s'affiche, nous indiquant que la m√©moire de l'objet est allou√©e et que le constructeur a bien fonctionn√©.  De plus, apr√®s avoir cr√©√© un pointeur intelligent, nous voyons que le compteur de r√©f√©rence pour l'objet cr√©√© a augment√© de un.  Cr√©er un nouveau pointeur, lui attribuer la valeur de l'ancien pointeur, c'est essentiellement cr√©er un nouveau lien vers le m√™me objet, de sorte que le compteur de r√©f√©rence est incr√©ment√© par un autre.  Lorsque le programme se ferme, le destructeur de la classe MonitoringTarget est appel√©. <br><br><img src="https://habrastorage.org/webt/oi/hv/gh/oihvghcjfhchgrjkd0wpxm_hmr4.png"><br><br>  Faisons une autre exp√©rience en ajoutant un tel code √† la fin de la fonction main () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(i); }</code> </pre><br>  conduisant √† un tel programme "d'√©chappement" <br><br><pre> <code class="plaintext hljs">16:04:30:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Constructing target 1 Dsetroying target 1 Constructing target 2 Dsetroying target 2 Constructing target 3 Dsetroying target 3 Constructing target 4 Dsetroying target 4 Dsetroying target 0 16:04:32:  </code> </pre><br>  Nous cr√©ons plusieurs objets dans le corps de la boucle, √† l'aide d'un pointeur intelligent.  √âtant donn√© que la port√©e du pointeur ne s'√©tend dans ce cas qu'au corps de la boucle, √† sa sortie, le destructeur est automatiquement appel√©.  Cela n'arriverait pas, bien √©videmment, nous utiliserions les pointeurs habituels. <br><br>  La lib√©ration automatique de la m√©moire est une autre caract√©ristique importante du travail avec les pointeurs intelligents.  √âtant donn√© que le destructeur de classe d√©riv√©e osg :: Referenced est prot√©g√©, nous ne pouvons pas appeler explicitement l'op√©rateur de suppression pour supprimer l'objet.  La seule fa√ßon de supprimer un objet est de r√©initialiser le nombre de liens vers celui-ci.  Mais alors notre code devient dangereux lors du traitement de donn√©es multithread - nous pouvons acc√©der √† un objet d√©j√† supprim√© √† partir d'un autre thread. <br><br>  Heureusement, OSG fournit une solution √† ce probl√®me √† l'aide de son planificateur de suppression d'objets.  Ce planificateur est bas√© sur l'utilisation de la classe osg :: DeleteHandler.  Il fonctionne de telle mani√®re qu'il n'effectue pas l'op√©ration de suppression d'un objet imm√©diatement, mais l'ex√©cute apr√®s un certain temps.  Tous les objets √† supprimer sont stock√©s temporairement jusqu'au moment de la suppression en toute s√©curit√©, puis ils sont tous supprim√©s en m√™me temps.  Le planificateur de suppression osg :: DeleteHandler est contr√¥l√© par le backend de rendu OSG. <br><br><h1>  6. Retour de fonction </h1><br>  Ajoutez la fonction suivante √† notre exemple de code <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MonitoringTarget *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMonitoringTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.release(); }</code> </pre><br>  et remplacer l'appel au nouvel op√©rateur dans la boucle par l'appel √† cette fonction <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = createMonitoringTarget(i); }</code> </pre><br>  L'appel release () r√©duira le nombre de r√©f√©rences √† l'objet √† z√©ro, mais au lieu de supprimer la m√©moire, il renvoie directement le pointeur r√©el √† la m√©moire allou√©e.  Si ce pointeur est affect√© √† un autre pointeur intelligent, il n'y aura aucune fuite de m√©moire. <br><br><h1>  Conclusions </h1><br>  Les concepts de graphe de sc√®ne et de pointeurs intelligents sont fondamentaux pour comprendre le principe de fonctionnement, et donc l'utilisation efficace d'OpenSceneGraph.  En ce qui concerne les pointeurs intelligents OSG, n'oubliez pas que leur utilisation est absolument <br><br><ul><li>  Le stockage √† long terme de l'installation est pr√©vu. </li><li>  Un objet stocke un lien vers un autre objet </li><li>  Vous devez renvoyer un pointeur depuis une fonction </li></ul><br>  L'exemple de code fourni dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est disponible ici</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429914/">https://habr.com/ru/post/fr429914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429902/index.html">Page Rank dans l'√®re du Web 2.0 - Partie 1</a></li>
<li><a href="../fr429904/index.html">Histoires dr√¥les et tristes sur le d√©veloppement de jeux informatiques</a></li>
<li><a href="../fr429908/index.html">Comment utiliser les coroutines dans les aliments et dormir paisiblement la nuit</a></li>
<li><a href="../fr429910/index.html">AppsConf Rises</a></li>
<li><a href="../fr429912/index.html">D√©veloppement de biblioth√®que: de l'API √† la version publique</a></li>
<li><a href="../fr429916/index.html">Comment construire et construire</a></li>
<li><a href="../fr429918/index.html">Monde virtuel Intel. Partie 2: SMP</a></li>
<li><a href="../fr429920/index.html">Tragicomedy in NaN Acts: comment nous avons cr√©√© un jeu sur JS et l'avons sorti sur Steam</a></li>
<li><a href="../fr429922/index.html">Comment transformer un projet simple en une construction √† long terme ou supprimer tout ce qui n'est pas n√©cessaire</a></li>
<li><a href="../fr429928/index.html">Tout ce que vous devez savoir sur le stress et les √©motions fortes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>