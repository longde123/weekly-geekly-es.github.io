<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😿 🥈 🌁 Como esse container lateral chegou aqui [no Kubernetes]? 🏛️ 🦃 ✝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : Com este artigo, escrito por Scott Rahner, engenheiro da Dow Jones, continuamos a série de vários materiais que explicam como o Kubernet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como esse container lateral chegou aqui [no Kubernetes]?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/431252/">  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: Com este artigo, escrito por Scott Rahner, engenheiro da Dow Jones, continuamos a série de vários materiais que explicam como o Kubernetes funciona, como seus componentes básicos funcionam, são interconectados e usados.</i>  <i>Desta vez, esta é uma nota prática com um código de amostra para criar um gancho no Kubernetes, demonstrado pelo autor "a pretexto" de criar automaticamente contêineres laterais.</i> <br><br><img src="https://habrastorage.org/webt/xg/bh/80/xgbh80h6dyzuokwsgrcttaiqtxs.jpeg"><br>  <i>(Foto de Gordon A. Maxwell, encontrada na Internet.)</i> <br><br>  Quando comecei a estudar os contêineres laterais e a malha de serviço, eu precisava entender como o mecanismo principal funciona - inserção automática de um contêiner lateral.  De fato, no caso de usar sistemas como Istio ou Consul, quando o contêiner com o aplicativo é implantado, o contêiner Envoy já configurado aparece de repente em seu pod <i>(uma situação semelhante ocorre com o Conduit, sobre o qual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrevemos</a> no início do ano - aprox. Transl.)</i> .  O que?  Como  Então minha pesquisa começou ... <a name="habracut"></a><br><br>  Para quem não sabe, um contêiner lateral é implantado próximo aos contêineres do aplicativo para "ajudar" esse aplicativo de alguma forma.  Um exemplo desse uso é um proxy para gerenciar o tráfego e encerrar sessões TLS, um contêiner para transmitir logs e métricas, um contêiner para verificar problemas de segurança ... A idéia é isolar vários aspectos de todo o aplicativo da lógica de negócios usando contêineres separados para cada funções <br><br>  Antes de prosseguir, descreverei minhas expectativas.  O objetivo deste artigo não é explicar os meandros e os cenários de uso do Docker, Kubernetes, malha de serviço etc., mas demonstrar uma abordagem poderosa para expandir os recursos dessas tecnologias.  O artigo é para aqueles que já estão familiarizados com o uso dessas tecnologias ou, pelo menos, já leram muito sobre elas.  Para experimentar a parte prática em ação, você precisará de uma máquina com o Docker e o Kubernetes já configurados.  A maneira mais fácil de fazer isso é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://docs.docker.com/docker-for-windows/kubernetes/</a> (um manual do Windows que funciona com o Docker para Mac).  <i>(Nota perev.: Como alternativa aos usuários de sistemas Linux e * nix, podemos oferecer o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Minikube</a> .)</i> <br><br><h2>  Quadro geral </h2><br>  Para começar, vamos dar uma olhada no Kubernetes um pouco: <br><br><img src="https://habrastorage.org/webt/gf/dh/2d/gfdh2deneli8j1ikyuutjbf2uvm.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kube Arch</a> licenciado sob CC BY 4.0</i> <br><br>  Quando você pretende implantar algo no Kubernetes, deve enviar o objeto ao kube-apiserver.  Isso geralmente é feito passando argumentos ou um arquivo YAML para o kubectl.  Nesse caso, o servidor da API passa por vários estágios antes de colocar diretamente os dados no etcd e agendar as tarefas correspondentes: <br><br><img src="https://habrastorage.org/webt/g-/mv/hw/g-mvhwfhhsoxrdofk2be2ezkrow.jpeg"><br><br>  Essa sequência é importante para entender como funciona a inserção de contêiner lateral.  Em particular, você precisa prestar atenção ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Controle de Admissão</a> , no qual o Kubernetes valida e, se necessário, modifica objetos antes de armazená-los <i>(para obter mais detalhes sobre esta etapa, consulte o capítulo "Controle de acesso" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> - aprox. Transl.)</i> .  O Kubernetes também permite registrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webhooks</a> que podem executar validações e <i>mutações</i> definidas pelo usuário. <br><br>  No entanto, o processo de criação e registro de seus ganchos não é tão simples e bem documentado.  Eu tive que passar vários dias lendo e relendo a documentação, além de analisar o código Istio e Consul.  E quando se tratava do código de algumas das respostas da API, passei pelo menos meio dia tentando e testando aleatoriamente. <br><br>  Depois que o resultado for alcançado, acho injusto não compartilhá-lo com todos vocês.  É simples e ao mesmo tempo eficaz. <br><br><h2>  Código </h2><br>  O nome webhook fala por si - é um ponto de extremidade HTTP que implementa a API definida no Kubernetes.  Você está criando um servidor de API que o Kubernetes pode chamar antes de lidar com as implantações.  Eu tive que lidar com dificuldades aqui, pois apenas alguns exemplos estão disponíveis, alguns dos quais são apenas testes de unidade do Kubernetes, outros estão ocultos no meio de uma enorme base de código ... e todos estão escritos em Go.  Mas eu escolhi uma opção mais acessível - Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(bodyParser.json()); app.post(<span class="hljs-string"><span class="hljs-string">'/mutate'</span></span>, (req, res) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body.request.object) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adminResp = {<span class="hljs-attr"><span class="hljs-attr">response</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">allowed</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">patch</span></span>: Buffer.from(<span class="hljs-string"><span class="hljs-string">"[{ \"op\": \"add\", \"path\": \"/metadata/labels/foo\", \"value\": \"bar\" }]"</span></span>).toString(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>), <span class="hljs-attr"><span class="hljs-attr">patchType</span></span>: <span class="hljs-string"><span class="hljs-string">"JSONPatch"</span></span>, }} <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(adminResp) res.send(adminResp) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = https.createServer(options, app);</code> </pre> <br>  <i>( <a href="">index.js</a> )</i> <br><br>  O caminho para a API - neste caso <code>/mutate</code> - pode ser arbitrário (deve corresponder apenas ao YAML passado para o Kubernetes no futuro).  É importante para ele ver e entender o JSON recebido do servidor da API.  Nesse caso, não extraímos nada do JSON, mas pode ser útil em outros cenários.  No código acima, atualizamos o JSON.  São necessárias duas coisas para isso: <br><br><ol><li>  Aprenda e entenda o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSON Patch</a> . </li><li>  Converta corretamente uma expressão de JSON Patch em uma matriz de bytes codificados com base64. </li></ol><br>  Feito isso, basta passar a resposta ao servidor da API com um objeto muito simples.  Nesse caso, adicionamos o rótulo <code>foo=bar</code> qualquer pod que chega até nós. <br><br><h2>  Implantação </h2><br>  Bem, temos um código que aceita solicitações do servidor da API do Kubernetes e responde a elas, mas como implantá-lo?  E como fazer com que o Kubernetes nos redirecione essas solicitações?  Você pode implantar esse terminal em qualquer lugar em que possa acessar o servidor da API Kubernetes.  A maneira mais simples é implantar o código no próprio cluster Kubernetes, o que faremos neste exemplo.  Tentei tornar o exemplo o mais simples possível, portanto, para todas as ações, uso apenas o Docker e o kubectl.  Vamos começar criando um contêiner no qual o código será executado: <br><br><pre> <code class="plaintext hljs">FROM node:8 USER node WORKDIR /home/node COPY index.js . COPY package.json . RUN npm install #       TLS CMD node index.js</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dockerfile</a> )</i> <br><br>  Aparentemente, tudo é muito simples aqui.  Pegue a imagem da comunidade do nó e solte o código nele.  Agora você pode executar uma montagem simples: <br><br><pre> <code class="bash hljs">docker build . -t localserver</code> </pre> <br>  A próxima etapa é criar uma implantação no Kubernetes: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: webhook-server spec: replicas: 1 selector: matchLabels: component: webhook-server template: metadata: labels: component: webhook-server spec: containers: - name: webhook-server imagePullPolicy: Never image: localserver</code> </pre> <br>  <i>( <a href="">deployment.yaml</a> )</i> <br><br>  Observe como aludimos à imagem que acabamos de criar?  Também poderia ser um pod e outra coisa à qual podemos conectar um serviço no Kubernetes.  Agora defina este serviço: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: webhook-service spec: ports: - port: 443 targetPort: 8443 selector: component: webhook-server</code> </pre> <br>  Portanto, no Kubernetes, um terminal aparece com um nome interno que aponta para o contêiner.  A etapa final é dizer ao Kubernetes que queremos que o servidor da API chame esse serviço quando estiver pronto para fazer <i>mutações</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: name: webhook webhooks: - name: webhook-service.default.svc failurePolicy: Fail clientConfig: service: name: webhook-service namespace: default path: "/mutate" #    base64-  rootCA.crt #    `cat rootCA.crt | base64 | tr -d '\n'` #    .  caBundle: "==" rules: - operations: [ "CREATE" ] apiGroups: [""] apiVersions: ["v1"] resources: ["pods"]</code> </pre>  <i>( <a href="">hook.yaml</a> )</i> <br><br>  O nome e o caminho aqui podem ser qualquer um, mas tentei torná-los o mais significativos possíveis.  Alterar o caminho significará a necessidade de modificar o código correspondente em JavaScript.  A falha <code>failurePolicy</code> política da <code>failurePolicy</code> também é <code>failurePolicy</code> - determina se o objeto deve ser salvo se o gancho retornar um erro ou falhar.  Nesse caso, estamos dizendo ao Kubernetes para não continuar o processamento.  Finalmente, as regras: elas serão alteradas dependendo da API que você espera que ações do Kubernetes.  Nesse caso, como estamos tentando emular a inserção de um contêiner lateral, precisamos interceptar solicitações para criar um pod. <br><br>  Isso é tudo!  Tão simples ... mas e a segurança?  O RBAC é um aspecto que não é coberto no artigo.  Suponho que você esteja executando o exemplo no Minikube ou no Kubernetes, que acompanha o Docker para Windows / Mac.  No entanto, vou falar sobre outro elemento necessário.  O servidor da API Kubernetes acessa apenas pontos de extremidade com HTTPS, portanto, o aplicativo requer certificados SSL.  Você também precisará informar ao Kubernetes quem é a autoridade de certificação do certificado raiz. <br><br><h2>  TLS </h2><br>  <b>Apenas para fins de demonstração (!!!),</b> adicionei algum código ao <code>Dockerfile</code> para criar uma CA raiz e usá-lo para assinar o certificado: <br><br><pre> <code class="plaintext hljs">RUN openssl genrsa -out rootCA.key 4096 RUN openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=*.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl genrsa -out webhook.key 4096 RUN openssl req -new -key webhook.key -out webhook.csr \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=webhook-service.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl x509 -req -in webhook.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out webhook.crt -days 1024 -sha256 RUN cat rootCA.crt | base64 | tr -d '\n'</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dockerfile</a> )</i> <br><br>  Observe: o último passo é exibir uma única linha com a CA raiz codificada em base64.  É exatamente isso que é necessário para a configuração do gancho; portanto, em seus testes adicionais, copie esta linha no campo <code>caBundle</code> arquivo <code>caBundle</code> .  <code>Dockerfile</code> lança certificados diretamente no <code>WORKDIR</code> ; portanto, o JavaScript apenas os pega de lá e o usa no servidor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privateKey = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.key'</span></span>).toString(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> certificate = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.crt'</span></span>).toString(); <span class="hljs-comment"><span class="hljs-comment">//… const options = {key: privateKey, cert: certificate}; const server = https.createServer(options, app);</span></span></code> </pre> <br>  Agora, o código suporta o lançamento do HTTPS e também disse ao Kubernetes onde nos encontrar e em qual centro de confiança confiar.  Resta apenas incorporar tudo em um cluster: <br><br><pre> <code class="bash hljs">kubectl create -f deployment.yaml kubectl create -f service.yaml kubectl create -f hook.yaml</code> </pre> <br><h3>  Resumir </h3><br><ul><li>  <code>Deployment.yaml</code> inicia um contêiner que serve a API de gancho por HTTPS e retorna um patch JSON para modificar o objeto. </li><li>  <code>Service.yaml</code> fornece um terminal para o contêiner - <code>webhook-service.default.svc</code> . </li><li>  <code>Hook.yaml</code> informa ao servidor da API onde nos encontrar: <code>https://webhook-service.default.svc/mutate</code> . </li></ul><br><h2>  Vamos tentar nos negócios! </h2><br>  Tudo é implantado em um cluster - é hora de experimentar o código em ação, o que faremos adicionando um novo pod / implantação.  Se tudo funcionar corretamente, o gancho terá que adicionar uma etiqueta adicional <code>foo</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: test spec: replicas: 1 selector: matchLabels: component: test template: metadata: labels: component: test spec: containers: - name: test image: node:8 command: [ "/bin/sh", "-c", "--" ] args: [ "while true; do sleep 30; done;" ]</code> </pre> <br>  <i>( <a href="">test.yaml</a> )</i> <br><br><pre> <code class="bash hljs">kubectl create -f test.yaml</code> </pre> <br>  Ok, vimos o <code>deployment.apps test created</code> ... mas funcionou? <br><br><pre> <code class="bash hljs">kubectl describe pods <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-6f79f9f8bd-r7tbd Namespace: default Node: docker-for-desktop/192.168.65.3 Start Time: Sat, 10 Nov 2018 16:08:47 -0500 Labels: component=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> foo=bar</code> </pre> <br>  Ótimo!  Embora <code>test.yaml</code> receba um rótulo único ( <code>component</code> ), o pod resultante recebeu dois: <code>component</code> e <code>foo</code> . <br><br><h2>  Lição de casa </h2><br>  Mas espera!  Vamos usar esse código para criar um contêiner lateral?  Eu avisei que mostrarei <b>como</b> adicionar sidecar ... E agora, com o conhecimento e o código: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/dowjones/k8s-webhook</a> - fique à vontade para experimentar e descobrir como fazer seu sidecar inserido automaticamente.  É bem simples: você só precisa preparar o patch JSON correto, que adicionará um contêiner adicional na implantação de teste.  Orquestração feliz! <br><br><h2>  PS do tradutor </h2><br>  Leia também em nosso blog: <br><br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Então, o que é um pod em Kubernetes?</a>  "; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como é fornecida a alta disponibilidade no Kubernetes</a> ”; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o agendador Kubernetes realmente funciona?"</a>  "; </li><li>  "O que acontece no Kubernetes quando o kubectl run é iniciado?"  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte 2</a> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entendendo o RBAC no Kubernetes</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nossa experiência com o Kubernetes em pequenos projetos</a> ” <i>(reportagem em vídeo, que inclui uma introdução ao dispositivo técnico do Kubernetes)</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que é uma malha de serviço e por que preciso dela?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431252/">https://habr.com/ru/post/pt431252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431242/index.html">TLS e certificados da Web</a></li>
<li><a href="../pt431244/index.html">"Dois não filtrados" ou uma maneira fácil de fotografar uma perna</a></li>
<li><a href="../pt431246/index.html">Meetup @OpenStack no grupo Mail.Ru: 30 de novembro</a></li>
<li><a href="../pt431248/index.html">Quem será responsável em agile pela qualidade do desenvolvimento de projetos complexos ou pela metodologia Quality Gates</a></li>
<li><a href="../pt431250/index.html">Os adeptos da digitação estática e dinâmica nunca se entenderão. E o TypeScript não os ajudará</a></li>
<li><a href="../pt431254/index.html">Como viver bem em um site remoto</a></li>
<li><a href="../pt431256/index.html">Reino Unido e Holanda multaram a Uber em US $ 1,2 milhão por vazamento de dados pessoais</a></li>
<li><a href="../pt431258/index.html">Webinars de dezembro Kotlin 1.3</a></li>
<li><a href="../pt431260/index.html">Como funciona: o trabalho de uma equipe de analistas usando o exemplo do desenvolvimento de um serviço digital</a></li>
<li><a href="../pt431262/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 19: “Redes Anônimas”, parte 1 (palestra do criador da rede Tor)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>