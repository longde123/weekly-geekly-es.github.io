<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜô üï¥üèæ üß£ RabbitMQ - SQL Server ‚òÅÔ∏è üë©üèø‚Äçüç≥ üìò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace una o dos semanas, vi un mensaje en el foro de usuarios de RabbitMQ sobre c√≥mo configurar el env√≠o de mensajes desde SQL Server a RabbitMQ. Como ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ - SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419457/">  Hace una o dos semanas, vi un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mensaje</a> en el foro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usuarios de RabbitMQ</a> sobre c√≥mo configurar el env√≠o de mensajes desde SQL Server a RabbitMQ.  Como trabajamos estrechamente con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Derivco</a> , dej√© algunas sugerencias all√≠ y tambi√©n dije que estoy escribiendo un blog sobre c√≥mo hacer esto.  Parte de mi mensaje no era del todo cierto, al menos hasta ese momento (lo siento, hermano, estaba muy ocupado). <br><br>  Incre√≠ble, este es tu <b>servidor SQL</b> .  Usarlo es muy f√°cil de poner informaci√≥n en una base de datos.  Recuperar datos de una base de datos mediante una consulta es igual de f√°cil.  Pero obtener los datos reci√©n actualizados o pegados ya es un poco m√°s dif√≠cil.  Piensa en eventos en tiempo real;  se realiza una compra: alguien debe ser notificado sobre esto en el momento en que esto suceda.  Tal vez alguien dir√° que dichos datos no deber√≠an extraerse de la base de datos, sino de otro lugar.  Por supuesto, este es el caso, pero a menudo simplemente no tenemos otra opci√≥n. <br><a name="habracut"></a><br>  Ten√≠amos una tarea: enviar eventos desde la base de datos externa para su posterior procesamiento, y la pregunta era: ¬øc√≥mo hacer esto? <br><br><h3>  SQL Server y comunicaciones externas </h3><br>  Durante la existencia de SQL Server, ha habido varios intentos de organizar las comunicaciones fuera de la base de datos;  <b>SQL Server Notification Services</b> (NS), que apareci√≥ en SQL Server 2000, y m√°s tarde, en SQL Server 2005, apareci√≥ <b>SQL Server Service Broker</b> (SSB).  Los describ√≠ en mi libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A First Look at SQL Server 2005 for Developers</a> , junto con Bob Boshemen y Dan Sullivan.  NS apareci√≥ en SQL Server 2000, como dije, y fue redise√±ado en la versi√≥n beta de SQL Server 2005. Sin embargo, NS fue <s>completamente</s> excluido de la versi√≥n lista para la venta (RTM) de SQL Server 2005. <br><blockquote>  <b>Nota:</b> Si lees el libro, encontrar√°s una serie de caracter√≠sticas que no estaban en la versi√≥n RTM. </blockquote>  SSB sobrevivi√≥, y Microsoft present√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Service Broker External Activator</a> (EA) en su paquete de caracter√≠sticas de SQL Server 2008.  Permite a trav√©s del SSB interactuar fuera de la base de datos local.  Te√≥ricamente, suena bien, pero en la pr√°ctica es engorroso y confuso.  Hicimos algunas pruebas y r√°pidamente nos dimos cuenta de que no estaba haciendo lo que necesit√°bamos.  Adem√°s, SSB no nos dio el rendimiento que se necesitaba, por lo que tuvimos que inventar algo m√°s. <br><br><h3>  SQLCLR </h3><br>  Como resultado, nos basamos en la tecnolog√≠a SQLCLR.  SQLCLR es una plataforma .NET que est√° integrada en el n√∫cleo de SQL Server y puede usarse para ejecutar c√≥digo .NET dentro del n√∫cleo.  Como ejecutamos c√≥digo .NET, podemos hacer casi todo como en una aplicaci√≥n .NET normal. <br><blockquote>  <b>Nota:</b> Escrib√≠ "casi" arriba, porque en realidad hay algunas limitaciones.  En este contexto, estas restricciones casi no tienen efecto sobre lo que vamos a hacer. <br></blockquote>  El principio de funcionamiento de SQLCLR es el siguiente: el c√≥digo se compila en una biblioteca dll, y luego esta biblioteca se registra utilizando las herramientas de SQL Server: <br><br>  Construir ensamblaje <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASSEMBLY</span></span> [RabbitMQ.SqlServer] AUTHORIZATION rmq <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">'F:\some_path\RabbitMQSqlClr4.dll'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> PERMISSION_SET = <span class="hljs-keyword"><span class="hljs-keyword">UNSAFE</span></span>; GO</code> </pre> <br>  <b>Fragmento de c√≥digo 1:</b> Crear un ensamblaje a lo largo de una ruta absoluta <br><br>  El c√≥digo realiza las siguientes acciones: <br><br><ul><li>  <code>CREATE ASSEMBLY</code> : crea un ensamblaje con el nombre de pila (no importa cu√°l sea). </li><li>  <code>AUTHORIZATION</code> : indica el propietario del ensamblaje.  En este caso, rmq es un rol predefinido de SQL Server. </li><li>  <code>FROM</code> : determina d√≥nde se encuentra el ensamblaje original.  En la <code>FROM</code> , tambi√©n puede especificar la ruta en formato binario o UNC.  Los archivos de instalaci√≥n para este proyecto usan una representaci√≥n binaria. </li><li>  <code>WITH PERMISSION_SET</code> - Establece permisos.  <code>UNSAFE</code> es el menos estricto y se requiere en este caso. </li></ul><br><blockquote>  <b>Nota:</b> independientemente del rol o inicio de sesi√≥n utilizado en la cl√°usula <code>AUTHORIZATION</code> , la clase appdomain debe crearse con el mismo nombre que cuando se carga el ensamblado en el dominio.  Se recomienda separar los ensamblados con diferentes nombres de clases de dominio de aplicaci√≥n para que cuando un ensamblaje falle, el resto no caiga.  Sin embargo, si los ensamblajes dependen unos de otros, no se pueden dividir en diferentes clases. <br></blockquote>  Cuando se crea el ensamblaje, hacemos envoltorios de m√©todos .NET en √©l: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> rmq.pr_clr_PostRabbitMsg @EndpointID <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, @Message <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> [RabbitMQ.SqlServer].[RabbitMQSqlClr.RabbitMQSqlServer].[pr_clr_PostRabbitMsg]; GO</code> </pre><br>  <b>Fragmento de c√≥digo 2:</b> Contenedor de m√©todos .NET <br><br>  El c√≥digo realiza las siguientes acciones: <br><br><ul><li>  Crea un procedimiento almacenado T-SQL denominado <code>rmq.pr_clr_PostRabbitMsg</code> que toma dos par√°metros;  <code>@EndpointID</code> y <code>@Message</code> . </li><li>  En lugar del cuerpo del procedimiento, se utiliza una fuente externa, que consiste en: <br><ul><li>  Un ensamblado llamado <code>RabbitMQ.SqlServer</code> , es decir, el agregado que creamos anteriormente en el <b>fragmento de c√≥digo 1</b> . </li><li>  Tipo completo (espacio de nombres y clase): <code>RabbitMQSqlClr.RabbitMQSqlServer</code> </li><li>  El m√©todo del espacio de nombres y la clase anteriores es: <code>pr_clr_PostRabbitMsg</code> . </li></ul></li></ul><br>  Cuando <code>rmq.pr_clr_PostRabbitMsg</code> , se <code>pr_clr_PostRabbitMsg</code> m√©todo <code>pr_clr_PostRabbitMsg</code> . <br><blockquote>  <b>Nota:</b> al crear un procedimiento, el nombre del ensamblado no distingue entre may√∫sculas y min√∫sculas, a diferencia del nombre completo del tipo y m√©todo.  No es necesario que el nombre del procedimiento que se est√° creando coincida con el nombre del m√©todo.  Sin embargo, los tipos de datos finales para los par√°metros deben coincidir. </blockquote>  Como dije anteriormente, en Derivco necesitamos enviar datos fuera de SQL Server, por lo que usamos SQLCLR y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RabbitMQ</a> (RMQ). <br><br><h3>  Rabbitmq </h3><br>  RMQ es un agente de mensajes de c√≥digo abierto que implementa el Protocolo avanzado de colas de mensajes (AMQP) y est√° escrito en Erlang. <br><br>  Dado que RMQ es un intermediario de mensajes, se requieren bibliotecas de cliente AMQP para conectarse a √©l.  La aplicaci√≥n hace referencia a las bibliotecas del cliente y, con su ayuda, abre una conexi√≥n y env√≠a mensajes, ya que, por ejemplo, hay una llamada a trav√©s de ADO.NET a SQL Server.  Pero a diferencia de ADO.NET, donde, lo m√°s probable, la conexi√≥n se abre cada vez que accede a la base de datos, aqu√≠ la conexi√≥n permanece abierta durante todo el per√≠odo de la aplicaci√≥n. <br><br>  Por lo tanto, para poder interactuar desde la base de datos con RabbitMQ, necesitamos la aplicaci√≥n y la biblioteca cliente .NET para RabbitMQ. <br><blockquote>  <b>Nota:</b> en la siguiente parte de este art√≠culo, se encontrar√°n fragmentos de c√≥digo RabbitMQ, pero sin explicaciones detalladas de lo que hacen.  Si es nuevo en trabajar con RabbitMQ, le sugiero que consulte los diversos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tutoriales de RabbitMQ</a> para comprender el prop√≥sito del c√≥digo.  El tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hello World</a> C # es un buen comienzo.  Una de las diferencias entre los libros de texto y los ejemplos de c√≥digo es que los intercambiadores no se declaran en los ejemplos.  Se supone que est√°n predefinidos. </blockquote><h3>  RabbitMQ.SqlServer </h3><br>  <b>RabbitMQ.SqlServer</b> es un ensamblado que utiliza la biblioteca de cliente .NET para RabbitMQ y proporciona la capacidad de enviar mensajes desde la base de datos a uno o m√°s puntos finales RabbitMQ (VHosts e intercambiadores).  El c√≥digo se puede descargar / bifurcar desde mi repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RabbitMQ-SqlServer</a> en GitHub.  Contiene fuentes de ensamblaje y archivos de instalaci√≥n (es decir, no tiene que compilarlos usted mismo). <br><blockquote>  <b>Nota:</b> este es solo un ejemplo para mostrar c√≥mo SQL Server puede interactuar con RabbitMQ.  Este NO es un producto terminado o incluso parte de √©l.  Si este c√≥digo te rompe el cerebro, no me culpes, porque esto es solo un ejemplo. <br></blockquote><h3>  Funcionalidad </h3><br>  Cuando se carga el ensamblaje, o cuando se llama expl√≠citamente a su inicializaci√≥n, o cuando se llama indirectamente, en el momento en que se llama al procedimiento de envoltura, el ensamblaje carga la cadena de conexi√≥n en la base de datos local en la que se instal√≥, as√≠ como los puntos finales RabbitMQ a los que se conecta: <br><br>  Conexi√≥n <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { connFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConnectionFactory(); connFactory.Uri = connString; connFactory.AutomaticRecoveryEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; connFactory.TopologyRecoveryEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; RabbitConn = connFactory.CreateConnection(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; channels; x++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ch = RabbitConn.CreateModel(); rabbitChannels.Push(ch); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  <b>Fragmento de c√≥digo 3:</b> conectarse al punto final <br><br>  Al mismo tiempo, parte de la conexi√≥n al punto final tambi√©n crea IModels en la conexi√≥n, y se usan al enviar (agregar a la cola) mensajes: <br><br>  Env√≠o de mensajes <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> exchange, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topic</span></span></span><span class="hljs-function">)</span></span> { IModel <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channelTryCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((!rabbitChannels.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) &amp;&amp; channelTryCount &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { channelTryCount += <span class="hljs-number"><span class="hljs-number">1</span></span>; Thread.Sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (channelTryCount == <span class="hljs-number"><span class="hljs-number">100</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">$"Channel pool blocked when trying to post message to Exchange: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{exchange}</span></span></span><span class="hljs-string">."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(errMsg); } <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.BasicPublish(exchange, topic, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, msg); rabbitChannels.Push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _rabbitChannels.Push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  El m√©todo <code>Post</code> se llama desde el m√©todo <code>pr_clr_PostRabbitMsg(int endPointId, string msgToPost)</code> , que se present√≥ como un procedimiento utilizando la cl√°usula <code>CREATE PROCEDURE</code> en el fragmento de c√≥digo 2: <br><br>  M√©todo de llamada posterior <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pr_clr_PostRabbitMsg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endPointId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msgToPost</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(endPointId == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">"EndpointId cannot be 0"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isInitialised) { pr_clr_InitialiseRabbitMq(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = Encoding.UTF8.GetBytes(msgToPost); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endPointId == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> remoteEndpoints) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exch = rep.Value.Exchange; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topic = rep.Value.RoutingKey; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pub <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rabbitPublishers.Values) { pub.Post(exch, msg, topic); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { RabbitPublisher pub; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rabbitPublishers.TryGetValue(endPointId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> pub)) { pub.Post(remoteEndpoints[endPointId].Exchange, msg, remoteEndpoints[endPointId].RoutingKey); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">$"EndpointId: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{endPointId}</span></span></span><span class="hljs-string">, does not exist"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  <b>Fragmento de c√≥digo 5:</b> Representar un m√©todo como procedimiento <br><br>  Cuando se ejecuta el m√©todo, se supone que la persona que llama env√≠a el identificador del punto final al que debe transmitirse el mensaje y, de hecho, el mensaje mismo.  Si el valor -1 se pasa como el identificador del punto final, iteramos sobre todos los puntos y enviamos un mensaje a cada uno de ellos.  El mensaje viene en forma de una cadena de la cual obtenemos bytes usando <code>Encoding.UTF8.GetBytes</code> .  En un entorno de producci√≥n, la llamada <code>Encoding.UTF8.GetBytes</code> debe reemplazarse por serializaci√≥n. <br><br><h3>  Instalaci√≥n </h3><br>  Para instalar y ejecutar el ejemplo, necesita todos los archivos en la carpeta <code>src\SQL</code> .  Para instalar, siga estos pasos: <br><br><ul><li>  Ejecute el script <code>01.create_database_and_role.sql</code> .  El crear√°: <br><ul><li>  Base de datos de prueba <code>RabbitMQTest</code> donde se crear√° el ensamblado. </li><li>  rol <code>rmq</code> que se asignar√° como propietario del ensamblado </li><li>  esquema, que tambi√©n se llamar√° <code>rmq</code> .  En este diagrama, se crean varios objetos de base de datos. <br></li></ul><br></li><li>  Ejecute el archivo <code>02.create_database_objects.sql</code> .  El crear√°: <br><br><ul><li>  la tabla <code>rmq.tb_RabbitSetting</code> , que almacenar√° la cadena de conexi√≥n en la base de datos local. </li><li>  La tabla <code>rmq.tb_RabbitEndpoint</code> , en la que se almacenar√°n uno o m√°s puntos finales <code>RabbitMQ</code> . </li></ul><br></li><li>  En el archivo <code>03.create_localhost_connstring.sql</code> cambie el valor de la variable <code>@connString</code> a la cadena de conexi√≥n correcta para la base de datos <code>RabbitMQTest</code> creada en el paso 1 y ejecute el script. <br></li></ul><br>  Antes de continuar, debe tener una instancia en ejecuci√≥n del corredor RabbitMQ y VHost (de forma predeterminada, VHost se representa como /).  Como regla, tenemos varios VHost, solo por aislamiento.  Este host tambi√©n necesita un intercambiador, en el ejemplo usamos <code>amq.topic</code> .  Cuando su corredor RabbitMQ est√© listo, edite los <code>rmq.pr_UpsertRabbitEndpoint</code> procedimiento <code>rmq.pr_UpsertRabbitEndpoint</code> , que se encuentra en el archivo <code>04.upsert_rabbit_endpoint.sql</code> : <br><br>  Endpoint RabbitMQ <br><br><pre> <code class="cs hljs">EXEC rmq.pr_UpsertRabbitEndpoint @Alias = <span class="hljs-string"><span class="hljs-string">'rabbitEp1'</span></span>, @ServerName = <span class="hljs-string"><span class="hljs-string">'RabbitServer'</span></span>, @Port = <span class="hljs-number"><span class="hljs-number">5672</span></span>, @VHost = <span class="hljs-string"><span class="hljs-string">'testHost'</span></span>, @LoginName = <span class="hljs-string"><span class="hljs-string">'rabbitAdmin'</span></span>, @LoginPassword = <span class="hljs-string"><span class="hljs-string">'some_secret_password'</span></span>, @Exchange = <span class="hljs-string"><span class="hljs-string">'amq.topic'</span></span>, @RoutingKey = <span class="hljs-string"><span class="hljs-string">'#'</span></span>, @ConnectionChannels = <span class="hljs-number"><span class="hljs-number">5</span></span>, @IsEnabled = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <b>Fragmento de c√≥digo 6:</b> Crear un punto final en RabbitMQ <br><br>  En este punto, es hora de implementar ensamblados.  Existen diferencias en las opciones de implementaci√≥n para versiones de SQL Server anteriores a SQL Server 2014 (2005, 2008, 2008R2, 2012), y para 2014 y posteriores.  La diferencia radica en la versi√≥n compatible de CLR.  Antes de SQL Server 2014, la plataforma .NET se estaba ejecutando en la versi√≥n 2 de CLR, y en SQL Server 2014 y versiones posteriores, se usaba la versi√≥n 4. <br><br><h3>  SQL Server 2005 - 2012 </h3><br>  Comencemos con las versiones de SQL Server que se ejecutan en CLR 2, ya que tienen sus propias caracter√≠sticas.  Necesitamos implementar el ensamblado creado y, al mismo tiempo, implementar la biblioteca .NET del cliente <code>RabbitMQ.Client</code> ( <code>RabbitMQ.Client</code> ).  Desde nuestro ensamblaje nos referiremos a la biblioteca del cliente RabbitMQ.  Porque  Como planeamos usar CLR 2, nuestro ensamblado y <code>RabbitMQ.Client</code> deber√≠an compilarse en base a .NET 3.5.  Hay problemas <br><br>  Todas las versiones m√°s recientes de la biblioteca <code>RabbitMQ.Client</code> est√°n compiladas para el entorno CLR 4, por lo que no pueden usarse en nuestro ensamblado.  La √∫ltima versi√≥n de las bibliotecas del cliente para CLR 2 se compila en .NET 3.4.3.  Pero incluso si tratamos de implementar este ensamblado, recibimos un mensaje de error: <br><br><img src="https://habrastorage.org/webt/db/yo/uj/dbyouj4az0fzhnwpkvtdkgj6i-q.png"><br>  <i><b>Figura 1:</b> Sistema perdido Conjunto de modelo de servicio</i> <br><br>  Esta versi√≥n de <code>RabbitMQ.Client</code> refiere a un ensamblado que no forma parte del CLR de SQL Server.  Este es un ensamblado WCF, y esta es una de las limitaciones en SQLCLR que mencion√© anteriormente: este ensamblaje en particular es para tipos de tareas que no se pueden realizar en SQL Server.  Las versiones recientes de <code>RabbitMQ.Client</code> no tienen estas dependencias, por lo que se pueden usar sin ning√∫n problema, excepto por los molestos requisitos del CLR 4. ¬øQu√© debo hacer? <br><br>  Como saben, RabbitMQ es de c√≥digo abierto, pero somos desarrolladores, ¬øverdad?  ;) ¬°Entonces recompilemos!  En la versi√≥n anterior a las √∫ltimas versiones (es decir, la versi√≥n &lt;3.5.0) de <code>RabbitMQ.Client</code> elimin√© los enlaces a <code>System.ServiceModel</code> y volv√≠ a compilar.  Tuve que cambiar un par de l√≠neas de c√≥digo usando la funcionalidad <code>System.ServiceModel</code> , pero estos fueron cambios menores. <br><br>  En este ejemplo, no utilic√© la versi√≥n 3.4.3 del cliente, pero tom√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n estable 3.6.6</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">volv√≠ a</a> compilar usando .NET 3.5 (CLR 2).  Casi funcion√≥ :), excepto que las versiones posteriores de <code>RabbitMQ.Client</code> usan <code>Task</code> 'y que originalmente no forman parte de .NET 3.5. <br><br>  Afortunadamente, hay una versi√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>System.Threading.dll</code></a> para .NET 3.5 que incluye <code>Task</code> .  Lo descargu√©, configur√© los enlaces y ¬°todo sali√≥!  Aqu√≠ el truco principal es que <code>System.Threading.dll</code> debe instalarse con el ensamblado. <br><blockquote>  <b>Nota: la</b> fuente de <code>RabbitMQ.Client</code> , desde la cual compil√© una versi√≥n de .NET 3.5, est√° en mi repositorio en GitHub <a href="">RabbitMQ Client 3.6.6 .NET 3.5</a> .  El archivo binario dll junto con <code>System.Threading.dll</code> para .NET 3.5 tambi√©n se encuentra en el <code>lib\NET3.5</code> repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(RabbitMQ-SqlServer)</a> . <br></blockquote>  Para instalar los ensamblados necesarios ( <code>System.Threading</code> , <code>RabbitMQ.Client</code> y <code>RabbitMQ.SqlServer</code> ) ejecute los scripts de instalaci√≥n desde el directorio <code>src\sql</code> en el siguiente orden: <br><br><ol><li>  <code>05.51.System.Threading.sql2k5-12.sql</code> - System.Threading </li><li>  <code>05.52.RabbitMQ.Client.sql2k5-12.sql</code> - RabbitMQ.Client </li><li>  <code>05.53.RabbitMQ.SqlServer.sql2k5-12.sql</code> - RabbitMQ.SqlServer </li></ol><br><h3>  SQL Server 2014+ </h3><br>  En SQL Server 2014 y versiones posteriores, el ensamblaje se compila bajo .NET 4.XX (mi ejemplo est√° en 4.5.2), y puede hacer referencia a cualquiera de las √∫ltimas versiones de <code>RabbitMQ.Client</code> , que se puede obtener usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NuGet</a> .  En mi ejemplo, estoy usando 4.1.1.  <code>RabbitMQ.Client</code> , que tambi√©n se encuentra en el <code>lib\NET4</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio (RabbitMQ-SqlServer)</a> . <br><br>  Para instalar, ejecute los scripts desde el directorio <code>src\sql</code> en el siguiente orden: <br><br><ol><li>  <code>05.141.RabbitMQ.Client.sql2k14+.sql</code> - RabbitMQ.Client </li><li>  <code>05.142.RabbitMQ.SqlServer.sql2k14+.sql</code> - RabbitMQ.SqlServer </li></ol><br><h3>  Contenedores de m√©todos SQL </h3><br>  Para crear procedimientos que se utilizar√°n desde nuestro ensamblado (3.5 o 4), ejecute el script <code>06.create_sqlclr_procedures.sql</code> .  Crear√° procedimientos T-SQL para tres m√©todos .NET: <br><br><ul><li>  <code>rmq.pr_clr_InitialiseRabbitMq</code> llama a <code>pr_clr_InitialiseRabbitMq</code> .  Se usa para cargar e inicializar el ensamblado RabbitMQ.SqlServer. </li><li>  <code>rmq.pr_clr_ReloadRabbitEndpoints</code> llama a <code>pr_clr_ReloadRabbitEndpoints</code> .  Carga varios puntos finales RabbitMQ. </li><li>  <code>rmq.pr_clr_PostRabbitMsg</code> llama a <code>pr_clr_PostRabbitMsg</code> .  Se usa para enviar mensajes a RabbitMQ. </li></ul><br>  El script tambi√©n crea un procedimiento T-SQL simple: <code>rmq.pr_PostRabbitMsg</code> , que se aplica a <code>rmq.pr_clr_PostRabbitMsg</code> .  Este es un procedimiento de envoltura que sabe qu√© hacer con los datos, maneja excepciones, etc.  En un entorno de producci√≥n, tenemos varios procedimientos similares que procesan varios tipos de mensajes.  Lea m√°s sobre esto a continuaci√≥n. <br><br><h3>  Uso </h3><br>  De todo lo anterior, est√° claro que para enviar mensajes a RabbitMQ llamamos <code>rmq.pr_PostRabbitMsg</code> o <code>rmq.pr_clr_PostRabbitMsg</code> , pasando los par√°metros del identificador del punto final y el mensaje en s√≠ como una cadena.  Todo esto, por supuesto, es genial, pero me gustar√≠a ver c√≥mo funcionar√° en realidad. <br><br>  Lo que hacemos en entornos de producci√≥n es que en los procedimientos almacenados que procesan los datos que se deben enviar a RabbitMQ, recopilamos los datos que se enviar√°n y en el bloque de conexi√≥n llamamos a un procedimiento como <code>rmq.pr_PostRabbitMsg</code> .  El siguiente es un ejemplo muy simplificado de dicho procedimiento: <br><br>  Procedimiento de procesamiento de datos <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> dbo.pr_SomeProcessingStuff @<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> NOCOUNT <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY <span class="hljs-comment"><span class="hljs-comment">--     DECLARE @endPointId int; --    DECLARE @msg nvarchar(max) = '{' --        SET @msg = @msg + '"Id":' + CAST(@id AS varchar(10)) + ',' --  -  SET @msg = @msg + '"FName":"Hello",'; SET @msg = @msg + '"LName":"World"'; SET @msg = @msg + '}'; -- -  --     -,  -  SELECT @endPointId = 1; --    --     EXEC rmq.pr_PostRabbitMsg @Message = @msg, @EndpointID = @endPointId; END TRY BEGIN CATCH DECLARE @errMsg nvarchar(max); DECLARE @errLine int; SELECT @errMsg = ERROR_MESSAGE(), @errLine = ERROR_LINE(); RAISERROR('Error: %s at line: %d', 16, -1, @errMsg, @errLine); END CATCH END</span></span></code> </pre> <br>  En el <b>fragmento de c√≥digo 7,</b> vemos c√≥mo se capturan y procesan los datos necesarios en el procedimiento y se env√≠an despu√©s del procesamiento.  Para utilizar este procedimiento, ejecute el script <code>07.create_processing_procedure.sql</code> desde el directorio <code>src\SQL</code> . <br><br><h3>  Vamos a correrlo todo </h3><br>  En este punto, debe estar preparado para enviar algunos mensajes.  Antes de realizar la prueba, aseg√∫rese de tener colas en RabbitMQ conectadas al intercambiador de punto final en <code>rmq.tb_RabbitEndpoint</code> . <br><br>  Entonces, para comenzar, debe hacer lo siguiente: <br>  Abra el archivo <code>99.test_send_message.sql</code> . <br>  Correr <br><br><pre> <code class="sql hljs">EXEC rmq.pr_clr_InitialiseRabbitMq;</code> </pre> <br>  para inicializar el ensamblaje y cargar los puntos finales RabbitMQ.  Este no es un paso obligatorio, pero se recomienda que precargue el ensamblaje despu√©s de crearlo o modificarlo. <br><br>  Correr <br><br><pre> <code class="sql hljs">EXEC dbo.pr_SomeProcessingStuff @id = 101</code> </pre> <br>  (puede usar cualquier otro identificador que desee). <br><br>  Si todo funcion√≥ sin errores, ¬°deber√≠a aparecer un mensaje en la cola RabbitMQ!  Entonces usaste SQLCLR para enviar un mensaje a RabbitMQ. <br><br>  Felicidades </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419457/">https://habr.com/ru/post/es419457/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419441/index.html">SpaceX reutiliza el cohete Falcon 9 Block 5 hoy</a></li>
<li><a href="../es419443/index.html">La NASA volver√° a volar a la luna, haciendo que todos los elementos del avi√≥n</a></li>
<li><a href="../es419449/index.html">API de contexto de Redux vs. React</a></li>
<li><a href="../es419451/index.html">Crea un paquete para Symfony 4 paso a paso</a></li>
<li><a href="../es419453/index.html">M√©todos num√©ricos para resolver sistemas de ecuaciones no lineales.</a></li>
<li><a href="../es419459/index.html">Bater√≠as de plomo-√°cido: alfabeto de carga de pulso</a></li>
<li><a href="../es419461/index.html">Ventilaci√≥n del ba√±o</a></li>
<li><a href="../es419467/index.html">Desde una bombilla hasta una aspiradora y un dron: c√≥mo le ense√±amos a Alice a administrar cientos de dispositivos</a></li>
<li><a href="../es419469/index.html">UE4 | El ciclo del d√≠a y la noche | Modificaci√≥n de SkySphere</a></li>
<li><a href="../es419471/index.html">Opci√≥n de migraci√≥n de jQuery a javascript puro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>