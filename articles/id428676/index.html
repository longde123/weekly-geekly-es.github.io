<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ ⤴️ 👨‍👨‍👧 Mematahkan fondasi dasar C #: mengalokasikan memori untuk tipe referensi pada stack 🧙🏽 🙇🏽 👩🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, dasar-dasar perangkat tipe internal akan diberikan, serta contoh di mana memori untuk tipe referensi akan dialokasikan sepenuhnya pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mematahkan fondasi dasar C #: mengalokasikan memori untuk tipe referensi pada stack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428676/">  Pada artikel ini, dasar-dasar perangkat tipe internal akan diberikan, serta contoh di mana memori untuk tipe referensi akan dialokasikan sepenuhnya pada stack (ini karena saya adalah seorang programmer full-stack). <br><br><img src="https://habrastorage.org/webt/xn/xh/rl/xnxhrlrmdifxe8o2pwopy-y-xhw.jpeg"><br><br><h3>  Penafian </h3><br>  Artikel ini tidak mengandung bahan yang harus digunakan dalam proyek nyata.  Ini hanyalah perpanjangan dari batas-batas di mana bahasa pemrograman dirasakan. <br><br>  Sebelum memulai cerita, saya sangat menyarankan Anda membaca posting pertama tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StructLayout</a> , karena  ada contoh yang dianalisis yang akan digunakan dalam artikel ini (Namun, seperti biasa). <br><a name="habracut"></a><br><h3>  Latar belakang </h3><br>  Mulai menulis kode untuk artikel ini, saya ingin melakukan sesuatu yang menarik menggunakan bahasa assembly.  Saya ingin entah bagaimana mematahkan model eksekusi standar dan mendapatkan hasil yang benar-benar tidak biasa.  Dan mengingat frekuensi yang dikatakan orang bahwa tipe referensi berbeda dari yang signifikan karena yang pertama terletak di heap dan yang kedua di stack, saya memutuskan untuk menggunakan assembler untuk menunjukkan bahwa tipe referensi dapat hidup di stack.  Namun, saya mulai menghadapi semua jenis masalah, misalnya, mengembalikan alamat yang diinginkan dan menyatakannya sebagai tautan terkelola (saya masih mengerjakannya).  Jadi saya mulai menipu dan melakukan apa yang tidak berfungsi di assembler, di C #.  Dan pada akhirnya, assembler tidak tetap sama sekali. <br>  Juga, rekomendasi untuk membaca - jika Anda terbiasa dengan perangkat jenis referensi, saya sarankan melewatkan teori tentang mereka (hanya dasar-dasar yang akan diberikan, tidak ada yang menarik). <br><br><h3>  Sedikit tentang struktur internal tipe </h3><br>  Saya ingin mengingatkan Anda bahwa pemisahan memori pada tumpukan dan tumpukan terjadi pada tingkat .NET, dan pembagian ini murni logis, secara fisik tidak ada perbedaan antara area memori di bawah tumpukan dan di bawah tumpukan.  Perbedaan produktivitas sudah disediakan secara khusus dengan bekerja dengan bidang-bidang ini. <br><br>  Lalu bagaimana cara mengalokasikan memori pada stack?  Untuk mulai dengan, mari kita lihat bagaimana tipe referensi misterius ini terstruktur dan apa yang ada di dalamnya, yang tidak signifikan. <br><br>  Jadi, pertimbangkan contoh paling sederhana dengan kelas Karyawan. <br><br><div class="spoiler">  <b class="spoiler_title">Kode Karyawan</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Employee</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Work</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(“Zzzz...”); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeVacation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> days</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(“Zzzz...”); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCompanyPolicy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CompanyPolicy policy</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Zzzz..."</span></span>); } }</code> </pre> <br></div></div><br>  Dan lihat bagaimana disajikan dalam memori. <br>  UPD: Kelas ini dipertimbangkan pada contoh sistem 32-bit. <br><br><img src="https://habrastorage.org/webt/xy/b-/dv/xyb-dvprkg9b1dmdqgjlabkss7c.jpeg"><br><br>  Jadi, selain memori untuk bidang, kami memiliki dua bidang tersembunyi lagi - indeks blok sinkronisasi (kata judul objek dalam gambar) dan alamat tabel metode. <br><br>  Bidang pertama, ini adalah indeks dari blok sinkronisasi, kami tidak terlalu tertarik.  Saat menempatkan tipenya, saya memutuskan untuk menghilangkannya.  Saya melakukan ini karena dua alasan: <br><br><ol><li>  Saya sangat malas (saya tidak mengatakan bahwa alasannya masuk akal) </li><li>  Bidang ini opsional untuk fungsi dasar objek </li></ol><br>  Tetapi karena kita sudah berbicara, saya pikir benar untuk mengatakan beberapa kata tentang bidang ini.  Ini digunakan untuk berbagai tujuan (kode hash, sinkronisasi).  Sebaliknya, bidang itu sendiri hanyalah indeks dari salah satu blok sinkronisasi yang terkait dengan objek ini.  Blok itu sendiri terletak di tabel blok sinkronisasi (a la global array).  Membuat blok semacam itu adalah operasi yang agak besar, jadi itu tidak dibuat jika tidak diperlukan.  Selain itu, ketika menggunakan kunci tipis, pengenal utas yang menerima kunci (bukan indeks) akan ditulis di sana. <br><br>  Bidang kedua jauh lebih penting bagi kami.  Berkat tabel metode jenis, alat yang ampuh seperti polimorfisme dimungkinkan (yang, kebetulan, tidak dimiliki oleh struktur, tumpukan raja).  Asumsikan bahwa kelas Karyawan juga mengimplementasikan tiga antarmuka: IComparable, IDisposable, dan ICloneable. <br><br>  Maka tabel metode akan terlihat seperti ini <br><br><img src="https://habrastorage.org/webt/ed/wn/bd/edwnbdjat20da-ij868sfkgwapg.jpeg"><br><br>  Gambarnya sangat keren, di sana, pada prinsipnya, semuanya dicat dan dimengerti.  Jika pendek di jari, maka metode virtual dipanggil tidak langsung di alamat, tetapi dengan offset di tabel metode.  Dalam hierarki, metode virtual yang sama akan ditempatkan pada offset yang sama dalam tabel metode.  Yaitu, kita memanggil metode pada kelas dasar pada offset, tidak mengetahui tipe tabel metode mana yang akan digunakan, tetapi mengetahui bahwa pada offset ini akan ada metode yang paling relevan untuk tipe runtime. <br><br>  Perlu juga diingat bahwa referensi ke objek menunjuk ke tabel metode. <br><br><h3>  Contoh yang sudah lama ditunggu-tunggu </h3><br>  Mari kita mulai dengan kelas yang akan membantu kita dalam tujuan kita.  Menggunakan StructLayout (saya benar-benar mencoba tanpa itu, tetapi tidak berhasil) saya menulis pemetaan pointer paling sederhana untuk jenis yang dikelola dan sebaliknya.  Sangat mudah untuk mendapatkan pointer dari tautan terkelola, tetapi transformasi terbalik menyebabkan saya kesulitan, dan tanpa berpikir dua kali, saya menerapkan atribut favorit saya.  Untuk menjaga kode dalam satu kunci, saya melakukannya dalam 2 arah dalam satu cara. <br><br><div class="spoiler">  <b class="spoiler_title">Kode di sini</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">//     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCasterFacade { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe T GetManagedReferenceByPointer&lt;T&gt;(<span class="hljs-type"><span class="hljs-type">int</span></span>* pointer) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe <span class="hljs-type"><span class="hljs-type">int</span></span>* GetPointerByManagedReference&lt;T&gt;(T managedReference) =&gt; (<span class="hljs-type"><span class="hljs-type">int</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>; } //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCasterUnderground { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual T GetManagedReferenceByPointer&lt;T&gt;(T reference) =&gt; reference; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe <span class="hljs-type"><span class="hljs-type">int</span></span>* GetPointerByManagedReference&lt;T&gt;(<span class="hljs-type"><span class="hljs-type">int</span></span>* pointer) =&gt; pointer; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCaster { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PointerCaster() { pointerCaster= <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PointerCasterUnderground(); } [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] private PointerCasterUnderground pointerCaster; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PointerCasterFacade Caster; }</code> </pre><br></div></div><br>  Pertama, tulis metode yang membawa pointer ke beberapa memori (tidak harus di stack, by the way) dan mengkonfigurasi tipe. <br><br>  Untuk memudahkan menemukan alamat tabel metode, saya membuat tipe di heap.  Saya yakin bahwa tabel metode dapat ditemukan dengan cara lain, tetapi saya tidak menetapkan diri saya untuk mengoptimalkan kode ini, itu lebih menarik bagi saya untuk membuatnya dimengerti.  Selanjutnya, menggunakan konverter yang dijelaskan sebelumnya, kita mendapatkan pointer ke tipe yang dibuat. <br><br>  Pointer ini menunjuk tepat ke tabel metode.  Oleh karena itu, cukup dengan hanya mendapatkan konten dari memori yang ditunjuknya.  Ini akan menjadi alamat tabel metode. <br>  Dan karena pointer yang diberikan kepada kita adalah semacam referensi ke objek, kita harus menuliskan alamat tabel metode tepat di mana ia menunjuk. <br><br>  Itu saja, sebenarnya.  Tanpa diduga, kan?  Sekarang tipe kita sudah siap.  Pinocchio, yang mengalokasikan kami memori, akan mengurus inisialisasi bidang. <br><br>  Tetap hanya menggunakan grandcaster untuk mengubah pointer menjadi tautan terkelola. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StackInitializer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> T InitializeOnStack&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* pointer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>() { T r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> caster = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PointerCaster().Caster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = caster.GetPointerByManagedReference(r); pointer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; T reference = caster.GetManagedReferenceByPointer&lt;T&gt;(pointer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre><br>  Sekarang kita memiliki tautan pada tumpukan yang menunjuk ke tumpukan yang sama, di mana oleh semua hukum jenis referensi (well, hampir) terletak sebuah objek yang dibangun dari tanah dan tongkat hitam.  Polimorfisme tersedia. <br><br>  Harus dipahami bahwa jika Anda melewati tautan ini di luar metode, maka setelah kembali dari itu, kami akan mendapatkan sesuatu yang tidak jelas.  Tidak ada pembicaraan tentang panggilan ke metode virtual; mari kita terbang dengan pengecualian.  Metode reguler dipanggil langsung, dalam kode hanya akan ada alamat untuk metode nyata, sehingga mereka akan bekerja.  Dan di tempat ladang akan ... tetapi tidak ada yang tahu apa yang akan ada di sana. <br><br>  Karena tidak mungkin menggunakan metode terpisah untuk inisialisasi pada stack (karena frame stack akan dihapus setelah kembali dari metode), memori harus dialokasikan oleh metode yang ingin menggunakan jenis pada stack.  Sebenarnya, tidak ada satu cara untuk melakukan ini.  Tapi yang paling cocok untuk kita adalah stackalloc.  Hanya kata kunci yang sempurna untuk keperluan kita.  Sayangnya, dialah yang memperkenalkan ketidakteraturan ke dalam kode.  Sebelum itu, ada ide untuk menggunakan Span untuk tujuan ini dan untuk melakukannya tanpa kode yang tidak aman.  Tidak ada yang salah dengan kode yang tidak aman, tetapi seperti di tempat lain, itu bukan peluru perak dan memiliki area aplikasi sendiri. <br><br>  Selanjutnya, setelah menerima pointer ke memori pada stack saat ini, kami meneruskan pointer ini ke metode yang membentuk tipe di bagian.  Itu semua yang mendengarkan - dilakukan dengan baik. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* pointer = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = StackInitializer.InitializeOnStack&lt;StackReferenceType&gt;(pointer); a.StubMethod(); Console.WriteLine(a.Field); Console.WriteLine(a); Console.Read(); } }</code> </pre><br>  Anda seharusnya tidak menggunakan ini dalam proyek nyata, metode yang mengalokasikan memori pada tumpukan menggunakan T () baru, yang pada gilirannya menggunakan refleksi untuk membuat tipe pada heap!  Jadi metode ini akan lebih lambat dari penciptaan yang biasa dari jenis sekali, yah, 40-50. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat melihat keseluruhan proyek. <br><br>  Sumber: dalam penyimpangan teoretis, contoh digunakan dari buku Sasha Goldstein - Pro .NET Performace </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428676/">https://habr.com/ru/post/id428676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428664/index.html">Boot kernel Linux. Bagian 1</a></li>
<li><a href="../id428666/index.html">Bagaimana saya membuat animasi yang mengubah suasana hati menggunakan topeng CSS</a></li>
<li><a href="../id428668/index.html">Blizzard mengumumkan rilis rilis ulang WarCraft III pada tahun 2019. Buka pre-order</a></li>
<li><a href="../id428672/index.html">Gambaran Umum QuietOn Active Squelch</a></li>
<li><a href="../id428674/index.html">Membangun pencarian perutean / semantik klien di Profi.ru</a></li>
<li><a href="../id428680/index.html">Membuat dan mengintegrasikan VK bot ke grup melalui VkBotLongPoll [Python]</a></li>
<li><a href="../id428682/index.html">Penghancuran Diri Beta Fallout 76</a></li>
<li><a href="../id428688/index.html">Menyiapkan lingkungan kerja di Docker untuk aplikasi kerangka-yii</a></li>
<li><a href="../id428690/index.html">Bagaimana cara mengajar pacar Anda bagaimana memprogram jika Anda bukan seorang guru, tetapi dia percaya pada Anda</a></li>
<li><a href="../id428694/index.html">Kisah permainan tunggal atau strategi 4x yang dimulai 20 tahun lalu dan masih hidup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>