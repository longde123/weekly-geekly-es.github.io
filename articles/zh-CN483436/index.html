<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍✈️ 👸🏻 🙍🏾 播放“ osu！”，但请注意错误 🧝🏻 📪 👩‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨，大家都很喜欢异国和普通bug的收藏家！ 今天，我们的PVS-Studio测试台上有一个罕见的标本-用C＃编写的名为“ osu！”的游戏。 像往常一样，我们将寻找错误，对其进行分析和播放。 

 游戏 
 大须！ 是一款开源节奏游戏。 根据该游戏的网站 ，它非常受欢迎，拥有超过1500万玩家帐户。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>播放“ osu！”，但请注意错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/483436/"><p><img src="https://habrastorage.org/getpro/habr/post_images/3ac/9da/a12/3ac9daa12b519fc14e45f7f65abdd204.png" alt="图片1" align="left"></p><br> 嗨，大家都很喜欢异国和普通bug的收藏家！ 今天，我们的PVS-Studio测试台上有一个罕见的标本-用C＃编写的名为“ osu！”的游戏。 像往常一样，我们将寻找错误，对其进行分析和播放。 <br><a name="habracut"></a><br><h2> 游戏 </h2><br> 大须！ 是一款开源节奏游戏。 根据该游戏的<a href="https://osu.ppy.sh/home">网站</a> ，它非常受欢迎，拥有超过1500万玩家帐户。 该项目具有免费的游戏玩法，色彩缤纷的设计，地图定制，先进的在线玩家排名系统，多人游戏模式以及丰富的音乐作品。 没有必要进一步阐述游戏了。 您可以在Internet上阅读有关它的所有信息。  <a href="https://en.wikipedia.org/wiki/Osu!">从此页面</a>开始。 <br><br> 我对项目的源代码更感兴趣，该源代码可在<a href="https://github.com/ppy/osu">GitHub</a>上<a href="https://github.com/ppy/osu">找到</a> 。 立即引起您注意的一件事是，大量的存储库提交（超过2万4千次），这表明正在持续进行紧张的开发（该游戏于2007年首次发布，但工作必须更早开始）。 但是，该项目并不大：只有1813个.cs文件，总共有13.5万个非空LOC。 该数字还包括测试，运行检查时通常不会考虑这些测试。 测试组成了306个.cs文件，具有2.5万个LOC。 该项目确实很小：例如，PVS-Studio的C＃内核大约有30万个LOC。 <br><br> 除去测试文件，我检查了1105个LOC长的1507个文件。 检查确实发现了一些有趣的错误，我愿意向您展示。 <br><br><h2> 虫子 </h2><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a>在'||'的左侧和右侧有相同的子表达式'result == HitResult.Perfect' 操作员。  DrawableHoldNote.cs 266 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckForResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... ApplyResult(r =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holdNote.hasBroken &amp;&amp; (result == HitResult.Perfect || result == HitResult.Perfect)) result = HitResult.Good; .... }); }</code> </pre> <br> 这是面向复制粘贴编程的一个很好的例子，这是我的同事Val​​eriy Komarov最近在他的文章“ <a href="https://www.viva64.com/en/b/0699/">2019年在Java项目中发现的十大错误</a> ”中使用的一个幽默术语。 <br><br> 无论如何，连续执行两个相同的检查。 其中之一可能是要检查<i>HitResult</i>枚举的其他常量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HitResult { None, Miss, Meh, Ok, Good, Great, Perfect, }</code> </pre> <br> 应该检查哪个常数？ 也许第二张支票根本不存在？ 这些是只有作者才能回答的问题。 无论如何，这是一个错误，会扭曲程序的执行逻辑。 <br><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a>在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'family！= GetFamilyString（TournamentTypeface.Aquatico）'。  TournamentFont.cs 64 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeightString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> family, FontWeight weight</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight == FontWeight.Regular &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico) &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico)) weightString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; .... }</code> </pre> <br> 再次复制粘贴。 我重构了代码，因此现在很容易注意到该错误，但最初它是用一行编写的。 就像在前面的示例中一样，我无法确定应该如何精确地解决此问题。  <i>TournamentTypeface</i>枚举仅包含一个常数： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TournamentTypeface { Aquatico }</code> </pre> <br> 也许错误是关于两次检查<i>家庭</i>变量的，但我可能是错的。 <br><br>  <a href="https://www.viva64.com/en/w/v3009/">V3009</a> [CWE-393]奇怪的是，此方法始终返回一个相同的'false'值。  KeyCounterAction.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forwards</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EqualityComparer&lt;T&gt;.Default.Equals(action, Action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; IsLit = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forwards) Increment(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 每次此方法返回<i>false</i> 。 在这种情况下，我通常会检查函数调用，因为您可能经常发现调用者未使用返回值，这意味着没有问题（除了不良样式）。 在这种情况下，呼叫如下所示： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action</span></span></span><span class="hljs-function">)</span></span> =&gt; Target.Children .OfType&lt;KeyCounterAction&lt;T&gt;&gt;() .Any(c =&gt; c.OnPressed(action, Clock.Rate &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br> 如您所见，调用者确实使用了<i>OnPressed</i>方法返回的值。 由于该值始终为<i>false</i> ，因此调用者本身也总是返回<i>false</i> 。 此代码很可能包含错误，应进行修订。 <br><br> 另一个类似的错误： <br><br><ul><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的'false'值。  KeyCounterAction.cs 30 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476]可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ val.NewValue”对象TournamentTeam.cs的成员41 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TournamentTeam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Acronym.ValueChanged += val =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) FlagName.Value = val.NewValue.Length &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= ? val.NewValue?.Substring(0, 2).ToUpper() : string.Empty; }; .... }</span></span></code> </pre> <br> 在<i>？：</i>运算符的情况下，以危险的方式处理<i>val.NewValue</i>变量。 使分析器如此认为的事实是，在<i>随后的then</i>分支中，使用条件访问运算符<i>val.NewValue？.Substring（....）</i>以安全的方式处理了相同的变量。 <br><br> 另一个类似的错误： <br><br><ul><li>  V3042 [CWE-476]可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ val.NewValue”对象TournamentTeam.cs的成员48 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476]可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ api”对象SetupScreen.cs的成员77 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionableInfo { Label = <span class="hljs-string"><span class="hljs-string">"Current User"</span></span>, ButtonText = <span class="hljs-string"><span class="hljs-string">"Change Login"</span></span>, Action = () =&gt; { api.Logout(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }, Value = api?.LocalUser.Value.Username, .... }, .... } private class ActionableInfo : LabelledDrawable&lt;Drawable&gt; { .... public Action Action; .... }</span></span></code> </pre> <br> 这个比较不明确，但是我相信这也是一个错误。 程序员创建一个<i>ActionableInfo</i>类型的对象。 使用lambda函数初始化<i>Action</i>字段，该函数以危险的方式处理可能为空的引用<i>api</i> 。 分析器认为此模式是错误的，因为在初始化<i>Value</i>参数时，以后会以安全的方式处理<i>api</i>变量。 我之所以称这种情况为模棱两可，是因为lambda函数中的代码暗含了执行延迟，此时开发人员可能会以某种方式保证<i>api</i>引用为非null。 但是我不确定，因为lambda函数的主体似乎未使用任何安全的引用处理，例如先前的检查。 <br><br>  <a href="https://www.viva64.com/en/w/v3066/">V3066</a> [CWE-683]传递给“ Atan2”方法的参数的可能错误顺序：“ diff.X”和“ diff.Y”。  SliderBall.cs 182 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> completionProgress</span></span></span><span class="hljs-function">)</span></span> { .... Rotation = <span class="hljs-number"><span class="hljs-number">-90</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(-Math.Atan2(diff.X, diff.Y) * <span class="hljs-number"><span class="hljs-number">180</span></span> / Math.PI); .... }</code> </pre> <br> 分析器怀疑<i>Atan2</i>方法的参数以错误的顺序传递。 这是方法的声明： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Parameters: // y: // The y coordinate of a point. // // x: // The x coordinate of a point. public static double Atan2(double y, double x);</span></span></code> </pre> <br> 值以相反的顺序传递。 我不确定这是否是一个错误，因为<i>UpdateProgress</i>方法包含很多非平凡的计算； 我只是将其提及为可能的错误。 <br><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> [CWE-476]可能的空解除引用。 考虑检查“ Beatmap”。  WorkingBeatmap.cs 57 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Track </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVirtualTrack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastObject = Beatmap.HitObjects.LastOrDefault(); .... }</code> </pre> <br> 分析器指出<i>Beatmap</i>可能会取消引用： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBeatmap Beatmap { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LoadBeatmapAsync().Result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TaskCanceledException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> 好吧，分析仪是正确的。 <br><br> 要了解有关PVS-Studio如何检测到此类错误的更多信息，以及有关C＃8.0中添加的与处理可能为空的引用有关的新功能的更多信息，请参阅文章“ <a href="https://www.viva64.com/en/b/0631/">C＃8.0中的可空引用类型和静态分析</a> ”。 <br><br>  <a href="https://www.viva64.com/en/w/v3083/">V3083</a> [CWE-367]事件'ObjectConverted'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  BeatmapConverter.cs 82 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjectConverted != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { converted = converted.ToList(); ObjectConverted.Invoke(obj, converted); } .... }</code> </pre> <br> 这是次要且相当常见的错误。 订户可能会取消订阅在空检查和事件调用之间的事件，从而导致崩溃。 这是修复该错误的一种方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... converted = converted.ToList(); ObjectConverted?.Invoke(obj, converted); .... }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3095/">V3095</a> [CWE-476]在验证是否为null之前，已使用“列”对象。 检查线：141，142。SquareGraph.cs 141 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redrawProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ColumnCount; i++) columns[i].State = i &lt;= progress ? ColumnState.Lit : ColumnState.Dimmed; columns?.ForceRedraw(); }</code> </pre> <br>  <i>列</i>集合上的迭代以危险的方式进行。 开发人员假定<i>列</i>引用可以为空，这通过使用条件访问运算符来进一步访问代码中的集合来指示。 <br><br>  <a href="https://www.viva64.com/en/w/v3119/">V3119</a>调用重写的事件'OnNewResult'可能导致不可预测的行为。 考虑显式实现事件访问器或使用“ sealed”关键字。  DrawableRuleset.cs 256 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHitObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TObject hitObject</span></span></span><span class="hljs-function">)</span></span> { .... drawableObject.OnNewResult += (_, r) =&gt; OnNewResult?.Invoke(r); .... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;JudgementResult&gt; OnNewResult;</code> </pre> <br> 分析仪说使用覆盖事件或虚拟事件很危险。 请参阅诊断<a href="https://www.viva64.com/en/w/v3119/">说明</a>以获取解释。 我还写了一篇有关该主题的文章：“ <a href="https://www.viva64.com/en/b/0453/">C＃中的虚拟事件：出了点问题</a> ”。 <br><br> 这是另一个类似的不安全构造： <br><br><ul><li>  V3119调用重写的事件可能导致不可预测的行为。 考虑显式实现事件访问器或使用“ sealed”关键字。  DrawableRuleset.cs 257 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783]也许是“ ??” 操作员的工作方式与预期不同。 它的优先级低于其左侧的其他运营商的优先级。  OsuScreenStack.cs 45 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * ((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; }</code> </pre> <br> 为了更好地理解，下面是一个综合示例，演示了此代码的原始逻辑： <br><br><pre> <code class="cs hljs">x = (c * a) ?? b;</code> </pre> <br> 该错误源于以下事实：“ *”运算符的优先级高于“ ??”的优先级 操作员。 固定代码如下所示（添加了括号）： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * (((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre> <br> 另一个类似的错误： <br><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783]也许是“ ??” 操作员的工作方式与预期不同。 它的优先级低于其左侧的其他运营商的优先级。  FramedReplayInputHandler.cs 103 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime - NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br> 与前面的情况一样，程序员对运算符的优先级有错误的假设。 传递给<i>Math.Abs</i>方法的原始表达式的评估如下： <br><br><pre> <code class="cs hljs">(a – b) ?? <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 固定方法如下： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime – (NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3142/">V3142</a> [CWE-561]未检测到代码。 可能存在错误。  DrawableHoldNote.cs 214 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnPressed(action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Result.Type == HitResult.Miss) <span class="hljs-comment"><span class="hljs-comment">// &lt;= holdNote.hasBroken = true; .... }</span></span></code> </pre> <br> 分析器认为，从第二个<i>if</i>语句开始， <i>OnPressed</i>处理程序的代码不可访问。 这是因为第一个条件始终为true，即<i>base.OnPressed</i>方法将始终返回<i>false</i> 。 让我们看一下<i>base.OnPressed</i>方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action != Action.Value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdateResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br> 现在在<i>UpdateResult</i>方法中： <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userTriggered</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.Elapsed &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Judged) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Judged; }</code> </pre> <br> 请注意，此处的<i>Judged</i>属性的实现无关紧要，因为<i>UpdateResult</i>方法的逻辑意味着最后的<i>return</i>语句等效于以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br> 这意味着<i>UpdateResult</i>方法将一直返回<i>false</i> ，从而导致堆栈中较早的代码无法到达。 <br><br>  <a href="https://www.viva64.com/en/w/v3146/">V3146</a> [CWE-476]可能对'规则集'进行空引用。  “ FirstOrDefault”可以返回默认的空值。  APILegacyScoreInfo.cs 24 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ScoreInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScoreInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RulesetStore rulesets</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ruleset = rulesets.GetRuleset(OnlineRulesetID); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mods = Mods != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? ruleset.CreateInstance() <span class="hljs-comment"><span class="hljs-comment">// &lt;= .GetAllMods().Where(....) .ToArray() : Array.Empty&lt;Mod&gt;(); .... }</span></span></code> </pre> <br> 分析器认为<i>ruleset.CreateInstance（）</i>调用不安全。 在此调用之前，由于调用<i>GetRuleset</i>方法而为<i>规则集</i>变量分配了一个值： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RulesetInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRuleset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; AvailableRulesets.FirstOrDefault(....);</code> </pre> <br> 如您所见，警告是有效的，因为调用序列包括<i>FirstOrDefault</i>方法，该方法可以返回<i>null</i> 。 <br><br><h2> 结论 </h2><br>  “ osu！”代码中没有很多错误，这很好。 但是我仍然建议作者检查分析仪报告的问题。 我希望这将有助于保持高质量，并且游戏将继续为玩家带来欢乐。 <br><br> 提醒一下，如果您喜欢修改源代码，PVS-Studio是一个不错的选择。 该分析仪可在官方网站上<a href="https://www.viva64.com/en/pvs-studio-download/">下载</a> 。 我还要记住的另一件事是，像这样的一次性检查与实际开发过程中静态分析的正常使用无关。 只有在构建服务器和开发人员的计算机上定期使用此方法时才最有效（这称为增量分析）。 您的最终目标是在编码阶段捕获错误，以防止错误进入版本控制系统。 <br><br> 祝你好运，并保持创造力！ <br><br><h2> 参考文献 </h2><br> 这是我们在2020年发表的第一篇文章。在撰写本文时，这是过去一年中对C＃项目进行检查的链接： <br><br><ul><li>  <a href="https://www.viva64.com/en/b/0605/">在.NET的Amazon Web Services SDK源代码中搜索错误</a> </li><li>  <a href="https://www.viva64.com/en/b/0622/">检查Roslyn源代码</a> </li><li>  <a href="https://www.viva64.com/en/b/0631/">C＃8.0中的可空引用类型和静态分析</a> </li><li>  <a href="https://www.viva64.com/en/b/0653/">WinForms：错误，福尔摩斯</a> </li><li>  <a href="https://www.viva64.com/en/b/0654/">有关PVS-Studio如何在... PVS-Studio中使用的库中发现错误的故事</a> </li><li>  <a href="https://www.viva64.com/en/b/0656/">通过PVS-Studio静态分析器检查.NET Core库源代码</a> </li><li>  <a href="https://www.viva64.com/en/b/0664/">罗斯林分析仪检查</a> </li><li>  <a href="https://www.viva64.com/en/b/0677/">检查Telerik UI以使用UWP作为PVS-Studio的入门方法</a> </li><li>  <a href="https://www.viva64.com/en/b/0678/">Azure PowerShell：大部分无害</a> </li><li>  <a href="https://www.viva64.com/en/b/0681/">扫描Orchard CMS的代码以查找错误</a> </li><li>  <a href="https://www.viva64.com/en/b/0683/">使用PVS-Studio检查OpenCv的OpenCvSharp包装</a> </li><li>  <a href="https://www.viva64.com/en/b/0692/">.NET的Azure SDK：关于困难错误搜索的故事</a> </li><li>  <a href="https://www.viva64.com/en/b/0694/">SARIF SDK及其错误</a> </li><li>  <a href="https://www.viva64.com/en/b/0698/">2019年C＃项目中发现的十大bug</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483436/">https://habr.com/ru/post/zh-CN483436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483416/index.html">尝试使用Powershell自动化流程</a></li>
<li><a href="../zh-CN483418/index.html">票务系统：您如何获得三笔免费的OTRS付款？</a></li>
<li><a href="../zh-CN483424/index.html">DBA：在PostgreSQL数据库之间传输SEQUENCE值</a></li>
<li><a href="../zh-CN483426/index.html">星期五标签调查</a></li>
<li><a href="../zh-CN483428/index.html">电子签名法修正案生效后，电子文档管理将如何？</a></li>
<li><a href="../zh-CN483438/index.html">播放“ osu！”，不要忘记错误</a></li>
<li><a href="../zh-CN483440/index.html">最新的D编译器</a></li>
<li><a href="../zh-CN483444/index.html">DORA报告2019：如何提高DevOps性能</a></li>
<li><a href="../zh-CN483446/index.html">科学家发现了一种降低饮用水中铁含量的新方法</a></li>
<li><a href="../zh-CN483448/index.html">迪士尼-人类历史上最伟大的双向</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>