<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚡️ 👨‍🚀 🕖 «Sans verrou, ou pas sans verrou, telle est la question» ou «Un sommeil sain est pire qu'un radis amer» 👧 🍘 🍊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les commentaires sur l'article " Comment dormir correctement et incorrectement " m'ont inspiré pour écrire cet article. 


 Cet article se concentrera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>«Sans verrou, ou pas sans verrou, telle est la question» ou «Un sommeil sain est pire qu'un radis amer»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428087/"><p>  Les commentaires sur l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment dormir correctement et incorrectement</a> " m'ont inspiré pour écrire cet article. </p><br><p>  Cet article se concentrera sur le développement d'applications multi-threads, l'applicabilité du verrouillage sans verrou à certains cas survenus lors des travaux sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LAppS</a> , sur la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nanosleep</a> et la violence sur le planificateur de tâches. </p><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">NB</span></span>:      <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>++  <span class="hljs-selector-tag"><span class="hljs-selector-tag">Linux</span></span>,       <span class="hljs-selector-tag"><span class="hljs-selector-tag">POSIX</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1-2008</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> (    ).</code> </pre> <br><p>  En général, tout est assez désordonné, j'espère que le fil conducteur de la présentation sera clair.  Si vous êtes intéressé, je demande un chat. </p><a name="habracut"></a><br><p>  Un logiciel orienté événement attend toujours quelque chose.  Qu'il s'agisse d'une interface graphique ou d'un serveur réseau, ils attendent tous les événements: entrée clavier, événements souris, paquets de données arrivant sur le réseau.  Mais tous les logiciels attendent différemment.  Les systèmes sans verrouillage ne doivent pas attendre du tout.  Au moins, l'utilisation d'algorithmes sans verrouillage devrait se produire là où vous n'avez pas besoin d'attendre, et même nuisible.  Mais nous parlons de systèmes compétitifs (multithread), et curieusement, des algorithmes sans verrouillage attendent également.  Oui, ils ne bloquent pas l'exécution des threads parallèles, mais ils attendent eux-mêmes l'opportunité de faire quelque chose sans bloquer. </p><br><p>  LAppS utilise très activement les mutex et les sémaphores.  En même temps, il n'y a pas de sémaphores dans la norme C ++.  Le mécanisme est très important et pratique, mais C ++ devrait fonctionner sur des systèmes qui ne prennent pas en charge les sémaphores, et donc les sémaphores ne sont pas inclus dans la norme.  De plus, si j'utilise des sémaphores parce qu'ils sont pratiques, alors des mutex parce que je le dois. </p><br><p>  Le comportement du mutex dans le cas de lock concurrentiel (), comme sem_wait () sous Linux, place le thread en attente à la fin de la file d'attente du planificateur de tâches, et lorsqu'il est en haut, la vérification est répétée sans retourner au pays utilisateur, le thread est replacé dans la file d'attente si l'événement attendu ne s'est pas encore produit.  Ceci est un point très important. </p><br><p>  Et j'ai décidé de vérifier si je peux refuser les sémaphores std :: mutex et POSIX, en les émulant avec std :: atomic, en transférant la charge principalement vers l'espace utilisateur.  En fait, a échoué, mais d'abord les choses. </p><br><p>  Tout d'abord, j'ai plusieurs sections dans lesquelles ces expériences pourraient être utiles: </p><br><ul><li>  verrous dans LibreSSL (cas 1); </li><li>  blocage lors du transfert de paquets reçus de charge utile vers des applications Lua (cas 2); </li><li>  En attente d'événements de charge utile prêts à être traités par les applications Lua (cas 3). </li></ul><br><p>  Commençons par les verrous non bloquants.  Écrivons notre mutex en utilisant l'atomique, comme le montrent certains discours de H. Sutter (il n'y a donc pas de code d'origine, de mémoire et donc le code ne coïncide pas avec les 100% d'origine, et dans Satter ce code était lié à la progression de C ++ 20, il y a donc des différences).  Et malgré la simplicité de ce code, il comporte des pièges. </p><br><pre> <code class="hljs kotlin">#include &lt;atomic&gt; #include &lt;pthread.h&gt; namespace test { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;pthread_t&gt; mLock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: explicit mutex():mLock{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } mutex(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutex&amp;)=delete; mutex(mutex&amp;)=delete; void lock() { pthread_t locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  C++20     , .. compare_exchange_strong          while(!mLock.compare_exchange_strong(locked_by,pthread_self())) { locked_by=0; //      } } void unlock() { pthread_t current=pthread_self(); if(!mLock.compare_exchange_strong(current,0)) { throw std::system_error(EACCES, std::system_category(), "An attempt to unlock the mutex owned by other thread"); } } const bool try_lock() { pthread_t unused=0; return mLock.compare_exchange_strong(unused,pthread_self()); } }; }</span></span></code> </pre> <br><p>  Contrairement à std :: mutex :: unlock (), le comportement de test :: mutex: unlock () lors de la tentative de déverrouillage à partir d'un autre thread est déterministe.  Une exception sera levée.  C'est bon, bien que non conforme au comportement standard.  Et qu'est-ce qui est mauvais dans cette classe?  La mauvaise nouvelle est que la méthode test :: mutex: lock () consommera sans vergogne les ressources CPU dans les quotas de temps alloués au thread, pour tenter de reprendre le mutex qu'un autre thread possède déjà.  C'est-à-dire  une boucle dans test :: mutex: lock () sera un gaspillage de ressources CPU.  Quelles sont nos options pour surmonter cette situation? </p><br><p>  Nous pouvons utiliser sched_yield () (comme suggéré dans l'un des commentaires sur l'article ci-dessus).  C'est aussi simple que ça?  Premièrement, pour utiliser sched_yield (), il est nécessaire que les threads d'exécution utilisent les politiques SCHED_RR, SCHED_FIFO pour leur priorisation dans le planificateur de tâches.  Sinon, appeler sched_yield () serait un gaspillage de ressources CPU.  Deuxièmement, un appel très fréquent à sched_yield () augmentera toujours la consommation du processeur.  De plus, l'utilisation de stratégies en temps réel dans votre application, et à condition qu'il n'y ait aucune autre application en temps réel dans le système, limitera la file d'attente du planificateur avec la stratégie sélectionnée à vos threads uniquement.  Il semblerait que ce soit bon!  Non, pas bon.  L'ensemble du système deviendra moins réactif, car  occupé avec tâche prioritaire.  CFQ sera dans le stylo.  Mais il existe d'autres threads dans l'application, et très souvent une situation se produit lorsque le thread qui a capturé le mutex est placé à la fin de la file d'attente (le quota a expiré), et le thread qui attend que le mutex soit libéré juste devant lui.  Dans mes expériences (cas 2), cette méthode a donné à peu près les mêmes résultats (3,8% de moins) que std :: mutex, mais le système est moins réactif et la consommation CPU est augmentée de 5% à 7%. </p><br><p>  Vous pouvez essayer de changer test :: mutex :: lock () comme ceci (également mauvais): </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!mLock.compare_exchange_strong(locked_by,pthread_self())) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pause</span></span></span><span class="hljs-class">{</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -      nanosleep(&amp;pause,nullptr); locked_by=0; } }</span></span></code> </pre> <br><p>  Ici, vous pouvez expérimenter la durée du sommeil en nanosecondes, les retards de 4 ns étaient optimaux pour mon processeur et la baisse de performances par rapport à std :: mutex dans le même cas 2 était de 1,2%.  Pas le fait que le nanosommeil dormait 4 ns.  En fait, ou plus (dans le cas général) ou moins (en cas d'interruption).  La baisse (!) De la consommation CPU était de 12% -20%.  C'est-à-dire  c'était un rêve si sain. </p><br><p>  OpenSSL et LibreSSL ont deux fonctions qui configurent des rappels à bloquer lors de l'utilisation de ces bibliothèques dans un environnement multithread.  Cela ressemble à ceci: </p><br><pre> <code class="hljs pgsql">//  callback <span class="hljs-type"><span class="hljs-type">void</span></span> openssl_crypt_locking_function_callback(<span class="hljs-type"><span class="hljs-type">int</span></span> mode, <span class="hljs-type"><span class="hljs-type">int</span></span> n, const <span class="hljs-type"><span class="hljs-type">char</span></span>* file, const <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span>) { static std::vector&lt;std::mutex&gt; locks(CRYPTO_num_locks()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n&gt;=static_cast&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(locks.size())) { <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mode &amp; CRYPTO_LOCK) locks[n].<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> locks[n].unlock(); } //  callback-a CRYPTO_set_locking_callback(openssl_crypt_locking_function_callback); //  id CRYPTO_set_id_callback(pthread_self);</code> </pre> <br><p>  Et maintenant, le pire, c'est que l'utilisation du test :: mutex mutex ci-dessus dans LibreSSL réduit les performances de LAppS de près de 2 fois.  De plus, quelle que soit l'option (boucle d'attente vide, sched_yield (), nanosleep ()). </p><br><p>  En général, nous supprimons le cas 2 et le cas 1, et restons avec std :: mutex. </p><br><p>  Passons aux sémaphores.  Il existe de nombreux exemples d'implémentation de sémaphores à l'aide de std :: condition_variable.  Ils utilisent tous également std :: mutex.  Et ces simulateurs de sémaphore sont plus lents (selon mes tests) que les sémaphores du système POSIX. </p><br><p>  Par conséquent, nous allons faire un sémaphore sur les atomes: </p><br><pre> <code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">semaphore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;bool&gt; mayRun; mutable std::atomic&lt;int64_t&gt; counter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">explicit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">semaphore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : mayRun</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>},counter{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } semaphore(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> semaphore&amp;)=delete; semaphore(semaphore&amp;)=delete; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mayRun.load(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(counter.fetch_sub(<span class="hljs-number"><span class="hljs-number">1</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!try_wait()) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> thread_local <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> struct timespec pause{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; nanosleep(&amp;pause,nullptr); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mayRun.store(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> int64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrimentOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_t value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter.fetch_sub(value); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } ~semaphore() { destroy(); } };</code> </pre> <br><p>  Oh, ce sémaphore est beaucoup plus rapide que le sémaphore système.  Le résultat d'un test séparé de ce sémaphore avec un fournisseur et 20 consamers: </p><br><pre> <code class="hljs bash">OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(OS): wakes: 500321 Thread(OS): wakes: 500473 Thread(OS): wakes: 501504 Thread(OS): wakes: 502337 Thread(OS): wakes: 498324 Thread(OS): wakes: 502755 Thread(OS): wakes: 500212 Thread(OS): wakes: 498579 Thread(OS): wakes: 499504 Thread(OS): wakes: 500228 Thread(OS): wakes: 499696 Thread(OS): wakes: 501978 Thread(OS): wakes: 498617 Thread(OS): wakes: 502238 Thread(OS): wakes: 497797 Thread(OS): wakes: 498089 Thread(OS): wakes: 499292 Thread(OS): wakes: 498011 Thread(OS): wakes: 498749 Thread(OS): wakes: 501296 OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 9924 milliseconds OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.9924ns ======================================= AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(EmuAtomic) wakes: 492748 Thread(EmuAtomic) wakes: 546860 Thread(EmuAtomic) wakes: 479375 Thread(EmuAtomic) wakes: 534676 Thread(EmuAtomic) wakes: 501014 Thread(EmuAtomic) wakes: 528220 Thread(EmuAtomic) wakes: 496783 Thread(EmuAtomic) wakes: 467563 Thread(EmuAtomic) wakes: 608086 Thread(EmuAtomic) wakes: 489825 Thread(EmuAtomic) wakes: 479799 Thread(EmuAtomic) wakes: 539634 Thread(EmuAtomic) wakes: 479559 Thread(EmuAtomic) wakes: 495377 Thread(EmuAtomic) wakes: 454759 Thread(EmuAtomic) wakes: 482375 Thread(EmuAtomic) wakes: 512442 Thread(EmuAtomic) wakes: 453303 Thread(EmuAtomic) wakes: 480227 Thread(EmuAtomic) wakes: 477375 AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 341 milliseconds AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.0341ns</code> </pre><br><p>  Ce sémaphore avec un post presque gratuit (), 29 fois plus rapide que celui du système, est également très rapide pour réveiller les threads qui l'attendent: 29325 réveils par milliseconde, contre 1007 réveils par milliseconde du système.  Il a un comportement déterministe avec un sémaphore détruit ou un sémaphore destructible.  Et naturellement, segfault lorsque vous essayez d'utiliser un déjà détruit. </p><br><p>  (¹) En fait, tant de fois en une milliseconde, un flux ne peut pas être retardé et réveillé par le planificateur.  Parce que  post () ne bloque pas, dans ce test synthétique, wait () se retrouve très souvent dans une situation où vous n'avez pas besoin de dormir.  Dans le même temps, au moins 7 threads en parallèle lisent la valeur du sémaphore. </p><br><p>  Mais son utilisation dans le cas 3 dans LAppS entraîne des pertes de performances indépendamment du temps de sommeil.  Il se réveille trop souvent pour vérifier, et les événements dans LAppS arrivent beaucoup plus lentement (latence réseau, latence côté client générant la charge, etc.).  Et vérifier moins souvent signifie également perdre des performances. </p><br><p>  De plus, l'utilisation du sommeil dans de tels cas et d'une manière similaire est complètement nuisible, car  sur un autre matériel, les résultats peuvent s'avérer complètement différents (comme dans le cas de la pause des instructions d'assembleur), et pour chaque modèle de CPU, vous devez également sélectionner le temps de retard. </p><br><p>  L'avantage d'un mutex et d'un sémaphore système est que le thread d'exécution ne se réveille pas jusqu'à ce qu'un événement (déverrouillage du mutex ou incrémentation du sémaphore) se produise.  Les cycles CPU supplémentaires ne sont pas gaspillés - profit. </p><br><p>  En général, tout de ce mal, la désactivation des iptables sur mon système donne de 12% (avec TLS) à 30% (sans TLS) un gain de performance ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428087/">https://habr.com/ru/post/fr428087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428077/index.html">React.js: Guide du débutant</a></li>
<li><a href="../fr428079/index.html">Appliquer les principes SOLID pour réagir au développement d'applications</a></li>
<li><a href="../fr428081/index.html">Utilisation de RxJS dans React Development pour gérer l'état de l'application</a></li>
<li><a href="../fr428083/index.html">Matrice d'influence de l'analyse Web - Système stratégique d'Avinash Koshik</a></li>
<li><a href="../fr428085/index.html">Frontend contre-attaque: Top 10 (?) Rapports HolyJS 2018 Piter</a></li>
<li><a href="../fr428089/index.html">"Calendrier des testeurs" pour octobre. Commentaires: comment cela se passe</a></li>
<li><a href="../fr428091/index.html">Comment un étudiant stagiaire a créé le jeu vidéo le plus populaire au monde ou l'historique des jeux Windows</a></li>
<li><a href="../fr428095/index.html">Étude de marché pour les studios web et les agences numériques</a></li>
<li><a href="../fr428097/index.html">Routage récursif dans MikroTik via des passerelles attribuées par DHCP</a></li>
<li><a href="../fr428099/index.html">Qu'ont en commun les robes ordinaires et la prochaine ère 5G?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>