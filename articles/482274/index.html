<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëö üòñ üëàüèª 5 razones por las que debe dejar de usar System.Drawing en ASP.NET üë®‚Äçüë®‚Äçüë¶ üìî üëµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Le presento la traducci√≥n del art√≠culo "5 razones por las que debe dejar de usar System.Drawing from ASP.NET" . 



 Pues lo hicieron. El e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 razones por las que debe dejar de usar System.Drawing en ASP.NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482274/"> Hola Habr!  Le presento la traducci√≥n del art√≠culo <a href="https://photosauce.net/blog/post/5-reasons-you-should-stop-using-systemdrawing-from-aspnet" rel="nofollow">"5 razones por las que debe dejar de usar System.Drawing from ASP.NET"</a> . <br><br><img src="https://habrastorage.org/webt/cz/ak/-m/czak-mp2zhhou0aufqy5s4p8z4c.png" alt="imagen"><br><br>  Pues lo hicieron.  El equipo de corefx finalmente acept√≥ <a href="https://github.com/dotnet/corefx/search%3Fq%3Dsystem.drawing%26type%3DIssues" rel="nofollow">numerosas solicitudes</a> e incluy√≥ System.Drawing en .NET Core. <a name="habracut"></a>  (art√≠culo original de julio de 2017) <br><br>  El <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">pr√≥ximo</a> paquete <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">System.Drawing.Common</a> contendr√° la mayor parte de la funcionalidad System.Drawing del .NET Framework completo y est√° destinado a ser utilizado como una opci√≥n de compatibilidad para aquellos que desean migrar a .NET Core pero no pueden hacerlo debido a dependencias.  Desde esta perspectiva, Microsoft est√° haciendo lo correcto.  La fricci√≥n debe reducirse ya que la adopci√≥n de .Net Core es un objetivo m√°s valioso. <br><br>  Por otro lado, System.Drawing es una de las √°reas m√°s pobres y desfavorecidas de .Net Framework y muchos de nosotros esperamos que la implementaci√≥n de .NET Core signifique la muerte lenta de System.Drawing.  Y junto con esta muerte deber√≠a ser una oportunidad para hacer algo mejor. <br><br>  Por ejemplo, el equipo de Mono cre√≥ un contenedor compatible con .NET para la biblioteca de gr√°ficos multiplataforma <a href="https://skia.org/" rel="nofollow">Skia de</a> Google, llamada <a href="https://github.com/mono/SkiaSharp" rel="nofollow">SkiaSharp</a> .  Para simplificar la instalaci√≥n, Nuget ha recorrido un largo camino en el soporte de bibliotecas nativas para cada plataforma.  Skia es bastante completo y su rendimiento hace System.Drawing. <br><br>  El equipo de <a href="https://github.com/JimBobSquarePants/ImageSharp" rel="nofollow">ImageSharp</a> tambi√©n ha hecho un gran trabajo repitiendo gran parte de la funcionalidad de dibujo del sistema, pero con la mejor implementaci√≥n de API y 100% C #.  Todav√≠a no est√°n listos para la explotaci√≥n productiva, pero parece que ya est√°n lo suficientemente cerca de esto.  Una peque√±a advertencia sobre esta biblioteca, ya que estamos hablando del uso en aplicaciones de servidor: ahora, en la configuraci√≥n predeterminada, Parallel.For se usa en el interior para acelerar algunas operaciones, lo que significa que se usar√°n m√°s flujos de trabajo del grupo ASP.NET, eventualmente <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">Como</a> resultado, se <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">reduce el rendimiento general de la aplicaci√≥n</a> .  Espero que este comportamiento se revise antes del lanzamiento, pero incluso ahora es suficiente cambiar una l√≠nea de la configuraci√≥n para que sea m√°s adecuado para su uso en el servidor. <br><br>  En cualquier caso, si est√° dibujando, trazando o renderizando texto en im√°genes en una aplicaci√≥n en el servidor, deber√≠a considerar seriamente cambiar System.Drawing a cualquier cosa, independientemente de si cambia a .NET Core o no. <br><br>  Por mi parte, he reunido una canalizaci√≥n de procesamiento de im√°genes de alto rendimiento para .NET y .NET Core, que proporciona una calidad de imagen que System.Drawing no puede proporcionar, y lo hace en una arquitectura altamente escalable dise√±ada espec√≠ficamente para su uso en el servidor.  Hasta ahora, es solo para Windows, sin embargo, la plataforma cruzada est√° en los planes.  Si usa System.Drawing (u otra cosa) para cambiar el tama√±o de las im√°genes en el servidor, es mejor considerar <a href="https://github.com/saucecontrol/PhotoSauce" rel="nofollow">MagicScaler</a> como un reemplazo. <br><br>  Pero es probable que un System.Drawing resurrection, que facilita la transici√≥n para algunos desarrolladores, mate la mayor parte del impulso que recibieron estos proyectos, ya que los desarrolladores se vieron obligados a buscar alternativas.  Desafortunadamente en el ecosistema .NET, las bibliotecas y paquetes de Microsoft siempre ganar√°n, sin importar cu√°n superiores puedan ser las alternativas. <br><br>  Esta publicaci√≥n es un intento de corregir algunos errores de c√°lculo de System.Drawing con la esperanza de que los desarrolladores exploren alternativas incluso si System.Drawing sigue siendo una opci√≥n. <br><br>  Comenzar√© con el <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">descargo de responsabilidad</a> frecuentemente citado <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">del</a> Sistema. Dibujo de documentaci√≥n.  Este rechazo se ha planteado un par de veces en una <a href="https://github.com/dotnet/corefx/issues/20325" rel="nofollow">discusi√≥n sobre Github cuando se habla de System.Drawing.Common</a> . <br><blockquote>  ‚ÄúLas clases con el espacio de nombres System.Drawing no son compatibles para su uso en servicios de Windows o ASP.NET.  Intentar utilizar estas clases con estos tipos de aplicaciones puede causar problemas inesperados, como una disminuci√≥n del rendimiento del servidor y errores de tiempo de ejecuci√≥n ". </blockquote><br>  Como muchos de ustedes, le√≠ este descargo de responsabilidad hace mucho tiempo, y luego lo omit√≠ y a√∫n us√© System.Drawing en mi aplicaci√≥n ASP.NET.  Por qu√©  Porque amo el peligro.  O eso, o no se encontraron otras opciones viables.  ¬øY sabes que?  No pas√≥ nada malo.  Lo m√°s probable es que no deber√≠a haber dicho esto, pero apuesto a que muchos de ustedes han experimentado lo mismo.  Entonces, ¬øpor qu√© no seguir usando System.Drawing o bibliotecas basadas en √©l? <br><br><h3>  Raz√≥n # 1: Descriptores GDI </h3><br>  Si alguna vez ha tenido problemas al usar System.Drawing en un servidor, este es probablemente el caso.  Si no se prueba, esta es una de las causas m√°s probables. <br><br>  System.Drawing en su mayor parte es una envoltura delgada alrededor de la API de Windows GDI +.  Muchos <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v%3Dvs.85).aspx" rel="nofollow">descriptores de GDI</a> admiten objetos System.Drawing y tienen un l√≠mite cuantitativo en el procesador y la sesi√≥n del usuario.  Si se alcanza este umbral, obtendr√° una excepci√≥n de "Memoria insuficiente" y / o un error 'gen√©rico' de GDI +. <br><br>  El problema es que en .NET, la recolecci√≥n de basura y la finalizaci√≥n del proceso pueden retrasar la publicaci√≥n de estos descriptores para cuando llegue al l√≠mite, incluso con poca carga.  Si olvida (o no sab√≠a lo que necesita) llamar a Dispose () en un objeto que contiene dichos descriptores, corre el riesgo de encontrar tales errores en su entorno.  Y como la mayor√≠a de los errores relacionados con las limitaciones o fugas de recursos, lo m√°s probable es que esta situaci√≥n se pruebe con √©xito y lo pique en una operaci√≥n productiva.  Naturalmente, esto suceder√° cuando su aplicaci√≥n est√© bajo la mayor carga, de modo que el n√∫mero m√°ximo de usuarios descubra su verg√ºenza. <br><br>  <a href="https://en.wikipedia.org/wiki/Graphics_Device_Interface" rel="nofollow">Las restricciones en el procesador y en la sesi√≥n del usuario</a> dependen de la versi√≥n del sistema operativo, y la restricci√≥n en el procesador es personalizable.  Pero la versi√≥n no importa, porque  Los descriptores de GDI est√°n representados internamente por el tipo de datos USHORT, por lo que hay un l√≠mite estricto de 65.536 descriptores por sesi√≥n de usuario, e incluso una aplicaci√≥n bien escrita corre el riesgo de alcanzar este l√≠mite con suficiente carga.  Cuando cree que un servidor m√°s potente le permitir√° servir a m√°s y m√°s usuarios en paralelo en una instancia, este riesgo se vuelve m√°s real.  Y realmente, ¬øqui√©n quiere crear software con un conocido l√≠mite r√≠gido de escalabilidad? <br><br><h3>  Raz√≥n # 2: concurrencia </h3><br>  GDI + siempre tuvo problemas con la simultaneidad, aunque muchos de ellos estaban relacionados con <a href="https://blogs.msdn.microsoft.com/e7/2009/04/25/engineering-windows-7-graphics-performance/" rel="nofollow">cambios arquitect√≥nicos en Windows 7 / Windows Server 2008 R2</a> , todav√≠a se ven algunos de ellos en nuevas versiones.  El m√°s notable es el <a href="https://stackoverflow.com/questions/3719748/parallelizing-gdi-image-resizing-net" rel="nofollow">bloqueo</a> del <a href="https://stackoverflow.com/questions/3719748/parallelizing-gdi-image-resizing-net" rel="nofollow">proceso</a> organizado por GDI + durante la operaci√≥n DrawImage ().  Si cambia el tama√±o de las im√°genes en el servidor utilizando System.Drawing (o las bibliotecas que lo envuelven), el m√©todo DrawImage () es probablemente la base de este c√≥digo. <br><br>  Adem√°s, al realizar varias llamadas a DrawImage () al mismo tiempo, <b>todas</b> se bloquear√°n hasta que se ejecuten todas.  Incluso si el tiempo de respuesta no es un problema para usted (¬øpor qu√© no? ¬øOdia a sus usuarios?) Tenga en cuenta que los recursos de memoria asociados con estas solicitudes y todos los descriptores GDI que poseen los objetos asociados con estas solicitudes est√°n vinculados al tiempo de ejecuci√≥n.  De hecho, no se necesita mucha carga en el servidor para comenzar a causar problemas. <br><br>  Por supuesto, hay soluciones para este problema en particular.  Por ejemplo, algunos desarrolladores crean un proceso externo para cada operaci√≥n DrawImage ().  Pero, de hecho, esa soluci√≥n solo agrega fragilidad adicional, lo que realmente no deber√≠a haber hecho. <br><br><h3>  Raz√≥n # 3: Memoria </h3><br>  Considere un controlador ASP.NET que genera un gr√°fico.  Deber√≠a hacer algo como esto: <br><br><ol><li>  Crear un mapa de bits como un lienzo </li><li>  Dibuja m√∫ltiples formas en un mapa de bits usando bol√≠grafos y / o pinceles </li><li>  Dibuja texto usando una o m√°s fuentes </li><li>  Guardar mapa de bits como PNG en MemoryStream </li></ol><br>  Digamos que el gr√°fico mide 600 por 400 puntos.  Esto es un total de 240,000 puntos, multiplicado por 4 bytes para un punto para el formato RGBA predeterminado, totalizando 960,000 bytes para un mapa de bits, m√°s un poco para dibujar objetos y un b√∫fer de guardado.  Deje que sea 1mb para toda la solicitud.  Lo m√°s probable es que no tenga problemas de memoria para tal escenario, y si se encuentra con algo, lo m√°s probable es que tenga un l√≠mite en el n√∫mero de descriptores, que mencion√© anteriormente, ya que las im√°genes, los pinceles, los l√°pices y las fuentes tienen sus propios descriptores. <br><br>  El verdadero problema surge cuando System.Drawing se usa para tareas de im√°genes.  System.Drawing es principalmente una biblioteca de gr√°ficos, y las bibliotecas de gr√°ficos generalmente se basan en la idea de que todo es un mapa de bits en la memoria.  Esto es genial mientras piensas en las peque√±as cosas.  Pero las im√°genes pueden ser realmente grandes, y se hacen m√°s grandes todos los d√≠as, porque  Las c√°maras con muchos megap√≠xeles son cada vez m√°s baratas. <br><br>  Si adopta el enfoque ingenuo de System.Drawing para la creaci√≥n de im√°genes, obtendr√° algo como esto para el controlador de cambio de tama√±o: <br><br><ol><li>  Cree un mapa de bits como lienzo para la imagen de destino. </li><li>  Cargue la imagen original en otro mapa de bits. </li><li>  Llame a DrawImage () con el par√°metro "image-source" para la imagen de destino, utilizando el cambio de tama√±o. </li><li>  Guarde el mapa de bits de destino en formato JPEG en la secuencia de memoria. </li></ol><br>  Supongamos que la imagen de destino ser√° 600x400, como en el ejemplo anterior, luego nuevamente tenemos 1 MB para la <i>imagen de destino</i> y el flujo de memoria.  Pero supongamos que alguien carg√≥ una imagen de 24 megap√≠xeles de sus nuevas r√©flex digitales, entonces necesitamos 6000x4000 p√≠xeles con 3 bytes para cada uno (72 MB) para el mapa de bits de la fuente decodificada en formato RGB.  Y utilizaremos el remuestreo HighQualityBicubic de System.Drawing, porque solo se ve bien.  Luego, debemos tener en cuenta los otros 6000x4000 puntos con 4 bytes cada uno, para la <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-5-push-vs-pull-and-image-validation" rel="nofollow">conversi√≥n PRGBA que ocurre dentro del m√©todo llamado</a> , agregando 96mb adicionales de memoria usada.  En total, se obtienen 169mb (!) Por una solicitud para convertir una sola imagen. <br><br>  Ahora imagine que tiene m√°s de un usuario haciendo tales cosas.  Ahora recuerde que las solicitudes se bloquean hasta que todas se ejecuten por completo.  ¬øCu√°nto tiempo lleva quedarse sin memoria?  E incluso si no se preocupa de agotar por completo todo lo disponible, recuerde que hay muchas maneras de utilizar mejor la memoria de su servidor que contener un mont√≥n de p√≠xeles.  Considere el efecto de la presi√≥n de la memoria en otras partes de la aplicaci√≥n / sistema: <br><br><ol><li>  La memoria cach√© de ASP.NET puede comenzar a vaciar elementos que son costosos de recrear </li><li>  El recolector de basura se iniciar√° con m√°s frecuencia, ralentizando la aplicaci√≥n </li><li>  El cach√© del kernel IIS o el cach√© del sistema de archivos de Windows puede eliminar elementos √∫tiles </li><li>  El grupo de aplicaciones puede exceder el l√≠mite de memoria y puede reiniciarse </li><li>  Windows puede comenzar a intercambiar memoria al disco, ralentizando todo el sistema </li></ol><br>  ¬øRealmente no quieres nada de esto? <br><br>  Las bibliotecas dise√±adas espec√≠ficamente para tareas de procesamiento de im√°genes abordan este problema de una manera completamente diferente.  No necesitan cargar toda la fuente o la imagen de destino en la memoria.  Si no va a dibujar en √©l, no necesita un lienzo / mapa de bits.  Esto se hace m√°s as√≠: <br><br><ol><li>  Crear flujo para el codificador JPEG de la imagen de destino </li><li>  Cargue una l√≠nea de la imagen original y compr√≠mala horizontalmente </li><li>  Repita tantas veces como sea necesario para formar una l√≠nea para el archivo de destino </li><li>  Comprime las l√≠neas resultantes verticalmente </li><li>  Repita desde el paso 2 hasta que se procesen todas las l√≠neas del archivo fuente. </li></ol><br>  Con este m√©todo, la misma imagen se puede procesar con 1 MB de memoria en total, e incluso las im√°genes mucho m√°s grandes requerir√°n un ligero aumento en la sobrecarga. <br><br>  Conozco solo una biblioteca .NET que est√° optimizada por este principio, y le dar√© una pista: esto no es System.Drawing. <br><br><h3>  Raz√≥n # 4: CPU </h3><br>  Otro efecto secundario de System.Drawing que est√° m√°s orientado gr√°ficamente que orientado a im√°genes es que DrawImage () es bastante ineficiente en t√©rminos de uso de CPU.  Cubr√≠ esto con cierto detalle en una <a href="https://photosauce.net/blog/post/lies-damned-lies-and-benchmarks-part-2-drawimage-why-u-so-slow" rel="nofollow">publicaci√≥n anterior</a> , pero esta discusi√≥n se puede resumir en los siguientes hechos: <br><br><ul><li>  En System.Drawing, la conversi√≥n de escala HighQualityBicubic solo funciona con el formato PRGBA.  En casi todos los escenarios, esto significa una copia extra de la imagen.  Esto no solo usa (significativamente) m√°s memoria adicional, sino que tambi√©n quema los ciclos del procesador para convertir y procesar el canal alfa adicional. </li><li>  Incluso despu√©s de que la imagen est√© en su formato nativo, la conversi√≥n de escala HighQualityBicubic realiza aproximadamente 4 veces m√°s c√°lculos de los necesarios para obtener los resultados de conversi√≥n correctos. </li></ul><br>  Estos hechos agregan una cantidad significativa de ciclos de CPU desperdiciados.  En un entorno nublado con pago por minuto, esto contribuye directamente al costo del alojamiento.  Y, por supuesto, su tiempo de respuesta se ver√° afectado. <br><br>  Y piense en el hecho de que se gastar√° electricidad adicional y se generar√° calor.  Su uso de System.Drawing para tareas de procesamiento de im√°genes afecta directamente el calentamiento global.  Eres un monstruo <br><br><h3>  Raz√≥n 5: el procesamiento de im√°genes es enga√±osamente complejo </h3><br>  Dejando a un lado el rendimiento, System.Drawing de muchas maneras evita que la imagen se procese correctamente.  Usar System.Drawing significa vivir con resultados incorrectos o aprender todo sobre el perfil ICC, la cuantizaci√≥n del color, la orientaci√≥n exif, la correcci√≥n y muchas otras cosas espec√≠ficas.  Este es un agujero de conejo, que la mayor√≠a de los desarrolladores no tienen ni el tiempo ni el deseo de explorar. <br><br>  Las bibliotecas como ImageResizer e ImageProcessor han ganado muchos admiradores, cuidando algunos de estos detalles, pero tenga cuidado, tienen System.Drawing dentro, y vienen con todo el equipaje que describ√≠ en detalle en este art√≠culo. <br><br><h3>  Raz√≥n adicional: puedes hacerlo mejor </h3><br>  Si usted, como yo, tuvo que usar anteojos en alg√∫n momento de su vida, probablemente recuerde c√≥mo fue la primera vez que se los puso.  Pens√© que estaba viendo normalmente, y si entrecerro los ojos correctamente, entonces todo estar√° bastante claro.  Pero luego me puse estas gafas y el mundo se volvi√≥ mucho m√°s detallado de lo que podr√≠a haber imaginado. <br><br>  Sistema: el dibujo es muy parecido.  Hace lo correcto si <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-3-drawimage-and-the-settings-that-affect-it" rel="nofollow">completa la configuraci√≥n correctamente</a> , pero se sorprender√° de lo mucho que se ver√°n sus im√°genes si usa las mejores utilidades. <br><br>  Dejar√© esto aqu√≠ como ejemplo.  Este es el mejor sistema que se puede hacer en comparaci√≥n con la configuraci√≥n predeterminada de MagicScaler.  Tal vez su aplicaci√≥n se beneficiar√° al obtener puntos ... <br><br>  Gdi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/9c9/491/9a69c9491e230c3a7e887e830d136860.jpg" alt="imagen"><br><br>  MagicScaler: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/eec/e24/dd2eece240e1a41b46c74ccde2e5eed2.jpg" alt="imagen"><br>  <a href="https://unsplash.com/%40jakobowens1" rel="nofollow">Foto de Jakob Owens.</a> <br><br>  Eche un vistazo, explore alternativas y, en nombre del amor por los gatitos, deje de usar System.Drawing en ASP.NET </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482274/">https://habr.com/ru/post/482274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482260/index.html">TelegramBot. La funcionalidad b√°sica. Pegatinas y emoticones. (Parte 3)</a></li>
<li><a href="../482262/index.html">C√≥mo iniciar sesi√≥n en Talend Open Studio</a></li>
<li><a href="../482264/index.html">Brasil, magia oscura, Mortal Kombat, Marte y 15,000 personas. Resultados del a√±o de Ontiko</a></li>
<li><a href="../482268/index.html">Megaestructuras del futuro: la esfera Dyson, el motor estelar y la "bomba de agujero negro"</a></li>
<li><a href="../482272/index.html">Elecci√≥n de un almac√©n de datos para Prometheus: Thanos vs VictoriaMetrics</a></li>
<li><a href="../482276/index.html">GOST R 57580. De las tendencias a la automatizaci√≥n eficiente</a></li>
<li><a href="../482280/index.html">¬øC√≥mo se hace el cosplay? Traje de traje avanzado de Isaac Clarke de Dead Space 2</a></li>
<li><a href="../482282/index.html">El final de la era ARMv7 o un poco sobre portar juegos</a></li>
<li><a href="../482284/index.html">"50 tonos de marr√≥n" o "¬øC√≥mo llegamos a esto?"</a></li>
<li><a href="../482286/index.html">Revisi√≥n colectiva inesperada de cartuchos Audio-Technica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>