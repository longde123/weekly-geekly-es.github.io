<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã üí∏ üë®‚Äçüëß Wie man richtig und falsch schl√§ft ü§™ ü§πüèª üèáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit lief ein guter Artikel √ºber den schrecklichen Leistungszustand moderner Software ( Original in Englisch , √úbersetzung in H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man richtig und falsch schl√§ft</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/427843/">  Vor nicht allzu langer Zeit lief ein guter Artikel √ºber den schrecklichen Leistungszustand moderner Software ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original in Englisch</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung in Habr√©</a> ) an uns vorbei.  Dieser Artikel erinnerte mich an ein Antimuster des Codes, das sehr h√§ufig ist und im Allgemeinen irgendwie funktioniert, aber hier und da zu kleinen Leistungsverlusten f√ºhrt.  Wei√üt du, eine Kleinigkeit, die die H√§nde in keiner Weise erreichen werden.  Das einzige Problem ist, dass ein Dutzend dieser "Kleinigkeiten", die an verschiedenen Stellen im Code verstreut sind, zu Problemen wie "Ich habe den neuesten Intel Core i7 und das Scrollen zuckt" f√ºhren. <br><br><img src="https://habrastorage.org/webt/ri/na/rs/rinarsug4i1qt6b8kzc0i-6tcjy.png" align="right">  Ich spreche von der falschen Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sleep-</a> Funktion (der Fall kann je nach Programmiersprache und Plattform variieren).  Was ist Schlaf?  Die Dokumentation beantwortet diese Frage sehr einfach: Dies ist eine Pause in der Ausf√ºhrung des aktuellen Threads f√ºr die angegebene Anzahl von Millisekunden.  Es sei auf die √§sthetische Sch√∂nheit des Prototyps dieser Funktion hingewiesen: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD dwMilliseconds)</span></span></span></span>;</code> </pre> <br>  Nur ein Parameter (extrem klar), keine Fehlercodes oder Ausnahmen - es funktioniert immer.  Es gibt nur sehr wenige so nette und verst√§ndliche Funktionen! <br><br><div class="spoiler">  <b class="spoiler_title">Sie erhalten noch mehr Respekt vor dieser Funktion, wenn Sie lesen, wie sie funktioniert.</b> <div class="spoiler_text">  Die Funktion geht zum OS-Thread-Scheduler und teilt ihm mit: ‚ÄûMein Thread und ich m√∂chten die uns zugewiesene CPU-Zeit jetzt und in Zukunft f√ºr ebenso viele Millisekunden ablehnen.  Gib den Armen! "  Der Scheduler, der von dieser Gro√üz√ºgigkeit leicht √ºberrascht ist, nimmt die Funktionen der Dankbarkeit im Namen des Prozessors heraus, gibt der n√§chsten Person die verbleibende Zeit (und es gibt immer solche) und enth√§lt nicht den Thread, der dazu gef√ºhrt hat, dass Sleep so getan hat, als w√ºrde er den Ausf√ºhrungskontext f√ºr die angegebene Anzahl von Millisekunden an ihn √ºbertragen.  Sch√∂nheit! <br></div></div><br>  Was h√§tte schief gehen k√∂nnen?  Die Tatsache, dass Programmierer diese wunderbare Funktion verwenden, ist nicht das, wof√ºr sie gedacht ist. <br><a name="habracut"></a><br>  Und es ist f√ºr die Software-Simulation eines externen, durch einen realen Pausenprozess definierten Prozesses vorgesehen. <br><br><h3>  Richtiges Beispiel Nummer 1 </h3><br>  Wir schreiben eine "Uhr" -Anwendung, in der Sie einmal pro Sekunde eine Ziffer auf dem Bildschirm (oder die Position des Pfeils) √§ndern m√ºssen.  Die Schlaffunktion ist hier perfekt geeignet: Wir haben f√ºr einen klar definierten Zeitraum (genau eine Sekunde) wirklich nichts zu tun.  Warum nicht schlafen? <br><br><h3>  Richtiges Beispiel Nummer 2 </h3><br>  Wir schreiben einen <s>Mondschein-</s> Controller <s>f√ºr eine</s> Brotmaschine.  Der Operationsalgorithmus wird von einem der Programme eingestellt und sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><ol><li>  Gehen Sie zu Modus 1. </li><li>  20 Minuten darin arbeiten </li><li>  Gehen Sie zu Modus 2. </li><li>  10 Minuten darin arbeiten </li><li>  Ausschalten. </li></ol><br>  Auch hier ist alles klar: Wir arbeiten mit der Zeit, sie wird durch den technologischen Prozess bestimmt.  Die Verwendung von Schlaf ist akzeptabel. <br><br>  Schauen wir uns nun Beispiele f√ºr den Missbrauch des Schlafes an. <br><br>  Wenn ich ein Beispiel f√ºr falschen C ++ - Code ben√∂tige, gehe ich zum Code- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository des</a> Notepad ++ - Texteditors.  Sein Code ist so schrecklich, dass definitiv jedes Antimuster vorhanden ist. Ich habe sogar einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> dar√ºber geschrieben.  Notepad ++ hat mich auch diesmal nicht entt√§uscht!  Mal sehen, wie es Schlaf verwendet. <br><br><h3>  Schlechtes Beispiel Nummer 1 </h3><br>  Beim Start pr√ºft Notepad ++, ob eine andere Instanz seines Prozesses bereits ausgef√ºhrt wird, sucht in diesem Fall nach seinem Fenster, sendet ihm eine Nachricht und schlie√üt sich selbst.  Um einen anderen Prozess zu erkennen, wird eine Standardmethode verwendet - der global benannte Mutex.  Der folgende Code wurde jedoch geschrieben, um nach Windows zu suchen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!isMultiInst) &amp;&amp; (!TheFirstOne)) { HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ;!hNotepad_plus &amp;&amp; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> ; ++i) { Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hNotepad_plus) { ... } ... }</code> </pre> <br><br>  Der Programmierer, der diesen Code geschrieben hat, hat versucht, das bereits gestartete Fenster von Notepad ++ zu finden, und sich sogar eine Situation vorgestellt, in der zwei Prozesse buchst√§blich gleichzeitig gestartet wurden. Der erste von ihnen hat bereits einen globalen Mutex erstellt, aber noch kein Editorfenster erstellt.  In diesem Fall wartet der zweite Prozess auf die Erstellung des Fensters ‚Äû5 Mal in 100 ms‚Äú.  Infolgedessen werden wir entweder √ºberhaupt nicht warten oder bis zu 100 ms zwischen dem Zeitpunkt der tats√§chlichen Erstellung des Fensters und dem Verlassen des Ruhezustands verlieren. <br><br>  Dies ist das erste (und eines der wichtigsten) Antimuster bei der Verwendung von Schlaf.  Wir warten nicht auf das Eintreten des Ereignisses, sondern "f√ºr ein paar Millisekunden wird es pl√∂tzlich Gl√ºck haben".  Wir warten so lange, dass wir einerseits den Benutzer nicht wirklich nerven und andererseits die Chance haben, auf das Ereignis zu warten, das wir brauchen.  Ja, der Benutzer bemerkt m√∂glicherweise keine Pause von 100 ms, wenn er die Anwendung startet.  Aber wenn eine solche Praxis, ‚Äûein wenig vom Bulldozer zu warten‚Äú, im Projekt akzeptiert und akzeptiert wird, kann dies damit enden, dass wir aus den kleinsten Gr√ºnden bei jedem Schritt warten werden.  Hier 100 ms, hier noch 50 ms und hier 200 ms - und hier verlangsamt sich unser Programm bereits "irgendwie f√ºr ein paar Sekunden". <br><br>  Dar√ºber hinaus ist es einfach √§sthetisch unangenehm, Code zu sehen, der lange l√§uft und schnell funktionieren kann.  In diesem speziellen Fall k√∂nnte man die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SetWindowsHookEx-</a> Funktion verwenden, um das Ereignis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HSHELL_WINDOWCREATED zu</a> abonnieren - und sofort eine Benachrichtigung √ºber die Fenstererstellung erhalten.  Ja, der Code wird etwas komplizierter, aber buchst√§blich 3-4 Zeilen.  Und wir gewinnen bis zu 100 ms!  Und am wichtigsten ist, dass wir die Funktionen der bedingungslosen Erwartung nicht mehr verwenden, wenn die Erwartung nicht unbedingt ist. <br><br><h3>  Schlechtes Beispiel Nummer 2 </h3><br><pre> <code class="cpp hljs">HANDLE hThread = ::CreateThread(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, threadTextTroller, &amp;trollerParams, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sleepTime = <span class="hljs-number"><span class="hljs-number">1000</span></span> / x * y; ::Sleep(sleepTime);</code> </pre> <br>  Ich habe nicht wirklich verstanden, was genau und wie lange dieser Code in Notepad ++ gewartet hat, aber ich habe oft das allgemeine Antipattern "Stream starten und warten" gesehen.  Die Leute erwarten verschiedene Dinge: den Beginn eines anderen Streams, den Empfang einiger Daten von ihm, das Ende seiner Arbeit.  Zwei Dinge sind hier sofort schlecht: <br><br><ol><li>  Multithread-Programmierung ist erforderlich, um etwas Multithread-Programm zu erstellen.  Das hei√üt,  Beim Start des zweiten Threads wird davon ausgegangen, dass wir im ersten Thread weiterhin etwas tun werden. Zu diesem Zeitpunkt wird der zweite Thread andere Arbeiten ausf√ºhren, und der erste, der seine Arbeit beendet hat (und m√∂glicherweise etwas l√§nger gewartet hat), wird sein Ergebnis erhalten und es irgendwie verwenden.  Wenn wir sofort nach dem Start des zweiten Threads anfangen zu "schlafen" - warum wird es √ºberhaupt ben√∂tigt? </li><li>  Es ist notwendig, richtig zu erwarten.  F√ºr die richtige Erwartung gibt es bew√§hrte Methoden: die Verwendung von Ereignissen, Wartefunktionen und R√ºckrufaufrufen.  Wenn wir darauf warten, dass der Code im zweiten Thread funktioniert, richten Sie hierf√ºr ein Ereignis ein und signalisieren Sie es im zweiten Thread.  Wenn wir darauf warten, dass der zweite Thread funktioniert - in C ++ gibt es eine wunderbare Thread-Klasse und ihre Join-Methode (oder auch plattformspezifische Methoden wie WaitForSingleObject und HANDLE unter Windows).  Es ist einfach dumm, ‚Äûeinige Millisekunden‚Äú darauf zu warten, dass die Arbeit in einem anderen Thread abgeschlossen ist, denn wenn wir kein Echtzeit-Betriebssystem haben, gibt Ihnen niemand eine Garantie daf√ºr, wie lange dieser zweite Thread startet oder ein Stadium seiner Arbeit erreicht. </li></ol><br><h3>  Schlechtes Beispiel Nummer 3 </h3><br>  Hier sehen wir einen Hintergrund-Thread, der schl√§ft und auf einige Ereignisse wartet. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CReadChangesServer</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (m_nOutstandingRequests || !m_bTerminate) { ::SleepEx(INFINITE, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestTermination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_bTerminate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ... } ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_bTerminate; };</code> </pre><br>  Ich muss zugeben, dass hier nicht Sleep verwendet wird, sondern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SleepEx</a> , das intelligenter ist und das Warten auf bestimmte Ereignisse (z. B. den Abschluss asynchroner Vorg√§nge) unterbrechen kann.  Das hilft aber √ºberhaupt nicht!  Tatsache ist, dass die while-Schleife (! M_bTerminate) das Recht hat, endlos zu arbeiten. Dabei wird die von einem anderen Thread aufgerufene RequestTermination () -Methode ignoriert und die Variable m_bTerminate auf true zur√ºckgesetzt.  Ich habe in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel</a> √ºber die Ursachen und Folgen davon geschrieben.  Um dies zu vermeiden, sollten Sie etwas verwenden, das garantiert korrekt zwischen Threads funktioniert: Atomic, Event oder √§hnliches. <br><br>  Ja, formal ist SleepEx nicht f√ºr das Problem verantwortlich, die √ºbliche boolesche Variable zum Synchronisieren von Threads zu verwenden. Dies ist ein separater Fehler einer anderen Klasse.  Aber warum wurde es in diesem Code m√∂glich?  Denn zuerst dachte der Programmierer: ‚ÄûDu musst hier schlafen‚Äú und dachte dann dar√ºber nach, wie lange und unter welchen Bedingungen er damit aufh√∂ren soll.  Und im richtigen Szenario sollte er nicht einmal einen ersten Gedanken haben.  Der Gedanke ‚Äûm√ºsste auf ein Ereignis warten‚Äú sollte in meinem Kopf aufgetaucht sein - und von nun an h√§tte der Gedanke darauf hingearbeitet, den richtigen Mechanismus f√ºr die Synchronisierung von Daten zwischen Threads auszuw√§hlen, der sowohl die boolesche Variable als auch die Verwendung von SleepEx ausschlie√üen w√ºrde. <br><br><h3>  Schlechtes Beispiel Nummer 4 </h3><br>  In diesem Beispiel sehen wir uns die Funktion backupDocument an, die als "automatische Speicherung" fungiert und bei einem unerwarteten Absturz des Editors hilfreich ist.  Standardm√§√üig schl√§ft sie 7 Sekunden lang und gibt dann den Befehl zum Speichern der √Ñnderungen (falls vorhanden). <br><br><pre> <code class="cpp hljs">DWORD WINAPI Notepad_plus::backupDocument(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-comment"><span class="hljs-comment">/*param*/</span></span>) { ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isSnapshotMode) { ... ::Sleep(DWORD(timer)); ... ::PostMessage(Notepad_plus_Window::gNppHWND, NPPM_INTERNAL_SAVEBACKUP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; }</code> </pre> <br>  Das Intervall kann ge√§ndert werden, dies ist jedoch nicht das Problem.  Jedes Intervall ist gleichzeitig zu lang und zu kurz.  Wenn wir einen Buchstaben pro Minute eingeben, macht es keinen Sinn, nur 7 Sekunden zu schlafen.  Wenn wir 10 Megabyte Text von irgendwoher kopieren und einf√ºgen, m√ºssen wir danach keine weiteren 7 Sekunden warten. Es ist gro√ü genug, um die Sicherung sofort zu starten (pl√∂tzlich schneiden wir es von irgendwoher aus und es ist dort weg und der Editor st√ºrzt nach einer Sekunde ab). <br><br>  Das hei√üt,  Mit einfacher Erwartung ersetzen wir hier den fehlenden intelligenteren Algorithmus. <br><br><h3>  Schlechtes Beispiel Nummer 5 </h3><br>  Notepad ++ kann "Text eingeben" - d. H.  Emulieren Sie die Eingabe von menschlichem Text, indem Sie zwischen dem Einf√ºgen von Buchstaben eine Pause einlegen.  Es scheint als "Osterei" geschrieben zu sein, aber Sie k√∂nnen sich eine funktionierende Anwendung dieser Funktion <s>einfallen lassen</s> ( <s>Upwork t√§uschen, ja</s> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pauseTimeArray[nbPauseTime] = {<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">600</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxRange = <span class="hljs-number"><span class="hljs-number">200</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ranNum = getRandomNumber(maxRange); ::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]); ::SendMessage(pCurrentView-&gt;getHSelf(), SCI_DELETEBACK, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Das Problem hierbei ist, dass der Code eine Vorstellung von einer Art ‚Äûdurchschnittlicher Person‚Äú hat, die zwischen jeder gedr√ºckten Taste f√ºr 400-800 ms pausiert.  Ok, vielleicht ist es "durchschnittlich" und normal.  Aber wei√üt du, wenn das Programm, das ich benutze, einige Pausen in meiner Arbeit macht, nur weil sie sch√∂n und f√ºr sie geeignet erscheinen - das bedeutet √ºberhaupt nicht, dass ich ihre Meinung teile.  Ich m√∂chte die Dauer der Pausendaten anpassen k√∂nnen.  Und wenn dies im Fall von Notepad ++ nicht sehr kritisch ist, stie√ü ich in anderen Programmen manchmal auf Einstellungen wie ‚ÄûDaten aktualisieren: oft, normalerweise, selten‚Äú, wobei ‚Äûoft‚Äú f√ºr mich oft nicht genug und ‚Äûselten‚Äú nicht genug war selten.  Ja, und "normal" war nicht normal.  Diese Funktionalit√§t sollte es dem Benutzer erm√∂glichen, die Anzahl der Millisekunden, die er warten m√∂chte, bis die gew√ºnschte Aktion abgeschlossen ist, genau anzugeben.  Mit der obligatorischen Option zur Eingabe von "0".  Dar√ºber hinaus sollte 0 in diesem Fall nicht einmal als Argument an die Sleep-Funktion √ºbergeben werden, sondern einfach ihren Aufruf ausschlie√üen (Sleep (0) kehrt nicht sofort zur√ºck, sondern gibt den verbleibenden Teil des vom Scheduler angegebenen Zeitfensters an einen anderen Thread weiter). <br><br><h2>  Schlussfolgerungen </h2><br>  Mit Hilfe des Schlafes ist es m√∂glich und notwendig, eine Erwartung zu erf√ºllen, wenn es sich genau um eine bedingungslos zugewiesene Erwartung f√ºr einen bestimmten Zeitraum handelt, und es gibt eine logische Erkl√§rung daf√ºr, warum dies so ist: ‚ÄûNach der Prozesstechnologie‚Äú, ‚ÄûZeit wird nach dieser Formel berechnet‚Äú, ‚Äûso viel warten sagte der Kunde. "  Das Warten auf bestimmte Ereignisse oder das Synchronisieren von Threads sollte nicht mit der Sleep-Funktion implementiert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427843/">https://habr.com/ru/post/de427843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427829/index.html">Supervising oder Outsourcing? Das ist die Frage</a></li>
<li><a href="../de427833/index.html">Bericht der Joker-Konferenz 2018</a></li>
<li><a href="../de427837/index.html">Die ersten Tage im Entwicklungsteam - so wie es bei uns passiert</a></li>
<li><a href="../de427839/index.html">Benutzerautorisierung in Django durch GSSAPI und Delegierung von Benutzerrechten an den Server</a></li>
<li><a href="../de427841/index.html">Magic Leap Scam</a></li>
<li><a href="../de427845/index.html">Wie man eine Million Sterne in ein iPhone passt</a></li>
<li><a href="../de427847/index.html">Neugier und Aufschub beim maschinellen Lernen</a></li>
<li><a href="../de427849/index.html">Gerade mit TM. v3.0</a></li>
<li><a href="../de427853/index.html">Reflexionen √ºber TDD. Warum diese Methode nicht allgemein anerkannt ist</a></li>
<li><a href="../de427855/index.html">MOSDROID-Mitaps in FunCorp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>