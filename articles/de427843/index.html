<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋ 💸 👨‍👧 Wie man richtig und falsch schläft 🤪 🤹🏻 🏇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit lief ein guter Artikel über den schrecklichen Leistungszustand moderner Software ( Original in Englisch , Übersetzung in H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man richtig und falsch schläft</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/427843/">  Vor nicht allzu langer Zeit lief ein guter Artikel über den schrecklichen Leistungszustand moderner Software ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original in Englisch</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung in Habré</a> ) an uns vorbei.  Dieser Artikel erinnerte mich an ein Antimuster des Codes, das sehr häufig ist und im Allgemeinen irgendwie funktioniert, aber hier und da zu kleinen Leistungsverlusten führt.  Weißt du, eine Kleinigkeit, die die Hände in keiner Weise erreichen werden.  Das einzige Problem ist, dass ein Dutzend dieser "Kleinigkeiten", die an verschiedenen Stellen im Code verstreut sind, zu Problemen wie "Ich habe den neuesten Intel Core i7 und das Scrollen zuckt" führen. <br><br><img src="https://habrastorage.org/webt/ri/na/rs/rinarsug4i1qt6b8kzc0i-6tcjy.png" align="right">  Ich spreche von der falschen Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sleep-</a> Funktion (der Fall kann je nach Programmiersprache und Plattform variieren).  Was ist Schlaf?  Die Dokumentation beantwortet diese Frage sehr einfach: Dies ist eine Pause in der Ausführung des aktuellen Threads für die angegebene Anzahl von Millisekunden.  Es sei auf die ästhetische Schönheit des Prototyps dieser Funktion hingewiesen: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD dwMilliseconds)</span></span></span></span>;</code> </pre> <br>  Nur ein Parameter (extrem klar), keine Fehlercodes oder Ausnahmen - es funktioniert immer.  Es gibt nur sehr wenige so nette und verständliche Funktionen! <br><br><div class="spoiler">  <b class="spoiler_title">Sie erhalten noch mehr Respekt vor dieser Funktion, wenn Sie lesen, wie sie funktioniert.</b> <div class="spoiler_text">  Die Funktion geht zum OS-Thread-Scheduler und teilt ihm mit: „Mein Thread und ich möchten die uns zugewiesene CPU-Zeit jetzt und in Zukunft für ebenso viele Millisekunden ablehnen.  Gib den Armen! "  Der Scheduler, der von dieser Großzügigkeit leicht überrascht ist, nimmt die Funktionen der Dankbarkeit im Namen des Prozessors heraus, gibt der nächsten Person die verbleibende Zeit (und es gibt immer solche) und enthält nicht den Thread, der dazu geführt hat, dass Sleep so getan hat, als würde er den Ausführungskontext für die angegebene Anzahl von Millisekunden an ihn übertragen.  Schönheit! <br></div></div><br>  Was hätte schief gehen können?  Die Tatsache, dass Programmierer diese wunderbare Funktion verwenden, ist nicht das, wofür sie gedacht ist. <br><a name="habracut"></a><br>  Und es ist für die Software-Simulation eines externen, durch einen realen Pausenprozess definierten Prozesses vorgesehen. <br><br><h3>  Richtiges Beispiel Nummer 1 </h3><br>  Wir schreiben eine "Uhr" -Anwendung, in der Sie einmal pro Sekunde eine Ziffer auf dem Bildschirm (oder die Position des Pfeils) ändern müssen.  Die Schlaffunktion ist hier perfekt geeignet: Wir haben für einen klar definierten Zeitraum (genau eine Sekunde) wirklich nichts zu tun.  Warum nicht schlafen? <br><br><h3>  Richtiges Beispiel Nummer 2 </h3><br>  Wir schreiben einen <s>Mondschein-</s> Controller <s>für eine</s> Brotmaschine.  Der Operationsalgorithmus wird von einem der Programme eingestellt und sieht ungefähr so ​​aus: <br><br><ol><li>  Gehen Sie zu Modus 1. </li><li>  20 Minuten darin arbeiten </li><li>  Gehen Sie zu Modus 2. </li><li>  10 Minuten darin arbeiten </li><li>  Ausschalten. </li></ol><br>  Auch hier ist alles klar: Wir arbeiten mit der Zeit, sie wird durch den technologischen Prozess bestimmt.  Die Verwendung von Schlaf ist akzeptabel. <br><br>  Schauen wir uns nun Beispiele für den Missbrauch des Schlafes an. <br><br>  Wenn ich ein Beispiel für falschen C ++ - Code benötige, gehe ich zum Code- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository des</a> Notepad ++ - Texteditors.  Sein Code ist so schrecklich, dass definitiv jedes Antimuster vorhanden ist. Ich habe sogar einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> darüber geschrieben.  Notepad ++ hat mich auch diesmal nicht enttäuscht!  Mal sehen, wie es Schlaf verwendet. <br><br><h3>  Schlechtes Beispiel Nummer 1 </h3><br>  Beim Start prüft Notepad ++, ob eine andere Instanz seines Prozesses bereits ausgeführt wird, sucht in diesem Fall nach seinem Fenster, sendet ihm eine Nachricht und schließt sich selbst.  Um einen anderen Prozess zu erkennen, wird eine Standardmethode verwendet - der global benannte Mutex.  Der folgende Code wurde jedoch geschrieben, um nach Windows zu suchen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!isMultiInst) &amp;&amp; (!TheFirstOne)) { HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ;!hNotepad_plus &amp;&amp; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> ; ++i) { Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hNotepad_plus) { ... } ... }</code> </pre> <br><br>  Der Programmierer, der diesen Code geschrieben hat, hat versucht, das bereits gestartete Fenster von Notepad ++ zu finden, und sich sogar eine Situation vorgestellt, in der zwei Prozesse buchstäblich gleichzeitig gestartet wurden. Der erste von ihnen hat bereits einen globalen Mutex erstellt, aber noch kein Editorfenster erstellt.  In diesem Fall wartet der zweite Prozess auf die Erstellung des Fensters „5 Mal in 100 ms“.  Infolgedessen werden wir entweder überhaupt nicht warten oder bis zu 100 ms zwischen dem Zeitpunkt der tatsächlichen Erstellung des Fensters und dem Verlassen des Ruhezustands verlieren. <br><br>  Dies ist das erste (und eines der wichtigsten) Antimuster bei der Verwendung von Schlaf.  Wir warten nicht auf das Eintreten des Ereignisses, sondern "für ein paar Millisekunden wird es plötzlich Glück haben".  Wir warten so lange, dass wir einerseits den Benutzer nicht wirklich nerven und andererseits die Chance haben, auf das Ereignis zu warten, das wir brauchen.  Ja, der Benutzer bemerkt möglicherweise keine Pause von 100 ms, wenn er die Anwendung startet.  Aber wenn eine solche Praxis, „ein wenig vom Bulldozer zu warten“, im Projekt akzeptiert und akzeptiert wird, kann dies damit enden, dass wir aus den kleinsten Gründen bei jedem Schritt warten werden.  Hier 100 ms, hier noch 50 ms und hier 200 ms - und hier verlangsamt sich unser Programm bereits "irgendwie für ein paar Sekunden". <br><br>  Darüber hinaus ist es einfach ästhetisch unangenehm, Code zu sehen, der lange läuft und schnell funktionieren kann.  In diesem speziellen Fall könnte man die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SetWindowsHookEx-</a> Funktion verwenden, um das Ereignis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HSHELL_WINDOWCREATED zu</a> abonnieren - und sofort eine Benachrichtigung über die Fenstererstellung erhalten.  Ja, der Code wird etwas komplizierter, aber buchstäblich 3-4 Zeilen.  Und wir gewinnen bis zu 100 ms!  Und am wichtigsten ist, dass wir die Funktionen der bedingungslosen Erwartung nicht mehr verwenden, wenn die Erwartung nicht unbedingt ist. <br><br><h3>  Schlechtes Beispiel Nummer 2 </h3><br><pre> <code class="cpp hljs">HANDLE hThread = ::CreateThread(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, threadTextTroller, &amp;trollerParams, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sleepTime = <span class="hljs-number"><span class="hljs-number">1000</span></span> / x * y; ::Sleep(sleepTime);</code> </pre> <br>  Ich habe nicht wirklich verstanden, was genau und wie lange dieser Code in Notepad ++ gewartet hat, aber ich habe oft das allgemeine Antipattern "Stream starten und warten" gesehen.  Die Leute erwarten verschiedene Dinge: den Beginn eines anderen Streams, den Empfang einiger Daten von ihm, das Ende seiner Arbeit.  Zwei Dinge sind hier sofort schlecht: <br><br><ol><li>  Multithread-Programmierung ist erforderlich, um etwas Multithread-Programm zu erstellen.  Das heißt,  Beim Start des zweiten Threads wird davon ausgegangen, dass wir im ersten Thread weiterhin etwas tun werden. Zu diesem Zeitpunkt wird der zweite Thread andere Arbeiten ausführen, und der erste, der seine Arbeit beendet hat (und möglicherweise etwas länger gewartet hat), wird sein Ergebnis erhalten und es irgendwie verwenden.  Wenn wir sofort nach dem Start des zweiten Threads anfangen zu "schlafen" - warum wird es überhaupt benötigt? </li><li>  Es ist notwendig, richtig zu erwarten.  Für die richtige Erwartung gibt es bewährte Methoden: die Verwendung von Ereignissen, Wartefunktionen und Rückrufaufrufen.  Wenn wir darauf warten, dass der Code im zweiten Thread funktioniert, richten Sie hierfür ein Ereignis ein und signalisieren Sie es im zweiten Thread.  Wenn wir darauf warten, dass der zweite Thread funktioniert - in C ++ gibt es eine wunderbare Thread-Klasse und ihre Join-Methode (oder auch plattformspezifische Methoden wie WaitForSingleObject und HANDLE unter Windows).  Es ist einfach dumm, „einige Millisekunden“ darauf zu warten, dass die Arbeit in einem anderen Thread abgeschlossen ist, denn wenn wir kein Echtzeit-Betriebssystem haben, gibt Ihnen niemand eine Garantie dafür, wie lange dieser zweite Thread startet oder ein Stadium seiner Arbeit erreicht. </li></ol><br><h3>  Schlechtes Beispiel Nummer 3 </h3><br>  Hier sehen wir einen Hintergrund-Thread, der schläft und auf einige Ereignisse wartet. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CReadChangesServer</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (m_nOutstandingRequests || !m_bTerminate) { ::SleepEx(INFINITE, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestTermination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_bTerminate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ... } ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_bTerminate; };</code> </pre><br>  Ich muss zugeben, dass hier nicht Sleep verwendet wird, sondern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SleepEx</a> , das intelligenter ist und das Warten auf bestimmte Ereignisse (z. B. den Abschluss asynchroner Vorgänge) unterbrechen kann.  Das hilft aber überhaupt nicht!  Tatsache ist, dass die while-Schleife (! M_bTerminate) das Recht hat, endlos zu arbeiten. Dabei wird die von einem anderen Thread aufgerufene RequestTermination () -Methode ignoriert und die Variable m_bTerminate auf true zurückgesetzt.  Ich habe in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel</a> über die Ursachen und Folgen davon geschrieben.  Um dies zu vermeiden, sollten Sie etwas verwenden, das garantiert korrekt zwischen Threads funktioniert: Atomic, Event oder ähnliches. <br><br>  Ja, formal ist SleepEx nicht für das Problem verantwortlich, die übliche boolesche Variable zum Synchronisieren von Threads zu verwenden. Dies ist ein separater Fehler einer anderen Klasse.  Aber warum wurde es in diesem Code möglich?  Denn zuerst dachte der Programmierer: „Du musst hier schlafen“ und dachte dann darüber nach, wie lange und unter welchen Bedingungen er damit aufhören soll.  Und im richtigen Szenario sollte er nicht einmal einen ersten Gedanken haben.  Der Gedanke „müsste auf ein Ereignis warten“ sollte in meinem Kopf aufgetaucht sein - und von nun an hätte der Gedanke darauf hingearbeitet, den richtigen Mechanismus für die Synchronisierung von Daten zwischen Threads auszuwählen, der sowohl die boolesche Variable als auch die Verwendung von SleepEx ausschließen würde. <br><br><h3>  Schlechtes Beispiel Nummer 4 </h3><br>  In diesem Beispiel sehen wir uns die Funktion backupDocument an, die als "automatische Speicherung" fungiert und bei einem unerwarteten Absturz des Editors hilfreich ist.  Standardmäßig schläft sie 7 Sekunden lang und gibt dann den Befehl zum Speichern der Änderungen (falls vorhanden). <br><br><pre> <code class="cpp hljs">DWORD WINAPI Notepad_plus::backupDocument(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-comment"><span class="hljs-comment">/*param*/</span></span>) { ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isSnapshotMode) { ... ::Sleep(DWORD(timer)); ... ::PostMessage(Notepad_plus_Window::gNppHWND, NPPM_INTERNAL_SAVEBACKUP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; }</code> </pre> <br>  Das Intervall kann geändert werden, dies ist jedoch nicht das Problem.  Jedes Intervall ist gleichzeitig zu lang und zu kurz.  Wenn wir einen Buchstaben pro Minute eingeben, macht es keinen Sinn, nur 7 Sekunden zu schlafen.  Wenn wir 10 Megabyte Text von irgendwoher kopieren und einfügen, müssen wir danach keine weiteren 7 Sekunden warten. Es ist groß genug, um die Sicherung sofort zu starten (plötzlich schneiden wir es von irgendwoher aus und es ist dort weg und der Editor stürzt nach einer Sekunde ab). <br><br>  Das heißt,  Mit einfacher Erwartung ersetzen wir hier den fehlenden intelligenteren Algorithmus. <br><br><h3>  Schlechtes Beispiel Nummer 5 </h3><br>  Notepad ++ kann "Text eingeben" - d. H.  Emulieren Sie die Eingabe von menschlichem Text, indem Sie zwischen dem Einfügen von Buchstaben eine Pause einlegen.  Es scheint als "Osterei" geschrieben zu sein, aber Sie können sich eine funktionierende Anwendung dieser Funktion <s>einfallen lassen</s> ( <s>Upwork täuschen, ja</s> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pauseTimeArray[nbPauseTime] = {<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">600</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxRange = <span class="hljs-number"><span class="hljs-number">200</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ranNum = getRandomNumber(maxRange); ::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]); ::SendMessage(pCurrentView-&gt;getHSelf(), SCI_DELETEBACK, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Das Problem hierbei ist, dass der Code eine Vorstellung von einer Art „durchschnittlicher Person“ hat, die zwischen jeder gedrückten Taste für 400-800 ms pausiert.  Ok, vielleicht ist es "durchschnittlich" und normal.  Aber weißt du, wenn das Programm, das ich benutze, einige Pausen in meiner Arbeit macht, nur weil sie schön und für sie geeignet erscheinen - das bedeutet überhaupt nicht, dass ich ihre Meinung teile.  Ich möchte die Dauer der Pausendaten anpassen können.  Und wenn dies im Fall von Notepad ++ nicht sehr kritisch ist, stieß ich in anderen Programmen manchmal auf Einstellungen wie „Daten aktualisieren: oft, normalerweise, selten“, wobei „oft“ für mich oft nicht genug und „selten“ nicht genug war selten.  Ja, und "normal" war nicht normal.  Diese Funktionalität sollte es dem Benutzer ermöglichen, die Anzahl der Millisekunden, die er warten möchte, bis die gewünschte Aktion abgeschlossen ist, genau anzugeben.  Mit der obligatorischen Option zur Eingabe von "0".  Darüber hinaus sollte 0 in diesem Fall nicht einmal als Argument an die Sleep-Funktion übergeben werden, sondern einfach ihren Aufruf ausschließen (Sleep (0) kehrt nicht sofort zurück, sondern gibt den verbleibenden Teil des vom Scheduler angegebenen Zeitfensters an einen anderen Thread weiter). <br><br><h2>  Schlussfolgerungen </h2><br>  Mit Hilfe des Schlafes ist es möglich und notwendig, eine Erwartung zu erfüllen, wenn es sich genau um eine bedingungslos zugewiesene Erwartung für einen bestimmten Zeitraum handelt, und es gibt eine logische Erklärung dafür, warum dies so ist: „Nach der Prozesstechnologie“, „Zeit wird nach dieser Formel berechnet“, „so viel warten sagte der Kunde. "  Das Warten auf bestimmte Ereignisse oder das Synchronisieren von Threads sollte nicht mit der Sleep-Funktion implementiert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427843/">https://habr.com/ru/post/de427843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427829/index.html">Supervising oder Outsourcing? Das ist die Frage</a></li>
<li><a href="../de427833/index.html">Bericht der Joker-Konferenz 2018</a></li>
<li><a href="../de427837/index.html">Die ersten Tage im Entwicklungsteam - so wie es bei uns passiert</a></li>
<li><a href="../de427839/index.html">Benutzerautorisierung in Django durch GSSAPI und Delegierung von Benutzerrechten an den Server</a></li>
<li><a href="../de427841/index.html">Magic Leap Scam</a></li>
<li><a href="../de427845/index.html">Wie man eine Million Sterne in ein iPhone passt</a></li>
<li><a href="../de427847/index.html">Neugier und Aufschub beim maschinellen Lernen</a></li>
<li><a href="../de427849/index.html">Gerade mit TM. v3.0</a></li>
<li><a href="../de427853/index.html">Reflexionen über TDD. Warum diese Methode nicht allgemein anerkannt ist</a></li>
<li><a href="../de427855/index.html">MOSDROID-Mitaps in FunCorp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>