<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíì üè¨ üë©üèæ‚Äçüè≠ Klasifikasi sejumlah besar data pada Apache Spark menggunakan model pembelajaran mesin sewenang-wenang ‚úåüèø üìà ü§∞üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 2: Solusi 
 Halo lagi! Hari ini saya akan melanjutkan kisah saya tentang bagaimana kita mengklasifikasikan sejumlah besar data di Apache Spark ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klasifikasi sejumlah besar data pada Apache Spark menggunakan model pembelajaran mesin sewenang-wenang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2>  Bagian 2: Solusi </h2><br>  Halo lagi!  Hari ini saya akan melanjutkan kisah saya tentang bagaimana kita mengklasifikasikan sejumlah besar data di Apache Spark menggunakan model pembelajaran mesin sewenang-wenang.  Di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama artikel,</a> kami memeriksa pernyataan masalah itu sendiri, serta masalah utama yang muncul ketika mengatur interaksi antara cluster di mana data awal disimpan dan diproses, dan layanan klasifikasi eksternal.  Pada bagian kedua, kami akan mempertimbangkan salah satu opsi untuk memecahkan masalah ini menggunakan pendekatan Reactive Streams dan implementasinya menggunakan pustaka akka-stream. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3>  Konsep Aliran Reaktif </h3><br>  Untuk memecahkan masalah yang dijelaskan di bagian pertama, Anda bisa menggunakan pendekatan, yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reactive Streams</a> .  Hal ini memungkinkan Anda untuk mengontrol proses mentransfer aliran data antara tahapan pemrosesan, beroperasi pada kecepatan yang berbeda dan secara independen dari satu sama lain tanpa perlu buffering.  Jika salah satu tahapan pemrosesan lebih lambat dari yang sebelumnya, perlu memberi sinyal pada tahapan yang lebih cepat tentang berapa banyak input data yang siap diproses saat ini.  Interaksi ini disebut tekanan balik.  Terdiri dari fakta bahwa tahap yang lebih cepat memproses elemen sebanyak yang diperlukan untuk tahap yang lebih lambat, dan tidak lebih, dan kemudian membebaskan sumber daya komputasi. <br><br>  Secara umum, Aliran Reaktif adalah spesifikasi untuk menerapkan template <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penerbit-Pelanggan</a> .  Spesifikasi ini menetapkan satu set empat antarmuka (Penerbit, Pelanggan, Pemroses, dan Berlangganan) dan kontrak untuk metode mereka. <br><br>  Mari kita pertimbangkan antarmuka ini lebih detail: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Ada dua sisi dari model Penerbit-Pelanggan: mentransmisikan dan menerima.  Saat menerapkan Aliran Reaktif, kelas yang mengimplementasikan antarmuka Penerbit bertanggung jawab untuk transfer data, dan Pelanggan bertanggung jawab untuk menerima.  Untuk menjalin komunikasi di antara mereka, Pelanggan harus terdaftar dengan Penerbit dengan memanggil metode berlangganannya.  Menurut spesifikasi, setelah mendaftar Pelanggan, Penerbit harus memanggil metode dalam urutan berikut: <br><br><ol><li>  di Berlangganan.  Metode ini dipanggil segera setelah mendaftar Pelanggan dengan Penerbit.  Sebagai parameter, objek Langganan diteruskan ke sana melalui mana Pelanggan akan meminta data dari Penerbit.  Objek ini harus disimpan dan dipanggil hanya dalam konteks Pelanggan ini. </li><li>  Setelah Pelanggan meminta data dari Penerbit dengan memanggil metode permintaan pada objek Langganan yang sesuai, Penerbit dapat memanggil metode Pelanggan diNext, melewati elemen berikutnya. </li><li>  Pelanggan kemudian dapat secara berkala memanggil metode permintaan pada Langganan, tetapi Penerbit tidak dapat memanggil metode onNext lebih dari total yang diminta melalui metode permintaan. </li><li>  Jika aliran data terbatas, setelah melewati semua elemen melalui metode onNext, Penerbit harus memanggil metode onComplete. </li><li>  Jika kesalahan terjadi di Publisher dan pemrosesan lebih lanjut dari elemen tidak dimungkinkan, itu harus memanggil metode onError </li><li>  Setelah memanggil metode onComplete atau onError, interaksi lebih lanjut Penerbit dengan Pelanggan harus dikecualikan. </li></ol><br>  Metode panggilan dapat dianggap sebagai mengirim sinyal antara Penerbit dan Pelanggan.  Pelanggan memberi sinyal kepada Penerbit berapa banyak elemen yang siap diproses, dan Penerbit, pada gilirannya, memberi sinyal kepadanya bahwa ada elemen berikutnya, atau tidak ada elemen lagi, atau beberapa kesalahan telah terjadi. <br><br>  Untuk mengecualikan pengaruh lain dari Penerbit dan Pelanggan satu sama lain, panggilan ke semua metode yang menerapkan antarmuka Reactive Streams harus non-pemblokiran.  Dalam hal ini, interaksi di antara mereka akan sepenuhnya tidak sinkron. <br><br>  Rincian lebih lanjut tentang spesifikasi untuk antarmuka Reactive Streams dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Dengan demikian, dengan menautkan iterator asli dan yang dihasilkan dengan mengonversinya masing-masing ke Publisher dan Pelanggan, kita dapat memecahkan masalah yang diidentifikasi di bagian sebelumnya artikel.  Masalah buffer overflow antara tahapan diselesaikan dengan meminta sejumlah elemen oleh Pelanggan.  Masalah penyelesaian yang berhasil atau tidak berhasil diselesaikan dengan mengirimkan sinyal ke Pelanggan melalui metode onComplete atau onError, masing-masing.  Penerbit bertanggung jawab untuk mengirimkan sinyal-sinyal ini, yang dalam kasus kami harus mengontrol berapa banyak permintaan HTTP yang dikirim dan berapa banyak dari mereka yang menerima tanggapan.  Setelah menerima respons terakhir dan memproses semua hasil yang datang di dalamnya, ia akan mengirim sinyal onComplete.  Jika salah satu permintaan gagal, itu harus mengirim sinyal onError, dan berhenti mengirim elemen lebih lanjut ke Pelanggan, serta mengurangi elemen dari iterator asli. <br><br>  Iterator yang dihasilkan harus diimplementasikan sebagai Pelanggan.  Dalam hal ini, kita tidak dapat melakukannya tanpa buffer di mana elemen akan ditulis ketika metode onNext dipanggil dari antarmuka Pelanggan, dan dikurangi menggunakan metode hasNext dan selanjutnya dari antarmuka Iterator.  Sebagai implementasi buffer, Anda dapat menggunakan antrian pemblokiran, misalnya, LinkedBlockedQueue. <br><br>  Pembaca yang penuh perhatian akan segera mengajukan pertanyaan: mengapa antrian pemblokiran, karena menurut spesifikasi Reactive Streams, implementasi semua metode harus non-pemblokiran?  Tapi ini baik-baik saja di sini: karena kami meminta Publisher untuk elemen yang ditentukan secara ketat, metode onNext akan dipanggil tidak lebih dari jumlah ini kali, dan antrian selalu dapat menambahkan elemen baru tanpa memblokir. <br><br>  Di sisi lain, pemblokiran dapat terjadi ketika metode hasNext dipanggil jika ada antrian kosong.  Namun, ini tidak apa-apa: metode hasNext bukan bagian dari kontrak antarmuka Pelanggan, itu didefinisikan dalam antarmuka Iterator, yang, seperti yang kami jelaskan sebelumnya, adalah struktur data pemblokiran.  Saat memanggil metode berikutnya, kami mengurangi elemen berikutnya dari antrian, dan ketika ukurannya menjadi kurang dari ambang tertentu, kami akan perlu meminta bagian elemen berikutnya melalui panggilan ke metode permintaan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>Gambar 7. Interaksi asinkron dengan layanan eksternal menggunakan pendekatan Reactive Streams</i> <br><br>  Tentu saja, dalam hal ini kami tidak akan sepenuhnya menghilangkan pemblokiran panggilan.  Ini disebabkan oleh ketidakcocokan paradigma antara aliran Reaktif, yang menganggap interaksi sepenuhnya tidak sinkron, dan iterator, yang harus memanggil trueN atau false ketika memanggil metode hasNext.  Namun, tidak seperti interaksi sinkron dengan layanan eksternal, waktu henti akibat penguncian dapat dikurangi secara signifikan dengan meningkatkan beban keseluruhan inti prosesor. <br><br>  Akan lebih mudah jika pengembang Apache Spark di versi yang akan datang menerapkan analog dari metode mapPartitions, yang berfungsi dengan Publisher dan Subscriber.  Ini akan memungkinkan untuk interaksi yang sepenuhnya tidak sinkron, sehingga menghilangkan kemungkinan memblokir thread. <br><br><h3>  Akka-stream dan akka-http sebagai implementasi dari spesifikasi Reactive Streams </h3><br>  Saat ini, sudah ada lebih dari selusin implementasi spesifikasi Reactive Streams.  Salah satu implementasi tersebut adalah modul akka-stream dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akka</a> .  Dalam dunia JVM akka telah memantapkan dirinya sebagai salah satu cara paling efektif untuk menulis sistem paralel dan terdistribusi.  Ini dicapai karena fakta bahwa prinsip dasar yang ditetapkan dalam fondasinya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model aktor</a> , yang memungkinkan Anda untuk menulis aplikasi yang sangat kompetitif tanpa kontrol langsung atas utas dan kumpulannya. <br><br>  Banyak literatur telah ditulis tentang implementasi konsep aktor dalam akka, jadi kami tidak akan berhenti di sini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs resmi akka</a> adalah sumber informasi yang sangat bagus, saya juga merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akka dalam aksi</a> ).  Di sini kita akan melihat lebih dekat pada sisi implementasi teknologi di bawah JVM. <br><br>  Secara umum, aktor tidak ada dengan sendirinya, tetapi membentuk sistem hierarkis.  Untuk membuat sistem aktor, Anda perlu mengalokasikan sumber daya untuk itu, jadi langkah pertama ketika bekerja dengan akka adalah membuat turunan dari objek ActorSystem.  Ketika ActorSystem dimulai, kumpulan utas terpisah dibuat, disebut dispatcher, di mana semua kode yang didefinisikan dalam aktor dieksekusi.  Biasanya, utas tunggal mengeksekusi kode beberapa aktor, namun, jika perlu, Anda dapat mengonfigurasi dispatcher terpisah untuk sekelompok aktor tertentu (misalnya, untuk aktor yang berinteraksi langsung dengan API pemblokiran). <br><br>  Salah satu tugas yang paling umum diselesaikan dengan menggunakan aktor adalah pemrosesan aliran data secara berurutan.  Sebelumnya, untuk ini, perlu secara manual membangun rantai aktor dan memastikan bahwa tidak ada hambatan di antara mereka (misalnya, jika satu aktor memproses pesan lebih cepat dari yang berikutnya, maka ia mungkin memiliki limpahan antrian pesan masuk, yang mengarah ke kesalahan OutOfMemoryError). <br><br>  Mulai dari versi 2.4, modul akka-stream ditambahkan ke akka, yang memungkinkan Anda untuk secara deklaratif mendefinisikan proses pemrosesan data, dan kemudian membuat aktor yang diperlukan untuk pelaksanaannya.  Akka-stream juga menerapkan prinsip tekanan balik, yang menghilangkan kemungkinan meluapnya antrian pesan masuk untuk semua aktor yang terlibat dalam pemrosesan. <br><br>  Elemen utama untuk mendefinisikan skema pemrosesan aliran data dalam akka-stream adalah Source, Flow dan Sink.  Dengan menggabungkan mereka satu sama lain, kita mendapatkan Runnable Graph.  Untuk memulai proses pemrosesan, materializer digunakan, yang menciptakan aktor yang bekerja sesuai dengan grafik yang ditentukan oleh kami (antarmuka Materializer dan implementasinya ActorMaterializer). <br><br>  Mari kita bahas tahapan Source, Flow, dan Sink lebih detail.  Sumber mendefinisikan sumber data.  Akka-stream mendukung lebih dari selusin cara berbeda untuk membuat sumber, termasuk dari iterator: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br>  Sumber juga dapat diperoleh dengan mengonversi sumber yang ada: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br>  Jika transformasi adalah operasi nontrivial, itu dapat direpresentasikan sebagai entitas Flow.  Akka-stream mendukung banyak cara berbeda untuk membuat Flow.  Cara termudah adalah membuat dari fungsi: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br>  Dengan menggabungkan Sumber dan Aliran, kami mendapatkan Sumber baru. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br>  Sink digunakan sebagai tahap akhir dari pemrosesan data.  Seperti dalam kasus Source, akka-stream menyediakan lebih dari selusin opsi Sink yang berbeda, misalnya, Sink.foreach melakukan operasi tertentu untuk setiap elemen, Sink.seq mengumpulkan semua elemen dalam koleksi, dll. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br>  Sumber, Aliran, dan Sink masing-masing diparameterisasi oleh tipe input dan / atau elemen output.  Selain itu, setiap tahap pemrosesan mungkin memiliki beberapa hasil pekerjaannya.  Untuk ini, Sumber, Aliran dan Sink juga parameter dengan tipe tambahan yang menentukan hasil operasi.  Tipe ini disebut tipe nilai terwujud.  Jika operasi tidak menyiratkan adanya hasil tambahan dari pekerjaannya, misalnya, ketika kita mendefinisikan Flow melalui fungsi, maka tipe NotUsed digunakan sebagai nilai material. <br><br>  Menggabungkan Sumber, Aliran, dan Sink yang diperlukan, kita mendapatkan RunnableGraph.  Ini diparameterisasi oleh satu jenis, yang menentukan jenis nilai yang diperoleh sebagai hasil dari eksekusi grafik ini.  Jika perlu, saat menggabungkan tahapan, Anda dapat menentukan hasil tahapan mana yang akan menjadi hasil dari seluruh grafik operasi.  Secara default, hasil dari tahap Sumber diambil: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br>  Namun, jika hasil dari tahap Sink lebih penting bagi kami, maka kami harus secara eksplisit menunjukkan ini: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br>  Setelah kami menentukan grafik operasi, kami harus menjalankannya.  Untuk melakukan ini, runnableGraph perlu memanggil metode run.  Sebagai parameter, metode ini mengambil objek ActorMaterializer (yang juga bisa dalam lingkup implisit), yang bertanggung jawab untuk membuat aktor yang akan melakukan operasi.  Biasanya, ActorMaterializer dibuat segera setelah pembuatan ActorSystem, melekat pada siklus hidupnya, dan menggunakannya untuk membuat aktor.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(‚Äúsystem name‚Äù) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br>  Dalam kasus kombinasi sederhana, Anda dapat melakukannya tanpa membuat RunnableGraph yang terpisah, tetapi cukup sambungkan Source to Sink dan mulai dengan memanggil metode runWith pada Source.  Metode ini juga mengasumsikan bahwa objek ActorMaterializer hadir dalam ruang lingkup implisit.  Selain itu, dalam hal ini, nilai material yang ditentukan dalam Sink akan digunakan.  Misalnya, menggunakan kode berikut, kami dapat mengonversi Sumber ke Penerbit dari spesifikasi Aliran Reaktif: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  Jadi, sekarang kami telah menunjukkan bagaimana Anda bisa mendapatkan Reactive Streams Publisher dengan membuat Sumber dari iterator sumber dan melakukan beberapa transformasi pada elemen-elemennya.  Sekarang kita dapat mengaitkannya dengan Pelanggan yang memasok data ke iterator yang dihasilkan.  Masih mempertimbangkan pertanyaan terakhir: bagaimana mengatur interaksi HTTP dengan layanan eksternal. <br><br>  Struktur akka termasuk modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://doc.akka.io/docs/akka-">akka-http</a> , yang memungkinkan Anda untuk mengatur komunikasi non-blocking asinkron melalui HTTP.  Selain itu, modul ini dibangun berdasarkan aliran akka, yang memungkinkan Anda untuk menambahkan interaksi HTTP sebagai langkah tambahan dalam grafik operasi pemrosesan aliran data. <br><br>  Untuk terhubung ke layanan eksternal, akka-http menyediakan tiga antarmuka yang berbeda. <br><br><ol><li>  Request-Level API - adalah opsi paling sederhana untuk kasus satu permintaan ke mesin arbitrer.  Pada tingkat ini, koneksi HTTP dikelola sepenuhnya secara otomatis, dan dalam setiap permintaan, perlu mengirimkan alamat lengkap mesin yang menjadi tujuan permintaan tersebut. </li><li>  Host-Level API - cocok ketika kita tahu port mana di mesin mana yang akan kita akses.  Dalam hal ini, akka-http mengendalikan kumpulan koneksi HTTP, dan dalam permintaan cukup untuk menentukan jalur relatif ke sumber daya yang diminta. </li><li>  Connection-Level API - memungkinkan Anda untuk mendapatkan kontrol penuh atas pengelolaan koneksi HTTP, yaitu membuka, menutup, dan mendistribusikan permintaan di seluruh koneksi. </li></ol><br>  Dalam kasus kami, alamat layanan klasifikasi diketahui oleh kami terlebih dahulu, oleh karena itu, perlu untuk mengatur interaksi HTTP hanya dengan mesin khusus ini.  Oleh karena itu, API Tingkat Host adalah yang terbaik bagi kami.  Sekarang, mari kita lihat bagaimana kumpulan koneksi HTTP dibuat saat menggunakannya: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br>  Saat memanggil Http (). CachedHostConnectionPool [T] (hostAddress, portNumber) di ActorSystem, yang dalam lingkup implisit, sumber daya dialokasikan untuk membuat kumpulan koneksi, tetapi koneksi itu sendiri tidak dibuat.  Sebagai hasil dari panggilan ini, Flow dikembalikan, yang menerima sepasang permintaan HTTP dan beberapa objek identifikasi Id sebagai input.  Objek identifikasi diperlukan untuk mencocokkan permintaan dengan respons yang sesuai karena fakta bahwa panggilan HTTP di akka-http adalah operasi asinkron, dan urutan penerimaan respons tidak harus sesuai dengan urutan permintaan pengiriman.  Oleh karena itu, pada Arus keluaran memberikan beberapa hasil permintaan dan objek identifikasi yang sesuai. <br><br>  Secara langsung, koneksi HTTP dibuat ketika grafik (termasuk Flow ini) diluncurkan (terwujud).  Akka-http diimplementasikan sedemikian rupa sehingga tidak peduli berapa kali grafik yang mengandung httpFlow telah terwujud, dalam ActorSystem yang sama akan selalu ada satu kumpulan koneksi HTTP yang akan digunakan oleh semua materialisasi.  Ini memungkinkan Anda untuk mengontrol penggunaan sumber daya jaringan dengan lebih baik dan menghindari kelebihannya. <br><br>  Dengan demikian, siklus hidup kumpulan koneksi HTTP terkait dengan ActorSystem.  Seperti yang telah disebutkan, siklus hidup thread pool juga melekat padanya, di mana operasi yang didefinisikan dalam aktor dilakukan (atau dalam kasus kami, didefinisikan sebagai tahapan akka-stream dan akka-http).  Oleh karena itu, untuk mencapai efisiensi maksimum, kita harus menggunakan kembali satu instance ActorSystem dalam proses JVM yang sama. <br><br><h3>  Menyatukan semua ini: contoh penerapan interaksi dengan layanan klasifikasi </h3><br>  Jadi, sekarang kita dapat beralih ke proses mengklasifikasikan volume besar data terdistribusi di Apache Spark menggunakan interaksi asinkron dengan layanan eksternal.  Skema umum dari interaksi ini telah ditunjukkan pada Gambar 7. <br><br>  Misalkan kita memiliki beberapa Dataset [Fitur] awal yang didefinisikan.  Menerapkan operasi mapPartitions untuk itu, kita harus mendapatkan Dataset, di mana setiap id dari set sumber dicap dengan nilai tertentu yang diperoleh sebagai hasil klasifikasi (Dataset [Skor]).  Untuk mengatur pemrosesan tidak sinkron pada pelaksana, kita harus membungkus sumber dan menghasilkan iterator di Publisher dan Pelanggan, masing-masing, dari spesifikasi aliran Reaktif dan menghubungkannya bersama. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(‚ÄúscoreService. batchesRequestCount‚Äù)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br>  Dalam implementasi ini, diperhitungkan bahwa layanan klasifikasi untuk satu panggilan dapat memproses sekelompok vektor fitur segera, oleh karena itu, hasil klasifikasi setelah panggilan itu juga akan segera tersedia untuk seluruh grup.  Karena itu, sebagai tipe parameter untuk Penerbit, kami tidak hanya Skor, seperti yang Anda harapkan, tetapi [Skor] terteratur.  Jadi, kami mengirim hasil klasifikasi untuk grup ini ke iterator yang dihasilkan (yang juga merupakan Pelanggan) dengan satu panggilan ke metode onNext.  Ini jauh lebih efisien daripada memanggil onNext untuk setiap elemen.  Sekarang kita akan menganalisis kode ini lebih terinci. <br><br><ol><li>  Kami menentukan struktur data input dan output.  Sebagai input, kita akan memiliki banyak pengidentifikasi id dengan vektor fitur, dan sebagai output, kita akan memiliki banyak pengidentifikasi dengan nilai numerik yang diperoleh sebagai hasil klasifikasi. </li><li>  Kami menentukan jumlah grup yang akan diminta oleh Pelanggan dari Penerbit sekaligus.  Karena diasumsikan bahwa nilai-nilai ini akan terletak di buffer dan menunggu sampai mereka dibaca dari iterator yang dihasilkan, nilai ini tergantung pada jumlah memori yang dialokasikan untuk pelaksana. </li><li>  Buat Penerbit dari sumber iterator.  Dia akan bertanggung jawab untuk berinteraksi dengan layanan klasifikasi.  Fungsi createPublisher dibahas di bawah ini. </li><li>  Buat Pelanggan, yang akan menjadi iterator yang dihasilkan.  Kode kelas IteratorSubscriber juga diberikan di bawah ini. </li><li>  Mendaftarkan Pelanggan ke Penerbit. </li><li>  Kembalikan IteratorSubscriber sebagai hasil dari operasi mapPartitions. </li></ol><br>  Sekarang pertimbangkan penerapan fungsi createPublisher. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br>      ,    akka  ActorSystem,        .  ,        Spark ,          .   Spark    JVM , ,        ,     ActorSystem    ActorMatrializer  httpFlow. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li>     ,   ,       ,     . </li><li>    ActorSystem   . </li><li>  ,     ,    ActorSystem,       terminate, ,   ,   ,     .      ,     JVM-. </li><li>    ActorMaterializer,      akka-streams,   ActorSystem. </li><li> ,   httpFlow     .      ,       HTTP-   ActorSystem. </li></ol><br>       Subscriber-    HTTP-. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br>  IteratorSubscriber    Producer-Consumer.   ,    Subscriber,  Producer-,  ,   Iterator, ‚Äì Consumer-.      ,     .    Iterator       Apache Spark,    Subscriber ‚Äì  ,  ActorSystem. <br><br>      IteratorSubscriber  . <br><br><ol><li>          .          ,     Done,    ,  Throwable,    . </li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li>  next      .    ,        hasNext,    next        . </li><li>     Publisher-  ,       ,   subscription,       Publisher-.     requestSize.         . </li></ol><br>  ,       ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i> 8.       .</i> <br><br><h3>  :      </h3><br>      ,        ,      .     ,       HTTP ,      .         . <br><br>    ‚Äì         .    ,     ,       Hadoop ,      .  ,    ,       -       .     ,  ,   hdfs, ,          , ,       . <br><br>  ,         . ,   akka-http              ,         .   ,      -,       -       Apache Spark ,       ,  ,    -. <br><br> ,   ,         .   ,   ,        http-,          ,     . <br><br>          ,         .  ,        ,    .     ,   .  ,         . <br><br>                ,    . ,  ,    Hadoop    ,           ,     . <br><br>  ,  ,  Hadoop-    ,     ,         . <br><br>  ,  ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CleverDATA</a> .                      .  ,  ,     ,  ,    ,            .  ,            . <br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembang Java</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insinyur sistem</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413141/">https://habr.com/ru/post/id413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413129/index.html">25 kesalahan seorang programmer pemula</a></li>
<li><a href="../id413133/index.html">Antipatterns populer: pagination</a></li>
<li><a href="../id413135/index.html">Penugasan tes review kode pengembang reaksi junior</a></li>
<li><a href="../id413137/index.html">Klasifikasi sejumlah besar data pada Apache Spark menggunakan model pembelajaran mesin sewenang-wenang</a></li>
<li><a href="../id413139/index.html">Mobil listrik: revolusi akan datang</a></li>
<li><a href="../id413143/index.html">Bobby Urban Lite: New Urban Backpack XD Design</a></li>
<li><a href="../id413145/index.html">Analis membantu bisnis menghasilkan uang</a></li>
<li><a href="../id413147/index.html">Apakah mungkin menggunakan Tibero alih-alih Oracle. Dan apakah itu perlu</a></li>
<li><a href="../id413149/index.html">Gudang data terdistribusi dalam konsep Danau Data: mulai dari mana</a></li>
<li><a href="../id413151/index.html">NSA mengusulkan standar enkripsi untuk perangkat IoT, tetapi ISO menolaknya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>