<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèª üêÉ ‚úãüèΩ Inicializa√ß√£o em C ++ moderno üëô üë®üèæ‚Äçüé§ üôáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√â sabido que a sem√¢ntica de inicializa√ß√£o √© uma das partes mais complexas do C ++. Existem muitos tipos de inicializa√ß√£o, descritos por sintaxe difere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inicializa√ß√£o em C ++ moderno</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469465/"><p><img src="https://habrastorage.org/webt/fy/g7/eb/fyg7ebgmdmbykh6evie2r7gx-zc.jpeg"></p><br><p>  √â sabido que a sem√¢ntica de inicializa√ß√£o √© uma das partes mais complexas do C ++.  Existem muitos tipos de inicializa√ß√£o, descritos por sintaxe diferente, e todos interagem de maneira complexa e desafiadora.  O C ++ 11 trouxe o conceito de "inicializa√ß√£o universal".  Infelizmente, ela introduziu regras ainda mais complexas e, por sua vez, elas foram bloqueadas no C ++ 14, C ++ 17 e alteradas novamente no C ++ 20. </p><br><p>  Sob o corte - v√≠deo e tradu√ß√£o do relat√≥rio de Timur Doumler da confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ na R√∫ssia</a> .  O Timur primeiro resume os resultados hist√≥ricos da evolu√ß√£o da inicializa√ß√£o em C ++, fornece uma vis√£o geral sistem√°tica da vers√£o atual da regra de inicializa√ß√£o, problemas e surpresas t√≠picos, explica como usar todas essas regras com efici√™ncia e, finalmente, fala sobre novas propostas no padr√£o que podem tornar a sem√¢ntica de inicializa√ß√£o C ++ 20 √© um pouco mais conveniente.  Al√©m disso, a hist√≥ria est√° em seu nome. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jJumNzcp6Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Sum√°rio</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o padr√£o (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o de c√≥pia (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o agregada (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o est√°tica (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o direta (C ++ 98)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o de valor (C ++ 03)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o universal (C ++ 11)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Melhorias no C ++ 14</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como inicializar corretamente em C ++</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o atribu√≠da (C ++ 20)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Corre√ß√µes em C ++ 20</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o direta de tipos agregados (C ++ 20)</a> </li></ul><br><p><img src="https://habrastorage.org/webt/bp/rd/ow/bprdow1rk6jtw5fzpm3bffzirps.gif"></p><br><p>  O gif que voc√™ v√™ agora transmite muito bem a mensagem principal do relat√≥rio.  Eu o encontrei na Internet h√° cerca de seis meses e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publiquei</a> no meu Twitter.  Nos coment√°rios, algu√©m disse que faltam mais tr√™s tipos de inicializa√ß√£o.  Come√ßou uma discuss√£o, durante a qual fui convidado a relatar isso.  E assim tudo come√ßou. </p><br><p>  Sobre a inicializa√ß√£o Nikolay Yossutis j√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disse</a> .  Seu relat√≥rio incluiu uma lista de slides de 19 maneiras diferentes de inicializar um int: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1; <span class="hljs-comment"><span class="hljs-comment">//undefined value int i2 = 42; //note: inits with 42 int i3(42); //inits with 42 int i4 = int(); //inits with 42 int i5{42}; //inits with 42 int i6 = {42}; //inits with 42 int i7{}; //inits with 0 int i8 = {}; //inits with 0 auto i9 = 42; //inits with 42 auto i10{42}; //C++11: std::initializer_list&lt;int&gt;, C++14: int auto i11 = {42}; //inits std::initializer_list&lt;int&gt; with 42 auto i12 = int{42}; //inits int with 42 int i13(); //declares a function int i14(7, 9); //compile-time error int i15 = (7, 9); //OK, inits int with 9 (comma operator) int i16 = int(7, 9); //compile-time error int i17(7, 9); //compile-time error auto i18 = (7, 9); //OK, inits int with 9 (comma operator) auto i19 = int(7, 9); //compile-time error</span></span></code> </pre> <br><p>  Parece-me que esta √© uma situa√ß√£o √∫nica para uma linguagem de programa√ß√£o.  A inicializa√ß√£o de uma vari√°vel √© uma das a√ß√µes mais simples, mas em C ++ n√£o √© nada f√°cil de fazer.  √â improv√°vel que esse idioma tenha qualquer outra √°rea em que, nos √∫ltimos anos, houvesse tantos relat√≥rios de desvios do padr√£o, corre√ß√µes e mudan√ßas.  As regras de inicializa√ß√£o mudam de padr√£o para padr√£o e h√° in√∫meras postagens na Internet sobre como inicializar em C ++.  Portanto, fazer uma revis√£o sistem√°tica √© uma tarefa n√£o trivial. </p><br><p>  Apresentarei o material em ordem cronol√≥gica: primeiro falaremos sobre o que foi herdado de C, depois sobre C ++ 98, depois sobre C ++ 03, C ++ 11, C ++ 14 e C ++ 17.  Discutiremos erros comuns e darei minhas recomenda√ß√µes sobre a inicializa√ß√£o adequada.  Tamb√©m falarei sobre inova√ß√µes em C ++ 20.  Uma tabela de vis√£o geral ser√° apresentada no final do relat√≥rio. </p><br><a name="a1"></a><br><h1 id="inicializaciya-po-umolchaniyu-s">  Inicializa√ß√£o padr√£o (C) </h1><br><p>  No C ++, muitas coisas s√£o herdadas do C, √© por isso que vamos come√ßar com ele.  Existem v√°rias maneiras de inicializar vari√°veis ‚Äã‚Äãem C.  Eles podem n√£o ser inicializados e isso √© chamado de <em>inicializa√ß√£o padr√£o</em> .  Na minha opini√£o, este √© um nome infeliz.  O fato √© que nenhuma vari√°vel recebe um valor padr√£o, ela simplesmente n√£o √© inicializada.  Se voc√™ ativar uma vari√°vel n√£o inicializada em C ++ e C, ter√° um comportamento indefinido: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; <span class="hljs-comment"><span class="hljs-comment">// undefined behaviour }</span></span></code> </pre> <br><p>  O mesmo se aplica aos tipos personalizados: se em alguma <code>struct</code> houver campos n√£o inicializados, ao acess√°-los, tamb√©m ocorrer√° um comportamento indefinido: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.i; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Muitas novas constru√ß√µes foram adicionadas ao C ++: classes, construtores, m√©todos p√∫blicos, privados, mas nada disso afeta o comportamento descrito.  Se algum elemento n√£o for inicializado na classe, ao acess√°-lo, ocorrer√° um comportamento indefinido: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_j</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.get_i(); <span class="hljs-comment"><span class="hljs-comment">// Undefined behaviour! }</span></span></code> </pre> <br><p>  N√£o h√° maneira m√°gica de inicializar um elemento de classe em C ++ por padr√£o.  Esse √© um ponto interessante e, durante os primeiros anos de minha carreira com C ++, eu n√£o sabia disso.  Nem o compilador nem o IDE, que eu usei na √©poca, me lembraram disso de forma alguma.  Meus colegas n√£o prestaram aten√ß√£o a esse recurso ao verificar o c√≥digo.  Tenho certeza de que, por causa dela, existem alguns bugs muito estranhos no meu c√≥digo escritos durante esses anos.  Pareceu-me √≥bvio que as classes deveriam inicializar suas vari√°veis. </p><br><p>  No C ++ 98, voc√™ pode inicializar vari√°veis ‚Äã‚Äãusando a lista de inicializadores de membros.  Mas essa solu√ß√£o para o problema n√£o √© ideal, pois deve ser feita em cada construtor, e isso √© f√°cil de esquecer.  Al√©m disso, a inicializa√ß√£o continua na ordem em que as vari√°veis ‚Äã‚Äãs√£o declaradas e n√£o na ordem da lista de inicializadores de membros: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++98: member initialiser list class Widget { public: Widget() : i(0), j(0) {} // member initialiser list int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i; int j; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  No C ++ 11, foram adicionados inicializadores diretos de membros, que s√£o muito mais convenientes de usar.  Eles permitem que voc√™ inicialize todas as vari√°veis ‚Äã‚Äãao mesmo tempo, e isso garante que todos os elementos sejam inicializados: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++11: default member initialisers class Widget { public: Widget() {} int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i = 0; // default member initialisers int j = 0; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  Minha primeira recomenda√ß√£o: sempre que puder, use sempre o DMI (inicializadores diretos de membros).  Eles podem ser usados ‚Äã‚Äãtanto com tipos <code>float</code> ( <code>float</code> e <code>int</code> ) quanto com objetos.  O h√°bito de inicializar elementos nos leva a abordar essa quest√£o de maneira mais consciente. </p><br><a name="a2"></a><br><h1 id="kopiruyuschaya-inicializaciya-s">  Inicializa√ß√£o de c√≥pia (C) </h1><br><p>  Portanto, o primeiro m√©todo de inicializa√ß√£o herdado de C √© a inicializa√ß√£o por padr√£o e n√£o deve ser usado.  A segunda maneira √© a <em>inicializa√ß√£o da c√≥pia</em> .  Nesse caso, indicamos a vari√°vel e atrav√©s do sinal de igual - seu valor: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int main() { int i = 2; }</span></span></code> </pre> <br><p>  A inicializa√ß√£o de c√≥pia tamb√©m √© usada quando um argumento √© passado para uma fun√ß√£o por valor ou quando um objeto √© retornado de uma fun√ß√£o por valor: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int square(int i) { return i * i; }</span></span></code> </pre> <br><p>  Um sinal de igual pode dar a impress√£o de que um valor est√° sendo atribu√≠do, mas n√£o √© assim.  A inicializa√ß√£o da c√≥pia n√£o √© uma atribui√ß√£o de valor.  N√£o haver√° nada sobre apropria√ß√£o neste relat√≥rio. </p><br><p>  Outra propriedade importante da inicializa√ß√£o da c√≥pia: se os tipos de valores n√£o corresponderem, uma sequ√™ncia de convers√£o ser√° executada.  Uma sequ√™ncia de convers√£o possui certas regras, por exemplo, n√£o chama construtores expl√≠citos, pois eles n√£o est√£o transformando construtores.  Portanto, se voc√™ executar a inicializa√ß√£o de c√≥pia para um objeto cujo construtor est√° marcado como expl√≠cito, ocorrer√° um erro de compila√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ERROR</span></span></code> </pre> <br><p>  Al√©m disso, se houver outro construtor que n√£o seja expl√≠cito, mas com pior tipo, a inicializa√ß√£o de c√≥pia o chamar√°, ignorando o construtor expl√≠cito: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double)</span></span></code> </pre> <br><a name="a3"></a><br><h1 id="agregatnaya-inicializaciya-s">  Inicializa√ß√£o agregada (C) </h1><br><p>  O terceiro tipo de inicializa√ß√£o que eu gostaria de falar √© <em>a inicializa√ß√£o agregada</em> .  √â executado quando a matriz √© inicializada com uma s√©rie de valores entre chaves: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br><p>  Se voc√™ n√£o especificar o tamanho da matriz, ser√° derivado do n√∫mero de valores entre colchetes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// array size deduction</span></span></code> </pre> <br><p>  A mesma inicializa√ß√£o √© usada para classes agregadas, ou seja, classes que s√£o apenas uma cole√ß√£o de elementos p√∫blicos (existem mais algumas regras na defini√ß√£o de classes agregadas, mas agora n√£o vamos nos deter sobre elas): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> j; }; Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  Essa sintaxe funcionou mesmo em C e C ++ 98 e, come√ßando com C ++ 11, voc√™ pode pular o sinal de igual: </p><br><pre> <code class="cpp hljs">Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  Inicializa√ß√£o agregada, na verdade, usa inicializa√ß√£o de c√≥pia para cada elemento.  Portanto, se voc√™ tentar usar a inicializa√ß√£o agregada (com um sinal de igual e sem ele) para v√°rios objetos com construtores expl√≠citos, a inicializa√ß√£o da c√≥pia ser√° executada para cada objeto e ocorrer√° um erro de compila√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ERROR Thingy thingy {3, 4}; // ERROR }</span></span></code> </pre> <br><p>  E se houver outro construtor para esses objetos, n√£o expl√≠cito, ele ser√° chamado, mesmo que seja mais adequado para o tipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Thingy thingy {3, 4}; //  Widget(double) }</span></span></code> </pre> <br><p>  Vamos considerar mais uma propriedade da inicializa√ß√£o agregada.  Pergunta: qual valor esse programa retorna? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.j; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text"><p>  Isso mesmo, zero.  Se voc√™ pular alguns elementos em uma matriz de valores durante a inicializa√ß√£o agregada, as vari√°veis ‚Äã‚Äãcorrespondentes ser√£o definidas como zero.  Essa √© uma propriedade muito √∫til, porque, gra√ßas a ela, nunca pode haver elementos n√£o inicializados.  Funciona com classes agregadas e com matrizes: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     int[100] = {};</span></span></code> </pre> </div></div><br><p>  Outra propriedade importante da inicializa√ß√£o agregada √© a omiss√£o de colchetes (brision elision).  Que valor voc√™ acha que esse programa retorna?  Ele possui um <code>Widget</code> , que √© um agregado de dois valores <code>int</code> , e <code>Thingy</code> , um agregado de <code>Widget</code> e <code>int</code> .  O que obtemos se passarmos dois valores de inicializa√ß√£o para ele: <code>{1, 2}</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy t = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tk; <span class="hljs-comment"><span class="hljs-comment">//   ? }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text"><p>  A resposta √© zero.  Aqui estamos lidando com um subagregado, ou seja, com uma classe agregada aninhada.  Essas classes podem ser inicializadas usando colchetes aninhados, mas voc√™ pode pular um desses pares de colchetes.  Nesse caso, √© realizada uma passagem recursiva do subagregado e <code>{1, 2}</code> √© equivalente a <code>{{1, 2}, 0}</code> .  √â certo que essa propriedade n√£o √© totalmente √≥bvia. </p></div></div><br><a name="a4"></a><br><h1 id="staticheskaya-inicializaciya-s">  Inicializa√ß√£o est√°tica (C) </h1><br><p>  Finalmente, a <em>inicializa√ß√£o est√°tica</em> tamb√©m <em>√©</em> herdada de C: vari√°veis ‚Äã‚Äãest√°ticas s√£o sempre inicializadas.  Isso pode ser feito de v√°rias maneiras.  Uma vari√°vel est√°tica pode ser inicializada com uma express√£o constante.  Nesse caso, a inicializa√ß√£o ocorre no momento da compila√ß√£o.  Se voc√™ n√£o atribuir nenhum valor √† vari√°vel, ele ser√° inicializado com zero: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   statit int j; //   int main() { return i + j; }</span></span></code> </pre> <br><p>  Este programa retorna 3 mesmo que <code>j</code> n√£o <code>j</code> inicializado.  Se a vari√°vel for inicializada n√£o por uma constante, mas por um objeto, poder√£o surgir problemas. </p><br><p>  Aqui est√° um exemplo de uma biblioteca real em que eu estava trabalhando: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Colour red = {<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br><p>  Havia uma classe Color nele, e as cores prim√°rias (vermelho, verde, azul) eram definidas como objetos est√°ticos.  Essa √© uma a√ß√£o v√°lida, mas assim que outro objeto est√°tico aparece no inicializador do qual √© usado o <code>red</code> , a incerteza aparece porque n√£o h√° uma ordem r√≠gida na qual as vari√°veis ‚Äã‚Äãs√£o inicializadas.  Seu aplicativo pode acessar uma vari√°vel n√£o inicializada e ela falha.  Felizmente, no C ++ 11, tornou-se poss√≠vel usar o construtor <code>constexpr</code> , e depois lidamos com a inicializa√ß√£o constante.  Nesse caso, n√£o h√° problemas com a ordem de inicializa√ß√£o. </p><br><p>  Portanto, quatro tipos de inicializa√ß√£o s√£o herdados da linguagem C: inicializa√ß√£o padr√£o, c√≥pia, agrega√ß√£o e inicializa√ß√£o est√°tica. </p><br><a name="a5"></a><br><h1 id="pryamaya-inicializaciya-s98">  Inicializa√ß√£o direta (C ++ 98) </h1><br><p>  Vamos para o C ++ 98.  Talvez o recurso mais importante que distingue C ++ de C sejam os construtores.  Aqui est√° um exemplo de uma chamada de construtor: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  Usando a mesma sintaxe, voc√™ pode inicializar tipos <code>int</code> como <code>int</code> e <code>float</code> .  Essa sintaxe √© chamada <em>inicializa√ß√£o direta</em> .  √â sempre executado quando temos um argumento entre par√™nteses. </p><br><p>  Para tipos <code>int</code> ( <code>int</code> , <code>bool</code> , <code>float</code> ), n√£o h√° diferen√ßa em rela√ß√£o √† inicializa√ß√£o de c√≥pia aqui.  Se estamos falando de tipos de usu√°rio, ao contr√°rio da inicializa√ß√£o de c√≥pia, com inicializa√ß√£o direta, voc√™ pode passar v√°rios argumentos.  Na verdade, por causa disso, a inicializa√ß√£o direta foi inventada. </p><br><p>  Al√©m disso, uma inicializa√ß√£o direta n√£o executa uma sequ√™ncia de convers√£o.  Em vez disso, o construtor √© chamado usando a resolu√ß√£o de sobrecarga.  A inicializa√ß√£o direta tem a mesma sintaxe que uma chamada de fun√ß√£o e usa a mesma l√≥gica que outras fun√ß√µes do C ++. </p><br><p>  Portanto, na situa√ß√£o com um construtor expl√≠cito, a inicializa√ß√£o direta funciona bem, embora a inicializa√ß√£o de c√≥pia gere um erro: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w2(1); //   </span></span></code> </pre> <br><p>  Em uma situa√ß√£o com dois construtores, um dos quais √© expl√≠cito e o segundo √© menos adequado no tipo, o primeiro √© chamado com inicializa√ß√£o direta e o segundo √© chamado com a c√≥pia.  Nessa situa√ß√£o, alterar a sintaxe levar√° a uma chamada para outro construtor - isso geralmente √© esquecido: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Widget w2(1); //  Widget(int)</span></span></code> </pre> <br><p>  A inicializa√ß√£o direta sempre √© usada quando par√™nteses s√£o usados, inclusive quando a nota√ß√£o de chamada do construtor √© usada para inicializar um objeto tempor√°rio, bem como em <code>new</code> express√µes com um inicializador entre colchetes e express√µes de <code>cast</code> : </p><br><pre> <code class="cpp hljs">useWidget(Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//   auto* widget_ptr = new Widget(2, 3); // new-expression with (args) static_cast&lt;Widget&gt;(thingy); // cast</span></span></code> </pre> <br><p>  Essa sintaxe existe enquanto o pr√≥prio C ++ existir e possui uma falha importante que Nikolai mencionou em seu discurso principal: <em>a an√°lise mais irritante</em> .  Isso significa que tudo o que o compilador pode ler como uma declara√ß√£o (declara√ß√£o), ele l√™ exatamente como uma declara√ß√£o. </p><br><p>  Considere um exemplo no qual h√° uma classe <code>Widget</code> e uma classe <code>Thingy</code> e um construtor <code>Thingy</code> que recebe um <code>Widget</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Thingy(Widget) {} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Thingy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget())</span></span></span></span>; }</code> </pre> <br><p>  √Ä primeira vista, parece que ap√≥s a inicializa√ß√£o do <code>Thingy</code> , o <code>Widget</code> padr√£o criado √© passado para ele, mas, de fato, a fun√ß√£o √© declarada aqui.  Este c√≥digo declara uma fun√ß√£o que recebe outra fun√ß√£o como entrada, que n√£o recebe nada como entrada e retorna um <code>Widget</code> , e a primeira fun√ß√£o retorna <code>Thingy</code> .  O c√≥digo √© compilado sem erros, mas √© improv√°vel que tenhamos procurado esse comportamento. </p><br><a name="a6"></a><br><h1 id="inicializaciya-znacheniem-c03">  Inicializa√ß√£o de valor (C ++ 03) </h1><br><p>  Vamos para a pr√≥xima vers√£o - C ++ 03.  √â geralmente aceito que n√£o houve altera√ß√µes significativas nesta vers√£o, mas n√£o √© assim.  No C ++ 03, apareceu a inicializa√ß√£o do valor, na qual s√£o escritos par√™nteses vazios: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// UB  C++98, 0   C++03 }</span></span></code> </pre> <br><p>  No C ++ 98, o comportamento indefinido ocorre aqui porque a inicializa√ß√£o ocorre por padr√£o e, iniciando no C ++ 03, este programa retorna zero. </p><br><p>  A regra √© a seguinte: se houver um construtor padr√£o definido pelo usu√°rio, a inicializa√ß√£o com um valor chamar√° esse construtor, caso contr√°rio, zero ser√° retornado. </p><br><p>  Vamos considerar com mais detalhes a situa√ß√£o com o construtor personalizado: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Widget(); <span class="hljs-comment"><span class="hljs-comment">// value initialization } int main() { return get_widget().i; }</span></span></code> </pre> <br><p>  Neste programa, a fun√ß√£o inicializa o valor para o novo <code>Widget</code> e o retorna.  Chamamos essa fun√ß√£o e acessamos o elemento <code>i</code> do objeto <code>Widget</code> .  Desde C ++ 03, o valor de retorno aqui √© zero, pois n√£o h√° construtor padr√£o definido pelo usu√°rio.  E se esse construtor existe, mas n√£o inicializa <code>i</code> , obtemos um comportamento indefinido: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {} <span class="hljs-comment"><span class="hljs-comment">//   int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //   ,  UB }</span></span></code> </pre> <br><p>  Vale ressaltar que ‚Äúdefinido pelo usu√°rio‚Äù n√£o significa ‚Äúdefinido pelo usu√°rio‚Äù.  Isso significa que o usu√°rio deve fornecer o corpo do construtor, ou seja, chaves.  Se no exemplo acima, substitua o corpo do construtor por <code>= default</code> (esse recurso foi adicionado no C ++ 11), o significado do programa ser√° alterado.  Agora, como temos um construtor definido pelo usu√°rio (definido pelo usu√°rio), mas n√£o fornecido pelo usu√°rio (fornecido pelo usu√°rio), o programa retorna zero: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// user-defined,   user-provided int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //  0 }</span></span></code> </pre> <br><p>  Agora vamos tentar <code>Widget() = default</code> da classe.  O significado do programa mudou novamente: <code>Widget() = default</code> √© considerado um construtor fornecido pelo usu√°rio se estiver fora da classe.  O programa retorna comportamento indefinido novamente. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; Widget::Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,  user-provided Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //    , UB }</span></span></code> </pre> <br><p>  Existe uma certa l√≥gica: um construtor definido fora de uma classe pode estar dentro de outra unidade de tradu√ß√£o.  O compilador pode n√£o ver esse construtor, pois pode estar em outro arquivo <code>.cpp</code> .  Portanto, o compilador n√£o pode tirar conclus√µes sobre esse construtor e n√£o pode distinguir um construtor com um corpo de um construtor com <code>= default</code> . </p><br><a name="a7"></a><br><h1 id="universalnaya-inicializaciya-c11">  Inicializa√ß√£o universal (C ++ 11) </h1><br><p>  Houve muitas mudan√ßas muito importantes no C ++ 11.  Em particular, a uniformiza√ß√£o universal foi introduzida, que eu prefiro chamar de ‚Äúinicializa√ß√£o de unic√≥rnio‚Äù porque √© apenas m√°gica.  Vamos ver por que ela apareceu. </p><br><p>  Como voc√™ j√° notou, no C ++ existem muitas sintaxes de inicializa√ß√£o diferentes com comportamentos diferentes.  A an√°lise irritante entre par√™nteses causou muitos inconvenientes.  Os desenvolvedores tamb√©m n√£o gostaram que a inicializa√ß√£o agregada pudesse ser usada apenas com matrizes, mas n√£o com cont√™ineres como <code>std::vector</code> .  Em vez disso, voc√™ tinha que executar <code>.reserve</code> e <code>.push_back</code> , ou usar todos os tipos de bibliotecas assustadoras: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  : std::vector&lt;int&gt; vec = {0, 1, 2, 3, 4}; //   : std::vector&lt;int&gt; vec; vec.reserve(5); vec.push_back(0); vec.push_back(1); vec.push_back(2); vec.push_back(3); vec.push_back(4);</span></span></code> </pre> <br><p>  Os criadores da linguagem tentaram resolver todos esses problemas, introduzindo sintaxe com chaves, mas sem sinal de igual.  Supunha-se que essa seria uma sintaxe √∫nica para todos os tipos, nos quais chaves s√£o usadas e n√£o h√° nenhum problema de an√°lise irritante.  Na maioria dos casos, essa sintaxe faz seu trabalho. </p><br><p>  Essa nova inicializa√ß√£o √© chamada de <em>inicializa√ß√£o de lista</em> e vem em dois tipos: direta e c√≥pia.  No primeiro caso, apenas chaves s√£o usadas, no segundo - chaves com um sinal de igual: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// direct-list-initialization Widget widget{1, 2}; // copy-list-initialization Widget widget = {1, 2};</span></span></code> </pre> <br><p>  A lista usada para inicializa√ß√£o √© chamada <em>braced-init-list</em> .  √â importante que esta lista n√£o seja um objeto, ela n√£o tem tipo.  Mudar para o C ++ 11 de vers√µes anteriores n√£o cria problemas com tipos agregados, portanto, essa altera√ß√£o n√£o √© cr√≠tica.  Mas agora a lista entre chaves tem novos recursos.  Embora n√£o tenha um tipo, ele pode ser oculto convertido em <code>std::initializer_list</code> , mas √© um tipo novo e especial.  E se houver um construtor que aceite <code>std::initializer_list</code> como entrada, esse construtor ser√° chamado: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//... vector(std::initializer_list&lt;T&gt; init); //   initializer_list }; std::vector&lt;int&gt; vec{0, 1, 2, 3, 4}; //  ^ </span></span></code> </pre> <br><p>  Parece-me que, do lado do comit√™ C ++, <code>std::initializer_list</code> n√£o era a solu√ß√£o mais bem-sucedida.  Dele mais mal do que bem. </p><br><p>  Para come√ßar, <code>std::initializer_list</code> √© um vetor de tamanho fixo com elementos <code>const</code> .  Ou seja, √© um tipo, possui fun√ß√µes de <code>begin</code> e <code>end</code> que os iteradores retornam, possui seu pr√≥prio tipo de iterador e, para us√°-lo, √© necess√°rio incluir um cabe√ßalho especial.  Como os elementos <code>std::initializer_list</code> s√£o <code>const</code> , ele n√£o pode ser movido; portanto, se <code>T</code> no c√≥digo acima √© do tipo somente movimento, o c√≥digo n√£o ser√° executado. </p><br><p>  Em seguida, <code>std::initializer_list</code> √© um objeto.  Com ele, criamos e transferimos objetos.  Como regra, o compilador pode otimizar isso, mas do ponto de vista da sem√¢ntica, ainda lidamos com objetos desnecess√°rios. </p><br><p>  Alguns meses atr√°s, houve uma pesquisa no Twitter: se voc√™ pudesse voltar no tempo e remover algo do C ++, o que voc√™ removeria?  A maioria de todos os votos recebeu exatamente <code>initializer_list</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://twitter.com/shafikyaghmour/status/1058031143935561728</a> </p><br><p>         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>   initializer_list</code></a> .         ,     . </p><br><p>  ,    .   ,     <code>initializer_list</code> ,              .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   0, 0, 0 std::vector&lt;int&gt; v{3, 0}; //   3, 0</span></span></code> </pre> <br><p>   <code>vector</code>    <code>int</code>    ,    ,      ,   ‚Äî  .       .       ,   <code>initializer_list</code>        , 3  0. </p><br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">48</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" std::string s{48, 'a'}; // "0a"</span></span></code> </pre> <br><p>       48  ¬´¬ª,     ¬´0¬ª.   ,   <code>string</code>    <code>initializer_list</code>  . 48   ,     .  ASCII  48 ‚Äî   ¬´0¬ª.   ,    ,    , <code>int</code>  <code>char</code> .         .    ,       ,   . </p><br><p>       .   ,    ?    ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;{N}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;().size(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>      ,    ‚Äî 3.   <code>string</code>   <code>int</code> ,   1,    <code>std::vector&lt;std::int&gt;</code>   <code>initializer_list</code> .         <code>initializer_list</code> ,   .    <code>string</code>  <code>int</code>  <code>float</code> ,     ,  .      ,     . ,     emplace ,          .  ,     <code>{}</code>    . </p></div></div><br><p>   ,     . </p><br><p>         <br> . <br>    ‚Äî   ( <code>{a}</code> )  <br>   ( <code>= {a}</code> ); <br>      : </p><br><ol><li>  ¬´¬ª   ,   <code>std::initializer_list</code> . <br>         ‚Äî  . </li><li>    ,   <br>   <code>()</code>    . </li></ol><br><p>      . </p><br><p>  1:   <code>= {a}</code> ,      <code>a</code> , <br>     . </p><br><p>  2:   , <code>{}</code> . <br>           ,   <code>initializer_list</code> . <br>     <code>Widget&lt;int&gt; widget{}\</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Typename&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); Widget(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;T&gt;); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; widget{}; <span class="hljs-comment"><span class="hljs-comment">//    ? }</span></span></code> </pre> <br><p>  ,    ,  <code>initializer_list</code> ,      <code>initializer_list</code>   .        .      ,  ,  <code>initializer_list</code> .     ,   .  ,     . </p><br><p>       <code>{}</code> . , -,  ,   <code>Widget() = default</code>  <code>Widget() {}</code>    ‚Äî     . </p><br><p> <code>Widget() = default</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{}; <span class="hljs-comment"><span class="hljs-comment">//   (),   vexing parse return widget.i; //  0 }</span></span></code> </pre> <br><p> <code>Widget() {}</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {}; <span class="hljs-comment"><span class="hljs-comment">// user-provided  int i; }; int main() { Widget widget{}; //  ,    return widget.i; //  ,  UB }</span></span></code> </pre> <br><p>      :   ,    (narrowing conversions).    <code>int</code>  <code>double</code> ,    ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i{<span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ! }</span></span></code> </pre> <br><p>    ,       <code>double</code> .   C++11,         ,      .          : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//   ++11    C++98/03 }</span></span></code> </pre> <br><p> ,        , ,     ,       (brace elision).   ,       ,   . ,    <code>map</code> .       <code>map</code> ,     ‚Äî  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; my_map {{<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}};</code> </pre> <br><p>   ,      .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; v1 {<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::vector&lt;std::string&gt; v2 {{"abc", "def"}}; // ??</span></span></code> </pre> <br><p> ,    ,     <code>initializer_list</code> .      <code>initializer_list</code>   ,   , ,     .           ,   .  , . </p><br><p>  <code>initializer_list</code>     ‚Äî  <code>initializer_list</code> ,        .     ,    <code>const char*</code> . ,  <code>string</code>  ,     <code>char</code>    .        .     ,     ,   . </p><br><p> : </p><br><ul><li>       ; </li><li>       . </li></ul><br><p>  .    braced-init-list     .    : </p><br><pre> <code class="cpp hljs">Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// copy-list    } void f2(Widget); f2({3, 0}); // copy-list  </span></span></code> </pre> <br><p>     ,    ,    braced-init-list    .    braced-init-list ,       . </p><br><p> ,          .  StackOverflow   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,             . ,      .      ,      ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; struct A { A() {} A(const A&amp;) {} }; struct B { B(const A&amp;) {} }; void f(const A&amp;) { std::cout &lt;&lt; "A" &lt;&lt; std::endl; } void f(const B&amp;) { std::cout &lt;&lt; "B" &lt;&lt; std::endl; } int main() { A a; f( {a} ); // A f( {{a}} ); // ambiguous f( {{{a}}} ); // B f({{{{a}}}}); // no matching function }</span></span></span></span></code> </pre> <br><a name="a8"></a><br><h1 id="uluchsheniya-v-s14">   ++14 </h1><br><p> ,      C++11 .      ,   ,        .    C++14.      ,    . </p><br><p> ,  ++11       direct member initializers,     .      ,  direct member initializers  .   ++14,      direct member initializers: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    C++14</span></span></code> </pre> <br><p>        ,    <code>auto</code> .   ++11  <code>auto</code>  braced-init-list,       <code>std::initializer_list</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int int i(3); // int int i{3}; // int int i = {3}; // int auto i = 3; // int auto i(3); // int auto i{3}; //  ++11 ‚Äî std::initializer_list&lt;int&gt; auto i = {3}; //  ++11 ‚Äî std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p>   :   <code>auto i{3}</code> ,     <code>int</code> ,   <code>std::initializer_list&lt;int&gt;</code> .  ++14   ,  <code>auto i{3}</code>    <code>int</code> .          ,     . , <code>auto i = {3}</code>    <code>std::initializer_list&lt;int&gt;</code> .  ,     :      <code>int</code> ,     ‚Äî <code>initializer_list</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int auto i(3); // int auto i{3}; //  ++14 ‚Äî int,         auto i = {3}; //    std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p> ,  C++14      ,      ,  ,     ,       .   ,     . </p><br><p>     ,  ++14      : </p><br><ul><li><p>   ,   ,  <code>std::initializer_list</code> . </p><br></li><li><p>  <code>std::initializer_list</code>    move-only . </p><br></li><li><p>  c   ,  <code>emplace</code>  <code>make_unique</code>     . </p><br></li><li><p>    ,     : </p><br><ul><li>      ,  -; </li><li>       ; </li><li> auto     . </li></ul><br></li><li><p> ,    ,        . </p><br></li></ul><br><p>   : <code>assert(Widget(2,3))</code> ,  <code>assert(Widget{2,3})</code>  .   ,      ,       ,        .           ,     .    . </p><br><a name="a9"></a><br><h1 id="kak-pravilno-inicializirovat-v-c">     C++ </h1><br><p>       ,      ++. </p><br><p>     <code>int</code>   , . .     ‚Äî      ,          . </p><br><p>      :   ,   ,  <code>std::initializer_list</code> ,   direct member initializers.          ,       . </p><br><p>  ,         √© .             . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; setPosition(Point{<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget(Widget{});</code> </pre> <br><p>        braced-init-list ‚Äî      . </p><br><pre> <code class="cpp hljs">setPosition({<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget({});</code> </pre> <br><p>      ,       ,    .   ,         ‚Äî  ,       .  ,     ,     ,    ,   ,    .    ,   ,     <code>initializer_list</code> .        :     ,  ,   . </p><br><p>   : </p><br><ul><li><p> <code>= value</code>    </p><br></li><li><p> <code>= {args}</code>  <code>= {}</code> : </p><br><ul><li>    </li><li>    <code>std::initializer_list</code> </li><li>  direct member initialisation (    <code>(args)</code> ) </li></ul><br></li><li><p> <code>{args}</code>  <code>{}</code>     √©  </p><br></li><li><p> <code>(args)</code>    </p><br></li></ul><br><p> ,   <code>(args)</code>     vexing parse.        .    2013  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,   ,          <code>auto</code> .     ,        :   <code>auto i;</code> ‚Äî    .     ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>   ,        .  ,           ,     vexing parse: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> thingy = Thingy();</code> </pre> <br><p>      ¬´  auto¬ª (¬´almost always auto¬ª, AAA),   ++11  ++14       , , ,     <code>std::atomic&lt;int&gt;</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++11/14:  // std::atomic is neither copyable nor movable</span></span></code> </pre> <br><p>   ,  atomic    .   ,          ,    ,    ,       .  ++17    ,    ,      (guaranteed copy elision): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++17: OK, guaranteed copy elision</span></span></code> </pre> <br><p>        <code>auto</code> .   ‚Äî  direct member initializers.     <code>auto</code>  . </p><br><p>  ++17    CTAD (class template argument deduction). ,              .        .  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  CppCon,   CTAD</a> ,       .   ,  ++17   ,    ++11  ++14,   ,       .     ,    , ,   ,      . </p><br><a name="a10"></a><br><h1 id="naznachennaya-inicializaciya-s20">   (++20) </h1><br><p>     ++20,     .  ,  ,          : <em> </em> (designated initialization): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, .c = <span class="hljs-number"><span class="hljs-number">7</span></span>}; };</code> </pre> <br><p>  ,      .         ,      ,      .        ,       .      <code></code>  <code></code> ,  <code>b</code>  . </p><br><p>      ,  ,     ,     .       ,         . </p><br><p>       ,    ,   99,   : </p><br><ul><li><p>       ,         ,   .  ++   ,     ,    . : </p><br><pre> <code class="cpp hljs">Widget widget{.c = <span class="hljs-number"><span class="hljs-number">7</span></span>, .a = <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><p>  ,     . </p><br></li><li><p>  ++      ,     <code>{.ce = 7};</code> ,    <code>{.c{.e = 7}}</code> : </p><br><pre> <code class="cpp hljs">Widget widget{.ce = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       ,      ,      : </p><br><pre> <code class="cpp hljs">Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       . , -,   ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>]{.[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li></ul><br><a name="a11"></a><br><h1 id="ispravleniya-v-c20">   C++20 </h1><br><p>      ++20       ,        .     ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wg21.link/p1008</a> ). </p><br><p>   ++17    ,    ,        .             ,    ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; Widget widget1; <span class="hljs-comment"><span class="hljs-comment">//  Widget widget2{}; //   C++17,     C++20</span></span></code> </pre> <br><p>    ,       ,      .  ++20   .        ,              .  ,   .       ,    ,     ,   . </p><br><p>         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wg21.link/p1009</a> ). Braced-init-list     <code>new</code> ,   :        ,    ?  ‚Äî ,    : braced-init-list      <code>new</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a[]{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK double* p = new double[]{1, 2, 3}; //   C++17,   C++20</span></span></code> </pre> <br><p>    ,   ++11  braced-init-list.  ++   .        ,       . </p><br><a name="a12"></a><br><h1 id="pryamaya-inicializaciya-agregatnyh-tipov-c20">     (C++20) </h1><br><p> ,  ++20      .       ,             .  ++20  :         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wg21.link/p0960</a> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//   C++20</span></span></code> </pre> <br><p>            .   ,        <code>emplace</code>  <code>make_unique</code> .      .  :   <code>auto</code> ,          : <em>58.11</em> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>   ,   :   uniform  2.0.     .         ,    , ,  ,           .  ‚Äî  <code>initializer_list</code> :    ,    ,   ‚Äî .    ,    .  ,   -     ,   ‚Äî .       . </p><br><p> ,    .   direct member initializers.   <code>auto</code> .      direct member initializers ‚Äî  ,    .   ,        .         ‚Äî ,     . </p><br><p>    ,    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .     ‚Äî  ,   ‚Äî  .     ,    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b8d/8a2/229/b8d8a2229e93baf65b78f738750ac635.png"></p><br><blockquote>   ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C++ Russia 2019 Piter</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">¬´Type punning in modern C++¬ª</a> .     ,   ++20,  ,    ,    ¬´¬ª  ++  ,    . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469465/">https://habr.com/ru/post/pt469465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469455/index.html">Migrando do Nginx para o Envoy Proxy</a></li>
<li><a href="../pt469457/index.html">Onde Extravaganza leva</a></li>
<li><a href="../pt469459/index.html">Conectando dispositivos IoT na cidade inteligente</a></li>
<li><a href="../pt469461/index.html">‚ÄúPara as Estrelas‚Äù: Anti-C√≥smico ‚ÄúApocalipse Hoje‚Äù</a></li>
<li><a href="../pt469463/index.html">Tend√™ncias e previs√µes no processamento de idiomas naturais</a></li>
<li><a href="../pt469467/index.html">C ++ vs C #</a></li>
<li><a href="../pt469471/index.html">"5 centavos" para falar sobre as sortes</a></li>
<li><a href="../pt469475/index.html">A ascens√£o e queda do Flash, o plugin irritante que moldou a web moderna</a></li>
<li><a href="../pt469477/index.html">Hora da Apple parar de comparar o iPad ao PC</a></li>
<li><a href="../pt469479/index.html">De onde vem a probabilidade qu√¢ntica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>