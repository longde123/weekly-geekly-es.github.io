<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Å ‚úçüèø ‚ìÇÔ∏è Connaissez votre JIT: plus pr√®s de la voiture üí∏ üõ∞Ô∏è üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avant que le code que nous avons √©crit soit ex√©cut√©, il va assez loin. Andrey Melikhov dans son rapport sur RIT ++ 2018 a examin√© chaque √©tape de ce c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Connaissez votre JIT: plus pr√®s de la voiture</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417459/"> Avant que le code que nous avons √©crit soit ex√©cut√©, il va assez loin.  <strong>Andrey Melikhov</strong> dans son rapport sur RIT ++ 2018 a examin√© chaque √©tape de ce chemin en utilisant l'exemple du moteur V8.  Entrez sous le chat pour d√©couvrir ce qui nous donne une compr√©hension approfondie des principes du compilateur et comment rendre le code JavaScript plus productif. <br><br><img src="https://habrastorage.org/webt/iy/2r/ke/iy2rkenolmtnchwu_whyurlrw80.jpeg"><br><br>  Nous verrons si WASM est une solution miracle pour am√©liorer les performances du code et si les optimisations sont toujours justifi√©es. <br><br>  <strong><em>Spoiler:</em></strong> ¬´L'optimisation pr√©matur√©e est la racine de tous les maux¬ª, Donald Knuth. <br><br><img src="https://habrastorage.org/webt/rd/-o/q7/rd-oq7q2m9bjipzyqo1l3jrlqti.jpeg"><br><br>  <strong><em>√Ä propos de l'orateur:</em></strong> Andrei Melikhov travaille chez Yandex.Money, √©crit activement sur Node.js, et moins dans le navigateur, donc le serveur JavaScript est plus proche de lui.  Andrew prend en charge et d√©veloppe la communaut√© devShacht, alors consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> . <br><a name="habracut"></a><br><h2>  <strong>Motivation et glossaire</strong> </h2><br>  Aujourd'hui, nous allons parler de la compilation JIT.  Je pense que cela vous int√©resse, puisque vous lisez ceci.  Cependant, clarifions pourquoi vous devez savoir ce qu'est JIT et comment fonctionne V8, et pourquoi √©crire React dans un navigateur n'est pas suffisant. <br><br><ul><li>  Vous permet <strong>d'√©crire du code plus efficace</strong> , car notre langage est sp√©cifique. </li><li>  <strong>Il r√©v√®le des √©nigmes</strong> pour lesquelles dans les biblioth√®ques d'autres personnes le code est √©crit de cette fa√ßon, et non autrement.  Parfois, nous rencontrons d'anciennes biblioth√®ques et voyons ce qui y est √©crit est quelque peu √©trange, mais si c'est n√©cessaire, ce n'est pas n√©cessaire - ce n'est pas clair.  Lorsque vous savez comment cela fonctionne, vous comprenez pourquoi cela a √©t√© fait. <br></li><li>  <strong>C'est juste int√©ressant</strong> .  De plus, cela nous permet de comprendre ce qu'Axel Rauschmeier, Benedict Moyrer et Dan Abramov communiquent sur Twitter. <br></li></ul><br><img src="https://habrastorage.org/webt/le/oy/yg/leoyyg4b8ru_n_2djyzkg6hbe1a.jpeg"><br><br>  Wikipedia dit que JavaScript est un langage de programmation interpr√©t√© de haut niveau avec une frappe dynamique.  Nous traiterons ces conditions. <br><br>  <strong>Compilation et interpr√©tation</strong> <br><br>  Compilation - lorsque le programme est livr√© en code binaire et est initialement optimis√© pour l'environnement dans lequel il fonctionnera. <br><br>  Interpr√©tation - lorsque nous livrons le code tel quel. <br><br>  JavaScript est livr√© tel quel - c'est un langage interpr√©t√©, tel qu'√©crit sur Wikipedia. <br><br>  <strong>Typage dynamique et statique</strong> <br><br>  Le typage statique et dynamique est souvent confondu avec un typage faible et fort.  Par exemple, C est un langage avec un typage faible statique.  JavaScript a un typage dynamique faible. <br><br>  Lequel est le meilleur?  Si le programme compile, il est orient√© vers l'environnement dans lequel il sera ex√©cut√©, ce qui signifie qu'il fonctionnera mieux.  La frappe statique rend ce code plus efficace.  En JavaScript, l'inverse est vrai. <br><br>  Mais en m√™me temps, notre application devient plus complexe: √† la fois sur le client et sur le serveur, d'√©normes clusters apparaissent sur Node.js, qui fonctionnent tr√®s bien et viennent remplacer les applications Java. <br><br>  Mais comment tout cela fonctionne-t-il s'il semble initialement √™tre un perdant. <br><br><blockquote>  JIT va r√©concilier tout le monde!  Ou du moins essayez. </blockquote><br>  Nous avons une JIT (compilation Just In Time) qui se produit au moment de l'ex√©cution.  Nous parlerons d'elle. <br><br><h3>  <strong>Moteurs Js</strong> </h3><br><ul><li>  Chakra non aim√©, qui se trouve dans Internet Explorer.  Cela ne fonctionne m√™me pas avec JavaScript, mais avec Jscript - il existe un tel sous-ensemble. <br></li><li>  Chakra moderne et ChakraCore qui fonctionnent dans Edge; <br></li><li>  SpiderMonkey dans FireFox; </li><li>  JavaScriptCore dans WebKit.  Il est √©galement utilis√© dans React Native.  Si vous avez une application RN pour Android, elle fonctionne √©galement sur JavaScriptCore - le moteur est fourni avec l'application. <br></li><li>  Le V8 est mon pr√©f√©r√©.  Ce n'est pas le meilleur, je travaille juste avec Node.js, dans lequel c'est le moteur principal, comme dans tous les navigateurs bas√©s sur Chrome. <br></li><li>  Rhino et Nashorn sont les moteurs utilis√©s en Java.  Avec leur aide, vous pouvez √©galement y ex√©cuter JavaScript. <br></li><li>  JerryScript - pour les appareils int√©gr√©s; <br></li><li>  et d'autres ... </li></ul><br>  Vous pouvez √©crire votre propre moteur, mais si vous vous dirigez vers une ex√©cution efficace, vous arriverez √† peu pr√®s au m√™me sch√©ma, que je montrerai plus tard. <br><br>  Aujourd'hui, nous allons parler du V8, et oui, il porte le nom du moteur 8 cylindres. <br><br><h2>  <strong>On grimpe sous le capot</strong> </h2><br>  Comment est ex√©cut√© javascript? <br><br><ul><li>  Il y a du code √©crit en JavaScript, qui est fourni. <br></li><li>  il analyse; </li><li>  est en cours d'ex√©cution; </li><li>  le r√©sultat est obtenu. <br></li></ul><br><img src="https://habrastorage.org/webt/wj/n0/us/wjn0ustvepwu4kmulit2v6xxtsy.jpeg"><br><br>  L'analyse transforme le code en une <strong>arborescence de syntaxe abstraite</strong> .  AST est un affichage de la structure syntaxique du code sous la forme d'un arbre.  C'est en fait pratique pour le programme, bien qu'il soit difficile √† lire. <br><img src="https://habrastorage.org/webt/3i/1p/y-/3i1py-dcnwj6enma0zveqcv67tq.jpeg"><br><br>  Obtenir un √©l√©ment de tableau avec l'index 1 sous la forme d'une arborescence est repr√©sent√© comme un op√©rateur et deux op√©randes: chargez la propri√©t√© par cl√© et ces cl√©s. <br><br><h3>  <strong>O√π l'AST est-il utilis√©?</strong> </h3><br>  AST n'est pas seulement dans les moteurs.  √Ä l'aide d'AST, de nombreux utilitaires √©crivent des extensions, notamment: <br><br><ul><li>  ESLint; </li><li>  Babel; </li><li>  Plus joli </li><li>  Jscodeshift. </li></ul><br>  Par exemple, le truc sympa Jscodeshift, dont tout le monde n'est pas encore au courant, vous permet d'√©crire des transformations.  Si vous modifiez l'API d'une fonction, vous pouvez y d√©finir ces transformations et apporter des modifications √† l'ensemble du projet. <br><br><img src="https://habrastorage.org/webt/wl/ct/8e/wlct8ejmclt1hoqiinm9jwbayyg.jpeg"><br><br>  Nous continuons.  Le processeur ne comprend pas l'arborescence de syntaxe abstraite; il a besoin d' <strong>un code machine</strong> .  Par cons√©quent, une transformation suppl√©mentaire a lieu via l'interpr√©teur, car la langue est interpr√©t√©e. <br><img src="https://habrastorage.org/webt/i6/cj/zh/i6cjzhohklmcdyenrvrjmdw6fyk.jpeg"><br><br>  Il en √©tait ainsi, alors que les navigateurs avaient un peu de JavaScript - mettez la ligne en surbrillance, ouvrez quelque chose, fermez.  Mais maintenant, nous avons des applications - SPA, Node.js et l' <strong>interpr√©teur devient un goulot d'√©tranglement</strong> . <br><br><h2>  <strong>Optimisation du compilateur JIT</strong> </h2><br>  Au lieu d'un interpr√©teur, un compilateur JIT d'optimisation appara√Æt, c'est-√†-dire un compilateur juste √† temps.  Les compilateurs avanc√©s travaillent avant l'ex√©cution de l'application et JIT - pendant.  Sur le probl√®me d'optimisation, le compilateur JIT essaie de deviner comment le code sera ex√©cut√©, quels types seront utilis√©s et optimiser le code pour qu'il fonctionne mieux. <br><br>  Une telle optimisation est appel√©e <strong>sp√©culative</strong> , car elle sp√©cule sur la connaissance de ce qui est arriv√© au code auparavant.  Autrement dit, si quelque chose avec le type de num√©ro a √©t√© appel√© 10 fois, le compilateur pense que cela se produira tout le temps et optimise pour ce type. <br><br>  Naturellement, si Boolean entre en entr√©e, la d√©soptimisation se produit.  Prenons une fonction qui ajoute des nombres. <br><br> <code>const foo=(a, b) =&gt; a + b; <br> foo (1, 2); <br> foo (2, 3);</code> <br> <br>  Pli√© une fois, la deuxi√®me fois.  Le compilateur construit la pr√©diction: "Ce sont des nombres, j'ai une solution sympa pour ajouter des nombres!"  Et vous √©crivez <code>foo('WTF', 'JS')</code> , et passez les lignes √† la fonction - nous avons JavaScript, nous pouvons ajouter une ligne avec un nombre. <br><br>  √Ä ce stade, la d√©soptimisation se produit. <br><br><img src="https://habrastorage.org/webt/h4/bf/d-/h4bfd-9twvmsqlk-euvv34he48u.jpeg"><br><br>  Ainsi, l'interpr√©teur a √©t√© remplac√© par le compilateur.  Le diagramme ci-dessus semble avoir un pipeline tr√®s simple.  En r√©alit√©, tout est un peu diff√©rent. <br><br><img src="https://habrastorage.org/webt/zp/ma/oo/zpmaoosvxia3btjyxstyyaq5nnc.jpeg"><br><br>  C'√©tait jusqu'√† l'ann√©e derni√®re.  L'ann√©e derni√®re, vous avez entendu de nombreux rapports de Google selon lesquels ils avaient lanc√© un nouveau pipeline avec TurboFan et maintenant le sch√©ma semble plus simple. <br><br><img src="https://habrastorage.org/webt/qz/wo/2x/qzwo2xg_2ju3fafi6hb4y8ssm24.jpeg"><br><br>  Fait int√©ressant, un interpr√®te est apparu ici. <br><br><img src="https://habrastorage.org/webt/w5/tu/u4/w5tuu4i3irrzbsck7e2ohdnzgai.jpeg"><br><br>  Un interpr√©teur est n√©cessaire pour transformer un arbre de syntaxe abstraite en bytecode et transmettre le bytecode √† un compilateur.  En cas de d√©soptimisation, il se rend √† nouveau chez l'interpr√®te. <br><br><h2>  <strong>Ignition de l'interpr√®te</strong> </h2><br>  Auparavant, il n'existait pas de sch√©ma d'interpr√©teur Ignition.  Google a d'abord d√©clar√© qu'un interpr√®te n'√©tait pas n√©cessaire - JavaScript est d√©j√† suffisamment compact et interpr√©table - nous ne gagnerons rien. <br><br>  Mais l'√©quipe qui a travaill√© avec des applications mobiles a rencontr√© le probl√®me suivant. <br><br><img src="https://habrastorage.org/webt/7e/ms/yd/7emsydqevnntiujqhsa_rtrvdec.jpeg"><br><br>  En 2013-2014, les gens ont commenc√© √† utiliser des appareils mobiles pour acc√©der √† Internet plus souvent que le bureau.  Fondamentalement, ce n'est pas un iPhone, mais des appareils plus simples - ils ont peu de m√©moire et un processeur faible. <br><br><img src="https://habrastorage.org/webt/8b/0l/zi/8b0lzi2wb8mqqbsetc88t2lsale.jpeg"><br><br>  Ci-dessus est un graphique de l'analyse initiale de 1 Mo de code avant de d√©marrer l'interpr√©teur.  On peut voir que le bureau gagne beaucoup.  L'iPhone n'est pas mal non plus, mais il a un moteur diff√©rent, et nous parlons de V8, qui fonctionne dans Chrome. <br><br><blockquote>  Saviez-vous que si vous installez Chrome sur l'iPhone, cela fonctionnera toujours sur JavaScriptCore? </blockquote><br>  Ainsi, le temps est perdu - et ce n'est qu'une analyse, pas une ex√©cution - votre fichier a √©t√© charg√©, et il essaie de comprendre ce qui y est √©crit. <br><img src="https://habrastorage.org/webt/kx/kv/l5/kxkvl5nr4j2cxe5d6kuhwegffnk.jpeg"><br><br>  Lorsque la d√©soptimisation se produit, vous devez reprendre le code source, c'est-√†-dire  il doit √™tre stock√© quelque part.  Cela a pris beaucoup de m√©moire. <br><br>  L'interpr√®te avait donc deux t√¢ches: <br><br><ol><li>  r√©duire l'analyse des frais g√©n√©raux; <br></li><li>  r√©duire la consommation de m√©moire. <br></li></ol><br>  Les t√¢ches ont √©t√© r√©solues en passant √† un interpr√©teur de bytecode. <br><img src="https://habrastorage.org/webt/yr/ky/sk/yrkyskmi_annr0w3jnps13y5alc.jpeg"><br><br>  <strong>Bytecode dans Chrome est une machine d'enregistrement avec une batterie</strong> .  SpiderMonkey a une machine empil√©e, l√† toutes les donn√©es sont sur la pile, mais il n'y a pas de registres.  Les voici. <br><br>  Nous n'analyserons pas compl√®tement comment cela fonctionne, il suffit de regarder le fragment de code. <br><br><img src="https://habrastorage.org/webt/vu/is/fh/vuisfhp0lin_et7pozzqny-g6q0.jpeg"><br><br>  Il dit ici: prenez la valeur qui se trouve dans la batterie et ajoutez-la √† la valeur qui se trouve dans le registre <strong>a0</strong> , c'est-√†-dire dans la variable <strong>a</strong> .  On ne sait encore rien sur les types ici.  S'il s'agissait d'un v√©ritable code assembleur, il serait √©crit en comprenant quel type de d√©calage se trouve dans la m√©moire, ce qui s'y trouve.  Voici juste une instruction - prenez ce qui se trouve dans le registre <strong>a0</strong> et ajoutez-le √† la valeur qui se trouve dans la batterie. <br><br>  Bien s√ªr, l'interpr√©teur ne prend pas simplement l'arbre de syntaxe abstraite et le traduit en bytecode. <br><img src="https://habrastorage.org/webt/vv/4g/i6/vv4gi6zw_zrtlsgl5lsb7ebqqza.jpeg"><br><br>  Il existe √©galement des optimisations, par exemple, l'√©limination du code mort. <br>  Si une section de code n'est pas appel√©e, elle est jet√©e et n'est pas stock√©e davantage.  Si Ignition voit l'ajout de deux nombres, il les ajoute et les laisse de mani√®re √† ne pas stocker d'informations inutiles.  Ce n'est qu'apr√®s cela que le bytecode est obtenu. <br><br><h2>  <strong>Optimisation et d√©soptimisation</strong> </h2><br><h3>  Fonctions froides et chaudes </h3><br>  C'est le sujet le plus simple. <br><br>  Les fonctions froides sont celles qui ont √©t√© appel√©es une fois ou pas du tout, les fonctions chaudes sont celles qui ont √©t√© appel√©es plusieurs fois.  Il est impossible de dire exactement combien de fois - √† tout moment cela peut √™tre refait.  Mais √† un moment donn√©, la fonction devient chaude, et le moteur comprend qu'elle doit √™tre optimis√©e. <br><br><img src="https://habrastorage.org/webt/mk/1t/vr/mk1tvrgq5h2l7mp72g4p6vg6wlm.jpeg"><br><br>  Le sch√©ma de travail. <br><br><ul><li>  Ignition (interpr√®te) recueille des informations.  Il convertit non seulement JavaScript en bytecode, mais comprend √©galement quels types sont entr√©s, quelles fonctions sont devenues chaudes, et il raconte tout cela au compilateur. </li><li>  Il y a une optimisation. </li><li>  Le compilateur ex√©cute le code.  Tout fonctionne bien, mais ici arrive un type auquel il ne s'attendait pas, il n'a pas de code pour fonctionner avec ce type. </li><li>  La d√©soptimisation se produit.  Le compilateur acc√®de √† l'interpr√©teur Ignition pour ce code. </li></ul><br>  Il s'agit d'un cycle normal qui se produit tout le temps, mais il n'est pas infini.  √Ä un moment donn√©, le moteur dit: ¬´Non, il est impossible d'optimiser¬ª et commence √† s'ex√©cuter sans optimisation.  Il est important de comprendre que le monomorphisme doit √™tre observ√©. <br><br>  <strong>Le monomorphisme,</strong> c'est quand les m√™mes types viennent toujours √† l'entr√©e de votre fonction.  Autrement dit, si vous obtenez tout le temps de la cha√Æne, vous n'avez pas besoin de passer de bool√©en √† cet endroit. <br><br>  Mais que faire des objets?  Les objets sont tous des objets.  Nous avons des cours, mais ils ne sont pas r√©els - c'est juste du sucre sur le mod√®le prototype.  Mais √† l'int√©rieur du moteur, il existe des classes dites cach√©es. <br><br><h3>  Classes cach√©es </h3><br>  Il existe des classes cach√©es dans tous les moteurs, pas seulement dans la V8.  Partout o√π ils sont appel√©s diff√©remment, en termes de V8 c'est Map. <br><br>  Tous les objets que vous avez cr√©√©s ont des classes masqu√©es.  Si vous <br>  regardez le profileur de m√©moire, vous verrez qu'il y a des √©l√©ments o√π la liste des √©l√©ments est stock√©e, des propri√©t√©s o√π la propri√©t√© est stock√©e et une carte (g√©n√©ralement le premier param√®tre), o√π un lien vers elle est indiqu√© sur sa classe cach√©e. <br><br>  Map d√©crit la structure des objets, car en principe, en JavaScript, la frappe n'est possible que structurelle, pas nominale.  Nous pouvons d√©crire √† quoi ressemble notre objet, √† quoi il sert. <br><br>  Lorsque vous supprimez / ajoutez des propri√©t√©s d'objets de classes cach√©es, l'objet change, un nouveau est affect√©.  Regardons le code. <br><img src="https://habrastorage.org/webt/4i/ia/bs/4iiabsuemjg-7nu0yiywvlsd9hc.jpeg"><br><br>  Nous avons un constructeur qui cr√©e un nouvel objet de type Point. <br><br><ul><li>  Cr√©ez un objet. </li><li>  Liez-lui une classe cach√©e, ce qui indique qu'il s'agit d'un objet de type Point. </li><li>  Nous avons ajout√© le champ x - une nouvelle classe cach√©e qui dit que c'est un objet de type Point, dans lequel la valeur x vient en premier. </li><li>  Ajout de y - les nouvelles classes Hidden, dans lesquelles x, puis y. </li><li>  Cr√©√© un autre objet - la m√™me chose se produit.  Autrement dit, il lie √©galement ce qui a d√©j√† √©t√© cr√©√©.  En ce moment, ces deux objets sont du m√™me type (via les classes Hidden). </li><li>  Lorsqu'un nouveau champ est ajout√© au deuxi√®me objet, une nouvelle classe Hidden appara√Æt dans l'objet.  Maintenant, pour le moteur p1 et p2, ce sont des objets de classes diff√©rentes, car ils ont des structures diff√©rentes </li><li>  Si vous transf√©rez le premier objet quelque part, alors lorsque vous transf√©rez le second l√†-bas, la d√©soptimisation se produira.  La premi√®re fait r√©f√©rence √† une classe cach√©e, la seconde √† une autre. </li></ul><br>  <strong>Comment puis-je v√©rifier les classes cach√©es?</strong> <br><br>  Dans Node.js, vous pouvez ex√©cuter node ‚Äîallow-natives-syntax.  Ensuite, vous aurez la possibilit√© d'√©crire des commandes dans une syntaxe sp√©ciale, qui, bien s√ªr, ne peut pas √™tre utilis√©e en production.  Cela ressemble √† ceci: <br><br><pre> <code class="javascript hljs">%HaveSameMap({<span class="hljs-string"><span class="hljs-string">'a'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  Personne ne garantit que demain ces commandes fonctionneront, elles ne sont pas dans la sp√©cification ECMAScript, c'est tout pour le d√©bogage. <br><br>  Selon vous, quel sera le r√©sultat de l'appel de la fonction% HaveSameMap pour deux objets.  La bonne r√©ponse est fausse, car l'une a un champ et l'autre a <strong>b</strong> .  Ce sont des objets diff√©rents.  Ces connaissances peuvent √™tre utilis√©es pour la technique des caches en ligne. <br><br><h3>  Caches en ligne </h3><br>  Nous appelons une fonction tr√®s simple qui renvoie un champ √† partir d'un objet.  Le retour de l'appareil semble √™tre tr√®s simple.  Mais si vous regardez la sp√©cification ECMAScript, vous verrez qu'il y a une √©norme liste de ce que vous devez faire pour obtenir le champ de l'objet.  Car, si le champ n'est pas dans l'objet, il est possible qu'il se trouve dans son prototype.  Peut-√™tre que c'est setter, getter et ainsi de suite.  Tout cela doit √™tre v√©rifi√©. <br><img src="https://habrastorage.org/webt/02/dn/nj/02dnnjtvkqa7fn87e8ioa3kwgpy.jpeg"><br><br>  Dans ce cas, l'objet a un lien vers la carte, qui dit: pour obtenir le champ <strong>x</strong> , vous devez faire un d√©calage d'un, et nous obtenons <strong>x</strong> .  Vous n'avez pas √† grimper n'importe o√π, dans tous les prototypes, tout est √† proximit√©.  Les caches en ligne l'utilisent. <br><br><img src="https://habrastorage.org/webt/ck/53/ny/ck53nyrhuj7ihixe7vi7ds_vjvc.jpeg"><br><br><ul><li>  Si on appelle la fonction pour la premi√®re fois, tout va bien, l'interpr√®te a fait l'optimisation </li><li>  Pour le deuxi√®me appel, un √©tat monomorphe est enregistr√©. </li><li>  J'appelle la fonction une troisi√®me fois, je passe un objet l√©g√®rement diff√©rent {x: 3, y: 1}.  La d√©soptimisation se produit, si elle appara√Æt, nous entrons dans un √©tat polymorphe.  Maintenant, le code qui ex√©cute cette fonction sait que deux types d'objets diff√©rents peuvent y voler. </li><li>  Si nous passons plusieurs objets diff√©rents plusieurs fois, il reste dans un √©tat polymorphe, ajoutant de nouveaux ifs.  Mais √† un moment donn√©, il se rend et entre dans un √©tat m√©gamorphique, c'est-√†-dire  quand: "Trop de types diff√©rents arrivent √† l'entr√©e - je ne sais pas comment l'optimiser!" </li></ul><br>  Il semble que maintenant 4 √©tats polymorphes soient autoris√©s, mais demain il y en aura peut-√™tre 8. Ceci est d√©cid√© par les d√©veloppeurs du moteur.  Il vaut mieux rester dans un √©tat monomorphe, dans les cas extr√™mes, polymorphe.  La transition entre les √©tats monomorphes et polymorphes est co√ªteuse, car vous devrez aller √† l'interpr√©teur, r√©cup√©rer le code et l'optimiser √† nouveau. <br><br><h3>  Tableaux </h3><br>  En JavaScript, outre les tableaux typ√©s sp√©cifiques, il existe un type <br>  tableau.  Il y en a 6 dans le moteur V8: <br><br>  1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS - juste un tableau compact de petits nombres entiers.  Il y a des optimisations pour lui. <br><br>  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS - un tableau compact d'√©l√©ments doubles, il y a aussi des optimisations pour lui, mais plus lentes. <br><br>  3. [1, 2, 3, 4, 'X'] // PACKED_ELEMENTS - un tableau compress√© dans lequel il y a des objets, des cha√Ænes et tout le reste.  Pour lui aussi, il y a des optimisations. <br><br>  Les trois types suivants sont des tableaux du m√™me type que les trois premiers, mais avec des trous: <br><br>  4. [1, / * trou * /, 2, / * trou * /, 3, 4] // HOLEY_SMI_ELEMENTS <br><br>  5. [1.2, / * trou * /, 2, / * trou * /, 3,4] // HOLEY_DOUBLE_ELEMENTS <br><br>  6. [1, / * trou * /, 'X'] // HOLEY_ELEMENTS <br><br>  Lorsque des trous apparaissent dans vos tableaux, les optimisations deviennent moins efficaces.  Ils commencent √† mal fonctionner, car il est impossible de parcourir ce tableau d'affil√©e, en triant les it√©rations.  Chaque type suivant est moins optimis√© <br><br><img src="https://habrastorage.org/webt/qb/rw/zf/qbrwzflusrdjbboqwgsth1ezozu.jpeg"><br><br>  Dans le diagramme, tout ce qui pr√©c√®de est optimis√© plus rapidement.  Autrement dit, toutes vos m√©thodes natives - mapper, r√©duire, trier - √† l'int√©rieur sont bien optimis√©es.  Mais avec chaque type, l'optimisation empire. <br><br>  Par exemple, un simple tableau [ <strong>1</strong> , <strong>2</strong> , <strong>3</strong> ] est entr√© en entr√©e (petit entier de type paquet).  Nous avons l√©g√®rement chang√© ce tableau en lui ajoutant un double - nous sommes pass√©s √† l'√©tat PACKED_DOUBLE_ELEMENTS.  Ajoutez-y un objet - passez √† l'√©tat suivant, le rectangle vert PACKED_ELEMENTS.  Ajoutez-y des trous - passez √† l'√©tat HOLEY_ELEMENTS.  Nous voulons le restaurer √† son √©tat pr√©c√©dent afin qu'il redevienne "bon" - nous supprimons tout ce que nous avons √©crit et restons dans le m√™me √©tat ... avec des trous!  Autrement dit, HOLEY_ELEMENTS en bas √† droite du diagramme.  Retour cela ne fonctionne pas.  Vos tableaux ne peuvent qu'empirer, mais pas l'inverse. <br><br><h2>  <strong>Objet de type tableau</strong> </h2><br>  Nous rencontrons souvent des objets de type tableau - ce sont des objets qui ressemblent √† des tableaux parce qu'ils ont un signe de longueur.  En fait, ils sont comme un chat pirate, c'est-√†-dire qu'ils semblent √™tre similaires, mais dans l'efficacit√© de la consommation de rhum, un chat sera pire qu'un pirate.  De m√™me, un objet de type tableau ressemble √† un tableau, mais n'est pas efficace. <br><img src="https://habrastorage.org/webt/uf/f4/u_/uff4u_bbjb3elwmhhor3lv2tiwm.jpeg"><br><br>  Nos deux objets de type tableau pr√©f√©r√©s sont les arguments et document.querySelectorAII.  Il y a de si belles choses fonctionnelles. <br><img src="https://habrastorage.org/webt/i7/_j/ul/i7_juluulfkpnerhxwnif4tjnoa.jpeg"><br><br>  Nous avons obtenu une carte - nous l'avons extraite du prototype et, apparemment, nous pouvons l'utiliser.  Mais si aucun tableau n'est venu √† son entr√©e, il n'y aura pas d'optimisation.  Notre moteur n'est pas en mesure d'optimiser les objets. <br><br>  Que faut-il faire? <br><br><ul><li>  L'option old-school - via slice.call () se transforme en un v√©ritable tableau. </li><li>  L'option moderne est encore meilleure: √©crire (... reste), obtenir un tableau propre - pas des arguments - tout va bien! </li></ul><br>  Avec querySelectorAll la m√™me chose - en raison de la propagation, nous pouvons le transformer en un tableau √† part enti√®re et travailler avec toutes les optimisations. <br><br><h2>  <strong>Grands tableaux</strong> </h2><br><blockquote>  <strong>Devinette:</strong> nouveau tableau (1000) vs tableau = [] <br>  Quelle option est la meilleure: cr√©er imm√©diatement un grand tableau et le remplir de 1000 objets en boucle, ou en cr√©er un vide et le remplir progressivement? <br></blockquote><br>  <strong>Bonne r√©ponse:</strong> d√©pend de. <br><br>  Quelle est la diff√©rence? <br><br><ul><li>  Lorsque nous cr√©ons un tableau de la premi√®re mani√®re et remplissons 1000 √©l√©ments, nous cr√©ons 1000 trous.  Ce tableau ne sera pas optimis√©.  Mais il √©crira rapidement. <br></li><li>  En cr√©ant un tableau selon la deuxi√®me variante, un peu de m√©moire est allou√©e, on √©crit, par exemple, 60 √©l√©ments, un peu plus de m√©moire est allou√©e, etc. </li></ul><br>  Autrement dit, dans le premier cas, nous √©crivons rapidement - nous travaillons lentement;  dans la seconde, nous √©crivons lentement - nous travaillons rapidement. <br><br><h2>  <strong>Collecteur d'ordures</strong> </h2><br>  Le garbage collector mange aussi un peu de temps et de ressources.  Sans plonger profond√©ment, je donnerai la base la plus courante. <br><br><img src="https://habrastorage.org/webt/fg/8e/1c/fg8e1csx9x1mo4y2hlvuzzjvgem.jpeg"><br><br>  Notre mod√®le g√©n√©ratif a un <strong>espace d'objets jeunes et vieux</strong> .  L'objet cr√©√© tombe dans l'espace des jeunes objets.  Apr√®s un certain temps, le nettoyage commence.  Si l'objet ne peut pas √™tre atteint par des liens √† partir de la racine, il peut √™tre collect√© √† la poubelle.  Si l'objet est toujours utilis√©, il se d√©place vers l'espace des anciens objets, qui est moins fr√©quemment nettoy√©.  Cependant, √† un certain point, les anciens objets sont supprim√©s. <br><img src="https://habrastorage.org/webt/ac/rd/1l/acrd1lqmylajg5b3crff97j-9h8.jpeg"><br><br>  Voici comment fonctionne un ramasse-miettes automatique - il nettoie les objets sur la base qu'il n'y a aucun lien vers eux.  Ce sont deux algorithmes diff√©rents. <br><br><ol><li>  <strong>Le nettoyage</strong> est rapide mais pas efficace. <br></li><li>  <strong>Mark-Sweep</strong> est lent mais efficace. <br></li></ol><br>  Si vous commencez √† profiler la consommation de m√©moire dans Node.js, vous obtenez quelque chose comme √ßa. <br><br><img src="https://habrastorage.org/webt/yp/uj/1b/ypuj1bus74-w473vsmczkvgwi0s.jpeg"><br><br>  Au d√©but, il cro√Æt brusquement - c'est le travail de l'algorithme Scavenge.  Ensuite, une forte baisse se produit - cet algorithme Mark-Sweep a collect√© des ordures dans l'espace des anciens objets.  En ce moment, tout commence √† ralentir un peu.  <strong>Vous ne pouvez pas le contr√¥ler</strong> , car vous ne savez pas quand cela se produira.  Vous ne pouvez ajuster que les tailles. <br><br>  Par cons√©quent, le pipeline a une √©tape de r√©cup√©ration de place qui consomme du temps. <br><br><img src="https://habrastorage.org/webt/zi/_3/ya/zi_3yao0kydtrtagdizs4oklcr0.jpeg"><br><br><h2>  <strong>Encore plus vite?</strong> </h2><br>  Regardons l'avenir.  Que faire ensuite, comment √™tre plus rapide? <br><img src="https://habrastorage.org/webt/ts/vc/fz/tsvcfzihzzewt_udo-39cjqea8c.jpeg"><br><br>  Sur cette ligne, les tailles de bloc sont √† peu pr√®s li√©es dans le temps qu'il faut. <br><br>  La premi√®re chose qui vient √† l'esprit pour les personnes qui ont entendu parler du bytecode - soumettre imm√©diatement un bytecode √† l'entr√©e et le d√©coder, plut√¥t que de l'analyser - sera plus rapide! <br><br><img src="https://habrastorage.org/webt/7i/lf/xd/7ilfxdfdm0dbkdknw0ecpushflo.jpeg"><br><br>  Le probl√®me est que le bytecode est diff√©rent maintenant.  Comme je l'ai dit: dans Safari un, dans FireFox un autre, dans Chrome troisi√®me.  N√©anmoins, les d√©veloppeurs de Mozilla, Bloomberg et Facebook ont ‚Äã‚Äãpr√©sent√© une telle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">proposition</a> , mais c'est l'avenir. <br><br>  Il y a un autre probl√®me - la compilation, l'optimisation et la r√©optimisation, si le compilateur n'a pas devin√©.  Imaginez qu'il y ait un langage typ√© √† l'entr√©e qui produit un code efficace, ce qui signifie que la r√©optimisation n'est plus n√©cessaire, car ce que nous avons obtenu est d√©j√† efficace.  Une telle entr√©e ne peut √™tre compil√©e et optimis√©e qu'une seule fois.  Le code r√©sultant sera plus efficace et s'ex√©cutera plus rapidement. <br><br>  Que peut-on faire d'autre?  Imaginez que ce langage poss√®de une gestion manuelle de la m√©moire.  Ensuite, vous n'avez pas besoin d'un ramasse-miettes.  La ligne est devenue plus courte et plus rapide. <br><br><img src="https://habrastorage.org/webt/e0/36/ut/e036utlk16ybet20xbica5qziey.jpeg"><br><br>  Devinez √† quoi √ßa ressemble?  <strong>WebAssembly</strong> environ <br>  voici comment cela fonctionne: gestion manuelle de la m√©moire, saisie statique <br>  langues et ex√©cution rapide. <br><img src="https://habrastorage.org/webt/qf/cd/8h/qfcd8hamo_iv_fznbksf35whw9q.jpeg"><br><br>  WebAssembly est-il une solution miracle? <br><img src="https://habrastorage.org/webt/ke/ip/pd/keippdq9hmpt3ueb7-kgd-zt1ig.jpeg"><br><br>  Non, car il signifie JavaScript.  WASM ne peut encore rien faire.  Il n'a pas acc√®s √† l'API DOM.  C'est √† l'int√©rieur du moteur JavaScript - √† l'int√©rieur du m√™me moteur!  Il fait tout via JavaScript, donc <strong>WASM n'acc√©l√©rera pas votre code</strong> .  Cela peut acc√©l√©rer les calculs individuels, mais votre √©change entre JavaScript et WASM sera un goulot d'√©tranglement. <br><br>  Par cons√©quent, alors que notre langage est JavaScript et seulement lui, et un peu d'aide de la bo√Æte noire. <br><br><h2>  <strong>Total</strong> </h2><br>  On peut distinguer trois types d'optimisation. <br><br>  ‚óè <strong>Optimisations algorithmiques</strong> <br><br>  Il y a un article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Peut-√™tre que vous n'avez pas besoin de Rust pour acc√©l√©rer votre JS</a> " par Vyacheslav Egorov, qui a autrefois d√©velopp√© V8 et d√©veloppe maintenant Dart.  Racontez bri√®vement son histoire. <br><br>  Il y avait une biblioth√®que JavaScript qui ne fonctionnait pas tr√®s rapidement.  Certains gars l'ont r√©√©crit dans Rust, compil√© et obtenu WebAssembly, et l'application a commenc√© √† fonctionner plus rapidement.  Vyacheslav Egorov en tant que d√©veloppeur JS exp√©riment√© a d√©cid√© d'y r√©pondre.  Il a appliqu√© des optimisations algorithmiques et la solution JavaScript est devenue beaucoup plus rapide que la solution Rust.  √Ä leur tour, ces gars-l√† ont vu cela, ont fait les m√™mes optimisations et ont gagn√© √† nouveau, mais pas beaucoup - cela d√©pend du moteur: dans Mozilla, ils ont gagn√©, dans Chrome, non. <br><br>  Aujourd'hui, nous n'avons pas parl√© d'optimisations algorithmiques, et les rendus frontaux n'en parlent g√©n√©ralement pas.  C'est tr√®s mauvais, car les <strong>algorithmes permettent √©galement au code de s'ex√©cuter plus rapidement</strong> .  Vous supprimez simplement les cycles dont vous n'avez pas besoin. <br><br>  ‚óè <strong>Optimisations sp√©cifiques √† la langue</strong> <br><br>  C'est ce dont nous avons parl√© aujourd'hui: notre langage est interpr√©t√© dynamiquement typ√©.  Comprendre le fonctionnement des tableaux, des objets et du monomorphisme <strong>vous permet d'√©crire du code efficace</strong> .  Cela doit √™tre connu et √©crit correctement. <br><br>  ‚óè <strong>Optimisations sp√©cifiques au moteur</strong> <br><br>  Ce sont les optimisations les plus dangereuses.  Si votre d√©veloppeur tr√®s intelligent, mais pas tr√®s sociable, qui a appliqu√© beaucoup de telles optimisations et n'en a parl√© √† personne, n'a pas √©crit la documentation, alors si vous ouvrez le code, vous ne verrez pas JavaScript, mais, par exemple, Crankshaft Script.  Autrement dit, JavaScript √©crit avec une compr√©hension approfondie du fonctionnement du moteur de vilebrequin il y a deux ans.  Tout fonctionne, mais maintenant il n'est plus n√©cessaire. <br><br>  Par cons√©quent, ces optimisations doivent n√©cessairement √™tre document√©es, couvertes de tests prouvant leur efficacit√© √† l'heure actuelle.  Ils doivent √™tre surveill√©s.  Vous devez vous y rendre uniquement au moment o√π vous avez vraiment ralenti quelque part - vous ne pouvez tout simplement pas vous passer de conna√Ætre des appareils aussi profonds.  Par cons√©quent, la c√©l√®bre phrase de Donald Knuth semble logique. <br><img src="https://habrastorage.org/webt/yx/xo/1u/yxxo1uda9lkq9fim_uy9zzylxlw.jpeg"><br><br>  Pas besoin d'essayer de mettre en ≈ìuvre des optimisations dures, simplement parce que vous avez lu des critiques positives √† leur sujet. <br><br>  Il faut avoir peur de telles optimisations, s'assurer de documenter et de laisser des m√©triques.  G√©n√©ralement, collectez toujours des m√©triques.  <strong>Les m√©triques sont importantes!</strong> <br><br>  <strong>Liens utiles:</strong> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©sum√©s et pr√©sentation du rapport</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'en est-il du monomorphisme?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce qui rend WebAssembly rapide?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment comprendre le bytecode V8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Devshacht: Hardcore</a> </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf Moscow</a> <strong>4  5 </strong>               . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> <strong> 15 </strong> ,  ,     : <br><br><ul><li> <strong> </strong> (KeepSolid)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,    Offline First    Persistent Storage </li><li> <strong> </strong> (TradingView)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>    WebGL  WebAssembly  ,        ,  <strong>  API</strong> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <strong> </strong>  ,          Google Docs. <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417459/">https://habr.com/ru/post/fr417459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417447/index.html">Exp√©dition dans les myst√©rieux cercles de f√©es du d√©sert du Namib</a></li>
<li><a href="../fr417449/index.html">Jurassic World: pouvons-nous vraiment ressusciter des dinosaures?</a></li>
<li><a href="../fr417451/index.html">Cinq erreurs courantes pour les d√©butants</a></li>
<li><a href="../fr417453/index.html">Organisation de stages pour √©tudiants: r√¢teau et astuces</a></li>
<li><a href="../fr417457/index.html">Frontend Conf Moscow - c√¥t√© client entrant et sortant</a></li>
<li><a href="../fr417461/index.html">Ivan Tulup: asynchrone en JS sous le capot</a></li>
<li><a href="../fr417463/index.html">Une rencontre inattendue. Chapitre 17</a></li>
<li><a href="../fr417465/index.html">Un aper√ßu des m√©thodes de liaison de texte</a></li>
<li><a href="../fr417469/index.html">Cinq raisons √©go√Østes de travailler de mani√®re reproductible</a></li>
<li><a href="../fr417471/index.html">Simple Solder MK936 SMD. Station de soudage DIY pour composants CMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>