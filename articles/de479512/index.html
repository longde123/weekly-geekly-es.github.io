<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚ÄçüöÄ ‚òÄÔ∏è ü§∞üèº MVCC in PostgreSQL-4. Schnappsch√ºsse üîÉ üöè üç∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem wir Isolationsprobleme besprochen und einen Exkurs in Bezug auf die Datenstruktur auf niedriger Ebene gemacht hatten , untersuchten wir das le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-4. Schnappsch√ºsse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/">  Nachdem wir <a href="https://habr.com/ru/company/postgrespro/blog/467437/">Isolationsprobleme</a> besprochen und einen Exkurs in Bezug auf die <a href="https://habr.com/ru/company/postgrespro/blog/469087/">Datenstruktur</a> auf <a href="https://habr.com/ru/company/postgrespro/blog/469087/">niedriger Ebene gemacht hatten</a> , untersuchten wir das letzte Mal <a href="https://habr.com/ru/company/postgrespro/blog/477648/">Zeilenversionen</a> und beobachteten, wie verschiedene Operationen Tupel-Header-Felder ver√§nderten. <br><br>  Nun werden wir untersuchen, wie konsistente Datenschnappsch√ºsse von Tupeln erhalten werden. <br><br><h1>  Was ist ein Datenschnappschuss? </h1><br>  Datenseiten k√∂nnen physisch mehrere Versionen derselben Zeile enthalten.  Jede Transaktion darf jedoch nur eine (oder keine) Version jeder Zeile enthalten, damit alle zu einem bestimmten Zeitpunkt ein konsistentes Bild der Daten (im Sinne von ACID) ergeben. <br><br>  Die Isolation in PosgreSQL basiert auf Snapshots: Jede Transaktion verwendet einen eigenen Daten-Snapshot, der Daten enth√§lt, die vor der Erstellung des Snapshots festgeschrieben wurden, und keine Daten enth√§lt, die zu diesem Zeitpunkt noch nicht festgeschrieben wurden.  Wir haben <a href="https://habr.com/ru/company/postgrespro/blog/467437/">bereits gesehen</a> , dass die resultierende Isolation zwar strenger als vom Standard gefordert erscheint, aber immer noch Anomalien aufweist. <br><a name="habracut"></a><br>  Auf der Isolationsstufe Read Committed wird zu Beginn jeder Transaktionsanweisung ein Snapshot erstellt.  Dieser Schnappschuss ist aktiv, w√§hrend die Anweisung ausgef√ºhrt wird.  In der Abbildung ist der Moment der Erstellung des Snapshots (der, wie wir uns erinnern, durch die Transaktions-ID bestimmt wird) blau dargestellt. <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br>  Auf den Ebenen Repeatable Read und Serializable wird der Snapshot einmal am Anfang der ersten Transaktionsanweisung erstellt.  Ein solcher Schnappschuss bleibt bis zum Ende der Transaktion aktiv. <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1>  Sichtbarkeit von Tupeln in einem Schnappschuss </h1><br><h2>  Sichtbarkeitsregeln </h2><br>  Ein Snapshot ist sicherlich keine physische Kopie aller notwendigen Tupel.  Ein Snapshot wird tats√§chlich durch mehrere Zahlen angegeben, und die Sichtbarkeit von Tupeln in einem Snapshot wird durch Regeln bestimmt. <br><br>  Ob ein Tupel in einem Snapshot sichtbar ist oder nicht, h√§ngt von zwei Feldern in der Kopfzeile ab, n√§mlich <code>xmin</code> und <code>xmax</code> , <code>xmax</code> den IDs der Transaktionen, mit denen das Tupel erstellt und gel√∂scht wurde.  Intervalle wie dieses √ºberlappen sich nicht und daher repr√§sentiert nicht mehr als eine Version eine Zeile in jedem Snapshot. <br><br>  Die genauen Sichtbarkeitsregeln sind ziemlich kompliziert und ber√ºcksichtigen viele verschiedene F√§lle und Extreme. <br><blockquote>  Sie k√∂nnen dies auf einfache Weise sicherstellen, indem Sie in src / backend / utils / time / tqual.c nachsehen (in Version 12 wurde das H√§kchen nach src / backend / access / heap / heapam_visibility.c verschoben). <br></blockquote><br>  Der <code>xmin</code> k√∂nnen wir sagen, dass ein Tupel sichtbar ist, wenn im Snapshot die von der Transaktion <code>xmin</code> vorgenommenen √Ñnderungen sichtbar sind, w√§hrend die von der Transaktion <code>xmax</code> vorgenommenen <code>xmax</code> nicht sichtbar sind (mit anderen Worten, es ist bereits klar, dass das Tupel erstellt wurde, aber es ist noch nicht klar, ob es gel√∂scht wurde). <br><br>  In Bezug auf eine Transaktion sind ihre √Ñnderungen im Snapshot sichtbar, entweder wenn es genau die Transaktion ist, die den Snapshot erstellt hat (es werden die eigenen noch nicht festgeschriebenen √Ñnderungen angezeigt), oder die Transaktion wurde festgeschrieben, bevor der Snapshot erstellt wurde. <br><br>  Wir k√∂nnen Transaktionen nach Segmenten grafisch darstellen (von der Startzeit bis zur Festschreibungszeit): <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br>  Hier: <br><br><ul><li>  √Ñnderungen der Transaktion 2 sind sichtbar, seit sie abgeschlossen wurden, bevor der Snapshot erstellt wurde. </li><li>  √Ñnderungen der Transaktion 1 sind nicht sichtbar, da sie zum Zeitpunkt der Erstellung des Snapshots aktiv war. </li><li>  √Ñnderungen der Transaktion 3 sind nicht sichtbar, da sie nach dem Erstellen des Snapshots gestartet wurde (unabh√§ngig davon, ob sie abgeschlossen wurde oder nicht). </li></ul><br>  Leider ist dem System der Festschreibungszeitpunkt von Transaktionen nicht bekannt.  Es ist nur die Startzeit bekannt (die durch die Transaktions-ID bestimmt und in den obigen Abbildungen mit einer gestrichelten Linie gekennzeichnet ist), der Abschluss wird jedoch nirgendwo geschrieben. <br><br>  Alles, was wir tun k√∂nnen, ist, den <em>aktuellen</em> Status der Transaktionen bei der Snapshot-Erstellung herauszufinden.  Diese Informationen stehen im gemeinsamen Speicher des Servers in der ProcArray-Struktur zur Verf√ºgung, die die Liste aller aktiven Sitzungen und ihrer Transaktionen enth√§lt. <br><br>  Wir k√∂nnen jedoch post factum nicht herausfinden, ob eine bestimmte Transaktion zum Zeitpunkt der Erstellung des Snapshots aktiv war oder nicht.  Daher muss in einem Snapshot eine Liste aller derzeit aktiven Transaktionen gespeichert werden. <br><br>  Aus dem oben Gesagten folgt, dass es in PostgreSQL nicht m√∂glich ist, einen Snapshot zu erstellen, der ab einem bestimmten Zeitpunkt konsistente Daten anzeigt, <em>selbst wenn</em> alle erforderlichen Tupel auf Tabellenseiten verf√ºgbar sind.  Oft stellt sich die Frage, warum es in PostgreSQL an retrospektiven (oder zeitlichen oder Flashback-, wie Oracle sie nennt) Abfragen mangelt - und dies ist einer der Gr√ºnde. <br><blockquote>  Ein bisschen komisch ist, dass diese Funktionalit√§t zuerst verf√ºgbar war, dann aber aus dem DBMS gel√∂scht wurde.  Lesen Sie dazu den <a href="https://arxiv.org/pdf/1901.01973.pdf">Artikel von Joseph M. Hellerstein</a> . <br></blockquote><br>  Der Schnappschuss wird also von mehreren Parametern bestimmt: <br><br><ul><li>  In dem Moment, in dem der Snapshot erstellt wurde, genauer gesagt, die ID der n√§chsten Transaktion, die im System noch nicht verf√ºgbar ist ( <code>snapshot.xmax</code> ). </li><li>  Die Liste der aktiven (in Bearbeitung befindlichen) Transaktionen zum Zeitpunkt der Erstellung des Snapshots ( <code>snapshot.xip</code> ). </li></ul><br>  Zur Vereinfachung und Optimierung wird auch die ID der fr√ºhesten aktiven Transaktion gespeichert ( <code>snapshot.xmin</code> ).  Dieser Wert ergibt einen wichtigen Sinn, auf den weiter unten eingegangen wird. <br><br>  Der Schnappschuss speichert auch einige weitere Parameter, die f√ºr uns jedoch unwichtig sind. <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2>  Beispiel </h2><br>  Um zu verstehen, wie der Schnappschuss die Sichtbarkeit bestimmt, reproduzieren wir das obige Beispiel mit drei Transaktionen.  Die Tabelle wird drei Zeilen haben, wobei: <br><br><ul><li>  Die erste wurde von einer Transaktion hinzugef√ºgt, die vor der Snapshot-Erstellung gestartet, danach jedoch abgeschlossen wurde. </li><li>  Die zweite wurde durch eine Transaktion hinzugef√ºgt, die vor der Snapshot-Erstellung gestartet und abgeschlossen wurde. </li><li>  Die dritte wurde nach der Snapshot-Erstellung hinzugef√ºgt. </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br>  Die erste Transaktion (noch nicht abgeschlossen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  Die zweite Transaktion (abgeschlossen, bevor der Snapshot erstellt wurde): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Erstellen eines Snapshots in einer Transaktion in einer anderen Sitzung. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Festschreiben der ersten Transaktion nach dem Erstellen des Snapshots: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und die dritte Transaktion (erschienen, nachdem der Schnappschuss erstellt wurde): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Offensichtlich ist in unserem Schnappschuss nur noch eine Zeile sichtbar: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Die Frage ist, wie Postgres das versteht. <br><br>  Alles wird durch den Schnappschuss bestimmt.  Schauen wir es uns an: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Hier werden <code>snapshot.xmin</code> , <code>snapshot.xmax</code> und <code>snapshot.xip</code> aufgelistet, die durch einen Doppelpunkt getrennt sind ( <code>snapshot.xip</code> ist in diesem Fall eine Zahl, im Allgemeinen jedoch eine Liste). <br><br>  Gem√§√ü den obigen Regeln m√ºssen im Snapshot die √Ñnderungen sichtbar sein, die von Transaktionen mit den IDs <code>xid</code> , sodass <code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code> Ausnahme derjenigen, die in der Liste <code>snapshot.xip</code> .  Sehen wir uns alle Tabellenzeilen an (im neuen Snapshot): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  Die erste Zeile ist nicht sichtbar: Sie wurde von einer Transaktion in der Liste der aktiven Transaktionen erstellt ( <code>xip</code> ). <br>  Die zweite Zeile ist sichtbar: Sie wurde von einer Transaktion erstellt, die sich im Snapshot-Bereich befindet. <br>  Die dritte Zeile ist nicht sichtbar: Sie wurde von einer Transaktion erstellt, die au√üerhalb des Snapshot-Bereichs liegt. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  √Ñnderungen der Transaktion </h1><br>  Das Ermitteln der Sichtbarkeit der eigenen √Ñnderungen der Transaktion erschwert die Situation etwas.  In diesem Fall muss m√∂glicherweise nur ein Teil dieser √Ñnderungen angezeigt werden.  Beispiel: Auf jeder Isolationsstufe darf ein zu einem bestimmten Zeitpunkt ge√∂ffneter Cursor keine √Ñnderungen mehr sehen, die sp√§ter vorgenommen werden. <br><br>  Zu diesem Zweck verf√ºgt ein Tupel-Header √ºber ein spezielles Feld (dargestellt in den <code>cmin</code> und <code>cmax</code> ), das die Auftragsnummer innerhalb der Transaktion anzeigt.  <code>cmin</code> ist die Nummer zum Einf√ºgen und <code>cmax</code> - zum L√∂schen, aber um Platz im <code>cmax</code> zu sparen, ist dies eigentlich ein Feld und nicht zwei verschiedene.  Es wird angenommen, dass eine Transaktion selten dieselbe Zeile einf√ºgt und l√∂scht. <br><br>  In diesem Fall wird eine spezielle Kombinationsbefehls-ID ( <code>combocid</code> ) in dasselbe Feld eingef√ºgt, und der <code>cmin</code> <code>cmax</code> Prozess merkt sich die tats√§chlichen <code>cmax</code> f√ºr <code>cmin</code> und <code>cmax</code> f√ºr diese <code>combocid</code> .  Das ist aber ganz exotisch. <br><br>  Hier ist ein einfaches Beispiel.  Beginnen wir eine Transaktion und f√ºgen der Tabelle eine Zeile hinzu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Lassen Sie uns den Inhalt der Tabelle zusammen mit dem Feld <code>cmin</code> (aber nur f√ºr Zeilen, die von der Transaktion hinzugef√ºgt wurden - f√ºr andere ist dies bedeutungslos): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Jetzt √∂ffnen wir einen Cursor f√ºr eine Abfrage, die die Anzahl der Zeilen in der Tabelle zur√ºckgibt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Und danach f√ºgen wir eine weitere Zeile hinzu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  Die Abfrage gibt 4 zur√ºck - die nach dem √ñffnen des Cursors hinzugef√ºgte Zeile gelangt nicht in den Datenschnappschuss: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Warum?  Weil der Snapshot nur Tupel mit <code>cmin &lt; 1</code> ber√ºcksichtigt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Ereignishorizont </h1><br>  Die ID der fr√ºhesten aktiven Transaktion ( <code>snapshot.xmin</code> ) hat einen wichtigen Sinn: Sie bestimmt den "Ereignishorizont" der Transaktion.  Das hei√üt, √ºber den Horizont hinaus werden f√ºr die Transaktion immer nur aktuelle Zeilenversionen angezeigt. <br><br>  Tats√§chlich muss eine veraltete (Dead) Row-Version nur sichtbar sein, wenn die aktuelle Version durch eine noch nicht abgeschlossene Transaktion erstellt wurde und daher noch nicht sichtbar ist.  Aber alle Transaktionen "jenseits des Horizonts" sind mit Sicherheit abgeschlossen. <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br>  Den Transaktionshorizont sehen Sie im Systemkatalog: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Wir k√∂nnen den Horizont auch auf Datenbankebene definieren.  Dazu m√ºssen wir alle aktiven Schnappsch√ºsse machen und die √§ltesten <code>xmin</code> unter ihnen finden.  Und es definiert den Horizont, ab dem tote Tupel in der Datenbank f√ºr keine Transaktion sichtbar sind.  <em>Solche Tupel k√∂nnen abgesaugt werden</em> - und genau deshalb ist das Konzept des Horizonts aus praktischer Sicht so wichtig. <br><br>  Wenn eine bestimmte Transaktion einen Snapshot f√ºr l√§ngere Zeit enth√§lt, wird dadurch auch der Datenbankhorizont beibehalten.  Dar√ºber hinaus wird nur das Vorhandensein einer nicht abgeschlossenen Transaktion den Horizont bestimmen, auch wenn die Transaktion selbst nicht den Snapshot enth√§lt. <br><br>  Und das bedeutet, dass tote Tupel in der DB nicht weggesaugt werden k√∂nnen.  Dar√ºber hinaus ist es m√∂glich, dass sich eine "Long-Play" -Transaktion mit Daten √ºberhaupt nicht mit anderen Transaktionen √ºberschneidet, was jedoch keine Rolle spielt, da sich alle einen Datenbankhorizont teilen. <br><br>  Wenn wir jetzt ein Segment so einrichten, dass es Snapshots (von <code>snapshot.xmin</code> bis <code>snapshot.xmax</code> ) und keine Transaktionen darstellt, k√∂nnen wir die Situation wie folgt darstellen: <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br>  In dieser Abbildung bezieht sich der niedrigste Snapshot auf eine nicht abgeschlossene Transaktion, und in den anderen Snapshots kann <code>snapshot.xmin</code> nicht gr√∂√üer als die Transaktions-ID sein. <br><br>  In unserem Beispiel wurde die Transaktion mit der Isolationsstufe Read Committed gestartet.  Auch wenn kein aktiver Datenschnappschuss vorhanden ist, wird der Horizont beibehalten: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Und erst nach Abschluss der Transaktion bewegt sich der Horizont vorw√§rts, wodurch tote Tupel abgesaugt werden k√∂nnen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  In dem Fall, dass die beschriebene Situation wirklich Probleme verursacht und es keine M√∂glichkeit gibt, sie auf Anwendungsebene zu umgehen, stehen ab Version 9.6 zwei Parameter zur Verf√ºgung: <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em> bestimmt die maximale Lebensdauer des Snapshots.  Nach Ablauf dieser Zeit kann der Server tote Tupel staubsaugen, und wenn eine "Long-Play" -Transaktion diese noch ben√∂tigt, wird der Fehler "Snapshot zu alt" ausgegeben. </li><li>  <em><code>idle_in_transaction_session_timeout</code></em> bestimmt die maximale Lebensdauer einer <em><code>idle_in_transaction_session_timeout</code></em> Transaktion.  Nach Ablauf dieser Zeit wird die Transaktion abgebrochen. </li></ul><br><h1>  Schnappschussexport </h1><br>  Es kann vorkommen, dass mehrere gleichzeitige Transaktionen garantiert werden m√ºssen, um dieselben Daten anzuzeigen.  Ein Beispiel ist <code>pg_dump</code> Dienstprogramm <code>pg_dump</code> , das im parallelen Modus ausgef√ºhrt werden kann: Alle Arbeitsprozesse m√ºssen die Datenbank im gleichen Status sehen, damit die Sicherungskopie konsistent ist. <br><br>  Nat√ºrlich k√∂nnen wir uns nicht auf die Annahme verlassen, dass f√ºr die Transaktionen dieselben Daten angezeigt werden, nur weil sie "gleichzeitig" gestartet wurden.  Zu diesem Zweck stehen Export und Import eines Snapshots zur Verf√ºgung. <br><br>  Die Funktion <code>pg_export_snapshot</code> gibt die Snapshot-ID zur√ºck, die an eine andere Transaktion √ºbergeben werden kann (mithilfe von Tools au√üerhalb des DBMS). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  Die andere Transaktion kann den Snapshot mit dem Befehl SET TRANSACTION SNAPSHOT importieren, bevor die erste Abfrage ausgef√ºhrt wird.  Die Isolationsstufe "Wiederholbares Lesen" oder "Serialisierbar" sollte ebenfalls angegeben werden, da Anweisungen auf der Ebene "Read Committed" ihre eigenen Snapshots verwenden. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  Die zweite Transaktion funktioniert jetzt mit dem Snapshot der ersten und sieht daher drei Zeilen (anstatt Null): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  Die Lebensdauer eines exportierten Snapshots entspricht der Lebensdauer der exportierenden Transaktion. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479512/">https://habr.com/ru/post/de479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479498/index.html">Wie aus linearer Zeit Windows in O (n¬≤) wird</a></li>
<li><a href="../de479502/index.html">Wie √ºberlebt man die schwerste Eiszeit der Erdgeschichte?</a></li>
<li><a href="../de479504/index.html">Erstellen Sie einen auf Raspberry Pi basierenden RDP Thin Client</a></li>
<li><a href="../de479508/index.html">PostgreSQL Antipatterns: sch√§dliche JOINs und ORs</a></li>
<li><a href="../de479510/index.html">PocketBook X Test - ein riesiges 10,3-Zoll-Leseger√§t mit einem E-Ink-Carta-Mobius-Bildschirm und einem Metallgeh√§use</a></li>
<li><a href="../de479514/index.html">Datenschutz durch Design und Datenschutz durch Standard (Datenschutz durch Design und Datenschutz durch GDPR)</a></li>
<li><a href="../de479516/index.html">Was ist Entropie in Software und wie verwaltet man sie?</a></li>
<li><a href="../de479518/index.html">Kommunikation in einem entfernten Team ist unsere Erfahrung</a></li>
<li><a href="../de479522/index.html">Herausgeber Peter. Winterschlussverkauf</a></li>
<li><a href="../de479524/index.html">Service for Active Restore oder die Geschichte eines Industrieprojekts in Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>