<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴 🐖 💦 La historia de los algoritmos de aleatorización de Tetris 🕘 🙍🏻 🤛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 1985, Alexey Pajitnov y Vadim Gerasimov lanzaron Tetris. Este juego fascinante y altamente adictivo requería que los jugadores conectaran piezas qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La historia de los algoritmos de aleatorización de Tetris</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466579/"><img src="https://habrastorage.org/getpro/habr/post_images/98b/032/444/98b032444bc6166195004d46d9b4ee2c.jpg" alt="imagen"><br>  En 1985, Alexey Pajitnov y Vadim Gerasimov lanzaron Tetris.  Este juego fascinante y altamente adictivo requería que los jugadores conectaran piezas que aparecían <em>al azar</em> .  Desde entonces, se han lanzado más de 150 versiones con licencia de Tetris.  A diferencia de los modos de juego, las reglas y la implementación, todos jugaron un poco (o muy) de manera diferente.  El aleatorizador Tetris es una función que devuelve una forma seleccionada al azar.  Con los años, las reglas para elegir formas han evolucionado, influyendo en el juego y la aleatoriedad en sí.  Algunos de estos algoritmos han sido diseñados y documentados de manera inversa.  He compilado una lista de aleatorizadores que considero importantes, y mostraré en el artículo cómo la estructura interna de Tetris ha cambiado con los años. <br><a name="habracut"></a><br><h2>  <em>Tetris</em> (c. 1985) </h2><br>  La primera y original versión de Tetris tenía un aleatorizador sin sesgos.  Nada influyó en la elección de la siguiente figura, simplemente fue elegida y mostrada al jugador. <br><br>  Cuando se usa un aleatorizador sin desplazamiento, surgen situaciones en las que el jugador recibe una secuencia de una figura (llamada "inundación", inundación) o una secuencia en la que no hay una figura determinada (llamada "sequía", sequía).  Veremos cómo los diseñadores de diferentes versiones de Tetris intentaron suavizar ligeramente este problema. <br><br>  Aunque un aleatorizador sin sesgos crea la mayor complejidad de rompecabezas para los jugadores, es inestable y puede conducir a una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuencia invencible (PDF)</a> .  Sin embargo, esto no sucede en un juego real, porque las computadoras no tienen verdaderos generadores de números aleatorios.  Los generadores de números pseudoaleatorios (PRNG) intentan simular una aleatoriedad verdadera, pero no tienen las propiedades que pueden generar en una fila 70 mil cifras Z. <br><br><h3>  Pseudoaleatoriedad verdadera </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { yield pieces[Math.<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(Math.random() * pieces.length)]; } }</code> </pre> <br>  Dificultad del rompecabezas: 4/5 <br><br>  Prevención de inundaciones: 0/5 <br><br>  Prevención de sequía: 0/5 <br><br><h2>  <em>Tetris</em> , Nintendo (1989) </h2><br>  Cuatro años después, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se lanzó</a> la versión inusualmente popular de Tetris para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NES</a> . <br><br>  Para reducir el número de inundaciones (repeticiones) de cifras, se agregó una verificación de historial al aleatorizador.  Este simple control hizo lo siguiente: <br><br><ol><li>  elige una figura </li><li>  comprobado si la cifra coincide con la anterior, </li><li>  si es así, entonces el algoritmo seleccionó una nueva forma, pero solo una vez, </li><li>  y cualquiera que sea el resultado, la cifra se le dio al jugador. </li></ol><br>  Aunque la probabilidad de obtener una pieza consecutiva estaba disminuyendo, nada impedía que el juego emitiera dos piezas alternas.  Además, en esta versión, la sequía en más de 30 cifras era una situación frecuente.  Podría ocurrir una sequía para cualquier tipo de tetramino, pero la figura I es importante para anotar en este juego, y su gran sequía podría afectar significativamente el puntaje final. <br><br><h3>  Memorizar una historia 1 figura en profundidad y con 1 tiro </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">historyRandomizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; let history; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// First "roll" piece = pieces[Math.floor(Math.random() * pieces.length)]; // Roll is checked against the history if (piece === history) { piece = pieces[Math.floor(Math.random() * pieces.length)]; } history = piece; yield piece; } }</span></span></code> </pre> <br>  Dificultad del rompecabezas: 5/5 <br><br>  Prevención de inundaciones: 2/5 <br><br>  Prevención de sequía: 0/5 <br><br><h2>  <em>Tetris: el gran maestro</em> (1998) </h2><br>  Aunque <em>Tetris para NES</em> mejoró el algoritmo en comparación con la aleatorización sin sesgo, las sequías en él todavía eran frecuentes.  <em>Tetris: El Gran Maestro</em> ( <em>TGM</em> ) usó esencialmente el mismo sistema, pero con una historia más larga y más lanzamientos. <br><br>  Debido al aumento en estos valores, no solo disminuyó el número de inundaciones, sino que también mejoró la situación con las sequías.  Cuatro figuras se conservaron en la historia, y esto significó que la probabilidad de obtener una figura que no había existido durante mucho tiempo aumentó.  A pesar de esto, el juego aún carecía de una regla estricta para prevenir las sequías y todavía ocurrían, aunque con mucha menos frecuencia que en <em>Tetris para NES</em> . <br><br><h3>  Memorizar una historia con 4 piezas y 4 tiros </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">historyRandomizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// First piece special conditions let piece = ['I', 'J', 'L', 'T'][Math.floor(Math.random() * 4)]; yield piece; let history = ['S', 'Z', 'S', piece]; while (true) { for (let roll = 0; roll &lt; 4; ++roll) { piece = pieces[Math.floor(Math.random() * 7)]; if (history.includes(piece) === false) break; } history.shift(); history.push(piece); yield piece; } }</span></span></code> </pre> <br>  Dificultad del rompecabezas: 4/5 <br><br>  Prevención de inundaciones: 4/5 <br><br>  Prevención de sequía: 2/5 <br><br><h2>  <em>Tetris Worlds</em> y otros (2001) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/59a/4a8/b4b59a4a8eb64c5edb6a280a72d38a8a.jpg"></div><br>  <em>Tetris Worlds</em> introdujo las masas al generador aleatorio.  Ahora es el aleatorizador oficial, en la mayoría de las versiones oficiales del juego después de <em>Tetris Worlds,</em> y hasta el día de hoy está acostumbrado. <br><br>  Los aleatorizadores basados ​​en la historia ayudaron a deshacerse de las inundaciones (o al menos minimizarlas), pero no detuvieron la sequía.  Bajo ciertas condiciones, aún existía la posibilidad de obtener una secuencia mortal de figuras. <br><br>  El generador aleatorio (Random Generator) resuelve estos problemas mediante el uso de un nuevo sistema de "bolsas" (bolsas).  En este sistema, la lista de figuras se coloca en una "bolsa", después de lo cual las figuras se extraen aleatoriamente una tras otra hasta que la "bolsa" está vacía.  Cuando está vacío, las piezas vuelven a él y el proceso se repite.  Random Generator tiene una "bolsa" de tamaño 7 (7 bolsas), es decir, una "bolsa" llena de cada uno de los 7 tetraminos.  Son posibles otros tipos de "bolsas", por ejemplo, una bolsa de 14, en la que se colocan dos piezas de cada tipo de tetramino. <br><br>  Debido a la falta de historia de las "bolsas", pueden producirse inundaciones de 2 figuras y "serpientes" de 4 figuras en sus cruces ( <img src="https://habrastorage.org/webt/pc/ws/v4/pcwsv4sjt7ofqojutpk2f8auhxo.png">  , <img src="https://habrastorage.org/webt/qp/ua/pn/qpuapnx-u3qicgxo1-nwppigh70.png">  etc.)  Es decir, en cierto sentido, este es un paso atrás en comparación con el <em>Tetris</em> tradicional <em>para NES</em> . <br><br>  Las piezas se caen de la bolsa de forma estable, lo que lo hace más predecible.  Es fácil entender en qué parte de la “bolsa” se encuentra y cuándo puede llegar la cifra que necesita.  Debido a la previsibilidad de este generador de aleatoriedad, el juego se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jugar sin cesar</a> .  En general, este es un sistema muy estúpido, y no está claro cómo se convirtió en un aleatorizador oficial. <br><br><h3>  7 bolsas </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomGenerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ let bag = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bag.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { bag = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; bag = shuffle(bag); } yield bag.pop(); } }</code> </pre> <br>  Dificultad del rompecabezas: 3/5 <br><br>  Prevención de inundaciones: 3/5 <br><br>  Prevención de sequía: 4/5 <br><br><h2>  <em>Tetris: The Grand Master 3 - Terror-Instinct</em> (2005) </h2><br>  TGM3 ha avanzado mucho la idea de generar aleatoriedad.  Este es un sistema único que no se encuentra en ninguna otra versión. <br><br>  En lugar de una bolsa o historia, el TGM3 utiliza un conjunto de formas.  Inicialmente, tiene 5 figuras de cada tipo, es decir, un total de 35 figuras.  Cuando se tira de una figura, no se elimina de la piscina, sino que se reemplaza por la figura con la mayor sequía (una que no se ha eliminado durante mucho tiempo).  Gradualmente, la piscina se llena cada vez más con esta figura hasta que finalmente se retira.  Esto resuelve los problemas de los sistemas de "bolsa", así como los sistemas con un historial;  ella toma lo mejor de ambos tipos de aleatorización. <br><br><h3>  Grupo de 35 figuras con 6 lanzamientos </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tgm3Randomizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ let pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; let order = []; <span class="hljs-comment"><span class="hljs-comment">// Create 35 pool. let pool = pieces.concat(pieces, pieces, pieces, pieces); // First piece special conditions const firstPiece = ['I', 'J', 'L', 'T'][Math.floor(Math.random() * 4)]; yield firstPiece; let history = ['S', 'Z', 'S', firstPiece]; while (true) { let roll; let i; let piece; // Roll For piece for (roll = 0; roll &lt; 6; ++roll) { i = Math.floor(Math.random() * 35); piece = pool[i]; if (history.includes(piece) === false || roll === 5) { break; } if (order.length) pool[i] = order[0]; } // Update piece order if (order.includes(piece)) { order.splice(order.indexOf(piece), 1); } order.push(piece); pool[i] = order[0]; // Update history history.shift(); history[3] = piece; yield piece; } }</span></span></code> </pre> <br>  Dificultad del rompecabezas: 4/5 <br><br>  Prevención de inundaciones: 4/5 <br><br>  Prevención de sequía: 4/5 <br><br><h2>  Conclusiones </h2><br>  Es difícil sacar un resultado definitivo.  El aleatorizador TGM3 parece más predecible y menos complejo para el jugador.  La torpe bolsa de 7 se siente antinatural, pero le permite crear muchas estrategias de construcción establemente viables.  Un aleatorizador hostil, como en Tetris para NES, puede arruinar tu juego o, más probablemente, tu estado de ánimo para jugar. <br><br>  ¿Podemos mejorar estos sistemas haciéndolos parecer más aleatorios y poniendo restricciones severas a las sequías e inundaciones?  ¿O son restricciones tan severas que solo hacen que el juego sea más predecible? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466579/">https://habr.com/ru/post/466579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466567/index.html">Kit de herramientas para el proveedor: seminarios web temáticos sobre sistemas para trabajar con tráfico y su configuración</a></li>
<li><a href="../466569/index.html">OPI en la Bolsa de Moscú: por qué es necesaria, quién la realiza y cómo comprar acciones</a></li>
<li><a href="../466571/index.html">Consejos de OCR de Tesseract: cree su propio vocabulario para mejorar el rendimiento de OCR</a></li>
<li><a href="../466573/index.html">Preguntas al futuro empleador</a></li>
<li><a href="../466575/index.html">Pasar listas bidimensionales de Python a DLL</a></li>
<li><a href="../466581/index.html">Darwinismo cuántico: una idea que explica la realidad objetiva pasa la primera prueba</a></li>
<li><a href="../466583/index.html">Una breve historia del detector de mentiras</a></li>
<li><a href="../466585/index.html">Comprender los corredores de mensajes. Aprendiendo la mecánica de la mensajería a través de ActiveMQ y Kafka. Capítulo 3. Kafka</a></li>
<li><a href="../466587/index.html">Variables CSS y tema de color para el sitio en varias líneas</a></li>
<li><a href="../466589/index.html">Cómo recibir datos de Google Analytics usando R en Microsoft SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>