<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≤ üë®üèΩ‚Äçüç≥ üßîüèª Umgang mit Fehlern in Go 1.13 üç• üëºüèΩ ‚ùï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten zehn Jahren haben wir erfolgreich die Tatsache ausgenutzt, dass Go Fehler als Werte behandelt . Obwohl die Standardbibliothek nur eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Umgang mit Fehlern in Go 1.13</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473658/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9f/wo/zl/9fwozl-z2zhf7bg5l_i8lfvdxdw.jpeg"></div><br>  In den letzten zehn Jahren haben wir erfolgreich die Tatsache ausgenutzt, dass Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler als Werte behandelt</a> .  Obwohl die Standardbibliothek nur eine minimale Unterst√ºtzung f√ºr Fehler hatte: nur die Funktionen <code>errors.New</code> und <code>fmt.Errorf</code> , die einen Fehler erzeugen, der nur eine Nachricht enth√§lt - die integrierte Schnittstelle erm√∂glicht es Go-Programmierern, Informationen hinzuzuf√ºgen.  Sie ben√∂tigen lediglich einen Typ, der die <code>Error</code> Methode implementiert: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Query + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> <a name="habracut"></a><br>  Diese Arten von Fehlern treten in allen Sprachen auf und speichern eine Vielzahl von Informationen, von Zeitstempeln √ºber Dateinamen bis hin zu Serveradressen.  Fehler auf niedriger Ebene, die zus√§tzlichen Kontext bieten, werden h√§ufig erw√§hnt. <br><br>  Ein Muster, bei dem ein Fehler einen anderen enth√§lt, ist in Go so h√§ufig, dass nach einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">heftigen Diskussion</a> in Go 1.13 seine explizite Unterst√ºtzung hinzugef√ºgt wurde.  In diesem Artikel werden Erg√§nzungen zur Standardbibliothek behandelt, die die erw√§hnte Unterst√ºtzung bieten: drei neue Funktionen im <code>fmt.Errorf</code> und ein neuer Formatierungsbefehl f√ºr <code>fmt.Errorf</code> . <br><br>  Bevor wir die √Ñnderungen im Detail besprechen, wollen wir uns damit befassen, wie Fehler in fr√ºheren Versionen der Sprache untersucht und konstruiert wurden. <br><br><h1>  Fehler vor dem Start 1.13 </h1><br><h4>  Fehlerforschung </h4><br>  Fehler in Go sind Bedeutungen.  Programme treffen Entscheidungen basierend auf diesen Werten auf unterschiedliche Weise.  Meistens wird der Fehler mit nil verglichen, um festzustellen, ob der Vorgang fehlgeschlagen ist. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// something went wrong }</span></span></code> </pre><br>  Manchmal vergleichen wir den Fehler, um den <i>Kontrollwert</i> herauszufinden und festzustellen, ob ein bestimmter Fehler aufgetreten ist. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == ErrNotFound { <span class="hljs-comment"><span class="hljs-comment">// something wasn't found }</span></span></code> </pre> <br>  Der Fehlerwert kann von einem beliebigen Typ sein, der die in der Sprache definierte Fehlerschnittstelle erf√ºllt.  Ein Programm kann eine Typanweisung oder einen Typschalter verwenden, um den Fehlerwert eines spezifischeren Typs anzuzeigen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NotFoundError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *NotFoundError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Name + <span class="hljs-string"><span class="hljs-string">": not found"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*NotFoundError); ok { <span class="hljs-comment"><span class="hljs-comment">// e.Name wasn't found }</span></span></code> </pre><br><h4>  Informationen hinzuf√ºgen </h4><br>  Oft leitet eine Funktion einen Fehler an den Aufrufstapel weiter und f√ºgt ihm Informationen hinzu, z. B. eine kurze Beschreibung dessen, was passiert ist, als der Fehler aufgetreten ist.  Dies ist einfach zu tun. Erstellen Sie einfach einen neuen Fehler, der den Text des vorherigen Fehlers enth√§lt: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Wenn Sie mit <code>fmt.Errorf</code> einen neuen Fehler <code>fmt.Errorf</code> verwerfen wir alles au√üer dem Text des urspr√ºnglichen Fehlers.  Wie wir im <code>QueryError</code> Beispiel gesehen haben, m√ºssen Sie manchmal einen neuen Fehlertyp definieren, der den urspr√ºnglichen Fehler enth√§lt, um ihn zur Analyse mithilfe von Code zu speichern: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error }</code> </pre> <br>  Programme k√∂nnen in den <code>*QueryError</code> und eine Entscheidung basierend auf dem urspr√ºnglichen Fehler treffen.  Dies wird manchmal als Auspacken eines Fehlers bezeichnet. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Der Typ <code>os.PathError</code> aus der Standardbibliothek ist ein weiteres Beispiel daf√ºr, wie ein Fehler einen anderen enth√§lt. <br><br><h1>  Fehler in Go 1.13 </h1><br><h4>  Methode auspacken </h4><br>  In Go 1.13 vereinfachten die Standardbibliothekspakete <code>errors</code> und <code>fmt</code> die <code>fmt</code> Fehlern, die andere Fehler enthalten.  Das wichtigste ist die Konvention, nicht die √Ñnderung: Ein Fehler, der einen anderen Fehler enth√§lt, kann die <code>Unwrap</code> Methode implementieren, die den urspr√ºnglichen Fehler zur√ºckgibt.  Wenn <code>e1.Unwrap()</code> <code>e2</code> zur√ºckgibt, sagen wir, dass <code>e1</code> <code>e2</code> <i>packt</i> und Sie <code>e1</code> <i>entpacken</i> k√∂nnen, um <code>e2</code> zu erhalten. <br><br>  Gem√§√ü dieser Konvention k√∂nnen Sie der <code>QueryError</code> beschriebenen <code>QueryError</code> Methode den <code>QueryError</code> beschriebenen <code>QueryError</code> Typ <code>QueryError</code> , der den darin enthaltenen Fehler zur√ºckgibt: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Err }</code> </pre> <br>  Das Ergebnis des Entpackens des Fehlers kann auch die <code>Unwrap</code> Methode enthalten.  Die Folge von Fehlern, die durch wiederholtes Auspacken erhalten werden, nennen wir die <i>Fehlerkette</i> . <br><br><h4>  Fehleruntersuchung mit Is und As </h4><br>  In Go 1.13 enth√§lt das <code>errors</code> zwei neue Funktionen zur Fehleruntersuchung: <code>Is</code> und <code>As</code> . <br><br>  Die Funktion <code>errors.Is</code> vergleicht einen Fehler mit einem Wert. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if err == ErrNotFound { ‚Ä¶ } if errors.Is(err, ErrNotFound) { // something wasn't found }</span></span></code> </pre> <br>  Die <code>As</code> Funktion pr√ºft, ob der Fehler von einem bestimmten Typ ist. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if e, ok := err.(*QueryError); ok { ‚Ä¶ } var e *QueryError if errors.As(err, &amp;e) { // err is a *QueryError, and e is set to the error's value }</span></span></code> </pre> <br>  Im einfachsten Fall verh√§lt sich die Funktion <code>errors.Is</code> wie ein Vergleich mit einem Steuerfehler und die Funktion <code>errors.As</code> wie eine <code>errors.As</code> .  Bei der Arbeit mit gepackten Fehlern bewerten diese Funktionen jedoch alle Fehler in der Kette.  Schauen wir uns das <code>QueryError</code> Beispiel oben an, um den urspr√ºnglichen Fehler zu untersuchen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Mit der Funktion <code>errors.Is</code> k√∂nnen <code>errors.Is</code> schreiben: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) { <span class="hljs-comment"><span class="hljs-comment">// err, or some error that it wraps, is a permission problem }</span></span></code> </pre> <br>  Das <code>Unwrap</code> enth√§lt auch eine neue <code>Unwrap</code> Funktion, die das Ergebnis des Aufrufs der <code>Unwrap</code> Methode des Fehlers zur√ºckgibt oder nil zur√ºckgibt, wenn der Fehler nicht √ºber die <code>Unwrap</code> Methode verf√ºgt.  Es ist normalerweise besser, <code>errors.Is</code> zu verwenden. <code>errors.Is</code> oder <code>errors.As</code> , da Sie damit die gesamte Kette mit einem einzigen Aufruf untersuchen k√∂nnen. <br><br><h4>  Fehler beim Verpacken mit% w </h4><br>  Wie bereits erw√§hnt, ist es √ºblich, die Funktion <code>fmt.Errorf</code> zu verwenden, um dem Fehler zus√§tzliche Informationen hinzuzuf√ºgen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  In Go 1.13 unterst√ºtzt die Funktion <code>fmt.Errorf</code> den neuen Befehl <code>%w</code> .  Wenn dies der <code>fmt.Errorf</code> ist, enth√§lt der von <code>fmt.Errorf</code> Fehler die <code>Unwrap</code> Methode, die das <code>%w</code> Argument zur√ºckgibt, das ein Fehler sein sollte.  In allen anderen F√§llen ist <code>%w</code> identisch mit <code>%v</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Return an error which unwraps to err. return fmt.Errorf("decompress %v: %w", name, err) }</span></span></code> </pre> <br>  Durch das Packen des Fehlers mit <code>%w</code> wird er f√ºr <code>errors.Is</code> verf√ºgbar. <code>errors.Is</code> und <code>errors.As</code> : <br><br><pre> <code class="go hljs">err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"access denied: %w"</span></span>, ErrPermission) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) ...</code> </pre><br><h4>  Wann packen? </h4><br>  Wenn Sie dem Fehler mit <code>fmt.Errorf</code> oder einer benutzerdefinierten <code>fmt.Errorf</code> einen zus√§tzlichen Kontext hinzuf√ºgen, m√ºssen Sie entscheiden, ob der neue Fehler das Original enth√§lt.  Es gibt keine einzige Antwort darauf, alles h√§ngt vom Kontext ab, in dem der neue Fehler erstellt wird.  Packen Sie, um ihren Anrufer zu zeigen.  Packen Sie den Fehler nicht ein, wenn dies zur Offenlegung von Implementierungsdetails f√ºhrt. <br><br>  Stellen Sie sich beispielsweise eine <code>Parse</code> , die eine komplexe Datenstruktur aus <code>io.Reader</code> liest.  Wenn ein Fehler auftritt, m√∂chten wir die Nummer der Zeile und Spalte herausfinden, in der er aufgetreten ist.  Wenn beim Lesen von <code>io.Reader</code> ein Fehler aufgetreten ist, m√ºssen wir ihn packen, um den Grund herauszufinden.  Da dem Aufrufer die Funktion <code>io.Reader</code> zur <code>io.Reader</code> , ist es sinnvoll, den von ihm erzeugten Fehler <code>io.Reader</code> . <br><br>  Ein anderer Fall: Eine Funktion, die mehrere Datenbankaufrufe ausf√ºhrt, sollte wahrscheinlich keinen Fehler zur√ºckgeben, bei dem das Ergebnis eines dieser Aufrufe gepackt ist.  Wenn die von dieser Funktion verwendete Datenbank Teil der Implementierung ist, verst√∂√üt das Offenlegen dieser Fehler gegen die Abstraktion.  Wenn die <code>LookupUser</code> Funktion aus dem Paket <code>pkg</code> Paket Go <code>database/sql</code> , tritt m√∂glicherweise der Fehler <code>sql.ErrNoRows</code> .  Wenn Sie mit <code>fmt.Errorf("accessing DB: %v", err)</code> einen Fehler <code>fmt.Errorf("accessing DB: %v", err)</code> , kann der Aufrufer nicht nach innen schauen und <code>sql.ErrNoRows</code> finden.  Wenn die Funktion jedoch <code>fmt.Errorf("accessing DB: %w", err)</code> , kann der Aufrufer <code>fmt.Errorf("accessing DB: %w", err)</code> schreiben: <br><br><pre> <code class="go hljs">err := pkg.LookupUser(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, sql.ErrNoRows) ‚Ä¶</code> </pre> <br>  In diesem Fall sollte die Funktion immer <code>sql.ErrNoRows</code> wenn Sie Clients nicht <code>sql.ErrNoRows</code> m√∂chten, auch wenn Sie zu einem Paket mit einer anderen Datenbank wechseln.  Mit anderen Worten, das Packen macht einen Fehler zu einem Teil Ihrer API.  Wenn Sie diesen Fehler in Zukunft nicht mehr als Teil der API unterst√ºtzen m√∂chten, packen Sie ihn nicht. <br><br>  Es ist wichtig zu beachten, dass der Fehler unabh√§ngig davon, ob Sie ihn einpacken oder nicht, unver√§ndert bleibt.  <i>Eine Person,</i> die es verstehen wird, wird die gleichen Informationen haben.  Entscheidungen √ºber Verpackungen zu treffen, h√§ngt davon ab, ob zus√§tzliche Informationen f√ºr <i>Programme</i> ben√∂tigt <i>werden,</i> damit sie fundiertere Entscheidungen treffen k√∂nnen.  oder wenn Sie diese Informationen ausblenden m√∂chten, um den Abstraktionsgrad beizubehalten. <br><br><h4>  Einrichten von Fehlertests mit Is- und As-Methoden </h4><br>  Die Funktion <code>errors.Is</code> jeden Fehler in der Kette mit dem Zielwert.  Standardm√§√üig entspricht ein Fehler diesem Wert, wenn sie gleichwertig sind.  Dar√ºber hinaus kann ein Fehler in der Kette mithilfe der Implementierung <i>der</i> <code>Is</code> <i>Methode</i> die √úbereinstimmung mit dem Zielwert erkl√§ren. <br><br>  Betrachten Sie den Fehler, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durch das Upspin-Paket</a> verursacht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird</a> , das den Fehler mit der Vorlage vergleicht und nur Felder ungleich Null auswertet: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { t, ok := target.(*Error) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e.Path == t.Path || t.Path == <span class="hljs-string"><span class="hljs-string">""</span></span>) &amp;&amp; (e.User == t.User || t.User == <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, &amp;Error{User: <span class="hljs-string"><span class="hljs-string">"someuser"</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">// err's User field is "someuser". }</span></span></code> </pre> <br>  Die Funktion <code>errors.As</code> empfiehlt auch die <code>As</code> Methode, falls vorhanden. <br><br><h4>  Fehler und Paket-APIs </h4><br>  Ein Paket, das Fehler zur√ºckgibt (und die meisten Pakete tun dies), sollte die Eigenschaften dieser Fehler beschreiben, auf die sich ein Programmierer verlassen kann.  Ein gut gestaltetes Paket vermeidet auch die R√ºckgabe von Fehlern mit Eigenschaften, auf die man sich nicht verlassen kann. <br><br>  Am einfachsten ist es zu sagen, ob die Operation erfolgreich war, und den Wert null bzw. nicht null zur√ºckzugeben.  In vielen F√§llen sind keine weiteren Informationen erforderlich. <br><br>  Wenn Sie die Funktion ben√∂tigen, um einen identifizierbaren Fehlerzustand zur√ºckzugeben, z. B. "Element nicht gefunden", k√∂nnen Sie einen Fehler zur√ºckgeben, in den der Signalwert gepackt ist. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// FetchItem returns the named item. // // If no item with the name exists, FetchItem returns an error // wrapping ErrNotFound. func FetchItem(name string) (*Item, error) { if itemNotFound(name) { return nil, fmt.Errorf("%q: %w", name, ErrNotFound) } // ... }</span></span></code> </pre> <br>  Es gibt andere Muster zum Bereitstellen von Fehlern, die der Aufrufer semantisch untersuchen kann.  Geben Sie beispielsweise direkt einen Steuerwert, einen bestimmten Typ oder einen Wert zur√ºck, der mithilfe einer Pr√§dikativfunktion analysiert werden kann. <br><br>  Geben Sie die internen Details in keinem Fall an den Benutzer weiter.  Wie im Kapitel ‚ÄûWann lohnt es sich zu verpacken?‚Äú Erw√§hnt: Wenn Sie einen Fehler von einem anderen Paket zur√ºckgeben, konvertieren Sie ihn so, dass der urspr√ºngliche Fehler nicht angezeigt wird, es sei denn, Sie beabsichtigen, diesen bestimmten Fehler in Zukunft zur√ºckzugeben. <br><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The *os.PathError returned by os.Open is an internal detail. // To avoid exposing it to the caller, repackage it as a new // error with the same text. We use the %v formatting verb, since // %w would permit the caller to unwrap the original *os.PathError. return fmt.Errorf("%v", err) }</span></span></code> </pre> <br>  Wenn eine Funktion einen Fehler mit einem gepackten Signalwert oder -typ zur√ºckgibt, wird der urspr√ºngliche Fehler nicht direkt zur√ºckgegeben. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrPermission = errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// DoSomething returns an error wrapping ErrPermission if the user // does not have permission to do something. func DoSomething() { if !userHasPermission() { // If we return ErrPermission directly, callers might come // to depend on the exact error value, writing code like this: // // if err := pkg.DoSomething(); err == pkg.ErrPermission { ‚Ä¶ } // // This will cause problems if we want to add additional // context to the error in the future. To avoid this, we // return an error wrapping the sentinel so that users must // always unwrap it: // // if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) { ... } return fmt.Errorf("%w", ErrPermission) } // ... }</span></span></code> </pre><br><h4>  Fazit </h4><br>  Obwohl wir nur drei Funktionen und einen Formatierungsbefehl besprochen haben, hoffen wir, dass sie dazu beitragen, die Fehlerbehandlung in Go-Programmen erheblich zu verbessern.  Wir hoffen, dass das Verpacken, um zus√§tzlichen Kontext bereitzustellen, zur normalen Praxis wird und Programmierern hilft, bessere Entscheidungen zu treffen und Fehler schneller zu finden. <br><br>  Wie Russ Cox in seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rede auf der GopherCon 2019</a> sagte, experimentieren, vereinfachen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versenden</a> wir auf dem Weg zu Go 2.  Und jetzt, nachdem wir diese √Ñnderungen ausgeliefert haben, machen wir uns an neue Experimente. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473658/">https://habr.com/ru/post/de473658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473646/index.html">Hackathon in einer kleinen Firma: Wie man arrangiert, ohne einen Zug von Ressourcen zu entsorgen</a></li>
<li><a href="../de473648/index.html">Das Pferd ist totschrei: √úbergang von Tslint zu Eslint</a></li>
<li><a href="../de473652/index.html">Erstellen einer REST-API mit Node.js und einer Oracle-Datenbank. Teil 5</a></li>
<li><a href="../de473654/index.html">PHP Composer: Korrigieren Sie Abh√§ngigkeiten ohne Schmerzen</a></li>
<li><a href="../de473656/index.html">Hugo Static Site Generator Erfahrung</a></li>
<li><a href="../de473660/index.html">Arcade Reverse Engineering: Nehmen Sie Michael Jordan bei NBA Jam auf</a></li>
<li><a href="../de473664/index.html">Lernerfahrung aus erster Hand. Yandex.Practicum - Datenanalyst</a></li>
<li><a href="../de473666/index.html">Als Science-Fiction-Autor h√§tte Arthur Clark die Zeitschrift Tech - Youth fast geschlossen</a></li>
<li><a href="../de473668/index.html">Warum Bitrix - Bitrix</a></li>
<li><a href="../de473670/index.html">Stoloto: Wie man ein Handy in die Lotterie einf√ºhrt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>