<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃 🏪 👩🏼‍🤝‍👩🏻 Akses ke Redd Ban di Jembatan FTDI 🍸 👂 🔺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah menyelesaikan blok teori besar yang menunjukkan cara membangun subsistem FPGA untuk kompleks Redd; bagaimana mengatur komunikasi antara FPG...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akses ke Redd Ban di Jembatan FTDI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477662/">  Kami telah menyelesaikan blok teori besar yang menunjukkan cara membangun subsistem FPGA untuk kompleks Redd;  bagaimana mengatur komunikasi antara FPGA dan prosesor pusat kompleks;  betapa mudahnya menyimpan aliran data berkecepatan tinggi dalam RAM, yang terhubung langsung ke FPGA, untuk transfer santai mereka selanjutnya ke prosesor pusat (atau sebaliknya, untuk memasukkan data ke dalam RAM ini untuk output cepat berikutnya ke saluran).  Kami meninjau teknik penelusuran prosesor Nios II.  Kami dapat mengoptimalkan kinerja sistem prosesor berdasarkan Nios II sehingga pekerjaan berjalan seefisien mungkin.  Secara umum, kami telah mempelajari semua teori minimum yang diperlukan, dan sudah saatnya untuk beralih ke praktik dengan merancang perangkat yang tidak terlalu rumit, tetapi praktis berguna ... Tapi ada satu TETAPI. <br><br>  Dari komentar di artikel, saya perhatikan bahwa beberapa pembaca percaya bahwa Redd dan FPGA seperti Lenin dan Partai.  Bahwa mereka terkait erat.  Faktanya, ini tidak benar sama sekali.  Saya hanya ingin memulai percakapan tentang kompleks Redd dengan sesuatu yang menarik, tetapi apa yang bisa lebih menarik daripada FPGA?  Nah, dan memulai percakapan, menginterupsi sekilas itu bodoh.  Dan akhirnya, blok logis besar selesai.  Dan untuk menunjukkan bahwa FPGA jauh dari keseluruhan Redd, saya mengusulkan untuk membuat sekitar tiga artikel tentang hal-hal yang tidak terkait dengannya.  Nah, dan setelah menyelesaikan blok ini, sudah pergi ke praktik FPGA. <br><br><img src="https://habrastorage.org/webt/nu/nw/7p/nunw7p7f7c5hcnmlsv7haliroz8.png"><br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Yang paling menakjubkan adalah begitu saya memutuskan untuk menyimpang dari topik lain, bos yang baik melemparkan saya ke dalam pertempuran yang sulit pada sebuah proyek di mana pekerjaan sedang berlangsung dengan bahasa VHDL dan Xilinx FPGA.  Pertama, itu sebabnya untuk waktu yang lama saya tidak mengambil pena pada umumnya, dan kedua, jelas bahwa persiapan artikel praktis memerlukan sejumlah besar percobaan.  Agak sulit untuk berurusan dengan VHDL / Verilog dan Xilinx / Altera secara bersamaan.  Jadi, istirahat dalam cerita tentang FPGA harus dilakukan. <br><br>  Jadi  Pada <a href="https://habr.com/ru/post/452656/">artikel pertama dari seri ini,</a> kami telah memeriksa diagram struktural kompleks Redd.  Mari kita lakukan sekali lagi. <br><br><img src="https://habrastorage.org/webt/vf/hv/da/vfhvda1kmsax-zkxaue4xu_ysmk.png"><br><br>  Dalam artikel hari ini, para ahli Linux tidak mungkin menemukan banyak informasi yang berharga, tetapi layak untuk melihat gambar secara dangkal.  Mereka yang, seperti saya, terbiasa bekerja dari Windows, akan menemukan daftar teknik siap pakai yang memungkinkan Anda untuk bekerja dengan kompleks.  Secara umum, artikel ini akan membawa keterampilan mereka dan kelompok pembaca lain ke penyebut yang sama. <br><br><div class="spoiler">  <b class="spoiler_title">Artikel siklus sebelumnya</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://habr.com/ru/post/453682/">Bagian 2. Kode program.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Eksperimen pertama menggunakan protokol streaming pada contoh koneksi CPU dan prosesor di FPGA kompleks Redd.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Merry Quartusel, atau bagaimana prosesor telah hidup seperti itu.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">Metode Optimasi Kode untuk Redd.</a>  <a href="https://habr.com/ru/post/467353/">Bagian 1: efek cache.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">Metode Optimasi Kode untuk Redd.</a>  <a href="https://habr.com/ru/post/468027/">Bagian 2: memori non-cache dan operasi bus paralel.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Optimalisasi kode ekstensif: mengganti generator jam untuk meningkatkan kinerja sistem.</a> </li></ol><br></div></div><br><h2>  Blok UART (Port Serial) </h2><br>  Dalam diagram blok, kita melihat pengontrol FT4232 yang mengimplementasikan 4 port serial (UART): <br><br><img src="https://habrastorage.org/webt/75/bh/hy/75bhhyfnu_19uedfnkc7bzyrido.png"><br><br>  Tetapi jika Anda berbicara sedikit lebih global, maka kompleks Redd tidak memiliki empat, tetapi enam port serial.  Hanya disebutkan empat memiliki tingkat CMOS, dan dua lagi disolder pada motherboard, karena kompleksnya didasarkan pada PC biasa. <br><br><img src="https://habrastorage.org/webt/14/vj/pl/14vjplsdplqalj4lcm-4g4nmnvg.png"><br><br>  Dengan demikian, mereka memiliki level - RS232 (plus atau minus 12 volt).  Port RS232 - semuanya jelas dengan mereka, mereka ditampilkan dalam bentuk dua konektor DB-9 standar, <br><br><img src="https://habrastorage.org/webt/xk/d0/h6/xkd0h6xvaxlz7gxl8v-r4t9n8de.png"><br><br>  dan di mana mencari garis dengan level CMOS?  Secara umum - pada konektor umum.  Pinout-nya ditunjukkan dalam diagram sirkuit listrik.  Ada, antara lain, kontak yang terkait dengan UART. <br><br><img src="https://habrastorage.org/webt/nm/pv/cr/nmpvcraxowuy0oea7wkin1aqulu.png"><br><br>  Secara eksternal, konektor ini terlihat sebagai berikut: <br><br><img src="https://habrastorage.org/webt/mf/qa/8h/mfqa8hkbar6y7u8shn39eiend2a.png"><br><br>  Cara menggunakannya tergantung pada tugas.  Anda dapat memanfaatkan untuk menghubungkan setiap perangkat.  Pendekatan ini bermanfaat jika seseorang menggunakan kompleks Redd untuk menguji perangkat yang diproduksi secara berkala dari jenis yang sama.  Namun tujuan utama dari kompleks ini masih men-debug peralatan yang sedang dikembangkan.  Dan dalam hal ini, lebih mudah untuk terhubung dengannya secara sementara.  Pola sementara ini terlihat di screensaver untuk semua artikel: Kabel Aruino dimasukkan langsung ke konektor.  Tentu saja, menghitung kontak masih menyenangkan, dan jika mereka secara tidak sengaja terbang, sangat sulit untuk mengembalikan switching sehingga lebih mudah untuk menyambungkan kembali semuanya dari awal;  Oleh karena itu, untuk memudahkan kehidupan, ada papan riser yang dapat Anda hubungkan setidaknya dengan bantuan konektor dua baris, setidaknya dengan kabel Arduino yang sama. <br><br><img src="https://habrastorage.org/webt/rb/we/66/rbwe66z9f5eahs3efqpxq93di6e.png"><br><br><h2>  Akses Perangkat Lunak UART </h2><br>  Port serial adalah elemen yang mapan dan terstandarisasi, oleh karena itu, bekerja dengannya tidak melalui beberapa pustaka FTDI tertentu, tetapi melalui sarana standar.  Mari kita lihat bagaimana alat ini terlihat di Linux. <br><br><h4>  Nama port </h4><br>  Dari sejumlah artikel dan forum di jaringan, dapat disimpulkan bahwa nama port yang disediakan oleh USB-Serial adapter berada dalam format / dev / ttyUSB0, / dev / ttyUSB1, dan seterusnya.  Di Linux, semua perangkat dapat dilihat menggunakan perintah yang sama seperti untuk melihat direktori biasa (pada kenyataannya, perangkat adalah file yang sama).  Mari kita lihat nama apa yang ada di sistem kita.  Kami memberikan perintah: <br>  <b>ls / dev /</b> <br><br><img src="https://habrastorage.org/webt/dj/ho/4g/djho4ghfwyceuqy6fjzezh3gyo8.png"><br><br>  Nama-nama yang menarik bagi kami disorot dengan warna merah.  Sesuatu yang banyak dari mereka.  Port mana yang sesuai dengan apa?  Mereka yang fasih di Linux tahu ribuan mantra untuk semua kesempatan.  Tetapi bagi mereka yang masih bekerja dengan Windows 3.1 (yah, sejajar dengan wanita tua RT-11 yang saat itu cukup riang), masih sulit untuk diingat, seiring bertambahnya usia yang baru lebih sulit untuk diingat.  Karena itu, lebih mudah untuk menemukan semuanya setiap waktu, menggunakan cara-cara sederhana.  Dan saya menyoroti pintu masuk ke jalan sederhana ini dengan bingkai hijau.  Serial subdirektori bersyarat.  Sekarang kita melihat <b>/ dev /</b> namespace.  Dan mari kita lihat ruang <b>/ dev / serial</b> : <br><br><img src="https://habrastorage.org/webt/kw/fc/31/kwfc3189zwxl3ut80xwehvplt70.png"><br><br>  Hebat!  Kami mempelajari hierarki, lihat ruang <b>/ dev / serial / by-id</b> .  Melihat ke depan, saya akan mengatakan bahwa untuk tampilan yang benar, Anda perlu menggunakan <b>perintah ls</b> dengan sakelar <b>-l</b> (terima kasih kepada bos saya untuk klarifikasi).  Yaitu, kami memberikan perintah: <br>  <b>ls –l / dev / serial / by-id</b> <br><br><img src="https://habrastorage.org/webt/qq/vl/vd/qqvlvdgcgak3c5cembrbmj4myue.png"><br><br>  Di satu sisi, semuanya baik-baik saja.  Sekarang kita tahu nama mana di ruang <b>/ dev / ttyUSBX yang</b> sesuai dengan perangkat mana.  Secara khusus, port yang dikelola oleh jembatan FT4232 (Quad) memiliki nama dari <b>ttyUSB3</b> hingga <b>ttyUSB6</b> .  Tetapi di sisi lain, ketika mempertimbangkan situs ini, saya menyadari bahwa di Paris di kamar berat dan ukuran harus ada ruang di mana standar kekacauan ditempatkan ... Karena entah bagaimana Anda harus dapat mengukur nilainya.  Baiklah, katakanlah kekurangan port <b>/ dev / ttyUSB0</b> dan <b>/ dev / ttyUSB1</b> dapat dengan mudah dijelaskan.  Tetapi bagaimana menjelaskan bahwa port “asli” berdasarkan keturunan jembatan FTDI yang terinstal diberi nomor dari tiga teratas, dan pengontrol Prolific pihak ketiga, yang dimasukkan untuk proyek tertentu, mengambil port nomor 2?  Bagaimana seseorang bisa bekerja di lingkungan seperti itu?  Besok seseorang akan memasukkan pengontrol lain ke kompleks (karena kompleks memungkinkan kelompok pengembang yang berbeda untuk bekerja dengan peralatan yang berbeda pada saat yang sama), dan port-port bergerak kembali.  Port apa yang perlu kita daftarkan di file konfigurasi untuk aplikasi yang berfungsi? <br><br>  Ternyata semuanya tidak begitu buruk.  Pertama, nama kuning <b>/ dev / ttyUSB3</b> dan nama biru <b>/ dev / serial / by-id / usb-FTDI_Quad_RS232-HS-if00-port0</b> adalah dua alias dari perangkat yang sama.  Dan opsi kedua juga bisa disajikan sebagai nama port, tetapi sudah lebih permanen daripada yang pertama.  Benar, dalam hal ini, semuanya agak buruk.  Kontroler eksternal berbasis FT4232 dapat dicolokkan ke dalam kompleks, dan itu sudah perlu untuk menangani penomoran mereka.  Dan di sini "kedua" datang untuk membantu kami.  Yakni, konvensi penamaan alternatif lain.  Kita ingat bahwa direktori <b>/ dev / serial</b> tidak hanya berisi subdirektori <b>/ by-id</b> , tetapi juga subdirektori <b>/ by-path</b> .  Kami memeriksa isinya (terletak di bagian bawah gambar berikutnya, di bawah garis merah). <br><br><img src="https://habrastorage.org/webt/y1/mm/xa/y1mmxabnvjburuzedzirgzusjbm.png"><br><br>  Semuanya di sini terkait dengan arsitektur fisik.  Dan saya sudah mengatakan berkali-kali bahwa semua pengontrol di dalam kompleks disolder ke papan, sehingga hierarki internal tidak akan berubah.  Dengan demikian, nama <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.0-port0</b> akan menjadi yang paling sulit. <br><br>  Secara total, kami memiliki cara berikut untuk mencari nama port (harus dilakukan sekali, hasil untuk instance Anda dari kompleks dapat dimasukkan ke dalam tabel dan digunakan terus-menerus): <br><br><ol><li>  Keluarkan perintah <b>ls –l / dev / serial / by-id</b> . </li><li>  Keluarkan <b>perintah ls –l / dev / serial / by-path</b> . </li><li>  Dari hasil poin 1, cari nama port yang sesuai dengan port yang diperlukan dari jembatan yang diperlukan.  Temukan nama port yang sama di hasil paragraf 2. Ambil nama fisik yang sesuai dengan paragraf ini. </li></ol><br>  Untuk port yang dilayani oleh pengontrol di motherboard, semuanya sedikit lebih rumit.  Di sini Anda tidak dapat membuat jalan dari perintah paling sederhana " <b>ls / dev</b> ", tetapi Anda harus mengingat sesuatu (baik, atau setidaknya ingat bahwa Anda dapat menghubungi di sini untuk bantuan).  Di mana-mana dikatakan bahwa nama port yang umum adalah <b>ttyS0-ttyS3</b> .  Pertanyaannya tetap, pada nama apa port nyata dalam sistem kita?  Saya menemukan mantra berikut untuk menjawab pertanyaan ini: <br>  <b>ls / sys / class / tty / * / perangkat / driver</b> <br><br>  Berikut ini respons sistem terhadapnya: <br><br><img src="https://habrastorage.org/webt/oc/gi/v7/ocgiv7g8ffmcmzr_bfypwrn__6g.png"><br><br>  Ternyata kita perlu menggunakan nama <b>/ dev / ttyS2</b> dan <b>/ dev / ttyS3</b> .  Kenapa - saya tidak tahu.  Tetapi satu hal yang menyenangkan: di sini tidak ada perubahan khusus yang diramalkan, oleh karena itu konstanta ini dapat diingat dan digunakan tanpa rasa takut bahwa mereka akan berubah. <br><br><h4>  Pengembangan kode </h4><br>  Saat mengembangkan, Anda harus menggunakan <b>Panduan Pemrograman Serial yang</b> luar biasa <b>untuk Sistem Operasi POSIX</b> (tautan langsung pertama yang Anda dapatkan adalah <a href="https://www.cmrr.umn.edu/~strupp/serial.html" rel="nofollow">https://www.cmrr.umn.edu/~strupp/serial.html</a> , tetapi tidak ada yang tahu berapa lama itu akan hidup).  Sangat penting bahwa ini memberi tahu cara bekerja dengan set sinyal penuh, karena port di kompleks sepenuhnya diimplementasikan.  Benar, hari ini kita hanya akan menggunakan garis Tx dan Rx. <br><br>  Biasanya saya memberikan hasil osilogram, tetapi sekarang ternyata saya dalam kondisi yang hampir nyata: kompleks ini terletak di tempat yang tidak terjangkau oleh tangan saya, jadi saya tidak dapat menghubungkan probe osiloskop.  Untuk melihat setidaknya beberapa hasil, atas permintaan saya, rekan menambahkan beberapa posting ke kompleks sesuai dengan skema klasik berikut: <br><br><img src="https://habrastorage.org/webt/4k/it/be/4kitbevmwnyxbllumfdz0qzr2a0.png"><br><br>  Mari kita coba transfer dari satu port ke port lainnya.  Dalam kasus kami, port <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0</b> dan <b>/dev/serial/by-path/pci-0000:00:15.0- terhubung usb-0: 6.5: 1.3-port0</b> . <br><br>  Kita sudah membahas bagaimana program untuk prosesor pusat Redd ditulis dalam salah satu <a href="https://habr.com/ru/post/456008/">artikel sebelumnya</a> , jadi hari ini kita akan membatasi diri kita hanya pada teks program yang ditulis di bawah kesan <b>Panduan Pemrograman Serial untuk</b> dokumen <b>Sistem Operasi POSIX</b> .  Sebenarnya, hal menarik utama yang ada adalah mengalihkan strategi penerimaan ke pembacaan non-blocking, sisanya sepele.  Namun demikian, mengingat kekacauan dalam contoh pada jaringan pada topik ini, lebih baik untuk memiliki sampel sepele di tangan (akan ditunjukkan nanti bahwa bahkan contoh berdasarkan dokumen yang luar biasa ini tidak bekerja 100%, kode di bawah ini berbeda dari kanon yang dijelaskan di dalamnya dalam satu baris, tetapi lebih pada kanon di bawah). <br><br><div class="spoiler">  <b class="spoiler_title">Kode sampel yang sama</b> <div class="spoiler_text"><pre><code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;unistd.h&gt; /* UNIX standard function definitions */ #include &lt;fcntl.h&gt; /* File control definitions */ #include &lt;errno.h&gt; /* Error number definitions */ #include &lt;termios.h&gt; /* POSIX terminal control definitions */ int OpenUART(const char* portName, speed_t baudRate) { //   int fd = open(portName, O_RDWR | O_NOCTTY | O_NDELAY); //     if (fd == -1) { return fd; } //     fcntl(fd, F_SETFL, FNDELAY); //    termios options; tcgetattr(fd, &amp;options); // ,       // ,   .  ... cfsetspeed(&amp;options, baudRate); //    ... // 1  ,   , 8    options.c_cflag &amp;= ~PARENB; options.c_cflag &amp;= ~CSTOPB; options.c_cflag &amp;= ~CSIZE; options.c_cflag |= CS8; options.c_cflag |= (CLOCAL | CREAD); // , ... tcsetattr(fd, TCSANOW, &amp;options); return fd; } int main() { printf("hello from ReddUARTTest!\n"); int fd1 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.3-port0", 9600); int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 9600); if ((fd1 != -1) &amp;&amp; (fd2 != -1)) { static const unsigned char dataForSend[] = {0xff,0xfe,0xfd,0xfb}; //      write(fd1, dataForSend, sizeof(dataForSend)); unsigned char dataForReceive[128]; ssize_t cnt = 0; //     ,  , //         int readSteps = 0; //      ,   while (cnt &lt; (ssize_t)sizeof(dataForSend)) { readSteps += 1; ssize_t rd = read(fd2, dataForReceive + cnt, sizeof(dataForReceive) - cnt); //   - ,     if (rd &lt;= 0) { usleep(1000); } else //  -   { cnt += rd; } } //   printf("%d read operations\n", readSteps); printf("Read Data: "); for (unsigned int i = 0; i &lt; cnt; i++) { printf("%X ", dataForReceive[i]); } printf("\n"); } else { printf("Error with any port open!\n"); } //   if (fd1 != -1) { close(fd1); } if (fd2 != -1) { close(fd2); } return 0; }</code> </pre> <br></div></div><br>  Jalankan - kami mendapatkan hasil yang diprediksi: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 14 read operations Read Data: FF FE FD FB</code> </pre><br>  Dapat dilihat bahwa 4 byte membutuhkan 14 upaya, yaitu pembacaan tidak menghalangi.  Terkadang sistem mengembalikan status "tidak ada data baru", dan program tersebut tertidur selama satu milidetik. <br><br>  Secara umum, semuanya baik-baik saja, tetapi tanpa osiloskop, saya tidak dapat memastikan bahwa dua port berdasarkan chip yang sama benar-benar mengatur kecepatan.  Saya sudah melompat pada kenyataan bahwa kecepatannya sama (untuk itu dia punya satu controller), tetapi bukan yang saya pesan.  Setidaknya mari kita periksa apakah setidaknya dikontrol.  Untuk melakukan ini, saya akan mengatur kecepatan port penerima menjadi dua kali lipat dari port transmisi.  Dan mengetahui fisika dari proses transfer data, Anda dapat memprediksi bagaimana data ini terdistorsi selama penerimaan.  Mari kita lihat transfer byte 0xff dalam bentuk grafis.  S - bit mulai (selalu ada nol) bit, bit P - stop (selalu ada satu), 0-7 - bit data (untuk 0xFF konstan - semua unit). <br><br><img src="https://habrastorage.org/webt/kx/0p/cz/kx0pczh7nor5fcn1nhkor8nrwum.png"><br><br>  Sekarang mari kita overlay tampilan ini dengan tampilan bagaimana semuanya akan dilihat oleh penerima yang beroperasi pada kecepatan dua kali lipat: <br><br><img src="https://habrastorage.org/webt/mp/n7/qn/mpn7qngefktxruxtyrex7ykrpwk.png"><br><br>  Bagus  Nilai "1111 1110" harus diterima (data sedikit lebih maju, yaitu 0xFE.  Bagian kedua dari nilai yang ditransmisikan tidak mempengaruhi penerimaan, karena unit sesuai dengan keheningan di telepon.  Artinya, kami mentransmisikan satu byte, satu byte juga akan datang. <br><br>  Kami akan membuat grafik yang sama untuk verifikasi, yang akan sesuai dengan nilai 0xFE yang dikirimkan: <br><br><img src="https://habrastorage.org/webt/do/e6/x2/doe6x2t9aapieqiat4gtkp9j8_y.png"><br><br>  Harapkan nilai "1111 1000" atau 0xF8.  Baiklah, mari kita verifikasi apa yang diharapkan dengan nilai 0xFD yang diteruskan: <br><br><img src="https://habrastorage.org/webt/c9/er/d0/c9erd0bsjla_b5bkwpmmzbqnrlm.png"><br><br>  Kami mendapatkan nilai 0xE6.  Nah, untuk nilai yang ditransmisikan 0xFB, kami mendapatkan 0x9E yang diterima (Anda dapat memplot grafik dan melihatnya sendiri).  Hebat!  Kami mengubah satu baris tunggal dalam aplikasi pengujian, menggantikan kecepatan 9600 dengan 19200: <br><br><pre> <code class="plaintext hljs"> int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 19200);</code> </pre><br>  Kami memulai dan mendapatkan hasil kerja ini: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 9 read operations Read Data: FE F8 E6 9E</code> </pre><br>  By the way, saya tidak sia-sia melakukan pemeriksaan ini.  Pada awalnya saya menggunakan fungsi pengaturan kecepatan lainnya (pasangan cfsetispeed / cfsetospeed), dan mereka tidak berfungsi!  Berkat tes ini, masalah telah diidentifikasi dan diselesaikan tepat waktu.  Saat bekerja dengan peralatan, Anda tidak akan pernah bisa memercayai intuisi.  Semuanya harus diperiksa! <br><br><h4>  Manajemen saluran listrik 220 volt </h4><br>  Secara umum, saluran listrik 220 volt tidak terkait dengan topik artikel (jembatan FTDI), tetapi mereka terkait dengan topik bagian ini (port serial).  Mari kita lihat mereka. <br><br><img src="https://habrastorage.org/webt/fj/py/1f/fjpy1fqzjfykydgxo28fctebh1c.png"><br><br>  Ketika kami mencantumkan port, kami melihat nama ini: <br><br><img src="https://habrastorage.org/webt/rt/0g/k7/rt0gk7ammjno5n1hgfh5waz85ri.png"><br><br>  Ini adalah port serial virtual.  Ini sangat virtual sehingga tidak masalah parameter apa pun yang dimilikinya (kecepatan port, jumlah bit, format paritas, dll.).  Tidak peduli parameter apa pun yang telah ia atur, ia masih dapat menangani perintah dengan sempurna.  Dan tim inilah yang mengendalikan outlet listrik di kompleks. <br><br><img src="https://habrastorage.org/webt/yc/ry/sk/ycryskkv2xpfkxnex41xbn5pooo.png"><br><br>  Ketika mengembangkan sistem perintah, diputuskan untuk meninggalkan antarmuka perintah yang kompleks.  Manajemen membutuhkan satu byte, tanpa membingkai string dan embel-embel lainnya, meskipun byte bersifat tekstual (sehingga dapat dengan mudah ditransfer dari terminal saat debugging).  Keringkasan ini mudah dijelaskan: antarmuka string memungkinkan Anda menangani gangguan dalam saluran UART yang tidak aman.  Tetapi dalam kasus kami, secara fisik, pekerjaan berjalan melalui saluran USB, yang dilindungi oleh kode kontrol siklik.  Memproses aliran balik memerlukan penulisan kode tambahan atau buffer yang terus-menerus disiram, yang tidak selalu nyaman.  Itu sebabnya tidak ada tolok ukur untuk string, tidak ada jawaban.  Diyakini bahwa salurannya stabil.  Jika Anda menginginkan respons, Anda dapat secara eksplisit memintanya.  Artinya, kinerja blok selalu dapat dengan mudah diperiksa dengan mengirim byte tambahan setelah perintah. <br><br>  Pertimbangkan perintah yang dapat dikirim: <br><div class="scrollable-table"><table><tbody><tr><th>  Tim </th><th>  Janji temu </th></tr><tr><td>  'A' </td><td>  Nyalakan outlet pertama </td></tr><tr><td>  'a' </td><td>  Matikan outlet pertama </td></tr><tr><td>  'B' </td><td>  Nyalakan outlet kedua </td></tr><tr><td>  'b' </td><td>  Matikan outlet kedua </td></tr><tr><td>  'C' </td><td>  Nyalakan outlet ketiga (jika ada) </td></tr><tr><td>  'c' </td><td>  Matikan outlet ketiga (jika ada) </td></tr><tr><td>  ' </td><td>  Kembalikan Status Outlet </td></tr></tbody></table></div><br>  Perintah '?'  (tanda tanya) adalah satu-satunya yang mengembalikan respons.  Menanggapi itu, 3 byte selalu datang, masing-masing sesuai dengan keadaan salah satu outlet.  Sebenarnya, negara sesuai dengan perintah.  Misalnya, 'abc' - ketiga outlet sekarang dimatikan, 'Abc' - yang pertama dinyalakan, yang kedua dan ketiga mati, dll. <br><br>  Untuk percobaan dengan subsistem ini, saya sarankan tidak menulis program khusus (tidak berbeda dari yang diberikan sebelumnya, hanya data yang dikirim ke port akan berbeda), tetapi menggunakan alat OS dan bermain secara interaktif dengan soket. <br><br>  Setelah banyak percobaan dengan melacak port melalui perintah cat dan mengirim perintah dalam jendela paralel menggunakan program echo, saya menyadari bahwa untuk beberapa alasan saya tidak dapat mencapai hasil dalam sepasang terminal ssh berbasis dempul (bahkan bermain dengan port yang hanya memiliki bahwa dia bereksperimen dengan sempurna dengan programnya).  Karena itu, saya harus menginstal program minicom standar.  Biarkan saya mengingatkan Anda perintah instalasi: <br>  <b>sudo apt-get minicom</b> <br><br>  Selanjutnya, jalankan dengan perintah: <br>  <b>minicom –D / dev / ttyACM0</b> <br><br>  Nama port pendek, karena dengan eksperimen manual itu paling mudah untuk masuk.  Dalam pekerjaan perangkat lunak, seperti biasa, lebih baik menggunakan nama yang terkait dengan hierarki perangkat keras.  Sekali lagi, saya perhatikan bahwa saya tidak mengkonfigurasi parameter port lain karena ini virtual.  Ini akan bekerja dengan pengaturan apa pun. <br><br>  Kemudian kami menekan tanda tanya di terminal dan langsung (tanpa umpan baris) kami mendapat respons <br><br><img src="https://habrastorage.org/webt/41/my/-j/41my-jjk9cffmmflot_zk_ph0ck.png"><br><br>  Ini berarti bahwa semua outlet saat ini dimatikan.  Katakanlah kita ingin menghidupkan outlet kedua.  Tekan ibukota 'B'.  Tidak ada reaksi di layar.  Tekan '?' Sekali lagi, kami mendapat baris baru dengan jawabannya: <br><br><img src="https://habrastorage.org/webt/5i/uz/-r/5iuz-rrjfbmier5bfmazwx1svb0.png"><br><br>  Semuanya berfungsi.  Jangan lupa mematikan 220 volt (perintah 'b').  Anda dapat keluar dari terminal dengan menekan ctrl + A, lalu X. Eksperimen selesai. <br><br><h2>  Ban SPI dan I <sup>2</sup> C </h2><br>  Bus SPI (yang juga dapat bekerja dalam mode Quad-SPI) dan I <sup>2</sup> C diimplementasikan dalam kombinasi dengan jembatan universal.  Artinya, secara umum, kompleks memiliki dua jembatan, yang masing-masing dapat diaktifkan baik dalam mode SPI atau di I <sup>2</sup> C. Dalam diagram struktural, bagian yang sesuai terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/uy/lp/6k/uylp6kc6vcqjrlwluk5nxzpcezc.png"><br><br>  Inti dari menyalakan bus akhir terlihat dari diagram sirkuit listrik.  Pertimbangkan hanya satu dari dua pengontrol: <br><br><img src="https://habrastorage.org/webt/ah/rj/ah/ahrjahvujglcs3uoxl-wsdxfcpy.png"><br><br>  Dengan demikian, bus SPI dan I <sup>2</sup> C tidak bersinggungan dengan cara apa pun.  Pembatasan penggunaan bersama mereka hanya ditentukan oleh pembatasan yang diberlakukan oleh FTDI pada pengontrol FT4222H.  Sayangnya, dokumentasi menyatakan bahwa hanya satu antarmuka yang dapat aktif pada satu waktu: <br><br><img src="https://habrastorage.org/webt/zc/7d/dw/zc7ddwfm-tstpt9lumoydqexceu.png"><br><br>  Cara mengelola baris CFG1_0..CFG1_1 dan CFG2_0..CFG2_1, kami akan bertemu di artikel berikutnya.  Sekarang kami percaya bahwa mereka semua dibatalkan. <br><br>  Secara umum, pekerjaan dengan controller dijelaskan dengan sangat baik dalam dokumen <b>FT4222H USB2.0 TO QUADSPI / I2C BRIDGE IC</b> , oleh karena itu kami tidak akan mempertimbangkan fitur mode kontrol pengendali.  Semuanya sangat jelas dari dokumen tersebut. <br><br>  Sedangkan untuk dukungan perangkat lunak, deskripsinya dapat ditemukan dalam dokumen yang tak kalah luar biasa.  Kami telah bekerja dengan jembatan FTDI dua kali: di paruh kedua <a href="https://habr.com/ru/post/456008/">artikel ini</a> dan di paruh kedua <a href="https://habr.com/ru/post/462253/">ini</a> .  Oleh karena itu, membandingkan dokumen ini dengan artikel-artikel ini, Anda dapat dengan cepat mengetahuinya dan mulai menulis kode Anda sendiri.  Biarkan saya tunjukkan kode referensi yang mengirim data ke bus SPI, tanpa memikirkan detail implementasinya, sepertinya sudah dianalisis dengan FT2232. <br><br><div class="spoiler">  <b class="spoiler_title">Kode yang mengirim data ke bus SPI.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include "../ftd2xx/ftd2xx.h" #include "../LibFT4222/inc/LibFT4222.h" void SpiTest (int pos) { FT_HANDLE ftHandle = NULL; FT_STATUS ftStatus; FT4222_STATUS ft4222Status; //   ftStatus = FT_Open(pos, &amp;ftHandle); if (FT_OK != ftStatus) { // open failed printf ("error: Cannot Open FTDI Device\n"); return; } ft4222Status = FT4222_SPIMaster_Init(ftHandle, SPI_IO_SINGLE, CLK_DIV_4, CLK_IDLE_LOW, CLK_LEADING, 0x01); if (FT4222_OK != ft4222Status) { printf ("error: Cannot switch to SPI Master Mode\n"); // spi master init failed return; } uint8 wrBuf [] = {0x9f,0xff,0xff,0xff,0xff,0xff,0xff}; uint8 rdBuf [sizeof (wrBuf)]; uint16 dwRead; ft4222Status = FT4222_SPIMaster_SingleReadWrite (ftHandle,rdBuf,wrBuf,sizeof (wrBuf),&amp;dwRead,TRUE); if (FT4222_OK != ft4222Status) { printf ("error: Error on ReadWrite\n"); } else { printf ("received: "); for (int i=0;i&lt;6;i++) { printf ("0x%X ",rdBuf[i]); } printf ("\n"); } FT4222_UnInitialize(ftHandle); FT_Close(ftHandle); }</code> </pre><br></div></div><br><h4>  Bagian Bus SPI </h4><br>  Pengembang kode untuk mikrokontroler sering menggunakan bus SPI sebagai generator frekuensi yang telah ditentukan.  Memang, pulsa yang dihasilkan murni secara terprogram melalui jalur GPIO tergantung pada banyak faktor.  Pertama, percabangan, memutar loop, membutuhkan siklus prosesor.  Kedua, gangguan, DMA dan faktor-faktor lain yang tidak terduga dapat mengganggu prosesor.  SPI lebih atau kurang stabil, tahu diri Anda berhasil memasukkan byte ke buffer.  Aplikasi khas dari blok SPI, yang tidak memiliki hubungan langsung dengan SPI itu sendiri, adalah kontrol RGB LEDs, yang keakuratan pengaturan durasi pulsa sangat penting. <br><br>  Sayangnya, ini tidak dapat diterima untuk jembatan FTDI.  Fragmen kode di atas akan menghasilkan pulsa ini di bus: <br><br><img src="https://habrastorage.org/webt/dv/zx/pe/dvzxpe6cevog4qaklf2zy8tkdye.png"><br><br>  Dalam hal ini, aturan operasi SPI tidak dilanggar, dari sudut pandang bus ini, semuanya berfungsi dengan benar.  Perlu diingat bahwa solusi khusus yang biasa pada pengendali tidak akan berfungsi di sini.  Benar, kompleks ini memiliki banyak konektor USB gratis.  Semua blok non-standar dapat dikembangkan secara terpisah dan terhubung dengannya. <br><br><h4>  Bagian ban I <sup>2</sup> C </h4><br>  Satu-satunya hal yang masuk akal adalah untuk menunjukkan tidak adanya resistor pull-up untuk bus I <sup>2</sup> C di sisi kompleks.  Tapi ini normal: di sisi perangkat yang berfungsi, masih ada lift.  Saat ini, pull-up dapat dilakukan ke tegangan apa pun, sehingga masuk akal jika diatur pada perangkat target. <br><br><h2>  Kesimpulan </h2><br>  Hari ini kami memperoleh keterampilan praktis dalam bekerja dengan ban yang diterapkan oleh jembatan FTDI.  Secara umum, bekerja dengan mereka adalah standar, hanya saja semua pengetahuan dirangkum dalam satu artikel, sehingga tidak mencari mereka sedikit demi sedikit.  Lain kali kita akan mempertimbangkan modul yang mengontrol perangkat non-standar, yang diimplementasikan berdasarkan pengontrol STM32.  Dalam diagram struktural, bagian ini sesuai dengan itu: <br><br><img src="https://habrastorage.org/webt/ic/w4/9g/icw49gdqjdx26qahasd425ul-sm.png"><br><br>  Tapi sungguh, semuanya sedikit lebih menarik di sana ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477662/">https://habr.com/ru/post/id477662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477648/index.html">MVCC dalam PostgreSQL-3. Versi baris</a></li>
<li><a href="../id477650/index.html">Enkripsi lalu lintas TLS menurut algoritma GOST-2012 dengan Stunnel</a></li>
<li><a href="../id477654/index.html">Mencoba instans operator yang ditingkatkan di Jawa 14</a></li>
<li><a href="../id477656/index.html">Jadi tetap saja, mengapa Anda perlu membuatnya?</a></li>
<li><a href="../id477658/index.html">Active Restore: dapatkah pemulihan bencana lebih cepat? Jauh lebih cepat?</a></li>
<li><a href="../id477668/index.html">29 November, 6 malam - devleads-mitap</a></li>
<li><a href="../id477670/index.html">Apa yang memberi otomatisasi pengujian</a></li>
<li><a href="../id477672/index.html">Hak dan kewajiban anggota tim: aspek hukum dan budaya</a></li>
<li><a href="../id477674/index.html">Apakah AI berarti cinta?</a></li>
<li><a href="../id477678/index.html">Prospek untuk televisi digital di Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>