<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎓 🏙️ 📏 Pertempuran MERGE. Kronik dengan kesimpulan dan moralitas 🔽 ✝️ ⁉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa minggu sebelum festival komit yang penting - yang terakhir sebelum feature freeze versi PostgreSQL 11 - buletin peretas , mengompresi chipset...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pertempuran MERGE. Kronik dengan kesimpulan dan moralitas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/412605/"> Beberapa minggu sebelum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">festival komit yang</a> penting - yang terakhir sebelum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>feature freeze</code></a> versi <b>PostgreSQL 11</b> - buletin <b>peretas</b> , mengompresi chipset dalam paket kiri, menyaksikan film thriller <b>MERGE</b> .  Sutradara thriller dan CEO <b>2ndQuadrant, <i>Simon Riggs</i></b> , mencoba mendorong tambalan yang mengimplementasikan sintaksis perintah MERGE dengan ketekunan dan kecerdikan yang mengesankan.  Riggs telah menjadi komedian sejak 2009, dan dengan status seorang komedian Anda dapat menyetujui tambalan sendiri.  Dia ditentang oleh komite dan veteran PostgreSQL yang tidak kalah dihormati.  Gairah menggebu-gebu jelas dan tersirat, itu bahkan tidak datang untuk menghina langsung - fakta mengejutkan bagi pelanggan tetap di banyak forum domestik.  Namun, beberapa ketegangan tetap sejauh ini ketika pertanyaan diselesaikan, dan tidak ada yang perlu diperdebatkan. <a name="habracut"></a><br><br>  Tapi nafsu adalah nafsu (mereka akan dibahas lebih lanjut), dan saya ingin memilah esensi dari masalah yang sepenuhnya dibuat-buat ini. <br><br><img src="https://habrastorage.org/webt/t5/zc/ra/t5zcramwnjffszncwjkkkl9xt2g.jpeg"><br><h3>  GABUNG di luar </h3><br>  Jika benar-benar menyederhanakan, maka masalahnya adalah ini: kami memiliki 2 tabel dengan bidang yang sama dan data yang berbeda.  Asumsikan nama dan umur.  Kita perlu menggabungkan mereka menjadi satu.  Tetapi akan perlu untuk memutuskan apa yang harus dilakukan dengan kepribadian yang ada di kedua tabel.  Kemungkinan besar kita akan menginginkan semua yang ada di tabel akhir, dan untuk memperbarui informasi ke individu yang cocok.  Jelas bahwa bahkan dalam pengaturan ini, ini adalah tugas yang sangat umum.  Ini dapat diselesaikan tanpa <code>MERGE</code> , membuat permintaan yang kompleks, Anda dapat menggunakan pemicu dan sebagainya.  Tapi itu tidak nyaman.  Namun, versi non-kanonik dari MERGE, yang disebut UPSERT (UPdate + inSERT), menyelesaikan masalah ini. <br><br>  Operator MERGE berada dalam standar SQL-2003 dan sudah dalam kejayaannya dalam SQL-2008.  Ini diimplementasikan dalam Oracle, DB2 dan MS SQL, yang berarti kurangnya MERGE akan mengecewakan mereka yang mempertimbangkan untuk beralih dari DBMS ke PostgreSQL.  Keinginan kerinduan Simon Riggs secepat mungkin, sudah ada di PostgreSQL 11, didorong oleh keinginan pelanggan 2ndQuadrant, dan bukan oleh ambisi atau pertengkaran. <br><br>  Faktanya, MERGE memiliki kemampuan yang kaya, data tidak harus diambil dari tabel, terutama dari yang serupa dalam struktur. <br><br>  Sintaks perintahnya adalah sebagai berikut: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tablename <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> table_reference <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> column1 = value1 [, column2 = value2 ...] <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (column1 [, column2 ...]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (value1 [, value2 ...]);</code> </pre> <br>  Namun, Anda dapat menyukai ini: <br><br><pre> <code class="hljs powershell">MERGE <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">hint</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INTO</span></span></span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] {</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USING</span></span></span></span> { subquery | <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view}} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ON</span></span></span></span> ( condition ) [ <span class="hljs-type"><span class="hljs-type">merge_update_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">merge_insert_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">error_logging_clause</span></span> ] ;</code> </pre> <br>  Sintaks ini diimplementasikan dalam Oracle.  Dalam kata-kata, kemudian MERGE melakukan tindakan yang mengubah catatan dalam tabel target target_table_name menggunakan data_source dalam perintah SQL tunggal, yang dapat, sesuai dengan kondisi, lakukan INSERT, UPDATE atau DELETE sehubungan dengan catatan dalam target_table_name.  Dalam hal ini, target_table_name dapat berupa tampilan, dan data_source dapat berupa serangkaian <b>tabel atau tampilan, hasil dari subquery</b> . <br><br>  Pertama, <code>MERGE</code> melakukan <code>left outer join</code> pada <code>data_source</code> dengan <code>target_table_name</code> , menyarankan 0 atau lebih catatan perubahan kandidat;  <code>WHEN</code> klausa dihitung dalam urutan yang ditentukan;  segera setelah kondisi terpenuhi, tindakan yang sesuai dilakukan.  Kata kunci <code>WHEN [NOT] MATCH THEN</code> tidak terlalu umum dalam <code>SQL</code> , jadi kami mengingatkan Anda bahwa ini adalah konstruk kontrol seperti <code>if-else</code> dalam bahasa lain.  <code>MERGE</code> bertindak dengan cara yang sama seperti <code>UPDATE, INSERT</code> atau <code>DELETE</code> sehubungan dengan <code>target_table_name</code> , hanya sintaks seluruh perintah yang berbeda. <br><br>  Klausa dengan <code>ON</code> harus membuat koneksi pada semua kolom kunci utama atau, jika kolom lain ditentukan, maka beberapa indeks unik harus digunakan sehingga kondisi <code>[NOT] MATCHED</code> segera menentukan tindakan untuk catatan kandidat untuk mengecualikan interaksi dengan transaksi lainnya. <br><br>  Perintah deterministik <code>MERGE</code> : Anda tidak dapat memperbarui catatan yang sama beberapa kali dalam perintah MERGE yang sama. <br>  Contoh: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> CustomerAccount CA <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> RecentTransactions T <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> T.CustomerId = CA.CustomerId <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Balance = Balance + TransactionValue <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (CustomerId, Balance) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (T.CustomerId, T.TransactionValue);</code> </pre> <br>  atau dengan subquery: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bonuses D <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_id, salary, department_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">80</span></span>) S <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (D.employee_id = S.employee_id) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> D.bonus = D.bonus + S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &gt; <span class="hljs-number"><span class="hljs-number">8000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (D.employee_id, D.bonus) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (S.employee_id, S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &lt;= <span class="hljs-number"><span class="hljs-number">8000</span></span>);</code> </pre> <br>  Di <b>IBM DB2,</b> sintaks akan bekerja juga.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seperti yang mereka katakan</a> , "di bawah tenda" ini akan dilakukan mirip dengan konstruksi <code>UPDATE FROM</code> . <br>  Sejak 2008, <b>MS SQL</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga memiliki</a> <code>MERGE</code> . <br><br>  Tetapi bahkan di balik sintaks standar tunggal, masalah memilih dari sejumlah besar mekanisme dan metode implementasi dimulai.  Tim harus bekerja pada tingkat isolasi transaksi yang berbeda, dengan algoritme penguncian yang berbeda, dengan fokus pada mode operasi yang sangat kompetitif atau tidak-jadi-begitu.  Dan, seperti yang Anda duga, untuk mengimplementasikan logika yang rumit ini, Anda perlu menyentuh banyak komponen DBMS. <br><br><h3>  UPSERT, pseudo-MERGE </h3><br>  Jelas bahwa pengembang DBMS mencari solusi kompromi, menolak untuk benar-benar mereproduksi sintaks standar.  Kelebihan dari pendekatan ini adalah kebebasan.  Anda dapat menggunakan mekanisme yang organik untuk DBMS tertentu, Anda dapat mengoptimalkan implementasi untuk tugas-tugas yang Anda anggap paling relevan bagi pengguna Anda. <br><br>  Misalnya, di <b>MySQL</b> ada perintah <code>REPLACE</code> yang berfungsi sebagai <code>INSERT</code> , tetapi jika baris baru dan lama memiliki nilai yang sama dalam indeks <code>PRIMARY KEY</code> atau indeks <code>UNIQUE</code> , maka baris lama terbunuh sebelum yang baru dimasukkan.  Tetapi ada juga <code>INSERT ... ON DUPLICATE KEY UPDATE</code> mana <code>INSERT</code> dan <code>UPDATE</code> terjadi (bukan <code>DELETE</code> dalam <code>REPLACE</code> ).  Ini adalah <code>UPSERT</code> .  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada</a> <code>INSERT IGNORE</code> , yang tidak melakukan penyisipan, tanpa melemparkan kesalahan (tetapi peringatan) di bawah batasan tertentu pada tabel target. <br><br><h3>  Kronik PG MERGE </h3><br>  Di komunitas PostgreSQL, pembicaraan tentang MERGE dimulai pada 2005 ketika Jaime Casanova bertanya <i>apakah ada orang di komunitas yang mulai mengembangkan</i> <code>MERGE</code> .  <i>Peter Eisentraut</i> <a href="">menyarankan mendiskusikan</a> <i>apakah PostgreSQL harus mengembangkan salah satu opsi MERGE: mirip dengan implementasi MySQL, atau lebih baik untuk mengarahkan upaya ke versi ringan fungsional dari tipe <code>MERGE</code> dari Oracle.</i>  <i>Namun, apakah layak untuk melakukan upaya ke arah ini?</i> <br><br>  Di tengah diskusi singkat, protagonis dari cerita ini <i>Simon Riggs</i> muncul dengan kata-kata: <br>  <i>MERGE berguna baik untuk sistem OLTP dan untuk DW (Data Warehouse - data warehouse, yaitu aplikasi analitis di mana pertanyaan kompleks, tetapi lingkungan yang tidak terlalu kompetitif dan data jarang diperbarui, dan jika diperbarui, biasanya dalam potongan besar. &lt;...&gt; Kita dapat mengimplementasikan MERGE sebagai varian dari COPY FROM, itu akan sangat keren.</i> <br><br>  Semua orang setuju: ya, keren.  Lebih tepatnya, hampir semuanya: <i>Stephen Frost</i> : <i>Saya pikir saya bukan satu-satunya yang mengatakan bahwa saya memerlukan standar MERGE yang lengkap dan patuh.</i> <br><br>  Bruce Momjian memiliki proposal yang berbeda dan lebih pragmatis: <i>bagi saya tampaknya kita perlu mengimplementasikan</i> <i>beberapa opsi yang dapat</i> <i>diimplementasikan di</i> <code>MERGE</code> <i>, dan sisanya kami akan memberikan kesalahan (dan dalam kasus-kasus di mana akan diperlukan untuk memblokir seluruh tabel).</i>  <i>Dan setelah kami mendapat umpan balik dari pengguna dan kami akan memikirkan apa yang harus dilakukan selanjutnya.</i> <br><br>  Namun sejauh ini tidak ada yang terjadi. <br><br><h3>  Esnya sudah pecah </h3><br>  Pada tahun <b>2008,</b> <i>Simon Riggs</i> sekali lagi mendesak untuk berurusan dengan MERGE - yang mana dari cara untuk memilih (saat itu versi baru MERGE dalam standar SQL-2008, yang masih konsep, sudah muncul).  Dia melukis secara rinci saat ini implementasi Oracle, IBM dan MS SQL dan sintaksis alternatif dari MySQL dan Teradata saat itu.  Dan sedikit kemudian dia sudah menyebutkan <b>awal pekerjaan di 2ndQuadrant</b> ke arah ini. <br><br>  Peter Eisentraut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis di blognya</a> : <i>Tentu saja, Riggs adalah salah satu spesialis yang paling memenuhi syarat, ia dapat memimpin pekerjaan pada implementasi MERGE.</i> <br><br>  Tetapi inilah giliran pertama yang tidak terduga: seorang <b>siswa</b> terlibat dalam masalah - seorang peserta dalam pengembangan program <b>GSoC</b> , yaitu, Google Summer of Code.  Namanya <i>Boxuan Bxzhai</i> - Saya tidak berani menuliskan nama belakang.  Segera dia menulis bahwa pekerjaannya hampir selesai. <br><br>  Tetapi hampir tidak masuk hitungan.  <i>Greg Smith</i> dari 2ndQuadrant (mis. Simon Riggs ally) menulis: <br>  <i>Jadi, kami memiliki tambalan dalam kode yang setengah lusin masalah serius yang belum terselesaikan.</i>  <i>Saya diam tentang hal-hal kecil.</i>  <i>Masalahnya terlalu dalam untuk menyelesaikan kode untuk commitfest.</i>  <i>Sementara itu, tidak ada yang terdengar dari Boxuan untuk waktu yang lama.</i>  <i>Kita bisa membantunya, tetapi di mana dia?</i>  <i>Siapa yang tahu?</i> <br><br>  Diskusi tentang jalur implementasi kembali berkobar di tahun <b>2014</b> , tetapi sekali lagi tidak ada yang terjadi: tidak ada kode. <br><br>  Akhirnya, pada awal <b>2017,</b> <i>Simon Riggs</i> menulis: <br>  <i>Saya sedang mengerjakan kode untuk mengkomit <code>MERGE</code> ke <b>PostgreSQL</b> versi <b>11</b> .</i>  <i>Kami menggunakan mekanisme yang sama yang mendasari <code>INSERT ON CONFLICT</code> sudah berfungsi, sehingga tidak ada perubahan infrastruktur yang diperlukan, pada dasarnya hanya menerapkan sintaksis di atas apa yang tersedia.</i>  <i>Tapi saya menulis kode saya dari awal, saya tidak menggunakan perkembangan sebelumnya.</i> <br><br>  Kita berbicara tentang Peter Geoghegan ( <b>VMware</b> ) yang diimplementasikan pada saat itu sudah dalam 9,5 alternatif sintaks <code>INSERT .. ON CONFLICT UPDATE</code> , berbeda dari standar SQL, tetapi masih terkait dengan <code>MERGE</code> dan <code>REPLACE</code> di MySQL. <br><br>  Pada awalnya, karya Simon disambut dengan seru dari karya Nice!  Namun, <i>Robert Haas</i> , meskipun mendukung, memperingatkan kemungkinan anomali serialisasi.  Seperti, untuk berurusan dengan <code>INSERT .. ON CONFLICT UPDATE</code> , tanpa MERGE pada dasarnya, entah bagaimana lebih tenang. <br><br>  PostgreSQL <code>UPSERT</code> penulis <code>UPSERT</code> sendiri: <br>  <i>Saya tidak akan mencampur kode <code>ON CONFLICT DO UPDATE</code> dan <code>MERGE</code> .</i>  <i>&lt;...&gt; Untuk memuat potongan besar data ( <code>bulk load</code> ) saya akan, misalnya, menggunakan algoritma <code>merge join</code> .</i>  <i>&lt;...&gt; Secara umum, keunggulan <code>MERGE</code> akan terkait dengan fakta bahwa koneksi normal akan bekerja di sana dengan cara yang biasa: <code>nested loop, hash, merge</code> .</i>  <i>Dan di <code>INSERT … ON CONFLICT</code> tidak ada gabungan sama sekali.</i> <br><br>  Haas: <i>Seperti Peter, saya pikir jika dilakukan dengan cara ini, maka kunci yang kuat ketika menjalankan permintaan <code>DML</code> terlihat begitu-begitu.</i>  <i>Tidak mungkin ada orang yang senang bahwa hanya satu orang yang dapat bekerja dengan <code>MERGE</code> pada satu waktu.</i> <br><br>  Bagi mereka yang penasaran: Geigan mem-parsing kehalusan dan perbedaan besar antara <code>MERGE</code> dan <code>MERGE</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (kami menyimpan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">korespondensi yang diarsipkan dari</a> PostgreSQL di situs web kami). <br><br>  Simon menolak.  Ia mengimbau Sejarah Terbaru.  Seperti, tentang perpisahan mereka juga mengatakan "sintaks baru, tidak lebih."  Namun ternyata hal itu menjadi hal yang sangat berguna.  <i>Tetapi saya tidak mengusulkan untuk segera merealisasikan semua yang ada dalam MERGE.</i>  <i>Kami akan melakukan hal yang sama dengan mempartisi - kami membagi pengembangan menjadi beberapa fase.</i> <br><br>  Dan satu argumen lagi, menurut saya sangat meyakinkan: <i>Bagus.</i>  <i>Tapi mari kita pilih.</i>  <i>Saya menyarankan opsi praktis.</i>  <i><b>10 tahun akan segera datang</b> dari upaya serius pertama untuk mengembangkan <code>MERGE</code> .</i>  <i>Bukankah sudah waktunya untuk mulai melakukan sesuatu, untuk mendapatkan beberapa solusi yang bermanfaat, alih-alih menunggu 10 tahun Solusi Sempurna?</i>  <i>Dengan asumsi itu ada sama sekali.</i> <br><br>  Akhirnya, tambalan tiba di komunitas.  Tanggal berapa?  Tolong bayangkan.  Tidak, mereka tidak menebak: Simon mengirimnya pada 30 Desember 2017.  Dan menetapkan bahwa ini adalah patch WIP, yaitu, Work in Progress - patch in work. <br><br>  Simon, Januari: <br>  <i>Patch selesai tanpa bug khusus.</i>  <i><b>1200 baris kode</b> plus tes dan dokumentasi.</i>  <i>Saya akan mengkomitnya ke commitfest ini, dan kami akan menyelesaikan RLS (Row Level Security - perlindungan di tingkat perekaman) dan dukungan partisi nanti.</i> <br><br><h3>  Komite dari kasta </h3><br>  Di sini kita harus mengambil langkah ke samping dan menjelaskan peran komisaris di masyarakat.  Fungsi komisaris, yaitu, orang yang diberdayakan untuk menerima tambalan di versi berikutnya, telah berubah secara historis.  Sekali waktu, ketika ada beberapa pengembang, hak untuk melakukan didistribusikan dengan murah hati.  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Julian Assange</b></a> yang terkenal (dalam bidang yang sama sekali berbeda) menerima gelar komandan, menjadi penulis hanya enam tambalan.  Sekarang tidak mudah untuk menjadi komisaris, tidak ada pemula dalam daftar beberapa lusin orang.  Boyus Momdjan ( <b>EnterpriseDB</b> ) memiliki 13.363 komit, Tom Lane (Tom Lane, <b>Crunchy Data</b> ) 13127, Robert Haas ( <b>EnterpriseDB</b> ) - 2074. Omong-omong, <b>satu</b> - <b>satunya committer dari Rusia</b> adalah <i>Fedor Sigaev</i> ( <b>Postgres Professional</b> ) dengan 383 komitnya .  Simon Riggs sendiri memiliki 449. Saya ulangi: dia, sebagai seorang komisaris, memiliki cukup wewenang untuk mengambil dan melakukan perbaikan - dia dan karyawannya.  Hal lain adalah bahwa hampir tidak ada gunanya melakukan hal ini, terus terang mengabaikan pendapat komite-komite terkemuka lainnya.  Mereka juga dapat menghilangkan status komisaris, tetapi setidaknya mereka akan <code>revert</code> patch kembali. <br><br><h3>  Fraktur dalam pertempuran </h3><br>  Tentu saja, di patch "putus asa", dibuat, secara umum, dengan tergesa-gesa, mereka menemukan kesalahan baru.  Versi baru merespons. <br><br>  Pada akhir Januari, muncul karakter baru: pengembang 2ndQuadrant <i>Pavan</i> (namanya semua orang dengan nama; sepenuhnya Pavan Deolasee).  Sekarang masyarakat berhadapan dengan tandem: Pavan mengirimkan versi baru dan terima kasih atas kritiknya, dan Simon menghancurkan mereka dengan tekanan pemasaran yang luar biasa. <br><br>  Haas: <i>Saya rasa tidak perlu mengambil keputusan sepihak untuk mengecualikan fitur yang bekerja di mana-mana.</i>  <i>Jika kami setuju bahwa beberapa fitur tidak akan disertakan dalam tambalan ini - ini adalah satu hal.</i>  <i>Dan sangat berbeda bahwa dalam komentar pada kesempatan ini semua orang menyatakan ketidaksetujuan.</i>  <i>Dan kami sebenarnya tidak mendengar alasan mengapa fitur ini harus dikecualikan.</i> <br><br>  Logikanya disajikan sebagai berikut: <br><br><ul><li>  a priori, ada masalah serius karena mereka tidak bisa tidak berada dalam perkembangan dalam gaya "serangan kavaleri." </li><li>  Dukungan bahkan untuk fitur-fitur penting seperti partisi baru di versi 10-11, CTE (Common Table Expressions = WITH queries) atau RLS (Row Level Security) dapat diselesaikan bahkan setelah patch diterima dalam versi saat ini, tetapi hanya jika arsitektur yang diusulkan cocok untuk membangun di atas fungsi yang diinginkannya. </li></ul><br>  Peter Geigan kedua merumuskan ini: <br>  <i>Biasanya saya memperhatikan <b>dukungan berbagai fungsi, karena jika ya, itu memperkuat kepercayaan umum bahwa desain dibuat sebagaimana mestinya</b> .</i>  <i>Dan jika masalah tersebut disebabkan oleh dukungan dengan ekspresi [yaitu, <code>CTE</code> ], maka saya mendapatkan ide bahwa arsitektur yang mendasarinya sedemikian rupa sehingga akan menyebabkan masalah di sana-sini.</i> <br><br>  Sementara itu, jam X (panitia terakhir) semakin dekat, dan awan di atas MERGE berkumpul.  Bukan karena para pendiri pendiri secara khusus mencari masalah serius dalam arsitektur tambalan yang dibuat oleh Simon dan kemudian Pavan.  Saya tidak perlu mencari masalah, mereka rela membuka diri. <br><br><h3>  Pengunduran diri sudah dekat </h3><br>  Plotnya semakin cepat.  Meskipun sikap keren komite lain terhadap usahanya, <b>pada tanggal 2 April,</b> Simon memutuskan untuk melakukan <b>Komando berikut SQL:</b> patch <b>2016</b> , menambahkan file, Depesz (Hubert Lubachevsky) berhasil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengumumkannya</a> di blog-nya, tetapi pada hari yang sama Simon mengembalikan semuanya karena kesalahan. <br><br>  Hari berikutnya, komit kembali dengan menambahkan <code>WITH</code> dukungan. <br><br>  Sebagai tanggapan, tuduhan itu benar-benar serius.  <i>Andres Freund</i> ( <b>EnterpriseDB</b> ) menulis: <br>  <i>Arsitektur untuk MERGE di parser dan pelaksana tidak membuat saya terkesan.</i>  <i>Membuat sambungan tersembunyi selama analisis parsing adalah ide yang sangat buruk.</i>  <i>Struktur pelaksana ini harus benar-benar diubah.</i> <br><br>  Tom Lane: <br>  <i>Desain pohon parsing lemah.</i> <br><br><br><br>  <i>Anda membebani fungsi <code>InsertStmt</code> , ia melanjutkan, itu tidak melakukan <code>INSERT</code> sama sekali, tetapi secara acak memiliki bidang yang sama dengan yang asli.</i>  <i>Dan tidak semua, tetapi beberapa.</i>  <i>Ini buruk, itu menyebabkan kebingungan.</i> <br><br>  Mari tambahkan pengamatan <i>Fedor Sigayev</i> : <br>  <i>Di parser, node <code>INSERT</code> terkait <code>MERGE</code> muncul, digantung dengan sekelompok bidang tambahan.</i>  <i>Jika Anda melihat rencana pelaksanaan dalam <code>ANALIZE</code> , Anda tidak akan segera mengerti apakah Anda berurusan dengan <code>INSERT</code> biasa atau dengan <code>MERGE</code> : untuk memahami, Anda perlu melihat bidang tambahan.</i> <br><br><br>  Simon, dengan tenang: <i>OK, kita akan mengubahnya dan mengirim file baru besok</i> . <br>  Haas: <i>Saya setuju dengan Peter.</i>  <i>Pilihan arsitektur tidak berhasil.</i> <br><br>  Simon tidak menyerah.  <b>6 April,</b> dalam menanggapi kritik terhadap Tom Lane, melakukan tambalan baru sebagaimana telah diubah dalam pengurai. <br><br><h3>  Negosiasi dan penyerahan </h3><br>  Bruce Momjan <b>6 April</b> : <br>  <i>Saya ingin mencatat bahwa orang tidak meminta Anda untuk bekerja keras untuk segera memperbaiki sesuatu.</i>  <i>Mereka meminta Anda untuk menarik tambalan.</i>  <i>Anda dapat, tentu saja, bekerja keras, berharap mereka akan berubah pikiran, tetapi - sekali lagi - mereka tidak menanyakan hal itu kepada Anda.</i> <br><br>  Simon: <i>Jika Tom [Lane] dan Andres [Freund] selama beberapa hari masih merasa bahwa ketakutan mereka belum <b>hilang</b> , saya <b>akan dengan senang hati mengembalikan tambalan</b> tanpa basa-basi lagi.</i> <br><br>  Tom Lane: <i>Saya masih memilih tambalan untuk dibatalkan.</i>  <i>Bahkan jika dia sempurna sekarang, sekarang orang tidak punya waktu untuk diyakinkan tentang ini - ke tenggorokan masalah mendesak lainnya.</i> <br><br>  Itu saja. <br><br>  Simon berkata OK, dan pertempuran di <code>MERGE</code> berakhir.  Semua tambalan telah dipompa kembali, topik telah dipindahkan ke commitfest berikutnya dengan status "Menunggu penyelesaian penulis".  Para peserta dalam pertunjukan berdamai. <br><br><img src="https://habrastorage.org/webt/ad/zw/ry/adzwryarovhxoldwxewpneljyms.jpeg"><br>  Namun, dilihat dari korespondensi beberapa minggu terakhir, beberapa ketegangan tampaknya tetap ada. <br><br><h3>  Moralitas yang Dijanjikan </h3><br><ul><li>  Untungnya, komunitas PostgreSQL memiliki mekanisme alami dan formal untuk (hampir) penyaringan upaya-upaya untuk solusi yang belum matang.  Bahkan jika mereka dipukul oleh pengembang yang dihormati di pangkat kepala perusahaan, yang kontribusinya terhadap pengembangan PostgreSQL sangat besar.  Dan pelanggan yang kurang fungsional mendorong untuk berinvestasi. </li><li>  Sayangnya, komunitasnya sering warung.  Ia bersifat inersia dalam mengadopsi perkembangan yang bahkan jelas relevan.  Terkadang perfeksionisme yang irasional dimasukkan.  Pengalaman Postgres Professional, tempat saya bekerja, menegaskan hal ini.  Kami menekan patch besar termasuk <b>indeks INCLUDE</b> selama 3 tahun.  Serangkaian tambalan yang berguna untuk bekerja dengan <b>JSON / JSONB</b> masih menunggu.  Ungkapan "berikan pengembangan Anda ke komunitas" <b>tidak benar</b> - <b>benar</b> berarti <b>memberi, tetapi meninju</b> : tamu disambut dengan tangan terbuka dan dikawal ke karantina. </li></ul><br>  PS: <i>Penafian dari penulis</i> : kami hanya ingin menunjukkan sepotong kehidupan komunitas.  Semua nama yang cocok adalah acak :) <br>  PPS: Samurai <i>Natalia Levshina</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412605/">https://habr.com/ru/post/id412605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412591/index.html">Membangun jetpack: 29 Mei adalah Hari Peringatan Wendell Moore</a></li>
<li><a href="../id412593/index.html">Produk Baru, Platform, dan All-as-a-Service: HPE Webinar</a></li>
<li><a href="../id412595/index.html">Laporan Club of Rome 2018, Bab 1.1.2: “Pembiayaan”</a></li>
<li><a href="../id412597/index.html">Jeff Bezos akan membangun koloni di permukaan bulan</a></li>
<li><a href="../id412603/index.html">Pernyataan php yang aneh</a></li>
<li><a href="../id412607/index.html">Stasiun solder reversibel kelas HI-END</a></li>
<li><a href="../id412609/index.html">10 tips untuk produktivitas di CLion, C / C ++ IDE lintas-platform</a></li>
<li><a href="../id412611/index.html">Apa yang dimiliki oleh teori penambangan dan permainan yang efektif</a></li>
<li><a href="../id412613/index.html">Aritmatika integer. Bagilah dengan membulatkan hasilnya. Bagian 1</a></li>
<li><a href="../id412615/index.html">Kehadiran Target Rute dalam Pengumuman BGP antara PE dan CE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>