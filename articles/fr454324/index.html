<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👙 👨🏼‍🔬 🕵🏿 Pointeurs en Python: à quoi ça sert? 🙅🏽 🕝 📮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous avez déjà travaillé avec des langages de bas niveau comme C ou C ++, vous avez probablement entendu parler de pointeurs. Ils vous permettent d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pointeurs en Python: à quoi ça sert?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454324/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_i/vd/cj/_ivdcjv0itamifffxs0i1i-mqh4.jpeg"></div><br>  Si vous avez déjà travaillé avec des langages de bas niveau comme C ou C ++, vous avez probablement entendu parler de pointeurs.  Ils vous permettent d'augmenter considérablement l'efficacité de différents morceaux de code.  Mais ils peuvent également dérouter les novices - et même les développeurs expérimentés - et conduire à des bugs de gestion de la mémoire.  Y a-t-il des pointeurs en Python, puis-je les émuler d'une manière ou d'une autre? <br><br>  Les pointeurs sont largement utilisés en C et C ++.  En fait, ce sont des variables qui contiennent les adresses mémoire auxquelles se trouvent les autres variables.  Pour rafraîchir les pointeurs, lisez cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">critique</a> . <br><br>  Grâce à cet article, vous comprendrez mieux le modèle objet en Python et découvrirez pourquoi les pointeurs n'existent pas réellement dans ce langage.  Si vous avez besoin de simuler le comportement de pointeurs, vous apprendrez à les émuler sans le cauchemar de gestion de la mémoire qui l'accompagne. <br><a name="habracut"></a><br>  Avec cet article, vous: <br><br><ul><li>  Découvrez pourquoi Python n'a pas de pointeurs. </li><li>  Apprenez la différence entre les variables C et les noms en Python. </li><li>  Apprenez à émuler des pointeurs en Python. </li><li> Utilisez des <code>ctypes</code> expérimenter avec de vrais pointeurs. </li></ul><br>  <b>Remarque</b> : Ici, le terme «Python» est appliqué à l'implémentation Python en C, connue sous le nom de CPython.  Toutes les discussions sur le périphérique de langage sont valides pour CPython 3.7, mais peuvent ne pas correspondre aux itérations suivantes. <br><br><h2>  Pourquoi n'y a-t-il pas de pointeurs en Python? </h2><br>  Je ne sais pas.  Les pointeurs peuvent-ils exister en Python nativement?  Probablement, mais apparemment, les pointeurs contredisent le concept de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zen of Python</a> , car ils provoquent des changements implicites au lieu de changements explicites.  Les pointeurs sont souvent assez complexes, surtout pour les débutants.  De plus, ils vous poussent à des décisions infructueuses ou à faire quelque chose de vraiment dangereux, comme lire dans une zone de mémoire, où vous n'auriez pas dû le lire. <br><br>  Python essaie d'abstraire les détails d'implémentation de l'utilisateur, comme une adresse mémoire.  Souvent, dans ce langage, l'accent est mis sur l'utilisabilité et non sur la vitesse.  Par conséquent, les pointeurs en Python n'ont pas beaucoup de sens.  Mais ne vous inquiétez pas, la langue par défaut vous offre certains des avantages de l'utilisation des pointeurs. <br><br>  Pour comprendre les pointeurs en Python, passons brièvement en revue les fonctionnalités de l'implémentation du langage.  En particulier, vous devez comprendre: <br><br><ol><li>  Quels sont les objets mutables et immuables. </li><li>  Comment les variables / noms sont-ils organisés en Python. </li></ol><br>  Accrochez-vous à vos adresses mémoire, c'est parti! <br><br><h2>  Objets en Python </h2><br>  Tout en Python est un objet.  Par exemple, ouvrez REPL et voyez comment <code>isinstance()</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>isinstance(<span class="hljs-number"><span class="hljs-number">1</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(list(), object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; isinstance(foo, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Ce code montre que tout en Python est en fait un objet.  Chaque objet contient au moins trois types de données: <br><br><ul><li>  Compteur de référence. <br></li><li>  Tapez <br></li><li>  La valeur. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un compteur de référence est</a> utilisé pour gérer la mémoire.  Les détails sur cette gestion sont écrits dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestion de la mémoire en Python</a> .  Le type est utilisé au niveau CPython pour assurer la sécurité du type pendant l'exécution.  Et la valeur est la valeur réelle associée à l'objet. <br><br>  Mais tous les objets ne sont pas identiques.  Il y a une différence importante: les objets sont mutables et immuables.  Comprendre cette distinction entre les types d'objets vous aidera à mieux comprendre la première couche de l'oignon appelée «pointeurs en Python». <br><br><h2>  Objets mutables et immuables </h2><br>  Il existe deux types d'objets en Python: <br><br><ol><li>  Objets immuables (ne peuvent pas être modifiés); <br></li><li>  Objets modifiables (sous réserve de modifications). <br></li></ol><br>  Reconnaître cette différence est la première clé pour voyager à travers le monde des pointeurs en Python.  Voici la caractéristique d'immuabilité de certains types populaires: <br><br><div class="scrollable-table"><table><tbody><tr><th width="400">  Tapez <br></th><th width="400">  Immuable? <br></th></tr><tr><td>  int <br></td><td>  Oui <br></td></tr><tr><td>  flotter <br></td><td>  Oui <br></td></tr><tr><td>  bool <br></td><td>  Oui <br></td></tr><tr><td>  complexe <br></td><td>  Oui <br></td></tr><tr><td>  tuple <br></td><td>  Oui <br></td></tr><tr><td>  frozenset <br></td><td>  Oui <br></td></tr><tr><td>  str <br></td><td>  Oui <br></td></tr><tr><td>  liste <br></td><td>  Non <br></td></tr><tr><td>  ensemble <br></td><td>  Non <br></td></tr><tr><td>  dicter <br></td><td>  Non <br></td></tr></tbody></table></div><br>  Comme vous pouvez le voir, la plupart des types primitifs couramment utilisés sont immuables.  Vous pouvez le vérifier en écrivant du code Python.  Vous aurez besoin de deux outils de la bibliothèque standard: <br><br><ol><li>  <code>id()</code> renvoie l'adresse mémoire de l'objet; <br></li><li>  <code>is</code> renvoie <code>True</code> si et seulement si deux objets ont la même adresse mémoire. <br></li></ol><br>  Vous pouvez exécuter ce code dans un environnement REPL: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049376</span></span></code> </pre> <br>  Ici, nous définissons la variable <code>x</code> à <code>5</code> .  Si vous essayez de modifier la valeur en utilisant l'addition, vous obtiendrez un nouvel objet: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049408</span></span></code> </pre> <br>  Bien qu'il puisse sembler que ce code modifie simplement la valeur de <code>x</code> , en réalité, vous obtenez un <b>nouvel</b> objet comme réponse. <br><br>  Le type <code>str</code> est également immuable: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = <span class="hljs-string"><span class="hljs-string">"real_python"</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819584048</span></span> &gt;&gt;&gt; s += <span class="hljs-string"><span class="hljs-string">"_rocks"</span></span> &gt;&gt;&gt; s <span class="hljs-string"><span class="hljs-string">'real_python_rocks'</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819609424</span></span></code> </pre> <br>  Et dans ce cas, <code>s</code> après l'opération <code>+=</code> obtient une adresse mémoire <b>différente</b> . <br><br>  <b>Bonus</b> : l'opérateur <code>+=</code> traduit par différents appels de méthode. <br><br>  Pour certains objets, comme une liste, <code>+=</code> converti en <code>__iadd__()</code> (ajout local).  Il se changera et renverra le même ID.  Cependant, <code>str</code> et <code>int</code> n'ont pas ces méthodes et par conséquent, <code>__add__()</code> sera appelé à la place de <code>__iadd__()</code> . <br><br>  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation du modèle de données</a> Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour plus de détails</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a> <br><br>  Lorsque nous essayons de modifier directement la valeur de chaîne de <code>s</code> nous obtenons une erreur: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"R"</span></span></code> </pre> <br>  Trace arrière (les derniers appels sont affichés en dernier): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;mdule&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'str'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Le code ci-dessus se bloque et Python signale que <code>str</code> ne prend pas en charge cette modification, ce qui correspond à la définition d'immuabilité du type <code>str</code> . <br><br>  Comparez avec un objet mutable, par exemple, avec une liste: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span> &gt;&gt;&gt; my_list.append(<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Ce code illustre la principale différence entre les deux types d'objets.  Initialement, <code>my_list</code> a un ID.  Même après avoir ajouté <code>4</code> à la liste, <code>my_list</code> toujours <b>le même</b> ID.  La raison en est que la <code>list</code> types est modifiable. <br><br>  Voici une autre démonstration de la mutabilité des listes à l'aide de l'affectation: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Dans ce code, nous avons changé <code>my_list</code> et l' <code>my_list</code> mis à <code>0</code> comme premier élément.  Cependant, la liste a conservé le même ID après cette opération.  La prochaine étape sur notre chemin vers l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">apprentissage de Python</a> sera d'explorer son écosystème. <br><br><h2>  Nous traitons des variables </h2><br>  Les variables en Python sont fondamentalement différentes des variables en C et C ++.  Essentiellement, ils n'existent tout simplement pas en Python.  <b>Au lieu de variables, il y a des noms</b> . <br><br>  Cela peut sembler pédant, et pour la plupart c'est le cas.  Le plus souvent, vous pouvez prendre des noms en Python comme variables, mais vous devez comprendre la différence.  Ceci est particulièrement important lorsque vous étudiez un sujet aussi difficile que les pointeurs. <br><br>  Pour vous faciliter la tâche, voyons comment fonctionnent les variables en C, ce qu'elles représentent, puis comparons avec le travail des noms en Python. <br><br><h3>  Variables en C </h3><br>  Prenez le code qui définit la variable <code>x</code> : <br><br><pre> <code class="python hljs">int x = <span class="hljs-number"><span class="hljs-number">2337</span></span>;</code> </pre> <br>  L'exécution de cette ligne courte passe par plusieurs étapes différentes: <br><br><ol><li>  Allouer suffisamment de mémoire pour un nombre. <br></li><li>  Affectation de <code>2337</code> à cet emplacement mémoire. <br></li><li>  Le mappage que <code>x</code> indique cette valeur. <br></li></ol><br>  Une mémoire simplifiée pourrait ressembler à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/e62/d71/f13e62d71774b73aecff45931b6db57f.png"><br><br>  Ici, la variable <code>x</code> a une fausse adresse de <code>0x7f1</code> et une valeur de <code>2337</code> .  Si vous souhaitez ultérieurement modifier la valeur de <code>x</code> , vous pouvez le faire: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">2338</span></span>;</code> </pre> <br>  Ce code définit la variable <code>x</code> nouvelle valeur de <code>2338</code> , <code>2338</code> ainsi la valeur <b>précédente</b> .  Cela signifie que la variable <code>x</code> <b>mutable</b> .  Schéma de mémoire mis à jour pour la nouvelle valeur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/491/19b/34749119bcba5c4009861aa4e7c40c45.png"><br><br>  Veuillez noter que l'emplacement de <code>x</code> pas changé, seulement la valeur elle-même.  C'est important.  Cela nous dit que <code>x</code> est <b>un lieu en mémoire</b> , et pas seulement un nom. <br><br>  Vous pouvez également considérer cette question comme faisant partie du concept de propriété.  D'une part, <code>x</code> possède une place en mémoire.  Tout d'abord, <code>x</code> est une boîte vide qui ne peut contenir qu'un seul entier, dans lequel les valeurs entières peuvent être stockées. <br><br>  Lorsque vous attribuez à <code>x</code> une valeur, vous placez la valeur dans une boîte qui appartient à <code>x</code> .  Si vous souhaitez introduire une nouvelle variable <code>y</code> , vous pouvez ajouter cette ligne: <br><br><pre> <code class="python hljs">int y = x;</code> </pre> <br>  Ce code crée une nouvelle boîte appelée <code>y</code> et copie la valeur de <code>x</code> dedans.  Maintenant, le circuit mémoire ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caa/74d/ed3/caa74ded301b1f527e1b94516f1b1196.png"><br><br>  Notez le nouvel emplacement <code>y</code> - <code>0x7f5</code> .  Bien que la valeur <code>x</code> été copiée dans <code>x</code> , la variable <code>y</code> possède une nouvelle adresse en mémoire.  Par conséquent, vous pouvez remplacer la valeur de <code>y</code> sans affecter <code>x</code> : <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2339</span></span>;</code> </pre> <br>  Maintenant, le circuit mémoire ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/f8d/ed4/fcff8ded49647ad0053a45f0773cb4bb.png"><br><br>  Je le répète: vous avez changé la valeur de <code>y</code> , mais pas l'emplacement.  De plus, vous n'avez pas affecté la variable d'origine <code>x</code> . <br><br>  Avec des noms en Python, la situation est complètement différente. <br><br><h3>  Noms en Python </h3><br>  Il n'y a pas de variables en Python, des noms à la place.  Vous pouvez utiliser le terme «variables» à votre discrétion, mais il est important de connaître la différence entre les variables et les noms. <br><br>  Prenons le code équivalent de l'exemple C ci-dessus et écrivons-le en Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2337</span></span></code> </pre> <br>  Comme en C, le code passe par plusieurs étapes distinctes lors de l'exécution de ceci: <br><br><ol><li>  PyObject est créé. <br></li><li>  Le numéro de PyObject se voit attribuer un code de type. <br></li><li>  <code>2337</code> reçoit une valeur pour PyObject. <br></li><li>  Le nom <code>x</code> est créé. </li><li>  <code>x</code> pointe vers le nouveau PyObject. </li><li>  Le nombre de références de PyObject est incrémenté de 1. <br></li></ol><br>  <b>Remarque</b> : <a href="">PyObject</a> n'est pas identique à un objet en Python, cette entité est spécifique à CPython et représente la structure de base de tous les objets Python. <br><br>  PyObject est défini comme une structure C, donc si vous vous demandez pourquoi vous ne pouvez pas appeler directement le code de type ou le compteur de référence, la raison en est que vous n'avez pas d'accès direct aux structures.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'appel de</a> méthodes comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sys.getrefcount ()</a> peut aider à obtenir une sorte de substance interne. <br><br>  Si nous parlons de mémoire, cela peut ressembler à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d9/ad7/932/9d9ad79327405315461e3880fe3db256.png"><br><br>  Ici, le circuit de mémoire est très différent du circuit en C montré ci-dessus.  Au lieu d'avoir <code>x</code> posséder un bloc de mémoire qui stocke la valeur <code>2337</code> , un objet Python fraîchement créé possède la mémoire dans laquelle <code>2337</code> vit.  Le nom Python <code>x</code> ne possède directement <b>aucune</b> adresse en mémoire, tout comme une variable C possède une cellule statique. <br><br>  Si vous souhaitez attribuer à <code>x</code> nouvelle valeur, essayez ce code: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Le comportement du système sera différent de ce qui se passe en C, mais il ne différera pas trop de la liaison d'origine en Python. <br><br>  Dans ce code: <br><br><ul><li>  Un nouveau PyObject est créé. <br></li><li>  Le numéro de PyObject se voit attribuer un code de type. <br></li><li>  <code>2</code> reçoit une valeur pour PyObject. <br></li><li>  <code>x</code> pointe vers le nouveau PyObject. <br></li><li>  Le compte de référence du nouveau PyObject est incrémenté de 1. <br></li><li>  Le compte de référence de l'ancien PyObject est réduit de 1. <br></li></ul><br>  Maintenant, le circuit mémoire ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/712/860/996/712860996aa37da34fdb69a466cdf5de.png"><br><br>  Cette illustration montre que <code>x</code> pointe vers une référence à un objet et ne possède pas la zone mémoire comme auparavant.  Vous voyez également que la commande <code>x = 2338</code> n'est pas une affectation, mais plutôt une liaison du nom <code>x</code> au lien. <br><br>  De plus, l'objet précédent (contenant la valeur <code>2337</code> ) est maintenant en mémoire avec un décompte de référence de 0 et sera supprimé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par le garbage collector</a> . <br><br>  Vous pouvez saisir un nouveau nom <code>y</code> , comme dans l'exemple C: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = x</code> </pre> <br>  Un nouveau nom apparaîtra en mémoire, mais pas nécessairement un nouvel objet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/adc/410/958adc41013bb5483f0526689a48a871.png"><br><br>  Vous voyez maintenant qu'un nouvel objet Python n'a <b>pas été</b> créé, seul un nouveau nom a <b>été</b> créé qui pointe vers le même objet.  De plus, le compteur de références d'objets a augmenté de 1. Vous pouvez vérifier l'équivalence de l'identité des objets pour confirmer leur identité: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Ce code montre que <code>x</code> et <code>y</code> sont un seul objet.  Mais ne vous y trompez pas: <code>y</code> est toujours immuable.  Par exemple, vous pouvez effectuer une opération d'addition avec <code>y</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Une fois l'ajout appelé, vous retournerez un nouvel objet Python.  Maintenant, la mémoire ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/abc/3e7/8bdabc3e7576ab86b00ba9c2b43b57b4.png"><br><br>  Un nouvel objet a été créé et <code>y</code> pointe maintenant vers lui.  Il est curieux que nous obtenions exactement le même état final si nous relions directement <code>y</code> à <code>2339</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = <span class="hljs-number"><span class="hljs-number">2339</span></span></code> </pre> <br>  Après cette expression, nous obtenons un tel état final de la mémoire, comme dans l'opération d'addition.  Permettez-moi de vous rappeler qu'en Python, vous n'affectez pas de variables, mais liez des noms à des liens. <br><br><h3>  À propos des stagiaires en Python </h3><br>  Vous comprenez maintenant comment de nouveaux objets sont créés en Python et comment les noms y sont attachés.  Il est temps de parler des objets internés. <br><br>  Nous avons ce code Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Comme précédemment, <code>x</code> et <code>y</code> sont des noms pointant vers le même objet Python.  Mais cet objet contenant la valeur <code>1000</code> ne peut pas toujours avoir la même adresse mémoire.  Par exemple, si vous additionnez deux nombres et obtenez 1000, vous obtiendrez une autre adresse: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">499</span></span> + <span class="hljs-number"><span class="hljs-number">501</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Cette fois, la chaîne <code>x is y</code> renvoie <code>False</code> .  Si vous êtes gêné, ne vous inquiétez pas.  Voici ce qui se passe lorsque ce code est exécuté: <br><br><ol><li>  Un objet Python est créé ( <code>1000</code> ). <br></li><li>  On lui donne le nom <code>x</code> . <br></li><li>  Un objet Python est créé ( <code>499</code> ). <br></li><li>  Un objet Python est créé ( <code>501</code> ). <br></li><li>  Ces deux objets s'additionnent. <br></li><li>  Un nouvel objet Python est créé ( <code>1000</code> ). <br></li><li>  On lui donne le nom <code>y</code> . <br></li></ol><br>  <b>Explications techniques</b> : Les étapes décrites n'ont lieu que lorsque ce code est exécuté dans le REPL.  Si vous prenez l'exemple ci-dessus, collez-le dans le fichier et exécutez-le, puis la ligne <code>x is y</code> retournera <code>True</code> . <br><br>  La raison en est l'esprit rapide du compilateur CPython, qui essaie d'effectuer des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optimisations de judas</a> qui aident à enregistrer autant que possible les étapes d'exécution du code.  Les détails peuvent être trouvés dans le <a href="">code source de l'optimiseur de judas CPython</a> . <br><br>  Mais n'est-ce pas du gaspillage?  Eh bien, oui, mais vous payez ce prix pour tous les grands avantages de Python.  Vous n'avez pas besoin de penser à supprimer de tels objets intermédiaires, et vous n'avez même pas besoin de connaître leur existence!  La plaisanterie est que ces opérations sont effectuées assez rapidement et que vous ne les connaissez pas avant ce moment. <br><br>  Les créateurs de Python ont sagement remarqué cette surcharge et ont décidé de faire plusieurs optimisations.  Leur résultat est un comportement qui peut surprendre les débutants: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">20</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">19</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Dans cet exemple, le code est presque le même que ci-dessus, sauf que nous obtenons <code>True</code> .  Tout tourne autour des objets internés.  Python pré-crée un sous-ensemble spécifique d'objets en mémoire et les stocke dans l'espace de noms global pour une utilisation quotidienne. <br><br>  Quels objets dépendent de l'implémentation Python?  Dans CPython 3.7, les internés sont: <br><br><ol><li>  Entiers allant de <code>-5</code> à <code>256</code> . <br></li><li>  Chaînes contenant uniquement des lettres, des chiffres ou des traits de soulignement ASCII. <br></li></ol><br>  En effet, ces variables sont très souvent utilisées dans de nombreux programmes.  En internant, Python empêche l'allocation de mémoire pour les objets persistants. <br><br>  Les lignes de moins de 20 caractères et contenant des lettres ASCII, des chiffres ou des traits de soulignement seront internées car elles sont censées être utilisées comme identifiants: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s1) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s2) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Ici, <code>s1</code> et <code>s2</code> pointent vers la même adresse en mémoire.  Si nous n'insérions pas de lettre, de chiffre ou de soulignement ASCII, nous obtiendrions un résultat différent: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Cet exemple utilise un point d'exclamation, donc les chaînes ne sont pas internes et sont différents objets en mémoire. <br><br>  <b>Bonus</b> : si vous voulez que ces objets se réfèrent au même objet interné, vous pouvez utiliser <code>sys.intern()</code> .  Une façon d'utiliser cette fonctionnalité est décrite dans la documentation: <br><br><blockquote>  L'internement de chaînes est utile pour une légère augmentation des performances de recherche de dictionnaire: si les clés du dictionnaire et la clé à rechercher sont internées, des comparaisons de clés (après hachage) peuvent être effectuées en comparant des pointeurs plutôt que des chaînes.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> ) </blockquote><br>  Les internés confondent souvent les programmeurs.  N'oubliez pas que si vous commencez à douter, vous pouvez toujours utiliser <code>id()</code> et <code>is</code> pour déterminer l'équivalence des objets. <br><br><h2>  Émulation de pointeur Python </h2><br>  Le fait que les pointeurs soient absents nativement en Python ne signifie pas que vous ne pouvez pas profiter des pointeurs.  Il existe en fait plusieurs façons d'émuler des pointeurs en Python.  Ici, nous regardons deux d'entre eux: <br><br><ol><li>  Utilisez-les comme pointeurs vers des types mutables. <br></li><li>  Utilisation d'objets Python spécialement préparés. <br></li></ol><br><h3>  Utiliser comme pointeurs de type mutable </h3><br>  Vous savez déjà ce que sont les types mutables.  C'est grâce à leur mutabilité que nous pouvons émuler le comportement des pointeurs.  Disons que vous devez répliquer ce code: <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Ce code prend un pointeur sur un nombre ( <code>*x</code> ) et incrémente la valeur de 1. Voici la fonction principale pour exécuter le code: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdi.h&gt; int main(void) { int y = 2337; printf("y = %d\n", y); add_one(&amp;y); printf("y = %d\n", y); return 0; }</span></span></code> </pre> <br>  Dans le fragment ci-dessus, nous avons attribué <code>y</code> à <code>2337</code> , affiché la valeur actuelle, augmenté de 1, puis affiché une nouvelle valeur.  L'écran suivant apparaît à l'écran: <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2337</span></span> y = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Une façon de reproduire ce comportement en Python consiste à utiliser un type mutable.  Par exemple, appliquez une liste et modifiez le premier élément: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> ... x[<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; y = [<span class="hljs-number"><span class="hljs-number">2337</span></span>] &gt;&gt;&gt; add_one(y) &gt;&gt;&gt; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Ici, <code>add_one(x)</code> fait référence au premier élément et augmente sa valeur de 1. L'utilisation de la liste signifie qu'en conséquence, nous obtenons la valeur modifiée.  Il y a donc des pointeurs en Python?  Non.  Le comportement décrit est devenu possible car la liste est un type mutable.  Si vous essayez d'utiliser un tuple, vous obtenez une erreur: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>z = (<span class="hljs-number"><span class="hljs-number">2337</span></span>,) &gt;&gt;&gt; add_one(z)</code> </pre> <br>  Trace arrière (les derniers appels passent en dernier): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> add_one TypeError: <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Ce code démontre l'immuabilité du tuple, il ne prend donc pas en charge l'attribution d'élément. <br><br>  <code>list</code> pas le seul type mutable; les pointeurs partiels sont également émulés à l'aide de <code>dict</code> . <br><br>  Supposons que vous ayez une application qui devrait suivre l'occurrence d'événements intéressants.  Cela peut être fait en créant un dictionnaire et en utilisant l'un de ses éléments comme compteur: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>counters = {<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>} &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... bar() ... &gt;&gt;&gt; foo() &gt;&gt;&gt; counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Dans cet exemple, le dictionnaire utilise des compteurs pour suivre le nombre d'appels de fonction.  Après avoir appelé <code>foo()</code> compteur a augmenté de 2, comme prévu.  Et tout cela grâce à la <code>dict</code> . <br><br>  N'oubliez pas, ce n'est qu'une <b>émulation</b> du comportement d'un pointeur, cela n'a rien à voir avec de vrais pointeurs en C et C ++.  On peut dire que ces opérations sont plus chères que si elles étaient effectuées en C ou C ++. <br><br><h3>  Utilisation d'objets Python </h3><br>  <code>dict</code> est un excellent moyen d'émuler des pointeurs en Python, mais il est parfois fastidieux de se souvenir du nom de clé que vous avez utilisé.  Surtout si vous utilisez le dictionnaire dans différentes parties de l'application.  Une classe Python personnalisée peut vous aider ici. <br><br>  Imaginons que vous ayez besoin de suivre les mesures dans une application.  Un excellent moyen d'ignorer les détails ennuyeux est de créer une classe: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }</code> </pre> <br>  Ce code définit la classe <code>Metrics</code> .  Il utilise toujours le dictionnaire pour stocker des données à jour qui se trouvent dans la <code>_metrics</code> membre <code>_metrics</code> .  Cela vous donnera la mutabilité requise.  Il ne vous reste plus qu'à accéder à ces valeurs.  Vous pouvez le faire en utilisant les propriétés: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... @property def func_calls(self): return self._metrics["func_calls"] @property def cat_pictures_served(self): return self._metrics["cat_pictures_served"]</span></span></code> </pre> <br>  Ici, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@property</a> .  Si vous débutez avec les décorateurs, lisez l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Primer on Python Decorators</a> .  Dans ce cas, le décorateur <code>@property</code> vous permet d'accéder à <code>func_calls</code> et <code>cat_pictures_served</code> , comme s'il s'agissait d'attributs: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; metrics.cat_pictures_served <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Le fait que vous puissiez faire référence à ces noms en tant qu'attributs signifie que vous êtes éloigné du fait que ces valeurs sont stockées dans le dictionnaire.  De plus, vous rendez les noms d'attributs plus explicites.  Bien sûr, vous devriez pouvoir augmenter les valeurs: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def inc_func_calls(self): self._metrics["func_calls"] += 1 def inc_cat_pics(self): self._metrics["cat_pictures_served"] += 1</span></span></code> </pre> <br>     : <br><br><ol><li> <code>inc_func_calls()</code> </li> <li> <code>inc_cat_pics()</code> </li> </ol><br>      <code>metrics</code> .     ,     ,   : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>     <code>func_calls</code>   <code>inc_func_calls()</code>         Python.    ,     -  <code>metrics</code> ,          . <br><br> <b></b> :   ,   <code>inc_func_calls()</code>  <code>inc_cat_pics()</code>   <code>@property.setter</code>        <code>int</code> ,     . <br><br>      <code>Metrics</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, } @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat_pictures_served</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_cat_pics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2>     ctypes </h2><br>  , -    Python,   CPython?     ctypes    ,   C.      ctypes,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extending Python With C Libraries and the «ctypes» Module</a> . <br><br>       ,     ,   .     - <code>add_one()</code> : <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> ,      <code>x</code>  1.   ,      (shared) .  ,      <code>add.c</code> ,      gcc: <br><br><pre> <code class="python hljs">$ gcc -c -Wall -Werror -fpic add.c $ gcc -shared -o libadd1.so add.o</code> </pre> <br>      C   <code>add.o</code> .           <code>libadd1.so</code> . <br><br> <code>libadd1.so</code>      .    ctypes    Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; add_lib = ctypes.CDLL(<span class="hljs-string"><span class="hljs-string">"./libadd1.so"</span></span>) &gt;&gt;&gt; add_lib.add_one &lt;_FuncPtr object at <span class="hljs-number"><span class="hljs-number">0x7f9f3b8852a0</span></span>&gt;</code> </pre> <br>  ctypes.CDLL  ,     <code>libadd1</code> .      <code>add_one()</code> ,      ,        Python-.     ,    .  Python  ,      . <br><br>         , ctypes       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one = add_lib.add_one &gt;&gt;&gt; add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]</code> </pre> <br>     ,    C. ,        ,       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(<span class="hljs-number"><span class="hljs-number">1</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ctypes.ArgumentError: argument <span class="hljs-number"><span class="hljs-number">1</span></span>: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeError</span></span></span><span class="hljs-class">'&gt;:</span></span> \ expected LP_c_int instance instead of int</code> </pre> <br> Python    ,  <code>add_one()</code>   ,     .  ,  ctypes      .       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = ctypes.c_int() &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>      <code>x</code>   <code>0</code> . ctypes    <code>byref()</code> ,      . <br><br> <b></b> :  <b> </b>     <b> </b> . <br><br>          ,       .         ,        . <br><br>   <code>add_one()</code>    : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(ctypes.byref(x)) <span class="hljs-number"><span class="hljs-number">998793640</span></span> &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Super!     1. ,     Python  . <br><br><h2>  Conclusion </h2><br>        Python  .          ,              Python. <br><br>         Python: <br><br><ul><li>          . <br></li><li>   Python-   . <br></li><li>       ctypes. <br></li></ul><br>       Python       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454324/">https://habr.com/ru/post/fr454324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454314/index.html">10 principes de programmation orientée objet que chaque développeur doit connaître</a></li>
<li><a href="../fr454316/index.html">Sur les traces du ninja industriel: nous vous invitons à participer au concours en ligne de sécurité industrielle</a></li>
<li><a href="../fr454318/index.html">Sondant le passé. Un guide pour les historiens sur la conversion des données en sons</a></li>
<li><a href="../fr454320/index.html">Analystes du marché du travail et scientifiques des données</a></li>
<li><a href="../fr454322/index.html">Certains disent que la technologie DANE pour les navigateurs a échoué</a></li>
<li><a href="../fr454326/index.html">En plus de Moore - qui d'autre a formulé les lois de la mise à l'échelle des systèmes informatiques</a></li>
<li><a href="../fr454330/index.html">10 points forts de TechTrain 2018: l'IA pour les masses, les interfaces, etc.</a></li>
<li><a href="../fr454332/index.html">Comment le bot Telegram a surmonté la procrastination des concepteurs et contribué à augmenter les revenus des agences numériques</a></li>
<li><a href="../fr454334/index.html">Moto. Weep AWS</a></li>
<li><a href="../fr454336/index.html">Client: - Combien coûte une copie de Facebook?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>