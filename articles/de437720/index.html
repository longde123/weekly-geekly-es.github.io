<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèª üò© üö∂üèæ Der Kampf um Qualit√§tsl√∂sungen bei Erlang / Elixir üöö üò∏ üíÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="@jcutrer 


 Heute werden wir √ºber Ereignisprotokolle, quantitative Metriken und die √úberwachung all dessen sprechen, um die Reaktionsrate des Teams a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der Kampf um Qualit√§tsl√∂sungen bei Erlang / Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437720/"><p><img src="https://habrastorage.org/webt/s8/mq/lh/s8mqlhd99fmiu32vwgxnk4x-8yu.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@jcutrer</a> </p><br><p>  Heute werden wir √ºber Ereignisprotokolle, quantitative Metriken und die √úberwachung all dessen sprechen, um die Reaktionsrate des Teams auf Vorf√§lle zu erh√∂hen und die Ausfallzeiten des Zielsystems zu verringern. </p><br><p> Erlang / OTP als Rahmen und Ideologie f√ºr den Aufbau verteilter Systeme bietet regulierte Ans√§tze f√ºr die Entwicklung, Tools und Implementierung von Standardkomponenten.  Nehmen wir an, wir haben das Potenzial von OTP genutzt und sind vom Prototyp bis zur Produktion gegangen.  Unser Erlang-Projekt f√ºhlt sich auf Kampfservern gro√üartig an, die Codebasis entwickelt sich st√§ndig weiter, neue Anforderungen und Funktionen erscheinen, neue Leute kommen ins Team und alles scheint in Ordnung zu sein.  Aber manchmal geht etwas schief und technische Probleme, multipliziert mit dem menschlichen Faktor, k√∂nnen zu einem Unfall f√ºhren. </p><br><p>  Da es unm√∂glich ist, f√ºr absolut alle m√∂glichen F√§lle von Fehlern und Problemen Strohhalme zu legen, oder dies wirtschaftlich nicht machbar ist, ist es erforderlich, die Ausfallzeit des Systems bei Fehlern durch Management- und Softwarel√∂sungen zu reduzieren. </p><a name="habracut"></a><br><p>  In Informationssystemen besteht immer die Wahrscheinlichkeit, dass Fehler verschiedener Art auftreten: </p><br><ul><li>  Hardwarefehler und Stromausf√§lle </li><li>  Netzwerkfehler: Konfigurationsfehler, Firmware-Kurven </li><li>  Logische Fehler: von Algorithmuscodierungsfehlern bis zu Architekturproblemen, die an den Grenzen von Subsystemen und Systemen auftreten. </li><li>  Sicherheitsprobleme und damit verbundene Angriffe und Hacks, einschlie√ülich interner Betrugsf√§lle. </li></ul><br><p>  Wir unterscheiden sofort die Verantwortung: Die √úberwachung der Infrastruktur, die beispielsweise von zabbix organisiert wird, wird f√ºr den Betrieb von Computerger√§ten und Daten√ºbertragungsnetzen verantwortlich sein.  Es wurde viel √ºber die Installation und Konfiguration einer solchen √úberwachung geschrieben, wir werden sie nicht wiederholen. </p><br><p>  Aus Sicht des Entwicklers liegt das Problem der Zug√§nglichkeit und Qualit√§t in der Ebene der Fr√ºherkennung von Fehlern und Leistungsproblemen und der schnellen Reaktion darauf.  Dies erfordert Ans√§tze und Mittel zur Bewertung.  Versuchen wir also, quantitative Metriken abzuleiten und zu analysieren, welche Qualit√§t wir in verschiedenen Phasen der Entwicklung und des Betriebs des Projekts erheblich verbessern k√∂nnen. </p><br><h3 id="sistemy-sborki">  Montagesysteme </h3><br><p>  Ich m√∂chte Sie noch einmal an die Bedeutung des Engineering-Ansatzes und der Tests in der Softwareentwicklung erinnern.  Erlang / OTP bietet zwei Test-Frameworks gleichzeitig: Eunit und Common Test. </p><br><p>  Als Metriken f√ºr eine erste Beurteilung des Status der Codebasis und ihrer Dynamik k√∂nnen Sie die Anzahl erfolgreicher und problematischer Tests, ihre Ausf√ºhrungszeit und den Prozentsatz der Codeabdeckung mit Tests verwenden.  Beide Frameworks erm√∂glichen das Speichern von Testergebnissen im Junit-Format. <br>  F√ºgen Sie beispielsweise f√ºr rebar3 und ct die folgenden Zeilen zu rebar.config hinzu: </p><br><pre><code class="erlang hljs">{cover_enabled, true}. {cover_export_enabled, true}. {ct_opts,[ {ct_hooks, [{cth_surefire, [{path, <span class="hljs-string"><span class="hljs-string">"report.xml"</span></span>}]}]} ]}.</code> </pre> <br><p>  Mit der Anzahl der erfolgreichen und erfolglosen Tests k√∂nnen Sie ein Trenddiagramm erstellen: <br><img src="https://habrastorage.org/webt/mw/lc/mw/mwlcmw24mj6f9wz5ctxshc4baf4.png"><br>  Wenn Sie sich das ansehen, k√∂nnen Sie die Dynamik des Teams und die Regression der Tests bewerten.  In Jenkins kann dieses Diagramm beispielsweise mit dem Test Results Analyzer Plugin abgerufen werden. </p><br><p>  Wenn die Tests rot werden oder l√§ngere Zeit ausgef√ºhrt werden, kann die Freigabe anhand der Metriken bereits in der Phase der Montage und des automatischen Tests abgeschlossen werden. </p><br><h3 id="metriki-prilozheniy">  Anwendungsmetriken </h3><br><p>  Zus√§tzlich zu den Betriebssystemmetriken sollte die √úberwachung Anwendungsmetriken umfassen, z. B. die Anzahl der Ansichten pro Sekunde, die Anzahl der Zahlungen und andere kritische Indikatoren. </p><br><p>  In meinen Projekten verwende ich eine Vorlage wie <code>${application}.${metrics_type}.${name}</code> , um die Metriken zu benennen.  Mit dieser Benennung k√∂nnen Sie Listen mit Metriken des Formulars abrufen </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3</code> </pre> <br><p>  Je mehr Metriken vorhanden sind, desto einfacher ist es m√∂glicherweise zu verstehen, was in einem komplexen System geschieht. </p><br><h3 id="metriki-erlang-vm">  Erlang VM-Metriken </h3><br><p>  Besondere Aufmerksamkeit sollte der √úberwachung der Erlang VM gewidmet werden.  Die Ideologie, es abst√ºrzen zu lassen, ist wundersch√∂n, und die ordnungsgem√§√üe Verwendung von OTP wird sicherlich dazu beitragen, die heruntergefallenen Teile der Anwendung in Erlang VM zu entfernen.  Vergessen Sie jedoch nicht Erlang VM selbst, da es schwierig ist, es zu l√∂schen, aber es ist m√∂glich.  Alle Optionen basieren auf der Ersch√∂pfung von Ressourcen.  Wir listen die wichtigsten auf: </p><br><ul><li><p>  Atomtabellen√ºberlauf. <br>  Atome sind Bezeichner, deren Hauptzweck darin besteht, die Lesbarkeit des Codes zu verbessern.  Einmal erstellte Atome bleiben f√ºr immer im Speicher der Erlang VM-Instanz, da sie vom Garbage Collector nicht gel√∂scht werden.  Warum passiert das?  Der Garbage Collector arbeitet in jedem Prozess separat mit Daten aus diesem Prozess, w√§hrend Atome √ºber die Datenstrukturen vieler Prozesse verteilt werden k√∂nnen. <br>  Standardm√§√üig k√∂nnen 1.048.576 Atome erstellt werden.  In Artikeln √ºber das T√∂ten von Erlang VM finden Sie normalerweise so etwas. </p><br><pre> <code class="erlang hljs">[list_to_atom(integer_to_list(I)) || I &lt;- lists:seq(erlang:system_info(atom_count), erlang:system_info(atom_limit))]</code> </pre> <br><p>  zur Veranschaulichung dieses Effekts.  Es scheint, dass ein k√ºnstliches Problem in realen Systemen nicht erreichbar ist, aber es gibt F√§lle ... Zum Beispiel wird im externen API-Handler beim Parsen von Anforderungen <code>binary_to_atom/2</code> anstelle von <code>binary_to_existing_atom/2</code> oder <code>list_to_atom/1</code> anstelle von <code>list_to_existing_atom/1</code> . <br>  Die folgenden Parameter sollten verwendet werden, um den Zustand der Atome zu √ºberwachen: </p><br><ol><li>  <code>erlang:memory(atom_used)</code> - Speichermenge, die f√ºr Atome verwendet wird </li><li>  <code>erlang:system_info(atom_count)</code> - die Anzahl der im System erstellten Atome.  Zusammen mit <code>erlang:system_info(atom_limit)</code> kann die <code>erlang:system_info(atom_limit)</code> berechnet werden. </li></ol><br></li><li><p>  Prozesslecks. <br>  Ich m√∂chte sofort sagen, dass, wenn process_limit (+ P erreicht ist, das Argument erl) erlang vm nicht f√§llt, aber es in einen Notfallzustand √ºbergeht, zum Beispiel wird es h√∂chstwahrscheinlich unm√∂glich sein, eine Verbindung dazu herzustellen.  Wenn bei der Zuweisung zu durchgesickerten Prozessen nicht gen√ºgend Speicher zur Verf√ºgung steht, st√ºrzt erlang vm ab. </p><br><ol><li>  <code>erlang:system_info(process_count)</code> - die Anzahl der momentan aktiven Prozesse.  Zusammen mit <code>erlang:system_info(process_limit)</code> kann die Prozessauslastung berechnet werden. </li><li>  <code>erlang:memory(processes)</code> - zugewiesener Speicher f√ºr Prozesse </li><li>  <code>erlang:memory(processes_used)</code> - verwendeter Speicher f√ºr Prozesse. </li></ol><br></li><li><p>  Mailbox-Prozess√ºberlauf. <br>  Ein typisches Beispiel f√ºr ein solches Problem ist, dass der Absenderprozess Nachrichten an den Empf√§ngerprozess sendet, ohne auf eine Best√§tigung zu warten, w√§hrend der <code>receive</code> im Empf√§ngerprozess alle diese Nachrichten aufgrund eines fehlenden oder falschen Musters ignoriert.  Infolgedessen werden Nachrichten in der Mailbox gesammelt.  Obwohl erlang √ºber einen Mechanismus zum Verlangsamen des Absenders verf√ºgt, falls der Handler die Verarbeitung nicht ausf√ºhren kann, st√ºrzt vm nach Ersch√∂pfung des verf√ºgbaren Speichers ab. <br>  Um zu verstehen, ob es Probleme mit dem Postfach√ºberlauf gibt, hilft etop. </p><br><pre> <code class="bash hljs">$ erl -name etop@host -hidden -s etop -s erlang halt -output text -node dest@host -setcookie some_cookie -tracing off -sort msg_q -interval 1 -lines 25</code> </pre> <br><p><img src="https://habrastorage.org/webt/k3/rc/xu/k3rcxuudnptazhjl0pxql1vmfji.png"><br>  Als Metrik f√ºr die kontinuierliche √úberwachung k√∂nnen Sie die Anzahl der Problemprozesse verwenden.  Um sie zu identifizieren, k√∂nnen Sie die folgende Funktion verwenden: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top_msq_q</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">-&gt;</span></span> [{P, RN, L, IC, ST} || P &lt;- processes(), { _, L } &lt;- [ process_info(P, message_queue_len) ], L &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>, [{_, RN}, {_, IC}, {_, ST}] &lt;- [process_info(P, [registered_name, initial_call, current_stacktrace]) ] ].</code> </pre> <br><p>  Diese Liste kann auch protokolliert werden. Wenn Sie eine Benachrichtigung von der √úberwachung erhalten, wird die Analyse des Problems vereinfacht. </p><br></li><li><p>  Undichte Bin√§rdateien. <br>  Der Speicher f√ºr gro√üe Bin√§rdateien (mehr als 64 Byte) wird im allgemeinen Heap zugewiesen.  Der zugewiesene Block verf√ºgt √ºber einen Referenzz√§hler, der die Anzahl der Prozesse angibt, die Zugriff darauf haben.  Nach dem Zur√ºcksetzen des Z√§hlers erfolgt die Reinigung.  Das einfachste System, aber wie sie sagen, gibt es Nuancen.  Im Prinzip besteht die M√∂glichkeit, dass ein Prozess so viel M√ºll auf dem Heap generiert, dass das System nicht √ºber gen√ºgend Speicher verf√ºgt, um die Bereinigung durchzuf√ºhren. <br>  <code>erlang:memory(binary)</code> dient als Metrik f√ºr die √úberwachung und zeigt den f√ºr Bin√§rdateien zugewiesenen Speicher an. </p><br></li></ul><br><p>  Die F√§lle, die zum Fall von VM f√ºhren, sind also aussortiert. Au√üerdem ist es hilfreich, nicht weniger wichtige Parameter zu √ºberwachen, die sich direkt oder indirekt auf die korrekte Funktion Ihrer Anwendungen auswirken: </p><br><ul><li>  Der von den ETS: <code>erlang:memory(ets)</code> . </li><li>  Speicher f√ºr kompilierte Module: <code>erlang:memory(code)</code> . <br>  Wenn Ihre L√∂sungen keine dynamische Codekompilierung verwenden, kann diese Option ausgeschlossen werden. <br>  Ich m√∂chte auch erlydtl erw√§hnen.  Wenn Sie Vorlagen dynamisch kompilieren, wird beim Kompilieren ein Strahl erstellt, der in den VM-Speicher geladen wird.  Es kann auch Speicherlecks verursachen. </li><li>  Systemspeicher: <code>erlang:memory(system)</code> .  Zeigt den Speicherbedarf zur Erlang-Laufzeit an. </li><li>  Insgesamt verbrauchter Speicher: <code>erlang:memory(total)</code> .  Dies ist die Speichermenge, die von Prozessen und zur Laufzeit verbraucht wird. </li><li>  Informationen zu Erm√§√üigungen: <code>erlang:statistics(reductions)</code> . </li><li>  Anzahl der Prozesse und Ports, die zur Ausf√ºhrung bereit sind: <code>erlang:statistics(run_queue)</code> . </li><li>  Mit der Verf√ºgbarkeit der Instanz vm: <code>erlang:statistics(runtime)</code> k√∂nnen Sie nachvollziehen, ob ein Neustart ohne Protokollanalyse durchgef√ºhrt wurde. </li><li>  Netzwerkaktivit√§t: <code>erlang:statistics(io)</code> . </li></ul><br><h3 id="otpravka-metrik-v-zabbix">  √úbermitteln von Metriken an zabbix </h3><br><p>  Wir erstellen eine Datei mit Anwendungsmetriken und erlang vm-Metriken, die wir alle N Sekunden aktualisieren.  F√ºr jeden erlang-Knoten muss die Metrikdatei die Metriken der darauf ausgef√ºhrten Anwendungen und die Metriken der erlang vm-Instanz enthalten.  Das Ergebnis sollte ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3 ‚Ä¶. erlang.io.input = 2205723664 erlang.io.output = 1665529234 erlang.memory.binary = 1911136 erlang.memory.ets = 1642416 erlang.memory.processes = 23596432 erlang.memory.processes_used = 23598864 erlang.memory.system = 50883752 erlang.memory.total = 74446048 erlang.processes.count = 402 erlang.processes.run_queue = 0 erlang.reductions = 148412771 ....</code> </pre> <br><p>  Mit <code>zabbix_sender</code> senden wir diese Datei an zabbix, wo bereits eine grafische Darstellung und die M√∂glichkeit zum Erstellen von Automatisierungs- und Benachrichtigungsausl√∂sern verf√ºgbar sind. </p><br><p>  Jetzt, da wir Metriken im √úberwachungssystem haben und Automatisierungsausl√∂ser und Benachrichtigungsereignisse auf ihrer Grundlage erstellt haben, haben wir die M√∂glichkeit, Unf√§lle zu vermeiden, indem wir im Voraus auf alle gef√§hrlichen Abweichungen von einem voll funktionsf√§higen Zustand reagieren. </p><br><h3 id="centralnyy-sbor-logov">  Zentrales Sammeln von Protokollen </h3><br><p>  Wenn ein Projekt 1-2 Server enth√§lt, k√∂nnen Sie wahrscheinlich immer noch ohne eine zentrale Protokollsammlung leben. Sobald jedoch ein verteiltes System mit vielen Servern, Clustern und Umgebungen angezeigt wird, muss das Problem der Erfassung und bequemen Anzeige von Protokollen gel√∂st werden. </p><br><p>  Um Protokolle in meine Projekte zu schreiben, verwende ich Lager.  Auf dem Weg vom Prototyp zur Produktion durchlaufen Projekte h√§ufig die folgenden Phasen des Sammelns von Protokollen: </p><br><ul><li>  Einfachste Protokollierung mit Ausgabe in eine lokale Datei oder sogar in stdout (lager_file_backend) </li><li>  Zentralisierte Erfassung von Protokollen mithilfe von beispielsweise syslogd und automatischem Senden von Protokollen an den Collector.  F√ºr ein solches Schema ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lager_syslog</a> geeignet. <br>  Der Hauptnachteil des Schemas besteht darin, dass Sie zum Protokollsammlungsserver gehen, die Datei mit den erforderlichen Protokollen suchen und die Ereignisse auf der Suche nach denjenigen filtern m√ºssen, die f√ºr das Debuggen erforderlich sind. </li><li>  Zentralisierte Erfassung von Protokollen mit Speicher im Repository mit der M√∂glichkeit, nach Datens√§tzen zu filtern und zu suchen. </li></ul><br><p>  √úber die Minuspunkte, Pluspunkte und quantitativen Metriken, die mit letzteren angewendet werden k√∂nnen, und wir werden im Prisma einer bestimmten Implementierung <code>lager_clickhouse</code> - <code>lager_clickhouse</code> , die ich in den meisten entwickelten Projekten verwende.  Ein paar Worte zu <code>lager_clickhouse</code> .  Dies ist das gr√∂√üere Backend zum Speichern von Ereignissen in Clickhouse.  Im Moment ist dies ein internes Projekt, aber es gibt Pl√§ne, es zu √∂ffnen.  Bei der Entwicklung von lager_clickhouse musste ich einige Funktionen von clickhouse umgehen, z. B. die Ereignispufferung verwenden, um h√§ufige Anfragen in clickhouse zu vermeiden.  Der Aufwand hat sich bei stabilem Betrieb und guter Leistung gelohnt. </p><br><p>  Der Hauptnachteil des Ansatzes zum Speichern im Repository ist das zus√§tzliche Wesentliche - Clickhouse und die Notwendigkeit, Code zum Speichern von Ereignissen darin und die Benutzeroberfl√§che zum Analysieren und Suchen nach Ereignissen zu entwickeln.  Bei einigen Projekten kann es auch wichtig sein, TCP zum Senden von Protokollen zu verwenden. </p><br><p>  Aber die Profis √ºberwiegen meines Erachtens alle m√∂glichen Nachteile. </p><br><ul><li><p>  Einfache und schnelle Ereignissuche: </p><br><ul><li>  Filtern nach Datum, ohne auf einem zentralen Server mit einer Reihe von Ereignissen nach einer oder mehreren Dateien suchen zu m√ºssen. </li><li>  Filtern nach Umgebung.  Protokolle von verschiedenen Subsystemen und h√§ufig von verschiedenen Clustern werden in ein Repository geschrieben.  Im Moment erfolgt die Trennung nach Beschriftungen, die auf jedem Knoten des Clusters festgelegt sind. </li><li>  Nach Hostnamen filtern </li><li>  Filtern nach dem Namen des Moduls, das das Ereignis gesendet hat </li><li>  Ereignisfilterung </li><li>  Textsuche </li></ul><br><p>  Eine Beispielansicht der Protokollanzeigeoberfl√§che ist im Screenshot dargestellt: <br><img src="https://habrastorage.org/webt/tz/6s/qy/tz6sqy5ofprtonxlxkhywfr7gmy.png"></p><br></li><li><p>  Automatisierungsf√§higkeit. <br>  Mit der Einf√ºhrung des Protokollspeichers wurde es m√∂glich, in Echtzeit Informationen √ºber die Anzahl der Fehler, das Auftreten kritischer Fehler und die Systemaktivit√§t zu erhalten.  Durch die Einf√ºhrung bestimmter Grenzwerte k√∂nnen wir Notfallereignisse generieren, wenn das System den Funktionsstatus verl√§sst. Die Handler f√ºhren Automatisierungsaktionen aus, um diesen Status zu beseitigen, und senden Benachrichtigungen an die f√ºr die Funktionalit√§t verantwortlichen Teammitglieder: </p><br><ul><li>  Wenn ein kritischer Fehler auftritt. </li><li>  Bei Massenfehlern (die Zeitableitung steigt schneller als ein bestimmter Grenzwert an). </li><li>  Eine separate Metrik ist die Rate der Ereignisgenerierung, d. H. Wie viele neue Ereignisse im Ereignisprotokoll angezeigt werden.  Sie k√∂nnen fast immer die ungef√§hre Anzahl der von einem Projekt pro Zeiteinheit generierten Protokolle kennen.  Wenn es mehrmals √ºberschritten wird, l√§uft h√∂chstwahrscheinlich etwas schief. </li></ul><br></li></ul><br><p>  Die Weiterentwicklung des Themas Automatisierung der Behandlung von Notfallereignissen war die Verwendung von Lua-Skripten.  Jeder Entwickler oder Administrator kann ein Skript zum Verarbeiten von Protokollen und Metriken schreiben.  Skripte bieten Flexibilit√§t und erm√∂glichen es Ihnen, personalisierte Automatisierungsskripte und Benachrichtigungen zu erstellen. </p><br><h3 id="itogi">  Zusammenfassung </h3><br><p>  Um die im System ablaufenden Prozesse zu verstehen und Vorf√§lle zu untersuchen, sind quantitative Indikatoren und Ereignisprotokolle sowie praktische Tools zu deren Analyse unerl√§sslich.  Je mehr Informationen wir √ºber das System sammeln, desto einfacher ist es, sein Verhalten zu analysieren und Probleme bereits im Stadium ihres Auftretens zu beheben.  F√ºr den Fall, dass unsere Ma√ünahmen nicht funktionierten, haben wir immer Zeitpl√§ne und detaillierte Protokolle des Vorfalls. </p><br><p>  Und wie arbeiten Sie mit L√∂sungen auf Erlang / Elixir und auf welche interessanten F√§lle sind Sie in der Produktion gesto√üen? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437720/">https://habr.com/ru/post/de437720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437706/index.html">Jahr mit Tesla</a></li>
<li><a href="../de437710/index.html">Beschr√§nkung der lokalen Benutzerrechte unter Linux auf ein Minimum</a></li>
<li><a href="../de437712/index.html">Raumstation Roskomnadzor</a></li>
<li><a href="../de437714/index.html">Wir zeichnen eine Cartoon-Explosion f√ºr 180 Zeilen nacktes C ++</a></li>
<li><a href="../de437716/index.html">Drei relativ ehrliche M√∂glichkeiten, ein Flutter-Projekt zu erstellen</a></li>
<li><a href="../de437722/index.html">Kosmische Folgen des amerikanischen Shatdown</a></li>
<li><a href="../de437724/index.html">OpenSceneGraph: Prozedurale Animation von Geometrie- und Statusattributen</a></li>
<li><a href="../de437726/index.html">Kotlin mit Kotlinx serialisieren. Serialisierung</a></li>
<li><a href="../de437730/index.html">Wie wir das Speicherproblem in PostgreSQL gel√∂st haben, ohne ein Byte hinzuzuf√ºgen</a></li>
<li><a href="../de437732/index.html">√úbersicht √ºber den MakeX M-One Pro 70 DLP-Drucker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>