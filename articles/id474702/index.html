<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏿 👵🏻 🌌 Pemrograman fungsional dari sudut pandang EcmaScript. Fungsi murni, lambda, kekebalan 🖕🏽 🙇🏿 🥃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Hari ini kita akan mulai berbicara tentang topik yang sangat penting - pemrograman fungsional. Pentingnya FP dalam pengembangan web mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman fungsional dari sudut pandang EcmaScript. Fungsi murni, lambda, kekebalan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474702/"> Halo, Habr! <br><br>  Hari ini kita akan mulai berbicara tentang topik yang sangat penting - pemrograman fungsional.  Pentingnya FP dalam pengembangan web modern sulit ditaksir terlalu tinggi.  Arsitektur dari setiap proyek modern besar termasuk fungsi perpustakaan yang ditentukan pengguna, dan akan ada pertanyaan wajib pada subjek wawancara di tingkat manapun. <br><br><h2>  Pengantar Pemrograman Fungsional </h2><br>  <b>Pemrograman fungsional (FP)</b> adalah cara mengatur kode dengan menulis serangkaian fungsi. <br><br>  EcmaScript, menjadi bahasa pemrograman multi-paradigma, mengimplementasikan, antara lain, paradigma fungsional.  Ini berarti bahwa fungsi dalam ES adalah data dan dapat dikirimkan ke fungsi, dikembalikan dari fungsi, dan dapat menerima fungsi itu sendiri.  Yaitu  fungsi dalam ES adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi kelas satu</a> . <br><br>  Definisi berikut mengikuti dari ini: <br><br>  <b>Argumen fungsional (funarg)</b> - argumen yang nilainya berfungsi. <br><br>  <b>Fungsi orde tinggi (FWP, orde-orde tinggi, hof)</b> adalah fungsi yang menerima fungsi sebagai argumen. <br><br>  <b>Fungsi dengan nilai fungsional (Function bernilai fungsi)</b> - fungsi yang mengembalikan fungsi. <br><br>  Semua jenis fungsi ini dikondisikan secara kondisional ke dalam fungsi-fungsi kelas satu, dan, sebagai berikut dari definisi di atas, dalam ES semua fungsi adalah objek-objek dari kelas pertama. <br><a name="habracut"></a><br><h3>  Fungsi murni - ideal pemrograman fungsional </h3><br>  <b>Fungsi murni (PF)</b> - selalu mengembalikan hasil yang diprediksi. <br>  Properti PF: <br><br><ul><li>  Hasil eksekusi PF hanya bergantung pada argumen yang diberikan dan algoritma yang mengimplementasikan PF </li><li>  Jangan gunakan nilai global </li><li>  Jangan memodifikasi nilai luar atau argumen yang diteruskan </li><li>  Jangan menulis data ke file, database, atau di tempat lain </li></ul><br>  Contoh fungsi murni: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">) =&gt;</span></span> x+y;</code> </pre> <br>  Contoh pengotor fungsi yang bagus adalah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; first = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++a; } second = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> --a; } a = <span class="hljs-number"><span class="hljs-number">2</span></span>; first();<span class="hljs-comment"><span class="hljs-comment">//3 } testFn(); first();//4 second();//3</span></span></code> </pre><br>  Bayangkan betapa rumitnya menulis tes untuk contoh ini dan seberapa sederhana untuk fungsi murni! <br><br>  Fungsi-fungsi yang tidak murni dicirikan oleh keadaan eksternal yang bervariasi waktu yang menyulitkan pemeliharaan, pemahaman, dan pengujian kode. <br><br>  Sebaliknya, fungsi murni selalu dapat dibaca, diuji, menyederhanakan paralelisasi perhitungan, dan mudah digunakan kembali. <br><br>  Saya pikir Anda memperhatikan bahwa dalam contoh-contoh pada fungsi murni, saya beralih ke sintaks ES6.  Ini dilakukan dengan sengaja.  Sintaks fungsi ini disebut "fungsi panah", tetapi sebenarnya ini merupakan implementasi dari abstraksi matematis, diciptakan sejak lama.  Tentang itu lebih jauh. <br><br><h3>  Lambda - fungsi </h3><br>  Inilah yang bentuk tulisan panah ini disebut dalam matematika dan beberapa bahasa pemrograman lainnya.  Pemrograman fungsional sangat erat kaitannya dengan mat.  analisis, jadi jangan kaget. <br><br>  Istilah kalkulus Lambda diperkenalkan kembali pada tahun 1930-an oleh Gereja Alonzo.  Pada dasarnya, kalkulus lambda tidak lebih dari bentuk formal menggambarkan persamaan matematika.  Lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Dalam ES, fungsi lambda sangat sering mengimplementasikan penutupan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; x + y;</code> </pre><br>  Singkat dan ringkas.  Fungsi add adalah lambda yang mengambil argumen x, menyimpannya dalam penutup, dan mengembalikan fungsi. <br><br>  Bandingkan dengan kode ini: <br><br><pre> <code class="javascript hljs">funtion add(x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } }</code> </pre><br>  Jelas, opsi pertama terlihat lebih baik. <br><br><h3>  Kekebalan </h3><br>  <b>Immutable (immutable, immunity)</b> adalah objek yang kondisinya tidak dapat diubah setelah penciptaan.  Hasil modifikasi objek semacam itu akan selalu menjadi objek baru, sedangkan objek lama tidak akan berubah. <br><br>  Kekekalan adalah cawan emas pemrograman fungsional. <br><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> impureAddProp = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, value, object</span></span></span><span class="hljs-function">) =&gt;</span></span> { object[key] = value;<span class="hljs-comment"><span class="hljs-comment">//   }; const User= { name: 'Alex' }; impureAddProp ('isAdmin', true, User);</span></span></code> </pre><br>  Seperti yang Anda lihat, dalam contoh ini, kami memutasikan objek Pengguna dengan menambahkan properti ke sana.  Sekarang objek Pengguna adalah semacam "keadaan bersama" untuk fungsi impureAddProp dan fungsi lain yang akan memutasinya.  Pendekatan ini lebih sulit untuk diuji karena  Saat mengubah fungsi apa pun yang berinteraksi dengan status bersama, orang harus selalu mengingat kemungkinan kesalahan dalam fungsi lainnya. <br><br>  Dari sudut pandang pemrograman fungsional, itu akan benar: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pureAddProp = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, value, object</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ ...object, [key]: value }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User= { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Alex'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Admin= pureAddProp (<span class="hljs-string"><span class="hljs-string">'isAdmin'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, User);</code> </pre><br>  Jadi objek Pengguna akan tetap tidak berubah.  Kami memodifikasi salinan data, yang selalu aman. <br><br><h2>  Kesimpulan </h2><br>  Hari ini kita telah memeriksa beberapa konsep teoritis penting.  Kami berkenalan dengan fungsi-fungsi murni, bentuk lambda dari fungsi perekaman dan konsep immutability dalam fp.  Namun, artikel ini adalah semacam pengantar.  Gagasan utama, teknik, dan “bagian sulit” dari pemrograman fungsional akan ada dalam artikel berikut. <br><br>  Pemrograman fungsional diimplementasikan oleh banyak perpustakaan.  Ini rambda, dan lodash, dan banyak lainnya.  Dalam proyek nyata, Anda, tentu saja, akan menggunakannya.  Di bawah kap perpustakaan mana pun, masih akan ada javascript asli yang sama, jadi dalam artikel berikut ini kami akan menganalisis FP, menerapkan semua konsepnya pada JS asli. <br><br><h2>  Catatan tambahan </h2><br>  Mulai menulis artikel, saya memikirkan rencana berikut: <br><br><ul><li>  menulis terjemahan artikel berbahasa Inggris yang menarik </li><li>  untuk menyoroti beberapa area yang relevan di JS (konsep utama, OOP dalam hal spesifikasi, pola, pemrograman fungsional EcmaScript). </li></ul><br>  Hingga saat ini, artikel utama di tiga bidang telah ditulis: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini dan ScopeChain dalam EcmaScript</a> - di sini saya menjelaskan konsep-konsep kunci seperti spesifikasi sebagai konteks eksekusi, kata kunci ini, dan properti konteks ScopeChain (lingkup rantai).  Dalam kerangka arah ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya tentang lingkungan Lexical dan Penutupan diterbitkan secara harfiah hari ini. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pandangan dari EcmaScript pada teori umum OOP</a> - perbedaan antara pengetikan kelas statis dan organisasi prototipe dinamis dijelaskan di sini, model pendelegasian dan pengetikan bebek dibongkar </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pola elegan dalam JavaScript modern (seri kompilasi Bill Sourour pada siklus)</a> - berikut adalah dua pola yang dapat berguna dalam beberapa situasi.  Pendekatan saya dalam hal pola cukup sederhana: lebih baik untuk mengetahui sebanyak mungkin pola, karena  cepat atau lambat berguna </li></ol><br>  Dan sekarang giliran pemrograman fungsional.  Di masa depan, saya akan menulis artikel sebagai kelanjutan dari masing-masing bidang ini.  Sebagai contoh, artikel berikut akan membahas konsep-konsep kunci OOP: enkapsulasi, abstraksi, pengotor (dan goresan), antarmuka, dll. Saya juga berencana untuk berbicara tentang bagaimana OOP dalam ES diterapkan di bawah tenda, mis.  tentang sifat-sifat [[Prototipe]], [[Kelas]] dan banyak lagi.  Bicara tentang bagaimana v8 membuat entitas dan instance kelas, fungsi. <br><br>  Banyak pertanyaan muncul di komentar, jadi saya ingin menjelaskan tujuan yang saya tetapkan untuk artikel saya.  Saya tidak menulis tutorial atau meninjau dokumentasi.  Menurut pendapat saya, ini tidak masuk akal.  Saya tidak menyarankan Anda dengan instrumen atau pola tertentu, pilihan mereka sepenuhnya terserah Anda. <br><br>  Dalam artikel-artikel itu, saya akan meninjau konsep-konsepnya, memberi tahu bagaimana konsep-konsep itu disusun di bawah tenda (menurut saya, ini meningkatkan pemahaman tentang apa yang kita tulis dan mengapa kita menulis dengan cara ini), atau saya berbicara tentang beberapa hal yang memperluas wawasan saya.  Menurut saya ini sangat penting.  Lihatlah perusahaan seperti Yandex atau Edadil, mereka terus-menerus berbicara tentang semacam ide orisinal.  Entah ini bitmap dalam reaksi, maka aplikasi vue hampir sepenuhnya pada kelas es6.  Kebanyakan pengembang web tidak akan pernah memikirkan hal seperti itu.  Ini membutuhkan pandangan yang luas. <br><br>  Saya sendiri mempelajari dan mempelajari web dengan cara ini, yaitu  setelah membaca tutorial atau dok, saya mencoba memahami cara alat yang dijelaskan ini bekerja di bawah tenda, untuk memahami mekanisme internalnya. <br><br>  Sampai artikel selanjutnya, teman-teman! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474702/">https://habr.com/ru/post/id474702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474692/index.html">Ulasan Skaffold untuk Pengembangan Kubernetes</a></li>
<li><a href="../id474694/index.html">Bagaimana kami memilih dan memutar kerangka kerja untuk pengujian kinerja</a></li>
<li><a href="../id474696/index.html">Tiket ke industri minyak atau Rosneft menyerukan Tantangan Seismik</a></li>
<li><a href="../id474698/index.html">Menggunakan modal windows di antarmuka pengguna</a></li>
<li><a href="../id474700/index.html">Cloud Smart Home. Bagian 2: Layanan Cloud</a></li>
<li><a href="../id474704/index.html">Wawancara Playboy: Steve Jobs, Bagian 2</a></li>
<li><a href="../id474706/index.html">Algoritma Pencarian Fuzzy TextRadar - Pendekatan Dasar</a></li>
<li><a href="../id474708/index.html">Internet lebih terfragmentasi dari sebelumnya: di mana lebih dari satu juta pengguna baru “datang” setiap hari? Bagian 1</a></li>
<li><a href="../id474710/index.html">c.tech: Frontend Meetup # 2</a></li>
<li><a href="../id474712/index.html">Udalenka di IT: pengalaman pribadi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>