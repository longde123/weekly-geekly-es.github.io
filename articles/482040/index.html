<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòº üññ üë¶üèø Ofrece programas de creaci√≥n de perfiles en C ++ üë®üèΩ‚Äçüöí üéª üë©üèª‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A veces, puede ser necesario perfilar el rendimiento del programa o el consumo de memoria en un programa C ++. Desafortunadamente, a menudo esto no es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ofrece programas de creaci√≥n de perfiles en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482040/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/sv/vy/xjsvvy62rgww5jixemahqzaz0yi.jpeg"></div><br>  A veces, puede ser necesario perfilar el rendimiento del programa o el consumo de memoria en un programa C ++.  Desafortunadamente, a menudo esto no es tan f√°cil como parece. <br><br>  Aqu√≠ consideraremos las caracter√≠sticas de los programas de creaci√≥n de perfiles utilizando las <b>herramientas Valgrind</b> y <b>Google Perftools</b> .  El material result√≥ no ser muy estructurado, es m√°s bien un intento de reunir una base de conocimiento "para fines personales" para que en el futuro no tenga que recordar fren√©ticamente "por qu√© esto no funciona" o "c√≥mo hacerlo".  Lo m√°s probable es que no todos los casos no obvios se vean afectados aqu√≠, si tiene algo que agregar, escriba los comentarios. <br><br>  Todos los ejemplos se ejecutar√°n en el sistema Linux. <a name="habracut"></a><br><br><h2>  Perfiles de tiempo de ejecuci√≥n </h2><br><h3>  Preparaci√≥n </h3><br>  Para analizar las caracter√≠sticas de la creaci√≥n de perfiles, ejecutar√© peque√±os programas, que generalmente consisten en un archivo main.cpp y un archivo func.cpp junto con la inclusi√≥n. <br>  Los compilar√© con el <b>compilador g ++ 8.3.0</b> . <br><br>  Dado que la creaci√≥n de perfiles de programas no optimizados es una tarea bastante extra√±a, compilaremos con la opci√≥n <b>-Ofast</b> , y para obtener caracteres de depuraci√≥n en la salida, no olvidaremos agregar la opci√≥n <b>-g</b> .  Sin embargo, a veces, en lugar de los nombres de funciones normales, solo puede ver direcciones de llamadas inaudibles.  Esto significa que ha habido una "aleatorizaci√≥n de la asignaci√≥n de espacio de direcciones".  Esto se puede determinar llamando al comando <b>nm</b> en el binario.  Si la mayor√≠a de las direcciones se parecen a esto 00000000000030e0 (una gran cantidad de ceros al principio), entonces lo m√°s probable es que sea as√≠.  En un programa normal, las direcciones se ven como 0000000000402fa0.  Por lo tanto, debe agregar la opci√≥n <b>-no-pie</b> .  Como resultado, el conjunto completo de opciones se ver√° as√≠: <br>  <b>-Ofast -g -no-pie</b> <br><br>  Para ver los resultados, utilizaremos el programa <b>KCachegrind</b> , que puede funcionar con el <b>formato de</b> informe <b>callgrind</b> <br><br><h3>  Callgrind </h3><br>  La primera utilidad que veremos hoy es <b>callgrind</b> .  Esta utilidad es parte de la herramienta valgrind.  Emula cada instrucci√≥n ejecutable del programa y, sobre la base de m√©tricas internas sobre el "costo" de cada instrucci√≥n, emite la conclusi√≥n que necesitamos.  Debido a este enfoque, a veces sucede que callgrind no puede reconocer la siguiente instrucci√≥n y se cae con un error <br>  <i>Instrucciones no reconocidas en la direcci√≥n</i> <br>  La √∫nica forma de salir de esta situaci√≥n es reconsiderar todas las opciones de compilaci√≥n e intentar encontrar la interferencia. <br><br>  Creemos un programa para probar esta herramienta, que consta de una biblioteca compartida y una biblioteca est√°tica (dejaremos las bibliotecas m√°s adelante en otras pruebas).  Cada biblioteca, as√≠ como el programa en s√≠, proporcionar√° una funci√≥n computacional simple, por ejemplo, el c√°lculo de la secuencia de Fibonacci. <br><br><div class="spoiler">  <b class="spoiler_title">static_lib</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////////// // static_lib.h // ////////////////// #ifndef SERVER_STATIC_LIB_H #define SERVER_STATIC_LIB_H int func_static_lib(int arg); #endif //SERVER_STATIC_LIB_H //////////////////// // static_lib.cpp // /////////////////// #include "static_lib.h" #include "static_func.h" #include &lt;cstddef&gt; int func_static_lib(int arg) { return static_func(arg); } /////////////////// // static_func.h // /////////////////// #ifndef TEST_PROFILER_STATIC_FUNC_H #define TEST_PROFILER_STATIC_FUNC_H int static_func(int arg); #endif //TEST_PROFILER_STATIC_FUNC_H ///////////////////// // static_func.cpp // ///////////////////// #include "static_func.h" int static_func(int arg) { int fst = 0; int snd = 1; for (int i = 0; i &lt; arg; i++) { int tmp = (fst + snd) % 17769897; fst = snd; snd = tmp; } return fst; }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">shared_lib</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////////// // shared_lib.h // ////////////////// #ifndef TEST_PROFILER_SHARED_LIB_H #define TEST_PROFILER_SHARED_LIB_H int func_shared_lib(int arg); #endif //TEST_PROFILER_SHARED_LIB_H //////////////////// // shared_lib.cpp // //////////////////// #include "shared_lib.h" #include "shared_func.h" int func_shared_lib(int arg) { return shared_func(arg); } /////////////////// // shared_func.h // /////////////////// #ifndef TEST_PROFILER_SHARED_FUNC_H #define TEST_PROFILER_SHARED_FUNC_H int shared_func(int arg); #endif //TEST_PROFILER_SHARED_FUNC_H ///////////////////// // shared_func.cpp // ///////////////////// #include "shared_func.h" int shared_func(int arg) { int result = 1; for (int i = 1; i &lt; arg; i++) { result = (int)(((long long)result * i) % 19637856977); } return result; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">principal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////// // main.cpp // ////////////// #include &lt;iostream&gt; #include "static_lib.h" #include "shared_lib.h" #include "func.h" int main(int argc, char **argv) { if (argc != 2) { std::cout &lt;&lt; "Incorrect args"; return -1; } const int arg = std::atoi(argv[1]); std::cout &lt;&lt; "result: " &lt;&lt; func_static_lib(arg) &lt;&lt; " " &lt;&lt; func_shared_lib(arg) &lt;&lt; " " &lt;&lt; func(arg); return 0; } //////////// // func.h // //////////// #ifndef TEST_PROFILER_FUNC_H #define TEST_PROFILER_FUNC_H int func(int arg); #endif //TEST_PROFILER_FUNC_H ////////////// // func.cpp // ////////////// #include "func.h" int func(int arg) { int fst = 1; int snd = 1; for (int i = 0; i &lt; arg; i++) { int res = (fst + snd + 1) % 19845689; fst = snd; snd = res; } return fst; }</span></span></code> </pre><br></div></div><br>  Compilamos el programa y ejecutamos valgrind de la siguiente manera: <br><br><pre> <code class="bash hljs">valgrind --tool=callgrind ./test_profiler 100000000</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/i7/xa/tt/i7xattm3xphucvb3x5ogxlbpv20.png"></a> <br>  Vemos que para una biblioteca est√°tica y una funci√≥n regular, el resultado es similar al esperado.  Pero en la biblioteca din√°mica, callgrind no pudo resolver completamente la funci√≥n. <br><br>  Para solucionar esto, al iniciar el programa, debe establecer la variable <b>LD_BIND_NOW</b> en 1, as√≠: <br><br><pre> <code class="bash hljs">LD_BIND_NOW=1 valgrind --tool=callgrind ./test_profiler 100000000</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/nb/l2/yb/nbl2ybqiy6atyd5cak6evogfbem.png"></a> <br>  Y ahora, como puedes ver, todo est√° bien <br><br>  El siguiente problema de callgrind que surge de la creaci√≥n de perfiles emulando instrucciones es que la ejecuci√≥n del programa se ralentiza mucho.  Esto puede llevar una estimaci√≥n relativa incorrecta del tiempo de ejecuci√≥n de varias partes del c√≥digo. <br><br>  Veamos este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fst = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> snd = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ofstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tmp.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = (fst + snd + <span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">19845689</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(res); file &lt;&lt; res; file.flush(); fst = snd; snd = res + r.size(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fst; }</code> </pre><br>  Aqu√≠, agregu√© una peque√±a cantidad de datos a un archivo para cada iteraci√≥n del bucle.  Como escribir en un archivo es una operaci√≥n bastante larga, como contrapeso, agregu√© una generaci√≥n de l√≠nea desde un n√∫mero a cada iteraci√≥n del bucle.  Obviamente, en este caso, la operaci√≥n de escritura en el archivo lleva m√°s tiempo que el resto de la l√≥gica de la funci√≥n.  Pero callgrind piensa diferente: <br> <a href=""><img src="https://habrastorage.org/webt/hn/pg/zt/hnpgztqrtptlu7_g0tmr5frgbuy.png"></a> <br><br>  Tambi√©n vale la pena considerar que callgrind solo puede medir el costo de una funci√≥n cuando funciona.  La funci√≥n no funciona, por lo tanto, el costo no aumenta.  Esto complica la depuraci√≥n de programas que de vez en cuando ingresan al bloqueo o funcionan con un sistema / red de archivos de bloqueo.  Vamos a ver: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"func.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; static std::mutex mutex; int funcImpl(int arg) { std::lock_guard&lt;std::mutex&gt; lock(mutex); int fst = 1; int snd = 1; for (int i = 0; i &lt; arg; i++) { int res = (fst + snd + 1) % 19845689; fst = snd; snd = res; } return fst; } int func2(int arg){ return funcImpl(arg); } int func(int arg) { return funcImpl(arg); } int main(int argc, char **argv) { if (argc != 2) { std::cout &lt;&lt; "Incorrect args"; return -1; } const int arg = std::atoi(argv[1]); auto future = std::async(std::launch::async, &amp;func2, arg); std::cout &lt;&lt; "result: " &lt;&lt; func(arg) &lt;&lt; std::endl; std::cout &lt;&lt; "second result " &lt;&lt; future.get() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Aqu√≠ hemos incluido toda la ejecuci√≥n de la funci√≥n en el bloqueo del mutex, y llamamos a esta funci√≥n desde dos hilos diferentes.  El resultado de callgrind es bastante predecible: no ve ning√∫n problema en capturar un mutex: <br> <a href=""><img src="https://habrastorage.org/webt/be/eh/nj/beehnjstn0h_kjbjjq2by_randc.png"></a> <br><br>  Entonces, examinamos algunos de los problemas de usar el generador de perfiles callgrind.  Pasemos al siguiente tema de prueba: el perfilador de perftools de google <br><br><h3>  perftools de google </h3><br>  A diferencia de callgrind, el generador de perfiles de Google funciona con un principio diferente. <br>  En lugar de analizar cada instrucci√≥n del programa ejecutable, detiene el programa a intervalos regulares e intenta determinar en qu√© funci√≥n se encuentra actualmente.  Como resultado, esto casi no afecta el rendimiento de la aplicaci√≥n en ejecuci√≥n.  Pero este enfoque tambi√©n tiene sus debilidades. <br><br>  Comencemos perfilando el primer programa con dos bibliotecas. <br><br>  Como regla general, para comenzar a generar perfiles con esta utilidad, debe precargar la biblioteca libprofiler.so, establecer la frecuencia de muestreo y especificar el archivo para guardar el volcado.  Desafortunadamente, el generador de perfiles requiere que el programa finalice "por s√≠ solo".  La terminaci√≥n forzada del programa har√° que el informe simplemente no se descarte.  Esto es inconveniente cuando se perfilan programas de larga duraci√≥n que no se detienen, como los demonios.  Para sortear este obst√°culo, cre√© este script: <br><br><div class="spoiler">  <b class="spoiler_title">gprof.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs">rnd=<span class="hljs-variable"><span class="hljs-variable">$RANDOM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">$#</span></span> -eq 0 ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"./gprof.sh command args"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Run with variable N_STOP=true if hand stop required"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> libprofiler=$( dirname <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASH_SOURCE[0]}</span></span></span><span class="hljs-string">"</span></span> ) arg=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> nostop=<span class="hljs-variable"><span class="hljs-variable">$N_STOP</span></span> profileName=callgrind.out.<span class="hljs-variable"><span class="hljs-variable">$rnd</span></span>.g gperftoolProfile=./gperftool.<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$rnd</span></span></span><span class="hljs-string">"</span></span>.txt touch <span class="hljs-variable"><span class="hljs-variable">$profileName</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Profile name </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$profileName</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$nostop</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ]] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"without stop"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> <span class="hljs-string"><span class="hljs-string">'echo trap &amp;&amp; kill -12 $PID &amp;&amp; sleep 1 &amp;&amp; kill -TERM $PID'</span></span> TERM INT <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> <span class="hljs-string"><span class="hljs-string">'echo trap &amp;&amp; kill -TERM $PID'</span></span> TERM INT <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$nostop</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ]] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CPUPROFILESIGNAL=12 CPUPROFILE_FREQUENCY=1000000 CPUPROFILE=<span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span> LD_PRELOAD=<span class="hljs-variable"><span class="hljs-variable">${libprofiler}</span></span>/libprofiler.so <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${@:1}</span></span></span><span class="hljs-string">"</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CPUPROFILE_FREQUENCY=1000000 CPUPROFILE=<span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span> LD_PRELOAD=<span class="hljs-variable"><span class="hljs-variable">${libprofiler}</span></span>/libprofiler.so <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${@:1}</span></span></span><span class="hljs-string">"</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> PID=$! <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$nostop</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ]] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> sleep 1 <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -12 <span class="hljs-variable"><span class="hljs-variable">$PID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-variable"><span class="hljs-variable">$PID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> - TERM INT <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-variable"><span class="hljs-variable">$PID</span></span> EXIT_STATUS=$? <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span> <span class="hljs-variable"><span class="hljs-variable">${libprofiler}</span></span>/pprof --callgrind <span class="hljs-variable"><span class="hljs-variable">$arg</span></span> <span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span>* &gt; <span class="hljs-variable"><span class="hljs-variable">$profileName</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Profile name </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$profileName</span></span></span><span class="hljs-string">"</span></span> rm -f <span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span>*</code> </pre><br></div></div><br>  Esta utilidad debe ejecutarse, pasando como par√°metros el nombre del archivo ejecutable y una lista de sus par√°metros.  Adem√°s, se supone que junto al script est√°n los archivos que necesita libprofiler.so y pprof.  Si el programa es de larga duraci√≥n y se detiene al interrumpir la ejecuci√≥n, debe establecer la variable N_STOP en true, por ejemplo, as√≠: <br><pre> <code class="bash hljs">N_STOP=<span class="hljs-literal"><span class="hljs-literal">true</span></span> ./gprof.sh ./test_profiler 10000000000</code> </pre> <br>  Al final del trabajo, el script generar√° un informe en mi formato favorito de callgrind. <br><br>  Entonces, ejecutemos nuestro programa bajo este generador de perfiles. <br><pre> <code class="bash hljs">./gprof.sh ./test_profiler 1000000000</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/qg/q_/sw/qgq_sw__etaj7mmmrgzvgw_b70c.png"></a> <br>  En principio, todo est√° bastante claro. <br><br>  Como dije, el generador de perfiles de Google funciona deteniendo la ejecuci√≥n del programa y calculando la funci√≥n actual.  ¬øC√≥mo hace eso?  Lo hace haciendo girar la pila.  ¬øPero qu√© pasa si, en el momento de la promoci√≥n de la pila, el programa en s√≠ mismo desenrolla la pila?  Bueno, obviamente, nada bueno suceder√°.  Vamos a verlo  Escribamos tal funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runExcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res % <span class="hljs-number"><span class="hljs-number">13</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"Exception"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fst = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> snd = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = (fst + snd + <span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">19845689</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = runExcept(res); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;e) { res = res - <span class="hljs-number"><span class="hljs-number">1</span></span>; } fst = snd; snd = res; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fst; }</code> </pre><br>  Y ejecuta el perfilado.  El programa se congela bastante r√°pido. <br><br>  Hay otro problema relacionado con la peculiaridad de la operaci√≥n del generador de perfiles.  Supongamos que logramos desenrollar la pila y ahora necesitamos unir las direcciones con las funciones espec√≠ficas del programa.  Esto puede ser muy poco trivial, ya que en C ++ hay una gran cantidad de funciones en l√≠nea.  Veamos un ejemplo como este: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"func.h"</span></span></span><span class="hljs-meta"> static int func1(int arg) { std::cout &lt;&lt; 1 &lt;&lt; std::endl; return func(arg); } static int func2(int arg) { std::cout &lt;&lt; 2 &lt;&lt; std::endl; return func(arg); } static int func3(int arg) { std::cout &lt;&lt; 3 &lt;&lt; std::endl; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg % 2 == 0) { return func2(arg); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { return func1(arg); } } int main(int argc, char **argv) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 2) { std::cout &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Incorrect args"</span></span></span><span class="hljs-meta">; return -1; } const int arg = std::atoi(argv[1]); int arg2 = func3(arg); int arg3 = func(arg); std::cout &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"result: "</span></span></span><span class="hljs-meta"> &lt;&lt; arg2 + arg3; return 0; }</span></span></code> </pre><br>  Obviamente, si ejecuta el programa, por ejemplo, as√≠: <br><pre> <code class="bash hljs">./gprof.sh ./test_profiler 1000000000</code> </pre> <br>  entonces la funci√≥n func1 nunca se llamar√°.  Pero el perfilador piensa de manera diferente: <br> <a href=""><img src="https://habrastorage.org/webt/8-/0o/ny/8-0onyayanqwvdarg94cd92srzc.png"></a> <br>  (Por cierto, valgrind aqu√≠ decidi√≥ guardar silencio modestamente y no especificar de qu√© funci√≥n espec√≠fica proven√≠a la llamada). <br><br><h2>  Perfiles de memoria </h2><br>  A menudo hay situaciones en las que la memoria de la aplicaci√≥n en alg√∫n lugar "fluye".  Si esto se debe a la falta de limpieza de recursos, entonces Memcheck deber√≠a ayudar a identificar el problema.  Pero en C ++ moderno no es tan dif√≠cil prescindir de la gesti√≥n manual de recursos.  unique_ptr, shared_ptr, vector, map hacen que la manipulaci√≥n de puntos desnudos no tenga sentido. <br><br>  Sin embargo, en tales aplicaciones, la memoria se pierde.  ¬øC√≥mo va esto?  En pocas palabras, por regla general, es algo as√≠ como "poner el valor en un mapa de larga vida, pero olvid√© eliminarlo".  Intentemos rastrear esta situaci√≥n. <br><br>  Para hacer esto, reescribimos nuestra funci√≥n de prueba de esta manera <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"func.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;deque&gt; #include &lt;string&gt; #include &lt;map&gt; static std::deque&lt;std::string&gt; deque; static std::map&lt;int, std::string&gt; map; int func(int arg) { int fst = 1; int snd = 1; for (int i = 0; i &lt; arg; i++) { int res = (fst + snd + 1) % 19845689; fst = snd; snd = res; deque.emplace_back(std::to_string(res) + " integer"); map[i] = "integer " + std::to_string(res); deque.pop_front(); if (res % 200 != 0) { map.erase(i - 1); } } return fst; }</span></span></span></span></code> </pre><br>  Aqu√≠, en cada iteraci√≥n, agregamos algunos elementos al mapa, y por casualidad (verdadero, verdadero) olvidamos eliminarlos a veces de all√≠.  Adem√°s, para evitar nuestros ojos, torturamos std :: deque un poco. <br><br>  <b>Detectaremos</b> p√©rdidas de memoria con dos herramientas: <b>valgrind massif</b> y <b>google heapdump</b> . <br><br><h3>  Macizo </h3><br>  Ejecute el programa con este comando <br><pre> <code class="bash hljs">valgrind --tool=massif ./test_profiler 1000000</code> </pre> <br>  Y vemos algo como <br><br><div class="spoiler">  <b class="spoiler_title">Macizo</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">1277949333</span></span> mem_heap_B=<span class="hljs-number"><span class="hljs-number">313518</span></span> mem_heap_extra_B=<span class="hljs-number"><span class="hljs-number">58266</span></span> mem_stacks_B=<span class="hljs-number"><span class="hljs-number">0</span></span> heap_tree=detailed n4: <span class="hljs-number"><span class="hljs-number">313518</span></span> (heap allocation functions) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[], --alloc-fns, etc. n1: <span class="hljs-number"><span class="hljs-number">195696</span></span> <span class="hljs-number"><span class="hljs-number">0x109A69</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (new_allocator.h:<span class="hljs-number"><span class="hljs-number">111</span></span>) n0: <span class="hljs-number"><span class="hljs-number">195696</span></span> <span class="hljs-number"><span class="hljs-number">0x10947A</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x52BA414</span></span>: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.25</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x4010731</span></span>: _dl_init (dl-init.c:<span class="hljs-number"><span class="hljs-number">72</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x40010C8</span></span>: ??? (in /lib/x86_64-linux-gnu/ld<span class="hljs-number"><span class="hljs-number">-2.27</span></span>.so) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span>: ??? n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000D1</span></span>: ??? n0: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000E1</span></span>: ??? n2: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x10A7EC</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_mutate(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (new_allocator.h:<span class="hljs-number"><span class="hljs-number">111</span></span>) n1: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x10AAD9</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_replace(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (basic_string.tcc:<span class="hljs-number"><span class="hljs-number">466</span></span>) n1: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x1099D4</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (basic_string.h:<span class="hljs-number"><span class="hljs-number">1932</span></span>) n0: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x10947A</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n0: <span class="hljs-number"><span class="hljs-number">0</span></span> in <span class="hljs-number"><span class="hljs-number">2</span></span> places, all below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%) n0: <span class="hljs-number"><span class="hljs-number">2152</span></span> in <span class="hljs-number"><span class="hljs-number">10</span></span> places, all below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%)</code> </pre> <br></div></div><br>  Se puede ver que el macizo pudo detectar una fuga en la funci√≥n, pero hasta ahora no est√° claro d√≥nde.  Reconstruyamos el programa con el <b>indicador -fno-inline</b> y <b>volvamos a</b> ejecutar el an√°lisis. <br><br><div class="spoiler">  <b class="spoiler_title">macizo</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">3160199549</span></span> mem_heap_B=<span class="hljs-number"><span class="hljs-number">345142</span></span> mem_heap_extra_B=<span class="hljs-number"><span class="hljs-number">65986</span></span> mem_stacks_B=<span class="hljs-number"><span class="hljs-number">0</span></span> heap_tree=detailed n4: <span class="hljs-number"><span class="hljs-number">345142</span></span> (heap allocation functions) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[], --alloc-fns, etc. n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10CDBC</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;* <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Select1st&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; &gt;::_M_create_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt; &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;&amp;&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt;&amp;&amp;) [clone .isra<span class="hljs-number"><span class="hljs-number">.81</span></span>] (stl_tree.h:<span class="hljs-number"><span class="hljs-number">653</span></span>) n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10CE0C</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree_iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Select1st&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; &gt;::_M_emplace_hint_unique&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt; &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree_const_iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;&amp;&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt;&amp;&amp;) [clone .constprop<span class="hljs-number"><span class="hljs-number">.87</span></span>] (stl_tree.h:<span class="hljs-number"><span class="hljs-number">2414</span></span>) n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10CF2B</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; &gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) (stl_map.h:<span class="hljs-number"><span class="hljs-number">499</span></span>) n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10A7F5</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (func.cpp:<span class="hljs-number"><span class="hljs-number">20</span></span>) n0: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x109F8E</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x52BA414</span></span>: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.25</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x4010731</span></span>: _dl_init (dl-init.c:<span class="hljs-number"><span class="hljs-number">72</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x40010C8</span></span>: ??? (in /lib/x86_64-linux-gnu/ld<span class="hljs-number"><span class="hljs-number">-2.27</span></span>.so) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span>: ??? n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000D1</span></span>: ??? n0: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000E1</span></span>: ??? n2: <span class="hljs-number"><span class="hljs-number">48670</span></span> <span class="hljs-number"><span class="hljs-number">0x10B866</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_mutate(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (basic_string.tcc:<span class="hljs-number"><span class="hljs-number">317</span></span>) n1: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x10BB2C</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_replace(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (basic_string.tcc:<span class="hljs-number"><span class="hljs-number">466</span></span>) n1: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x10A643</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;&amp;&amp;) [clone .constprop<span class="hljs-number"><span class="hljs-number">.86</span></span>] (basic_string.h:<span class="hljs-number"><span class="hljs-number">6018</span></span>) n1: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x10A7E5</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (func.cpp:<span class="hljs-number"><span class="hljs-number">20</span></span>) n0: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x109F8E</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n0: <span class="hljs-number"><span class="hljs-number">31</span></span> in <span class="hljs-number"><span class="hljs-number">1</span></span> place, below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%) n0: <span class="hljs-number"><span class="hljs-number">2152</span></span> in <span class="hljs-number"><span class="hljs-number">10</span></span> places, all below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%)</code> </pre> <br></div></div><br>  Ahora est√° claro d√≥nde est√° la fuga al agregar el elemento del mapa.  Massif puede detectar objetos de corta duraci√≥n, por lo que las manipulaciones con std :: deque son invisibles en este volcado. <br><br><h3>  Heapdump </h3><br>  Para que Google Heapdump funcione, debe vincular o precargar la biblioteca <b>tcmalloc</b> .  Esta biblioteca reemplaza las funciones est√°ndar de asignaci√≥n de memoria malloc, gratuita, ... Adem√°s, puede recopilar informaci√≥n sobre el uso de estas funciones, que utilizaremos al analizar el programa. <br><br>  Dado que este m√©todo funciona muy lentamente (incluso en comparaci√≥n con el macizo), le recomiendo que desactive inmediatamente la compilaci√≥n de funciones con la opci√≥n <b>-fno-inline</b> al compilar.  Entonces, reconstruimos nuestra aplicaci√≥n y corremos con el equipo <br><pre> <code class="bash hljs">HEAPPROFILESIGNAL=23 HEAPPROFILE=./heap ./test_profiler 100000000</code> </pre> <br>  Aqu√≠ se supone que la biblioteca tcmalloc est√° vinculada a nuestra aplicaci√≥n. <br><br>  Ahora, esperamos el tiempo necesario para la formaci√≥n de una fuga notable y enviamos a nuestro proceso una se√±al 23 <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -23 &lt;pid&gt;</code> </pre> <br>  Como resultado, aparece un archivo llamado heap.0001.heap, que convertimos al formato callgrind con el comando <br><br><pre> <code class="bash hljs">pprof ./test_profiler <span class="hljs-string"><span class="hljs-string">"./heap.0001.heap"</span></span> --inuse_space --callgrind &gt; callgrind.out.4</code> </pre> <br>  Tambi√©n preste atenci√≥n a las opciones de pprof.  Puede elegir entre las opciones <b>inuse_space</b> , <b>inuse_objects</b> , <b>alloc_space</b> , <b>alloc_objects</b> , que muestran el espacio u objetos que est√°n en uso, o el espacio y los objetos asignados durante todo el programa, respectivamente.  Estamos interesados ‚Äã‚Äãen la opci√≥n inuse_space, que muestra el espacio de memoria utilizado actualmente. <br><br>  Abra nuestro kCacheGrind favorito y vea <br> <a href=""><img src="https://habrastorage.org/webt/of/z2/j8/ofz2j88agvmi4bhfyhigracbn-i.png"></a> <br>  std :: map ha consumido demasiada memoria.  Probablemente una fuga en √©l. <br><br><h2>  Conclusiones </h2><br>  Perfilar en C ++ es una tarea muy dif√≠cil.  Aqu√≠ tenemos que lidiar con funciones de alineaci√≥n, instrucciones no compatibles, resultados incorrectos, etc.  No siempre es posible confiar en los resultados del generador de perfiles. <br><br>  Adem√°s de las funciones propuestas anteriormente, hay otras herramientas dise√±adas para perfilar: perf, intel VTune y otras.  Pero tambi√©n muestran algunas de estas deficiencias.  Por lo tanto, no olvide el m√©todo de creaci√≥n de perfiles "abuelo" midiendo el tiempo de ejecuci√≥n de las funciones y mostr√°ndolo en el registro. <br><br>  Adem√°s, si tiene t√©cnicas interesantes para perfilar su c√≥digo, publ√≠quelas en los comentarios </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482040/">https://habr.com/ru/post/482040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482028/index.html">Dos botones rojos, soldador y React: c√≥mo hicimos un movimiento para una conferencia de TI</a></li>
<li><a href="../482030/index.html">Vue.js: ganchos de ciclo de vida de sus componentes y los de terceros</a></li>
<li><a href="../482032/index.html">Jugamos con fuego: ejecutamos c√≥digo arbitrario en el desarrollo del iPhone 7</a></li>
<li><a href="../482034/index.html">Yandex: hay de todo ... acerca de los usuarios</a></li>
<li><a href="../482038/index.html">Estamos resumiendo los resultados de 2019 en Haber Career</a></li>
<li><a href="../482042/index.html">Trabajando con la biblioteca Newtonsoft.Json con un ejemplo real. Parte 2</a></li>
<li><a href="../482044/index.html">10 mejores pr√°cticas para asegurar las im√°genes de Docker. Parte 2</a></li>
<li><a href="../482050/index.html">T√©cnica de reducci√≥n de red de convoluci√≥n Jedi - poda</a></li>
<li><a href="../482052/index.html">Conjunto de datos de A√±o Nuevo 2019: diccionario tonal abierto del idioma ruso</a></li>
<li><a href="../482054/index.html">3. Pila el√°stica: an√°lisis de registro de seguridad. Tableros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>