<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàÅ üó®Ô∏è üçª API Camera2 do Android do bule, parte 3. Codec de m√≠dia e transmitir v√≠deo por UDP ü§≥üèΩ ‚úåüèø üòõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ent√£o, descobrimos como tirar fotos e gravar v√≠deos usando a API Camera2. Resta apenas aprender a transferir o fluxo de v√≠deo do dispositivo Android p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API Camera2 do Android do bule, parte 3. Codec de m√≠dia e transmitir v√≠deo por UDP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473036/">  Ent√£o, descobrimos como tirar fotos e gravar v√≠deos usando a API Camera2.  Resta apenas aprender a transferir o fluxo de v√≠deo do dispositivo Android para os destinat√°rios que sofrem do lado de fora.  O objetivo final, como j√° foi dito v√°rias vezes, √© a intelectualiza√ß√£o dos rob√¥s - colocamos um smartphone nele e, por assim dizer, transformamos um macaco em uma pessoa.  O Media Codec nos ajudar√° com isso.  E, claro, a nova API Camera2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/tl/mf/satlmfdhbe-ow-gywoc5-tuxupe.jpeg"></div><br>  Quem se importa, por favor, debaixo do gato. <br><a name="habracut"></a><br>  Detalhes sobre o projeto rob√≥tico podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , mas, por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enquanto</a> , transmitiremos o v√≠deo diretamente dele (ou melhor, de um smartphone Android anexado a ele) para um computador eletr√¥nico pessoal. <br><br><h4>  Do que precisamos para isso? </h4><br>  Para transferir um fluxo de v√≠deo da tela do smartphone para outro lugar, como voc√™ sabe, ele (fluxo) deve primeiro ser convertido para um formato reduzido (ser√° muito espesso para transmitir quadro a quadro), colocar carimbos de data / hora (carimbos de hora) e enviar em formato bin√°rio para o destinat√°rio .  O qual executar√° a opera√ß√£o de decodifica√ß√£o inversa. <br><br>  √â exatamente com essas a√ß√µes negras de baixo n√≠vel que a classe Media Codec lida desde 2013, a partir da data de lan√ßamento do Android 4.3. <br><br><img src="https://habrastorage.org/webt/ci/oz/xq/ciozxqlqwq8hecadsrkn0-8me6m.png"><br><br>  Outra coisa √© que a abordagem anterior da codifica√ß√£o de v√≠deo, ao contr√°rio de hoje, n√£o era t√£o simples.  Para tirar uma foto da c√¢mera, era necess√°rio usar toneladas de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo misterioso</a> no qual, como nos feiti√ßos dos xam√£s Yakut, a √∫nica imprecis√£o poderia levar a uma falha completa do aplicativo.  Adicione a isso a API da c√¢mera anterior, onde, em vez de retornos de chamada prontos, voc√™ mesmo precisar√° escrever diferentes canetas sincronizadas, e essa atividade, digamos, n√£o √© para os fracos de cora√ß√£o. <br><br>  E o mais importante, voc√™ olha para o <a href="">c√≥digo de</a> trabalho de longe, tudo parece claro em termos gerais.  Voc√™ come√ßa a transferir partes para o seu projeto - n√£o est√° claro por que ele est√° vazando.  Mas √© imposs√≠vel corrigir, porque √© dif√≠cil entender os detalhes. <br><br>  Sim, e de s√≥lidos <s>obsoletos de</s> alguma forma √† vontade.  Em suma, bagun√ßa <br><br>  Felizmente, para os lentos, os construtores do Google introduziram o conceito m√°gico do <b>Surface</b> , trabalhando com o qual voc√™ pode evitar detalhes de baixo n√≠vel.  √â dif√≠cil para mim, como leigo, entender a que custo e o que o desenvolvedor perde, mas agora podemos dizer quase literalmente: "Android, leve essa superf√≠cie para a qual o v√≠deo da c√¢mera √© exibido e n√£o mude nada l√°, bem, como est√°, codifique e enviar. "  E o mais surpreendente √© que funciona.  E com a nova API Camera2, o pr√≥prio programa sabe quando enviar dados, novos retornos de chamada apareceram! <br><br>  Ent√£o agora para codificar o v√≠deo - apenas cuspir.  O que faremos agora? <br>  Pegamos o c√≥digo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo</a> e, como sempre, jogamos tudo fora dele, exceto os bot√µes e a inicializa√ß√£o da c√¢mera. <br><br><div class="spoiler">  <b class="spoiler_title">Vamos come√ßar com o layout do aplicativo.</b> <div class="spoiler_text"><pre><code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span> xmlns:app=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span> xmlns:tools=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/tools"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> tools:context=<span class="hljs-string"><span class="hljs-string">".MainActivity"</span></span>&gt; &lt;TextureView android:id=<span class="hljs-string"><span class="hljs-string">"@+id/textureView"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"356dp"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"410dp"</span></span> android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"32dp"</span></span> app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintHorizontal_bias=<span class="hljs-string"><span class="hljs-string">"0.49"</span></span> app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintTop_toTopOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> /&gt; &lt;LinearLayout android:layout_width=<span class="hljs-string"><span class="hljs-string">"292dp"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"145dp"</span></span> android:layout_marginStart=<span class="hljs-string"><span class="hljs-string">"16dp"</span></span> android:orientation=<span class="hljs-string"><span class="hljs-string">"vertical"</span></span> app:layout_constraintBottom_toBottomOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintTop_toBottomOf=<span class="hljs-string"><span class="hljs-string">"@+id/textureView"</span></span> app:layout_constraintVertical_bias=<span class="hljs-string"><span class="hljs-string">"0.537"</span></span>&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button1"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">"   "</span></span> /&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button2"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">" "</span></span> /&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button3"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">" "</span></span> /&gt; &lt;/LinearLayout&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code> </pre> <br></div></div><br><h4>  E termine com a conex√£o do Media Codec </h4><br>  Na √∫ltima postagem, exibimos a imagem da c√¢mera na superf√≠cie e gravamos v√≠deos usando o MediaRecorder.  Para fazer isso, simplesmente especificamos os dois componentes na lista Surface. <br><br><pre> <code class="java hljs">(Arrays.asList(surface, mMediaRecorder.getSurface()).</code> </pre><br>  Aqui a mesma coisa, somente em vez de mMediaRecorder especificamos: <br><br><pre> <code class="java hljs">(Arrays.asList(surface, mEncoderSurface),</code> </pre><br>  Acontece, algo como: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startCameraPreviewSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(<span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>); surface = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Surface(texture); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CameraCaptureSession.StateCallback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ mSession = session; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mSession.setRepeatingRequest(mPreviewBuilder.build(), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, mBackgroundHandler); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CameraAccessException e) { e.printStackTrace(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigureFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ } }, mBackgroundHandler); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CameraAccessException e) { e.printStackTrace(); } }</code> </pre><br>  O que √© mEncoderSurface?  E esta √© a mesma superf√≠cie com a qual o Media Codec funcionar√°.  Apenas para come√ßar, voc√™ precisa inicializar os dois aproximadamente dessa maneira. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpMediaCodec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mCodec = MediaCodec.createEncoderByType(<span class="hljs-string"><span class="hljs-string">"video/avc"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 2; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); }</span></span></code> </pre><br>  Agora resta registrar um √∫nico retorno de chamada.  Quando o Media Codec sente repentinamente que os pr√≥ximos dados para transmiss√£o adicional est√£o prontos, ele nos notificar√° atrav√©s dele: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncoderCallback</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaCodec</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInputBufferAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOutputBufferAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, MediaCodec.BufferInfo info)</span></span></span><span class="hljs-function"> </span></span>{ outPutByteBuffer = mCodec.getOutputBuffer(index); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] outDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[info.size]; outPutByteBuffer.get(outDate); Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">" outDate.length : "</span></span> + outDate.length); mCodec.releaseOutputBuffer(index, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, MediaCodec.CodecException e)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOutputFormatChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, MediaFormat format)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"encoder output format changed: "</span></span> + format); } }</code> </pre><br>  A matriz de bytes outDate √© um verdadeiro tesouro.  Ele cont√©m partes prontas de um fluxo de v√≠deo H264 codificado com o qual agora podemos fazer o que quisermos. <br><br>  Aqui est√£o eles ... <br><br><img src="https://habrastorage.org/webt/lh/pe/kz/lhpekzdgk-z95gpos8493tdgdqi.png"><br><br>  Algumas pe√ßas podem ser grandes demais para serem transmitidas pela rede, mas nada, se necess√°rio, o sistema as triturar√° sozinho e as enviar√° ao destinat√°rio. <br>  Mas se for muito assustador, voc√™ pode se destruir empurrando um fragmento desse tipo <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count =<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp =outDate.length ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-comment"><span class="hljs-comment">//    byte[] ds; temp = temp-1024; if(temp&gt;=0) { ds = new byte[1024];} else { ds = new byte[temp+1024];} for(int i =0;i&lt;ds.length;i++) { ds[i]=outDate[i+1024*count]; } count=count+1; try { // Log.i(LOG_TAG, " outDate.length : " + ds.length); DatagramPacket packet = new DatagramPacket(ds, ds.length, address, port); udpSocket.send(packet); } catch (IOException e) { Log.i(LOG_TAG, "   UDP "); } } while (temp&gt;=0);</span></span></code> </pre><br><br>  Mas, por enquanto, precisamos ver em primeira m√£o que os dados no buffer s√£o realmente um fluxo de v√≠deo H264.  Portanto, vamos envi√°-los para um arquivo: <br><br>  Vamos escrever na configura√ß√£o: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpMediaCodec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ File mFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), <span class="hljs-string"><span class="hljs-string">"test3.h264"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { outputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(mFile)); Log.i(<span class="hljs-string"><span class="hljs-string">"Encoder"</span></span>, <span class="hljs-string"><span class="hljs-string">"outputStream initialized"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.printStackTrace(); }</code> </pre><br>  E no retorno de chamada, onde est√° o buffer: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { outputStream.write(outDate, <span class="hljs-number"><span class="hljs-number">0</span></span>, outDate.length);<span class="hljs-comment"><span class="hljs-comment">//     } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); }</span></span></code> </pre><br>  Abra o aplicativo, pressione o bot√£o: ‚ÄúLIGUE A C√ÇMERA E O FLUXO‚Äù.  A grava√ß√£o come√ßa automaticamente.  Esperamos um pouco e pressionamos o bot√£o Parar. <br><br>  O arquivo salvo normalmente n√£o ser√° perdido, pois o formato n√£o √© MP4, mas se voc√™ o abrir com um player VLC ou o converter on-line <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usando o ONLINE CONVERT</a> , garantiremos que estamos no caminho certo.  √â verdade que a imagem est√° de lado, mas √© corrig√≠vel. <br><br>  Em geral, para cada evento de grava√ß√£o, fotografia ou transmiss√£o, √© melhor, √© claro, abrir uma nova sess√£o a cada vez e fechar a antiga.  Ou seja, primeiro ligamos a c√¢mera e iniciamos a pr√©-visualiza√ß√£o.  Em seguida, se voc√™ precisar tirar uma foto, feche a visualiza√ß√£o e abra a visualiza√ß√£o, mas com o Image Reader preso.  Se mudarmos para a grava√ß√£o de v√≠deo, feche a sess√£o atual e inicie a sess√£o com a visualiza√ß√£o e o Media Recorder anexados.  Eu n√£o fiz isso, para que a visibilidade do c√≥digo n√£o sofra, e voc√™ decide como √© mais conveniente para si mesmo. <br><br>  E aqui est√° o c√≥digo inteiro. <br><br><div class="spoiler">  <b class="spoiler_title">BasicMediaCodec</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.basicmediacodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.annotation.RequiresApi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.appcompat.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.core.content.ContextCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.Manifest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.ActivityInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.PackageManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.graphics.SurfaceTexture; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraAccessException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraCaptureSession; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraDevice; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CaptureRequest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodecInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Build; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Environment; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Handler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.HandlerThread; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.StrictMode; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.util.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.Surface; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.TextureView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.View; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Button; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Toast; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String LOG_TAG = <span class="hljs-string"><span class="hljs-string">"myLogs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Surface surface = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; CameraService[] myCameras = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CameraManager mCameraManager = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CAMERA1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonOpenCamera1 = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonTStopStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TextureView mImageView = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HandlerThread mBackgroundThread; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Handler mBackgroundHandler = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MediaCodec mCodec = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Surface mEncoderSurface; // Surface      BufferedOutputStream outputStream; ByteBuffer outPutByteBuffer; private void startBackgroundThread() { mBackgroundThread = new HandlerThread("CameraBackground"); mBackgroundThread.start(); mBackgroundHandler = new Handler(mBackgroundThread.getLooper()); } private void stopBackgroundThread() { mBackgroundThread.quitSafely(); try { mBackgroundThread.join(); mBackgroundThread = null; mBackgroundHandler = null; } catch (InterruptedException e) { e.printStackTrace(); } } @RequiresApi(api = Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setContentView(R.layout.activity_main); Log.d(LOG_TAG, " "); if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ) { requestPermissions(new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1); } mButtonOpenCamera1 = findViewById(R.id.button1); mButtonStreamVideo = findViewById(R.id.button2); mButtonTStopStreamVideo = findViewById(R.id.button3); mImageView = findViewById(R.id.textureView); mButtonOpenCamera1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { setUpMediaCodec();//    if (myCameras[CAMERA1] != null) {//   if (!myCameras[CAMERA1].isOpen()) myCameras[CAMERA1].openCamera(); } } }); mButtonStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { { //    } } }); mButtonTStopStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mCodec != null) { Toast.makeText(MainActivity.this, "  ", Toast.LENGTH_SHORT).show(); myCameras[CAMERA1].stopStreamingVideo(); } } }); mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); try { //      myCameras = new CameraService[mCameraManager.getCameraIdList().length]; for (String cameraID : mCameraManager.getCameraIdList()) { Log.i(LOG_TAG, "cameraID: " + cameraID); int id = Integer.parseInt(cameraID); //     myCameras[id] = new CameraService(mCameraManager, cameraID); } } catch (CameraAccessException e) { Log.e(LOG_TAG, e.getMessage()); e.printStackTrace(); } } public class CameraService { private String mCameraID; private CameraDevice mCameraDevice = null; private CameraCaptureSession mSession; private CaptureRequest.Builder mPreviewBuilder; public CameraService(CameraManager cameraManager, String cameraID) { mCameraManager = cameraManager; mCameraID = cameraID; } private CameraDevice.StateCallback mCameraCallback = new CameraDevice.StateCallback() { @Override public void onOpened(CameraDevice camera) { mCameraDevice = camera; Log.i(LOG_TAG, "Open camera with id:" + mCameraDevice.getId()); startCameraPreviewSession(); } @Override public void onDisconnected(CameraDevice camera) { mCameraDevice.close(); Log.i(LOG_TAG, "disconnect camera with id:" + mCameraDevice.getId()); mCameraDevice = null; } @Override public void onError(CameraDevice camera, int error) { Log.i(LOG_TAG, "error! camera id:" + camera.getId() + " error:" + error); } }; private void startCameraPreviewSession() { SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(320, 240); surface = new Surface(texture); try { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), new CameraCaptureSession.StateCallback() { @Override public void onConfigured(CameraCaptureSession session) { mSession = session; try { mSession.setRepeatingRequest(mPreviewBuilder.build(), null, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onConfigureFailed(CameraCaptureSession session) { } }, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } public boolean isOpen() { if (mCameraDevice == null) { return false; } else { return true; } } public void openCamera() { try { if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { mCameraManager.openCamera(mCameraID, mCameraCallback, mBackgroundHandler); } } catch (CameraAccessException e) { Log.i(LOG_TAG, e.getMessage()); } } public void closeCamera() { if (mCameraDevice != null) { mCameraDevice.close(); mCameraDevice = null; } } public void stopStreamingVideo() { if (mCameraDevice != null &amp; mCodec != null) { try { mSession.stopRepeating(); mSession.abortCaptures(); } catch (CameraAccessException e) { e.printStackTrace(); } mCodec.stop(); mCodec.release(); mEncoderSurface.release(); closeCamera(); } } } private void setUpMediaCodec() { File mFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), "test3.h264"); try { outputStream = new BufferedOutputStream(new FileOutputStream(mFile)); Log.i("Encoder", "outputStream initialized"); } catch (Exception e) { e.printStackTrace(); } try { mCodec = MediaCodec.createEncoderByType("video/avc"); // H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 3; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); } private class EncoderCallback extends MediaCodec.Callback { @Override public void onInputBufferAvailable(MediaCodec codec, int index) { } @Override public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) { outPutByteBuffer = mCodec.getOutputBuffer(index); byte[] outDate = new byte[info.size]; outPutByteBuffer.get(outDate); try { Log.i(LOG_TAG, " outDate.length : " + outDate.length); outputStream.write(outDate, 0, outDate.length);//     } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } mCodec.releaseOutputBuffer(index, false); } @Override public void onError(MediaCodec codec, MediaCodec.CodecException e) { Log.i(LOG_TAG, "Error: " + e); } @Override public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { Log.i(LOG_TAG, "encoder output format changed: " + format); } } @Override public void onPause() { if (myCameras[CAMERA1].isOpen()) { myCameras[CAMERA1].closeCamera(); } stopBackgroundThread(); super.onPause(); } @Override public void onResume() { super.onResume(); startBackgroundThread(); } }</span></span></code> </pre><br></div></div><br>  E n√£o se esque√ßa das permiss√µes no manifesto. <br><br><pre> <code class="java hljs"> &lt;uses-permission android:name=<span class="hljs-string"><span class="hljs-string">"android.permission.CAMERA"</span></span> /&gt; &lt;uses-permission android:name=<span class="hljs-string"><span class="hljs-string">"android.permission.INTERNET"</span></span>/&gt;</code> </pre><br>  Portanto, garantimos que o Media Codec esteja funcionando.  Mas us√°-lo para gravar v√≠deo em um arquivo √© algo sem esp√≠rito.  O Media Recorder pode lidar com essa tarefa muito melhor e ir√° adicionar som.  Portanto, jogaremos fora a parte do arquivo novamente e adicionaremos um bloco de c√≥digo para transmitir v√≠deo √† rede usando o protocolo udp.  Tamb√©m √© muito simples. <br><br>  Primeiro, inicializamos o servidor UDP praticamente. <br><br><pre> <code class="java hljs"> DatagramSocket udpSocket; String ip_address = <span class="hljs-string"><span class="hljs-string">"192.168.1.84"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      InetAddress address; int port = 40002; // ,      ‚Ä¶‚Ä¶.. try { udpSocket = new DatagramSocket(); Log.i(LOG_TAG, "  udp "); } catch ( SocketException e) { Log.i(LOG_TAG, "   udp "); } try { address = InetAddress.getByName(ip_address); Log.i(LOG_TAG, "  "); } catch (Exception e) {</span></span></code> </pre><br>  E no mesmo retorno de chamada, onde enviamos dados de prontid√£o para o fluxo do arquivo, agora os enviaremos na forma de datagramas para nossa rede dom√©stica (espero que todos tenham?) <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DatagramPacket packet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DatagramPacket(outDate, outDate.length, address, port); udpSocket.send(packet); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"   UDP "</span></span>); }</code> </pre><br><br>  Isso √© tudo? <br><br>  Parece, mas n√£o.  O aplicativo ser√° iluminado na inicializa√ß√£o.  Veja bem, o sistema n√£o gosta disso no fluxo principal, enviamos todos os tipos de pacotes de datagramas.  Mas n√£o h√° motivo para p√¢nico.  Em primeiro lugar, embora estejamos no segmento principal, ainda trabalhamos de forma ass√≠ncrona, ou seja, para acionar um retorno de chamada.  Em segundo lugar, o envio de pacotes udp √© o mesmo processo ass√≠ncrono.  Dizemos apenas ao sistema operacional que seria bom enviar um pacote, mas que confiamos totalmente nele nesse assunto.  Portanto, para que o Android n√£o se rebele, adicionaremos duas linhas no in√≠cio do programa: <br><br><pre> <code class="java hljs"> StrictMode.ThreadPolicy policy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy);</code> </pre><br>  Em geral, o seguinte pequeno e <s>elegante</s> programa de demonstra√ß√£o ser√° exibido: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.basicmediacodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.annotation.RequiresApi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.appcompat.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.core.content.ContextCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.Manifest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.ActivityInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.PackageManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.graphics.SurfaceTexture; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraAccessException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraCaptureSession; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraDevice; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CaptureRequest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodecInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Build; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Handler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.HandlerThread; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.StrictMode; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.util.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.Surface; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.TextureView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.View; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Button; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Toast; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.DatagramPacket; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.DatagramSocket; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.InetAddress; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.SocketException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String LOG_TAG = <span class="hljs-string"><span class="hljs-string">"myLogs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Surface surface = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; CameraService[] myCameras = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CameraManager mCameraManager = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CAMERA1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonOpenCamera1 = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonTStopStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TextureView mImageView = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HandlerThread mBackgroundThread; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Handler mBackgroundHandler = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MediaCodec mCodec = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Surface mEncoderSurface; // Surface      BufferedOutputStream outputStream; ByteBuffer outPutByteBuffer; DatagramSocket udpSocket; String ip_address = "192.168.1.84"; InetAddress address; int port = 40002; private void startBackgroundThread() { mBackgroundThread = new HandlerThread("CameraBackground"); mBackgroundThread.start(); mBackgroundHandler = new Handler(mBackgroundThread.getLooper()); } private void stopBackgroundThread() { mBackgroundThread.quitSafely(); try { mBackgroundThread.join(); mBackgroundThread = null; mBackgroundHandler = null; } catch (InterruptedException e) { e.printStackTrace(); } } @RequiresApi(api = Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setContentView(R.layout.activity_main); Log.d(LOG_TAG, " "); if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ) { requestPermissions(new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1); } mButtonOpenCamera1 = findViewById(R.id.button1); mButtonStreamVideo = findViewById(R.id.button2); mButtonTStopStreamVideo = findViewById(R.id.button3); mImageView = findViewById(R.id.textureView); mButtonOpenCamera1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { setUpMediaCodec();//    if (myCameras[CAMERA1] != null) {//   if (!myCameras[CAMERA1].isOpen()) myCameras[CAMERA1].openCamera(); } } }); mButtonStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { { //    } } }); mButtonTStopStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mCodec != null) { Toast.makeText(MainActivity.this, "  ", Toast.LENGTH_SHORT).show(); myCameras[CAMERA1].stopStreamingVideo(); } } }); try { udpSocket = new DatagramSocket(); Log.i(LOG_TAG, "  udp "); } catch ( SocketException e) { Log.i(LOG_TAG, "   udp "); } try { address = InetAddress.getByName(ip_address); Log.i(LOG_TAG, "  "); } catch (Exception e) { } mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); try { //      myCameras = new CameraService[mCameraManager.getCameraIdList().length]; for (String cameraID : mCameraManager.getCameraIdList()) { Log.i(LOG_TAG, "cameraID: " + cameraID); int id = Integer.parseInt(cameraID); //     myCameras[id] = new CameraService(mCameraManager, cameraID); } } catch (CameraAccessException e) { Log.e(LOG_TAG, e.getMessage()); e.printStackTrace(); } } public class CameraService { private String mCameraID; private CameraDevice mCameraDevice = null; private CameraCaptureSession mSession; private CaptureRequest.Builder mPreviewBuilder; public CameraService(CameraManager cameraManager, String cameraID) { mCameraManager = cameraManager; mCameraID = cameraID; } private CameraDevice.StateCallback mCameraCallback = new CameraDevice.StateCallback() { @Override public void onOpened(CameraDevice camera) { mCameraDevice = camera; Log.i(LOG_TAG, "Open camera with id:" + mCameraDevice.getId()); startCameraPreviewSession(); } @Override public void onDisconnected(CameraDevice camera) { mCameraDevice.close(); Log.i(LOG_TAG, "disconnect camera with id:" + mCameraDevice.getId()); mCameraDevice = null; } @Override public void onError(CameraDevice camera, int error) { Log.i(LOG_TAG, "error! camera id:" + camera.getId() + " error:" + error); } }; private void startCameraPreviewSession() { SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(320, 240); surface = new Surface(texture); try { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), new CameraCaptureSession.StateCallback() { @Override public void onConfigured(CameraCaptureSession session) { mSession = session; try { mSession.setRepeatingRequest(mPreviewBuilder.build(), null, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onConfigureFailed(CameraCaptureSession session) { } }, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } public boolean isOpen() { if (mCameraDevice == null) { return false; } else { return true; } } public void openCamera() { try { if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { mCameraManager.openCamera(mCameraID, mCameraCallback, mBackgroundHandler); } } catch (CameraAccessException e) { Log.i(LOG_TAG, e.getMessage()); } } public void closeCamera() { if (mCameraDevice != null) { mCameraDevice.close(); mCameraDevice = null; } } public void stopStreamingVideo() { if (mCameraDevice != null &amp; mCodec != null) { try { mSession.stopRepeating(); mSession.abortCaptures(); } catch (CameraAccessException e) { e.printStackTrace(); } mCodec.stop(); mCodec.release(); mEncoderSurface.release(); closeCamera(); } } } private void setUpMediaCodec() { try { mCodec = MediaCodec.createEncoderByType("video/avc"); // H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 3; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); } private class EncoderCallback extends MediaCodec.Callback { @Override public void onInputBufferAvailable(MediaCodec codec, int index) { } @Override public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) { outPutByteBuffer = mCodec.getOutputBuffer(index); byte[] outDate = new byte[info.size]; outPutByteBuffer.get(outDate); try { DatagramPacket packet = new DatagramPacket(outDate, outDate.length, address, port); udpSocket.send(packet); } catch (IOException e) { Log.i(LOG_TAG, "   UDP "); } mCodec.releaseOutputBuffer(index, false); } @Override public void onError(MediaCodec codec, MediaCodec.CodecException e) { Log.i(LOG_TAG, "Error: " + e); } @Override public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { Log.i(LOG_TAG, "encoder output format changed: " + format); } } @Override public void onPause() { if (myCameras[CAMERA1].isOpen()) { myCameras[CAMERA1].closeCamera(); } stopBackgroundThread(); super.onPause(); } @Override public void onResume() { super.onResume(); startBackgroundThread(); } }</span></span></code> </pre><br>  N√£o sei como os outros sabem, mas no Red Note 7 voc√™ pode ver como os kilobytes s√£o baixados no endere√ßo certo <br><br><img src="https://habrastorage.org/webt/9x/3q/gz/9x3qgzrctdcevzw5ym5zi6imgq8.png"><br><br>  E existem muitos soquetes udp, quanta largura de banda de rede √© suficiente.  O principal √© que existem endere√ßos onde.  Voc√™ ter√° uma transmiss√£o. <br><br><h4>  Agora vamos procurar o endere√ßo desejado no computador </h4><br>  Devo dizer que nem todo programa de computador √© capaz de absorver e digerir um fluxo de v√≠deo H264 atrav√©s de um √∫nico canal de UDP, sem qualquer informa√ß√£o adicional.  Mas alguns podem.  Este √©, por exemplo, o extremamente conhecido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reprodutor de</a> m√≠dia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VLC</a> .  Isso √© uma coisa t√£o legal que, se voc√™ come√ßar a descrever seus recursos, a partir do artigo, receber√° um livro inteiro.  Certamente voc√™ tem.  Caso contr√°rio, coloque-o. <br><br>  E, a julgar pela descri√ß√£o dos comandos, os pacotes udp podem digerir esse player. <br><br><pre> <code class="java hljs">URL syntax: file:<span class="hljs-comment"><span class="hljs-comment">///path/file Plain media file http://host[:port]/file HTTP URL ftp://host[:port]/file FTP URL mms://host[:port]/file MMS URL screen:// Screen capture dvd://[device] DVD device vcd://[device] VCD device cdda://[device] Audio CD device udp://[[&lt;source address&gt;]@[&lt;bind address&gt;][:&lt;bind port&gt;]]</span></span></code> </pre><br>  E todos esses endere√ßos de origem e endere√ßos de liga√ß√£o, em teoria, n√£o s√£o necess√°rios.  Somente a porta de escuta √© necess√°ria. <br><br><img src="https://habrastorage.org/webt/7-/kw/pi/7-kwpik08ayqmgvd2rta1sqjtae.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, no entanto, √© claro, voc√™ n√£o deve esquecer de permitir que essa porta escute (Malvar) </font></font><br><br><img src="https://habrastorage.org/webt/ix/9r/sj/ix9rsjovph-xzqgmosv_kgu-in4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ sabia que o Windows n√£o permite que voc√™ fa√ßa uma tela de impress√£o a partir do monitor de recursos? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou voc√™ pode desativar o firewall (n√£o o recomendo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, superando esses espinhos, lan√ßamos o VLC player com nosso endere√ßo e apreciamos a tela em branco. </font><font style="vertical-align: inherit;">Nenhum v√≠deo.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como assim? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E assim </font><font style="vertical-align: inherit;">Voc√™ provavelmente tem a vers√£o mais recente do VLC 3.08 Vetinari? </font><font style="vertical-align: inherit;">√â isso, nesta vers√£o do udp, √© declarada obsoleta e, al√©m disso, est√° fodida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, a l√≥gica dos desenvolvedores do jogador √© clara. </font><font style="vertical-align: inherit;">Atualmente, poucas pessoas precisam usar o canal udp bare porque:</font></font><br><br><ul><li>       .                 ,    .       . </li><li>     </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, as pessoas normais, √© claro, usam protocolos de alto n√≠vel RTP e outros. Ou seja, nos dedos - voc√™ escreve um servidor que usa o udp (para velocidade) de qualquer maneira, mas ao mesmo tempo troca informa√ß√µes de controle com o cliente para quem ele transmite o v√≠deo. Qual √© a sua largura de banda, √© necess√°rio aumentar ou diminuir o cache dos dados, que detalhes da imagem s√£o ideais agora e assim por diante. Novamente, √†s vezes tamb√©m √© necess√°rio som. E ele precisa, voc√™ sabe, de sincroniza√ß√£o com o v√≠deo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olha, os caras de Odnoklassniki at√© tiveram que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arquivar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">protocolo</font></a><font style="vertical-align: inherit;"> para transmiss√£o. Mas suas tarefas, √© claro, s√£o muito mais importantes - enviar v√≠deos com gatos para dezenas de milh√µes de donas de casa em todo o mundo. L√° voc√™ n√£o gerenciar√° um canal udp.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas, de alguma forma, estamos tristes em escrever nosso servidor RTP no Android. Provavelmente, voc√™ pode at√© achar pronto e at√© gratuito, mas vamos tentar n√£o complicar as entidades por enquanto. Basta levar a vers√£o do VLC player onde o streaming de udp ainda funcionava. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, fa√ßa o download aqui do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLC 2.2.6 Umbrella</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Install, em vez de ou ao lado do antigo (ou seja, novo VLC), como desejar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Come√ßamos e vemos uma tela em branco novamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E tudo isso √© porque obviamente n√£o configuramos o uso do codec H264. Portanto, o VLC poderia selecionar o codec automaticamente se tivesse que lidar com o arquivo (nas configura√ß√µes inicialmente, a sele√ß√£o autom√°tica foi especificada). Mas eles lan√ßam um fluxo de bytes em um √∫nico canal e h√° dezenas de codecs que o VLC suporta. Como ele pode descobrir qual aplicar?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, instalamos o codec √† for√ßa. </font></font><br><br><img src="https://habrastorage.org/webt/jq/f5/er/jqf5ercz20oa2hxzlbeqmokqgbs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E agora gostamos da transmiss√£o de v√≠deo "ao vivo". </font><font style="vertical-align: inherit;">A √∫nica coisa √© que, por algum motivo, est√° do lado dele, mas isso j√° √© facilmente corrigido nas configura√ß√µes do player de v√≠deo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E voc√™ pode simplesmente iniciar o player na linha de comando com esta chave:</font></font><br><br><pre> <code class="java hljs">C:\Program Files\VideoLAN\VLC\vlc udp:<span class="hljs-comment"><span class="hljs-comment">//@:40002 --demux h264 --video-filter=transform --transform-type=90</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E ele se decodificar√° e girar√°. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/IbN9eh1uyv4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, o streaming funciona. </font><font style="vertical-align: inherit;">Resta apenas integr√°-lo √† janela JAVA do aplicativo de controle do rob√¥. </font><font style="vertical-align: inherit;">Lidaremos com isso muito em breve na parte final.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473036/">https://habr.com/ru/post/pt473036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473026/index.html">Om-yum-yum e valida√ß√£o de dados</a></li>
<li><a href="../pt473028/index.html">Na R√∫ssia come√ßou a importar res√≠duos radioativos da Europa? Resolvido</a></li>
<li><a href="../pt473030/index.html">Calculamos potenciais bots "maus" e os bloqueamos por IP</a></li>
<li><a href="../pt473032/index.html">"A esperan√ßa √© uma p√©ssima estrat√©gia." SRE intensivo em Moscou, 3-5 de fevereiro</a></li>
<li><a href="../pt473034/index.html">Como se sentar timlid</a></li>
<li><a href="../pt473038/index.html">C√≥digo morse de 8 bits</a></li>
<li><a href="../pt473042/index.html">Pr√≥s e contras do Django</a></li>
<li><a href="../pt473044/index.html">Como criar capturas de tela eficazes para um aplicativo na App Store</a></li>
<li><a href="../pt473050/index.html">A AMD obriga a Intel a reduzir os pre√ßos n√£o apenas em novos, mas tamb√©m em modelos de CPU mais antigos. Este √© o come√ßo de outra guerra de pre√ßos</a></li>
<li><a href="../pt473054/index.html">WorldSkills final, desenvolvimento de solu√ß√µes de TI para empresas - o que √©, como era e por que os programadores da 1C venceram l√°</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>