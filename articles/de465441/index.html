<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏿 🌵 👨🏿‍🏫 LuaVela: Lua 5.1-Implementierung basierend auf LuaJIT 2.0 💼 😚 🤙🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit haben wir eine Veröffentlichung angekündigt und unter der MIT-Lizenz den Quellcode von LuaVela eröffnet - eine Implementierung von Lu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LuaVela: Lua 5.1-Implementierung basierend auf LuaJIT 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iponweb/blog/465441/">  Vor einiger Zeit haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> Veröffentlichung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angekündigt</a> und unter der MIT-Lizenz den Quellcode von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LuaVela eröffnet</a> - eine Implementierung von Lua 5.1, basierend auf LuaJIT 2.0.  Wir haben 2015 damit begonnen, daran zu arbeiten, und Anfang 2017 wurde es in mehr als 95% der Projekte des Unternehmens verwendet.  Jetzt möchte ich auf den zurückgelegten Weg zurückblicken.  Welche Umstände haben uns veranlasst, eine eigene Implementierung einer Programmiersprache zu entwickeln?  Auf welche Probleme sind wir gestoßen und wie haben wir sie gelöst?  Wie unterscheidet sich LuaVela von anderen LuaJIT-Gabeln? <br><a name="habracut"></a><br><h1>  Hintergrund </h1><br>  Dieser Abschnitt basiert auf unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> über HighLoad ++.  Seit 2008 nutzen wir Lua aktiv, um die Geschäftslogik unserer Produkte zu schreiben.  Zuerst war es Vanille Lua und seit 2009 - LuaJIT.  Das RTB-Protokoll legte einen engen Rahmen für die Verarbeitung der Anforderung fest, sodass der Übergang zu einer schnelleren Implementierung der Sprache eine logische und ab einem gewissen Punkt notwendige Lösung war. <br><br>  Im Laufe der Zeit stellten wir fest, dass die LuaJIT-Architektur gewisse Einschränkungen aufweist.  Das Wichtigste für uns war, dass LuaJIT 2.0 ausschließlich 32-Bit-Zeiger verwendet.  Dies führte zu einer Situation, in der unter 64-Bit-Linux die Größe des virtuellen Adressraums des Prozessspeichers auf ein Gigabyte begrenzt wurde (in späteren Versionen des Linux-Kernels wurde diese Grenze auf zwei Gigabyte angehoben): <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* MAP_32BIT    4  x86-64: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr = mmap((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)MMAP_REGION_START, size, MMAP_PROT, MAP_32BIT | MMAP_FLAGS, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Diese Einschränkung wurde zu einem großen Problem - bis 2015 reichten 1-2 Gigabyte Speicher für viele Projekte nicht mehr aus, um die Daten zu laden, mit denen die Logik arbeitete.  Es ist anzumerken, dass jede Instanz der virtuellen Lua-Maschine Single-Threaded ist und nicht weiß, wie Daten mit anderen Instanzen geteilt werden sollen. Dies bedeutet, dass in der Praxis jede virtuelle Maschine eine Speichergröße von nicht mehr als 2 GB / n beanspruchen kann, wobei n die Anzahl der Worker-Threads unseres Servers ist Anwendungen. <br><br>  Wir haben verschiedene Lösungen für das Problem durchlaufen: Wir haben die Anzahl der Threads in unserem Anwendungsserver reduziert, versucht, den Zugriff auf Daten über LuaJIT FFI zu organisieren, und den Übergang zu LuaJIT 2.1 getestet.  Leider waren alle diese Optionen entweder wirtschaftlich nachteilig oder auf lange Sicht nicht gut skalierbar.  Das einzige, was uns noch blieb, war, ein Risiko einzugehen und LuaJIT zu teilen.  In diesem Moment haben wir Entscheidungen getroffen, die das Schicksal des Projekts maßgeblich bestimmt haben. <br><br>  Zunächst beschlossen wir sofort, keine Änderungen an der Syntax und Semantik der Sprache vorzunehmen, und konzentrierten uns darauf, die architektonischen Einschränkungen von LuaJIT zu beseitigen, die sich als Problem für das Unternehmen herausstellten.  Natürlich haben wir im Verlauf des Projekts begonnen, Erweiterungen hinzuzufügen (wir werden dies weiter unten diskutieren) - aber wir haben alle neuen APIs aus der Standard-Sprachbibliothek isoliert. <br><br>  Darüber hinaus haben wir plattformübergreifend aufgegeben und nur Linux x86-64 unterstützt, unsere einzige Produktionsplattform.  Leider hatten wir nicht genügend Ressourcen, um die gigantische Menge an Änderungen, die wir an der Plattform vornehmen würden, angemessen zu testen. <br><br><h1>  Ein kurzer Blick unter die Motorhaube der Plattform </h1><br>  Mal sehen, woher die Beschränkung der Zeigergröße kommt.  Zunächst ist die Typennummer in Lua 5.1 (mit einigen geringfügigen Einschränkungen) der C-Typ double, der wiederum dem vom IEEE 754-Standard definierten Typ mit doppelter Genauigkeit entspricht. Bei der Codierung dieses 64-Bit-Typs wird der Wertebereich für die Darstellung hervorgehoben NaN.  Insbesondere, wie ein Wert im Bereich [0xFFF8000000000000;  0xFFFFFFFFFFFFFFFF]. <br><br>  Auf diese Weise können wir entweder eine „echte“ Zahl mit doppelter Genauigkeit oder eine Entität in einen einzelnen 64-Bit-Wert packen, die aus Sicht des Typs double als NaN interpretiert wird, und aus Sicht unserer Plattform ist sie etwas aussagekräftiger - zum Beispiel. durch den Objekttyp (hohe 32 Bit) und einen Zeiger auf seinen Inhalt (niedrige 32 Bit): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> TValue { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> type; } o; };</code> </pre><br>  Diese Technik wird manchmal als NaN-Tagging (oder NaN-Boxing) bezeichnet, und TValue beschreibt im Wesentlichen, wie LuaJIT variable Werte in Lua darstellt.  TValue hat auch eine dritte Hypostase, die zum Speichern eines Funktionszeigers und von Informationen zum Abwickeln des Lua-Stapels verwendet wird, dh letztendlich sieht die Datenstruktur folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> TValue { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> type; } o; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">frame</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *func; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> link; } f; };</code> </pre><br>  Das Feld frame.link in der obigen Definition ist vom Typ uintptr_t, da es in einigen Fällen einen Zeiger speichert und in anderen eine Ganzzahl ist.  Das Ergebnis ist eine sehr kompakte Darstellung des Stapels der virtuellen Maschine - tatsächlich handelt es sich um ein TValue-Array, und jedes Element des Arrays wird situativ entweder als Zahl, dann als typisierter Zeiger auf ein Objekt oder als Daten über den Rahmen des Lua-Stapels interpretiert. <br><br>  Schauen wir uns ein Beispiel an.  Stellen Sie sich vor, wir haben mit LuaJIT diesen Lua-Code begonnen und einen Haltepunkt innerhalb der Druckfunktion festgelegt: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> .. x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span> foo(b) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> bar({}, <span class="hljs-string"><span class="hljs-string">"Lua"</span></span>)</code> </pre><br>  Der Lua-Stapel sieht an dieser Stelle folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/1n/av/hn/1navhnm8vbz-inawirkvewxppme.png" alt="Lua-Stack mit LuaJIT 2.0"><br><br>  Und alles wäre in Ordnung, aber diese Technik beginnt zu scheitern, sobald wir versuchen, auf x86-64 zu starten.  Wenn wir im Kompatibilitätsmodus für 32-Bit-Anwendungen ausgeführt werden, lehnen wir die oben bereits erwähnte mmap-Einschränkung ab.  Und 64-Bit-Zeiger funktionieren überhaupt nicht sofort.  Was zu tun ist?  Um das Problem zu beheben, musste ich: <br><br><ol><li>  Erweitern Sie TValue von 64 auf 128 Bit: Auf diese Weise erhalten wir auf einer 64-Bit-Plattform eine „ehrliche“ Lücke *. </li><li>  Korrigieren Sie den Code der virtuellen Maschine entsprechend. </li><li>  Nehmen Sie Änderungen am JIT-Compiler vor. </li></ol><br>  Das Gesamtvolumen der Änderungen erwies sich als sehr bedeutsam und entfremdete uns ziemlich vom ursprünglichen LuaJIT.  Es ist erwähnenswert, dass die TValue-Erweiterung nicht die einzige Möglichkeit ist, das Problem zu lösen.  In LuaJIT 2.1 haben wir den LJ_GC64-Modus implementiert.  Peter Cawley, der einen enormen Beitrag zur Entwicklung dieser Arbeitsweise geleistet hat, las bei einem Treffen in London darüber.  Nun, im Fall von LuaVela sieht der Stapel für dasselbe Beispiel folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/ar/rj/yv/arrjyvsnfyixhd8haufn95nhgu8.png" alt="Lua-Stapel bei Verwendung von LuaVela"><br><br><h1>  Erste Erfolge und Stabilisierung des Projekts </h1><br>  Nach Monaten aktiver Entwicklung ist es Zeit, LuaVela im Kampf auszuprobieren.  Als Experiment haben wir die problematischsten Projekte in Bezug auf den Speicherverbrauch ausgewählt: Die Datenmenge, mit der sie arbeiten mussten, überstieg offensichtlich 1 Gigabyte, sodass sie gezwungen waren, verschiedene Problemumgehungen zu verwenden.  Die ersten Ergebnisse waren ermutigend: LuaVela war stabil und zeigte eine bessere Leistung im Vergleich zu der in denselben Projekten verwendeten LuaJIT-Konfiguration. <br><br>  Gleichzeitig stellte sich die Frage nach dem Testen.  Glücklicherweise mussten wir nicht bei Null anfangen, da wir vom ersten Tag der Entwicklung an zusätzlich zu den Staging-Servern Folgendes zur Verfügung hatten: <br><br><ul><li>  Funktions- und Integrationstests eines Anwendungsservers, der die Geschäftslogik aller Unternehmensprojekte ausführt. </li><li>  Tests einzelner Projekte. </li></ul><br>  Wie die Praxis gezeigt hat, reichten diese Ressourcen völlig aus, um das Projekt zu debuggen und auf einen stabilen Mindestzustand zu bringen (sie haben eine Entwickler-Assembly durchgeführt - auf Staging ausgerollt - es funktioniert und stürzt nicht ab).  Andererseits war ein solches Testen durch andere Projekte auf lange Sicht völlig ungeeignet: Ein Projekt mit einer solchen Komplexität wie der Implementierung einer Programmiersprache kann keine eigenen Tests haben.  Darüber hinaus erschwerte das Fehlen von Tests direkt im Projekt die Suche und Korrektur von Fehlern rein technisch. <br><br>  In einer idealen Welt wollten wir nicht nur unsere Implementierung testen, sondern auch eine Reihe von Tests durchführen, mit denen wir sie anhand der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semantik der Sprache</a> validieren können.  Leider erwartete uns in dieser Angelegenheit eine gewisse Enttäuschung.  Trotz der Tatsache, dass die Lua-Community bereitwillig Gabeln bestehender Implementierungen erstellt, fehlten bis vor kurzem ähnliche Validierungstests.  Die Situation änderte sich zum Besseren, als François Perrad Ende 2018 das Projekt lua-Harness <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ankündigte</a> . <br><br>  Am Ende haben wir das Testproblem geschlossen, indem wir die vollständigsten und repräsentativsten Testsuiten im Lua-Ökosystem in unser Repository integriert haben: <br><br><ul><li>  <a href="">Tests,</a> die von den Erstellern der Sprache für die Implementierung von Lua 5.1 geschrieben wurden. </li><li>  Von der Community bereitgestellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests</a> des LuaJIT-Autors Mike Pall. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lua Geschirr</a> </li><li>  Eine Teilmenge der vom CERN entwickelten Tests des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAD-</a> Projekts. </li><li>  Zwei Testreihen, die wir in IPONWEB erstellt haben und die bis jetzt noch aufgefüllt werden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> für Funktionstests der Plattform, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cmocka-</a> Framework zum Testen der C-API und alles, was auf Lua-Code-Ebene nicht getestet werden kann. </li></ul><br>  Die Einführung jeder Testreihe ermöglichte es uns, 2-3 kritische Fehler zu erkennen und zu korrigieren - daher ist es offensichtlich, dass sich unsere Bemühungen gelohnt haben.  Obwohl das Thema des Testens von Sprachlaufzeiten und Compilern (sowohl statisch als auch dynamisch) wirklich unbegrenzt ist, glauben wir, dass wir eine ziemlich solide Grundlage für eine stabile Entwicklung des Projekts gelegt haben.  Wir haben zweimal auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lua in Moskau 2017</a> und auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++ 2018</a> über die Probleme beim Testen unserer eigenen Implementierung von Lua gesprochen (einschließlich Themen wie Arbeiten mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testbänken</a> und Postmortem-Debugging). Jeder, der sich für Details interessiert, kann sich ein Video dieser Berichte ansehen.  Schauen Sie sich natürlich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testverzeichnis</a> in unserem Repository an. <br><br><h1>  Neue Funktionen </h1><br>  So verfügten wir über eine stabile Implementierung von Lua 5.1 für Linux x86-64, die von den Kräften eines kleinen Teams entwickelt wurde, das das LuaJIT-Erbe und das gesammelte Fachwissen schrittweise „beherrschte“.  Unter solchen Bedingungen wurde der Wunsch, die Plattform zu erweitern und Funktionen hinzuzufügen, die weder in Vanilla Lua noch in LuaJIT enthalten sind, uns aber bei der Lösung anderer dringender Probleme helfen würden, ganz natürlich. <br><br>  Eine detaillierte Beschreibung aller Erweiterungen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> im RST-Format (verwenden Sie cmake. &amp;&amp; make docs, um eine lokale Kopie im HTML-Format zu erstellen).  Eine vollständige Beschreibung der Lua-API-Erweiterungen finden Sie <a href="">unter diesem Link</a> und der C-API unter <a href="">diesem Link</a> .  Leider ist es in einem Übersichtsartikel unmöglich, über alles zu sprechen. Hier ist eine Liste der wichtigsten Funktionen: <br><br><ul><li>  DataState - Die Möglichkeit, den gemeinsamen Zugriff auf ein Objekt von mehreren unabhängigen Instanzen virtueller Lua-Maschinen aus zu organisieren. </li><li>  Die Möglichkeit, <a href="">eine Zeitüberschreitung für Coroutine festzulegen</a> und die Ausführung derjenigen zu unterbrechen, die länger als diese ausgeführt werden. </li><li>  Eine Reihe von JIT-Compiler-Optimierungen, mit denen die exponentielle Zunahme der Anzahl der Traces beim Kopieren von Daten zwischen Objekten bekämpft werden soll. Wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> auf HighLoad ++ 2017 darüber gesprochen, aber vor einigen Monaten hatten wir neue Arbeitsideen, die noch dokumentiert werden müssen. </li><li>  Neues Toolkit: Sampling Profiler.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dumpanalyze</a> Compiler Debug Output Analyzer usw. </li></ul><br>  Jede dieser Funktionen verdient einen eigenen Artikel - schreiben Sie in die Kommentare, über welche Sie mehr lesen möchten. <br><br>  Hier möchte ich etwas mehr darüber sprechen, wie wir die Belastung des Garbage Collectors reduziert haben.  <a href="">Durch Versiegeln</a> können Sie ein Objekt für den Garbage Collector unzugänglich machen.  In unserem typischen Projekt handelt es sich bei den meisten Daten (bis zu 80%) in der virtuellen Lua-Maschine bereits um Geschäftsregeln, bei denen es sich um eine komplexe Lua-Tabelle handelt.  Die Lebensdauer dieser Tabelle (Minuten) ist viel länger als die Lebensdauer der verarbeiteten Anforderungen (zehn Millisekunden), und die darin enthaltenen Daten ändern sich während der Abfrageverarbeitung nicht.  In einer solchen Situation macht es keinen Sinn, den Garbage Collector zu zwingen, diese riesige Datenstruktur immer wieder zu durchlaufen.  Dazu "versiegeln" wir das Objekt rekursiv und ordnen die Daten so um, dass der Garbage Collector weder das "versiegelte" Objekt noch dessen Inhalt erreicht.  In Vanilla Lua 5.4 wird dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gelöst, indem</a> Generationen von Objekten in der Speicherbereinigung für Generationen unterstützt werden. <br><br>  Es ist wichtig zu beachten, dass „versiegelte“ Objekte nicht beschreibbar sein dürfen.  Die Nichtbeachtung dieser Invariante führt zum Auftreten baumelnder Zeiger: Beispielsweise bezieht sich ein „versiegeltes“ Objekt auf ein reguläres Objekt, und ein Müllsammler, der ein „versiegeltes“ Objekt überspringt, wenn er einen Haufen umrundet, überspringt ein reguläres Objekt - mit dem Unterschied, dass ein „versiegeltes“ Objekt nicht freigegeben werden kann. und das übliche kann man.  Nachdem wir die Unterstützung für diese Invariante implementiert haben, erhalten wir im Wesentlichen kostenlose <a href="">Immunitätsunterstützung für</a> Objekte, deren Fehlen in Lua häufig beklagt wird.  Ich betone, dass unveränderliche und „versiegelte“ Objekte nicht dasselbe sind.  Die zweite Eigenschaft impliziert die erste, aber nicht umgekehrt. <br><br>  Ich stelle auch fest, dass in Lua 5.1 die Immunität mithilfe von Metatables implementiert werden kann - die Lösung funktioniert recht gut, ist jedoch in Bezug auf die Leistung nicht die rentabelste.  Weitere Informationen zu „Versiegelung“, Immunität und deren Verwendung im Alltag finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Bericht. <br><br><h1>  Schlussfolgerungen </h1><br>  Im Moment sind wir mit der Stabilität und den Möglichkeiten für unsere Implementierung zufrieden.  Und obwohl unsere Implementierung aufgrund der anfänglichen Einschränkungen Vanilla Lua und LuaJIT in Bezug auf die Portabilität erheblich unterlegen ist, löst sie viele unserer Probleme - wir hoffen, dass diese Lösungen für andere nützlich sind. <br><br>  Auch wenn LuaVela nicht für die Produktion geeignet ist, laden wir Sie ein, es als Einstiegspunkt zu verwenden, um zu verstehen, wie LuaJIT oder seine Gabel funktionieren.  Neben der Lösung von Problemen und der Erweiterung der Funktionalität haben wir im Laufe der Jahre einen wesentlichen Teil der Codebasis überarbeitet und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schulungsartikel</a> zur internen Struktur des Projekts verfasst - viele davon gelten nicht nur für LuaVela, sondern auch für LuaJIT. <br><br>  Vielen Dank für Ihre Aufmerksamkeit, wir warten auf Pull-Anfragen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465441/">https://habr.com/ru/post/de465441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465429/index.html">Dennoch ist C eine einfache Sprache</a></li>
<li><a href="../de465431/index.html">Analyse des RPC-Quellcodes des Apache Dubbo-Frameworks mit dem statischen Analysator PVS-Studio</a></li>
<li><a href="../de465433/index.html">Arbeitsroboter - glücklicher Mann</a></li>
<li><a href="../de465435/index.html">Welche Distribution ist für Ihr eingebettetes System besser geeignet?</a></li>
<li><a href="../de465437/index.html">Warum ich mich geweigert habe, in AWS zu arbeiten</a></li>
<li><a href="../de465445/index.html">Hinweise des IoT-Anbieters. Impulsausgangsfluch</a></li>
<li><a href="../de465449/index.html">Wie die Probleme von Mail.ru und dem FSB durch den Ruf von Pavel Durov und das Vertrauen in Telegram geschmiedet wurden</a></li>
<li><a href="../de465453/index.html">3. September - CTO-Tag in St. Petersburg</a></li>
<li><a href="../de465455/index.html">Arbeiten Sie mit Vorfällen, verbessern Sie die Reaktion auf Vorfälle und den Wert der technischen Schulden. Backend United 4 Mitap-Materialien: Okroshka</a></li>
<li><a href="../de465457/index.html">Über Züchterrechte an den Fingern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>