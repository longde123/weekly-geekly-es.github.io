<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕥 🚽 📝 Dari Pemula hingga Ikon Gaya: bagaimana kami membuat penghargaan di 2GIS 👩🏾‍🎓 🤴🏽 🕐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap hari, pengguna 2GIS membantu kami menjaga akurasi data: mereka melaporkan perusahaan baru, menambahkan acara lalu lintas, mengunggah foto, dan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari Pemula hingga Ikon Gaya: bagaimana kami membuat penghargaan di 2GIS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/470942/"><img src="https://habrastorage.org/webt/kl/9g/ja/kl9gjaqo9dmcbsimconigs2pnxo.png"><br><br>  Setiap hari, pengguna 2GIS membantu kami menjaga akurasi data: mereka melaporkan perusahaan baru, menambahkan acara lalu lintas, mengunggah foto, dan menulis ulasan.  Sebelumnya, kami hanya bisa berterima kasih kepada mereka dengan kata-kata atau mengatur hadiah.  Namun seiring waktu, kata-kata dilupakan, dan tidak semua orang mendapat hadiah.  Oleh karena itu, kami memutuskan untuk memastikan bahwa semua orang yang peduli tentang 2GIS melihat kontribusi mereka terhadap produk dan terima kasih kami untuk ini. <br><br>  Jadi ada penghargaan - medali virtual yang kami dapatkan untuk berbagai jenis tugas: unggah foto ke kartu kafe, tulis ulasan tentang teater, tentukan jam kerja organisasi, dan sebagainya.  Pengguna melihat hadiah yang diperoleh di profil 2GIS pribadi mereka dan pada tab "My 2GIS" di aplikasi seluler.  Di sana kami menunjukkan berapa banyak yang tersisa hingga pencapaian berikutnya. <br><br>  Untuk mengimplementasikan fitur ini, kami mempelajari cara memproses aliran peristiwa dengan volume 500 ribu catatan per jam (di tempat hingga 50 ribu catatan per detik) dan menganalisis data dari beberapa layanan.  Dan juga - mereka menambahkan sedikit metaprogramming untuk menyederhanakan konfigurasi ketika mengembangkan penghargaan baru. <br><br>  Bersama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Rapter</a> , kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">akan</a> memberi tahu Anda apa yang ada di bawah tenda proses penghargaan. <br><a name="habracut"></a><br><h2>  Konsep </h2><br>  Untuk memahami kompleksitas fitur, Anda perlu memahami bagaimana masalah teknis terdengar.  Kemudian - pertimbangkan gagasan implementasi dan skema umum komponen sistem.  Inilah yang akan kita lakukan di bagian ini. <br><br><h3>  Persyaratan untuk Abstrak </h3><br>  Persyaratan - hal yang agak membosankan, jadi kami tidak akan melukis semua nuansa, kami akan berkonsentrasi pada hal-hal yang paling penting: <br><br><ul><li>  penghargaan hanya diberikan kepada pengguna yang berwenang; </li><li>  memperbarui kemajuan pada hadiah harus secepat mungkin; </li><li>  hadiah - hasil dari pengguna yang melakukan serangkaian tindakan dalam produk: mengunggah foto, menulis ulasan, menemukan arah, dll. Ada banyak sumber data. </li></ul><br><h3>  Ide arsitektur </h3><br>  Gagasan implementasi tidak terlalu rumit.  Itu dapat diungkapkan secara tesis: <br><br><ul><li>  penghargaan terdiri dari tugas-tugas, yang hasilnya digabungkan sesuai dengan formula yang ditentukan saat mengkonfigurasi penghargaan; </li><li>  tugas menanggapi peristiwa tentang tindakan pengguna yang datang dari luar, memfilternya dan mendaftarkan perubahan yang sedang berlangsung dalam bentuk penghitung; </li><li>  "Peristiwa eksternal" dihasilkan oleh sistem master (foto, umpan balik, layanan penyempurnaan, dll.) Atau layanan tambahan yang mengubah atau memfilter aliran acara yang sudah ada; </li><li>  pemrosesan peristiwa terjadi secara tidak sinkron dan dapat dihentikan kapan saja jika perlu; </li><li>  pengguna melihat status penghargaannya saat ini; </li><li>  yang lainnya adalah detail ... </li></ul><br><h3>  Entitas Kunci </h3><br>  Diagram di bawah ini menunjukkan entitas utama dari area subjek dan hubungannya: <br><br><img src="https://habrastorage.org/webt/vi/ya/59/viya59qa7bnnad3hogutbunyds4.png"><br><br>  Dua zona dibedakan dalam diagram: <br><br><ul><li>  Skema - zona untuk menggambarkan struktur penghargaan dan aturan untuk akrualnya; </li><li>  Data - Area penghargaan untuk pengguna tertentu dan data yang terkait dengan status mereka saat ini. </li></ul><br>  Entitas dalam diagram: <br><br><ul><li>  Mencapai - informasi tentang penghargaan yang dapat diperoleh.  Termasuk meta-informasi dan deskripsi cara menggabungkan hasil tugas - strategi. </li><li>  Objektif - tugas, kondisi yang harus dipenuhi untuk maju untuk menerima penghargaan. </li><li>  UserAchieve - kondisi hadiah saat ini untuk pengguna tertentu. </li><li>  UserObjective - keadaan saat ini dari pekerjaan hadiah pengguna. </li><li>  Pengguna - informasi tentang pengguna, yang diperlukan untuk pemberitahuan dan pemahaman tentang statusnya saat ini (hadiah jarak jauh dan banned tidak diperlukan). </li><li>  ProcessingLog - log akrual untuk tugas.  Berisi informasi tentang bagaimana suatu tindakan spesifik memengaruhi kemajuan penugasan. </li><li>  Peristiwa - informasi minimum yang diperlukan tentang suatu peristiwa yang entah bagaimana mempengaruhi kemajuan tugas pengguna. </li></ul><br><h3>  Struktur layanan </h3><br>  Sekarang pertimbangkan komponen utama dari layanan dan dependensinya: <br><br><img src="https://habrastorage.org/webt/qi/dp/k_/qidpk_jo7rqnh2x5dywk0sg0ij4.png"><br><br><ul><li>  Event Bus - sebuah bus acara yang dapat digunakan untuk menyelesaikan tugas.  Kami menggunakan Apache Kafka. </li><li>  Master dan Slave DB adalah gudang data utama.  Dalam hal ini, cluster PostgreSQL. </li><li>  ConsumingWorkers - penangan acara bus.  Tugas utama adalah membaca peristiwa dari sumber tertentu (foto, ulasan, dll.), Menerapkannya pada tugas pengguna dan menyimpan hasilnya. </li><li>  AchievesWorker - menceritakan kemajuan penghargaan pengguna sesuai dengan status tugas. </li><li>  NotificationWorkers - seperangkat penangan untuk penjadwalan dan mengirim pemberitahuan tentang menerima penghargaan, pengumuman kemungkinan pencapaian baru, dll. </li><li>  API Publik - antarmuka REST publik untuk aplikasi Web dan seluler. </li><li>  API Pribadi - antarmuka REST untuk panel admin, yang membantu dalam penyelidikan insiden dan dukungan layanan.  Ini tersedia untuk pengembang dan tim pendukung. </li></ul><br>  Masing-masing komponen terisolasi dalam hal logika dan bidang tanggung jawab, yang menghindari integrasi dan deadlock yang tidak perlu saat memodifikasi data.  Di bawah ini kami menganggap hanya sebagian dari skema yang terkait dengan pemrosesan acara dan mengubahnya menjadi hadiah. <br><br><h2>  Penanganan acara </h2><br><h3>  Konten </h3><br>  Hadiah utamanya adalah layanan agregasi data.  Setiap sistem master menghasilkan beberapa jenis peristiwa.  Sebagai aturan, setiap jenis peristiwa terkait erat dengan keadaan konten, model statusnya.  Jadi, foto dapat dimoderasi, dihapus, diblokir, disembunyikan, atau aktif.  Semua ini adalah peristiwa yang berbeda yang ditangani oleh pekerja terpisah yang berspesialisasi dalam sumber tertentu.  Saat ini, ada interaksi dengan sumber-sumber berikut (sistem master): <br><br><ul><li>  Foto - menghasilkan berbagai peristiwa yang berhubungan dengan operasi yang dilakukan oleh pengguna pada foto. </li><li>  Ulasan - acara yang terkait dengan operasi pada ulasan pengguna. </li><li>  Datafeedback - peristiwa yang terkait dengan operasi penyempurnaan.  Klarifikasi adalah perubahan informasi tentang suatu objek pada peta, baik itu perusahaan atau monumen. </li><li>  Pemeriksaan - peristiwa yang berhubungan dengan aplikasi Pemeriksaan 2GIS. </li><li>  BSS adalah peristiwa analitik yang menghasilkan aplikasi 2GIS.  Misalnya, pembukaan perusahaan tertentu, perjalanan dengan navigator, dll. </li></ul><br><img src="https://habrastorage.org/webt/vg/xy/zb/vgxyzbizbytl_up3fllx5epasue.png"><br><br>  Peristiwa yang dihasilkan oleh sistem master masuk ke dalam topik Kafka dalam urutan mengubah status mereka, yang memungkinkan untuk memindahkan progres penghargaan bagi pengguna tidak hanya maju, tetapi juga mengembalikannya.  Misalnya, jika foto itu dalam status "aktif", dan karena alasan tertentu memperoleh status "diblokir", kemajuan penghargaan harus berubah ke bawah.  Kemajuan penghargaan adalah interpretasi dari objek internal yang disebut penghitung konten. <br><br>  Penghitung dapat bervariasi untuk data yang berbeda.  Misalnya, untuk acara tentang foto, mereka adalah sebagai berikut: jumlah yang disetujui, jumlah moderasi, jumlah diblokir, dan untuk acara pembukaan kartu, Anda hanya perlu mempertimbangkan jumlah kartu yang dibuka oleh pengguna.  Berdasarkan nilai saat ini dari penghitung konten, untuk pengguna tertentu, dalam kerangka penghargaan tertentu, jawaban atas pertanyaan berikut ditentukan: <br><br><ul><li>  Sudahkah penghargaan dimulai? </li><li>  apa kemajuannya </li><li>  Apakah hadiah sudah selesai? </li></ul><br><h3>  Filter dan Aturan </h3><br>  Penghitung pekerjaan dari penghargaan tertentu diubah hanya jika suatu peristiwa telah tiba dengan jenis konten yang diinginkan, serta dengan data yang diperlukan yang diperlukan untuk menerima penghargaan. <br><br>  Untuk melewati hanya konten yang sesuai untuk penghargaan, kami menjalankan setiap acara melalui serangkaian filter dan aturan. <br><br>  Filter adalah batasan tertentu yang dikenakan pada konten.  Dia hanya peduli dengan menjawab pertanyaan: "Apakah acara baru cocok dengan kondisi ini atau tidak?" <br>  Aturan adalah filter khusus, yang tujuannya adalah untuk mengatakan: "Jika suatu peristiwa cocok dengan kondisi tersebut, lalu bagaimana seharusnya penghitung berubah?"  Aturan termasuk algoritma untuk mengubah penghitung.  Setiap penghargaan hanya berisi satu aturan. <br><br>  Implementasi filter dan aturan ada dalam kode proyek, dan deskripsi filter (aturan) mana yang termasuk penghargaan tertentu ada di database dalam format JSON.  Kami tidak langsung mengambil keputusan seperti itu.  Awalnya, filter dan aturan tidak dapat diatur menggunakan konfigurasi melalui database, penghargaan sepenuhnya dijelaskan dalam kode, hanya pengenalnya yang disimpan dalam tabel.  Keputusan ini memberikan sejumlah kelemahan signifikan: <br><br><ul><li>  Masalah mendukung beberapa lingkungan.  Jika Anda ingin meluncurkan satu status dari daftar penghargaan ke lingkungan pengujian, dan mengirim yang lain ke pertempuran, Anda perlu mengetahui kode lingkungan dalam kode proyek atau memiliki file konfigurasi dengan daftar penghargaan.  Pada saat yang sama, tidak mungkin untuk menggunakan basis data yang berbeda untuk tugas ini, meskipun mereka sudah ada untuk setiap lingkungan. </li><li>  Kemampuan untuk mengonfigurasi pemfilteran hanya oleh pengembang.  Karena semuanya dijelaskan dalam kode, hanya orang yang mengetahui proyek dan bahasa pemrograman yang dapat membuat perubahan, saya ingin dimungkinkan untuk melakukan ini hanya melalui API atau basis data pribadi. </li><li>  Kerugian dari melihat.  Ada banyak hadiah, terkadang Anda perlu melihat filter yang mereka gunakan.  Setiap kali, melakukan ini dengan melihat kode sangat membosankan. </li></ul><br>  Pada awal aplikasi, kami mencocokkan dengan nama filter yang dimuat dari database dan menaruhnya dalam hadiah tertentu.  Contoh deskripsi filter: <br><br><pre><code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"SourceFilter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"config"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"sources"</span></span>:[<span class="hljs-string"><span class="hljs-string">"reviews"</span></span>] } }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ReviewsLengthFilter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"config"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"allowed_length"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } } ]</code> </pre> <br>  Dalam hal ini, kami hanya akan mengambil ulasan tersebut (ini ditunjukkan oleh objek deskripsi pertama dari array filter), teks yang berisi lebih dari 100 karakter (filter kedua dalam daftar). <br><br>  Deskripsi aturan contoh: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ReviewUniqueByObjectRule"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"config"</span></span>:{}}</code> </pre><br>  Aturan ini akan memungkinkan Anda untuk mengubah penghitung hanya jika pengguna menulis ulasan untuk objek, sementara hanya satu ulasan akan diperhitungkan untuk satu objek. <br><br><h3>  Bss </h3><br>  Mari kita bekerja secara terpisah untuk bekerja dengan aliran acara BSS.  Setidaknya ada tiga alasan untuk ini: <br><br><ul><li>  Acara Analytics tidak dapat dibatalkan, tidak ada model status di dalamnya, yang secara umum logis, karena mengemudi melalui navigator atau membuat rute tidak dapat dibatalkan.  Tindakan itu ada di sana atau tidak. </li><li>  Volume.  Biarkan saya mengingatkan Anda bahwa total pemirsa 2GIS adalah 50+ juta pengguna per bulan.  Bersama-sama mereka membuat lebih dari 1,5 miliar permintaan pencarian, serta banyak tindakan lain: meluncurkan aplikasi, melihat kartu objek, dll. Pada puncaknya, jumlah acara dapat mencapai 50.000 per detik.  Kami harus meneruskan semua informasi ini melalui filter untuk memberikan hadiah kepada pengguna. </li><li>  Acara Analytics memiliki fitur: beberapa format, berbagai jenis. </li></ul><br>  Semua ini sangat mempengaruhi pemrosesan data dari topik BSS, karena jika kita membutuhkan waktu nyata, maka kita perlu waktu pemrosesan yang sangat dekat. <br><br>  Untuk mengurangi perbedaan yang diuraikan, layanan terpisah telah dibuat yang menyiapkan acara semacam itu.  Layanan ini dapat bekerja dengan seluruh variasi format pesan yang berasal dari analytics.  Inti dari karyanya adalah sebagai berikut: seluruh aliran acara BSS dibaca, dari mana hanya yang diperlukan untuk Penghargaan yang diambil.  Filter layanan seperti itu secara signifikan mengurangi beban (setelah pemfilteran, laju aliran adalah ≈300 peristiwa per detik) dari Hadiah prosesor aliran BSS, dan juga menghasilkan peristiwa dalam format tunggal, meratakan kerugian yang terkait dengan sejarah analitik internal. <br><br><h2>  Penghargaan </h2><br>  Jadi, kami menemukan cara untuk menangani acara dan menghitung kemajuan tugas.  Sekarang saatnya untuk melihat proses pemberian hadiah kepada pengguna. <br><br>  Pertanyaan pertama yang muncul adalah: mengapa mengalokasikan output ke pekerja yang terpisah, tidak dapatkah ia dihitung ulang saat memproses setiap peristiwa?  Jawab: mungkin, tetapi tidak sepadan. <br><br>  Ada beberapa alasan untuk mengalokasikan ekstradisi ke proses terpisah: <br><br><ol><li>  Mentransfer penghitungan ulang ke setiap ConsumingWorker, kami mendapatkan Kondisi Balapan untuk operasi memperbarui kemajuan dengan hadiah, karena setiap penangan akan mencoba memperbarui kemajuan berdasarkan pada keadaan tugas yang diketahui, dan yang lain akan secara aktif mengubah status ini. </li><li>  Setiap kumpulan ConsumingWorker memproses acara dari Kafka dalam suatu transaksi.  Dengan menambahkan sisipan ke tabel hadiah pengguna, kami akan memanggil kunci tambahan di tingkat basis data, yang akan menghambat penangan lain. </li><li>  Dalam proses mengeluarkan penghargaan, ada logika untuk mengirim pemberitahuan, yang hanya akan memperlambat pemrosesan aliran acara, yang tidak diinginkan. </li></ol><br>  Alasan munculnya AchievesWorker yang terpisah (penangan untuk pemberian penghargaan) diurutkan keluar.  Sekarang Anda perlu berurusan dengan dua bagian penting dari pemrosesan: <br><br><ol><li>  Ada satu set pencarian dalam hadiah.  Ada satu set penghitung untuk tugas-tugas ini.  Bagaimana memahami seberapa banyak penghargaan dibuat dan bagaimana mengekspresikannya dalam kode? <br>  Contoh: Anda perlu menulis 3 ulasan atau mengunggah 3 foto.  Pengguna memiliki 1 ulasan dan 2 foto.  Apa kemajuan dari penghargaan itu?  Jawaban: 3, karena pengguna pasti akan yakin bahwa Anda membutuhkan total 3. </li><li>  Kami memiliki penangan terpisah untuk menerbitkan penghargaan.  Setiap kali, menceritakan beberapa lusin penghargaan untuk setiap pengguna yang berwenang, yaitu beberapa puluh juta, tidak mungkin berhasil dengan cepat.  Bagaimana dia bisa belajar tentang kemajuan pengguna mana dan pada tugas apa yang telah berubah sejak pemrosesan terakhir? </li></ol><br>  Kami akan mempertimbangkan setiap bagian secara terpisah. <br><br><h3>  Aliran kemajuan </h3><br>  Untuk pemahaman yang lebih baik tentang bagaimana Anda dapat menggambarkan bagaimana mengubah kemajuan tugas menjadi kemajuan dengan penghargaan, kami membagi penghargaan ke dalam kategori dan melihat transformasi. <br><br>  <b>"Selesaikan satu tugas per X unit."</b>  Contoh: Berkendara 10 km di navigator. <br><br><img src="https://habrastorage.org/webt/vv/qu/x5/vvqux5yb09uehrul3dkd3mux3wm.png"><br><br>  <b>"Selesaikan beberapa tugas untuk masing-masing unit X."</b>  Contoh: unggah 5 foto dan tulis 5 ulasan dalam kartu - hanya 10 unit konten. <br><br><img src="https://habrastorage.org/webt/fe/n8/oc/fen8oc0kbm372ozvyvr3a7fj8jo.png"><br><br>  <b>"Selesaikan beberapa tugas untuk unit X secara total."</b>  Contoh: tulis 5 ulasan atau unggah 5 foto. <br><br><img src="https://habrastorage.org/webt/d-/ld/gd/d-ldgdazj8xt2eysdzqhgauaxgc.png"><br><br>  <b>"Selesaikan beberapa tugas yang dikelompokkan berdasarkan jenis."</b>  Contoh: unggah 5 unit konten (foto atau ulasan) dan kendarai 10 km di navigator. <br><br><img src="https://habrastorage.org/webt/ue/c3/ck/uec3ckf33tcm4pjcfmtkfbmv9eq.png"><br><br>  Secara teoritis, mungkin ada kombinasi bersarang yang lebih kompleks.  Namun, dalam kondisi nyata, tidak mungkin untuk menjelaskan kepada pengguna dalam dua atau tiga kalimat kombinasi logis kompleks yang harus dilakukan untuk menerima penghargaan.  Oleh karena itu, dalam kebanyakan kasus, opsi ini sudah cukup. <br><br>  Kami menyebut metode konversi sebagai strategi dan mencoba membuatnya lebih atau kurang universal dengan menyusun deskripsi formal dalam bentuk objek JSON.  Anda tentu saja dapat berpikir untuk menulis dalam bentuk formula, tetapi kemudian Anda harus menggunakan persamaan eval atau menggambarkan tata bahasa dan mengimplementasikannya, dan ini jelas merupakan komplikasi berlebihan.  Menyimpan strategi dalam kode sumber untuk setiap penghargaan sangat tidak nyaman, karena deskripsi penghargaan (bagian dalam database, dan bagian dalam kode) akan robek, dan itu juga tidak akan memungkinkan mengumpulkan penghargaan dari komponen yang sudah jadi di masa depan tanpa partisipasi dari pengembangan. <br><br>  Strategi disajikan dalam bentuk pohon, di mana setiap simpul: <br><br><ul><li>  Mengacu pada kemajuan saat ini pada penugasan atau sekelompok node lain. </li><li>  Mungkin memiliki batasan atas - sebenarnya indikasi kebutuhan untuk menggunakan min (). </li><li>  Dapat memiliki koefisien normalisasi.  Diperlukan untuk konversi sederhana dengan mengalikan hasilnya dengan angka.  Kami berguna untuk mengonversi meter ke kilometer. </li></ul><br>  Untuk menggambarkan contoh di atas, satu operasi sudah cukup - jumlah.  Sum sangat bagus untuk menunjukkan dengan jelas kemajuan pengguna dengan satu angka, tetapi operasi lain dapat digunakan jika diinginkan. <br><br>  Berikut adalah contoh deskripsi strategi untuk kategori terakhir: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"goal"</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operation"</span></span>: <span class="hljs-string"><span class="hljs-string">"sum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"strategy"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"goal"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operation"</span></span>: <span class="hljs-string"><span class="hljs-string">"sum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"strategy"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"objective_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"photo"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"objective_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"reviews"</span></span> } ] }, { <span class="hljs-attr"><span class="hljs-attr">"goal"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operation"</span></span>: <span class="hljs-string"><span class="hljs-string">"sum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"strategy"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"objective_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"navi"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"normalization_factor"</span></span>: <span class="hljs-number"><span class="hljs-number">0.001</span></span> } ] } ] }</code> </pre><br><h3>  Pembaruan yang Diperlukan </h3><br>  Ada beberapa penangan yang tanpa henti menganalisis peristiwa oleh pengguna dan menerapkan perubahan pada kemajuan tugas.  Pencarian reguler semua pengguna dengan setiap penghargaan akan mengarah pada analisis puluhan juta penghargaan - tidak terlalu menggembirakan, asalkan pembaruan nyata akan diukur dalam ribuan.  Bagaimana cara belajar hanya tentang ribuan dan tidak membuang-buang jutaan CPU? <br><br>  Gagasan tentang bagaimana menghitung ulang kemajuan hanya pada penghargaan yang benar-benar berubah, datang dengan sangat cepat.  Ini didasarkan pada penggunaan jam tangan vektor. <br><br>  Sebelum uraian saya akan mengingatkan entitas: <br><br><ul><li>  UserObjective - data tentang kemajuan pengguna dengan menetapkan penghargaan. </li><li>  UserAchieve - hadiahi data kemajuan pengguna. </li></ul><br>  Implementasinya terlihat seperti ini: <br><br><ul><li>  Kami mendapatkan bidang versi untuk UserObjective dan UserAchieve dan Sequence di PostgreSQL. </li><li>  Setiap pembaruan entitas UserObjective mengubah versinya.  Nilai diambil dari urutan (kami memilikinya umum untuk semua catatan). </li><li>  Nilai versi untuk UserAchieve akan ditentukan sebagai maksimum dari versi UserObjective terkait. </li><li>  Pada setiap siklus pemrosesan, AchievesWorker mencari UserObjective yang tidak ada UserAchieve atau UserAchieve.version &lt;UserObjective.version.  Masalahnya diselesaikan dengan satu permintaan ke database. </li></ul><br>  Perlu dicatat bahwa solusi memiliki batasan pada jumlah entri dalam tabel penghargaan dan penugasan, serta pada frekuensi perubahan dalam progres penugasan, tetapi dengan beberapa puluh juta penghargaan dan jumlah pembaruan kurang dari seribu per menit, sangat mungkin untuk hidup dengan solusi semacam itu.  Entah bagaimana kami akan secara terpisah memberi tahu tentang bagaimana kami mengoptimalkan penerbitan untuk kontes " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2GIS Agents</a> ". <br><br><h2>  Kesimpulan </h2><br>  Terlepas dari kenyataan bahwa artikel itu ternyata cukup banyak, banyak nuansa tetap di belakang layar, karena tidak mungkin untuk membicarakannya secara singkat. <br><br>  Kesimpulan apa yang kami buat berkat Penghargaan: <br><br><ul><li>  Prinsip "memecah belah dan menaklukkan" dalam kasus ini dimainkan ke tangan kita.  Alokasi penangan acara untuk setiap sumber membantu kami mengukur bila perlu.  Pekerjaan mereka terisolasi menurut data dan hanya bersinggungan di daerah kecil.  Menyoroti logika hadiah memungkinkan Anda untuk mengurangi overhead di penangan acara. </li><li>  Jika Anda perlu mencerna banyak data dan pengolahannya cukup mahal, Anda harus segera memikirkan cara menyaring apa yang jelas tidak diperlukan.  Pengalaman dengan memfilter aliran BSS adalah contohnya. </li><li>  Sekali lagi kami yakin bahwa integrasi layanan melalui bus peristiwa umum sangat mudah dan memungkinkan Anda untuk menghindari beban yang tidak perlu pada layanan lain.  Jika layanan Hadiah menerima data dari Foto, Ulasan, dll. Layanan melalui permintaan http, maka beberapa layanan harus disiapkan untuk pemuatan tambahan. </li><li>  Sedikit metaprogramming dapat membantu menjaga integritas konfigurasi data dan lingkungan terpisah secara sewenang-wenang.  Menyimpan filter, aturan, dan strategi dalam basis data menyederhanakan proses pengembangan dan pelepasan penghargaan baru. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470942/">https://habr.com/ru/post/id470942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470928/index.html">Praktik terbaik untuk menjalankan Buildah di dalam sebuah wadah</a></li>
<li><a href="../id470930/index.html">Gamifikasi produk. Riwayat Ratatype</a></li>
<li><a href="../id470934/index.html">Menyembuhkan sebelum pernikahan: proliferasi sel dan kemampuan regenerasi ubur-ubur</a></li>
<li><a href="../id470938/index.html">Cara membuka tautan dengan Python. Bekerja dengan WebBrowser dan memecahkan masalah dengan Internet Explorer</a></li>
<li><a href="../id470940/index.html">Pertemuan MSK VUE.JS # 3 di Mail.ru Group: bahan dari mitap</a></li>
<li><a href="../id470950/index.html">bear_hug: game dalam seni ASCII dengan Python3.6 +</a></li>
<li><a href="../id470952/index.html">Tip & Trik Forensik Digital: Forensik aplikasi "Telepon Anda"</a></li>
<li><a href="../id470954/index.html">Instal Zimbra OSE 8.8.15 dan Zextras Suite Pro di Ubuntu 18.04 LTS</a></li>
<li><a href="../id470958/index.html">Probe kehidupan di Kubernetes bisa berbahaya</a></li>
<li><a href="../id470962/index.html">JSConf Budapest 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>