<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤩 👨🏻‍⚕️ ⏪ Texture convolutionnelle 👋🏾 👩‍🌾 🤲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Textures à mise à jour automatique 
 Lorsqu'il est possible de paralléliser des simulations ou des tâches de rendu, il est généralement préférable de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Texture convolutionnelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478772/"><h2>  Textures à mise à jour automatique </h2><br>  Lorsqu'il est possible de paralléliser des simulations ou des tâches de rendu, il est généralement préférable de les exécuter dans le GPU.  Dans cet article, je vais expliquer une technique qui utilise ce fait pour créer des trucs visuels impressionnants avec des frais généraux de faible performance.  Tous les effets que je vais démontrer sont implémentés à l'aide de textures qui, une fois mises à jour, se " <em>rendent</em> ";  la texture est mise à jour lorsqu'un nouveau cadre est rendu et l'état de texture suivant dépend complètement de l'état précédent.  Sur ces textures, vous pouvez dessiner, provoquant certains changements, et la texture elle-même, directement ou indirectement, peut être utilisée pour rendre des animations intéressantes.  Je les appelle <em>des textures convolutionnelles</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/756/a1a/005/756a1a0051471cbe895a8883d89efadd.jpg"></div><br>  <i>Figure 1: double tampon de convolution</i> <br><br>  Avant de continuer, nous devons résoudre un problème: la texture ne peut pas être lue et écrite en même temps, des API graphiques comme OpenGL et DirectX ne le permettent pas.  Étant donné que l'état suivant de la texture dépend du précédent, nous devons en quelque sorte contourner cette limitation.  J'ai besoin de lire à partir d'une texture différente, pas de celle dans laquelle j'écris. <br><br>  La solution est un <em>double tampon</em> .  La figure 1 montre comment cela fonctionne: en fait, au lieu d'une texture, il y en a deux, mais l'une est écrite et l'autre est lue de l'autre.  La texture en cours d'écriture est appelée le <em>tampon arrière</em> et la texture rendue est appelée le <em>tampon avant</em> .  Étant donné que le test convolutionnel est «écrit sur lui-même», le tampon secondaire de chaque trame écrit dans le tampon principal, puis le primaire est rendu ou utilisé pour le rendu.  Dans la trame suivante, les rôles changent et le tampon primaire précédent est utilisé comme source pour le tampon primaire suivant. <br><a name="habracut"></a><br>  En rendant l'état précédent dans une nouvelle texture de convolution en utilisant le shader de fragment (ou <em>pixel shader</em> ) fournit des effets et des animations intéressants.  Le shader détermine comment l'état change.  Le code source de tous les exemples de l'article (ainsi que d'autres) peut être trouvé dans le <a href="https://github.com/jobtalle/ConvolutionalTextures">référentiel sur GitHub</a> . <br><br><h2>  Exemples d'application simples </h2><br>  Pour démontrer cette technique, j'ai choisi une simulation bien connue dans laquelle, lors de la mise à jour, l'état dépend complètement de l'état précédent: le <em>jeu Conway «Life»</em> .  Cette simulation est réalisée dans une grille de carrés dont chaque cellule est vivante ou morte.  Les règles pour l'état de cellule suivant sont simples: <br><br><ul><li>  Si une cellule vivante a moins de deux voisins, mais elle devient morte. </li><li>  Si une cellule vivante a deux ou trois voisins vivants, elle reste vivante. </li><li>  Si une cellule vivante a plus de trois voisins vivants, elle devient morte. </li><li>  Si une cellule morte a trois voisins vivants, elle devient vivante. </li></ul><br>  Pour implémenter ce jeu comme une texture convolutive, j'interprète la texture comme la grille du jeu, et le rendu du shader est basé sur les règles ci-dessus.  Un pixel transparent est une cellule morte et un pixel blanc opaque est une cellule vivante.  Une implémentation interactive est illustrée ci-dessous.  Pour accéder au GPU, j'utilise <a href=""><em>myr.js</em></a> , qui nécessite <em>WebGL 2</em> .  La plupart des navigateurs modernes (par exemple, Chrome et Firefox) peuvent fonctionner avec, mais si la démo ne fonctionne pas, le navigateur ne la prend probablement pas en charge.  Utilisez la souris (ou l'écran tactile) [dans l'article original] pour dessiner des cellules vivantes sur la texture. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SQ3EKUPm8FY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le code du fragment shader (dans GLSL, car j'utilise WebGL pour le rendu) est illustré ci-dessous.  Tout d'abord, j'implémente la fonction <code>get</code> , qui me permet de lire un pixel à partir d'un décalage spécifique par rapport à celui en cours.  La variable <code>pixelSize</code> est un vecteur 2D pré-créé contenant le décalage UV de chaque pixel, et la fonction <code>get</code> l'utilise pour lire la cellule voisine.  Ensuite, la fonction <code>main</code> détermine la nouvelle couleur de la cellule en fonction de l'état actuel (en <code>live</code> ) et du nombre de voisins vivants. <br><br><pre> <code class="cpp hljs">uniform sampler2D source; uniform lowp vec2 pixelSize; in mediump vec2 uv; layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out lowp vec4 color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(texture(source, uv + pixelSize * vec2(dx, dy)).r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> live = get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbors = get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span> || neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>)) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Une autre texture convolutionnelle simple est un <em>jeu avec du sable qui tombe</em> , dans lequel l'utilisateur peut jeter du sable coloré sur la scène, qui tombe et forme des montagnes.  Bien que sa mise en œuvre soit un peu plus compliquée, les règles sont plus simples: <br><br><ul><li>  S'il n'y a pas de sable sous un grain de sable, il tombe d'un pixel vers le bas. </li><li>  S'il y a du sable sous un grain de sable, mais qu'il peut glisser de 45 degrés vers la gauche ou la droite, il le fera. </li></ul><br>  La gestion dans cet exemple est la même que dans le jeu "Life".  Étant donné que dans de telles règles, le sable peut tomber à une vitesse d'un seul pixel par image afin d'accélérer légèrement le processus, la texture par image est mise à jour trois fois.  Le code source de l'application est <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/sand.html">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MV10ScILiAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Un pas en avant </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Chaîne</b> </td><td>  <b>Candidature</b> </td></tr><tr><td>  Rouge </td><td>  Hauteur des vagues </td></tr><tr><td>  Vert </td><td>  Vitesse des vagues </td></tr><tr><td>  Bleu </td><td>  <i>Non utilisé</i> </td></tr><tr><td>  Alpha </td><td>  <i>Non utilisé</i> </td></tr></tbody></table></div><br>  <i>Figure 2: vagues de pixels.</i> <br><br>  Les exemples ci-dessus utilisent directement la texture convolutionnelle;  son contenu est restitué à l'écran tel quel.  Si vous interprétez les images uniquement comme des pixels, les limites d'utilisation de cette technique sont très limitées, mais grâce à un équipement moderne, elles peuvent être étendues.  Au lieu de compter les pixels comme des couleurs, je les interpréterai un peu différemment, ce qui peut être utilisé pour créer des animations d'une autre texture ou d'un modèle 3D. <br><br>  Tout d'abord, je vais interpréter la texture convolutionnelle comme une carte de hauteur.  La texture simulera les <em>vagues</em> et les <em>vibrations</em> sur le plan d'eau, et les résultats seront utilisés pour rendre les réflexions et les vagues ombrées.  Nous ne sommes plus tenus de lire la texture comme une image, nous pouvons donc utiliser ses pixels pour stocker des informations.  Dans le cas d'un shader à eau, je stocke la hauteur des vagues dans le canal rouge et l'impulsion des vagues dans le canal vert, comme illustré à la figure 2. Les canaux bleu et alpha ne sont pas encore utilisés.  Les vagues sont créées en dessinant des taches rouges sur une texture convolutionnelle. <br><br>  Je ne considérerai pas la méthodologie de mise à jour de la carte des hauteurs, que j'ai empruntée au site d' <em>Hugo Elias</em> , qui semble avoir disparu d'Internet.  Il a également découvert cet algorithme d'un auteur inconnu et l'a implémenté en C pour exécution dans le CPU.  Le code source de l'application ci-dessous est <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/water.html">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/h8GjEGMV8AE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ici, j'ai utilisé une carte de hauteur uniquement pour compenser la texture et ajouter de l'ombrage, mais dans la troisième dimension, des applications beaucoup plus intéressantes peuvent être implémentées.  Lorsqu'une texture convolutionnelle est interprétée par un vertex shader, un plan plat subdivisé peut être déformé pour créer des ondes tridimensionnelles.  Vous pouvez appliquer l'ombrage et l'éclairage habituels à la forme résultante. <br><br>  Il convient de noter que les pixels de la texture convolutionnelle de l'exemple ci-dessus stockent parfois de très petites valeurs qui ne devraient pas disparaître en raison d'erreurs d'arrondi.  Par conséquent, les canaux de couleur de cette texture doivent avoir une résolution plus élevée et non les 8 bits standard.  Dans cet exemple, j'ai augmenté la taille de chaque canal de couleur à 16 bits, ce qui a donné des résultats assez précis.  Si vous ne stockez pas de pixels, vous devez souvent augmenter la précision de la texture.  Heureusement, les API graphiques modernes prennent en charge cette fonctionnalité. <br><br><h2>  Nous utilisons tous les canaux </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Chaîne</b> </td><td>  <b>Candidature</b> </td></tr><tr><td>  Rouge </td><td>  Décalage X </td></tr><tr><td>  Vert </td><td>  Décalage Y </td></tr><tr><td>  Bleu </td><td>  Vitesse X </td></tr><tr><td>  Alpha </td><td>  Décalage Y </td></tr></tbody></table></div><br>  <i>Figure 3: Pixel grass.</i> <br><br>  Dans l'exemple de l'eau, seuls les canaux rouge et vert sont utilisés, mais dans l'exemple suivant, nous appliquerons les quatre.  Un champ avec de l'herbe (ou des arbres) est simulé, qui peut être déplacé à l'aide du curseur.  La figure 3 montre quelles données sont stockées dans un pixel.  Le décalage est stocké dans les canaux rouge et vert et la vitesse est stockée dans les canaux bleu et alpha.  Cette vitesse est mise à jour pour se déplacer vers la position de repos avec un mouvement d'onde qui s'estompe progressivement. <br><br>  Dans l'exemple avec de l'eau, créer des vagues est assez simple: des taches peuvent être dessinées sur la texture et le mélange alpha fournit des formes douces.  Vous pouvez facilement créer plusieurs spots qui se chevauchent.  Dans cet exemple, tout est plus délicat car le canal alpha est déjà utilisé.  Nous ne pouvons pas dessiner un point avec une valeur alpha de 1 au centre et 0 du bord, car cela donnera à l'herbe une impulsion inutile (car l'impulsion verticale est stockée dans le canal alpha).  Dans ce cas, un ombrage séparé a été écrit pour dessiner l'effet sur la texture convolutionnelle.  Ce shader garantit que le mélange alpha ne produit pas d'effets inattendus. <br><br>  Le code source de l'application se trouve <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/grass.html">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oBqQL7HViLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'herbe est créée en 2D, mais l'effet fonctionnera dans des environnements 3D.  Au lieu du déplacement des pixels, les sommets sont décalés, ce qui est également plus rapide.  De plus, à l'aide de pics, un autre effet peut être réalisé: force différente des branches - l'herbe se plie facilement au moindre vent et les arbres forts ne fluctuent que pendant les tempêtes. <br><br>  Bien qu'il existe de nombreux algorithmes et shaders pour créer les effets du vent et du déplacement de la végétation, cette approche a un sérieux avantage: dessiner des effets sur une texture convolutionnelle est un processus très peu coûteux.  Si l'effet est appliqué dans un jeu, alors le mouvement de la végétation peut être déterminé par des centaines d'influences différentes.  Non seulement le personnage principal, mais aussi tous les objets, animaux et mouvements peuvent influencer le monde au détriment de coûts insignifiants. <br><br><h2>  Autres cas d'utilisation et défauts </h2><br>  Vous pouvez proposer de nombreuses autres applications technologiques, par exemple: <br><br><ul><li>  En utilisant une texture convolutionnelle, vous pouvez simuler la vitesse du vent.  Sur la texture, vous pouvez dessiner des obstacles qui font circuler l'air autour d'eux.  Les particules (pluie, neige et feuilles) peuvent utiliser cette texture pour contourner les obstacles. </li><li>  Vous pouvez simuler la propagation de la fumée ou du feu. </li><li>  La texture peut coder l'épaisseur d'une couche de neige ou de sable.  Les traces et autres interactions avec le calque peuvent créer des bosses et des impressions sur le calque. </li></ul><br>  Lors de l'utilisation de cette méthode, il existe des difficultés et des limites: <br><br><ul><li>  Il est difficile d'ajuster les animations à l'évolution des fréquences d'images.  Par exemple, dans une application avec du sable qui tombe, les grains de sable tombent à une vitesse constante - un pixel par mise à jour.  Une solution possible peut être de mettre à jour les textures convolutionnelles avec une fréquence constante, semblable à la façon dont la plupart des moteurs physiques fonctionnent;  le moteur physique fonctionne à une fréquence constante et ses résultats sont interpolés. </li><li>  Le transfert de données vers le GPU est un processus rapide et facile, cependant, récupérer des données n'est pas si facile.  Cela signifie que la plupart des effets générés par cette technique sont unidirectionnels;  ils sont transférés vers le GPU, et le GPU fait son travail sans autre intervention et rétroaction.  Si je voulais intégrer la longueur d'onde de l'exemple de l'eau dans des calculs physiques (par exemple, pour que les navires oscillent avec les vagues), alors j'aurais besoin de valeurs de la texture convolutionnelle.  La récupération des données de texture à partir d'un GPU est un processus extrêmement lent qui n'a pas besoin d'être effectué en temps réel.  La solution à ce problème peut être l'implémentation de deux simulations: l'une avec une haute résolution pour les graphiques de l'eau en tant que texture convolutionnelle, l'autre avec une basse résolution dans le CPU pour la physique de l'eau.  Si les algorithmes sont les mêmes, les écarts peuvent être tout à fait acceptables. </li></ul><br>  Les démos de cet article peuvent être encore optimisées.  Dans l'exemple de l'herbe, vous pouvez utiliser une texture avec une résolution beaucoup plus faible sans défauts notables;  cela aidera beaucoup dans les grandes scènes.  Autre optimisation: vous pouvez utiliser un taux de rafraîchissement inférieur, par exemple, dans chaque quatrième trame, ou un quart par trame (car cette technique ne pose pas de problème avec les mises à jour segmentées).  Pour maintenir une fréquence d'images régulière, l'état précédent et actuel de la texture convolutionnelle peut être interpolé. <br><br>  Étant donné que les textures convolutives utilisent une double mémoire tampon interne, vous pouvez utiliser les deux textures en même temps pour le rendu.  Le tampon principal est l'état actuel et le secondaire est le précédent.  Cela peut être utile pour interpoler la texture dans le temps ou pour calculer des dérivés pour les valeurs de texture. <br><br><h2>  Conclusion </h2><br>  Les GPU, en particulier dans les programmes 2D, sont souvent inactifs.  Bien qu'il semble qu'elle ne puisse être utilisée que pour le rendu de scènes 3D complexes, la technique présentée dans cet article montre au moins une autre façon d'utiliser la puissance du GPU.  En utilisant les capacités pour lesquelles le GPU a été développé, vous pouvez implémenter des effets et des animations intéressants qui sont généralement trop coûteux pour le CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478772/">https://habr.com/ru/post/fr478772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478752/index.html">Histoire des systèmes de contrôle de version</a></li>
<li><a href="../fr478758/index.html">Grand guide des balises UTM: comment savoir d'où viennent les utilisateurs</a></li>
<li><a href="../fr478760/index.html">L'enfer "zéro" et comment s'en sortir</a></li>
<li><a href="../fr478764/index.html">Erreurs JavaScript: correction, traitement, réparation</a></li>
<li><a href="../fr478766/index.html">Personnaliser le mappage des contrôleurs Spring MVC</a></li>
<li><a href="../fr478774/index.html">Ambiance du Nouvel An d'Arduino et de bâtons</a></li>
<li><a href="../fr478788/index.html">Dans un certain royaume, pas dans un état «naissant». Rapport Yandex</a></li>
<li><a href="../fr478790/index.html">Julia et la sémantique de distribution</a></li>
<li><a href="../fr478796/index.html">Premier cycle aux États-Unis: un moyen non conventionnel d'atteindre les meilleures écoles secondaires</a></li>
<li><a href="../fr478798/index.html">Le graphène, qui ne pouvait toujours pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>