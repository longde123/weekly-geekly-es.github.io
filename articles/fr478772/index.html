<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§© üë®üèª‚Äç‚öïÔ∏è ‚è™ Texture convolutionnelle üëãüèæ üë©‚Äçüåæ ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Textures √† mise √† jour automatique 
 Lorsqu'il est possible de parall√©liser des simulations ou des t√¢ches de rendu, il est g√©n√©ralement pr√©f√©rable de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Texture convolutionnelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478772/"><h2>  Textures √† mise √† jour automatique </h2><br>  Lorsqu'il est possible de parall√©liser des simulations ou des t√¢ches de rendu, il est g√©n√©ralement pr√©f√©rable de les ex√©cuter dans le GPU.  Dans cet article, je vais expliquer une technique qui utilise ce fait pour cr√©er des trucs visuels impressionnants avec des frais g√©n√©raux de faible performance.  Tous les effets que je vais d√©montrer sont impl√©ment√©s √† l'aide de textures qui, une fois mises √† jour, se " <em>rendent</em> ";  la texture est mise √† jour lorsqu'un nouveau cadre est rendu et l'√©tat de texture suivant d√©pend compl√®tement de l'√©tat pr√©c√©dent.  Sur ces textures, vous pouvez dessiner, provoquant certains changements, et la texture elle-m√™me, directement ou indirectement, peut √™tre utilis√©e pour rendre des animations int√©ressantes.  Je les appelle <em>des textures convolutionnelles</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/756/a1a/005/756a1a0051471cbe895a8883d89efadd.jpg"></div><br>  <i>Figure 1: double tampon de convolution</i> <br><br>  Avant de continuer, nous devons r√©soudre un probl√®me: la texture ne peut pas √™tre lue et √©crite en m√™me temps, des API graphiques comme OpenGL et DirectX ne le permettent pas.  √âtant donn√© que l'√©tat suivant de la texture d√©pend du pr√©c√©dent, nous devons en quelque sorte contourner cette limitation.  J'ai besoin de lire √† partir d'une texture diff√©rente, pas de celle dans laquelle j'√©cris. <br><br>  La solution est un <em>double tampon</em> .  La figure 1 montre comment cela fonctionne: en fait, au lieu d'une texture, il y en a deux, mais l'une est √©crite et l'autre est lue de l'autre.  La texture en cours d'√©criture est appel√©e le <em>tampon arri√®re</em> et la texture rendue est appel√©e le <em>tampon avant</em> .  √âtant donn√© que le test convolutionnel est ¬´√©crit sur lui-m√™me¬ª, le tampon secondaire de chaque trame √©crit dans le tampon principal, puis le primaire est rendu ou utilis√© pour le rendu.  Dans la trame suivante, les r√¥les changent et le tampon primaire pr√©c√©dent est utilis√© comme source pour le tampon primaire suivant. <br><a name="habracut"></a><br>  En rendant l'√©tat pr√©c√©dent dans une nouvelle texture de convolution en utilisant le shader de fragment (ou <em>pixel shader</em> ) fournit des effets et des animations int√©ressants.  Le shader d√©termine comment l'√©tat change.  Le code source de tous les exemples de l'article (ainsi que d'autres) peut √™tre trouv√© dans le <a href="https://github.com/jobtalle/ConvolutionalTextures">r√©f√©rentiel sur GitHub</a> . <br><br><h2>  Exemples d'application simples </h2><br>  Pour d√©montrer cette technique, j'ai choisi une simulation bien connue dans laquelle, lors de la mise √† jour, l'√©tat d√©pend compl√®tement de l'√©tat pr√©c√©dent: le <em>jeu Conway ¬´Life¬ª</em> .  Cette simulation est r√©alis√©e dans une grille de carr√©s dont chaque cellule est vivante ou morte.  Les r√®gles pour l'√©tat de cellule suivant sont simples: <br><br><ul><li>  Si une cellule vivante a moins de deux voisins, mais elle devient morte. </li><li>  Si une cellule vivante a deux ou trois voisins vivants, elle reste vivante. </li><li>  Si une cellule vivante a plus de trois voisins vivants, elle devient morte. </li><li>  Si une cellule morte a trois voisins vivants, elle devient vivante. </li></ul><br>  Pour impl√©menter ce jeu comme une texture convolutive, j'interpr√®te la texture comme la grille du jeu, et le rendu du shader est bas√© sur les r√®gles ci-dessus.  Un pixel transparent est une cellule morte et un pixel blanc opaque est une cellule vivante.  Une impl√©mentation interactive est illustr√©e ci-dessous.  Pour acc√©der au GPU, j'utilise <a href=""><em>myr.js</em></a> , qui n√©cessite <em>WebGL 2</em> .  La plupart des navigateurs modernes (par exemple, Chrome et Firefox) peuvent fonctionner avec, mais si la d√©mo ne fonctionne pas, le navigateur ne la prend probablement pas en charge.  Utilisez la souris (ou l'√©cran tactile) [dans l'article original] pour dessiner des cellules vivantes sur la texture. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SQ3EKUPm8FY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le code du fragment shader (dans GLSL, car j'utilise WebGL pour le rendu) est illustr√© ci-dessous.  Tout d'abord, j'impl√©mente la fonction <code>get</code> , qui me permet de lire un pixel √† partir d'un d√©calage sp√©cifique par rapport √† celui en cours.  La variable <code>pixelSize</code> est un vecteur 2D pr√©-cr√©√© contenant le d√©calage UV de chaque pixel, et la fonction <code>get</code> l'utilise pour lire la cellule voisine.  Ensuite, la fonction <code>main</code> d√©termine la nouvelle couleur de la cellule en fonction de l'√©tat actuel (en <code>live</code> ) et du nombre de voisins vivants. <br><br><pre> <code class="cpp hljs">uniform sampler2D source; uniform lowp vec2 pixelSize; in mediump vec2 uv; layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out lowp vec4 color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(texture(source, uv + pixelSize * vec2(dx, dy)).r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> live = get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbors = get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span> || neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>)) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Une autre texture convolutionnelle simple est un <em>jeu avec du sable qui tombe</em> , dans lequel l'utilisateur peut jeter du sable color√© sur la sc√®ne, qui tombe et forme des montagnes.  Bien que sa mise en ≈ìuvre soit un peu plus compliqu√©e, les r√®gles sont plus simples: <br><br><ul><li>  S'il n'y a pas de sable sous un grain de sable, il tombe d'un pixel vers le bas. </li><li>  S'il y a du sable sous un grain de sable, mais qu'il peut glisser de 45 degr√©s vers la gauche ou la droite, il le fera. </li></ul><br>  La gestion dans cet exemple est la m√™me que dans le jeu "Life".  √âtant donn√© que dans de telles r√®gles, le sable peut tomber √† une vitesse d'un seul pixel par image afin d'acc√©l√©rer l√©g√®rement le processus, la texture par image est mise √† jour trois fois.  Le code source de l'application est <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/sand.html">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MV10ScILiAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Un pas en avant </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Cha√Æne</b> </td><td>  <b>Candidature</b> </td></tr><tr><td>  Rouge </td><td>  Hauteur des vagues </td></tr><tr><td>  Vert </td><td>  Vitesse des vagues </td></tr><tr><td>  Bleu </td><td>  <i>Non utilis√©</i> </td></tr><tr><td>  Alpha </td><td>  <i>Non utilis√©</i> </td></tr></tbody></table></div><br>  <i>Figure 2: vagues de pixels.</i> <br><br>  Les exemples ci-dessus utilisent directement la texture convolutionnelle;  son contenu est restitu√© √† l'√©cran tel quel.  Si vous interpr√©tez les images uniquement comme des pixels, les limites d'utilisation de cette technique sont tr√®s limit√©es, mais gr√¢ce √† un √©quipement moderne, elles peuvent √™tre √©tendues.  Au lieu de compter les pixels comme des couleurs, je les interpr√©terai un peu diff√©remment, ce qui peut √™tre utilis√© pour cr√©er des animations d'une autre texture ou d'un mod√®le 3D. <br><br>  Tout d'abord, je vais interpr√©ter la texture convolutionnelle comme une carte de hauteur.  La texture simulera les <em>vagues</em> et les <em>vibrations</em> sur le plan d'eau, et les r√©sultats seront utilis√©s pour rendre les r√©flexions et les vagues ombr√©es.  Nous ne sommes plus tenus de lire la texture comme une image, nous pouvons donc utiliser ses pixels pour stocker des informations.  Dans le cas d'un shader √† eau, je stocke la hauteur des vagues dans le canal rouge et l'impulsion des vagues dans le canal vert, comme illustr√© √† la figure 2. Les canaux bleu et alpha ne sont pas encore utilis√©s.  Les vagues sont cr√©√©es en dessinant des taches rouges sur une texture convolutionnelle. <br><br>  Je ne consid√©rerai pas la m√©thodologie de mise √† jour de la carte des hauteurs, que j'ai emprunt√©e au site d' <em>Hugo Elias</em> , qui semble avoir disparu d'Internet.  Il a √©galement d√©couvert cet algorithme d'un auteur inconnu et l'a impl√©ment√© en C pour ex√©cution dans le CPU.  Le code source de l'application ci-dessous est <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/water.html">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/h8GjEGMV8AE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ici, j'ai utilis√© une carte de hauteur uniquement pour compenser la texture et ajouter de l'ombrage, mais dans la troisi√®me dimension, des applications beaucoup plus int√©ressantes peuvent √™tre impl√©ment√©es.  Lorsqu'une texture convolutionnelle est interpr√©t√©e par un vertex shader, un plan plat subdivis√© peut √™tre d√©form√© pour cr√©er des ondes tridimensionnelles.  Vous pouvez appliquer l'ombrage et l'√©clairage habituels √† la forme r√©sultante. <br><br>  Il convient de noter que les pixels de la texture convolutionnelle de l'exemple ci-dessus stockent parfois de tr√®s petites valeurs qui ne devraient pas dispara√Ætre en raison d'erreurs d'arrondi.  Par cons√©quent, les canaux de couleur de cette texture doivent avoir une r√©solution plus √©lev√©e et non les 8 bits standard.  Dans cet exemple, j'ai augment√© la taille de chaque canal de couleur √† 16 bits, ce qui a donn√© des r√©sultats assez pr√©cis.  Si vous ne stockez pas de pixels, vous devez souvent augmenter la pr√©cision de la texture.  Heureusement, les API graphiques modernes prennent en charge cette fonctionnalit√©. <br><br><h2>  Nous utilisons tous les canaux </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Cha√Æne</b> </td><td>  <b>Candidature</b> </td></tr><tr><td>  Rouge </td><td>  D√©calage X </td></tr><tr><td>  Vert </td><td>  D√©calage Y </td></tr><tr><td>  Bleu </td><td>  Vitesse X </td></tr><tr><td>  Alpha </td><td>  D√©calage Y </td></tr></tbody></table></div><br>  <i>Figure 3: Pixel grass.</i> <br><br>  Dans l'exemple de l'eau, seuls les canaux rouge et vert sont utilis√©s, mais dans l'exemple suivant, nous appliquerons les quatre.  Un champ avec de l'herbe (ou des arbres) est simul√©, qui peut √™tre d√©plac√© √† l'aide du curseur.  La figure 3 montre quelles donn√©es sont stock√©es dans un pixel.  Le d√©calage est stock√© dans les canaux rouge et vert et la vitesse est stock√©e dans les canaux bleu et alpha.  Cette vitesse est mise √† jour pour se d√©placer vers la position de repos avec un mouvement d'onde qui s'estompe progressivement. <br><br>  Dans l'exemple avec de l'eau, cr√©er des vagues est assez simple: des taches peuvent √™tre dessin√©es sur la texture et le m√©lange alpha fournit des formes douces.  Vous pouvez facilement cr√©er plusieurs spots qui se chevauchent.  Dans cet exemple, tout est plus d√©licat car le canal alpha est d√©j√† utilis√©.  Nous ne pouvons pas dessiner un point avec une valeur alpha de 1 au centre et 0 du bord, car cela donnera √† l'herbe une impulsion inutile (car l'impulsion verticale est stock√©e dans le canal alpha).  Dans ce cas, un ombrage s√©par√© a √©t√© √©crit pour dessiner l'effet sur la texture convolutionnelle.  Ce shader garantit que le m√©lange alpha ne produit pas d'effets inattendus. <br><br>  Le code source de l'application se trouve <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/grass.html">ici</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oBqQL7HViLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'herbe est cr√©√©e en 2D, mais l'effet fonctionnera dans des environnements 3D.  Au lieu du d√©placement des pixels, les sommets sont d√©cal√©s, ce qui est √©galement plus rapide.  De plus, √† l'aide de pics, un autre effet peut √™tre r√©alis√©: force diff√©rente des branches - l'herbe se plie facilement au moindre vent et les arbres forts ne fluctuent que pendant les temp√™tes. <br><br>  Bien qu'il existe de nombreux algorithmes et shaders pour cr√©er les effets du vent et du d√©placement de la v√©g√©tation, cette approche a un s√©rieux avantage: dessiner des effets sur une texture convolutionnelle est un processus tr√®s peu co√ªteux.  Si l'effet est appliqu√© dans un jeu, alors le mouvement de la v√©g√©tation peut √™tre d√©termin√© par des centaines d'influences diff√©rentes.  Non seulement le personnage principal, mais aussi tous les objets, animaux et mouvements peuvent influencer le monde au d√©triment de co√ªts insignifiants. <br><br><h2>  Autres cas d'utilisation et d√©fauts </h2><br>  Vous pouvez proposer de nombreuses autres applications technologiques, par exemple: <br><br><ul><li>  En utilisant une texture convolutionnelle, vous pouvez simuler la vitesse du vent.  Sur la texture, vous pouvez dessiner des obstacles qui font circuler l'air autour d'eux.  Les particules (pluie, neige et feuilles) peuvent utiliser cette texture pour contourner les obstacles. </li><li>  Vous pouvez simuler la propagation de la fum√©e ou du feu. </li><li>  La texture peut coder l'√©paisseur d'une couche de neige ou de sable.  Les traces et autres interactions avec le calque peuvent cr√©er des bosses et des impressions sur le calque. </li></ul><br>  Lors de l'utilisation de cette m√©thode, il existe des difficult√©s et des limites: <br><br><ul><li>  Il est difficile d'ajuster les animations √† l'√©volution des fr√©quences d'images.  Par exemple, dans une application avec du sable qui tombe, les grains de sable tombent √† une vitesse constante - un pixel par mise √† jour.  Une solution possible peut √™tre de mettre √† jour les textures convolutionnelles avec une fr√©quence constante, semblable √† la fa√ßon dont la plupart des moteurs physiques fonctionnent;  le moteur physique fonctionne √† une fr√©quence constante et ses r√©sultats sont interpol√©s. </li><li>  Le transfert de donn√©es vers le GPU est un processus rapide et facile, cependant, r√©cup√©rer des donn√©es n'est pas si facile.  Cela signifie que la plupart des effets g√©n√©r√©s par cette technique sont unidirectionnels;  ils sont transf√©r√©s vers le GPU, et le GPU fait son travail sans autre intervention et r√©troaction.  Si je voulais int√©grer la longueur d'onde de l'exemple de l'eau dans des calculs physiques (par exemple, pour que les navires oscillent avec les vagues), alors j'aurais besoin de valeurs de la texture convolutionnelle.  La r√©cup√©ration des donn√©es de texture √† partir d'un GPU est un processus extr√™mement lent qui n'a pas besoin d'√™tre effectu√© en temps r√©el.  La solution √† ce probl√®me peut √™tre l'impl√©mentation de deux simulations: l'une avec une haute r√©solution pour les graphiques de l'eau en tant que texture convolutionnelle, l'autre avec une basse r√©solution dans le CPU pour la physique de l'eau.  Si les algorithmes sont les m√™mes, les √©carts peuvent √™tre tout √† fait acceptables. </li></ul><br>  Les d√©mos de cet article peuvent √™tre encore optimis√©es.  Dans l'exemple de l'herbe, vous pouvez utiliser une texture avec une r√©solution beaucoup plus faible sans d√©fauts notables;  cela aidera beaucoup dans les grandes sc√®nes.  Autre optimisation: vous pouvez utiliser un taux de rafra√Æchissement inf√©rieur, par exemple, dans chaque quatri√®me trame, ou un quart par trame (car cette technique ne pose pas de probl√®me avec les mises √† jour segment√©es).  Pour maintenir une fr√©quence d'images r√©guli√®re, l'√©tat pr√©c√©dent et actuel de la texture convolutionnelle peut √™tre interpol√©. <br><br>  √âtant donn√© que les textures convolutives utilisent une double m√©moire tampon interne, vous pouvez utiliser les deux textures en m√™me temps pour le rendu.  Le tampon principal est l'√©tat actuel et le secondaire est le pr√©c√©dent.  Cela peut √™tre utile pour interpoler la texture dans le temps ou pour calculer des d√©riv√©s pour les valeurs de texture. <br><br><h2>  Conclusion </h2><br>  Les GPU, en particulier dans les programmes 2D, sont souvent inactifs.  Bien qu'il semble qu'elle ne puisse √™tre utilis√©e que pour le rendu de sc√®nes 3D complexes, la technique pr√©sent√©e dans cet article montre au moins une autre fa√ßon d'utiliser la puissance du GPU.  En utilisant les capacit√©s pour lesquelles le GPU a √©t√© d√©velopp√©, vous pouvez impl√©menter des effets et des animations int√©ressants qui sont g√©n√©ralement trop co√ªteux pour le CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478772/">https://habr.com/ru/post/fr478772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478752/index.html">Histoire des syst√®mes de contr√¥le de version</a></li>
<li><a href="../fr478758/index.html">Grand guide des balises UTM: comment savoir d'o√π viennent les utilisateurs</a></li>
<li><a href="../fr478760/index.html">L'enfer "z√©ro" et comment s'en sortir</a></li>
<li><a href="../fr478764/index.html">Erreurs JavaScript: correction, traitement, r√©paration</a></li>
<li><a href="../fr478766/index.html">Personnaliser le mappage des contr√¥leurs Spring MVC</a></li>
<li><a href="../fr478774/index.html">Ambiance du Nouvel An d'Arduino et de b√¢tons</a></li>
<li><a href="../fr478788/index.html">Dans un certain royaume, pas dans un √©tat ¬´naissant¬ª. Rapport Yandex</a></li>
<li><a href="../fr478790/index.html">Julia et la s√©mantique de distribution</a></li>
<li><a href="../fr478796/index.html">Premier cycle aux √âtats-Unis: un moyen non conventionnel d'atteindre les meilleures √©coles secondaires</a></li>
<li><a href="../fr478798/index.html">Le graph√®ne, qui ne pouvait toujours pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>