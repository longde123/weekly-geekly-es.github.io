<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè† ü§¶üèæ ‚ûï Bergetar. Kunci! Untuk apa mereka? ‚¨úÔ∏è ü§¥üèΩ üçì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parameter key dapat ditemukan di hampir setiap konstruktor widget, tetapi parameter ini jarang digunakan dalam pengembangan. Keys mempertahankan statu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bergetar. Kunci! Untuk apa mereka?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446050/"><p><img src="https://habrastorage.org/webt/bd/bp/o2/bdbpo2nvc1jntzhrnowfckpywh0.jpeg"></p><br><p> Parameter <code>key</code> dapat ditemukan di hampir setiap konstruktor widget, tetapi parameter ini jarang digunakan dalam pengembangan.  <code>Keys</code> mempertahankan status saat memindahkan widget di pohon widget.  Dalam praktiknya, ini berarti bahwa mereka dapat berguna untuk menyimpan lokasi gulir pengguna atau menyimpan kondisi ketika koleksi berubah. </p><br><p>  Artikel ini diadaptasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> berikut.  Jika Anda lebih suka mendengarkan / menonton daripada membaca, maka video akan memberi Anda materi yang sama. </p><a name="habracut"></a><br><h2 id="sekretnaya-informaciya-o-keys">  Informasi rahasia tentang <code>keys</code> </h2><br><p>  Sebagian besar waktu ... Anda tidak perlu <code>keys</code> .  Secara umum, tidak ada salahnya menambahkannya, tetapi ini juga tidak perlu, karena mereka hanya terjadi sebagai kata kunci baru atau ketik deklarasi di kedua sisi variabel baru (saya berbicara tentang Anda, <code>Map&lt;Foo, Bar&gt; aMap = Map&lt;Foo, Bar&gt;()</code> ). </p><br><blockquote>  Tetapi jika Anda menemukan bahwa Anda menambahkan, menghapus, atau mengatur ulang widget dalam koleksi yang berisi beberapa status dan jenis yang sama, maka Anda harus memperhatikan <code>keys</code> ! </blockquote><p>  Untuk menunjukkan mengapa Anda memerlukan <code>keys</code> saat mengubah koleksi widget, saya menulis aplikasi yang sangat sederhana dengan dua widget berwarna yang mengubah tempat ketika sebuah tombol diklik: </p><br><p><img src="https://habrastorage.org/webt/n3/qy/l1/n3qyl1ute2ckxrbmjoasonmttra.gif"></p><br><p>  Dalam versi aplikasi ini, saya memiliki dua widget stateless dengan warna acak ( <code>StatelessWidget</code> ) di widget <code>Row</code> dan PositionedTiles dengan status ( <code>StatefulWidget</code> ) untuk menyimpan urutan widget warna di dalamnya.  Ketika saya mengklik tombol <code>FloatingActionButton</code> di bagian bawah, widget warna dengan benar mengubah tempat mereka dalam daftar: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>, tiles.removeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ Color myColor = UniqueColorGenerator.getColor(); <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding(padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>))); } }</code> </pre> <br><p>  Tetapi jika kita menambahkan status ke widget warna kita (membuatnya <code>StatefulWidget</code> ) dan menyimpan warna di dalamnya, maka ketika kita mengklik tombol itu tampak seolah-olah tidak ada yang terjadi: </p><br><p><img src="https://habrastorage.org/webt/ou/xm/mh/ouxmmh4qaybwgmg3pezne9ocwwo.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">ColorfulTileState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; ColorfulTileState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTileState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTile</span></span></span><span class="hljs-class">&gt; </span></span>{ Color myColor; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.initState(); myColor = UniqueColorGenerator.getColor(); } <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding( padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>), )); } }</code> </pre> <br><p>  Sebagai penjelasan: kode di atas bermasalah karena tidak menunjukkan pertukaran warna saat pengguna mengklik tombol.  Untuk memperbaiki kesalahan ini, Anda perlu menambahkan parameter <code>key</code> ke widget <code>StatefulWidget</code> berwarna, dan kemudian widget akan ditukar seperti yang kita inginkan: </p><br><p><img src="https://habrastorage.org/webt/se/zh/am/sezham9ms7u158mzemvce1wwlhu.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(key: UniqueKey()), <span class="hljs-comment"><span class="hljs-comment">// Keys added here StatefulColorfulTile(key: UniqueKey()), ]; ... class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); // NEW CONSTRUCTOR @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Tetapi ini hanya diperlukan jika Anda memiliki widget dengan status di subtree yang sedang Anda ubah.  Jika seluruh subtree widget dalam koleksi Anda tidak memiliki status, tidak diperlukan tombol. <br>  Itu dia!  Semua dalam semua, semua yang perlu Anda ketahui untuk menggunakan <code>keys</code> di <code>Flutter</code> .  Tetapi jika Anda ingin sedikit lebih dalam tentang apa yang terjadi ... </p><br><hr><br><h2 id="razbiraemsya-pochemu-keys-inogda-neobhodimy">  Memahami mengapa <code>keys</code> terkadang diperlukan </h2><br><p>  Kamu masih di sini, kan?  Kalau begitu datanglah lebih dekat untuk mengetahui sifat sebenarnya dari elemen tree dan widget untuk menjadi Flutter Mage!  Wahahaha!  Haha  Haha  Um, maaf. </p><br><p>  Seperti yang Anda ketahui, di dalam setiap widget Flutter membangun elemen yang sesuai.  Sama seperti Flutter membangun pohon widget, itu juga membuat pohon elemen (ElementTree).  ElementTree sangat sederhana, hanya berisi informasi jenis setiap widget dan tautan ke elemen anak.  Anda dapat menganggap ElementTree sebagai kerangka aplikasi Flutter Anda.  Ini menunjukkan struktur aplikasi Anda, tetapi semua informasi tambahan dapat ditemukan pada tautan ke widget sumber. </p><br><p>  Widget baris pada contoh di atas berisi satu set slot yang dipesan untuk masing-masing anak-anaknya.  Ketika kami menyusun ulang widget warna di Row, Flutter berjalan di sekitar ElementTree untuk memeriksa apakah struktur kerangka aplikasi itu sama. </p><br><p><img src="https://habrastorage.org/webt/ha/dh/vy/hadhvybi_mhjvuwdiiucmmx2w6i.gif"></p><br><p>  Validasi dimulai dengan RowElement, dan kemudian beralih ke anak-anak.  ElementTree memeriksa apakah widget baru memiliki jenis dan <code>key</code> sama dengan yang lama, dan jika ya, elemen memperbarui tautannya ke widget baru.  Dalam versi tanpa kode, widget tidak memiliki <code>key</code> , jadi Flutter hanya memeriksa jenisnya saja.  (Jika ada terlalu banyak informasi pada suatu waktu, maka lihat bagan animasi di atas.) </p><br><p>  Di bawah ElementTree untuk widget keadaan terlihat sedikit berbeda.  Ada widget dan elemen, seperti sebelumnya, tetapi ada juga beberapa objek keadaan untuk widget, dan informasi warna disimpan di dalamnya, dan bukan di widget itu sendiri. </p><br><p><img src="https://habrastorage.org/webt/dh/ay/sh/dhayshomjpkfv7b45fxmx1ecduw.gif"></p><br><p>  Dalam kasus widget <code>StatefulWidget</code> berwarna tanpa <code>key</code> , ketika saya mengubah urutan dua widget, Flutter berkeliling ElementTree, memeriksa jenis RowWidget dan memperbarui tautan.  Kemudian elemen widget warna memeriksa apakah widget yang sesuai memiliki tipe yang sama dan memperbarui tautannya.  Hal yang sama terjadi dengan widget kedua.  Karena Flutter menggunakan ElementTree dan status terkait untuk menentukan apa yang sebenarnya ditampilkan pada perangkat Anda, dari sudut pandang kami, tampaknya widget belum ditukar! </p><br><p><img src="https://habrastorage.org/webt/nu/yw/ah/nuywahtbnrv2bfvrwb0osfj1fye.gif"></p><br><p>  Dalam versi kode yang diperbaiki dalam widget berwarna dengan status konstruktor, saya mendefinisikan properti <code>key</code> .  Sekarang, jika kita mengubah widget di <code>Row</code> , maka dengan mengetiknya mereka akan cocok seperti sebelumnya, tetapi nilai <code>key</code> widget warna dan elemen yang sesuai di ElementTree akan berbeda.  Ini menyebabkan Flutter menonaktifkan elemen widget warna ini dan menghapus tautannya di ElementTree, mulai dari yang pertama, yang tidak cocok dengan <code>key</code> . </p><br><p><img src="https://habrastorage.org/webt/iz/vw/os/izvwos_wwqsng-afywi2az2shsu.gif"></p><br><p>  Kemudian Flutter mencari widget di elemen <code>Row</code> di ElementTree dengan <code>key</code> sesuai.  Jika cocok, itu menambahkan tautan ke elemen widget.  Flutter tidak untuk setiap anak tanpa tautan.  Sekarang Flutter akan menampilkan apa yang kita harapkan, widget warna akan berubah tempat ketika saya mengklik tombol. </p><br><p>  Dengan demikian, <code>keys</code> berguna jika Anda mengubah urutan atau jumlah widget dengan status dalam koleksi.  Dalam contoh ini, saya menyimpan warnanya.  Namun, seringkali kondisinya tidak begitu jelas.  Memutar animasi, menampilkan input pengguna, dan menggulir lokasi - semuanya memiliki status. </p><br><hr><br><h2 id="kogda-mne-ispolzovat-keys">  Kapan saya harus menggunakan <code>keys</code> ? </h2><br><p>  Jawaban singkat: jika Anda perlu menambahkan <code>keys</code> ke aplikasi, Anda harus menambahkannya di bagian atas subtree widget dengan status yang ingin Anda simpan. </p><br><p>  Kesalahan umum yang saya lihat adalah orang berpikir bahwa mereka perlu mendefinisikan <code>key</code> hanya untuk widget pertama dengan status, tetapi ada nuansa.  Jangan percaya padaku?  Untuk menunjukkan masalah yang kita hadapi, saya membungkus widget warna saya di widget <code>Padding</code> , sambil meninggalkan tombol untuk widget warna. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Stateful tiles now wrapped in padding (a stateless widget) to increase height // of widget tree and show why keys are needed at the Padding level. List&lt;Widget&gt; tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Sekarang, dengan satu sentuhan tombol, widget mendapatkan warna yang benar-benar acak! </p><br><p><img src="https://habrastorage.org/webt/w2/ge/lb/w2gelbrnaw_hlvftimjhe-vhhim.gif"></p><br><p>  Beginilah tampilan pohon widget dan ElementTree dengan widget <code>Padding</code> ditambahkan: </p><br><p><img src="https://habrastorage.org/webt/k-/br/0o/k-br0o5hmbvzwvjodwemswze0na.jpeg"></p><br><p>  Saat kami mengubah posisi widget anak, algoritme pencocokan antara elemen dan widget terlihat satu tingkat di hierarki elemen.  Dalam diagram, anak-anak anak-anak digelapkan sehingga tidak ada yang mengalihkan perhatian dari tingkat pertama.  Pada level ini, semuanya cocok dengan benar. </p><br><p><img src="https://habrastorage.org/webt/j6/tt/zp/j6ttzpgzdbpupkzqw4s1vlsyz6g.gif"></p><br><p>  Pada tingkat kedua, Flutter memperhatikan bahwa <code>key</code> elemen warna tidak cocok dengan <code>key</code> widget, jadi ini menonaktifkan elemen ini, membuangnya dan menghapus semua tautan ke sana.  <code>keys</code> kami gunakan dalam contoh ini adalah <code>LocalKeys</code> .  Ini berarti bahwa ketika mencocokkan widget dengan elemen, Flutter mencari <code>keys</code> hanya pada tingkat pohon tertentu. </p><br><p>  Karena dia tidak dapat menemukan elemen widget warna pada level ini dengan tombol yang sesuai, dia membuat yang baru dan menginisialisasi keadaan baru, membuat widget berwarna oranye dalam hal ini! </p><br><p><img src="https://habrastorage.org/webt/2q/mn/xk/2qmnxkwb7xpxtyi3jgbefvg70mi.gif"></p><br><p>  Jika kami menetapkan <code>keys</code> untuk widget <code>Padding</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ Padding( <span class="hljs-comment"><span class="hljs-comment">// Place the keys at the *top* of the tree of the items in the collection. key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Flutter memperhatikan masalah dan memperbarui tautan dengan benar, seperti pada contoh sebelumnya.  Urutan di alam semesta dipulihkan. </p><br><p><img src="https://habrastorage.org/webt/xp/4w/h0/xp4wh0wpzgd-5wxtxdkwu3jogps.gif"></p><br><hr><br><h2 id="kakoy-tip-key-mne-sleduet-ispolzovat">  Jenis <code>Key</code> harus saya gunakan? </h2><br><p>  Flutter API memberi kami pilihan beberapa kelas <code>Key</code> .  Jenis <code>key</code> yang harus Anda gunakan tergantung pada fitur apa yang membedakan elemen yang membutuhkan <code>keys</code> .  Lihatlah informasi yang Anda simpan di masing-masing widget. </p><br><p>  Pertimbangkan aplikasi Agenda berikut [1], di mana Anda dapat mengubah urutan item dalam daftar tugas berdasarkan prioritas, dan ketika selesai, Anda dapat menghapusnya. </p><br><p><img src="https://habrastorage.org/webt/nz/qb/8g/nzqb8g-8ywgycp0g_xe-6p7-xk0.gif"></p><br><p>  <strong>ValueKey</strong> <br>  Dalam hal ini, kita dapat berharap bahwa teks paragraf implementasi akan bersifat permanen dan unik.  Jika demikian, maka ini mungkin kandidat yang baik untuk <code>ValueKey</code> , di mana teksnya adalah "nilai". </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction) =&gt; _removeTodo(context, todo), );</code> </pre> <br><p>  <strong>Objectkey</strong> <br>  Atau, Anda mungkin memiliki aplikasi Buku Alamat, yang mencantumkan informasi tentang setiap pengguna.  Dalam hal ini, setiap widget anak menyimpan kombinasi data yang lebih kompleks.  Setiap bidang individual, misalnya, nama atau tanggal lahir, mungkin bertepatan dengan entri lain, tetapi kombinasinya unik.  Dalam hal ini, <code>ObjectKey</code> kemungkinan besar paling cocok. </p><br><p><img src="https://habrastorage.org/webt/jk/jz/av/jkjzavsw7v74t_dnnmb79mvukd0.png"></p><br><p>  <strong>Uniquekey</strong> <br>  Jika Anda memiliki beberapa widget dalam koleksi dengan nilai yang sama atau jika Anda ingin memastikan bahwa setiap widget berbeda dari yang lain, maka Anda dapat menggunakan <code>UniqueKey</code> .  Saya menggunakan <code>UniqueKey</code> dalam contoh aplikasi untuk beralih warna, karena kami tidak memiliki data konstan lain yang akan disimpan dalam widget kami, dan kami tidak tahu apa warna widget yang akan dimiliki ketika itu dibuat. </p><br><p>  Namun, satu hal <strong>yang tidak ingin Anda</strong> gunakan sebagai <code>key</code> adalah angka acak.  Setiap kali widget dibuat, nomor acak baru akan dihasilkan dan Anda akan kehilangan konsistensi antara frame.  Dalam skenario ini, Anda tidak boleh menggunakan <code>keys</code> sama sekali! </p><br><p>  <strong>PageStorageKeys</strong> <br>  <code>PageStorageKeys</code> adalah <code>keys</code> khusus yang berisi keadaan gulir saat ini sehingga aplikasi dapat menyimpannya untuk digunakan nanti. </p><br><p><img src="https://habrastorage.org/webt/dx/db/if/dxdbif6yn7hlszee_-hbzbaevn8.gif"></p><br><p>  <strong>Globalkey</strong> <br>  Ada dua opsi untuk menggunakan <code>GlobalKeys</code> : mereka memungkinkan widget untuk mengubah orang tua di mana saja dalam aplikasi tanpa kehilangan status dan dapat digunakan untuk mengakses informasi tentang widget lain di bagian pohon widget yang sama sekali berbeda.  Sebagai contoh skenario pertama, Anda dapat membayangkan bahwa Anda ingin menampilkan widget yang sama di dua layar berbeda, tetapi dengan status yang sama, agar data widget disimpan, Anda akan menggunakan <code>GlobalKey</code> .  Dalam kasus kedua, situasi mungkin muncul ketika Anda perlu memeriksa kata sandi, tetapi Anda tidak ingin berbagi informasi status dengan widget lain di pohon.  <code>GlobalKeys</code> juga dapat berguna untuk pengujian, menggunakan <code>key</code> untuk mengakses widget tertentu dan meminta informasi tentang statusnya. </p><br><p><img src="https://habrastorage.org/webt/eh/rq/bl/ehrqble5pcoeqrh7ktl0j0_dm5s.gif"></p><br><p>  Seringkali (tetapi tidak selalu!) <code>GlobalKeys</code> sedikit seperti variabel global.  Seringkali mereka dapat diganti dengan <code>InheritedWidgets</code> atau sesuatu seperti Redux, atau template BLoC. </p><br><hr><br><h2 id="kratkoe-zaklyuchenie">  Kesimpulan singkat </h2><br><p>  Secara umum, gunakan <code>Keys</code> jika Anda ingin mempertahankan status di antara subtree widget.  Ini paling sering terjadi ketika mengubah koleksi widget dari jenis yang sama.  Tempatkan <code>key</code> di bagian atas subtree widget yang ingin Anda simpan, dan pilih jenis <code>key</code> berdasarkan data yang disimpan dalam widget. </p><br><p>  Selamat, Anda sekarang berada di jalan untuk menjadi Flutter Mage!  Oh, aku bilang pesulap?  Maksud saya pesulap, seperti orang yang menulis kode sumber aplikasi ... yang hampir sama bagusnya.  ... hampir. </p><br><p>  [1] Inspirasi untuk menulis kode aplikasi Agenda yang diterima di sini <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla</a> <br>  [2] Penulis menggunakan kata <code>sorcerer</code> dan kemudian menambahkan surat tambahan untuknya sebelum <code>sourcerer</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446050/">https://habr.com/ru/post/id446050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446038/index.html">Panduan singkat tentang membuat nubuat, dewa mobil dan kesalahan orde kedua</a></li>
<li><a href="../id446040/index.html">Pengakuan Penuh Stack: Profesi, Agama, Mimpi</a></li>
<li><a href="../id446042/index.html">DJI Mavic 2 Pro setelah enam bulan digunakan</a></li>
<li><a href="../id446046/index.html">Perluasan alam semesta adalah kesalahan terbesar dalam sejarah sains</a></li>
<li><a href="../id446048/index.html">Persatuan Arduino dan prosesor klasik</a></li>
<li><a href="../id446052/index.html">Menciptakan suara & nada produk Anda</a></li>
<li><a href="../id446054/index.html">Siap cadangan: menghancurkan mitos liburan</a></li>
<li><a href="../id446056/index.html">Cara Sederhana untuk Berbicara di Situs Web Anda</a></li>
<li><a href="../id446058/index.html">Cara Membangun SDN - Delapan Alat Sumber Terbuka</a></li>
<li><a href="../id446060/index.html">Sintesis mimpi molekul tinggi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>