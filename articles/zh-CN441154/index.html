<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴 🤲🏾 😥 Java 11的十一颗隐藏的珍珠 👍🏽 ◼️ 🏝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 11没有引入任何创新功能，但是它包含了一些您可能还没有听说过的瑰宝。 已经查看过String ， Optional ， Collection和其他主要功能中的最新功能？ 如果没有，那么您来了：今天，我们将看一下Java 11中的11个隐藏的宝石！ 
 Lambda参数的类型推断 


 在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java 11的十一颗隐藏的珍珠</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441154/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java 11</a>没有引入任何创新功能，但是它包含了一些您可能还没有听说过的瑰宝。 已经查看过<code>String</code> ， <code>Optional</code> ， <code>Collection</code>和其他主要功能中的最新功能？ 如果没有，那么您来了：今天，我们将看一下Java 11中的11个隐藏的宝石！ </p><a name="habracut"></a><br><h3 id="vyvod-tipov-dlya-lyambda-parametrov">  Lambda参数的类型推断 </h3><br><p> 在编写lambda表达式时，可以在显式指定类型和跳过它们之间进行选择： </p><br><pre> <code class="java hljs">Function&lt;String, String&gt; append = string -&gt; string + <span class="hljs-string"><span class="hljs-string">" "</span></span>; Function&lt;String, String&gt; append = (String s) -&gt; s + <span class="hljs-string"><span class="hljs-string">" "</span></span>;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java 10引入了</a> <code>var</code> ，但是不能在lambdas中使用： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Java 10 Function&lt;String, String&gt; append = (var string) -&gt; string + " ";</span></span></code> </pre> <br><p> 在Java 11中已经可以实现。 但是为什么呢？ 看起来<code>var</code>提供的不仅仅是类型传递。 尽管是这种情况，但使用<code>var</code>有两个次要优点： </p><br><ul><li> 通过删除规则的异常，使使用<code>var</code>更通用 </li><li> 允许您向参数类型添加注释，而无需使用其全名 </li></ul><br><p> 这是第二种情况的示例： </p><br><pre> <code class="java hljs">List&lt;EnterpriseGradeType&lt;With, Generics&gt;&gt; types = <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>; types .stream() <span class="hljs-comment"><span class="hljs-comment">// ,     @Nonnull   .filter(type -&gt; check(type)) //  Java 10    ~&gt;  .filter((@Nonnull EnterpriseGradeType&lt;With, Generics&gt; type) -&gt; check(type)) //  Java 11    ~&gt;   .filter((@Nonnull var type) -&gt; check(type))</span></span></code> </pre> <br><p> 尽管可以在形式为<code>(var type, String option, index) -&gt; ...</code> lambda表达式中混合派生的显式和隐式类型，但是（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在JEP-323框架中</a> ）这项工作没有执行。 因此，有必要选择三种方法之一，并对lambda表达式的所有参数都坚持使用。 需要为所有参数指定<code>var</code>以便为其中一个参数添加注释可能会有些烦人，但通常是可以忍受的。 </p><br><h3 id="potokovaya-obrabotka-strok-s-stringlines"> 使用<code>'String::lines'</code>对字符串进行流处理 </h3><br><p> 有多行字符串？ 想要对每一行做点什么？ 那么<code>String::lines</code>是正确的选择： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiline = <span class="hljs-string"><span class="hljs-string">"\r\n\r\n\r\n"</span></span>; multiline .lines() <span class="hljs-comment"><span class="hljs-comment">//Stream&lt;String&gt; .map(line -&gt; "// " + line) .forEach(System.out::println); // : //  //  //  // </span></span></code> </pre> <br><p> 请注意，原始行使用<code>\r\n</code>螺丝定界符，尽管我在Linux上，但<code>lines()</code>仍然将其破坏。 这是由于以下事实：尽管使用了当前的操作系统，该方法仍将<code>\r</code> ， <code>\n</code>和<code>\r\n</code>为换行符-即使它们混在同一行中。 </p><br><p> 行流永远不会包含行分隔符本身。 行可以为空（ <code>"\n\n \n\n"</code> ，其中包含5行），但是如果原始行的最后一行为空，则忽略该行（ <code>"\n\n"</code> ; <code>"\n\n"</code> ; 2行）。  <em>（译者注：他们有<code>line</code> ，但是有<code>string</code> ，我们都很方便。）</em> </p><br><p> 不同于<code>split("\R")</code> ，各<code>lines()</code>惰性的， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我引用</a> “通过更快地搜索新的换行符来提供更好的性能”。  （如果有人想在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JMH上发布</a>基准进行验证，请告诉我）。 它还可以更好地反映处理算法，并使用更方便的数据结构（流而不是数组）。 </p><br><h3 id="udalenie-probelnyh-simvolov-s-stringstrip-i-tp"> 用<code>'String::strip'</code>等删除空格 </h3><br><p> 最初， <code>String</code>有一个<code>trim</code>方法来删除空格，这被认为是所有代码不超过<code>U+0020</code> 。 是的， <code>BACKSPACE</code> （ <code>U+0008)</code>是一个类似于<code>BELL</code> （ <code>U+0007</code> ）的空白，但是不再将<code>LINE SEPARATOR</code> （ <code>U+2028</code> ）视为空格。 </p><br><p>  Java 11引入了<code>strip</code>方法，该方法具有更多细微差别。 它使用Java 5中的<code>Character::isWhitespace</code>来确定确切需要删除的内容。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从其文档中</a>可以明显看出： </p><br><ul><li>  <code>SPACE SEPARATOR</code> ， <code>LINE SEPARATOR</code> ，参数<code>PARAGRAPH SEPARATOR</code> ，但不是不可分割的空间 </li><li>  <code>HORIZONTAL TABULATION</code> （ <code>U+0009</code> ）， <code>U+000A</code> <code>LINE FEED</code> （ <code>U+000A</code> ）， <code>VERTICAL TABULATION</code> （ <code>U+000B</code> ）， <code>FORM FEED</code> （ <code>U+000C</code> ）， <code>CARRIAGE RETURN</code> （ <code>U+000D</code> ） </li><li>  <code>FILE SEPARATOR</code> <code>U+001E</code> （ <code>U+001C</code> ）， <code>GROUP SEPARATOR</code> <code>U+001E</code> （ <code>U+001D</code> ）， <code>RECORD SEPARATOR</code> <code>U+001E</code> （ <code>U+001E</code> ）， <code>UNIT SEPARATOR</code> <code>U+001E</code> （ <code>U+001F</code> ） </li></ul><br><p> 按照相同的逻辑，还有另外两种清洁方法， <code>stripLeading</code>和<code>stripTailing</code> ，它们完全可以完成对它们的期望。 </p><br><p> 最后，如果您只需要找出删除空格后该行是否为空，则无需真正删除它们-只需使用<code>isBlank</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">" "</span></span>.isBlank(); <span class="hljs-comment"><span class="hljs-comment">//  ~&gt; true " ".isBlank(); //   ~&gt; false</span></span></code> </pre> <br><h3 id="povtorenie-strok-s-stringrepeat"> 用<code>'String::repeat'</code>重复字符串 </h3><br><p> 抓住主意： </p><br><h6 id="shag-1-pristalno-sledim-za-razvitiem-jdk"> 步骤1：监视JDK </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/874/8df/a06/8748dfa06086f57aae4b16686d9c6c04.png" alt="密切关注JDK开发"></p><br><h6 id="shag-2-razyskivaem-na-stackoverflow-svyazannye-voprosy"> 步骤2：查找与StackOverflow相关的问题 </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df2/3f8/7ae/df23f87ae8d723f53beb5617017de913.png" alt="寻找有关Stackoverflow的相关问题"></p><br><h6 id="shag-3-priletaem-s-novym-otvetom-osnovannym-na-buduschih-izmeneniyah"> 步骤3：根据未来的变化得出新的答案 </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b68/556/748/b685567487db2b1ea3cab180b8f39089.png" alt="根据即将发生的变化提供新答案"></p><br><h6 id="shag-4-"> 步骤4：???? </h6><br><h6 id="shag-4-profit"> 步骤4：获利 </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/695/015/36969501570588225baae6cd5dd3edb1.gif" alt="¯\ _（ツ）_ /¯"></p><br><p> 可以想象， <code>String</code>有一个新的<code>repeat(int)</code>方法。 它的工作完全符合期望，因此几乎没有讨论。 </p><br><h3 id="sozdanie-putey-s-pathof"> 使用<code>'Path::of'</code>创建路径 </h3><br><p> 我真的很喜欢<code>Path</code> API，但是在不同视图之间转换路径（例如<code>Path</code> ， <code>File</code> ， <code>URL</code> ， <code>URI</code>和<code>String</code> ）仍然很烦人。 通过将两个<code>Paths::get</code>方法复制<code>Paths::get</code>方法的<code>Path::of</code>这一点在Java 11中变得不再那么混乱了： </p><br><pre> <code class="java hljs">Path tmp = Path.of(<span class="hljs-string"><span class="hljs-string">"/home/nipa"</span></span>, <span class="hljs-string"><span class="hljs-string">"tmp"</span></span>); Path codefx = Path.of(URI.create(<span class="hljs-string"><span class="hljs-string">"http://codefx.org"</span></span>));</code> </pre> <br><p> 它们可以被认为是规范的，因为两个旧的<code>Paths::get</code>方法都使用新选项。 </p><br><h3 id="chtenie-i-zapis-faylov-s-filesreadstring-i-fileswritestring"> 使用<code>'Files::readString'</code>和<code>'Files::writeString'</code>读写文件 </h3><br><p> 如果需要读取大文件，通常会使用<code>Files::lines</code>来获取其行的惰性流。 类似地，要写入可能无法完全存储在内存中的大量数据，我使用<code>Files::write</code>作为<code>Iterable&lt;String&gt;</code>传递它们。 </p><br><p> 但是，当我想将文件内容作为一行处理时，这种简单情况又如何呢？ 这不是很方便，因为<code>Files::readAllBytes</code>和<code>Files::write</code>的相应变体在字节数组上运行。 </p><br><p> 然后出现Java 11，将<code>readString</code>和<code>writeString</code>添加到<code>Files</code> ： </p><br><pre> <code class="java hljs">String haiku = Files.readString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku.txt"</span></span>)); String modified = modify(haiku); Files.writeString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku-mod.txt"</span></span>), modified);</code> </pre> <br><p> 清晰易用。 如有必要，可以将<code>Charset</code>传递给<code>readString</code> ，在<code>writeString</code>还<code>OpenOptions</code>一个<code>OpenOptions</code>数组。 </p><br><h3 id="pustoe-io-s-readernullreader-i-tp"> 使用<code>'Reader::nullReader'</code>等来清空I / O。 </h3><br><p> 需要一个不会在任何地方写的<code>OutputStream</code>吗？ 还是一个空的<code>InputStream</code> ？ 什么都不做的<code>Reader</code>和<code>Writer</code>呢？  Java 11拥有全部： </p><br><pre> <code class="java hljs">InputStream input = InputStream.nullInputStream(); OutputStream output = OutputStream.nullOutputStream(); Reader reader = Reader.nullReader(); Writer writer = Writer.nullWriter();</code> </pre> <br><p>  <em>（译者注：在<code>commons-io</code>这些类自2014年左右就已经存在。）</em> </p><br><p> 但是，我很惊讶<code>null</code>真的是最好的前缀吗？ 我不喜欢用它来表示“故意缺席”……也许最好使用<code>noOp</code> ？  <em>（译者注：由于<code>/dev/null</code>的常用用法，因此很可能选择了此前缀。）</em> </p><br><h3 id="-----s-collectiontoarray">  <code>{ } ~&gt; [ ]</code>与<code>'Collection::toArray'</code> </h3><br><p> 如何将集合转换为数组？ </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Java 11 List&lt;String&gt; list = /*...*/; Object[] objects = list.toArray(); String[] strings_0 = list.toArray(new String[0]); String[] strings_size = list.toArray(new String[list.size()]);</span></span></code> </pre> <br><p> 第一个选项<code>objects</code>会丢失有关类型的所有信息，因此它正在运行中。 其余的呢？ 两者都很笨重，但第一个较短。 后者创建了所需大小的数组，因此看起来效率更高（也就是说，“似乎效率更高”，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信誉</a> ）。 但这真的更有生产力吗？  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不，相反，它</a> （现在） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较慢</a> 。 </p><br><p> 但是我为什么要在乎呢？ 有没有更好的方法可以做到这一点？ 在Java 11中有： </p><br><pre> <code class="java hljs">String[] strings_fun = list.toArray(String[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre> <br><p>  <code>Collection::toArray</code>了<code>Collection::toArray</code>新变体，它接受<code>IntFunction&lt;T[]&gt;</code> ，即 接收数组大小并返回所需大小的数组的函数。 它可以简短地表示为对<code>T[]::new</code>形式的构造函数的引用（对于著名的<code>T</code> ）。 </p><br><p> 有趣的是， <code>Collection#toArray(IntFunction&lt;T[]&gt;)</code>的默认实现始终将<code>0</code>传递给数组生成器。 最初，我认为此解决方案基于零长度数组的最佳性能，但现在我认为原因可能是对于某些集合而言，计算大小可能是一项非常昂贵的操作，并且您不应该在<code>Collection</code>的默认实现中使用此方法。 但是，特定的集合实现（例如<code>ArrayList</code> ）可以更改此方法，但是在Java 11中不会更改。 我猜这不值得。 </p><br><h3 id="proverka-otsutstviya-s-optionalisempty"> 使用<code>'Optional::isEmpty'</code>缺席检查 </h3><br><p> 随着<code>Optional</code>的大量使用，尤其是在大型项目中，您经常会遇到非<code>Optional</code>方法，因此您通常必须检查它是否有价值。  <code>Optional::isPresent</code>有一个<code>Optional::isPresent</code>方法。 但是，您经常需要了解相反的情况<code>Optional</code>空。 没问题，只需使用<code>!opt.isPresent()</code>吧？ </p><br><p> 当然，可以这样做，但是<code>if</code>条件没有反转，则几乎总是更容易理解<code>if</code>逻辑。 有时，在一连串的通话结束时会弹出<code>Optional</code> ，如果您不需要检查任何内容，则必须下注<code>!</code> 在开始时： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isPresent(); }</code> </pre> <br><p> 在这种情况下，请跳过<code>!</code> 非常容易 从Java 11开始，有一个更好的选择： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isEmpty(); }</code> </pre> <br><h3 id="invertirovanie-predikatov-s-predicatenot"> 用<code>'Predicate::not'</code>反转谓词 </h3><br><p> 说到反转... <code>Predicate</code>接口具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个</a> <code>negate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实例</a> <code>negate</code> ：它返回一个新的谓词，该谓词执行相同的检查，但是将其结果反转。 不幸的是，我很少设法使用它... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Stream .of("a", "b", "", "c") // ,  ~&gt;        .filter(s -&gt; !s.isBlank()) //          ~&gt;  .filter((String::isBlank).negate()) // ,  ~&gt;       .filter(((Predicate&lt;String&gt;) String::isBlank).negate()) .forEach(System.out::println);</span></span></code> </pre> <br><p> 问题是我很少访问<code>Predicate</code>实例。 更常见的是，我想通过方法的链接来获得这样的实例（并将其反转），但是要使其正常工作，编译器必须知道将对该方法的引用带到何处-没有它，它什么也做不了。 如果您使用<code>(String::isBlank).negate()</code> ，这就是发生的情况：编译器不再知道应在此<code>String::isBlank</code>什么。 正确指定的种姓可以解决此问题，但要付出什么代价？ </p><br><p> 虽然有一个简单的解决方案。 不要使用<code>negate</code>实例<code>negate</code> ，而要使用Java 11中的新静态方法<code>Predicate.not(Predicate&lt;T&gt;)</code> ： </p><br><pre> <code class="java hljs">Stream .of(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   `java.util.function.Predicate.not` .filter(not(String::isBlank)) .forEach(System.out::println);</span></span></code> </pre> <br><p> 已经更好了！ </p><br><h3 id="regulyarnye-vyrazheniya-kak-predikat-s-patternasmatchpredicate"> 以<code>'Pattern::asMatchPredicate'</code>作为谓词的正则表达式 </h3><br><p> 有正则表达式吗？ 需要过滤数据吗？ 怎么样： </p><br><pre> <code class="java hljs">Pattern nonWordCharacter = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"\\W"</span></span>); Stream .of(<span class="hljs-string"><span class="hljs-string">"Metallica"</span></span>, <span class="hljs-string"><span class="hljs-string">"Motörhead"</span></span>) .filter(nonWordCharacter.asPredicate()) .forEach(System.out::println);</code> </pre> <br><p> 我很高兴找到这种方法！ 值得补充的是，这是Java 8中的一种方法。糟糕，我当时错过了它。  Java 11添加了另一个类似的方法： <code>Pattern::asMatchPredicate</code> 。 有什么区别？ </p><br><ul><li>  <code>asPredicate</code>检查字符串<strong>或</strong>字符串的<strong>一部分是否</strong>与模式匹配（类似于<code>s -&gt; this.matcher(s).find()</code> ） </li><li>  <code>asMatchPredicate</code>检查<strong>整个字符串是否</strong>与模式匹配（类似于<code>s -&gt; this.matcher(s).matches()</code> ） </li></ul><br><p> 例如，我们有一个检查电话号码的正则表达式，但是它不包含<code>^</code>和<code>$</code>来跟踪行的开头和结尾。 然后，以下代码将无法正常运行： </p><br><pre> <code class="java hljs">prospectivePhoneNumbers .stream() .filter(phoneNumberPatter.asPredicate()) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::robocall);</code> </pre> <br><p> 你有没有发现错误？ 诸如<code>" -152 ? +1-202-456-1414"</code>行将被过滤，因为其中包含有效的电话号码。 另一方面， <code>Pattern::asMatchPredicate</code>将不允许这样做，因为<strong>整个</strong>字符串<strong>将不再</strong>与模式匹配。 </p><br><h3 id="samoproverka"> 自检 </h3><br><p> 这是所有11颗珍珠的概述-您还记得每种方法的作用吗？ 如果是这样，则说明您已通过测试。 </p><br><ul><li> 在<code>String</code> ： <br><ul><li> <code>Stream&lt;String&gt; lines()</code> </li> <li> <code>String strip()</code> </li> <li> <code>String stripLeading()</code> </li> <li> <code>String stripTrailing()</code> </li> <li> <code>boolean isBlank()</code> </li> <li> <code>String repeat(int)</code> </li> </ul></li><li> 在<code>Path</code> ： <br><ul><li> <code>static Path of(String, String...)</code> </li> <li> <code>static Path of(URI)</code> </li> </ul></li><li> 在<code>Files</code> ： <br><ul><li> <code>String readString(Path) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, OpenOption...) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, Charset, OpenOption...) throws IOException</code> </li> </ul></li><li> 在<code>InputStream</code> ： <code>static InputStream nullInputStream()</code> </li><li> 在<code>OutputStream</code> ： <code>static OutputStream nullOutputStream()</code> </li><li> 在<code>Reader</code> ： <code>static Reader nullReader()</code> </li><li> 在<code>Writer</code> ： <code>static Writer nullWriter()</code> </li><li>  in <code>Collection</code> ： <code>T[] toArray(IntFunction&lt;T[]&gt;)</code> </li><li> 在<code>Optional</code> ： <code>boolean isEmpty()</code> </li><li> 在<code>Predicate</code> ： <code>static Predicate&lt;T&gt; not(Predicate&lt;T&gt;)</code> </li><li> 在<code>Pattern</code> ： <code>Predicate&lt;String&gt; asMatchPredicate()</code> </li></ul><br><p> 玩Java 11！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441154/">https://habr.com/ru/post/zh-CN441154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441142/index.html">转化增长或真正销售的内容有12点</a></li>
<li><a href="../zh-CN441146/index.html">工业无线网络：选择哪个？</a></li>
<li><a href="../zh-CN441148/index.html">如何正确处理错误：沉默并不总是好事</a></li>
<li><a href="../zh-CN441150/index.html">通过编写最简单的Java Web服务器首次介绍HTTP协议</a></li>
<li><a href="../zh-CN441152/index.html">与外部服务集成时如何最大程度地减少错误：在线经纪人的经验</a></li>
<li><a href="../zh-CN441158/index.html">伦理如何成为最昂贵的硅谷问题，而哲学如何成为其最实际的解决方案</a></li>
<li><a href="../zh-CN441160/index.html">如何学习确定何时说不</a></li>
<li><a href="../zh-CN441166/index.html">我们从锁定的密码管理器中获取主密码1密码4</a></li>
<li><a href="../zh-CN441168/index.html">QUIC数据通道：第一步</a></li>
<li><a href="../zh-CN441172/index.html">2018年3D打印市场如何增长以及对业务意味着什么</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>